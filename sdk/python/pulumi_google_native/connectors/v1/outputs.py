# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AuditConfigResponse',
    'AuditLogConfigResponse',
    'AuthConfigResponse',
    'AuthorizationCodeLinkResponse',
    'BindingResponse',
    'ConfigVariableResponse',
    'ConfigVariableTemplateResponse',
    'ConnectionStatusResponse',
    'ConnectorVersionInfraConfigResponse',
    'ConnectorsLogConfigResponse',
    'DeadLetterConfigResponse',
    'DestinationConfigResponse',
    'DestinationResponse',
    'EncryptionKeyResponse',
    'EndPointResponse',
    'EnumOptionResponse',
    'EventSubscriptionDestinationResponse',
    'EventSubscriptionStatusResponse',
    'EventingConfigResponse',
    'EventingRuntimeDataResponse',
    'EventingStatusResponse',
    'ExprResponse',
    'FieldComparisonResponse',
    'HPAConfigResponse',
    'HeaderResponse',
    'JMSResponse',
    'JwtClaimsResponse',
    'LockConfigResponse',
    'LogicalExpressionResponse',
    'NodeConfigResponse',
    'Oauth2AuthCodeFlowResponse',
    'Oauth2ClientCredentialsResponse',
    'Oauth2JwtBearerResponse',
    'ResourceLimitsResponse',
    'ResourceRequestsResponse',
    'ResourceResponse',
    'RoleGrantResponse',
    'SecretResponse',
    'SshPublicKeyResponse',
    'SslConfigResponse',
    'UserPasswordResponse',
    'WebhookDataResponse',
]

@pulumi.output_type
class AuditConfigResponse(dict):
    """
    Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditLogConfigs":
            suggest = "audit_log_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_log_configs: Sequence['outputs.AuditLogConfigResponse'],
                 service: str):
        """
        Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
        :param Sequence['AuditLogConfigResponse'] audit_log_configs: The configuration for logging of each type of permission.
        :param str service: Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
        """
        pulumi.set(__self__, "audit_log_configs", audit_log_configs)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="auditLogConfigs")
    def audit_log_configs(self) -> Sequence['outputs.AuditLogConfigResponse']:
        """
        The configuration for logging of each type of permission.
        """
        return pulumi.get(self, "audit_log_configs")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class AuditLogConfigResponse(dict):
    """
    Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exemptedMembers":
            suggest = "exempted_members"
        elif key == "logType":
            suggest = "log_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditLogConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditLogConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditLogConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exempted_members: Sequence[str],
                 log_type: str):
        """
        Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
        :param Sequence[str] exempted_members: Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
        :param str log_type: The log type that this config enables.
        """
        pulumi.set(__self__, "exempted_members", exempted_members)
        pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="exemptedMembers")
    def exempted_members(self) -> Sequence[str]:
        """
        Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
        """
        return pulumi.get(self, "exempted_members")

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> str:
        """
        The log type that this config enables.
        """
        return pulumi.get(self, "log_type")


@pulumi.output_type
class AuthConfigResponse(dict):
    """
    AuthConfig defines details of a authentication type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalVariables":
            suggest = "additional_variables"
        elif key == "authKey":
            suggest = "auth_key"
        elif key == "authType":
            suggest = "auth_type"
        elif key == "oauth2AuthCodeFlow":
            suggest = "oauth2_auth_code_flow"
        elif key == "oauth2ClientCredentials":
            suggest = "oauth2_client_credentials"
        elif key == "oauth2JwtBearer":
            suggest = "oauth2_jwt_bearer"
        elif key == "sshPublicKey":
            suggest = "ssh_public_key"
        elif key == "userPassword":
            suggest = "user_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_variables: Sequence['outputs.ConfigVariableResponse'],
                 auth_key: str,
                 auth_type: str,
                 oauth2_auth_code_flow: 'outputs.Oauth2AuthCodeFlowResponse',
                 oauth2_client_credentials: 'outputs.Oauth2ClientCredentialsResponse',
                 oauth2_jwt_bearer: 'outputs.Oauth2JwtBearerResponse',
                 ssh_public_key: 'outputs.SshPublicKeyResponse',
                 user_password: 'outputs.UserPasswordResponse'):
        """
        AuthConfig defines details of a authentication type.
        :param Sequence['ConfigVariableResponse'] additional_variables: List containing additional auth configs.
        :param str auth_key: Identifier key for auth config
        :param str auth_type: The type of authentication configured.
        :param 'Oauth2AuthCodeFlowResponse' oauth2_auth_code_flow: Oauth2AuthCodeFlow.
        :param 'Oauth2ClientCredentialsResponse' oauth2_client_credentials: Oauth2ClientCredentials.
        :param 'Oauth2JwtBearerResponse' oauth2_jwt_bearer: Oauth2JwtBearer.
        :param 'SshPublicKeyResponse' ssh_public_key: SSH Public Key.
        :param 'UserPasswordResponse' user_password: UserPassword.
        """
        pulumi.set(__self__, "additional_variables", additional_variables)
        pulumi.set(__self__, "auth_key", auth_key)
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "oauth2_auth_code_flow", oauth2_auth_code_flow)
        pulumi.set(__self__, "oauth2_client_credentials", oauth2_client_credentials)
        pulumi.set(__self__, "oauth2_jwt_bearer", oauth2_jwt_bearer)
        pulumi.set(__self__, "ssh_public_key", ssh_public_key)
        pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="additionalVariables")
    def additional_variables(self) -> Sequence['outputs.ConfigVariableResponse']:
        """
        List containing additional auth configs.
        """
        return pulumi.get(self, "additional_variables")

    @property
    @pulumi.getter(name="authKey")
    def auth_key(self) -> str:
        """
        Identifier key for auth config
        """
        return pulumi.get(self, "auth_key")

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        """
        The type of authentication configured.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="oauth2AuthCodeFlow")
    def oauth2_auth_code_flow(self) -> 'outputs.Oauth2AuthCodeFlowResponse':
        """
        Oauth2AuthCodeFlow.
        """
        return pulumi.get(self, "oauth2_auth_code_flow")

    @property
    @pulumi.getter(name="oauth2ClientCredentials")
    def oauth2_client_credentials(self) -> 'outputs.Oauth2ClientCredentialsResponse':
        """
        Oauth2ClientCredentials.
        """
        return pulumi.get(self, "oauth2_client_credentials")

    @property
    @pulumi.getter(name="oauth2JwtBearer")
    def oauth2_jwt_bearer(self) -> 'outputs.Oauth2JwtBearerResponse':
        """
        Oauth2JwtBearer.
        """
        return pulumi.get(self, "oauth2_jwt_bearer")

    @property
    @pulumi.getter(name="sshPublicKey")
    def ssh_public_key(self) -> 'outputs.SshPublicKeyResponse':
        """
        SSH Public Key.
        """
        return pulumi.get(self, "ssh_public_key")

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> 'outputs.UserPasswordResponse':
        """
        UserPassword.
        """
        return pulumi.get(self, "user_password")


@pulumi.output_type
class AuthorizationCodeLinkResponse(dict):
    """
    This configuration captures the details required to render an authorization link for the OAuth Authorization Code Flow.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "enablePkce":
            suggest = "enable_pkce"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizationCodeLinkResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizationCodeLinkResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizationCodeLinkResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 enable_pkce: bool,
                 scopes: Sequence[str],
                 uri: str):
        """
        This configuration captures the details required to render an authorization link for the OAuth Authorization Code Flow.
        :param str client_id: The client ID assigned to the Google Cloud Connectors OAuth app for the connector data source.
        :param bool enable_pkce: Whether to enable PKCE for the auth code flow.
        :param Sequence[str] scopes: The scopes for which the user will authorize Google Cloud Connectors on the connector data source.
        :param str uri: The base URI the user must click to trigger the authorization code login flow.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "enable_pkce", enable_pkce)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID assigned to the Google Cloud Connectors OAuth app for the connector data source.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="enablePkce")
    def enable_pkce(self) -> bool:
        """
        Whether to enable PKCE for the auth code flow.
        """
        return pulumi.get(self, "enable_pkce")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        The scopes for which the user will authorize Google Cloud Connectors on the connector data source.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The base URI the user must click to trigger the authorization code login flow.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class BindingResponse(dict):
    """
    Associates `members`, or principals, with a `role`.
    """
    def __init__(__self__, *,
                 condition: 'outputs.ExprResponse',
                 members: Sequence[str],
                 role: str):
        """
        Associates `members`, or principals, with a `role`.
        :param 'ExprResponse' condition: The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        :param Sequence[str] members: Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workforce identity pool. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`: All workforce identities in a group. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All workforce identities with a specific attribute value. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/*`: All identities in a workforce identity pool. * `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workload identity pool. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`: A workload identity pool group. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All identities in a workload identity pool with a certain attribute. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/*`: All identities in a workload identity pool. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: Deleted single identity in a workforce identity pool. For example, `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
        :param str role: Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`. For an overview of the IAM roles and permissions, see the [IAM documentation](https://cloud.google.com/iam/docs/roles-overview). For a list of the available pre-defined roles, see [here](https://cloud.google.com/iam/docs/understanding-roles).
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.ExprResponse':
        """
        The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def members(self) -> Sequence[str]:
        """
        Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workforce identity pool. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`: All workforce identities in a group. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All workforce identities with a specific attribute value. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/*`: All identities in a workforce identity pool. * `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workload identity pool. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`: A workload identity pool group. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All identities in a workload identity pool with a certain attribute. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/*`: All identities in a workload identity pool. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: Deleted single identity in a workforce identity pool. For example, `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
        """
        return pulumi.get(self, "members")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`. For an overview of the IAM roles and permissions, see the [IAM documentation](https://cloud.google.com/iam/docs/roles-overview). For a list of the available pre-defined roles, see [here](https://cloud.google.com/iam/docs/understanding-roles).
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class ConfigVariableResponse(dict):
    """
    ConfigVariable represents a configuration variable present in a Connection. or AuthConfig.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boolValue":
            suggest = "bool_value"
        elif key == "encryptionKeyValue":
            suggest = "encryption_key_value"
        elif key == "intValue":
            suggest = "int_value"
        elif key == "secretValue":
            suggest = "secret_value"
        elif key == "stringValue":
            suggest = "string_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigVariableResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigVariableResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigVariableResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bool_value: bool,
                 encryption_key_value: 'outputs.EncryptionKeyResponse',
                 int_value: str,
                 key: str,
                 secret_value: 'outputs.SecretResponse',
                 string_value: str):
        """
        ConfigVariable represents a configuration variable present in a Connection. or AuthConfig.
        :param bool bool_value: Value is a bool.
        :param 'EncryptionKeyResponse' encryption_key_value: Value is a Encryption Key.
        :param str int_value: Value is an integer
        :param str key: Key of the config variable.
        :param 'SecretResponse' secret_value: Value is a secret.
        :param str string_value: Value is a string.
        """
        pulumi.set(__self__, "bool_value", bool_value)
        pulumi.set(__self__, "encryption_key_value", encryption_key_value)
        pulumi.set(__self__, "int_value", int_value)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_value", secret_value)
        pulumi.set(__self__, "string_value", string_value)

    @property
    @pulumi.getter(name="boolValue")
    def bool_value(self) -> bool:
        """
        Value is a bool.
        """
        return pulumi.get(self, "bool_value")

    @property
    @pulumi.getter(name="encryptionKeyValue")
    def encryption_key_value(self) -> 'outputs.EncryptionKeyResponse':
        """
        Value is a Encryption Key.
        """
        return pulumi.get(self, "encryption_key_value")

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> str:
        """
        Value is an integer
        """
        return pulumi.get(self, "int_value")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of the config variable.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> 'outputs.SecretResponse':
        """
        Value is a secret.
        """
        return pulumi.get(self, "secret_value")

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> str:
        """
        Value is a string.
        """
        return pulumi.get(self, "string_value")


@pulumi.output_type
class ConfigVariableTemplateResponse(dict):
    """
    ConfigVariableTemplate provides metadata about a `ConfigVariable` that is used in a Connection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationCodeLink":
            suggest = "authorization_code_link"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "enumOptions":
            suggest = "enum_options"
        elif key == "enumSource":
            suggest = "enum_source"
        elif key == "isAdvanced":
            suggest = "is_advanced"
        elif key == "locationType":
            suggest = "location_type"
        elif key == "requiredCondition":
            suggest = "required_condition"
        elif key == "roleGrant":
            suggest = "role_grant"
        elif key == "validationRegex":
            suggest = "validation_regex"
        elif key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigVariableTemplateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigVariableTemplateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigVariableTemplateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_code_link: 'outputs.AuthorizationCodeLinkResponse',
                 description: str,
                 display_name: str,
                 enum_options: Sequence['outputs.EnumOptionResponse'],
                 enum_source: str,
                 is_advanced: bool,
                 key: str,
                 location_type: str,
                 required: bool,
                 required_condition: 'outputs.LogicalExpressionResponse',
                 role_grant: 'outputs.RoleGrantResponse',
                 state: str,
                 validation_regex: str,
                 value_type: str):
        """
        ConfigVariableTemplate provides metadata about a `ConfigVariable` that is used in a Connection.
        :param 'AuthorizationCodeLinkResponse' authorization_code_link: Authorization code link options. To be populated if `ValueType` is `AUTHORIZATION_CODE`
        :param str description: Description.
        :param str display_name: Display name of the parameter.
        :param Sequence['EnumOptionResponse'] enum_options: Enum options. To be populated if `ValueType` is `ENUM`
        :param str enum_source: Optional. enum source denotes the source of api to fill the enum options
        :param bool is_advanced: Indicates if current template is part of advanced settings
        :param str key: Key of the config variable.
        :param str location_type: Optional. Location Tyep denotes where this value should be sent in BYOC connections.
        :param bool required: Flag represents that this `ConfigVariable` must be provided for a connection.
        :param 'LogicalExpressionResponse' required_condition: Condition under which a field would be required. The condition can be represented in the form of a logical expression.
        :param 'RoleGrantResponse' role_grant: Role grant configuration for the config variable.
        :param str state: State of the config variable.
        :param str validation_regex: Regular expression in RE2 syntax used for validating the `value` of a `ConfigVariable`.
        :param str value_type: Type of the parameter: string, int, bool etc. consider custom type for the benefit for the validation.
        """
        pulumi.set(__self__, "authorization_code_link", authorization_code_link)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "enum_options", enum_options)
        pulumi.set(__self__, "enum_source", enum_source)
        pulumi.set(__self__, "is_advanced", is_advanced)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "required_condition", required_condition)
        pulumi.set(__self__, "role_grant", role_grant)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "validation_regex", validation_regex)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter(name="authorizationCodeLink")
    def authorization_code_link(self) -> 'outputs.AuthorizationCodeLinkResponse':
        """
        Authorization code link options. To be populated if `ValueType` is `AUTHORIZATION_CODE`
        """
        return pulumi.get(self, "authorization_code_link")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="enumOptions")
    def enum_options(self) -> Sequence['outputs.EnumOptionResponse']:
        """
        Enum options. To be populated if `ValueType` is `ENUM`
        """
        return pulumi.get(self, "enum_options")

    @property
    @pulumi.getter(name="enumSource")
    def enum_source(self) -> str:
        """
        Optional. enum source denotes the source of api to fill the enum options
        """
        return pulumi.get(self, "enum_source")

    @property
    @pulumi.getter(name="isAdvanced")
    def is_advanced(self) -> bool:
        """
        Indicates if current template is part of advanced settings
        """
        return pulumi.get(self, "is_advanced")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of the config variable.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="locationType")
    def location_type(self) -> str:
        """
        Optional. Location Tyep denotes where this value should be sent in BYOC connections.
        """
        return pulumi.get(self, "location_type")

    @property
    @pulumi.getter
    def required(self) -> bool:
        """
        Flag represents that this `ConfigVariable` must be provided for a connection.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter(name="requiredCondition")
    def required_condition(self) -> 'outputs.LogicalExpressionResponse':
        """
        Condition under which a field would be required. The condition can be represented in the form of a logical expression.
        """
        return pulumi.get(self, "required_condition")

    @property
    @pulumi.getter(name="roleGrant")
    def role_grant(self) -> 'outputs.RoleGrantResponse':
        """
        Role grant configuration for the config variable.
        """
        return pulumi.get(self, "role_grant")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State of the config variable.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="validationRegex")
    def validation_regex(self) -> str:
        """
        Regular expression in RE2 syntax used for validating the `value` of a `ConfigVariable`.
        """
        return pulumi.get(self, "validation_regex")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        Type of the parameter: string, int, bool etc. consider custom type for the benefit for the validation.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class ConnectionStatusResponse(dict):
    """
    ConnectionStatus indicates the state of the connection.
    """
    def __init__(__self__, *,
                 description: str,
                 state: str,
                 status: str):
        """
        ConnectionStatus indicates the state of the connection.
        :param str description: Description.
        :param str state: State.
        :param str status: Status provides detailed information for the state.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status provides detailed information for the state.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ConnectorVersionInfraConfigResponse(dict):
    """
    This cofiguration provides infra configs like rate limit threshold which need to be configurable for every connector version
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionRatelimitWindowSeconds":
            suggest = "connection_ratelimit_window_seconds"
        elif key == "deploymentModel":
            suggest = "deployment_model"
        elif key == "hpaConfig":
            suggest = "hpa_config"
        elif key == "internalclientRatelimitThreshold":
            suggest = "internalclient_ratelimit_threshold"
        elif key == "ratelimitThreshold":
            suggest = "ratelimit_threshold"
        elif key == "resourceLimits":
            suggest = "resource_limits"
        elif key == "resourceRequests":
            suggest = "resource_requests"
        elif key == "sharedDeployment":
            suggest = "shared_deployment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorVersionInfraConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorVersionInfraConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorVersionInfraConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_ratelimit_window_seconds: str,
                 deployment_model: str,
                 hpa_config: 'outputs.HPAConfigResponse',
                 internalclient_ratelimit_threshold: str,
                 ratelimit_threshold: str,
                 resource_limits: 'outputs.ResourceLimitsResponse',
                 resource_requests: 'outputs.ResourceRequestsResponse',
                 shared_deployment: str):
        """
        This cofiguration provides infra configs like rate limit threshold which need to be configurable for every connector version
        :param str connection_ratelimit_window_seconds: The window used for ratelimiting runtime requests to connections.
        :param str deployment_model: Optional. Indicates whether connector is deployed on GKE/CloudRun
        :param 'HPAConfigResponse' hpa_config: HPA autoscaling config.
        :param str internalclient_ratelimit_threshold: Max QPS supported for internal requests originating from Connd.
        :param str ratelimit_threshold: Max QPS supported by the connector version before throttling of requests.
        :param 'ResourceLimitsResponse' resource_limits: System resource limits.
        :param 'ResourceRequestsResponse' resource_requests: System resource requests.
        :param str shared_deployment: The name of shared connector deployment.
        """
        pulumi.set(__self__, "connection_ratelimit_window_seconds", connection_ratelimit_window_seconds)
        pulumi.set(__self__, "deployment_model", deployment_model)
        pulumi.set(__self__, "hpa_config", hpa_config)
        pulumi.set(__self__, "internalclient_ratelimit_threshold", internalclient_ratelimit_threshold)
        pulumi.set(__self__, "ratelimit_threshold", ratelimit_threshold)
        pulumi.set(__self__, "resource_limits", resource_limits)
        pulumi.set(__self__, "resource_requests", resource_requests)
        pulumi.set(__self__, "shared_deployment", shared_deployment)

    @property
    @pulumi.getter(name="connectionRatelimitWindowSeconds")
    def connection_ratelimit_window_seconds(self) -> str:
        """
        The window used for ratelimiting runtime requests to connections.
        """
        return pulumi.get(self, "connection_ratelimit_window_seconds")

    @property
    @pulumi.getter(name="deploymentModel")
    def deployment_model(self) -> str:
        """
        Optional. Indicates whether connector is deployed on GKE/CloudRun
        """
        return pulumi.get(self, "deployment_model")

    @property
    @pulumi.getter(name="hpaConfig")
    def hpa_config(self) -> 'outputs.HPAConfigResponse':
        """
        HPA autoscaling config.
        """
        return pulumi.get(self, "hpa_config")

    @property
    @pulumi.getter(name="internalclientRatelimitThreshold")
    def internalclient_ratelimit_threshold(self) -> str:
        """
        Max QPS supported for internal requests originating from Connd.
        """
        return pulumi.get(self, "internalclient_ratelimit_threshold")

    @property
    @pulumi.getter(name="ratelimitThreshold")
    def ratelimit_threshold(self) -> str:
        """
        Max QPS supported by the connector version before throttling of requests.
        """
        return pulumi.get(self, "ratelimit_threshold")

    @property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> 'outputs.ResourceLimitsResponse':
        """
        System resource limits.
        """
        return pulumi.get(self, "resource_limits")

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> 'outputs.ResourceRequestsResponse':
        """
        System resource requests.
        """
        return pulumi.get(self, "resource_requests")

    @property
    @pulumi.getter(name="sharedDeployment")
    def shared_deployment(self) -> str:
        """
        The name of shared connector deployment.
        """
        return pulumi.get(self, "shared_deployment")


@pulumi.output_type
class ConnectorsLogConfigResponse(dict):
    """
    Log configuration for the connection.
    """
    def __init__(__self__, *,
                 enabled: bool):
        """
        Log configuration for the connection.
        :param bool enabled: Enabled represents whether logging is enabled or not for a connection.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enabled represents whether logging is enabled or not for a connection.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DeadLetterConfigResponse(dict):
    """
    Dead Letter configuration details provided by the user.
    """
    def __init__(__self__, *,
                 project: str,
                 topic: str):
        """
        Dead Letter configuration details provided by the user.
        :param str project: Optional. Project which has the topic given.
        :param str topic: Optional. Topic to push events which couldn't be processed.
        """
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        Optional. Project which has the topic given.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def topic(self) -> str:
        """
        Optional. Topic to push events which couldn't be processed.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class DestinationConfigResponse(dict):
    """
    Define the Connectors target endpoint.
    """
    def __init__(__self__, *,
                 destinations: Sequence['outputs.DestinationResponse'],
                 key: str):
        """
        Define the Connectors target endpoint.
        :param Sequence['DestinationResponse'] destinations: The destinations for the key.
        :param str key: The key is the destination identifier that is supported by the Connector.
        """
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def destinations(self) -> Sequence['outputs.DestinationResponse']:
        """
        The destinations for the key.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key is the destination identifier that is supported by the Connector.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class DestinationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAttachment":
            suggest = "service_attachment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 port: int,
                 service_attachment: str):
        """
        :param str host: For publicly routable host.
        :param int port: The port is the target port number that is accepted by the destination.
        :param str service_attachment: PSC service attachments. Format: projects/*/regions/*/serviceAttachments/*
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "service_attachment", service_attachment)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        For publicly routable host.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port is the target port number that is accepted by the destination.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serviceAttachment")
    def service_attachment(self) -> str:
        """
        PSC service attachments. Format: projects/*/regions/*/serviceAttachments/*
        """
        return pulumi.get(self, "service_attachment")


@pulumi.output_type
class EncryptionKeyResponse(dict):
    """
    Encryption Key value.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyName":
            suggest = "kms_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_name: str,
                 type: str):
        """
        Encryption Key value.
        :param str kms_key_name: The [KMS key name] with which the content of the Operation is encrypted. The expected format: `projects/*/locations/*/keyRings/*/cryptoKeys/*`. Will be empty string if google managed.
        :param str type: Type.
        """
        pulumi.set(__self__, "kms_key_name", kms_key_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> str:
        """
        The [KMS key name] with which the content of the Operation is encrypted. The expected format: `projects/*/locations/*/keyRings/*/cryptoKeys/*`. Will be empty string if google managed.
        """
        return pulumi.get(self, "kms_key_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EndPointResponse(dict):
    """
    Endpoint message includes details of the Destination endpoint.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointUri":
            suggest = "endpoint_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndPointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndPointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndPointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_uri: str,
                 headers: Sequence['outputs.HeaderResponse']):
        """
        Endpoint message includes details of the Destination endpoint.
        :param str endpoint_uri: The URI of the Endpoint.
        :param Sequence['HeaderResponse'] headers: List of Header to be added to the Endpoint.
        """
        pulumi.set(__self__, "endpoint_uri", endpoint_uri)
        pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter(name="endpointUri")
    def endpoint_uri(self) -> str:
        """
        The URI of the Endpoint.
        """
        return pulumi.get(self, "endpoint_uri")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.HeaderResponse']:
        """
        List of Header to be added to the Endpoint.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class EnumOptionResponse(dict):
    """
    EnumOption definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnumOptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnumOptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnumOptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: str):
        """
        EnumOption definition
        :param str display_name: Display name of the option.
        """
        pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Display name of the option.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class EventSubscriptionDestinationResponse(dict):
    """
    Message for EventSubscription Destination to act on receiving an event
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSubscriptionDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSubscriptionDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSubscriptionDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: 'outputs.EndPointResponse',
                 service_account: str,
                 type: str):
        """
        Message for EventSubscription Destination to act on receiving an event
        :param 'EndPointResponse' endpoint: OPTION 1: Hit an endpoint when we receive an event.
        :param str service_account: Service account needed for runtime plane to trigger IP workflow.
        :param str type: type of the destination
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "service_account", service_account)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def endpoint(self) -> 'outputs.EndPointResponse':
        """
        OPTION 1: Hit an endpoint when we receive an event.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> str:
        """
        Service account needed for runtime plane to trigger IP workflow.
        """
        return pulumi.get(self, "service_account")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of the destination
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EventSubscriptionStatusResponse(dict):
    """
    EventSubscription Status denotes the status of the EventSubscription resource.
    """
    def __init__(__self__, *,
                 description: str,
                 state: str):
        """
        EventSubscription Status denotes the status of the EventSubscription resource.
        :param str description: Description of the state.
        :param str state: State of Event Subscription resource.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the state.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State of Event Subscription resource.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class EventingConfigResponse(dict):
    """
    Eventing Configuration of a connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalVariables":
            suggest = "additional_variables"
        elif key == "authConfig":
            suggest = "auth_config"
        elif key == "deadLetterConfig":
            suggest = "dead_letter_config"
        elif key == "enrichmentEnabled":
            suggest = "enrichment_enabled"
        elif key == "eventsListenerIngressEndpoint":
            suggest = "events_listener_ingress_endpoint"
        elif key == "listenerAuthConfig":
            suggest = "listener_auth_config"
        elif key == "privateConnectivityEnabled":
            suggest = "private_connectivity_enabled"
        elif key == "proxyDestinationConfig":
            suggest = "proxy_destination_config"
        elif key == "registrationDestinationConfig":
            suggest = "registration_destination_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventingConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventingConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventingConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_variables: Sequence['outputs.ConfigVariableResponse'],
                 auth_config: 'outputs.AuthConfigResponse',
                 dead_letter_config: 'outputs.DeadLetterConfigResponse',
                 enrichment_enabled: bool,
                 events_listener_ingress_endpoint: str,
                 listener_auth_config: 'outputs.AuthConfigResponse',
                 private_connectivity_enabled: bool,
                 proxy_destination_config: 'outputs.DestinationConfigResponse',
                 registration_destination_config: 'outputs.DestinationConfigResponse'):
        """
        Eventing Configuration of a connection
        :param Sequence['ConfigVariableResponse'] additional_variables: Additional eventing related field values
        :param 'AuthConfigResponse' auth_config: Auth details for the webhook adapter.
        :param 'DeadLetterConfigResponse' dead_letter_config: Optional. Dead letter configuration for eventing of a connection.
        :param bool enrichment_enabled: Enrichment Enabled.
        :param str events_listener_ingress_endpoint: Optional. Ingress endpoint of the event listener. This is used only when private connectivity is enabled.
        :param 'AuthConfigResponse' listener_auth_config: Optional. Auth details for the event listener.
        :param bool private_connectivity_enabled: Optional. Private Connectivity Enabled.
        :param 'DestinationConfigResponse' proxy_destination_config: Optional. Proxy for Eventing auto-registration.
        :param 'DestinationConfigResponse' registration_destination_config: Registration endpoint for auto registration.
        """
        pulumi.set(__self__, "additional_variables", additional_variables)
        pulumi.set(__self__, "auth_config", auth_config)
        pulumi.set(__self__, "dead_letter_config", dead_letter_config)
        pulumi.set(__self__, "enrichment_enabled", enrichment_enabled)
        pulumi.set(__self__, "events_listener_ingress_endpoint", events_listener_ingress_endpoint)
        pulumi.set(__self__, "listener_auth_config", listener_auth_config)
        pulumi.set(__self__, "private_connectivity_enabled", private_connectivity_enabled)
        pulumi.set(__self__, "proxy_destination_config", proxy_destination_config)
        pulumi.set(__self__, "registration_destination_config", registration_destination_config)

    @property
    @pulumi.getter(name="additionalVariables")
    def additional_variables(self) -> Sequence['outputs.ConfigVariableResponse']:
        """
        Additional eventing related field values
        """
        return pulumi.get(self, "additional_variables")

    @property
    @pulumi.getter(name="authConfig")
    def auth_config(self) -> 'outputs.AuthConfigResponse':
        """
        Auth details for the webhook adapter.
        """
        return pulumi.get(self, "auth_config")

    @property
    @pulumi.getter(name="deadLetterConfig")
    def dead_letter_config(self) -> 'outputs.DeadLetterConfigResponse':
        """
        Optional. Dead letter configuration for eventing of a connection.
        """
        return pulumi.get(self, "dead_letter_config")

    @property
    @pulumi.getter(name="enrichmentEnabled")
    def enrichment_enabled(self) -> bool:
        """
        Enrichment Enabled.
        """
        return pulumi.get(self, "enrichment_enabled")

    @property
    @pulumi.getter(name="eventsListenerIngressEndpoint")
    def events_listener_ingress_endpoint(self) -> str:
        """
        Optional. Ingress endpoint of the event listener. This is used only when private connectivity is enabled.
        """
        return pulumi.get(self, "events_listener_ingress_endpoint")

    @property
    @pulumi.getter(name="listenerAuthConfig")
    def listener_auth_config(self) -> 'outputs.AuthConfigResponse':
        """
        Optional. Auth details for the event listener.
        """
        return pulumi.get(self, "listener_auth_config")

    @property
    @pulumi.getter(name="privateConnectivityEnabled")
    def private_connectivity_enabled(self) -> bool:
        """
        Optional. Private Connectivity Enabled.
        """
        return pulumi.get(self, "private_connectivity_enabled")

    @property
    @pulumi.getter(name="proxyDestinationConfig")
    def proxy_destination_config(self) -> 'outputs.DestinationConfigResponse':
        """
        Optional. Proxy for Eventing auto-registration.
        """
        return pulumi.get(self, "proxy_destination_config")

    @property
    @pulumi.getter(name="registrationDestinationConfig")
    def registration_destination_config(self) -> 'outputs.DestinationConfigResponse':
        """
        Registration endpoint for auto registration.
        """
        return pulumi.get(self, "registration_destination_config")


@pulumi.output_type
class EventingRuntimeDataResponse(dict):
    """
    Eventing runtime data has the details related to eventing managed by the system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventsListenerEndpoint":
            suggest = "events_listener_endpoint"
        elif key == "eventsListenerPscSa":
            suggest = "events_listener_psc_sa"
        elif key == "webhookData":
            suggest = "webhook_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventingRuntimeDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventingRuntimeDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventingRuntimeDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 events_listener_endpoint: str,
                 events_listener_psc_sa: str,
                 status: 'outputs.EventingStatusResponse',
                 webhook_data: 'outputs.WebhookDataResponse'):
        """
        Eventing runtime data has the details related to eventing managed by the system.
        :param str events_listener_endpoint: Events listener endpoint. The value will populated after provisioning the events listener.
        :param str events_listener_psc_sa: Events listener PSC Service attachment. The value will be populated after provisioning the events listener with private connectivity enabled.
        :param 'EventingStatusResponse' status: Current status of eventing.
        :param 'WebhookDataResponse' webhook_data: Webhook data.
        """
        pulumi.set(__self__, "events_listener_endpoint", events_listener_endpoint)
        pulumi.set(__self__, "events_listener_psc_sa", events_listener_psc_sa)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "webhook_data", webhook_data)

    @property
    @pulumi.getter(name="eventsListenerEndpoint")
    def events_listener_endpoint(self) -> str:
        """
        Events listener endpoint. The value will populated after provisioning the events listener.
        """
        return pulumi.get(self, "events_listener_endpoint")

    @property
    @pulumi.getter(name="eventsListenerPscSa")
    def events_listener_psc_sa(self) -> str:
        """
        Events listener PSC Service attachment. The value will be populated after provisioning the events listener with private connectivity enabled.
        """
        return pulumi.get(self, "events_listener_psc_sa")

    @property
    @pulumi.getter
    def status(self) -> 'outputs.EventingStatusResponse':
        """
        Current status of eventing.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="webhookData")
    def webhook_data(self) -> 'outputs.WebhookDataResponse':
        """
        Webhook data.
        """
        return pulumi.get(self, "webhook_data")


@pulumi.output_type
class EventingStatusResponse(dict):
    """
    EventingStatus indicates the state of eventing.
    """
    def __init__(__self__, *,
                 description: str,
                 state: str):
        """
        EventingStatus indicates the state of eventing.
        :param str description: Description of error if State is set to "ERROR".
        :param str state: State.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of error if State is set to "ERROR".
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ExprResponse(dict):
    """
    Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
    """
    def __init__(__self__, *,
                 description: str,
                 expression: str,
                 location: str,
                 title: str):
        """
        Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
        :param str description: Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str location: Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        :param str title: Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class FieldComparisonResponse(dict):
    """
    Field that needs to be compared.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boolValue":
            suggest = "bool_value"
        elif key == "intValue":
            suggest = "int_value"
        elif key == "stringValue":
            suggest = "string_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FieldComparisonResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FieldComparisonResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FieldComparisonResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bool_value: bool,
                 comparator: str,
                 int_value: str,
                 key: str,
                 string_value: str):
        """
        Field that needs to be compared.
        :param bool bool_value: Boolean value
        :param str comparator: Comparator to use for comparing the field value.
        :param str int_value: Integer value
        :param str key: Key of the field.
        :param str string_value: String value
        """
        pulumi.set(__self__, "bool_value", bool_value)
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "int_value", int_value)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "string_value", string_value)

    @property
    @pulumi.getter(name="boolValue")
    def bool_value(self) -> bool:
        """
        Boolean value
        """
        return pulumi.get(self, "bool_value")

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        Comparator to use for comparing the field value.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> str:
        """
        Integer value
        """
        return pulumi.get(self, "int_value")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of the field.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> str:
        """
        String value
        """
        return pulumi.get(self, "string_value")


@pulumi.output_type
class HPAConfigResponse(dict):
    """
    Autoscaling config for connector deployment system metrics.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuUtilizationThreshold":
            suggest = "cpu_utilization_threshold"
        elif key == "memoryUtilizationThreshold":
            suggest = "memory_utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HPAConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HPAConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HPAConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_utilization_threshold: str,
                 memory_utilization_threshold: str):
        """
        Autoscaling config for connector deployment system metrics.
        :param str cpu_utilization_threshold: Percent CPU utilization where HPA triggers autoscaling.
        :param str memory_utilization_threshold: Percent Memory utilization where HPA triggers autoscaling.
        """
        pulumi.set(__self__, "cpu_utilization_threshold", cpu_utilization_threshold)
        pulumi.set(__self__, "memory_utilization_threshold", memory_utilization_threshold)

    @property
    @pulumi.getter(name="cpuUtilizationThreshold")
    def cpu_utilization_threshold(self) -> str:
        """
        Percent CPU utilization where HPA triggers autoscaling.
        """
        return pulumi.get(self, "cpu_utilization_threshold")

    @property
    @pulumi.getter(name="memoryUtilizationThreshold")
    def memory_utilization_threshold(self) -> str:
        """
        Percent Memory utilization where HPA triggers autoscaling.
        """
        return pulumi.get(self, "memory_utilization_threshold")


@pulumi.output_type
class HeaderResponse(dict):
    """
    Header details for a given header to be added to Endpoint.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        Header details for a given header to be added to Endpoint.
        :param str key: Key of Header.
        :param str value: Value of Header.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of Header.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of Header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class JMSResponse(dict):
    """
    JMS message denotes the source of the event
    """
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        JMS message denotes the source of the event
        :param str name: Optional. Name of the JMS source. i.e. queueName or topicName
        :param str type: Optional. Type of the JMS Source. i.e. Queue or Topic
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Optional. Name of the JMS source. i.e. queueName or topicName
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Optional. Type of the JMS Source. i.e. Queue or Topic
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class JwtClaimsResponse(dict):
    """
    JWT claims used for the jwt-bearer authorization grant.
    """
    def __init__(__self__, *,
                 audience: str,
                 issuer: str,
                 subject: str):
        """
        JWT claims used for the jwt-bearer authorization grant.
        :param str audience: Value for the "aud" claim.
        :param str issuer: Value for the "iss" claim.
        :param str subject: Value for the "sub" claim.
        """
        pulumi.set(__self__, "audience", audience)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def audience(self) -> str:
        """
        Value for the "aud" claim.
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        Value for the "iss" claim.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        Value for the "sub" claim.
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class LockConfigResponse(dict):
    """
    Determines whether or no a connection is locked. If locked, a reason must be specified.
    """
    def __init__(__self__, *,
                 locked: bool,
                 reason: str):
        """
        Determines whether or no a connection is locked. If locked, a reason must be specified.
        :param bool locked: Indicates whether or not the connection is locked.
        :param str reason: Describes why a connection is locked.
        """
        pulumi.set(__self__, "locked", locked)
        pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def locked(self) -> bool:
        """
        Indicates whether or not the connection is locked.
        """
        return pulumi.get(self, "locked")

    @property
    @pulumi.getter
    def reason(self) -> str:
        """
        Describes why a connection is locked.
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class LogicalExpressionResponse(dict):
    """
    Struct for representing boolean expressions.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldComparisons":
            suggest = "field_comparisons"
        elif key == "logicalExpressions":
            suggest = "logical_expressions"
        elif key == "logicalOperator":
            suggest = "logical_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogicalExpressionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogicalExpressionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogicalExpressionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_comparisons: Sequence['outputs.FieldComparisonResponse'],
                 logical_expressions: Sequence['outputs.LogicalExpressionResponse'],
                 logical_operator: str):
        """
        Struct for representing boolean expressions.
        :param Sequence['FieldComparisonResponse'] field_comparisons: A list of fields to be compared.
        :param Sequence['LogicalExpressionResponse'] logical_expressions: A list of nested conditions to be compared.
        :param str logical_operator: The logical operator to use between the fields and conditions.
        """
        pulumi.set(__self__, "field_comparisons", field_comparisons)
        pulumi.set(__self__, "logical_expressions", logical_expressions)
        pulumi.set(__self__, "logical_operator", logical_operator)

    @property
    @pulumi.getter(name="fieldComparisons")
    def field_comparisons(self) -> Sequence['outputs.FieldComparisonResponse']:
        """
        A list of fields to be compared.
        """
        return pulumi.get(self, "field_comparisons")

    @property
    @pulumi.getter(name="logicalExpressions")
    def logical_expressions(self) -> Sequence['outputs.LogicalExpressionResponse']:
        """
        A list of nested conditions to be compared.
        """
        return pulumi.get(self, "logical_expressions")

    @property
    @pulumi.getter(name="logicalOperator")
    def logical_operator(self) -> str:
        """
        The logical operator to use between the fields and conditions.
        """
        return pulumi.get(self, "logical_operator")


@pulumi.output_type
class NodeConfigResponse(dict):
    """
    Node configuration for the connection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxNodeCount":
            suggest = "max_node_count"
        elif key == "minNodeCount":
            suggest = "min_node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_node_count: int,
                 min_node_count: int):
        """
        Node configuration for the connection.
        :param int max_node_count: Maximum number of nodes in the runtime nodes.
        :param int min_node_count: Minimum number of nodes in the runtime nodes.
        """
        pulumi.set(__self__, "max_node_count", max_node_count)
        pulumi.set(__self__, "min_node_count", min_node_count)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> int:
        """
        Maximum number of nodes in the runtime nodes.
        """
        return pulumi.get(self, "max_node_count")

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> int:
        """
        Minimum number of nodes in the runtime nodes.
        """
        return pulumi.get(self, "min_node_count")


@pulumi.output_type
class Oauth2AuthCodeFlowResponse(dict):
    """
    Parameters to support Oauth 2.0 Auth Code Grant Authentication. See https://www.rfc-editor.org/rfc/rfc6749#section-1.3.1 for more details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authCode":
            suggest = "auth_code"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "enablePkce":
            suggest = "enable_pkce"
        elif key == "pkceVerifier":
            suggest = "pkce_verifier"
        elif key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Oauth2AuthCodeFlowResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Oauth2AuthCodeFlowResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Oauth2AuthCodeFlowResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_code: str,
                 auth_uri: str,
                 client_id: str,
                 client_secret: 'outputs.SecretResponse',
                 enable_pkce: bool,
                 pkce_verifier: str,
                 redirect_uri: str,
                 scopes: Sequence[str]):
        """
        Parameters to support Oauth 2.0 Auth Code Grant Authentication. See https://www.rfc-editor.org/rfc/rfc6749#section-1.3.1 for more details.
        :param str auth_code: Authorization code to be exchanged for access and refresh tokens.
        :param str auth_uri: Auth URL for Authorization Code Flow
        :param str client_id: Client ID for user-provided OAuth app.
        :param 'SecretResponse' client_secret: Client secret for user-provided OAuth app.
        :param bool enable_pkce: Whether to enable PKCE when the user performs the auth code flow.
        :param str pkce_verifier: PKCE verifier to be used during the auth code exchange.
        :param str redirect_uri: Redirect URI to be provided during the auth code exchange.
        :param Sequence[str] scopes: Scopes the connection will request when the user performs the auth code flow.
        """
        pulumi.set(__self__, "auth_code", auth_code)
        pulumi.set(__self__, "auth_uri", auth_uri)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "enable_pkce", enable_pkce)
        pulumi.set(__self__, "pkce_verifier", pkce_verifier)
        pulumi.set(__self__, "redirect_uri", redirect_uri)
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> str:
        """
        Authorization code to be exchanged for access and refresh tokens.
        """
        return pulumi.get(self, "auth_code")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> str:
        """
        Auth URL for Authorization Code Flow
        """
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID for user-provided OAuth app.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> 'outputs.SecretResponse':
        """
        Client secret for user-provided OAuth app.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="enablePkce")
    def enable_pkce(self) -> bool:
        """
        Whether to enable PKCE when the user performs the auth code flow.
        """
        return pulumi.get(self, "enable_pkce")

    @property
    @pulumi.getter(name="pkceVerifier")
    def pkce_verifier(self) -> str:
        """
        PKCE verifier to be used during the auth code exchange.
        """
        return pulumi.get(self, "pkce_verifier")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> str:
        """
        Redirect URI to be provided during the auth code exchange.
        """
        return pulumi.get(self, "redirect_uri")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        Scopes the connection will request when the user performs the auth code flow.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class Oauth2ClientCredentialsResponse(dict):
    """
    Parameters to support Oauth 2.0 Client Credentials Grant Authentication. See https://tools.ietf.org/html/rfc6749#section-1.3.4 for more details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Oauth2ClientCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Oauth2ClientCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Oauth2ClientCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: 'outputs.SecretResponse'):
        """
        Parameters to support Oauth 2.0 Client Credentials Grant Authentication. See https://tools.ietf.org/html/rfc6749#section-1.3.4 for more details.
        :param str client_id: The client identifier.
        :param 'SecretResponse' client_secret: Secret version reference containing the client secret.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client identifier.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> 'outputs.SecretResponse':
        """
        Secret version reference containing the client secret.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class Oauth2JwtBearerResponse(dict):
    """
    Parameters to support JSON Web Token (JWT) Profile for Oauth 2.0 Authorization Grant based authentication. See https://tools.ietf.org/html/rfc7523 for more details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientKey":
            suggest = "client_key"
        elif key == "jwtClaims":
            suggest = "jwt_claims"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Oauth2JwtBearerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Oauth2JwtBearerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Oauth2JwtBearerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_key: 'outputs.SecretResponse',
                 jwt_claims: 'outputs.JwtClaimsResponse'):
        """
        Parameters to support JSON Web Token (JWT) Profile for Oauth 2.0 Authorization Grant based authentication. See https://tools.ietf.org/html/rfc7523 for more details.
        :param 'SecretResponse' client_key: Secret version reference containing a PKCS#8 PEM-encoded private key associated with the Client Certificate. This private key will be used to sign JWTs used for the jwt-bearer authorization grant. Specified in the form as: `projects/*/secrets/*/versions/*`.
        :param 'JwtClaimsResponse' jwt_claims: JwtClaims providers fields to generate the token.
        """
        pulumi.set(__self__, "client_key", client_key)
        pulumi.set(__self__, "jwt_claims", jwt_claims)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> 'outputs.SecretResponse':
        """
        Secret version reference containing a PKCS#8 PEM-encoded private key associated with the Client Certificate. This private key will be used to sign JWTs used for the jwt-bearer authorization grant. Specified in the form as: `projects/*/secrets/*/versions/*`.
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="jwtClaims")
    def jwt_claims(self) -> 'outputs.JwtClaimsResponse':
        """
        JwtClaims providers fields to generate the token.
        """
        return pulumi.get(self, "jwt_claims")


@pulumi.output_type
class ResourceLimitsResponse(dict):
    """
    Resource limits defined for connection pods of a given connector type.
    """
    def __init__(__self__, *,
                 cpu: str,
                 memory: str):
        """
        Resource limits defined for connection pods of a given connector type.
        :param str cpu: CPU limit.
        :param str memory: Memory limit.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> str:
        """
        CPU limit.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def memory(self) -> str:
        """
        Memory limit.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ResourceRequestsResponse(dict):
    """
    Resource requests defined for connection pods of a given connector type.
    """
    def __init__(__self__, *,
                 cpu: str,
                 memory: str):
        """
        Resource requests defined for connection pods of a given connector type.
        :param str cpu: CPU request.
        :param str memory: Memory request.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> str:
        """
        CPU request.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def memory(self) -> str:
        """
        Memory request.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ResourceResponse(dict):
    """
    Resource definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathTemplate":
            suggest = "path_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path_template: str,
                 type: str):
        """
        Resource definition
        :param str path_template: Template to uniquely represent a Google Cloud resource in a format IAM expects This is a template that can have references to other values provided in the config variable template.
        :param str type: Different types of resource supported.
        """
        pulumi.set(__self__, "path_template", path_template)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="pathTemplate")
    def path_template(self) -> str:
        """
        Template to uniquely represent a Google Cloud resource in a format IAM expects This is a template that can have references to other values provided in the config variable template.
        """
        return pulumi.get(self, "path_template")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Different types of resource supported.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RoleGrantResponse(dict):
    """
    This configuration defines all the Cloud IAM roles that needs to be granted to a particular Google Cloud resource for the selected principal like service account. These configurations will let UI display to customers what IAM roles need to be granted by them. Or these configurations can be used by the UI to render a 'grant' button to do the same on behalf of the user.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "helperTextTemplate":
            suggest = "helper_text_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoleGrantResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoleGrantResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoleGrantResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 helper_text_template: str,
                 principal: str,
                 resource: 'outputs.ResourceResponse',
                 roles: Sequence[str]):
        """
        This configuration defines all the Cloud IAM roles that needs to be granted to a particular Google Cloud resource for the selected principal like service account. These configurations will let UI display to customers what IAM roles need to be granted by them. Or these configurations can be used by the UI to render a 'grant' button to do the same on behalf of the user.
        :param str helper_text_template: Template that UI can use to provide helper text to customers.
        :param str principal: Prinicipal/Identity for whom the role need to assigned.
        :param 'ResourceResponse' resource: Resource on which the roles needs to be granted for the principal.
        :param Sequence[str] roles: List of roles that need to be granted.
        """
        pulumi.set(__self__, "helper_text_template", helper_text_template)
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="helperTextTemplate")
    def helper_text_template(self) -> str:
        """
        Template that UI can use to provide helper text to customers.
        """
        return pulumi.get(self, "helper_text_template")

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        Prinicipal/Identity for whom the role need to assigned.
        """
        return pulumi.get(self, "principal")

    @property
    @pulumi.getter
    def resource(self) -> 'outputs.ResourceResponse':
        """
        Resource on which the roles needs to be granted for the principal.
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def roles(self) -> Sequence[str]:
        """
        List of roles that need to be granted.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class SecretResponse(dict):
    """
    Secret provides a reference to entries in Secret Manager.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretVersion":
            suggest = "secret_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_version: str):
        """
        Secret provides a reference to entries in Secret Manager.
        :param str secret_version: The resource name of the secret version in the format, format as: `projects/*/secrets/*/versions/*`.
        """
        pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> str:
        """
        The resource name of the secret version in the format, format as: `projects/*/secrets/*/versions/*`.
        """
        return pulumi.get(self, "secret_version")


@pulumi.output_type
class SshPublicKeyResponse(dict):
    """
    Parameters to support Ssh public key Authentication.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certType":
            suggest = "cert_type"
        elif key == "sshClientCert":
            suggest = "ssh_client_cert"
        elif key == "sshClientCertPass":
            suggest = "ssh_client_cert_pass"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SshPublicKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SshPublicKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SshPublicKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_type: str,
                 ssh_client_cert: 'outputs.SecretResponse',
                 ssh_client_cert_pass: 'outputs.SecretResponse',
                 username: str):
        """
        Parameters to support Ssh public key Authentication.
        :param str cert_type: Format of SSH Client cert.
        :param 'SecretResponse' ssh_client_cert: SSH Client Cert. It should contain both public and private key.
        :param 'SecretResponse' ssh_client_cert_pass: Password (passphrase) for ssh client certificate if it has one.
        :param str username: The user account used to authenticate.
        """
        pulumi.set(__self__, "cert_type", cert_type)
        pulumi.set(__self__, "ssh_client_cert", ssh_client_cert)
        pulumi.set(__self__, "ssh_client_cert_pass", ssh_client_cert_pass)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="certType")
    def cert_type(self) -> str:
        """
        Format of SSH Client cert.
        """
        return pulumi.get(self, "cert_type")

    @property
    @pulumi.getter(name="sshClientCert")
    def ssh_client_cert(self) -> 'outputs.SecretResponse':
        """
        SSH Client Cert. It should contain both public and private key.
        """
        return pulumi.get(self, "ssh_client_cert")

    @property
    @pulumi.getter(name="sshClientCertPass")
    def ssh_client_cert_pass(self) -> 'outputs.SecretResponse':
        """
        Password (passphrase) for ssh client certificate if it has one.
        """
        return pulumi.get(self, "ssh_client_cert_pass")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The user account used to authenticate.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SslConfigResponse(dict):
    """
    SSL Configuration of a connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalVariables":
            suggest = "additional_variables"
        elif key == "clientCertType":
            suggest = "client_cert_type"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientPrivateKey":
            suggest = "client_private_key"
        elif key == "clientPrivateKeyPass":
            suggest = "client_private_key_pass"
        elif key == "privateServerCertificate":
            suggest = "private_server_certificate"
        elif key == "serverCertType":
            suggest = "server_cert_type"
        elif key == "trustModel":
            suggest = "trust_model"
        elif key == "useSsl":
            suggest = "use_ssl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_variables: Sequence['outputs.ConfigVariableResponse'],
                 client_cert_type: str,
                 client_certificate: 'outputs.SecretResponse',
                 client_private_key: 'outputs.SecretResponse',
                 client_private_key_pass: 'outputs.SecretResponse',
                 private_server_certificate: 'outputs.SecretResponse',
                 server_cert_type: str,
                 trust_model: str,
                 type: str,
                 use_ssl: bool):
        """
        SSL Configuration of a connection
        :param Sequence['ConfigVariableResponse'] additional_variables: Additional SSL related field values
        :param str client_cert_type: Type of Client Cert (PEM/JKS/.. etc.)
        :param 'SecretResponse' client_certificate: Client Certificate
        :param 'SecretResponse' client_private_key: Client Private Key
        :param 'SecretResponse' client_private_key_pass: Secret containing the passphrase protecting the Client Private Key
        :param 'SecretResponse' private_server_certificate: Private Server Certificate. Needs to be specified if trust model is `PRIVATE`.
        :param str server_cert_type: Type of Server Cert (PEM/JKS/.. etc.)
        :param str trust_model: Trust Model of the SSL connection
        :param str type: Controls the ssl type for the given connector version.
        :param bool use_ssl: Bool for enabling SSL
        """
        pulumi.set(__self__, "additional_variables", additional_variables)
        pulumi.set(__self__, "client_cert_type", client_cert_type)
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_private_key", client_private_key)
        pulumi.set(__self__, "client_private_key_pass", client_private_key_pass)
        pulumi.set(__self__, "private_server_certificate", private_server_certificate)
        pulumi.set(__self__, "server_cert_type", server_cert_type)
        pulumi.set(__self__, "trust_model", trust_model)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "use_ssl", use_ssl)

    @property
    @pulumi.getter(name="additionalVariables")
    def additional_variables(self) -> Sequence['outputs.ConfigVariableResponse']:
        """
        Additional SSL related field values
        """
        return pulumi.get(self, "additional_variables")

    @property
    @pulumi.getter(name="clientCertType")
    def client_cert_type(self) -> str:
        """
        Type of Client Cert (PEM/JKS/.. etc.)
        """
        return pulumi.get(self, "client_cert_type")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> 'outputs.SecretResponse':
        """
        Client Certificate
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientPrivateKey")
    def client_private_key(self) -> 'outputs.SecretResponse':
        """
        Client Private Key
        """
        return pulumi.get(self, "client_private_key")

    @property
    @pulumi.getter(name="clientPrivateKeyPass")
    def client_private_key_pass(self) -> 'outputs.SecretResponse':
        """
        Secret containing the passphrase protecting the Client Private Key
        """
        return pulumi.get(self, "client_private_key_pass")

    @property
    @pulumi.getter(name="privateServerCertificate")
    def private_server_certificate(self) -> 'outputs.SecretResponse':
        """
        Private Server Certificate. Needs to be specified if trust model is `PRIVATE`.
        """
        return pulumi.get(self, "private_server_certificate")

    @property
    @pulumi.getter(name="serverCertType")
    def server_cert_type(self) -> str:
        """
        Type of Server Cert (PEM/JKS/.. etc.)
        """
        return pulumi.get(self, "server_cert_type")

    @property
    @pulumi.getter(name="trustModel")
    def trust_model(self) -> str:
        """
        Trust Model of the SSL connection
        """
        return pulumi.get(self, "trust_model")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Controls the ssl type for the given connector version.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="useSsl")
    def use_ssl(self) -> bool:
        """
        Bool for enabling SSL
        """
        return pulumi.get(self, "use_ssl")


@pulumi.output_type
class UserPasswordResponse(dict):
    """
    Parameters to support Username and Password Authentication.
    """
    def __init__(__self__, *,
                 password: 'outputs.SecretResponse',
                 username: str):
        """
        Parameters to support Username and Password Authentication.
        :param 'SecretResponse' password: Secret version reference containing the password.
        :param str username: Username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> 'outputs.SecretResponse':
        """
        Secret version reference containing the password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class WebhookDataResponse(dict):
    """
    WebhookData has details of webhook configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalVariables":
            suggest = "additional_variables"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "nextRefreshTime":
            suggest = "next_refresh_time"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_variables: Sequence['outputs.ConfigVariableResponse'],
                 create_time: str,
                 name: str,
                 next_refresh_time: str,
                 update_time: str):
        """
        WebhookData has details of webhook configuration.
        :param Sequence['ConfigVariableResponse'] additional_variables: Additional webhook related field values.
        :param str create_time: Timestamp when the webhook was created.
        :param str name: Name of the Webhook
        :param str next_refresh_time: Next webhook refresh time. Will be null if refresh is not supported.
        :param str update_time: Timestamp when the webhook was last updated.
        """
        pulumi.set(__self__, "additional_variables", additional_variables)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next_refresh_time", next_refresh_time)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="additionalVariables")
    def additional_variables(self) -> Sequence['outputs.ConfigVariableResponse']:
        """
        Additional webhook related field values.
        """
        return pulumi.get(self, "additional_variables")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Timestamp when the webhook was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Webhook
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextRefreshTime")
    def next_refresh_time(self) -> str:
        """
        Next webhook refresh time. Will be null if refresh is not supported.
        """
        return pulumi.get(self, "next_refresh_time")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        Timestamp when the webhook was last updated.
        """
        return pulumi.get(self, "update_time")



# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AuthorizedNetworkResponse',
    'AutomatedBackupPolicyResponse',
    'BackupSourceResponse',
    'ClientConnectionConfigResponse',
    'ContinuousBackupConfigResponse',
    'ContinuousBackupInfoResponse',
    'DenyMaintenancePeriodResponse',
    'EncryptionConfigResponse',
    'EncryptionInfoResponse',
    'GeminiClusterConfigResponse',
    'GeminiInstanceConfigResponse',
    'GoogleTypeDateResponse',
    'GoogleTypeTimeOfDayResponse',
    'InstanceNetworkConfigResponse',
    'MachineConfigResponse',
    'MaintenanceScheduleResponse',
    'MaintenanceUpdatePolicyResponse',
    'MaintenanceWindowResponse',
    'MigrationSourceResponse',
    'NetworkConfigResponse',
    'NodeResponse',
    'ObservabilityInstanceConfigResponse',
    'PrimaryConfigResponse',
    'PscConfigResponse',
    'PscInstanceConfigResponse',
    'QuantityBasedExpiryResponse',
    'QuantityBasedRetentionResponse',
    'QueryInsightsInstanceConfigResponse',
    'ReadPoolConfigResponse',
    'SecondaryConfigResponse',
    'SslConfigResponse',
    'TimeBasedRetentionResponse',
    'UpdatePolicyResponse',
    'UserPasswordResponse',
    'WeeklyScheduleResponse',
]

@pulumi.output_type
class AuthorizedNetworkResponse(dict):
    """
    AuthorizedNetwork contains metadata for an authorized network.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrRange":
            suggest = "cidr_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizedNetworkResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizedNetworkResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizedNetworkResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_range: str):
        """
        AuthorizedNetwork contains metadata for an authorized network.
        :param str cidr_range: CIDR range for one authorzied network of the instance.
        """
        pulumi.set(__self__, "cidr_range", cidr_range)

    @property
    @pulumi.getter(name="cidrRange")
    def cidr_range(self) -> str:
        """
        CIDR range for one authorzied network of the instance.
        """
        return pulumi.get(self, "cidr_range")


@pulumi.output_type
class AutomatedBackupPolicyResponse(dict):
    """
    Message describing the user-specified automated backup policy. All fields in the automated backup policy are optional. Defaults for each field are provided if they are not set.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupWindow":
            suggest = "backup_window"
        elif key == "encryptionConfig":
            suggest = "encryption_config"
        elif key == "quantityBasedRetention":
            suggest = "quantity_based_retention"
        elif key == "timeBasedRetention":
            suggest = "time_based_retention"
        elif key == "weeklySchedule":
            suggest = "weekly_schedule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomatedBackupPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomatedBackupPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomatedBackupPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_window: str,
                 enabled: bool,
                 encryption_config: 'outputs.EncryptionConfigResponse',
                 labels: Mapping[str, str],
                 location: str,
                 quantity_based_retention: 'outputs.QuantityBasedRetentionResponse',
                 time_based_retention: 'outputs.TimeBasedRetentionResponse',
                 weekly_schedule: 'outputs.WeeklyScheduleResponse'):
        """
        Message describing the user-specified automated backup policy. All fields in the automated backup policy are optional. Defaults for each field are provided if they are not set.
        :param str backup_window: The length of the time window during which a backup can be taken. If a backup does not succeed within this time window, it will be canceled and considered failed. The backup window must be at least 5 minutes long. There is no upper bound on the window. If not set, it defaults to 1 hour.
        :param bool enabled: Whether automated automated backups are enabled. If not set, defaults to true.
        :param 'EncryptionConfigResponse' encryption_config: Optional. The encryption config can be specified to encrypt the backups with a customer-managed encryption key (CMEK). When this field is not specified, the backup will then use default encryption scheme to protect the user data.
        :param Mapping[str, str] labels: Labels to apply to backups created using this configuration.
        :param str location: The location where the backup will be stored. Currently, the only supported option is to store the backup in the same region as the cluster. If empty, defaults to the region of the cluster.
        :param 'QuantityBasedRetentionResponse' quantity_based_retention: Quantity-based Backup retention policy to retain recent backups.
        :param 'TimeBasedRetentionResponse' time_based_retention: Time-based Backup retention policy.
        :param 'WeeklyScheduleResponse' weekly_schedule: Weekly schedule for the Backup.
        """
        pulumi.set(__self__, "backup_window", backup_window)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "encryption_config", encryption_config)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "quantity_based_retention", quantity_based_retention)
        pulumi.set(__self__, "time_based_retention", time_based_retention)
        pulumi.set(__self__, "weekly_schedule", weekly_schedule)

    @property
    @pulumi.getter(name="backupWindow")
    def backup_window(self) -> str:
        """
        The length of the time window during which a backup can be taken. If a backup does not succeed within this time window, it will be canceled and considered failed. The backup window must be at least 5 minutes long. There is no upper bound on the window. If not set, it defaults to 1 hour.
        """
        return pulumi.get(self, "backup_window")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether automated automated backups are enabled. If not set, defaults to true.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="encryptionConfig")
    def encryption_config(self) -> 'outputs.EncryptionConfigResponse':
        """
        Optional. The encryption config can be specified to encrypt the backups with a customer-managed encryption key (CMEK). When this field is not specified, the backup will then use default encryption scheme to protect the user data.
        """
        return pulumi.get(self, "encryption_config")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Labels to apply to backups created using this configuration.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The location where the backup will be stored. Currently, the only supported option is to store the backup in the same region as the cluster. If empty, defaults to the region of the cluster.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="quantityBasedRetention")
    def quantity_based_retention(self) -> 'outputs.QuantityBasedRetentionResponse':
        """
        Quantity-based Backup retention policy to retain recent backups.
        """
        return pulumi.get(self, "quantity_based_retention")

    @property
    @pulumi.getter(name="timeBasedRetention")
    def time_based_retention(self) -> 'outputs.TimeBasedRetentionResponse':
        """
        Time-based Backup retention policy.
        """
        return pulumi.get(self, "time_based_retention")

    @property
    @pulumi.getter(name="weeklySchedule")
    def weekly_schedule(self) -> 'outputs.WeeklyScheduleResponse':
        """
        Weekly schedule for the Backup.
        """
        return pulumi.get(self, "weekly_schedule")


@pulumi.output_type
class BackupSourceResponse(dict):
    """
    Message describing a BackupSource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupName":
            suggest = "backup_name"
        elif key == "backupUid":
            suggest = "backup_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_name: str,
                 backup_uid: str):
        """
        Message describing a BackupSource.
        :param str backup_name: The name of the backup resource with the format: * projects/{project}/locations/{region}/backups/{backup_id}
        :param str backup_uid: The system-generated UID of the backup which was used to create this resource. The UID is generated when the backup is created, and it is retained until the backup is deleted.
        """
        pulumi.set(__self__, "backup_name", backup_name)
        pulumi.set(__self__, "backup_uid", backup_uid)

    @property
    @pulumi.getter(name="backupName")
    def backup_name(self) -> str:
        """
        The name of the backup resource with the format: * projects/{project}/locations/{region}/backups/{backup_id}
        """
        return pulumi.get(self, "backup_name")

    @property
    @pulumi.getter(name="backupUid")
    def backup_uid(self) -> str:
        """
        The system-generated UID of the backup which was used to create this resource. The UID is generated when the backup is created, and it is retained until the backup is deleted.
        """
        return pulumi.get(self, "backup_uid")


@pulumi.output_type
class ClientConnectionConfigResponse(dict):
    """
    Client connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requireConnectors":
            suggest = "require_connectors"
        elif key == "sslConfig":
            suggest = "ssl_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientConnectionConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientConnectionConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientConnectionConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 require_connectors: bool,
                 ssl_config: 'outputs.SslConfigResponse'):
        """
        Client connection configuration
        :param bool require_connectors: Optional. Configuration to enforce connectors only (ex: AuthProxy) connections to the database.
        :param 'SslConfigResponse' ssl_config: Optional. SSL config option for this instance.
        """
        pulumi.set(__self__, "require_connectors", require_connectors)
        pulumi.set(__self__, "ssl_config", ssl_config)

    @property
    @pulumi.getter(name="requireConnectors")
    def require_connectors(self) -> bool:
        """
        Optional. Configuration to enforce connectors only (ex: AuthProxy) connections to the database.
        """
        return pulumi.get(self, "require_connectors")

    @property
    @pulumi.getter(name="sslConfig")
    def ssl_config(self) -> 'outputs.SslConfigResponse':
        """
        Optional. SSL config option for this instance.
        """
        return pulumi.get(self, "ssl_config")


@pulumi.output_type
class ContinuousBackupConfigResponse(dict):
    """
    ContinuousBackupConfig describes the continuous backups recovery configurations of a cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionConfig":
            suggest = "encryption_config"
        elif key == "recoveryWindowDays":
            suggest = "recovery_window_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContinuousBackupConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContinuousBackupConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContinuousBackupConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 encryption_config: 'outputs.EncryptionConfigResponse',
                 recovery_window_days: int):
        """
        ContinuousBackupConfig describes the continuous backups recovery configurations of a cluster.
        :param bool enabled: Whether ContinuousBackup is enabled.
        :param 'EncryptionConfigResponse' encryption_config: The encryption config can be specified to encrypt the backups with a customer-managed encryption key (CMEK). When this field is not specified, the backup will then use default encryption scheme to protect the user data.
        :param int recovery_window_days: The number of days that are eligible to restore from using PITR. To support the entire recovery window, backups and logs are retained for one day more than the recovery window. If not set, defaults to 14 days.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "encryption_config", encryption_config)
        pulumi.set(__self__, "recovery_window_days", recovery_window_days)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether ContinuousBackup is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="encryptionConfig")
    def encryption_config(self) -> 'outputs.EncryptionConfigResponse':
        """
        The encryption config can be specified to encrypt the backups with a customer-managed encryption key (CMEK). When this field is not specified, the backup will then use default encryption scheme to protect the user data.
        """
        return pulumi.get(self, "encryption_config")

    @property
    @pulumi.getter(name="recoveryWindowDays")
    def recovery_window_days(self) -> int:
        """
        The number of days that are eligible to restore from using PITR. To support the entire recovery window, backups and logs are retained for one day more than the recovery window. If not set, defaults to 14 days.
        """
        return pulumi.get(self, "recovery_window_days")


@pulumi.output_type
class ContinuousBackupInfoResponse(dict):
    """
    ContinuousBackupInfo describes the continuous backup properties of a cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "earliestRestorableTime":
            suggest = "earliest_restorable_time"
        elif key == "enabledTime":
            suggest = "enabled_time"
        elif key == "encryptionInfo":
            suggest = "encryption_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContinuousBackupInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContinuousBackupInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContinuousBackupInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 earliest_restorable_time: str,
                 enabled_time: str,
                 encryption_info: 'outputs.EncryptionInfoResponse',
                 schedule: Sequence[str]):
        """
        ContinuousBackupInfo describes the continuous backup properties of a cluster.
        :param str earliest_restorable_time: The earliest restorable time that can be restored to. Output only field.
        :param str enabled_time: When ContinuousBackup was most recently enabled. Set to null if ContinuousBackup is not enabled.
        :param 'EncryptionInfoResponse' encryption_info: The encryption information for the WALs and backups required for ContinuousBackup.
        :param Sequence[str] schedule: Days of the week on which a continuous backup is taken. Output only field. Ignored if passed into the request.
        """
        pulumi.set(__self__, "earliest_restorable_time", earliest_restorable_time)
        pulumi.set(__self__, "enabled_time", enabled_time)
        pulumi.set(__self__, "encryption_info", encryption_info)
        pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter(name="earliestRestorableTime")
    def earliest_restorable_time(self) -> str:
        """
        The earliest restorable time that can be restored to. Output only field.
        """
        return pulumi.get(self, "earliest_restorable_time")

    @property
    @pulumi.getter(name="enabledTime")
    def enabled_time(self) -> str:
        """
        When ContinuousBackup was most recently enabled. Set to null if ContinuousBackup is not enabled.
        """
        return pulumi.get(self, "enabled_time")

    @property
    @pulumi.getter(name="encryptionInfo")
    def encryption_info(self) -> 'outputs.EncryptionInfoResponse':
        """
        The encryption information for the WALs and backups required for ContinuousBackup.
        """
        return pulumi.get(self, "encryption_info")

    @property
    @pulumi.getter
    def schedule(self) -> Sequence[str]:
        """
        Days of the week on which a continuous backup is taken. Output only field. Ignored if passed into the request.
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class DenyMaintenancePeriodResponse(dict):
    """
    DenyMaintenancePeriod definition. Excepting emergencies, maintenance will not be scheduled to start within this deny period. The start_date must be less than the end_date.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DenyMaintenancePeriodResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DenyMaintenancePeriodResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DenyMaintenancePeriodResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: 'outputs.GoogleTypeDateResponse',
                 start_date: 'outputs.GoogleTypeDateResponse',
                 time: 'outputs.GoogleTypeTimeOfDayResponse'):
        """
        DenyMaintenancePeriod definition. Excepting emergencies, maintenance will not be scheduled to start within this deny period. The start_date must be less than the end_date.
        :param 'GoogleTypeDateResponse' end_date: Deny period end date. This can be: * A full date, with non-zero year, month and day values. * A month and day value, with a zero year for recurring. Date matching this period will have to be before the end.
        :param 'GoogleTypeDateResponse' start_date: Deny period start date. This can be: * A full date, with non-zero year, month and day values. * A month and day value, with a zero year for recurring. Date matching this period will have to be the same or after the start.
        :param 'GoogleTypeTimeOfDayResponse' time: Time in UTC when the deny period starts on start_date and ends on end_date. This can be: * Full time. * All zeros for 00:00:00 UTC
        """
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> 'outputs.GoogleTypeDateResponse':
        """
        Deny period end date. This can be: * A full date, with non-zero year, month and day values. * A month and day value, with a zero year for recurring. Date matching this period will have to be before the end.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> 'outputs.GoogleTypeDateResponse':
        """
        Deny period start date. This can be: * A full date, with non-zero year, month and day values. * A month and day value, with a zero year for recurring. Date matching this period will have to be the same or after the start.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def time(self) -> 'outputs.GoogleTypeTimeOfDayResponse':
        """
        Time in UTC when the deny period starts on start_date and ends on end_date. This can be: * Full time. * All zeros for 00:00:00 UTC
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class EncryptionConfigResponse(dict):
    """
    EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyName":
            suggest = "kms_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_name: str):
        """
        EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
        :param str kms_key_name: The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME]
        """
        pulumi.set(__self__, "kms_key_name", kms_key_name)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> str:
        """
        The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME]
        """
        return pulumi.get(self, "kms_key_name")


@pulumi.output_type
class EncryptionInfoResponse(dict):
    """
    EncryptionInfo describes the encryption information of a cluster or a backup.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKeyVersions":
            suggest = "kms_key_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_type: str,
                 kms_key_versions: Sequence[str]):
        """
        EncryptionInfo describes the encryption information of a cluster or a backup.
        :param str encryption_type: Type of encryption.
        :param Sequence[str] kms_key_versions: Cloud KMS key versions that are being used to protect the database or the backup.
        """
        pulumi.set(__self__, "encryption_type", encryption_type)
        pulumi.set(__self__, "kms_key_versions", kms_key_versions)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> str:
        """
        Type of encryption.
        """
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter(name="kmsKeyVersions")
    def kms_key_versions(self) -> Sequence[str]:
        """
        Cloud KMS key versions that are being used to protect the database or the backup.
        """
        return pulumi.get(self, "kms_key_versions")


@pulumi.output_type
class GeminiClusterConfigResponse(dict):
    """
    Cluster level configuration parameters related to the Gemini in Databases add-on. See go/prd-enable-duet-ai-databases for more details.
    """
    def __init__(__self__, *,
                 entitled: bool):
        """
        Cluster level configuration parameters related to the Gemini in Databases add-on. See go/prd-enable-duet-ai-databases for more details.
        :param bool entitled: Whether the Gemini in Databases add-on is enabled for the cluster. It will be true only if the add-on has been enabled for the billing account corresponding to the cluster. Its status is toggled from the Admin Control Center (ACC) and cannot be toggled using AlloyDB's APIs.
        """
        pulumi.set(__self__, "entitled", entitled)

    @property
    @pulumi.getter
    def entitled(self) -> bool:
        """
        Whether the Gemini in Databases add-on is enabled for the cluster. It will be true only if the add-on has been enabled for the billing account corresponding to the cluster. Its status is toggled from the Admin Control Center (ACC) and cannot be toggled using AlloyDB's APIs.
        """
        return pulumi.get(self, "entitled")


@pulumi.output_type
class GeminiInstanceConfigResponse(dict):
    """
    Instance level configuration parameters related to the Gemini in Databases add-on. See go/prd-enable-duet-ai-databases for more details.
    """
    def __init__(__self__, *,
                 entitled: bool):
        """
        Instance level configuration parameters related to the Gemini in Databases add-on. See go/prd-enable-duet-ai-databases for more details.
        :param bool entitled: Whether the Gemini in Databases add-on is enabled for the instance. It will be true only if the add-on has been enabled for the billing account corresponding to the instance. Its status is toggled from the Admin Control Center (ACC) and cannot be toggled using AlloyDB's APIs.
        """
        pulumi.set(__self__, "entitled", entitled)

    @property
    @pulumi.getter
    def entitled(self) -> bool:
        """
        Whether the Gemini in Databases add-on is enabled for the instance. It will be true only if the add-on has been enabled for the billing account corresponding to the instance. Its status is toggled from the Admin Control Center (ACC) and cannot be toggled using AlloyDB's APIs.
        """
        return pulumi.get(self, "entitled")


@pulumi.output_type
class GoogleTypeDateResponse(dict):
    """
    Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp
    """
    def __init__(__self__, *,
                 day: int,
                 month: int,
                 year: int):
        """
        Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp
        :param int day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
        :param int month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param int year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "month", month)
        pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> int:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def month(self) -> int:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @property
    @pulumi.getter
    def year(self) -> int:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")


@pulumi.output_type
class GoogleTypeTimeOfDayResponse(dict):
    """
    Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.
    """
    def __init__(__self__, *,
                 hours: int,
                 minutes: int,
                 nanos: int,
                 seconds: int):
        """
        Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.
        :param int hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param int minutes: Minutes of hour of day. Must be from 0 to 59.
        :param int nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param int seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> int:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> int:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def nanos(self) -> int:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> int:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class InstanceNetworkConfigResponse(dict):
    """
    Metadata related to instance level network configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizedExternalNetworks":
            suggest = "authorized_external_networks"
        elif key == "enablePublicIp":
            suggest = "enable_public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorized_external_networks: Sequence['outputs.AuthorizedNetworkResponse'],
                 enable_public_ip: bool):
        """
        Metadata related to instance level network configuration.
        :param Sequence['AuthorizedNetworkResponse'] authorized_external_networks: Optional. A list of external network authorized to access this instance.
        :param bool enable_public_ip: Optional. Enabling public ip for the instance.
        """
        pulumi.set(__self__, "authorized_external_networks", authorized_external_networks)
        pulumi.set(__self__, "enable_public_ip", enable_public_ip)

    @property
    @pulumi.getter(name="authorizedExternalNetworks")
    def authorized_external_networks(self) -> Sequence['outputs.AuthorizedNetworkResponse']:
        """
        Optional. A list of external network authorized to access this instance.
        """
        return pulumi.get(self, "authorized_external_networks")

    @property
    @pulumi.getter(name="enablePublicIp")
    def enable_public_ip(self) -> bool:
        """
        Optional. Enabling public ip for the instance.
        """
        return pulumi.get(self, "enable_public_ip")


@pulumi.output_type
class MachineConfigResponse(dict):
    """
    MachineConfig describes the configuration of a machine.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCount":
            suggest = "cpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_count: int):
        """
        MachineConfig describes the configuration of a machine.
        :param int cpu_count: The number of CPU's in the VM instance.
        """
        pulumi.set(__self__, "cpu_count", cpu_count)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> int:
        """
        The number of CPU's in the VM instance.
        """
        return pulumi.get(self, "cpu_count")


@pulumi.output_type
class MaintenanceScheduleResponse(dict):
    """
    MaintenanceSchedule stores the maintenance schedule generated from the MaintenanceUpdatePolicy, once a maintenance rollout is triggered, if MaintenanceWindow is set, and if there is no conflicting DenyPeriod. The schedule is cleared once the update takes place. This field cannot be manually changed; modify the MaintenanceUpdatePolicy instead.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_time: str):
        """
        MaintenanceSchedule stores the maintenance schedule generated from the MaintenanceUpdatePolicy, once a maintenance rollout is triggered, if MaintenanceWindow is set, and if there is no conflicting DenyPeriod. The schedule is cleared once the update takes place. This field cannot be manually changed; modify the MaintenanceUpdatePolicy instead.
        :param str start_time: The scheduled start time for the maintenance.
        """
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        The scheduled start time for the maintenance.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class MaintenanceUpdatePolicyResponse(dict):
    """
    MaintenanceUpdatePolicy defines the policy for system updates.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "denyMaintenancePeriods":
            suggest = "deny_maintenance_periods"
        elif key == "maintenanceWindows":
            suggest = "maintenance_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceUpdatePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceUpdatePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceUpdatePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deny_maintenance_periods: Sequence['outputs.DenyMaintenancePeriodResponse'],
                 maintenance_windows: Sequence['outputs.MaintenanceWindowResponse']):
        """
        MaintenanceUpdatePolicy defines the policy for system updates.
        :param Sequence['DenyMaintenancePeriodResponse'] deny_maintenance_periods: Periods to deny maintenance. Currently limited to 1.
        :param Sequence['MaintenanceWindowResponse'] maintenance_windows: Preferred windows to perform maintenance. Currently limited to 1.
        """
        pulumi.set(__self__, "deny_maintenance_periods", deny_maintenance_periods)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)

    @property
    @pulumi.getter(name="denyMaintenancePeriods")
    def deny_maintenance_periods(self) -> Sequence['outputs.DenyMaintenancePeriodResponse']:
        """
        Periods to deny maintenance. Currently limited to 1.
        """
        return pulumi.get(self, "deny_maintenance_periods")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.MaintenanceWindowResponse']:
        """
        Preferred windows to perform maintenance. Currently limited to 1.
        """
        return pulumi.get(self, "maintenance_windows")


@pulumi.output_type
class MaintenanceWindowResponse(dict):
    """
    MaintenanceWindow specifies a preferred day and time for maintenance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day: str,
                 start_time: 'outputs.GoogleTypeTimeOfDayResponse'):
        """
        MaintenanceWindow specifies a preferred day and time for maintenance.
        :param str day: Preferred day of the week for maintenance, e.g. MONDAY, TUESDAY, etc.
        :param 'GoogleTypeTimeOfDayResponse' start_time: Preferred time to start the maintenance operation on the specified day. Maintenance will start within 1 hour of this time.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def day(self) -> str:
        """
        Preferred day of the week for maintenance, e.g. MONDAY, TUESDAY, etc.
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> 'outputs.GoogleTypeTimeOfDayResponse':
        """
        Preferred time to start the maintenance operation on the specified day. Maintenance will start within 1 hour of this time.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class MigrationSourceResponse(dict):
    """
    Subset of the source instance configuration that is available when reading the cluster resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostPort":
            suggest = "host_port"
        elif key == "referenceId":
            suggest = "reference_id"
        elif key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrationSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrationSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrationSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_port: str,
                 reference_id: str,
                 source_type: str):
        """
        Subset of the source instance configuration that is available when reading the cluster resource.
        :param str host_port: The host and port of the on-premises instance in host:port format
        :param str reference_id: Place holder for the external source identifier(e.g DMS job name) that created the cluster.
        :param str source_type: Type of migration source.
        """
        pulumi.set(__self__, "host_port", host_port)
        pulumi.set(__self__, "reference_id", reference_id)
        pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> str:
        """
        The host and port of the on-premises instance in host:port format
        """
        return pulumi.get(self, "host_port")

    @property
    @pulumi.getter(name="referenceId")
    def reference_id(self) -> str:
        """
        Place holder for the external source identifier(e.g DMS job name) that created the cluster.
        """
        return pulumi.get(self, "reference_id")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Type of migration source.
        """
        return pulumi.get(self, "source_type")


@pulumi.output_type
class NetworkConfigResponse(dict):
    """
    Metadata related to network configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocatedIpRange":
            suggest = "allocated_ip_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocated_ip_range: str,
                 network: str):
        """
        Metadata related to network configuration.
        :param str allocated_ip_range: Optional. Name of the allocated IP range for the private IP AlloyDB cluster, for example: "google-managed-services-default". If set, the instance IPs for this cluster will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. Field name is intended to be consistent with Cloud SQL.
        :param str network: Optional. The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster. It is specified in the form: `projects/{project_number}/global/networks/{network_id}`. This is required to create a cluster.
        """
        pulumi.set(__self__, "allocated_ip_range", allocated_ip_range)
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter(name="allocatedIpRange")
    def allocated_ip_range(self) -> str:
        """
        Optional. Name of the allocated IP range for the private IP AlloyDB cluster, for example: "google-managed-services-default". If set, the instance IPs for this cluster will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. Field name is intended to be consistent with Cloud SQL.
        """
        return pulumi.get(self, "allocated_ip_range")

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        Optional. The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster. It is specified in the form: `projects/{project_number}/global/networks/{network_id}`. This is required to create a cluster.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class NodeResponse(dict):
    """
    Details of a single node in the instance. Nodes in an AlloyDB instance are ephemereal, they can change during update, failover, autohealing and resize operations.
    """
    def __init__(__self__, *,
                 ip: str,
                 state: str,
                 zone: str):
        """
        Details of a single node in the instance. Nodes in an AlloyDB instance are ephemereal, they can change during update, failover, autohealing and resize operations.
        :param str ip: The private IP address of the VM e.g. "10.57.0.34".
        :param str state: Determined by state of the compute VM and postgres-service health. Compute VM state can have values listed in https://cloud.google.com/compute/docs/instances/instance-life-cycle and postgres-service health can have values: HEALTHY and UNHEALTHY.
        :param str zone: The Compute Engine zone of the VM e.g. "us-central1-b".
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The private IP address of the VM e.g. "10.57.0.34".
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Determined by state of the compute VM and postgres-service health. Compute VM state can have values listed in https://cloud.google.com/compute/docs/instances/instance-life-cycle and postgres-service health can have values: HEALTHY and UNHEALTHY.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The Compute Engine zone of the VM e.g. "us-central1-b".
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class ObservabilityInstanceConfigResponse(dict):
    """
    Observability Instance specific configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxQueryStringLength":
            suggest = "max_query_string_length"
        elif key == "preserveComments":
            suggest = "preserve_comments"
        elif key == "queryPlansPerMinute":
            suggest = "query_plans_per_minute"
        elif key == "recordApplicationTags":
            suggest = "record_application_tags"
        elif key == "trackActiveQueries":
            suggest = "track_active_queries"
        elif key == "trackWaitEventTypes":
            suggest = "track_wait_event_types"
        elif key == "trackWaitEvents":
            suggest = "track_wait_events"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObservabilityInstanceConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObservabilityInstanceConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObservabilityInstanceConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 max_query_string_length: int,
                 preserve_comments: bool,
                 query_plans_per_minute: int,
                 record_application_tags: bool,
                 track_active_queries: bool,
                 track_wait_event_types: bool,
                 track_wait_events: bool):
        """
        Observability Instance specific configuration.
        :param bool enabled: Observability feature status for an instance. This is a read-only flag and modifiable only by producer API. This flag is turned "off" by default.
        :param int max_query_string_length: Query string length. The default value is 10k.
        :param bool preserve_comments: Preserve comments in query string for an instance. This flag is turned "off" by default.
        :param int query_plans_per_minute: Number of query execution plans captured by Insights per minute for all queries combined. The default value is 5. Any integer between 0 to 20 is considered valid.
        :param bool record_application_tags: Record application tags for an instance. This flag is turned "off" by default.
        :param bool track_active_queries: Track actively running queries on the instance. If not set, this flag is "off" by default.
        :param bool track_wait_event_types: Track wait event types during query execution for an instance. This flag is turned "on" by default but tracking is enabled only after observability enabled flag is also turned on. This is read-only flag and only modifiable by producer API.
        :param bool track_wait_events: Track wait events during query execution for an instance. This flag is turned "on" by default but tracking is enabled only after observability enabled flag is also turned on.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "max_query_string_length", max_query_string_length)
        pulumi.set(__self__, "preserve_comments", preserve_comments)
        pulumi.set(__self__, "query_plans_per_minute", query_plans_per_minute)
        pulumi.set(__self__, "record_application_tags", record_application_tags)
        pulumi.set(__self__, "track_active_queries", track_active_queries)
        pulumi.set(__self__, "track_wait_event_types", track_wait_event_types)
        pulumi.set(__self__, "track_wait_events", track_wait_events)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Observability feature status for an instance. This is a read-only flag and modifiable only by producer API. This flag is turned "off" by default.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxQueryStringLength")
    def max_query_string_length(self) -> int:
        """
        Query string length. The default value is 10k.
        """
        return pulumi.get(self, "max_query_string_length")

    @property
    @pulumi.getter(name="preserveComments")
    def preserve_comments(self) -> bool:
        """
        Preserve comments in query string for an instance. This flag is turned "off" by default.
        """
        return pulumi.get(self, "preserve_comments")

    @property
    @pulumi.getter(name="queryPlansPerMinute")
    def query_plans_per_minute(self) -> int:
        """
        Number of query execution plans captured by Insights per minute for all queries combined. The default value is 5. Any integer between 0 to 20 is considered valid.
        """
        return pulumi.get(self, "query_plans_per_minute")

    @property
    @pulumi.getter(name="recordApplicationTags")
    def record_application_tags(self) -> bool:
        """
        Record application tags for an instance. This flag is turned "off" by default.
        """
        return pulumi.get(self, "record_application_tags")

    @property
    @pulumi.getter(name="trackActiveQueries")
    def track_active_queries(self) -> bool:
        """
        Track actively running queries on the instance. If not set, this flag is "off" by default.
        """
        return pulumi.get(self, "track_active_queries")

    @property
    @pulumi.getter(name="trackWaitEventTypes")
    def track_wait_event_types(self) -> bool:
        """
        Track wait event types during query execution for an instance. This flag is turned "on" by default but tracking is enabled only after observability enabled flag is also turned on. This is read-only flag and only modifiable by producer API.
        """
        return pulumi.get(self, "track_wait_event_types")

    @property
    @pulumi.getter(name="trackWaitEvents")
    def track_wait_events(self) -> bool:
        """
        Track wait events during query execution for an instance. This flag is turned "on" by default but tracking is enabled only after observability enabled flag is also turned on.
        """
        return pulumi.get(self, "track_wait_events")


@pulumi.output_type
class PrimaryConfigResponse(dict):
    """
    Configuration for the primary cluster. It has the list of clusters that are replicating from this cluster. This should be set if and only if the cluster is of type PRIMARY.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secondaryClusterNames":
            suggest = "secondary_cluster_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrimaryConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrimaryConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrimaryConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secondary_cluster_names: Sequence[str]):
        """
        Configuration for the primary cluster. It has the list of clusters that are replicating from this cluster. This should be set if and only if the cluster is of type PRIMARY.
        :param Sequence[str] secondary_cluster_names: Names of the clusters that are replicating from this cluster.
        """
        pulumi.set(__self__, "secondary_cluster_names", secondary_cluster_names)

    @property
    @pulumi.getter(name="secondaryClusterNames")
    def secondary_cluster_names(self) -> Sequence[str]:
        """
        Names of the clusters that are replicating from this cluster.
        """
        return pulumi.get(self, "secondary_cluster_names")


@pulumi.output_type
class PscConfigResponse(dict):
    """
    PscConfig contains PSC related configuration at a cluster level.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pscEnabled":
            suggest = "psc_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PscConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PscConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PscConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 psc_enabled: bool):
        """
        PscConfig contains PSC related configuration at a cluster level.
        :param bool psc_enabled: Optional. Create an instance that allows connections from Private Service Connect endpoints to the instance.
        """
        pulumi.set(__self__, "psc_enabled", psc_enabled)

    @property
    @pulumi.getter(name="pscEnabled")
    def psc_enabled(self) -> bool:
        """
        Optional. Create an instance that allows connections from Private Service Connect endpoints to the instance.
        """
        return pulumi.get(self, "psc_enabled")


@pulumi.output_type
class PscInstanceConfigResponse(dict):
    """
    PscInstanceConfig contains PSC related configuration at an instance level.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedConsumerProjects":
            suggest = "allowed_consumer_projects"
        elif key == "pscDnsName":
            suggest = "psc_dns_name"
        elif key == "serviceAttachmentLink":
            suggest = "service_attachment_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PscInstanceConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PscInstanceConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PscInstanceConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_consumer_projects: Sequence[str],
                 psc_dns_name: str,
                 service_attachment_link: str):
        """
        PscInstanceConfig contains PSC related configuration at an instance level.
        :param Sequence[str] allowed_consumer_projects: Optional. List of consumer projects that are allowed to create PSC endpoints to service-attachments to this instance.
        :param str psc_dns_name: The DNS name of the instance for PSC connectivity. Name convention: ...alloydb-psc.goog
        :param str service_attachment_link: The service attachment created when Private Service Connect (PSC) is enabled for the instance. The name of the resource will be in the format of `projects//regions//serviceAttachments/`
        """
        pulumi.set(__self__, "allowed_consumer_projects", allowed_consumer_projects)
        pulumi.set(__self__, "psc_dns_name", psc_dns_name)
        pulumi.set(__self__, "service_attachment_link", service_attachment_link)

    @property
    @pulumi.getter(name="allowedConsumerProjects")
    def allowed_consumer_projects(self) -> Sequence[str]:
        """
        Optional. List of consumer projects that are allowed to create PSC endpoints to service-attachments to this instance.
        """
        return pulumi.get(self, "allowed_consumer_projects")

    @property
    @pulumi.getter(name="pscDnsName")
    def psc_dns_name(self) -> str:
        """
        The DNS name of the instance for PSC connectivity. Name convention: ...alloydb-psc.goog
        """
        return pulumi.get(self, "psc_dns_name")

    @property
    @pulumi.getter(name="serviceAttachmentLink")
    def service_attachment_link(self) -> str:
        """
        The service attachment created when Private Service Connect (PSC) is enabled for the instance. The name of the resource will be in the format of `projects//regions//serviceAttachments/`
        """
        return pulumi.get(self, "service_attachment_link")


@pulumi.output_type
class QuantityBasedExpiryResponse(dict):
    """
    A backup's position in a quantity-based retention queue, of backups with the same source cluster and type, with length, retention, specified by the backup's retention policy. Once the position is greater than the retention, the backup is eligible to be garbage collected. Example: 5 backups from the same source cluster and type with a quantity-based retention of 3 and denoted by backup_id (position, retention). Safe: backup_5 (1, 3), backup_4, (2, 3), backup_3 (3, 3). Awaiting garbage collection: backup_2 (4, 3), backup_1 (5, 3)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionCount":
            suggest = "retention_count"
        elif key == "totalRetentionCount":
            suggest = "total_retention_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QuantityBasedExpiryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QuantityBasedExpiryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QuantityBasedExpiryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_count: int,
                 total_retention_count: int):
        """
        A backup's position in a quantity-based retention queue, of backups with the same source cluster and type, with length, retention, specified by the backup's retention policy. Once the position is greater than the retention, the backup is eligible to be garbage collected. Example: 5 backups from the same source cluster and type with a quantity-based retention of 3 and denoted by backup_id (position, retention). Safe: backup_5 (1, 3), backup_4, (2, 3), backup_3 (3, 3). Awaiting garbage collection: backup_2 (4, 3), backup_1 (5, 3)
        :param int retention_count: The backup's position among its backups with the same source cluster and type, by descending chronological order create time(i.e. newest first).
        :param int total_retention_count: The length of the quantity-based queue, specified by the backup's retention policy.
        """
        pulumi.set(__self__, "retention_count", retention_count)
        pulumi.set(__self__, "total_retention_count", total_retention_count)

    @property
    @pulumi.getter(name="retentionCount")
    def retention_count(self) -> int:
        """
        The backup's position among its backups with the same source cluster and type, by descending chronological order create time(i.e. newest first).
        """
        return pulumi.get(self, "retention_count")

    @property
    @pulumi.getter(name="totalRetentionCount")
    def total_retention_count(self) -> int:
        """
        The length of the quantity-based queue, specified by the backup's retention policy.
        """
        return pulumi.get(self, "total_retention_count")


@pulumi.output_type
class QuantityBasedRetentionResponse(dict):
    """
    A quantity based policy specifies that a certain number of the most recent successful backups should be retained.
    """
    def __init__(__self__, *,
                 count: int):
        """
        A quantity based policy specifies that a certain number of the most recent successful backups should be retained.
        :param int count: The number of backups to retain.
        """
        pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of backups to retain.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class QueryInsightsInstanceConfigResponse(dict):
    """
    QueryInsights Instance specific configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryPlansPerMinute":
            suggest = "query_plans_per_minute"
        elif key == "queryStringLength":
            suggest = "query_string_length"
        elif key == "recordApplicationTags":
            suggest = "record_application_tags"
        elif key == "recordClientAddress":
            suggest = "record_client_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryInsightsInstanceConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryInsightsInstanceConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryInsightsInstanceConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_plans_per_minute: int,
                 query_string_length: int,
                 record_application_tags: bool,
                 record_client_address: bool):
        """
        QueryInsights Instance specific configuration.
        :param int query_plans_per_minute: Number of query execution plans captured by Insights per minute for all queries combined. The default value is 5. Any integer between 0 and 20 is considered valid.
        :param int query_string_length: Query string length. The default value is 1024. Any integer between 256 and 4500 is considered valid.
        :param bool record_application_tags: Record application tags for an instance. This flag is turned "on" by default.
        :param bool record_client_address: Record client address for an instance. Client address is PII information. This flag is turned "on" by default.
        """
        pulumi.set(__self__, "query_plans_per_minute", query_plans_per_minute)
        pulumi.set(__self__, "query_string_length", query_string_length)
        pulumi.set(__self__, "record_application_tags", record_application_tags)
        pulumi.set(__self__, "record_client_address", record_client_address)

    @property
    @pulumi.getter(name="queryPlansPerMinute")
    def query_plans_per_minute(self) -> int:
        """
        Number of query execution plans captured by Insights per minute for all queries combined. The default value is 5. Any integer between 0 and 20 is considered valid.
        """
        return pulumi.get(self, "query_plans_per_minute")

    @property
    @pulumi.getter(name="queryStringLength")
    def query_string_length(self) -> int:
        """
        Query string length. The default value is 1024. Any integer between 256 and 4500 is considered valid.
        """
        return pulumi.get(self, "query_string_length")

    @property
    @pulumi.getter(name="recordApplicationTags")
    def record_application_tags(self) -> bool:
        """
        Record application tags for an instance. This flag is turned "on" by default.
        """
        return pulumi.get(self, "record_application_tags")

    @property
    @pulumi.getter(name="recordClientAddress")
    def record_client_address(self) -> bool:
        """
        Record client address for an instance. Client address is PII information. This flag is turned "on" by default.
        """
        return pulumi.get(self, "record_client_address")


@pulumi.output_type
class ReadPoolConfigResponse(dict):
    """
    Configuration for a read pool instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReadPoolConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReadPoolConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReadPoolConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_count: int):
        """
        Configuration for a read pool instance.
        :param int node_count: Read capacity, i.e. number of nodes in a read pool instance.
        """
        pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        """
        Read capacity, i.e. number of nodes in a read pool instance.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class SecondaryConfigResponse(dict):
    """
    Configuration information for the secondary cluster. This should be set if and only if the cluster is of type SECONDARY.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryClusterName":
            suggest = "primary_cluster_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecondaryConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecondaryConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecondaryConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary_cluster_name: str):
        """
        Configuration information for the secondary cluster. This should be set if and only if the cluster is of type SECONDARY.
        :param str primary_cluster_name: The name of the primary cluster name with the format: * projects/{project}/locations/{region}/clusters/{cluster_id}
        """
        pulumi.set(__self__, "primary_cluster_name", primary_cluster_name)

    @property
    @pulumi.getter(name="primaryClusterName")
    def primary_cluster_name(self) -> str:
        """
        The name of the primary cluster name with the format: * projects/{project}/locations/{region}/clusters/{cluster_id}
        """
        return pulumi.get(self, "primary_cluster_name")


@pulumi.output_type
class SslConfigResponse(dict):
    """
    SSL configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caSource":
            suggest = "ca_source"
        elif key == "sslMode":
            suggest = "ssl_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_source: str,
                 ssl_mode: str):
        """
        SSL configuration.
        :param str ca_source: Optional. Certificate Authority (CA) source. Only CA_SOURCE_MANAGED is supported currently, and is the default value.
        :param str ssl_mode: Optional. SSL mode. Specifies client-server SSL/TLS connection behavior.
        """
        pulumi.set(__self__, "ca_source", ca_source)
        pulumi.set(__self__, "ssl_mode", ssl_mode)

    @property
    @pulumi.getter(name="caSource")
    def ca_source(self) -> str:
        """
        Optional. Certificate Authority (CA) source. Only CA_SOURCE_MANAGED is supported currently, and is the default value.
        """
        return pulumi.get(self, "ca_source")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> str:
        """
        Optional. SSL mode. Specifies client-server SSL/TLS connection behavior.
        """
        return pulumi.get(self, "ssl_mode")


@pulumi.output_type
class TimeBasedRetentionResponse(dict):
    """
    A time based retention policy specifies that all backups within a certain time period should be retained.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionPeriod":
            suggest = "retention_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeBasedRetentionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeBasedRetentionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeBasedRetentionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_period: str):
        """
        A time based retention policy specifies that all backups within a certain time period should be retained.
        :param str retention_period: The retention period.
        """
        pulumi.set(__self__, "retention_period", retention_period)

    @property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> str:
        """
        The retention period.
        """
        return pulumi.get(self, "retention_period")


@pulumi.output_type
class UpdatePolicyResponse(dict):
    """
    Policy to be used while updating the instance.
    """
    def __init__(__self__, *,
                 mode: str):
        """
        Policy to be used while updating the instance.
        :param str mode: Mode for updating the instance.
        """
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Mode for updating the instance.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class UserPasswordResponse(dict):
    """
    The username/password for a database user. Used for specifying initial users at cluster creation time.
    """
    def __init__(__self__, *,
                 password: str,
                 user: str):
        """
        The username/password for a database user. Used for specifying initial users at cluster creation time.
        :param str password: The initial password for the user.
        :param str user: The database username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The initial password for the user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        The database username.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class WeeklyScheduleResponse(dict):
    """
    A weekly schedule starts a backup at prescribed start times within a day, for the specified days of the week. The weekly schedule message is flexible and can be used to create many types of schedules. For example, to have a daily backup that starts at 22:00, configure the `start_times` field to have one element "22:00" and the `days_of_week` field to have all seven days of the week.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeek":
            suggest = "days_of_week"
        elif key == "startTimes":
            suggest = "start_times"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WeeklyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WeeklyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WeeklyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_week: Sequence[str],
                 start_times: Sequence['outputs.GoogleTypeTimeOfDayResponse']):
        """
        A weekly schedule starts a backup at prescribed start times within a day, for the specified days of the week. The weekly schedule message is flexible and can be used to create many types of schedules. For example, to have a daily backup that starts at 22:00, configure the `start_times` field to have one element "22:00" and the `days_of_week` field to have all seven days of the week.
        :param Sequence[str] days_of_week: The days of the week to perform a backup. If this field is left empty, the default of every day of the week is used.
        :param Sequence['GoogleTypeTimeOfDayResponse'] start_times: The times during the day to start a backup. The start times are assumed to be in UTC and to be an exact hour (e.g., 04:00:00). If no start times are provided, a single fixed start time is chosen arbitrarily.
        """
        pulumi.set(__self__, "days_of_week", days_of_week)
        pulumi.set(__self__, "start_times", start_times)

    @property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> Sequence[str]:
        """
        The days of the week to perform a backup. If this field is left empty, the default of every day of the week is used.
        """
        return pulumi.get(self, "days_of_week")

    @property
    @pulumi.getter(name="startTimes")
    def start_times(self) -> Sequence['outputs.GoogleTypeTimeOfDayResponse']:
        """
        The times during the day to start a backup. The start times are assumed to be in UTC and to be an exact hour (e.g., 04:00:00). If no start times are provided, a single fixed start time is chosen arbitrarily.
        """
        return pulumi.get(self, "start_times")



// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.BinaryAuthorization.V1
{
    /// <summary>
    /// The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
    /// </summary>
    [EnumType]
    public readonly struct PkixPublicKeySignatureAlgorithm : IEquatable<PkixPublicKeySignatureAlgorithm>
    {
        private readonly string _value;

        private PkixPublicKeySignatureAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm SignatureAlgorithmUnspecified { get; } = new PkixPublicKeySignatureAlgorithm("SIGNATURE_ALGORITHM_UNSPECIFIED");
        /// <summary>
        /// RSASSA-PSS 2048 bit key with a SHA256 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm RsaPss2048Sha256 { get; } = new PkixPublicKeySignatureAlgorithm("RSA_PSS_2048_SHA256");
        /// <summary>
        /// RSASSA-PSS 2048 bit key with a SHA256 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm RsaSignPss2048Sha256 { get; } = new PkixPublicKeySignatureAlgorithm("RSA_SIGN_PSS_2048_SHA256");
        /// <summary>
        /// RSASSA-PSS 3072 bit key with a SHA256 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm RsaPss3072Sha256 { get; } = new PkixPublicKeySignatureAlgorithm("RSA_PSS_3072_SHA256");
        /// <summary>
        /// RSASSA-PSS 3072 bit key with a SHA256 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm RsaSignPss3072Sha256 { get; } = new PkixPublicKeySignatureAlgorithm("RSA_SIGN_PSS_3072_SHA256");
        /// <summary>
        /// RSASSA-PSS 4096 bit key with a SHA256 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm RsaPss4096Sha256 { get; } = new PkixPublicKeySignatureAlgorithm("RSA_PSS_4096_SHA256");
        /// <summary>
        /// RSASSA-PSS 4096 bit key with a SHA256 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm RsaSignPss4096Sha256 { get; } = new PkixPublicKeySignatureAlgorithm("RSA_SIGN_PSS_4096_SHA256");
        /// <summary>
        /// RSASSA-PSS 4096 bit key with a SHA512 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm RsaPss4096Sha512 { get; } = new PkixPublicKeySignatureAlgorithm("RSA_PSS_4096_SHA512");
        /// <summary>
        /// RSASSA-PSS 4096 bit key with a SHA512 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm RsaSignPss4096Sha512 { get; } = new PkixPublicKeySignatureAlgorithm("RSA_SIGN_PSS_4096_SHA512");
        /// <summary>
        /// RSASSA-PKCS1-v1_5 with a 2048 bit key and a SHA256 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm RsaSignPkcs12048Sha256 { get; } = new PkixPublicKeySignatureAlgorithm("RSA_SIGN_PKCS1_2048_SHA256");
        /// <summary>
        /// RSASSA-PKCS1-v1_5 with a 3072 bit key and a SHA256 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm RsaSignPkcs13072Sha256 { get; } = new PkixPublicKeySignatureAlgorithm("RSA_SIGN_PKCS1_3072_SHA256");
        /// <summary>
        /// RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA256 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm RsaSignPkcs14096Sha256 { get; } = new PkixPublicKeySignatureAlgorithm("RSA_SIGN_PKCS1_4096_SHA256");
        /// <summary>
        /// RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA512 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm RsaSignPkcs14096Sha512 { get; } = new PkixPublicKeySignatureAlgorithm("RSA_SIGN_PKCS1_4096_SHA512");
        /// <summary>
        /// ECDSA on the NIST P-256 curve with a SHA256 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm EcdsaP256Sha256 { get; } = new PkixPublicKeySignatureAlgorithm("ECDSA_P256_SHA256");
        /// <summary>
        /// ECDSA on the NIST P-256 curve with a SHA256 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm EcSignP256Sha256 { get; } = new PkixPublicKeySignatureAlgorithm("EC_SIGN_P256_SHA256");
        /// <summary>
        /// ECDSA on the NIST P-384 curve with a SHA384 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm EcdsaP384Sha384 { get; } = new PkixPublicKeySignatureAlgorithm("ECDSA_P384_SHA384");
        /// <summary>
        /// ECDSA on the NIST P-384 curve with a SHA384 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm EcSignP384Sha384 { get; } = new PkixPublicKeySignatureAlgorithm("EC_SIGN_P384_SHA384");
        /// <summary>
        /// ECDSA on the NIST P-521 curve with a SHA512 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm EcdsaP521Sha512 { get; } = new PkixPublicKeySignatureAlgorithm("ECDSA_P521_SHA512");
        /// <summary>
        /// ECDSA on the NIST P-521 curve with a SHA512 digest.
        /// </summary>
        public static PkixPublicKeySignatureAlgorithm EcSignP521Sha512 { get; } = new PkixPublicKeySignatureAlgorithm("EC_SIGN_P521_SHA512");

        public static bool operator ==(PkixPublicKeySignatureAlgorithm left, PkixPublicKeySignatureAlgorithm right) => left.Equals(right);
        public static bool operator !=(PkixPublicKeySignatureAlgorithm left, PkixPublicKeySignatureAlgorithm right) => !left.Equals(right);

        public static explicit operator string(PkixPublicKeySignatureAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PkixPublicKeySignatureAlgorithm other && Equals(other);
        public bool Equals(PkixPublicKeySignatureAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don't need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
    /// </summary>
    [EnumType]
    public readonly struct VerificationRuleTrustedBuilder : IEquatable<VerificationRuleTrustedBuilder>
    {
        private readonly string _value;

        private VerificationRuleTrustedBuilder(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Should never happen.
        /// </summary>
        public static VerificationRuleTrustedBuilder BuilderUnspecified { get; } = new VerificationRuleTrustedBuilder("BUILDER_UNSPECIFIED");
        /// <summary>
        /// The whole Google Cloud Build (GCB) builder group, including all GCB builder types.
        /// </summary>
        public static VerificationRuleTrustedBuilder GoogleCloudBuild { get; } = new VerificationRuleTrustedBuilder("GOOGLE_CLOUD_BUILD");

        public static bool operator ==(VerificationRuleTrustedBuilder left, VerificationRuleTrustedBuilder right) => left.Equals(right);
        public static bool operator !=(VerificationRuleTrustedBuilder left, VerificationRuleTrustedBuilder right) => !left.Equals(right);

        public static explicit operator string(VerificationRuleTrustedBuilder value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VerificationRuleTrustedBuilder other && Equals(other);
        public bool Equals(VerificationRuleTrustedBuilder other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The threshold for severity for which a fix is currently available. This field is required and must be set.
    /// </summary>
    [EnumType]
    public readonly struct VulnerabilityCheckMaximumFixableSeverity : IEquatable<VulnerabilityCheckMaximumFixableSeverity>
    {
        private readonly string _value;

        private VulnerabilityCheckMaximumFixableSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified.
        /// </summary>
        public static VulnerabilityCheckMaximumFixableSeverity MaximumAllowedSeverityUnspecified { get; } = new VulnerabilityCheckMaximumFixableSeverity("MAXIMUM_ALLOWED_SEVERITY_UNSPECIFIED");
        /// <summary>
        /// Block any vulnerability.
        /// </summary>
        public static VulnerabilityCheckMaximumFixableSeverity BlockAll { get; } = new VulnerabilityCheckMaximumFixableSeverity("BLOCK_ALL");
        /// <summary>
        /// Allow only minimal severity.
        /// </summary>
        public static VulnerabilityCheckMaximumFixableSeverity Minimal { get; } = new VulnerabilityCheckMaximumFixableSeverity("MINIMAL");
        /// <summary>
        /// Allow only low severity and lower.
        /// </summary>
        public static VulnerabilityCheckMaximumFixableSeverity Low { get; } = new VulnerabilityCheckMaximumFixableSeverity("LOW");
        /// <summary>
        /// Allow medium severity and lower.
        /// </summary>
        public static VulnerabilityCheckMaximumFixableSeverity Medium { get; } = new VulnerabilityCheckMaximumFixableSeverity("MEDIUM");
        /// <summary>
        /// Allow high severity and lower.
        /// </summary>
        public static VulnerabilityCheckMaximumFixableSeverity High { get; } = new VulnerabilityCheckMaximumFixableSeverity("HIGH");
        /// <summary>
        /// Allow critical severity and lower.
        /// </summary>
        public static VulnerabilityCheckMaximumFixableSeverity Critical { get; } = new VulnerabilityCheckMaximumFixableSeverity("CRITICAL");
        /// <summary>
        /// Allow all severity, even vulnerability with unspecified severity.
        /// </summary>
        public static VulnerabilityCheckMaximumFixableSeverity AllowAll { get; } = new VulnerabilityCheckMaximumFixableSeverity("ALLOW_ALL");

        public static bool operator ==(VulnerabilityCheckMaximumFixableSeverity left, VulnerabilityCheckMaximumFixableSeverity right) => left.Equals(right);
        public static bool operator !=(VulnerabilityCheckMaximumFixableSeverity left, VulnerabilityCheckMaximumFixableSeverity right) => !left.Equals(right);

        public static explicit operator string(VulnerabilityCheckMaximumFixableSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VulnerabilityCheckMaximumFixableSeverity other && Equals(other);
        public bool Equals(VulnerabilityCheckMaximumFixableSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The threshold for severity for which a fix isn't currently available. This field is required and must be set.
    /// </summary>
    [EnumType]
    public readonly struct VulnerabilityCheckMaximumUnfixableSeverity : IEquatable<VulnerabilityCheckMaximumUnfixableSeverity>
    {
        private readonly string _value;

        private VulnerabilityCheckMaximumUnfixableSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified.
        /// </summary>
        public static VulnerabilityCheckMaximumUnfixableSeverity MaximumAllowedSeverityUnspecified { get; } = new VulnerabilityCheckMaximumUnfixableSeverity("MAXIMUM_ALLOWED_SEVERITY_UNSPECIFIED");
        /// <summary>
        /// Block any vulnerability.
        /// </summary>
        public static VulnerabilityCheckMaximumUnfixableSeverity BlockAll { get; } = new VulnerabilityCheckMaximumUnfixableSeverity("BLOCK_ALL");
        /// <summary>
        /// Allow only minimal severity.
        /// </summary>
        public static VulnerabilityCheckMaximumUnfixableSeverity Minimal { get; } = new VulnerabilityCheckMaximumUnfixableSeverity("MINIMAL");
        /// <summary>
        /// Allow only low severity and lower.
        /// </summary>
        public static VulnerabilityCheckMaximumUnfixableSeverity Low { get; } = new VulnerabilityCheckMaximumUnfixableSeverity("LOW");
        /// <summary>
        /// Allow medium severity and lower.
        /// </summary>
        public static VulnerabilityCheckMaximumUnfixableSeverity Medium { get; } = new VulnerabilityCheckMaximumUnfixableSeverity("MEDIUM");
        /// <summary>
        /// Allow high severity and lower.
        /// </summary>
        public static VulnerabilityCheckMaximumUnfixableSeverity High { get; } = new VulnerabilityCheckMaximumUnfixableSeverity("HIGH");
        /// <summary>
        /// Allow critical severity and lower.
        /// </summary>
        public static VulnerabilityCheckMaximumUnfixableSeverity Critical { get; } = new VulnerabilityCheckMaximumUnfixableSeverity("CRITICAL");
        /// <summary>
        /// Allow all severity, even vulnerability with unspecified severity.
        /// </summary>
        public static VulnerabilityCheckMaximumUnfixableSeverity AllowAll { get; } = new VulnerabilityCheckMaximumUnfixableSeverity("ALLOW_ALL");

        public static bool operator ==(VulnerabilityCheckMaximumUnfixableSeverity left, VulnerabilityCheckMaximumUnfixableSeverity right) => left.Equals(right);
        public static bool operator !=(VulnerabilityCheckMaximumUnfixableSeverity left, VulnerabilityCheckMaximumUnfixableSeverity right) => !left.Equals(right);

        public static explicit operator string(VulnerabilityCheckMaximumUnfixableSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VulnerabilityCheckMaximumUnfixableSeverity other && Equals(other);
        public bool Equals(VulnerabilityCheckMaximumUnfixableSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.GoogleNative.NetworkConnectivity.V1
{
    /// <summary>
    /// Creates a new policy-based route in a given project and location.
    /// Auto-naming is currently not supported for this resource.
    /// </summary>
    [GoogleNativeResourceType("google-native:networkconnectivity/v1:PolicyBasedRoute")]
    public partial class PolicyBasedRoute : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Time when the policy-based route was created.
        /// </summary>
        [Output("createTime")]
        public Output<string> CreateTime { get; private set; } = null!;

        /// <summary>
        /// Optional. An optional description of this resource. Provide this field when you create the resource.
        /// </summary>
        [Output("description")]
        public Output<string> Description { get; private set; } = null!;

        /// <summary>
        /// The filter to match L4 traffic.
        /// </summary>
        [Output("filter")]
        public Output<Outputs.FilterResponse> Filter { get; private set; } = null!;

        /// <summary>
        /// Optional. The interconnect attachments that this policy-based route applies to.
        /// </summary>
        [Output("interconnectAttachment")]
        public Output<Outputs.InterconnectAttachmentResponse> InterconnectAttachment { get; private set; } = null!;

        /// <summary>
        /// Type of this resource. Always networkconnectivity#policyBasedRoute for policy-based Route resources.
        /// </summary>
        [Output("kind")]
        public Output<string> Kind { get; private set; } = null!;

        /// <summary>
        /// User-defined labels.
        /// </summary>
        [Output("labels")]
        public Output<ImmutableDictionary<string, string>> Labels { get; private set; } = null!;

        /// <summary>
        /// Immutable. A unique name of the resource in the form of `projects/{project_number}/locations/global/PolicyBasedRoutes/{policy_based_route_id}`
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Fully-qualified URL of the network that this route applies to, for example: projects/my-project/global/networks/my-network.
        /// </summary>
        [Output("network")]
        public Output<string> Network { get; private set; } = null!;

        /// <summary>
        /// Optional. The IP address of a global-access-enabled L4 ILB that is the next hop for matching packets. For this version, only nextHopIlbIp is supported.
        /// </summary>
        [Output("nextHopIlbIp")]
        public Output<string> NextHopIlbIp { get; private set; } = null!;

        /// <summary>
        /// Optional. Other routes that will be referenced to determine the next hop of the packet.
        /// </summary>
        [Output("nextHopOtherRoutes")]
        public Output<string> NextHopOtherRoutes { get; private set; } = null!;

        /// <summary>
        /// Required. Unique id for the policy-based route to create.
        /// </summary>
        [Output("policyBasedRouteId")]
        public Output<string> PolicyBasedRouteId { get; private set; } = null!;

        /// <summary>
        /// Optional. The priority of this policy-based route. Priority is used to break ties in cases where there are more than one matching policy-based routes found. In cases where multiple policy-based routes are matched, the one with the lowest-numbered priority value wins. The default value is 1000. The priority value must be from 1 to 65535, inclusive.
        /// </summary>
        [Output("priority")]
        public Output<int> Priority { get; private set; } = null!;

        [Output("project")]
        public Output<string> Project { get; private set; } = null!;

        /// <summary>
        /// Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
        /// </summary>
        [Output("requestId")]
        public Output<string?> RequestId { get; private set; } = null!;

        /// <summary>
        /// Server-defined fully-qualified URL for this resource.
        /// </summary>
        [Output("selfLink")]
        public Output<string> SelfLink { get; private set; } = null!;

        /// <summary>
        /// Time when the policy-based route was updated.
        /// </summary>
        [Output("updateTime")]
        public Output<string> UpdateTime { get; private set; } = null!;

        /// <summary>
        /// Optional. VM instances to which this policy-based route applies to.
        /// </summary>
        [Output("virtualMachine")]
        public Output<Outputs.VirtualMachineResponse> VirtualMachine { get; private set; } = null!;

        /// <summary>
        /// If potential misconfigurations are detected for this route, this field will be populated with warning messages.
        /// </summary>
        [Output("warnings")]
        public Output<ImmutableArray<Outputs.WarningsResponse>> Warnings { get; private set; } = null!;


        /// <summary>
        /// Create a PolicyBasedRoute resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public PolicyBasedRoute(string name, PolicyBasedRouteArgs args, CustomResourceOptions? options = null)
            : base("google-native:networkconnectivity/v1:PolicyBasedRoute", name, args ?? new PolicyBasedRouteArgs(), MakeResourceOptions(options, ""))
        {
        }

        private PolicyBasedRoute(string name, Input<string> id, CustomResourceOptions? options = null)
            : base("google-native:networkconnectivity/v1:PolicyBasedRoute", name, null, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                ReplaceOnChanges =
                {
                    "policyBasedRouteId",
                    "project",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing PolicyBasedRoute resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static PolicyBasedRoute Get(string name, Input<string> id, CustomResourceOptions? options = null)
        {
            return new PolicyBasedRoute(name, id, options);
        }
    }

    public sealed class PolicyBasedRouteArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Optional. An optional description of this resource. Provide this field when you create the resource.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The filter to match L4 traffic.
        /// </summary>
        [Input("filter", required: true)]
        public Input<Inputs.FilterArgs> Filter { get; set; } = null!;

        /// <summary>
        /// Optional. The interconnect attachments that this policy-based route applies to.
        /// </summary>
        [Input("interconnectAttachment")]
        public Input<Inputs.InterconnectAttachmentArgs>? InterconnectAttachment { get; set; }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// User-defined labels.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// Immutable. A unique name of the resource in the form of `projects/{project_number}/locations/global/PolicyBasedRoutes/{policy_based_route_id}`
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Fully-qualified URL of the network that this route applies to, for example: projects/my-project/global/networks/my-network.
        /// </summary>
        [Input("network", required: true)]
        public Input<string> Network { get; set; } = null!;

        /// <summary>
        /// Optional. The IP address of a global-access-enabled L4 ILB that is the next hop for matching packets. For this version, only nextHopIlbIp is supported.
        /// </summary>
        [Input("nextHopIlbIp")]
        public Input<string>? NextHopIlbIp { get; set; }

        /// <summary>
        /// Optional. Other routes that will be referenced to determine the next hop of the packet.
        /// </summary>
        [Input("nextHopOtherRoutes")]
        public Input<Pulumi.GoogleNative.NetworkConnectivity.V1.PolicyBasedRouteNextHopOtherRoutes>? NextHopOtherRoutes { get; set; }

        /// <summary>
        /// Required. Unique id for the policy-based route to create.
        /// </summary>
        [Input("policyBasedRouteId", required: true)]
        public Input<string> PolicyBasedRouteId { get; set; } = null!;

        /// <summary>
        /// Optional. The priority of this policy-based route. Priority is used to break ties in cases where there are more than one matching policy-based routes found. In cases where multiple policy-based routes are matched, the one with the lowest-numbered priority value wins. The default value is 1000. The priority value must be from 1 to 65535, inclusive.
        /// </summary>
        [Input("priority")]
        public Input<int>? Priority { get; set; }

        [Input("project")]
        public Input<string>? Project { get; set; }

        /// <summary>
        /// Optional. An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
        /// </summary>
        [Input("requestId")]
        public Input<string>? RequestId { get; set; }

        /// <summary>
        /// Optional. VM instances to which this policy-based route applies to.
        /// </summary>
        [Input("virtualMachine")]
        public Input<Inputs.VirtualMachineArgs>? VirtualMachine { get; set; }

        public PolicyBasedRouteArgs()
        {
        }
        public static new PolicyBasedRouteArgs Empty => new PolicyBasedRouteArgs();
    }
}

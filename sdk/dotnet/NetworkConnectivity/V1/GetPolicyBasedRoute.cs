// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.GoogleNative.NetworkConnectivity.V1
{
    public static class GetPolicyBasedRoute
    {
        /// <summary>
        /// Gets details of a single policy-based route.
        /// </summary>
        public static Task<GetPolicyBasedRouteResult> InvokeAsync(GetPolicyBasedRouteArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.InvokeAsync<GetPolicyBasedRouteResult>("google-native:networkconnectivity/v1:getPolicyBasedRoute", args ?? new GetPolicyBasedRouteArgs(), options.WithDefaults());

        /// <summary>
        /// Gets details of a single policy-based route.
        /// </summary>
        public static Output<GetPolicyBasedRouteResult> Invoke(GetPolicyBasedRouteInvokeArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.Invoke<GetPolicyBasedRouteResult>("google-native:networkconnectivity/v1:getPolicyBasedRoute", args ?? new GetPolicyBasedRouteInvokeArgs(), options.WithDefaults());
    }


    public sealed class GetPolicyBasedRouteArgs : global::Pulumi.InvokeArgs
    {
        [Input("policyBasedRouteId", required: true)]
        public string PolicyBasedRouteId { get; set; } = null!;

        [Input("project")]
        public string? Project { get; set; }

        public GetPolicyBasedRouteArgs()
        {
        }
        public static new GetPolicyBasedRouteArgs Empty => new GetPolicyBasedRouteArgs();
    }

    public sealed class GetPolicyBasedRouteInvokeArgs : global::Pulumi.InvokeArgs
    {
        [Input("policyBasedRouteId", required: true)]
        public Input<string> PolicyBasedRouteId { get; set; } = null!;

        [Input("project")]
        public Input<string>? Project { get; set; }

        public GetPolicyBasedRouteInvokeArgs()
        {
        }
        public static new GetPolicyBasedRouteInvokeArgs Empty => new GetPolicyBasedRouteInvokeArgs();
    }


    [OutputType]
    public sealed class GetPolicyBasedRouteResult
    {
        /// <summary>
        /// Time when the policy-based route was created.
        /// </summary>
        public readonly string CreateTime;
        /// <summary>
        /// Optional. An optional description of this resource. Provide this field when you create the resource.
        /// </summary>
        public readonly string Description;
        /// <summary>
        /// The filter to match L4 traffic.
        /// </summary>
        public readonly Outputs.FilterResponse Filter;
        /// <summary>
        /// Optional. The interconnect attachments that this policy-based route applies to.
        /// </summary>
        public readonly Outputs.InterconnectAttachmentResponse InterconnectAttachment;
        /// <summary>
        /// Type of this resource. Always networkconnectivity#policyBasedRoute for policy-based Route resources.
        /// </summary>
        public readonly string Kind;
        /// <summary>
        /// User-defined labels.
        /// </summary>
        public readonly ImmutableDictionary<string, string> Labels;
        /// <summary>
        /// Immutable. A unique name of the resource in the form of `projects/{project_number}/locations/global/PolicyBasedRoutes/{policy_based_route_id}`
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// Fully-qualified URL of the network that this route applies to, for example: projects/my-project/global/networks/my-network.
        /// </summary>
        public readonly string Network;
        /// <summary>
        /// Optional. The IP address of a global-access-enabled L4 ILB that is the next hop for matching packets. For this version, only nextHopIlbIp is supported.
        /// </summary>
        public readonly string NextHopIlbIp;
        /// <summary>
        /// Optional. Other routes that will be referenced to determine the next hop of the packet.
        /// </summary>
        public readonly string NextHopOtherRoutes;
        /// <summary>
        /// Optional. The priority of this policy-based route. Priority is used to break ties in cases where there are more than one matching policy-based routes found. In cases where multiple policy-based routes are matched, the one with the lowest-numbered priority value wins. The default value is 1000. The priority value must be from 1 to 65535, inclusive.
        /// </summary>
        public readonly int Priority;
        /// <summary>
        /// Server-defined fully-qualified URL for this resource.
        /// </summary>
        public readonly string SelfLink;
        /// <summary>
        /// Time when the policy-based route was updated.
        /// </summary>
        public readonly string UpdateTime;
        /// <summary>
        /// Optional. VM instances to which this policy-based route applies to.
        /// </summary>
        public readonly Outputs.VirtualMachineResponse VirtualMachine;
        /// <summary>
        /// If potential misconfigurations are detected for this route, this field will be populated with warning messages.
        /// </summary>
        public readonly ImmutableArray<Outputs.WarningsResponse> Warnings;

        [OutputConstructor]
        private GetPolicyBasedRouteResult(
            string createTime,

            string description,

            Outputs.FilterResponse filter,

            Outputs.InterconnectAttachmentResponse interconnectAttachment,

            string kind,

            ImmutableDictionary<string, string> labels,

            string name,

            string network,

            string nextHopIlbIp,

            string nextHopOtherRoutes,

            int priority,

            string selfLink,

            string updateTime,

            Outputs.VirtualMachineResponse virtualMachine,

            ImmutableArray<Outputs.WarningsResponse> warnings)
        {
            CreateTime = createTime;
            Description = description;
            Filter = filter;
            InterconnectAttachment = interconnectAttachment;
            Kind = kind;
            Labels = labels;
            Name = name;
            Network = network;
            NextHopIlbIp = nextHopIlbIp;
            NextHopOtherRoutes = nextHopOtherRoutes;
            Priority = priority;
            SelfLink = selfLink;
            UpdateTime = updateTime;
            VirtualMachine = virtualMachine;
            Warnings = warnings;
        }
    }
}

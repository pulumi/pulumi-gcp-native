// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.NetworkSecurity.V1
{
    /// <summary>
    /// Required. The type of the Address Group. Possible values are "IPv4" or "IPV6".
    /// </summary>
    [EnumType]
    public readonly struct AddressGroupType : IEquatable<AddressGroupType>
    {
        private readonly string _value;

        private AddressGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static AddressGroupType TypeUnspecified { get; } = new AddressGroupType("TYPE_UNSPECIFIED");
        /// <summary>
        /// IP v4 ranges.
        /// </summary>
        public static AddressGroupType Ipv4 { get; } = new AddressGroupType("IPV4");
        /// <summary>
        /// IP v6 ranges.
        /// </summary>
        public static AddressGroupType Ipv6 { get; } = new AddressGroupType("IPV6");

        public static bool operator ==(AddressGroupType left, AddressGroupType right) => left.Equals(right);
        public static bool operator !=(AddressGroupType left, AddressGroupType right) => !left.Equals(right);

        public static explicit operator string(AddressGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AddressGroupType other && Equals(other);
        public bool Equals(AddressGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The action to take when a rule match is found. Possible values are "ALLOW" or "DENY".
    /// </summary>
    [EnumType]
    public readonly struct AuthorizationPolicyAction : IEquatable<AuthorizationPolicyAction>
    {
        private readonly string _value;

        private AuthorizationPolicyAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static AuthorizationPolicyAction ActionUnspecified { get; } = new AuthorizationPolicyAction("ACTION_UNSPECIFIED");
        /// <summary>
        /// Grant access.
        /// </summary>
        public static AuthorizationPolicyAction Allow { get; } = new AuthorizationPolicyAction("ALLOW");
        /// <summary>
        /// Deny access. Deny rules should be avoided unless they are used to provide a default "deny all" fallback.
        /// </summary>
        public static AuthorizationPolicyAction Deny { get; } = new AuthorizationPolicyAction("DENY");

        public static bool operator ==(AuthorizationPolicyAction left, AuthorizationPolicyAction right) => left.Equals(right);
        public static bool operator !=(AuthorizationPolicyAction left, AuthorizationPolicyAction right) => !left.Equals(right);

        public static explicit operator string(AuthorizationPolicyAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuthorizationPolicyAction other && Equals(other);
        public bool Equals(AuthorizationPolicyAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct GoogleIamV1AuditLogConfigLogType : IEquatable<GoogleIamV1AuditLogConfigLogType>
    {
        private readonly string _value;

        private GoogleIamV1AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default case. Should never be this.
        /// </summary>
        public static GoogleIamV1AuditLogConfigLogType LogTypeUnspecified { get; } = new GoogleIamV1AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");
        /// <summary>
        /// Admin reads. Example: CloudIAM getIamPolicy
        /// </summary>
        public static GoogleIamV1AuditLogConfigLogType AdminRead { get; } = new GoogleIamV1AuditLogConfigLogType("ADMIN_READ");
        /// <summary>
        /// Data writes. Example: CloudSQL Users create
        /// </summary>
        public static GoogleIamV1AuditLogConfigLogType DataWrite { get; } = new GoogleIamV1AuditLogConfigLogType("DATA_WRITE");
        /// <summary>
        /// Data reads. Example: CloudSQL Users list
        /// </summary>
        public static GoogleIamV1AuditLogConfigLogType DataRead { get; } = new GoogleIamV1AuditLogConfigLogType("DATA_READ");

        public static bool operator ==(GoogleIamV1AuditLogConfigLogType left, GoogleIamV1AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(GoogleIamV1AuditLogConfigLogType left, GoogleIamV1AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(GoogleIamV1AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GoogleIamV1AuditLogConfigLogType other && Equals(other);
        public bool Equals(GoogleIamV1AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// When the client presents an invalid certificate or no certificate to the load balancer, the `client_validation_mode` specifies how the client connection is handled. Required if the policy is to be used with the external HTTPS load balancing. For Traffic Director it must be empty.
    /// </summary>
    [EnumType]
    public readonly struct MTLSPolicyClientValidationMode : IEquatable<MTLSPolicyClientValidationMode>
    {
        private readonly string _value;

        private MTLSPolicyClientValidationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not allowed.
        /// </summary>
        public static MTLSPolicyClientValidationMode ClientValidationModeUnspecified { get; } = new MTLSPolicyClientValidationMode("CLIENT_VALIDATION_MODE_UNSPECIFIED");
        /// <summary>
        /// Allow connection even if certificate chain validation of the client certificate failed or no client certificate was presented. The proof of possession of the private key is always checked if client certificate was presented. This mode requires the backend to implement processing of data extracted from a client certificate to authenticate the peer, or to reject connections if the client certificate fingerprint is missing.
        /// </summary>
        public static MTLSPolicyClientValidationMode AllowInvalidOrMissingClientCert { get; } = new MTLSPolicyClientValidationMode("ALLOW_INVALID_OR_MISSING_CLIENT_CERT");
        /// <summary>
        /// Require a client certificate and allow connection to the backend only if validation of the client certificate passed. If set, requires a reference to non-empty TrustConfig specified in `client_validation_trust_config`.
        /// </summary>
        public static MTLSPolicyClientValidationMode RejectInvalid { get; } = new MTLSPolicyClientValidationMode("REJECT_INVALID");

        public static bool operator ==(MTLSPolicyClientValidationMode left, MTLSPolicyClientValidationMode right) => left.Equals(right);
        public static bool operator !=(MTLSPolicyClientValidationMode left, MTLSPolicyClientValidationMode right) => !left.Equals(right);

        public static explicit operator string(MTLSPolicyClientValidationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MTLSPolicyClientValidationMode other && Equals(other);
        public bool Equals(MTLSPolicyClientValidationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The type of the Address Group. Possible values are "IPv4" or "IPV6".
    /// </summary>
    [EnumType]
    public readonly struct OrganizationAddressGroupType : IEquatable<OrganizationAddressGroupType>
    {
        private readonly string _value;

        private OrganizationAddressGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static OrganizationAddressGroupType TypeUnspecified { get; } = new OrganizationAddressGroupType("TYPE_UNSPECIFIED");
        /// <summary>
        /// IP v4 ranges.
        /// </summary>
        public static OrganizationAddressGroupType Ipv4 { get; } = new OrganizationAddressGroupType("IPV4");
        /// <summary>
        /// IP v6 ranges.
        /// </summary>
        public static OrganizationAddressGroupType Ipv6 { get; } = new OrganizationAddressGroupType("IPV6");

        public static bool operator ==(OrganizationAddressGroupType left, OrganizationAddressGroupType right) => left.Equals(right);
        public static bool operator !=(OrganizationAddressGroupType left, OrganizationAddressGroupType right) => !left.Equals(right);

        public static explicit operator string(OrganizationAddressGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OrganizationAddressGroupType other && Equals(other);
        public bool Equals(OrganizationAddressGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Profile which tells what the primitive action should be.
    /// </summary>
    [EnumType]
    public readonly struct RuleBasicProfile : IEquatable<RuleBasicProfile>
    {
        private readonly string _value;

        private RuleBasicProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// If there is not a mentioned action for the target.
        /// </summary>
        public static RuleBasicProfile BasicProfileUnspecified { get; } = new RuleBasicProfile("BASIC_PROFILE_UNSPECIFIED");
        /// <summary>
        /// Allow the matched traffic.
        /// </summary>
        public static RuleBasicProfile Allow { get; } = new RuleBasicProfile("ALLOW");
        /// <summary>
        /// Deny the matched traffic.
        /// </summary>
        public static RuleBasicProfile Deny { get; } = new RuleBasicProfile("DENY");

        public static bool operator ==(RuleBasicProfile left, RuleBasicProfile right) => left.Equals(right);
        public static bool operator !=(RuleBasicProfile left, RuleBasicProfile right) => !left.Equals(right);

        public static explicit operator string(RuleBasicProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleBasicProfile other && Equals(other);
        public bool Equals(RuleBasicProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Minimum TLS version that the firewall should use when negotiating connections with both clients and servers. If this is not set, then the default value is to allow the broadest set of clients and servers (TLS 1.0 or higher). Setting this to more restrictive values may improve security, but may also prevent the firewall from connecting to some clients or servers. Note that Secure Web Proxy does not yet honor this field.
    /// </summary>
    [EnumType]
    public readonly struct TlsInspectionPolicyMinTlsVersion : IEquatable<TlsInspectionPolicyMinTlsVersion>
    {
        private readonly string _value;

        private TlsInspectionPolicyMinTlsVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates no TLS version was specified.
        /// </summary>
        public static TlsInspectionPolicyMinTlsVersion TlsVersionUnspecified { get; } = new TlsInspectionPolicyMinTlsVersion("TLS_VERSION_UNSPECIFIED");
        /// <summary>
        /// TLS 1.0
        /// </summary>
        public static TlsInspectionPolicyMinTlsVersion Tls10 { get; } = new TlsInspectionPolicyMinTlsVersion("TLS_1_0");
        /// <summary>
        /// TLS 1.1
        /// </summary>
        public static TlsInspectionPolicyMinTlsVersion Tls11 { get; } = new TlsInspectionPolicyMinTlsVersion("TLS_1_1");
        /// <summary>
        /// TLS 1.2
        /// </summary>
        public static TlsInspectionPolicyMinTlsVersion Tls12 { get; } = new TlsInspectionPolicyMinTlsVersion("TLS_1_2");
        /// <summary>
        /// TLS 1.3
        /// </summary>
        public static TlsInspectionPolicyMinTlsVersion Tls13 { get; } = new TlsInspectionPolicyMinTlsVersion("TLS_1_3");

        public static bool operator ==(TlsInspectionPolicyMinTlsVersion left, TlsInspectionPolicyMinTlsVersion right) => left.Equals(right);
        public static bool operator !=(TlsInspectionPolicyMinTlsVersion left, TlsInspectionPolicyMinTlsVersion right) => !left.Equals(right);

        public static explicit operator string(TlsInspectionPolicyMinTlsVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TlsInspectionPolicyMinTlsVersion other && Equals(other);
        public bool Equals(TlsInspectionPolicyMinTlsVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The selected Profile. If this is not set, then the default value is to allow the broadest set of clients and servers ("PROFILE_COMPATIBLE"). Setting this to more restrictive values may improve security, but may also prevent the TLS inspection proxy from connecting to some clients or servers. Note that Secure Web Proxy does not yet honor this field.
    /// </summary>
    [EnumType]
    public readonly struct TlsInspectionPolicyTlsFeatureProfile : IEquatable<TlsInspectionPolicyTlsFeatureProfile>
    {
        private readonly string _value;

        private TlsInspectionPolicyTlsFeatureProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates no profile was specified.
        /// </summary>
        public static TlsInspectionPolicyTlsFeatureProfile ProfileUnspecified { get; } = new TlsInspectionPolicyTlsFeatureProfile("PROFILE_UNSPECIFIED");
        /// <summary>
        /// Compatible profile. Allows the broadest set of clients, even those which support only out-of-date SSL features to negotiate with the TLS inspection proxy.
        /// </summary>
        public static TlsInspectionPolicyTlsFeatureProfile ProfileCompatible { get; } = new TlsInspectionPolicyTlsFeatureProfile("PROFILE_COMPATIBLE");
        /// <summary>
        /// Modern profile. Supports a wide set of SSL features, allowing modern clients to negotiate SSL with the TLS inspection proxy.
        /// </summary>
        public static TlsInspectionPolicyTlsFeatureProfile ProfileModern { get; } = new TlsInspectionPolicyTlsFeatureProfile("PROFILE_MODERN");
        /// <summary>
        /// Restricted profile. Supports a reduced set of SSL features, intended to meet stricter compliance requirements.
        /// </summary>
        public static TlsInspectionPolicyTlsFeatureProfile ProfileRestricted { get; } = new TlsInspectionPolicyTlsFeatureProfile("PROFILE_RESTRICTED");
        /// <summary>
        /// Custom profile. Allow only the set of allowed SSL features specified in the custom_features field of SslPolicy.
        /// </summary>
        public static TlsInspectionPolicyTlsFeatureProfile ProfileCustom { get; } = new TlsInspectionPolicyTlsFeatureProfile("PROFILE_CUSTOM");

        public static bool operator ==(TlsInspectionPolicyTlsFeatureProfile left, TlsInspectionPolicyTlsFeatureProfile right) => left.Equals(right);
        public static bool operator !=(TlsInspectionPolicyTlsFeatureProfile left, TlsInspectionPolicyTlsFeatureProfile right) => !left.Equals(right);

        public static explicit operator string(TlsInspectionPolicyTlsFeatureProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TlsInspectionPolicyTlsFeatureProfile other && Equals(other);
        public bool Equals(TlsInspectionPolicyTlsFeatureProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.NetworkSecurity.V1Beta1
{
    /// <summary>
    /// Required. The type of the Address Group. Possible values are "IPv4" or "IPV6".
    /// </summary>
    [EnumType]
    public readonly struct AddressGroupType : IEquatable<AddressGroupType>
    {
        private readonly string _value;

        private AddressGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static AddressGroupType TypeUnspecified { get; } = new AddressGroupType("TYPE_UNSPECIFIED");
        /// <summary>
        /// IP v4 ranges.
        /// </summary>
        public static AddressGroupType Ipv4 { get; } = new AddressGroupType("IPV4");
        /// <summary>
        /// IP v6 ranges.
        /// </summary>
        public static AddressGroupType Ipv6 { get; } = new AddressGroupType("IPV6");

        public static bool operator ==(AddressGroupType left, AddressGroupType right) => left.Equals(right);
        public static bool operator !=(AddressGroupType left, AddressGroupType right) => !left.Equals(right);

        public static explicit operator string(AddressGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AddressGroupType other && Equals(other);
        public bool Equals(AddressGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The action to take when a rule match is found. Possible values are "ALLOW" or "DENY".
    /// </summary>
    [EnumType]
    public readonly struct AuthorizationPolicyAction : IEquatable<AuthorizationPolicyAction>
    {
        private readonly string _value;

        private AuthorizationPolicyAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static AuthorizationPolicyAction ActionUnspecified { get; } = new AuthorizationPolicyAction("ACTION_UNSPECIFIED");
        /// <summary>
        /// Grant access.
        /// </summary>
        public static AuthorizationPolicyAction Allow { get; } = new AuthorizationPolicyAction("ALLOW");
        /// <summary>
        /// Deny access. Deny rules should be avoided unless they are used to provide a default "deny all" fallback.
        /// </summary>
        public static AuthorizationPolicyAction Deny { get; } = new AuthorizationPolicyAction("DENY");

        public static bool operator ==(AuthorizationPolicyAction left, AuthorizationPolicyAction right) => left.Equals(right);
        public static bool operator !=(AuthorizationPolicyAction left, AuthorizationPolicyAction right) => !left.Equals(right);

        public static explicit operator string(AuthorizationPolicyAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuthorizationPolicyAction other && Equals(other);
        public bool Equals(AuthorizationPolicyAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct GoogleIamV1AuditLogConfigLogType : IEquatable<GoogleIamV1AuditLogConfigLogType>
    {
        private readonly string _value;

        private GoogleIamV1AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default case. Should never be this.
        /// </summary>
        public static GoogleIamV1AuditLogConfigLogType LogTypeUnspecified { get; } = new GoogleIamV1AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");
        /// <summary>
        /// Admin reads. Example: CloudIAM getIamPolicy
        /// </summary>
        public static GoogleIamV1AuditLogConfigLogType AdminRead { get; } = new GoogleIamV1AuditLogConfigLogType("ADMIN_READ");
        /// <summary>
        /// Data writes. Example: CloudSQL Users create
        /// </summary>
        public static GoogleIamV1AuditLogConfigLogType DataWrite { get; } = new GoogleIamV1AuditLogConfigLogType("DATA_WRITE");
        /// <summary>
        /// Data reads. Example: CloudSQL Users list
        /// </summary>
        public static GoogleIamV1AuditLogConfigLogType DataRead { get; } = new GoogleIamV1AuditLogConfigLogType("DATA_READ");

        public static bool operator ==(GoogleIamV1AuditLogConfigLogType left, GoogleIamV1AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(GoogleIamV1AuditLogConfigLogType left, GoogleIamV1AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(GoogleIamV1AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GoogleIamV1AuditLogConfigLogType other && Equals(other);
        public bool Equals(GoogleIamV1AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// When the client presents an invalid certificate or no certificate to the load balancer, the `client_validation_mode` specifies how the client connection is handled. Required if the policy is to be used with the external HTTPS load balancing. For Traffic Director it must be empty.
    /// </summary>
    [EnumType]
    public readonly struct MTLSPolicyClientValidationMode : IEquatable<MTLSPolicyClientValidationMode>
    {
        private readonly string _value;

        private MTLSPolicyClientValidationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not allowed.
        /// </summary>
        public static MTLSPolicyClientValidationMode ClientValidationModeUnspecified { get; } = new MTLSPolicyClientValidationMode("CLIENT_VALIDATION_MODE_UNSPECIFIED");
        /// <summary>
        /// Allow connection even if certificate chain validation of the client certificate failed or no client certificate was presented. The proof of possession of the private key is always checked if client certificate was presented. This mode requires the backend to implement processing of data extracted from a client certificate to authenticate the peer, or to reject connections if the client certificate fingerprint is missing.
        /// </summary>
        public static MTLSPolicyClientValidationMode AllowInvalidOrMissingClientCert { get; } = new MTLSPolicyClientValidationMode("ALLOW_INVALID_OR_MISSING_CLIENT_CERT");
        /// <summary>
        /// Require a client certificate and allow connection to the backend only if validation of the client certificate passed. If set, requires a reference to non-empty TrustConfig specified in `client_validation_trust_config`.
        /// </summary>
        public static MTLSPolicyClientValidationMode RejectInvalid { get; } = new MTLSPolicyClientValidationMode("REJECT_INVALID");

        public static bool operator ==(MTLSPolicyClientValidationMode left, MTLSPolicyClientValidationMode right) => left.Equals(right);
        public static bool operator !=(MTLSPolicyClientValidationMode left, MTLSPolicyClientValidationMode right) => !left.Equals(right);

        public static explicit operator string(MTLSPolicyClientValidationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MTLSPolicyClientValidationMode other && Equals(other);
        public bool Equals(MTLSPolicyClientValidationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The type of the Address Group. Possible values are "IPv4" or "IPV6".
    /// </summary>
    [EnumType]
    public readonly struct OrganizationAddressGroupType : IEquatable<OrganizationAddressGroupType>
    {
        private readonly string _value;

        private OrganizationAddressGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static OrganizationAddressGroupType TypeUnspecified { get; } = new OrganizationAddressGroupType("TYPE_UNSPECIFIED");
        /// <summary>
        /// IP v4 ranges.
        /// </summary>
        public static OrganizationAddressGroupType Ipv4 { get; } = new OrganizationAddressGroupType("IPV4");
        /// <summary>
        /// IP v6 ranges.
        /// </summary>
        public static OrganizationAddressGroupType Ipv6 { get; } = new OrganizationAddressGroupType("IPV6");

        public static bool operator ==(OrganizationAddressGroupType left, OrganizationAddressGroupType right) => left.Equals(right);
        public static bool operator !=(OrganizationAddressGroupType left, OrganizationAddressGroupType right) => !left.Equals(right);

        public static explicit operator string(OrganizationAddressGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OrganizationAddressGroupType other && Equals(other);
        public bool Equals(OrganizationAddressGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Profile which tells what the primitive action should be.
    /// </summary>
    [EnumType]
    public readonly struct RuleBasicProfile : IEquatable<RuleBasicProfile>
    {
        private readonly string _value;

        private RuleBasicProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// If there is not a mentioned action for the target.
        /// </summary>
        public static RuleBasicProfile BasicProfileUnspecified { get; } = new RuleBasicProfile("BASIC_PROFILE_UNSPECIFIED");
        /// <summary>
        /// Allow the matched traffic.
        /// </summary>
        public static RuleBasicProfile Allow { get; } = new RuleBasicProfile("ALLOW");
        /// <summary>
        /// Deny the matched traffic.
        /// </summary>
        public static RuleBasicProfile Deny { get; } = new RuleBasicProfile("DENY");

        public static bool operator ==(RuleBasicProfile left, RuleBasicProfile right) => left.Equals(right);
        public static bool operator !=(RuleBasicProfile left, RuleBasicProfile right) => !left.Equals(right);

        public static explicit operator string(RuleBasicProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleBasicProfile other && Equals(other);
        public bool Equals(RuleBasicProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

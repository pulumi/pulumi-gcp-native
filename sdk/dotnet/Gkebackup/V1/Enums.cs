// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Gkebackup.V1
{
    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct AuditLogConfigLogType : IEquatable<AuditLogConfigLogType>
    {
        private readonly string _value;

        private AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default case. Should never be this.
        /// </summary>
        public static AuditLogConfigLogType LogTypeUnspecified { get; } = new AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");
        /// <summary>
        /// Admin reads. Example: CloudIAM getIamPolicy
        /// </summary>
        public static AuditLogConfigLogType AdminRead { get; } = new AuditLogConfigLogType("ADMIN_READ");
        /// <summary>
        /// Data writes. Example: CloudSQL Users create
        /// </summary>
        public static AuditLogConfigLogType DataWrite { get; } = new AuditLogConfigLogType("DATA_WRITE");
        /// <summary>
        /// Data reads. Example: CloudSQL Users list
        /// </summary>
        public static AuditLogConfigLogType DataRead { get; } = new AuditLogConfigLogType("DATA_READ");

        public static bool operator ==(AuditLogConfigLogType left, AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(AuditLogConfigLogType left, AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuditLogConfigLogType other && Equals(other);
        public bool Equals(AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines the behavior for handling the situation where cluster-scoped resources being restored already exist in the target cluster. This MUST be set to a value other than CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED if cluster_resource_restore_scope is not empty.
    /// </summary>
    [EnumType]
    public readonly struct RestoreConfigClusterResourceConflictPolicy : IEquatable<RestoreConfigClusterResourceConflictPolicy>
    {
        private readonly string _value;

        private RestoreConfigClusterResourceConflictPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified. Only allowed if no cluster-scoped resources will be restored.
        /// </summary>
        public static RestoreConfigClusterResourceConflictPolicy ClusterResourceConflictPolicyUnspecified { get; } = new RestoreConfigClusterResourceConflictPolicy("CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED");
        /// <summary>
        /// Do not attempt to restore the conflicting resource.
        /// </summary>
        public static RestoreConfigClusterResourceConflictPolicy UseExistingVersion { get; } = new RestoreConfigClusterResourceConflictPolicy("USE_EXISTING_VERSION");
        /// <summary>
        /// Delete the existing version before re-creating it from the Backup. Note that this is a dangerous option which could cause unintentional data loss if used inappropriately - for example, deleting a CRD will cause Kubernetes to delete all CRs of that type.
        /// </summary>
        public static RestoreConfigClusterResourceConflictPolicy UseBackupVersion { get; } = new RestoreConfigClusterResourceConflictPolicy("USE_BACKUP_VERSION");

        public static bool operator ==(RestoreConfigClusterResourceConflictPolicy left, RestoreConfigClusterResourceConflictPolicy right) => left.Equals(right);
        public static bool operator !=(RestoreConfigClusterResourceConflictPolicy left, RestoreConfigClusterResourceConflictPolicy right) => !left.Equals(right);

        public static explicit operator string(RestoreConfigClusterResourceConflictPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RestoreConfigClusterResourceConflictPolicy other && Equals(other);
        public bool Equals(RestoreConfigClusterResourceConflictPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines the behavior for handling the situation where sets of namespaced resources being restored already exist in the target cluster. This MUST be set to a value other than NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED if any namespaced restoration is configured via namespaced_resource_restore_scope .
    /// </summary>
    [EnumType]
    public readonly struct RestoreConfigNamespacedResourceRestoreMode : IEquatable<RestoreConfigNamespacedResourceRestoreMode>
    {
        private readonly string _value;

        private RestoreConfigNamespacedResourceRestoreMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified. Only allowed if no namespaced resources will be restored.
        /// </summary>
        public static RestoreConfigNamespacedResourceRestoreMode NamespacedResourceRestoreModeUnspecified { get; } = new RestoreConfigNamespacedResourceRestoreMode("NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED");
        /// <summary>
        /// When conflicting top-level resources (either Namespaces or ProtectedApplications, depending upon the scope) are encountered, this will first trigger a delete of the conflicting resource AND ALL OF ITS REFERENCED RESOURCES (e.g., all resources in the Namespace or all resources referenced by the ProtectedApplication) before restoring the resources from the Backup. This mode should only be used when you are intending to revert some portion of a cluster to an earlier state.
        /// </summary>
        public static RestoreConfigNamespacedResourceRestoreMode DeleteAndRestore { get; } = new RestoreConfigNamespacedResourceRestoreMode("DELETE_AND_RESTORE");
        /// <summary>
        /// If conflicting top-level resources (either Namespaces or ProtectedApplications, depending upon the scope) are encountered at the beginning of a restore process, the Restore will fail. If a conflict occurs during the restore process itself (e.g., because an out of band process creates conflicting resources), a conflict will be reported.
        /// </summary>
        public static RestoreConfigNamespacedResourceRestoreMode FailOnConflict { get; } = new RestoreConfigNamespacedResourceRestoreMode("FAIL_ON_CONFLICT");

        public static bool operator ==(RestoreConfigNamespacedResourceRestoreMode left, RestoreConfigNamespacedResourceRestoreMode right) => left.Equals(right);
        public static bool operator !=(RestoreConfigNamespacedResourceRestoreMode left, RestoreConfigNamespacedResourceRestoreMode right) => !left.Equals(right);

        public static explicit operator string(RestoreConfigNamespacedResourceRestoreMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RestoreConfigNamespacedResourceRestoreMode other && Equals(other);
        public bool Equals(RestoreConfigNamespacedResourceRestoreMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the mechanism to be used to restore volume data. Default: VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED (will be treated as NO_VOLUME_DATA_RESTORATION).
    /// </summary>
    [EnumType]
    public readonly struct RestoreConfigVolumeDataRestorePolicy : IEquatable<RestoreConfigVolumeDataRestorePolicy>
    {
        private readonly string _value;

        private RestoreConfigVolumeDataRestorePolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// unspecified, default value
        /// </summary>
        public static RestoreConfigVolumeDataRestorePolicy VolumeDataRestorePolicyUnspecified { get; } = new RestoreConfigVolumeDataRestorePolicy("VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED");
        /// <summary>
        /// For each PVC to be restored, will create a new underlying volume (and PV) from the corresponding VolumeBackup contained within the Backup.
        /// </summary>
        public static RestoreConfigVolumeDataRestorePolicy RestoreVolumeDataFromBackup { get; } = new RestoreConfigVolumeDataRestorePolicy("RESTORE_VOLUME_DATA_FROM_BACKUP");
        /// <summary>
        /// For each PVC to be restored, attempt to reuse the original PV contained in the Backup (with its original underlying volume). Note that option is likely only usable when restoring a workload to its original cluster.
        /// </summary>
        public static RestoreConfigVolumeDataRestorePolicy ReuseVolumeHandleFromBackup { get; } = new RestoreConfigVolumeDataRestorePolicy("REUSE_VOLUME_HANDLE_FROM_BACKUP");
        /// <summary>
        /// For each PVC to be restored, PVCs will be created without any particular action to restore data. In this case, the normal Kubernetes provisioning logic would kick in, and this would likely result in either dynamically provisioning blank PVs or binding to statically provisioned PVs.
        /// </summary>
        public static RestoreConfigVolumeDataRestorePolicy NoVolumeDataRestoration { get; } = new RestoreConfigVolumeDataRestorePolicy("NO_VOLUME_DATA_RESTORATION");

        public static bool operator ==(RestoreConfigVolumeDataRestorePolicy left, RestoreConfigVolumeDataRestorePolicy right) => left.Equals(right);
        public static bool operator !=(RestoreConfigVolumeDataRestorePolicy left, RestoreConfigVolumeDataRestorePolicy right) => !left.Equals(right);

        public static explicit operator string(RestoreConfigVolumeDataRestorePolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RestoreConfigVolumeDataRestorePolicy other && Equals(other);
        public bool Equals(RestoreConfigVolumeDataRestorePolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

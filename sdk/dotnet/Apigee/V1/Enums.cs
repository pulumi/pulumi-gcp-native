// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Apigee.V1
{
    /// <summary>
    /// Scope of the quota decides how the quota counter gets applied and evaluate for quota violation. If the Scope is set as PROXY, then all the operations defined for the APIproduct that are associated with the same proxy will share the same quota counter set at the APIproduct level, making it a global counter at a proxy level. If the Scope is set as OPERATION, then each operations get the counter set at the API product dedicated, making it a local counter. Note that, the QuotaCounterScope applies only when an operation does not have dedicated quota set for itself.
    /// </summary>
    [EnumType]
    public readonly struct ApiProductQuotaCounterScope : IEquatable<ApiProductQuotaCounterScope>
    {
        private readonly string _value;

        private ApiProductQuotaCounterScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// When quota is not explicitly defined for each operation(REST/GraphQL), the limits set at product level will be used as a local counter for quota evaluation by all the operations, independent of proxy association.
        /// </summary>
        public static ApiProductQuotaCounterScope QuotaCounterScopeUnspecified { get; } = new ApiProductQuotaCounterScope("QUOTA_COUNTER_SCOPE_UNSPECIFIED");
        /// <summary>
        /// When quota is not explicitly defined for each operation(REST/GraphQL), set at product level will be used as a global counter for quota evaluation by all the operations associated with a particular proxy.
        /// </summary>
        public static ApiProductQuotaCounterScope Proxy { get; } = new ApiProductQuotaCounterScope("PROXY");
        /// <summary>
        /// When quota is not explicitly defined for each operation(REST/GraphQL), the limits set at product level will be used as a local counter for quota evaluation by all the operations, independent of proxy association. This behavior mimics the same as QUOTA_COUNTER_SCOPE_UNSPECIFIED.
        /// </summary>
        public static ApiProductQuotaCounterScope Operation { get; } = new ApiProductQuotaCounterScope("OPERATION");

        public static bool operator ==(ApiProductQuotaCounterScope left, ApiProductQuotaCounterScope right) => left.Equals(right);
        public static bool operator !=(ApiProductQuotaCounterScope left, ApiProductQuotaCounterScope right) => !left.Equals(right);

        public static explicit operator string(ApiProductQuotaCounterScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApiProductQuotaCounterScope other && Equals(other);
        public bool Equals(ApiProductQuotaCounterScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Immutable. The type of data this data collector will collect.
    /// </summary>
    [EnumType]
    public readonly struct DataCollectorType : IEquatable<DataCollectorType>
    {
        private readonly string _value;

        private DataCollectorType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// For future compatibility.
        /// </summary>
        public static DataCollectorType TypeUnspecified { get; } = new DataCollectorType("TYPE_UNSPECIFIED");
        /// <summary>
        /// For integer values.
        /// </summary>
        public static DataCollectorType Integer { get; } = new DataCollectorType("INTEGER");
        /// <summary>
        /// For float values.
        /// </summary>
        public static DataCollectorType Float { get; } = new DataCollectorType("FLOAT");
        /// <summary>
        /// For string values.
        /// </summary>
        public static DataCollectorType String { get; } = new DataCollectorType("STRING");
        /// <summary>
        /// For boolean values.
        /// </summary>
        public static DataCollectorType Boolean { get; } = new DataCollectorType("BOOLEAN");
        /// <summary>
        /// For datetime values.
        /// </summary>
        public static DataCollectorType Datetime { get; } = new DataCollectorType("DATETIME");

        public static bool operator ==(DataCollectorType left, DataCollectorType right) => left.Equals(right);
        public static bool operator !=(DataCollectorType left, DataCollectorType right) => !left.Equals(right);

        public static explicit operator string(DataCollectorType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataCollectorType other && Equals(other);
        public bool Equals(DataCollectorType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. API Proxy type supported by the environment. The type can be set when creating the Environment and cannot be changed.
    /// </summary>
    [EnumType]
    public readonly struct EnvironmentApiProxyType : IEquatable<EnvironmentApiProxyType>
    {
        private readonly string _value;

        private EnvironmentApiProxyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// API proxy type not specified.
        /// </summary>
        public static EnvironmentApiProxyType ApiProxyTypeUnspecified { get; } = new EnvironmentApiProxyType("API_PROXY_TYPE_UNSPECIFIED");
        /// <summary>
        /// Programmable API Proxies enable you to develop APIs with highly flexible behavior using bundled policy configuration and one or more programming languages to describe complex sequential and/or conditional flows of logic.
        /// </summary>
        public static EnvironmentApiProxyType Programmable { get; } = new EnvironmentApiProxyType("PROGRAMMABLE");
        /// <summary>
        /// Configurable API Proxies enable you to develop efficient APIs using simple configuration while complex execution control flow logic is handled by Apigee. This type only works with the ARCHIVE deployment type and cannot be combined with the PROXY deployment type.
        /// </summary>
        public static EnvironmentApiProxyType Configurable { get; } = new EnvironmentApiProxyType("CONFIGURABLE");

        public static bool operator ==(EnvironmentApiProxyType left, EnvironmentApiProxyType right) => left.Equals(right);
        public static bool operator !=(EnvironmentApiProxyType left, EnvironmentApiProxyType right) => !left.Equals(right);

        public static explicit operator string(EnvironmentApiProxyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnvironmentApiProxyType other && Equals(other);
        public bool Equals(EnvironmentApiProxyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Deployment type supported by the environment. The deployment type can be set when creating the environment and cannot be changed. When you enable archive deployment, you will be **prevented from performing** a [subset of actions](/apigee/docs/api-platform/local-development/overview#prevented-actions) within the environment, including: * Managing the deployment of API proxy or shared flow revisions * Creating, updating, or deleting resource files * Creating, updating, or deleting target servers
    /// </summary>
    [EnumType]
    public readonly struct EnvironmentDeploymentType : IEquatable<EnvironmentDeploymentType>
    {
        private readonly string _value;

        private EnvironmentDeploymentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Deployment type not specified.
        /// </summary>
        public static EnvironmentDeploymentType DeploymentTypeUnspecified { get; } = new EnvironmentDeploymentType("DEPLOYMENT_TYPE_UNSPECIFIED");
        /// <summary>
        /// Proxy deployment enables you to develop and deploy API proxies using Apigee on Google Cloud. This cannot currently be combined with the CONFIGURABLE API proxy type.
        /// </summary>
        public static EnvironmentDeploymentType Proxy { get; } = new EnvironmentDeploymentType("PROXY");
        /// <summary>
        /// Archive deployment enables you to develop API proxies locally then deploy an archive of your API proxy configuration to an environment in Apigee on Google Cloud. You will be prevented from performing a [subset of actions](/apigee/docs/api-platform/local-development/overview#prevented-actions) within the environment.
        /// </summary>
        public static EnvironmentDeploymentType Archive { get; } = new EnvironmentDeploymentType("ARCHIVE");

        public static bool operator ==(EnvironmentDeploymentType left, EnvironmentDeploymentType right) => left.Equals(right);
        public static bool operator !=(EnvironmentDeploymentType left, EnvironmentDeploymentType right) => !left.Equals(right);

        public static explicit operator string(EnvironmentDeploymentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnvironmentDeploymentType other && Equals(other);
        public bool Equals(EnvironmentDeploymentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. EnvironmentType selected for the environment.
    /// </summary>
    [EnumType]
    public readonly struct EnvironmentType : IEquatable<EnvironmentType>
    {
        private readonly string _value;

        private EnvironmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Environment type not specified.
        /// </summary>
        public static EnvironmentType EnvironmentTypeUnspecified { get; } = new EnvironmentType("ENVIRONMENT_TYPE_UNSPECIFIED");
        /// <summary>
        /// Base environment has limited capacity and capabilities and are usually used when you are getting started with Apigee or while experimenting. Refer to Apigee's public documentation for more details.
        /// </summary>
        public static EnvironmentType Base { get; } = new EnvironmentType("BASE");
        /// <summary>
        /// This is the default type and it supports API management features and higher capacity than Base environment. Refer to Apigee's public documentation for more details.
        /// </summary>
        public static EnvironmentType Intermediate { get; } = new EnvironmentType("INTERMEDIATE");
        /// <summary>
        /// Comprehensive environment supports advanced capabilites and even higher capacity than Intermediate environment. Refer to Apigee's public documentation for more details.
        /// </summary>
        public static EnvironmentType Comprehensive { get; } = new EnvironmentType("COMPREHENSIVE");

        public static bool operator ==(EnvironmentType left, EnvironmentType right) => left.Equals(right);
        public static bool operator !=(EnvironmentType left, EnvironmentType right) => !left.Equals(right);

        public static explicit operator string(EnvironmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnvironmentType other && Equals(other);
        public bool Equals(EnvironmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sampler of distributed tracing. OFF is the default value.
    /// </summary>
    [EnumType]
    public readonly struct GoogleCloudApigeeV1TraceSamplingConfigSampler : IEquatable<GoogleCloudApigeeV1TraceSamplingConfigSampler>
    {
        private readonly string _value;

        private GoogleCloudApigeeV1TraceSamplingConfigSampler(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Sampler unspecified.
        /// </summary>
        public static GoogleCloudApigeeV1TraceSamplingConfigSampler SamplerUnspecified { get; } = new GoogleCloudApigeeV1TraceSamplingConfigSampler("SAMPLER_UNSPECIFIED");
        /// <summary>
        /// OFF means distributed trace is disabled, or the sampling probability is 0.
        /// </summary>
        public static GoogleCloudApigeeV1TraceSamplingConfigSampler Off { get; } = new GoogleCloudApigeeV1TraceSamplingConfigSampler("OFF");
        /// <summary>
        /// PROBABILITY means traces are captured on a probability that defined by sampling_rate. The sampling rate is limited to 0 to 0.5 when this is set.
        /// </summary>
        public static GoogleCloudApigeeV1TraceSamplingConfigSampler Probability { get; } = new GoogleCloudApigeeV1TraceSamplingConfigSampler("PROBABILITY");

        public static bool operator ==(GoogleCloudApigeeV1TraceSamplingConfigSampler left, GoogleCloudApigeeV1TraceSamplingConfigSampler right) => left.Equals(right);
        public static bool operator !=(GoogleCloudApigeeV1TraceSamplingConfigSampler left, GoogleCloudApigeeV1TraceSamplingConfigSampler right) => !left.Equals(right);

        public static explicit operator string(GoogleCloudApigeeV1TraceSamplingConfigSampler value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GoogleCloudApigeeV1TraceSamplingConfigSampler other && Equals(other);
        public bool Equals(GoogleCloudApigeeV1TraceSamplingConfigSampler other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct GoogleIamV1AuditLogConfigLogType : IEquatable<GoogleIamV1AuditLogConfigLogType>
    {
        private readonly string _value;

        private GoogleIamV1AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default case. Should never be this.
        /// </summary>
        public static GoogleIamV1AuditLogConfigLogType LogTypeUnspecified { get; } = new GoogleIamV1AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");
        /// <summary>
        /// Admin reads. Example: CloudIAM getIamPolicy
        /// </summary>
        public static GoogleIamV1AuditLogConfigLogType AdminRead { get; } = new GoogleIamV1AuditLogConfigLogType("ADMIN_READ");
        /// <summary>
        /// Data writes. Example: CloudSQL Users create
        /// </summary>
        public static GoogleIamV1AuditLogConfigLogType DataWrite { get; } = new GoogleIamV1AuditLogConfigLogType("DATA_WRITE");
        /// <summary>
        /// Data reads. Example: CloudSQL Users list
        /// </summary>
        public static GoogleIamV1AuditLogConfigLogType DataRead { get; } = new GoogleIamV1AuditLogConfigLogType("DATA_READ");

        public static bool operator ==(GoogleIamV1AuditLogConfigLogType left, GoogleIamV1AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(GoogleIamV1AuditLogConfigLogType left, GoogleIamV1AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(GoogleIamV1AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GoogleIamV1AuditLogConfigLogType other && Equals(other);
        public bool Equals(GoogleIamV1AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Size of the CIDR block range that will be reserved by the instance. PAID organizations support `SLASH_16` to `SLASH_20` and defaults to `SLASH_16`. Evaluation organizations support only `SLASH_23`.
    /// </summary>
    [EnumType]
    public readonly struct InstancePeeringCidrRange : IEquatable<InstancePeeringCidrRange>
    {
        private readonly string _value;

        private InstancePeeringCidrRange(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Range not specified.
        /// </summary>
        public static InstancePeeringCidrRange CidrRangeUnspecified { get; } = new InstancePeeringCidrRange("CIDR_RANGE_UNSPECIFIED");
        /// <summary>
        /// `/16` CIDR range.
        /// </summary>
        public static InstancePeeringCidrRange Slash16 { get; } = new InstancePeeringCidrRange("SLASH_16");
        /// <summary>
        /// `/17` CIDR range.
        /// </summary>
        public static InstancePeeringCidrRange Slash17 { get; } = new InstancePeeringCidrRange("SLASH_17");
        /// <summary>
        /// `/18` CIDR range.
        /// </summary>
        public static InstancePeeringCidrRange Slash18 { get; } = new InstancePeeringCidrRange("SLASH_18");
        /// <summary>
        /// `/19` CIDR range.
        /// </summary>
        public static InstancePeeringCidrRange Slash19 { get; } = new InstancePeeringCidrRange("SLASH_19");
        /// <summary>
        /// `/20` CIDR range.
        /// </summary>
        public static InstancePeeringCidrRange Slash20 { get; } = new InstancePeeringCidrRange("SLASH_20");
        /// <summary>
        /// `/22` CIDR range. Supported for evaluation only.
        /// </summary>
        public static InstancePeeringCidrRange Slash22 { get; } = new InstancePeeringCidrRange("SLASH_22");
        /// <summary>
        /// `/23` CIDR range. Supported for evaluation only.
        /// </summary>
        public static InstancePeeringCidrRange Slash23 { get; } = new InstancePeeringCidrRange("SLASH_23");

        public static bool operator ==(InstancePeeringCidrRange left, InstancePeeringCidrRange right) => left.Equals(right);
        public static bool operator !=(InstancePeeringCidrRange left, InstancePeeringCidrRange right) => !left.Equals(right);

        public static explicit operator string(InstancePeeringCidrRange value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstancePeeringCidrRange other && Equals(other);
        public bool Equals(InstancePeeringCidrRange other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Billing type of the Apigee organization. See [Apigee pricing](https://cloud.google.com/apigee/pricing).
    /// </summary>
    [EnumType]
    public readonly struct OrganizationBillingType : IEquatable<OrganizationBillingType>
    {
        private readonly string _value;

        private OrganizationBillingType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Billing type not specified.
        /// </summary>
        public static OrganizationBillingType BillingTypeUnspecified { get; } = new OrganizationBillingType("BILLING_TYPE_UNSPECIFIED");
        /// <summary>
        /// A pre-paid subscription to Apigee.
        /// </summary>
        public static OrganizationBillingType Subscription { get; } = new OrganizationBillingType("SUBSCRIPTION");
        /// <summary>
        /// Free and limited access to Apigee for evaluation purposes only.
        /// </summary>
        public static OrganizationBillingType Evaluation { get; } = new OrganizationBillingType("EVALUATION");
        /// <summary>
        /// Access to Apigee using a Pay-As-You-Go plan.
        /// </summary>
        public static OrganizationBillingType Payg { get; } = new OrganizationBillingType("PAYG");

        public static bool operator ==(OrganizationBillingType left, OrganizationBillingType right) => left.Equals(right);
        public static bool operator !=(OrganizationBillingType left, OrganizationBillingType right) => !left.Equals(right);

        public static explicit operator string(OrganizationBillingType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OrganizationBillingType other && Equals(other);
        public bool Equals(OrganizationBillingType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Runtime type of the Apigee organization based on the Apigee subscription purchased.
    /// </summary>
    [EnumType]
    public readonly struct OrganizationRuntimeType : IEquatable<OrganizationRuntimeType>
    {
        private readonly string _value;

        private OrganizationRuntimeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Runtime type not specified.
        /// </summary>
        public static OrganizationRuntimeType RuntimeTypeUnspecified { get; } = new OrganizationRuntimeType("RUNTIME_TYPE_UNSPECIFIED");
        /// <summary>
        /// Google-managed Apigee runtime.
        /// </summary>
        public static OrganizationRuntimeType Cloud { get; } = new OrganizationRuntimeType("CLOUD");
        /// <summary>
        /// User-managed Apigee hybrid runtime.
        /// </summary>
        public static OrganizationRuntimeType Hybrid { get; } = new OrganizationRuntimeType("HYBRID");

        public static bool operator ==(OrganizationRuntimeType left, OrganizationRuntimeType right) => left.Equals(right);
        public static bool operator !=(OrganizationRuntimeType left, OrganizationRuntimeType right) => !left.Equals(right);

        public static explicit operator string(OrganizationRuntimeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OrganizationRuntimeType other && Equals(other);
        public bool Equals(OrganizationRuntimeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Not used by Apigee.
    /// </summary>
    [EnumType]
    public readonly struct OrganizationType : IEquatable<OrganizationType>
    {
        private readonly string _value;

        private OrganizationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Subscription type not specified.
        /// </summary>
        public static OrganizationType TypeUnspecified { get; } = new OrganizationType("TYPE_UNSPECIFIED");
        /// <summary>
        /// Subscription to Apigee is free, limited, and used for evaluation purposes only.
        /// </summary>
        public static OrganizationType TypeTrial { get; } = new OrganizationType("TYPE_TRIAL");
        /// <summary>
        /// Full subscription to Apigee has been purchased. See [Apigee pricing](https://cloud.google.com/apigee/pricing/).
        /// </summary>
        public static OrganizationType TypePaid { get; } = new OrganizationType("TYPE_PAID");
        /// <summary>
        /// For internal users only.
        /// </summary>
        public static OrganizationType TypeInternal { get; } = new OrganizationType("TYPE_INTERNAL");

        public static bool operator ==(OrganizationType left, OrganizationType right) => left.Equals(right);
        public static bool operator !=(OrganizationType left, OrganizationType right) => !left.Equals(right);

        public static explicit operator string(OrganizationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OrganizationType other && Equals(other);
        public bool Equals(OrganizationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Frequency at which the customer will be billed.
    /// </summary>
    [EnumType]
    public readonly struct RatePlanBillingPeriod : IEquatable<RatePlanBillingPeriod>
    {
        private readonly string _value;

        private RatePlanBillingPeriod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Billing period not specified.
        /// </summary>
        public static RatePlanBillingPeriod BillingPeriodUnspecified { get; } = new RatePlanBillingPeriod("BILLING_PERIOD_UNSPECIFIED");
        /// <summary>
        /// Weekly billing period. **Note**: Not supported by Apigee at this time.
        /// </summary>
        public static RatePlanBillingPeriod Weekly { get; } = new RatePlanBillingPeriod("WEEKLY");
        /// <summary>
        /// Monthly billing period.
        /// </summary>
        public static RatePlanBillingPeriod Monthly { get; } = new RatePlanBillingPeriod("MONTHLY");

        public static bool operator ==(RatePlanBillingPeriod left, RatePlanBillingPeriod right) => left.Equals(right);
        public static bool operator !=(RatePlanBillingPeriod left, RatePlanBillingPeriod right) => !left.Equals(right);

        public static explicit operator string(RatePlanBillingPeriod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RatePlanBillingPeriod other && Equals(other);
        public bool Equals(RatePlanBillingPeriod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Pricing model used for consumption-based charges.
    /// </summary>
    [EnumType]
    public readonly struct RatePlanConsumptionPricingType : IEquatable<RatePlanConsumptionPricingType>
    {
        private readonly string _value;

        private RatePlanConsumptionPricingType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Pricing model not specified. This is the default.
        /// </summary>
        public static RatePlanConsumptionPricingType ConsumptionPricingTypeUnspecified { get; } = new RatePlanConsumptionPricingType("CONSUMPTION_PRICING_TYPE_UNSPECIFIED");
        /// <summary>
        /// Fixed rate charged for each API call.
        /// </summary>
        public static RatePlanConsumptionPricingType FixedPerUnit { get; } = new RatePlanConsumptionPricingType("FIXED_PER_UNIT");
        /// <summary>
        /// Variable rate charged for each API call based on price tiers. Example: * 1-100 calls cost $2 per call * 101-200 calls cost $1.50 per call * 201-300 calls cost $1 per call * Total price for 50 calls: 50 x $2 = $100 * Total price for 150 calls: 100 x $2 + 50 x $1.5 = $275 * Total price for 250 calls: 100 x $2 + 100 x $1.5 + 50 x $1 = $400. **Note**: Not supported by Apigee at this time.
        /// </summary>
        public static RatePlanConsumptionPricingType Banded { get; } = new RatePlanConsumptionPricingType("BANDED");
        /// <summary>
        /// **Note**: Not supported by Apigee at this time.
        /// </summary>
        public static RatePlanConsumptionPricingType Tiered { get; } = new RatePlanConsumptionPricingType("TIERED");
        /// <summary>
        /// **Note**: Not supported by Apigee at this time.
        /// </summary>
        public static RatePlanConsumptionPricingType Stairstep { get; } = new RatePlanConsumptionPricingType("STAIRSTEP");

        public static bool operator ==(RatePlanConsumptionPricingType left, RatePlanConsumptionPricingType right) => left.Equals(right);
        public static bool operator !=(RatePlanConsumptionPricingType left, RatePlanConsumptionPricingType right) => !left.Equals(right);

        public static explicit operator string(RatePlanConsumptionPricingType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RatePlanConsumptionPricingType other && Equals(other);
        public bool Equals(RatePlanConsumptionPricingType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// DEPRECATED: This field is no longer supported and will eventually be removed when Apigee Hybrid 1.5/1.6 is no longer supported. Instead, use the `billingType` field inside `DeveloperMonetizationConfig` resource. Flag that specifies the billing account type, prepaid or postpaid.
    /// </summary>
    [EnumType]
    public readonly struct RatePlanPaymentFundingModel : IEquatable<RatePlanPaymentFundingModel>
    {
        private readonly string _value;

        private RatePlanPaymentFundingModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Billing account type not specified.
        /// </summary>
        public static RatePlanPaymentFundingModel PaymentFundingModelUnspecified { get; } = new RatePlanPaymentFundingModel("PAYMENT_FUNDING_MODEL_UNSPECIFIED");
        /// <summary>
        /// Prepaid billing account type. Developer pays in advance for the use of your API products. Funds are deducted from their prepaid account balance. **Note**: Not supported by Apigee at this time.
        /// </summary>
        public static RatePlanPaymentFundingModel Prepaid { get; } = new RatePlanPaymentFundingModel("PREPAID");
        /// <summary>
        /// Postpaid billing account type. Developer is billed through an invoice after using your API products.
        /// </summary>
        public static RatePlanPaymentFundingModel Postpaid { get; } = new RatePlanPaymentFundingModel("POSTPAID");

        public static bool operator ==(RatePlanPaymentFundingModel left, RatePlanPaymentFundingModel right) => left.Equals(right);
        public static bool operator !=(RatePlanPaymentFundingModel left, RatePlanPaymentFundingModel right) => !left.Equals(right);

        public static explicit operator string(RatePlanPaymentFundingModel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RatePlanPaymentFundingModel other && Equals(other);
        public bool Equals(RatePlanPaymentFundingModel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Method used to calculate the revenue that is shared with developers.
    /// </summary>
    [EnumType]
    public readonly struct RatePlanRevenueShareType : IEquatable<RatePlanRevenueShareType>
    {
        private readonly string _value;

        private RatePlanRevenueShareType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Revenue share type is not specified.
        /// </summary>
        public static RatePlanRevenueShareType RevenueShareTypeUnspecified { get; } = new RatePlanRevenueShareType("REVENUE_SHARE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Fixed percentage of the total revenue will be shared. The percentage to be shared can be configured by the API provider.
        /// </summary>
        public static RatePlanRevenueShareType Fixed { get; } = new RatePlanRevenueShareType("FIXED");
        /// <summary>
        /// Amount of revenue shared depends on the number of API calls. The API call volume ranges and the revenue share percentage for each volume can be configured by the API provider. **Note**: Not supported by Apigee at this time.
        /// </summary>
        public static RatePlanRevenueShareType VolumeBanded { get; } = new RatePlanRevenueShareType("VOLUME_BANDED");

        public static bool operator ==(RatePlanRevenueShareType left, RatePlanRevenueShareType right) => left.Equals(right);
        public static bool operator !=(RatePlanRevenueShareType left, RatePlanRevenueShareType right) => !left.Equals(right);

        public static explicit operator string(RatePlanRevenueShareType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RatePlanRevenueShareType other && Equals(other);
        public bool Equals(RatePlanRevenueShareType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Current state of the rate plan (draft or published).
    /// </summary>
    [EnumType]
    public readonly struct RatePlanState : IEquatable<RatePlanState>
    {
        private readonly string _value;

        private RatePlanState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// State of the rate plan is not specified.
        /// </summary>
        public static RatePlanState StateUnspecified { get; } = new RatePlanState("STATE_UNSPECIFIED");
        /// <summary>
        /// Rate plan is in draft mode and only visible to API providers.
        /// </summary>
        public static RatePlanState Draft { get; } = new RatePlanState("DRAFT");
        /// <summary>
        /// Rate plan is published and will become visible to developers for the configured duration (between `startTime` and `endTime`).
        /// </summary>
        public static RatePlanState Published { get; } = new RatePlanState("PUBLISHED");

        public static bool operator ==(RatePlanState left, RatePlanState right) => left.Equals(right);
        public static bool operator !=(RatePlanState left, RatePlanState right) => !left.Equals(right);

        public static explicit operator string(RatePlanState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RatePlanState other && Equals(other);
        public bool Equals(RatePlanState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Only an ENABLED SecurityAction is enforced. An ENABLED SecurityAction past its expiration time will not be enforced.
    /// </summary>
    [EnumType]
    public readonly struct SecurityActionState : IEquatable<SecurityActionState>
    {
        private readonly string _value;

        private SecurityActionState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default value. This only exists for forward compatibility. A create request with this value will be rejected.
        /// </summary>
        public static SecurityActionState StateUnspecified { get; } = new SecurityActionState("STATE_UNSPECIFIED");
        /// <summary>
        /// An ENABLED SecurityAction is actively enforced if the `expiration_time` is in the future.
        /// </summary>
        public static SecurityActionState Enabled { get; } = new SecurityActionState("ENABLED");
        /// <summary>
        /// A disabled SecurityAction is never enforced.
        /// </summary>
        public static SecurityActionState Disabled { get; } = new SecurityActionState("DISABLED");

        public static bool operator ==(SecurityActionState left, SecurityActionState right) => left.Equals(right);
        public static bool operator !=(SecurityActionState left, SecurityActionState right) => !left.Equals(right);

        public static explicit operator string(SecurityActionState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityActionState other && Equals(other);
        public bool Equals(SecurityActionState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Immutable. The protocol used by this TargetServer.
    /// </summary>
    [EnumType]
    public readonly struct TargetServerProtocol : IEquatable<TargetServerProtocol>
    {
        private readonly string _value;

        private TargetServerProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// UNSPECIFIED defaults to HTTP for backwards compatibility.
        /// </summary>
        public static TargetServerProtocol ProtocolUnspecified { get; } = new TargetServerProtocol("PROTOCOL_UNSPECIFIED");
        /// <summary>
        /// The TargetServer uses HTTP.
        /// </summary>
        public static TargetServerProtocol Http { get; } = new TargetServerProtocol("HTTP");
        /// <summary>
        /// The TargetSever uses HTTP2.
        /// </summary>
        public static TargetServerProtocol Http2 { get; } = new TargetServerProtocol("HTTP2");
        /// <summary>
        /// The TargetServer uses GRPC.
        /// </summary>
        public static TargetServerProtocol GrpcTarget { get; } = new TargetServerProtocol("GRPC_TARGET");
        /// <summary>
        /// GRPC TargetServer to be used in ExternalCallout Policy. Prefer to use EXTERNAL_CALLOUT instead. TODO(b/266125112) deprecate once EXTERNAL _CALLOUT generally available.
        /// </summary>
        public static TargetServerProtocol Grpc { get; } = new TargetServerProtocol("GRPC");
        /// <summary>
        /// The TargetServer is to be used in the ExternalCallout Policy
        /// </summary>
        public static TargetServerProtocol ExternalCallout { get; } = new TargetServerProtocol("EXTERNAL_CALLOUT");

        public static bool operator ==(TargetServerProtocol left, TargetServerProtocol right) => left.Equals(right);
        public static bool operator !=(TargetServerProtocol left, TargetServerProtocol right) => !left.Equals(right);

        public static explicit operator string(TargetServerProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetServerProtocol other && Equals(other);
        public bool Equals(TargetServerProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

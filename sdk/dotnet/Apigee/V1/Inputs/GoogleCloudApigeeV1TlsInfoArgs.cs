// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.GoogleNative.Apigee.V1.Inputs
{

    /// <summary>
    /// TLS configuration information for virtual hosts and TargetServers.
    /// </summary>
    public sealed class GoogleCloudApigeeV1TlsInfoArgs : Pulumi.ResourceArgs
    {
        [Input("ciphers")]
        private InputList<string>? _ciphers;

        /// <summary>
        /// The SSL/TLS cipher suites to be used. Must be one of the cipher suite names listed in: http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#ciphersuites
        /// </summary>
        public InputList<string> Ciphers
        {
            get => _ciphers ?? (_ciphers = new InputList<string>());
            set => _ciphers = value;
        }

        /// <summary>
        /// Optional. Enables two-way TLS.
        /// </summary>
        [Input("clientAuthEnabled")]
        public Input<bool>? ClientAuthEnabled { get; set; }

        /// <summary>
        /// The TLS Common Name of the certificate.
        /// </summary>
        [Input("commonName")]
        public Input<Inputs.GoogleCloudApigeeV1TlsInfoCommonNameArgs>? CommonName { get; set; }

        /// <summary>
        /// Enables TLS. If false, neither one-way nor two-way TLS will be enabled.
        /// </summary>
        [Input("enabled", required: true)]
        public Input<bool> Enabled { get; set; } = null!;

        /// <summary>
        /// If true, Edge ignores TLS certificate errors. Valid when configuring TLS for target servers and target endpoints, and when configuring virtual hosts that use 2-way TLS. When used with a target endpoint/target server, if the backend system uses SNI and returns a cert with a subject Distinguished Name (DN) that does not match the hostname, there is no way to ignore the error and the connection fails.
        /// </summary>
        [Input("ignoreValidationErrors")]
        public Input<bool>? IgnoreValidationErrors { get; set; }

        /// <summary>
        /// Required if `client_auth_enabled` is true. The resource ID for the alias containing the private key and cert.
        /// </summary>
        [Input("keyAlias")]
        public Input<string>? KeyAlias { get; set; }

        /// <summary>
        /// Required if `client_auth_enabled` is true. The resource ID of the keystore.
        /// </summary>
        [Input("keyStore")]
        public Input<string>? KeyStore { get; set; }

        [Input("protocols")]
        private InputList<string>? _protocols;

        /// <summary>
        /// The TLS versioins to be used.
        /// </summary>
        public InputList<string> Protocols
        {
            get => _protocols ?? (_protocols = new InputList<string>());
            set => _protocols = value;
        }

        /// <summary>
        /// The resource ID of the truststore.
        /// </summary>
        [Input("trustStore")]
        public Input<string>? TrustStore { get; set; }

        public GoogleCloudApigeeV1TlsInfoArgs()
        {
        }
    }
}

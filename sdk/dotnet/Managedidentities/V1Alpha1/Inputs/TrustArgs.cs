// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.GcpNative.Managedidentities.V1Alpha1.Inputs
{

    /// <summary>
    /// Represents a relationship between two domains which makes it possible for users in one domain to be authenticated by a dc in another domain. Refer https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc731335(v%3dws.10) If the trust is being changed, it will be placed into the UPDATING state, which indicates that the resource is being reconciled. At this point, Get will reflect an intermediate state.
    /// </summary>
    public sealed class TrustArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The time the instance was created.
        /// </summary>
        [Input("createTime")]
        public Input<string>? CreateTime { get; set; }

        /// <summary>
        /// The last heartbeat time when the trust was known to be connected.
        /// </summary>
        [Input("lastKnownTrustConnectedHeartbeatTime")]
        public Input<string>? LastKnownTrustConnectedHeartbeatTime { get; set; }

        /// <summary>
        /// The trust authentication type which decides whether the trusted side has forest/domain wide access or selective access to approved set of resources.
        /// </summary>
        [Input("selectiveAuthentication")]
        public Input<bool>? SelectiveAuthentication { get; set; }

        /// <summary>
        /// The current state of this trust.
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        /// <summary>
        /// Additional information about the current state of this trust, if available.
        /// </summary>
        [Input("stateDescription")]
        public Input<string>? StateDescription { get; set; }

        [Input("targetDnsIpAddresses")]
        private InputList<string>? _targetDnsIpAddresses;

        /// <summary>
        /// The target dns server ip addresses which can resolve the remote domain involved in trust.
        /// </summary>
        public InputList<string> TargetDnsIpAddresses
        {
            get => _targetDnsIpAddresses ?? (_targetDnsIpAddresses = new InputList<string>());
            set => _targetDnsIpAddresses = value;
        }

        /// <summary>
        /// The fully qualified target domain name which will be in trust with current domain.
        /// </summary>
        [Input("targetDomainName")]
        public Input<string>? TargetDomainName { get; set; }

        /// <summary>
        /// The trust direction decides the current domain is trusted, trusting or both.
        /// </summary>
        [Input("trustDirection")]
        public Input<string>? TrustDirection { get; set; }

        /// <summary>
        /// Input only, and will not be stored. The trust secret used for handshake with target domain.
        /// </summary>
        [Input("trustHandshakeSecret")]
        public Input<string>? TrustHandshakeSecret { get; set; }

        /// <summary>
        /// The type of trust represented by the trust resource.
        /// </summary>
        [Input("trustType")]
        public Input<string>? TrustType { get; set; }

        /// <summary>
        /// Last update time.
        /// </summary>
        [Input("updateTime")]
        public Input<string>? UpdateTime { get; set; }

        public TrustArgs()
        {
        }
    }
}

// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Retail.V2
{
    /// <summary>
    /// The online availability of the Product. Default to Availability.IN_STOCK. Corresponding properties: Google Merchant Center property [availability](https://support.google.com/merchants/answer/6324448). Schema.org property [Offer.availability](https://schema.org/availability).
    /// </summary>
    [EnumType]
    public readonly struct ProductAvailability : IEquatable<ProductAvailability>
    {
        private readonly string _value;

        private ProductAvailability(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default product availability. Default to Availability.IN_STOCK if unset.
        /// </summary>
        public static ProductAvailability AvailabilityUnspecified { get; } = new ProductAvailability("AVAILABILITY_UNSPECIFIED");
        /// <summary>
        /// Product in stock.
        /// </summary>
        public static ProductAvailability InStock { get; } = new ProductAvailability("IN_STOCK");
        /// <summary>
        /// Product out of stock.
        /// </summary>
        public static ProductAvailability OutOfStock { get; } = new ProductAvailability("OUT_OF_STOCK");
        /// <summary>
        /// Product that is in pre-order state.
        /// </summary>
        public static ProductAvailability Preorder { get; } = new ProductAvailability("PREORDER");
        /// <summary>
        /// Product that is back-ordered (i.e. temporarily out of stock).
        /// </summary>
        public static ProductAvailability Backorder { get; } = new ProductAvailability("BACKORDER");

        public static bool operator ==(ProductAvailability left, ProductAvailability right) => left.Equals(right);
        public static bool operator !=(ProductAvailability left, ProductAvailability right) => !left.Equals(right);

        public static explicit operator string(ProductAvailability value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProductAvailability other && Equals(other);
        public bool Equals(ProductAvailability other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Immutable. The type of the product. Default to Catalog.product_level_config.ingestion_product_type if unset.
    /// </summary>
    [EnumType]
    public readonly struct ProductType : IEquatable<ProductType>
    {
        private readonly string _value;

        private ProductType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. Default to Catalog.product_level_config.ingestion_product_type if unset.
        /// </summary>
        public static ProductType TypeUnspecified { get; } = new ProductType("TYPE_UNSPECIFIED");
        /// <summary>
        /// The primary type. As the primary unit for predicting, indexing and search serving, a Type.PRIMARY Product is grouped with multiple Type.VARIANT Products.
        /// </summary>
        public static ProductType Primary { get; } = new ProductType("PRIMARY");
        /// <summary>
        /// The variant type. Type.VARIANT Products usually share some common attributes on the same Type.PRIMARY Products, but they have variant attributes like different colors, sizes and prices, etc.
        /// </summary>
        public static ProductType Variant { get; } = new ProductType("VARIANT");
        /// <summary>
        /// The collection type. Collection products are bundled Type.PRIMARY Products or Type.VARIANT Products that are sold together, such as a jewelry set with necklaces, earrings and rings, etc.
        /// </summary>
        public static ProductType Collection { get; } = new ProductType("COLLECTION");

        public static bool operator ==(ProductType left, ProductType right) => left.Equals(right);
        public static bool operator !=(ProductType left, ProductType right) => !left.Equals(right);

        public static explicit operator string(ProductType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ProductType other && Equals(other);
        public bool Equals(ProductType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

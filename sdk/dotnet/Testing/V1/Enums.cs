// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Testing.V1
{
    /// <summary>
    /// The option of whether running each test within its own invocation of instrumentation with Android Test Orchestrator or not. ** Orchestrator is only compatible with AndroidJUnitRunner version 1.0 or higher! ** Orchestrator offers the following benefits: - No shared state - Crashes are isolated - Logs are scoped per test See for more information about Android Test Orchestrator. If not set, the test will be run without the orchestrator.
    /// </summary>
    [EnumType]
    public readonly struct AndroidInstrumentationTestOrchestratorOption : IEquatable<AndroidInstrumentationTestOrchestratorOption>
    {
        private readonly string _value;

        private AndroidInstrumentationTestOrchestratorOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value: the server will choose the mode. Currently implies that the test will run without the orchestrator. In the future, all instrumentation tests will be run with the orchestrator. Using the orchestrator is highly encouraged because of all the benefits it offers.
        /// </summary>
        public static AndroidInstrumentationTestOrchestratorOption OrchestratorOptionUnspecified { get; } = new AndroidInstrumentationTestOrchestratorOption("ORCHESTRATOR_OPTION_UNSPECIFIED");
        /// <summary>
        /// Run test using orchestrator. ** Only compatible with AndroidJUnitRunner version 1.0 or higher! ** Recommended.
        /// </summary>
        public static AndroidInstrumentationTestOrchestratorOption UseOrchestrator { get; } = new AndroidInstrumentationTestOrchestratorOption("USE_ORCHESTRATOR");
        /// <summary>
        /// Run test without using orchestrator.
        /// </summary>
        public static AndroidInstrumentationTestOrchestratorOption DoNotUseOrchestrator { get; } = new AndroidInstrumentationTestOrchestratorOption("DO_NOT_USE_ORCHESTRATOR");

        public static bool operator ==(AndroidInstrumentationTestOrchestratorOption left, AndroidInstrumentationTestOrchestratorOption right) => left.Equals(right);
        public static bool operator !=(AndroidInstrumentationTestOrchestratorOption left, AndroidInstrumentationTestOrchestratorOption right) => !left.Equals(right);

        public static explicit operator string(AndroidInstrumentationTestOrchestratorOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AndroidInstrumentationTestOrchestratorOption other && Equals(other);
        public bool Equals(AndroidInstrumentationTestOrchestratorOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The type of action that Robo should perform on the specified element.
    /// </summary>
    [EnumType]
    public readonly struct RoboDirectiveActionType : IEquatable<RoboDirectiveActionType>
    {
        private readonly string _value;

        private RoboDirectiveActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DO NOT USE. For proto versioning only.
        /// </summary>
        public static RoboDirectiveActionType ActionTypeUnspecified { get; } = new RoboDirectiveActionType("ACTION_TYPE_UNSPECIFIED");
        /// <summary>
        /// Direct Robo to click on the specified element. No-op if specified element is not clickable.
        /// </summary>
        public static RoboDirectiveActionType SingleClick { get; } = new RoboDirectiveActionType("SINGLE_CLICK");
        /// <summary>
        /// Direct Robo to enter text on the specified element. No-op if specified element is not enabled or does not allow text entry.
        /// </summary>
        public static RoboDirectiveActionType EnterText { get; } = new RoboDirectiveActionType("ENTER_TEXT");
        /// <summary>
        /// Direct Robo to ignore interactions with a specific element.
        /// </summary>
        public static RoboDirectiveActionType Ignore { get; } = new RoboDirectiveActionType("IGNORE");

        public static bool operator ==(RoboDirectiveActionType left, RoboDirectiveActionType right) => left.Equals(right);
        public static bool operator !=(RoboDirectiveActionType left, RoboDirectiveActionType right) => !left.Equals(right);

        public static explicit operator string(RoboDirectiveActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RoboDirectiveActionType other && Equals(other);
        public bool Equals(RoboDirectiveActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Output only. Indicates the current progress of the test execution (e.g., FINISHED).
    /// </summary>
    [EnumType]
    public readonly struct TestExecutionState : IEquatable<TestExecutionState>
    {
        private readonly string _value;

        private TestExecutionState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use. For proto versioning only.
        /// </summary>
        public static TestExecutionState TestStateUnspecified { get; } = new TestExecutionState("TEST_STATE_UNSPECIFIED");
        /// <summary>
        /// The execution or matrix is being validated.
        /// </summary>
        public static TestExecutionState Validating { get; } = new TestExecutionState("VALIDATING");
        /// <summary>
        /// The execution or matrix is waiting for resources to become available.
        /// </summary>
        public static TestExecutionState Pending { get; } = new TestExecutionState("PENDING");
        /// <summary>
        /// The execution is currently being processed. Can only be set on an execution.
        /// </summary>
        public static TestExecutionState Running { get; } = new TestExecutionState("RUNNING");
        /// <summary>
        /// The execution or matrix has terminated normally. On a matrix this means that the matrix level processing completed normally, but individual executions may be in an ERROR state.
        /// </summary>
        public static TestExecutionState Finished { get; } = new TestExecutionState("FINISHED");
        /// <summary>
        /// The execution or matrix has stopped because it encountered an infrastructure failure.
        /// </summary>
        public static TestExecutionState Error { get; } = new TestExecutionState("ERROR");
        /// <summary>
        /// The execution was not run because it corresponds to a unsupported environment. Can only be set on an execution.
        /// </summary>
        public static TestExecutionState UnsupportedEnvironment { get; } = new TestExecutionState("UNSUPPORTED_ENVIRONMENT");
        /// <summary>
        /// The execution was not run because the provided inputs are incompatible with the requested environment. Example: requested AndroidVersion is lower than APK's minSdkVersion Can only be set on an execution.
        /// </summary>
        public static TestExecutionState IncompatibleEnvironment { get; } = new TestExecutionState("INCOMPATIBLE_ENVIRONMENT");
        /// <summary>
        /// The execution was not run because the provided inputs are incompatible with the requested architecture. Example: requested device does not support running the native code in the supplied APK Can only be set on an execution.
        /// </summary>
        public static TestExecutionState IncompatibleArchitecture { get; } = new TestExecutionState("INCOMPATIBLE_ARCHITECTURE");
        /// <summary>
        /// The user cancelled the execution. Can only be set on an execution.
        /// </summary>
        public static TestExecutionState Cancelled { get; } = new TestExecutionState("CANCELLED");
        /// <summary>
        /// The execution or matrix was not run because the provided inputs are not valid. Examples: input file is not of the expected type, is malformed/corrupt, or was flagged as malware
        /// </summary>
        public static TestExecutionState Invalid { get; } = new TestExecutionState("INVALID");

        public static bool operator ==(TestExecutionState left, TestExecutionState right) => left.Equals(right);
        public static bool operator !=(TestExecutionState left, TestExecutionState right) => !left.Equals(right);

        public static explicit operator string(TestExecutionState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TestExecutionState other && Equals(other);
        public bool Equals(TestExecutionState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Output only. Describes why the matrix is considered invalid. Only useful for matrices in the INVALID state.
    /// </summary>
    [EnumType]
    public readonly struct TestMatrixInvalidMatrixDetails : IEquatable<TestMatrixInvalidMatrixDetails>
    {
        private readonly string _value;

        private TestMatrixInvalidMatrixDetails(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use. For proto versioning only.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails InvalidMatrixDetailsUnspecified { get; } = new TestMatrixInvalidMatrixDetails("INVALID_MATRIX_DETAILS_UNSPECIFIED");
        /// <summary>
        /// The matrix is INVALID, but there are no further details available.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails DetailsUnavailable { get; } = new TestMatrixInvalidMatrixDetails("DETAILS_UNAVAILABLE");
        /// <summary>
        /// The input app APK could not be parsed.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails MalformedApk { get; } = new TestMatrixInvalidMatrixDetails("MALFORMED_APK");
        /// <summary>
        /// The input test APK could not be parsed.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails MalformedTestApk { get; } = new TestMatrixInvalidMatrixDetails("MALFORMED_TEST_APK");
        /// <summary>
        /// The AndroidManifest.xml could not be found.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails NoManifest { get; } = new TestMatrixInvalidMatrixDetails("NO_MANIFEST");
        /// <summary>
        /// The APK manifest does not declare a package name.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails NoPackageName { get; } = new TestMatrixInvalidMatrixDetails("NO_PACKAGE_NAME");
        /// <summary>
        /// The APK application ID (aka package name) is invalid. See also https://developer.android.com/studio/build/application-id
        /// </summary>
        public static TestMatrixInvalidMatrixDetails InvalidPackageName { get; } = new TestMatrixInvalidMatrixDetails("INVALID_PACKAGE_NAME");
        /// <summary>
        /// The test package and app package are the same.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails TestSameAsApp { get; } = new TestMatrixInvalidMatrixDetails("TEST_SAME_AS_APP");
        /// <summary>
        /// The test apk does not declare an instrumentation.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails NoInstrumentation { get; } = new TestMatrixInvalidMatrixDetails("NO_INSTRUMENTATION");
        /// <summary>
        /// The input app apk does not have a signature.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails NoSignature { get; } = new TestMatrixInvalidMatrixDetails("NO_SIGNATURE");
        /// <summary>
        /// The test runner class specified by user or in the test APK's manifest file is not compatible with Android Test Orchestrator. Orchestrator is only compatible with AndroidJUnitRunner version 1.0 or higher. Orchestrator can be disabled by using DO_NOT_USE_ORCHESTRATOR OrchestratorOption.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails InstrumentationOrchestratorIncompatible { get; } = new TestMatrixInvalidMatrixDetails("INSTRUMENTATION_ORCHESTRATOR_INCOMPATIBLE");
        /// <summary>
        /// The test APK does not contain the test runner class specified by user or in the manifest file. This can be caused by either of the following reasons: - the user provided a runner class name that's incorrect, or - the test runner isn't built into the test APK (might be in the app APK instead).
        /// </summary>
        public static TestMatrixInvalidMatrixDetails NoTestRunnerClass { get; } = new TestMatrixInvalidMatrixDetails("NO_TEST_RUNNER_CLASS");
        /// <summary>
        /// A main launcher activity could not be found.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails NoLauncherActivity { get; } = new TestMatrixInvalidMatrixDetails("NO_LAUNCHER_ACTIVITY");
        /// <summary>
        /// The app declares one or more permissions that are not allowed.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails ForbiddenPermissions { get; } = new TestMatrixInvalidMatrixDetails("FORBIDDEN_PERMISSIONS");
        /// <summary>
        /// There is a conflict in the provided robo_directives.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails InvalidRoboDirectives { get; } = new TestMatrixInvalidMatrixDetails("INVALID_ROBO_DIRECTIVES");
        /// <summary>
        /// There is at least one invalid resource name in the provided robo directives
        /// </summary>
        public static TestMatrixInvalidMatrixDetails InvalidResourceName { get; } = new TestMatrixInvalidMatrixDetails("INVALID_RESOURCE_NAME");
        /// <summary>
        /// Invalid definition of action in the robo directives (e.g. a click or ignore action includes an input text field)
        /// </summary>
        public static TestMatrixInvalidMatrixDetails InvalidDirectiveAction { get; } = new TestMatrixInvalidMatrixDetails("INVALID_DIRECTIVE_ACTION");
        /// <summary>
        /// There is no test loop intent filter, or the one that is given is not formatted correctly.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails TestLoopIntentFilterNotFound { get; } = new TestMatrixInvalidMatrixDetails("TEST_LOOP_INTENT_FILTER_NOT_FOUND");
        /// <summary>
        /// The request contains a scenario label that was not declared in the manifest.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails ScenarioLabelNotDeclared { get; } = new TestMatrixInvalidMatrixDetails("SCENARIO_LABEL_NOT_DECLARED");
        /// <summary>
        /// There was an error when parsing a label's value.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails ScenarioLabelMalformed { get; } = new TestMatrixInvalidMatrixDetails("SCENARIO_LABEL_MALFORMED");
        /// <summary>
        /// The request contains a scenario number that was not declared in the manifest.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails ScenarioNotDeclared { get; } = new TestMatrixInvalidMatrixDetails("SCENARIO_NOT_DECLARED");
        /// <summary>
        /// Device administrator applications are not allowed.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails DeviceAdminReceiver { get; } = new TestMatrixInvalidMatrixDetails("DEVICE_ADMIN_RECEIVER");
        /// <summary>
        /// The zipped XCTest was malformed. The zip did not contain a single .xctestrun file and the contents of the DerivedData/Build/Products directory.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails MalformedXcTestZip { get; } = new TestMatrixInvalidMatrixDetails("MALFORMED_XC_TEST_ZIP");
        /// <summary>
        /// The zipped XCTest was built for the iOS simulator rather than for a physical device.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails BuiltForIosSimulator { get; } = new TestMatrixInvalidMatrixDetails("BUILT_FOR_IOS_SIMULATOR");
        /// <summary>
        /// The .xctestrun file did not specify any test targets.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails NoTestsInXcTestZip { get; } = new TestMatrixInvalidMatrixDetails("NO_TESTS_IN_XC_TEST_ZIP");
        /// <summary>
        /// One or more of the test targets defined in the .xctestrun file specifies "UseDestinationArtifacts", which is disallowed.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails UseDestinationArtifacts { get; } = new TestMatrixInvalidMatrixDetails("USE_DESTINATION_ARTIFACTS");
        /// <summary>
        /// XC tests which run on physical devices must have "IsAppHostedTestBundle" == "true" in the xctestrun file.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails TestNotAppHosted { get; } = new TestMatrixInvalidMatrixDetails("TEST_NOT_APP_HOSTED");
        /// <summary>
        /// An Info.plist file in the XCTest zip could not be parsed.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails PlistCannotBeParsed { get; } = new TestMatrixInvalidMatrixDetails("PLIST_CANNOT_BE_PARSED");
        /// <summary>
        /// The APK is marked as "testOnly". Deprecated and not currently used.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails TestOnlyApk { get; } = new TestMatrixInvalidMatrixDetails("TEST_ONLY_APK");
        /// <summary>
        /// The input IPA could not be parsed.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails MalformedIpa { get; } = new TestMatrixInvalidMatrixDetails("MALFORMED_IPA");
        /// <summary>
        /// The application doesn't register the game loop URL scheme.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails MissingUrlScheme { get; } = new TestMatrixInvalidMatrixDetails("MISSING_URL_SCHEME");
        /// <summary>
        /// The iOS application bundle (.app) couldn't be processed.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails MalformedAppBundle { get; } = new TestMatrixInvalidMatrixDetails("MALFORMED_APP_BUNDLE");
        /// <summary>
        /// APK contains no code. See also https://developer.android.com/guide/topics/manifest/application-element.html#code
        /// </summary>
        public static TestMatrixInvalidMatrixDetails NoCodeApk { get; } = new TestMatrixInvalidMatrixDetails("NO_CODE_APK");
        /// <summary>
        /// Either the provided input APK path was malformed, the APK file does not exist, or the user does not have permission to access the APK file.
        /// </summary>
        public static TestMatrixInvalidMatrixDetails InvalidInputApk { get; } = new TestMatrixInvalidMatrixDetails("INVALID_INPUT_APK");
        /// <summary>
        /// APK is built for a preview SDK which is unsupported
        /// </summary>
        public static TestMatrixInvalidMatrixDetails InvalidApkPreviewSdk { get; } = new TestMatrixInvalidMatrixDetails("INVALID_APK_PREVIEW_SDK");

        public static bool operator ==(TestMatrixInvalidMatrixDetails left, TestMatrixInvalidMatrixDetails right) => left.Equals(right);
        public static bool operator !=(TestMatrixInvalidMatrixDetails left, TestMatrixInvalidMatrixDetails right) => !left.Equals(right);

        public static explicit operator string(TestMatrixInvalidMatrixDetails value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TestMatrixInvalidMatrixDetails other && Equals(other);
        public bool Equals(TestMatrixInvalidMatrixDetails other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Output Only. The overall outcome of the test. Only set when the test matrix state is FINISHED.
    /// </summary>
    [EnumType]
    public readonly struct TestMatrixOutcomeSummary : IEquatable<TestMatrixOutcomeSummary>
    {
        private readonly string _value;

        private TestMatrixOutcomeSummary(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use. For proto versioning only.
        /// </summary>
        public static TestMatrixOutcomeSummary OutcomeSummaryUnspecified { get; } = new TestMatrixOutcomeSummary("OUTCOME_SUMMARY_UNSPECIFIED");
        /// <summary>
        /// The test matrix run was successful, for instance: - All the test cases passed. - Robo did not detect a crash of the application under test.
        /// </summary>
        public static TestMatrixOutcomeSummary Success { get; } = new TestMatrixOutcomeSummary("SUCCESS");
        /// <summary>
        /// A run failed, for instance: - One or more test case failed. - A test timed out. - The application under test crashed.
        /// </summary>
        public static TestMatrixOutcomeSummary Failure { get; } = new TestMatrixOutcomeSummary("FAILURE");
        /// <summary>
        /// Something unexpected happened. The run should still be considered unsuccessful but this is likely a transient problem and re-running the test might be successful.
        /// </summary>
        public static TestMatrixOutcomeSummary Inconclusive { get; } = new TestMatrixOutcomeSummary("INCONCLUSIVE");
        /// <summary>
        /// All tests were skipped, for instance: - All device configurations were incompatible.
        /// </summary>
        public static TestMatrixOutcomeSummary Skipped { get; } = new TestMatrixOutcomeSummary("SKIPPED");

        public static bool operator ==(TestMatrixOutcomeSummary left, TestMatrixOutcomeSummary right) => left.Equals(right);
        public static bool operator !=(TestMatrixOutcomeSummary left, TestMatrixOutcomeSummary right) => !left.Equals(right);

        public static explicit operator string(TestMatrixOutcomeSummary value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TestMatrixOutcomeSummary other && Equals(other);
        public bool Equals(TestMatrixOutcomeSummary other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Output only. Indicates the current progress of the test matrix.
    /// </summary>
    [EnumType]
    public readonly struct TestMatrixState : IEquatable<TestMatrixState>
    {
        private readonly string _value;

        private TestMatrixState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use. For proto versioning only.
        /// </summary>
        public static TestMatrixState TestStateUnspecified { get; } = new TestMatrixState("TEST_STATE_UNSPECIFIED");
        /// <summary>
        /// The execution or matrix is being validated.
        /// </summary>
        public static TestMatrixState Validating { get; } = new TestMatrixState("VALIDATING");
        /// <summary>
        /// The execution or matrix is waiting for resources to become available.
        /// </summary>
        public static TestMatrixState Pending { get; } = new TestMatrixState("PENDING");
        /// <summary>
        /// The execution is currently being processed. Can only be set on an execution.
        /// </summary>
        public static TestMatrixState Running { get; } = new TestMatrixState("RUNNING");
        /// <summary>
        /// The execution or matrix has terminated normally. On a matrix this means that the matrix level processing completed normally, but individual executions may be in an ERROR state.
        /// </summary>
        public static TestMatrixState Finished { get; } = new TestMatrixState("FINISHED");
        /// <summary>
        /// The execution or matrix has stopped because it encountered an infrastructure failure.
        /// </summary>
        public static TestMatrixState Error { get; } = new TestMatrixState("ERROR");
        /// <summary>
        /// The execution was not run because it corresponds to a unsupported environment. Can only be set on an execution.
        /// </summary>
        public static TestMatrixState UnsupportedEnvironment { get; } = new TestMatrixState("UNSUPPORTED_ENVIRONMENT");
        /// <summary>
        /// The execution was not run because the provided inputs are incompatible with the requested environment. Example: requested AndroidVersion is lower than APK's minSdkVersion Can only be set on an execution.
        /// </summary>
        public static TestMatrixState IncompatibleEnvironment { get; } = new TestMatrixState("INCOMPATIBLE_ENVIRONMENT");
        /// <summary>
        /// The execution was not run because the provided inputs are incompatible with the requested architecture. Example: requested device does not support running the native code in the supplied APK Can only be set on an execution.
        /// </summary>
        public static TestMatrixState IncompatibleArchitecture { get; } = new TestMatrixState("INCOMPATIBLE_ARCHITECTURE");
        /// <summary>
        /// The user cancelled the execution. Can only be set on an execution.
        /// </summary>
        public static TestMatrixState Cancelled { get; } = new TestMatrixState("CANCELLED");
        /// <summary>
        /// The execution or matrix was not run because the provided inputs are not valid. Examples: input file is not of the expected type, is malformed/corrupt, or was flagged as malware
        /// </summary>
        public static TestMatrixState Invalid { get; } = new TestMatrixState("INVALID");

        public static bool operator ==(TestMatrixState left, TestMatrixState right) => left.Equals(right);
        public static bool operator !=(TestMatrixState left, TestMatrixState right) => !left.Equals(right);

        public static explicit operator string(TestMatrixState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TestMatrixState other && Equals(other);
        public bool Equals(TestMatrixState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

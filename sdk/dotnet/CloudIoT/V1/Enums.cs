// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.CloudIoT.V1
{
    /// <summary>
    /// **Beta Feature** The logging verbosity for device activity. If unspecified, DeviceRegistry.log_level will be used.
    /// </summary>
    [EnumType]
    public readonly struct DeviceLogLevel : IEquatable<DeviceLogLevel>
    {
        private readonly string _value;

        private DeviceLogLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No logging specified. If not specified, logging will be disabled.
        /// </summary>
        public static DeviceLogLevel LogLevelUnspecified { get; } = new DeviceLogLevel("LOG_LEVEL_UNSPECIFIED");
        /// <summary>
        /// Disables logging.
        /// </summary>
        public static DeviceLogLevel None { get; } = new DeviceLogLevel("NONE");
        /// <summary>
        /// Error events will be logged.
        /// </summary>
        public static DeviceLogLevel Error { get; } = new DeviceLogLevel("ERROR");
        /// <summary>
        /// Informational events will be logged, such as connections and disconnections.
        /// </summary>
        public static DeviceLogLevel Info { get; } = new DeviceLogLevel("INFO");
        /// <summary>
        /// All events will be logged.
        /// </summary>
        public static DeviceLogLevel Debug { get; } = new DeviceLogLevel("DEBUG");

        public static bool operator ==(DeviceLogLevel left, DeviceLogLevel right) => left.Equals(right);
        public static bool operator !=(DeviceLogLevel left, DeviceLogLevel right) => !left.Equals(right);

        public static explicit operator string(DeviceLogLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeviceLogLevel other && Equals(other);
        public bool Equals(DeviceLogLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates how to authorize and/or authenticate devices to access the gateway.
    /// </summary>
    [EnumType]
    public readonly struct GatewayConfigGatewayAuthMethod : IEquatable<GatewayConfigGatewayAuthMethod>
    {
        private readonly string _value;

        private GatewayConfigGatewayAuthMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No authentication/authorization method specified. No devices are allowed to access the gateway.
        /// </summary>
        public static GatewayConfigGatewayAuthMethod GatewayAuthMethodUnspecified { get; } = new GatewayConfigGatewayAuthMethod("GATEWAY_AUTH_METHOD_UNSPECIFIED");
        /// <summary>
        /// The device is authenticated through the gateway association only. Device credentials are ignored even if provided.
        /// </summary>
        public static GatewayConfigGatewayAuthMethod AssociationOnly { get; } = new GatewayConfigGatewayAuthMethod("ASSOCIATION_ONLY");
        /// <summary>
        /// The device is authenticated through its own credentials. Gateway association is not checked.
        /// </summary>
        public static GatewayConfigGatewayAuthMethod DeviceAuthTokenOnly { get; } = new GatewayConfigGatewayAuthMethod("DEVICE_AUTH_TOKEN_ONLY");
        /// <summary>
        /// The device is authenticated through both device credentials and gateway association. The device must be bound to the gateway and must provide its own credentials.
        /// </summary>
        public static GatewayConfigGatewayAuthMethod AssociationAndDeviceAuthToken { get; } = new GatewayConfigGatewayAuthMethod("ASSOCIATION_AND_DEVICE_AUTH_TOKEN");

        public static bool operator ==(GatewayConfigGatewayAuthMethod left, GatewayConfigGatewayAuthMethod right) => left.Equals(right);
        public static bool operator !=(GatewayConfigGatewayAuthMethod left, GatewayConfigGatewayAuthMethod right) => !left.Equals(right);

        public static explicit operator string(GatewayConfigGatewayAuthMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GatewayConfigGatewayAuthMethod other && Equals(other);
        public bool Equals(GatewayConfigGatewayAuthMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the device is a gateway.
    /// </summary>
    [EnumType]
    public readonly struct GatewayConfigGatewayType : IEquatable<GatewayConfigGatewayType>
    {
        private readonly string _value;

        private GatewayConfigGatewayType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// If unspecified, the device is considered a non-gateway device.
        /// </summary>
        public static GatewayConfigGatewayType GatewayTypeUnspecified { get; } = new GatewayConfigGatewayType("GATEWAY_TYPE_UNSPECIFIED");
        /// <summary>
        /// The device is a gateway.
        /// </summary>
        public static GatewayConfigGatewayType Gateway { get; } = new GatewayConfigGatewayType("GATEWAY");
        /// <summary>
        /// The device is not a gateway.
        /// </summary>
        public static GatewayConfigGatewayType NonGateway { get; } = new GatewayConfigGatewayType("NON_GATEWAY");

        public static bool operator ==(GatewayConfigGatewayType left, GatewayConfigGatewayType right) => left.Equals(right);
        public static bool operator !=(GatewayConfigGatewayType left, GatewayConfigGatewayType right) => !left.Equals(right);

        public static explicit operator string(GatewayConfigGatewayType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GatewayConfigGatewayType other && Equals(other);
        public bool Equals(GatewayConfigGatewayType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If enabled, allows devices to use DeviceService via the HTTP protocol. Otherwise, any requests to DeviceService will fail for this registry.
    /// </summary>
    [EnumType]
    public readonly struct HttpConfigHttpEnabledState : IEquatable<HttpConfigHttpEnabledState>
    {
        private readonly string _value;

        private HttpConfigHttpEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No HTTP state specified. If not specified, DeviceService will be enabled by default.
        /// </summary>
        public static HttpConfigHttpEnabledState HttpStateUnspecified { get; } = new HttpConfigHttpEnabledState("HTTP_STATE_UNSPECIFIED");
        /// <summary>
        /// Enables DeviceService (HTTP) service for the registry.
        /// </summary>
        public static HttpConfigHttpEnabledState HttpEnabled { get; } = new HttpConfigHttpEnabledState("HTTP_ENABLED");
        /// <summary>
        /// Disables DeviceService (HTTP) service for the registry.
        /// </summary>
        public static HttpConfigHttpEnabledState HttpDisabled { get; } = new HttpConfigHttpEnabledState("HTTP_DISABLED");

        public static bool operator ==(HttpConfigHttpEnabledState left, HttpConfigHttpEnabledState right) => left.Equals(right);
        public static bool operator !=(HttpConfigHttpEnabledState left, HttpConfigHttpEnabledState right) => !left.Equals(right);

        public static explicit operator string(HttpConfigHttpEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HttpConfigHttpEnabledState other && Equals(other);
        public bool Equals(HttpConfigHttpEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If enabled, allows connections using the MQTT protocol. Otherwise, MQTT connections to this registry will fail.
    /// </summary>
    [EnumType]
    public readonly struct MqttConfigMqttEnabledState : IEquatable<MqttConfigMqttEnabledState>
    {
        private readonly string _value;

        private MqttConfigMqttEnabledState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No MQTT state specified. If not specified, MQTT will be enabled by default.
        /// </summary>
        public static MqttConfigMqttEnabledState MqttStateUnspecified { get; } = new MqttConfigMqttEnabledState("MQTT_STATE_UNSPECIFIED");
        /// <summary>
        /// Enables a MQTT connection.
        /// </summary>
        public static MqttConfigMqttEnabledState MqttEnabled { get; } = new MqttConfigMqttEnabledState("MQTT_ENABLED");
        /// <summary>
        /// Disables a MQTT connection.
        /// </summary>
        public static MqttConfigMqttEnabledState MqttDisabled { get; } = new MqttConfigMqttEnabledState("MQTT_DISABLED");

        public static bool operator ==(MqttConfigMqttEnabledState left, MqttConfigMqttEnabledState right) => left.Equals(right);
        public static bool operator !=(MqttConfigMqttEnabledState left, MqttConfigMqttEnabledState right) => !left.Equals(right);

        public static explicit operator string(MqttConfigMqttEnabledState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MqttConfigMqttEnabledState other && Equals(other);
        public bool Equals(MqttConfigMqttEnabledState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The certificate format.
    /// </summary>
    [EnumType]
    public readonly struct PublicKeyCertificateFormat : IEquatable<PublicKeyCertificateFormat>
    {
        private readonly string _value;

        private PublicKeyCertificateFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The format has not been specified. This is an invalid default value and must not be used.
        /// </summary>
        public static PublicKeyCertificateFormat UnspecifiedPublicKeyCertificateFormat { get; } = new PublicKeyCertificateFormat("UNSPECIFIED_PUBLIC_KEY_CERTIFICATE_FORMAT");
        /// <summary>
        /// An X.509v3 certificate ([RFC5280](https://www.ietf.org/rfc/rfc5280.txt)), encoded in base64, and wrapped by `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----`.
        /// </summary>
        public static PublicKeyCertificateFormat X509CertificatePem { get; } = new PublicKeyCertificateFormat("X509_CERTIFICATE_PEM");

        public static bool operator ==(PublicKeyCertificateFormat left, PublicKeyCertificateFormat right) => left.Equals(right);
        public static bool operator !=(PublicKeyCertificateFormat left, PublicKeyCertificateFormat right) => !left.Equals(right);

        public static explicit operator string(PublicKeyCertificateFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicKeyCertificateFormat other && Equals(other);
        public bool Equals(PublicKeyCertificateFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format of the key.
    /// </summary>
    [EnumType]
    public readonly struct PublicKeyCredentialFormat : IEquatable<PublicKeyCredentialFormat>
    {
        private readonly string _value;

        private PublicKeyCredentialFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The format has not been specified. This is an invalid default value and must not be used.
        /// </summary>
        public static PublicKeyCredentialFormat UnspecifiedPublicKeyFormat { get; } = new PublicKeyCredentialFormat("UNSPECIFIED_PUBLIC_KEY_FORMAT");
        /// <summary>
        /// An RSA public key encoded in base64, and wrapped by `-----BEGIN PUBLIC KEY-----` and `-----END PUBLIC KEY-----`. This can be used to verify `RS256` signatures in JWT tokens ([RFC7518]( https://www.ietf.org/rfc/rfc7518.txt)).
        /// </summary>
        public static PublicKeyCredentialFormat RsaPem { get; } = new PublicKeyCredentialFormat("RSA_PEM");
        /// <summary>
        /// As RSA_PEM, but wrapped in an X.509v3 certificate ([RFC5280]( https://www.ietf.org/rfc/rfc5280.txt)), encoded in base64, and wrapped by `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----`.
        /// </summary>
        public static PublicKeyCredentialFormat RsaX509Pem { get; } = new PublicKeyCredentialFormat("RSA_X509_PEM");
        /// <summary>
        /// Public key for the ECDSA algorithm using P-256 and SHA-256, encoded in base64, and wrapped by `-----BEGIN PUBLIC KEY-----` and `-----END PUBLIC KEY-----`. This can be used to verify JWT tokens with the `ES256` algorithm ([RFC7518](https://www.ietf.org/rfc/rfc7518.txt)). This curve is defined in [OpenSSL](https://www.openssl.org/) as the `prime256v1` curve.
        /// </summary>
        public static PublicKeyCredentialFormat Es256Pem { get; } = new PublicKeyCredentialFormat("ES256_PEM");
        /// <summary>
        /// As ES256_PEM, but wrapped in an X.509v3 certificate ([RFC5280]( https://www.ietf.org/rfc/rfc5280.txt)), encoded in base64, and wrapped by `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----`.
        /// </summary>
        public static PublicKeyCredentialFormat Es256X509Pem { get; } = new PublicKeyCredentialFormat("ES256_X509_PEM");

        public static bool operator ==(PublicKeyCredentialFormat left, PublicKeyCredentialFormat right) => left.Equals(right);
        public static bool operator !=(PublicKeyCredentialFormat left, PublicKeyCredentialFormat right) => !left.Equals(right);

        public static explicit operator string(PublicKeyCredentialFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicKeyCredentialFormat other && Equals(other);
        public bool Equals(PublicKeyCredentialFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// **Beta Feature** The default logging verbosity for activity from devices in this registry. The verbosity level can be overridden by Device.log_level.
    /// </summary>
    [EnumType]
    public readonly struct RegistryLogLevel : IEquatable<RegistryLogLevel>
    {
        private readonly string _value;

        private RegistryLogLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No logging specified. If not specified, logging will be disabled.
        /// </summary>
        public static RegistryLogLevel LogLevelUnspecified { get; } = new RegistryLogLevel("LOG_LEVEL_UNSPECIFIED");
        /// <summary>
        /// Disables logging.
        /// </summary>
        public static RegistryLogLevel None { get; } = new RegistryLogLevel("NONE");
        /// <summary>
        /// Error events will be logged.
        /// </summary>
        public static RegistryLogLevel Error { get; } = new RegistryLogLevel("ERROR");
        /// <summary>
        /// Informational events will be logged, such as connections and disconnections.
        /// </summary>
        public static RegistryLogLevel Info { get; } = new RegistryLogLevel("INFO");
        /// <summary>
        /// All events will be logged.
        /// </summary>
        public static RegistryLogLevel Debug { get; } = new RegistryLogLevel("DEBUG");

        public static bool operator ==(RegistryLogLevel left, RegistryLogLevel right) => left.Equals(right);
        public static bool operator !=(RegistryLogLevel left, RegistryLogLevel right) => !left.Equals(right);

        public static explicit operator string(RegistryLogLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegistryLogLevel other && Equals(other);
        public bool Equals(RegistryLogLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

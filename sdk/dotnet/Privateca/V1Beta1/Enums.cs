// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Privateca.V1Beta1
{
    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct AuditLogConfigLogType : IEquatable<AuditLogConfigLogType>
    {
        private readonly string _value;

        private AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default case. Should never be this.
        /// </summary>
        public static AuditLogConfigLogType LogTypeUnspecified { get; } = new AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");
        /// <summary>
        /// Admin reads. Example: CloudIAM getIamPolicy
        /// </summary>
        public static AuditLogConfigLogType AdminRead { get; } = new AuditLogConfigLogType("ADMIN_READ");
        /// <summary>
        /// Data writes. Example: CloudSQL Users create
        /// </summary>
        public static AuditLogConfigLogType DataWrite { get; } = new AuditLogConfigLogType("DATA_WRITE");
        /// <summary>
        /// Data reads. Example: CloudSQL Users list
        /// </summary>
        public static AuditLogConfigLogType DataRead { get; } = new AuditLogConfigLogType("DATA_READ");

        public static bool operator ==(AuditLogConfigLogType left, AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(AuditLogConfigLogType left, AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuditLogConfigLogType other && Equals(other);
        public bool Equals(AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Immutable. The Tier of this CertificateAuthority.
    /// </summary>
    [EnumType]
    public readonly struct CertificateAuthorityTier : IEquatable<CertificateAuthorityTier>
    {
        private readonly string _value;

        private CertificateAuthorityTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified.
        /// </summary>
        public static CertificateAuthorityTier TierUnspecified { get; } = new CertificateAuthorityTier("TIER_UNSPECIFIED");
        /// <summary>
        /// Enterprise tier.
        /// </summary>
        public static CertificateAuthorityTier Enterprise { get; } = new CertificateAuthorityTier("ENTERPRISE");
        /// <summary>
        /// DevOps tier.
        /// </summary>
        public static CertificateAuthorityTier Devops { get; } = new CertificateAuthorityTier("DEVOPS");

        public static bool operator ==(CertificateAuthorityTier left, CertificateAuthorityTier right) => left.Equals(right);
        public static bool operator !=(CertificateAuthorityTier left, CertificateAuthorityTier right) => !left.Equals(right);

        public static explicit operator string(CertificateAuthorityTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CertificateAuthorityTier other && Equals(other);
        public bool Equals(CertificateAuthorityTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Immutable. The Type of this CertificateAuthority.
    /// </summary>
    [EnumType]
    public readonly struct CertificateAuthorityType : IEquatable<CertificateAuthorityType>
    {
        private readonly string _value;

        private CertificateAuthorityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified.
        /// </summary>
        public static CertificateAuthorityType TypeUnspecified { get; } = new CertificateAuthorityType("TYPE_UNSPECIFIED");
        /// <summary>
        /// Self-signed CA.
        /// </summary>
        public static CertificateAuthorityType SelfSigned { get; } = new CertificateAuthorityType("SELF_SIGNED");
        /// <summary>
        /// Subordinate CA. Could be issued by a Private CA CertificateAuthority or an unmanaged CA.
        /// </summary>
        public static CertificateAuthorityType Subordinate { get; } = new CertificateAuthorityType("SUBORDINATE");

        public static bool operator ==(CertificateAuthorityType left, CertificateAuthorityType right) => left.Equals(right);
        public static bool operator !=(CertificateAuthorityType left, CertificateAuthorityType right) => !left.Equals(right);

        public static explicit operator string(CertificateAuthorityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CertificateAuthorityType other && Equals(other);
        public bool Equals(CertificateAuthorityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The algorithm to use for creating a managed Cloud KMS key for a for a simplified experience. All managed keys will be have their ProtectionLevel as `HSM`.
    /// </summary>
    [EnumType]
    public readonly struct KeyVersionSpecAlgorithm : IEquatable<KeyVersionSpecAlgorithm>
    {
        private readonly string _value;

        private KeyVersionSpecAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified.
        /// </summary>
        public static KeyVersionSpecAlgorithm SignHashAlgorithmUnspecified { get; } = new KeyVersionSpecAlgorithm("SIGN_HASH_ALGORITHM_UNSPECIFIED");
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256
        /// </summary>
        public static KeyVersionSpecAlgorithm RsaPss2048Sha256 { get; } = new KeyVersionSpecAlgorithm("RSA_PSS_2048_SHA256");
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm. RSA_SIGN_PSS_3072_SHA256
        /// </summary>
        public static KeyVersionSpecAlgorithm RsaPss3072Sha256 { get; } = new KeyVersionSpecAlgorithm("RSA_PSS_3072_SHA256");
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_4096_SHA256
        /// </summary>
        public static KeyVersionSpecAlgorithm RsaPss4096Sha256 { get; } = new KeyVersionSpecAlgorithm("RSA_PSS_4096_SHA256");
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_2048_SHA256
        /// </summary>
        public static KeyVersionSpecAlgorithm RsaPkcs12048Sha256 { get; } = new KeyVersionSpecAlgorithm("RSA_PKCS1_2048_SHA256");
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_3072_SHA256
        /// </summary>
        public static KeyVersionSpecAlgorithm RsaPkcs13072Sha256 { get; } = new KeyVersionSpecAlgorithm("RSA_PKCS1_3072_SHA256");
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_4096_SHA256
        /// </summary>
        public static KeyVersionSpecAlgorithm RsaPkcs14096Sha256 { get; } = new KeyVersionSpecAlgorithm("RSA_PKCS1_4096_SHA256");
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.EC_SIGN_P256_SHA256
        /// </summary>
        public static KeyVersionSpecAlgorithm EcP256Sha256 { get; } = new KeyVersionSpecAlgorithm("EC_P256_SHA256");
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.EC_SIGN_P384_SHA384
        /// </summary>
        public static KeyVersionSpecAlgorithm EcP384Sha384 { get; } = new KeyVersionSpecAlgorithm("EC_P384_SHA384");

        public static bool operator ==(KeyVersionSpecAlgorithm left, KeyVersionSpecAlgorithm right) => left.Equals(right);
        public static bool operator !=(KeyVersionSpecAlgorithm left, KeyVersionSpecAlgorithm right) => !left.Equals(right);

        public static explicit operator string(KeyVersionSpecAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeyVersionSpecAlgorithm other && Equals(other);
        public bool Equals(KeyVersionSpecAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The type of public key. If specified, it must match the public key used for the`key` field.
    /// </summary>
    [EnumType]
    public readonly struct PublicKeyType : IEquatable<PublicKeyType>
    {
        private readonly string _value;

        private PublicKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default unspecified value.
        /// </summary>
        public static PublicKeyType KeyTypeUnspecified { get; } = new PublicKeyType("KEY_TYPE_UNSPECIFIED");
        /// <summary>
        /// A PEM-encoded PKCS#1/RFC 3447 RSAPublicKey structure, or an RFC 5280 [SubjectPublicKeyInfo](https://tools.ietf.org/html/rfc5280#section-4.1) structure containing the former.
        /// </summary>
        public static PublicKeyType PemRsaKey { get; } = new PublicKeyType("PEM_RSA_KEY");
        /// <summary>
        /// An RFC 5280 [SubjectPublicKeyInfo](https://tools.ietf.org/html/rfc5280#section-4.1) structure containing a PEM-encoded compressed NIST P-256/secp256r1/prime256v1 or P-384 key.
        /// </summary>
        public static PublicKeyType PemEcKey { get; } = new PublicKeyType("PEM_EC_KEY");

        public static bool operator ==(PublicKeyType left, PublicKeyType right) => left.Equals(right);
        public static bool operator !=(PublicKeyType left, PublicKeyType right) => !left.Equals(right);

        public static explicit operator string(PublicKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicKeyType other && Equals(other);
        public bool Equals(PublicKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

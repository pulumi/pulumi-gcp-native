// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Firestore.V1
{
    /// <summary>
    /// The App Engine integration mode to use for this database.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseAppEngineIntegrationMode : IEquatable<DatabaseAppEngineIntegrationMode>
    {
        private readonly string _value;

        private DatabaseAppEngineIntegrationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not used.
        /// </summary>
        public static DatabaseAppEngineIntegrationMode AppEngineIntegrationModeUnspecified { get; } = new DatabaseAppEngineIntegrationMode("APP_ENGINE_INTEGRATION_MODE_UNSPECIFIED");
        /// <summary>
        /// If an App Engine application exists in the same region as this database, App Engine configuration will impact this database. This includes disabling of the application &amp; database, as well as disabling writes to the database.
        /// </summary>
        public static DatabaseAppEngineIntegrationMode Enabled { get; } = new DatabaseAppEngineIntegrationMode("ENABLED");
        /// <summary>
        /// App Engine has no effect on the ability of this database to serve requests. This is the default setting for databases created with the Firestore API.
        /// </summary>
        public static DatabaseAppEngineIntegrationMode Disabled { get; } = new DatabaseAppEngineIntegrationMode("DISABLED");

        public static bool operator ==(DatabaseAppEngineIntegrationMode left, DatabaseAppEngineIntegrationMode right) => left.Equals(right);
        public static bool operator !=(DatabaseAppEngineIntegrationMode left, DatabaseAppEngineIntegrationMode right) => !left.Equals(right);

        public static explicit operator string(DatabaseAppEngineIntegrationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseAppEngineIntegrationMode other && Equals(other);
        public bool Equals(DatabaseAppEngineIntegrationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The concurrency control mode to use for this database.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseConcurrencyMode : IEquatable<DatabaseConcurrencyMode>
    {
        private readonly string _value;

        private DatabaseConcurrencyMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not used.
        /// </summary>
        public static DatabaseConcurrencyMode ConcurrencyModeUnspecified { get; } = new DatabaseConcurrencyMode("CONCURRENCY_MODE_UNSPECIFIED");
        /// <summary>
        /// Use optimistic concurrency control by default. This mode is available for Cloud Firestore databases.
        /// </summary>
        public static DatabaseConcurrencyMode Optimistic { get; } = new DatabaseConcurrencyMode("OPTIMISTIC");
        /// <summary>
        /// Use pessimistic concurrency control by default. This mode is available for Cloud Firestore databases. This is the default setting for Cloud Firestore.
        /// </summary>
        public static DatabaseConcurrencyMode Pessimistic { get; } = new DatabaseConcurrencyMode("PESSIMISTIC");
        /// <summary>
        /// Use optimistic concurrency control with entity groups by default. This is the only available mode for Cloud Datastore. This mode is also available for Cloud Firestore with Datastore Mode but is not recommended.
        /// </summary>
        public static DatabaseConcurrencyMode OptimisticWithEntityGroups { get; } = new DatabaseConcurrencyMode("OPTIMISTIC_WITH_ENTITY_GROUPS");

        public static bool operator ==(DatabaseConcurrencyMode left, DatabaseConcurrencyMode right) => left.Equals(right);
        public static bool operator !=(DatabaseConcurrencyMode left, DatabaseConcurrencyMode right) => !left.Equals(right);

        public static explicit operator string(DatabaseConcurrencyMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseConcurrencyMode other && Equals(other);
        public bool Equals(DatabaseConcurrencyMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State of delete protection for the database.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseDeleteProtectionState : IEquatable<DatabaseDeleteProtectionState>
    {
        private readonly string _value;

        private DatabaseDeleteProtectionState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default value. Delete protection type is not specified
        /// </summary>
        public static DatabaseDeleteProtectionState DeleteProtectionStateUnspecified { get; } = new DatabaseDeleteProtectionState("DELETE_PROTECTION_STATE_UNSPECIFIED");
        /// <summary>
        /// Delete protection is disabled
        /// </summary>
        public static DatabaseDeleteProtectionState DeleteProtectionDisabled { get; } = new DatabaseDeleteProtectionState("DELETE_PROTECTION_DISABLED");
        /// <summary>
        /// Delete protection is enabled
        /// </summary>
        public static DatabaseDeleteProtectionState DeleteProtectionEnabled { get; } = new DatabaseDeleteProtectionState("DELETE_PROTECTION_ENABLED");

        public static bool operator ==(DatabaseDeleteProtectionState left, DatabaseDeleteProtectionState right) => left.Equals(right);
        public static bool operator !=(DatabaseDeleteProtectionState left, DatabaseDeleteProtectionState right) => !left.Equals(right);

        public static explicit operator string(DatabaseDeleteProtectionState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseDeleteProtectionState other && Equals(other);
        public bool Equals(DatabaseDeleteProtectionState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to enable the PITR feature on this database.
    /// </summary>
    [EnumType]
    public readonly struct DatabasePointInTimeRecoveryEnablement : IEquatable<DatabasePointInTimeRecoveryEnablement>
    {
        private readonly string _value;

        private DatabasePointInTimeRecoveryEnablement(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not used.
        /// </summary>
        public static DatabasePointInTimeRecoveryEnablement PointInTimeRecoveryEnablementUnspecified { get; } = new DatabasePointInTimeRecoveryEnablement("POINT_IN_TIME_RECOVERY_ENABLEMENT_UNSPECIFIED");
        /// <summary>
        /// Reads are supported on selected versions of the data from within the past 7 days: * Reads against any timestamp within the past hour * Reads against 1-minute snapshots beyond 1 hour and within 7 days `version_retention_period` and `earliest_version_time` can be used to determine the supported versions.
        /// </summary>
        public static DatabasePointInTimeRecoveryEnablement PointInTimeRecoveryEnabled { get; } = new DatabasePointInTimeRecoveryEnablement("POINT_IN_TIME_RECOVERY_ENABLED");
        /// <summary>
        /// Reads are supported on any version of the data from within the past 1 hour.
        /// </summary>
        public static DatabasePointInTimeRecoveryEnablement PointInTimeRecoveryDisabled { get; } = new DatabasePointInTimeRecoveryEnablement("POINT_IN_TIME_RECOVERY_DISABLED");

        public static bool operator ==(DatabasePointInTimeRecoveryEnablement left, DatabasePointInTimeRecoveryEnablement right) => left.Equals(right);
        public static bool operator !=(DatabasePointInTimeRecoveryEnablement left, DatabasePointInTimeRecoveryEnablement right) => !left.Equals(right);

        public static explicit operator string(DatabasePointInTimeRecoveryEnablement value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabasePointInTimeRecoveryEnablement other && Equals(other);
        public bool Equals(DatabasePointInTimeRecoveryEnablement other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the database. See https://cloud.google.com/datastore/docs/firestore-or-datastore for information about how to choose.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseType : IEquatable<DatabaseType>
    {
        private readonly string _value;

        private DatabaseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default value. This value is used if the database type is omitted.
        /// </summary>
        public static DatabaseType DatabaseTypeUnspecified { get; } = new DatabaseType("DATABASE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Firestore Native Mode
        /// </summary>
        public static DatabaseType FirestoreNative { get; } = new DatabaseType("FIRESTORE_NATIVE");
        /// <summary>
        /// Firestore in Datastore Mode.
        /// </summary>
        public static DatabaseType DatastoreMode { get; } = new DatabaseType("DATASTORE_MODE");

        public static bool operator ==(DatabaseType left, DatabaseType right) => left.Equals(right);
        public static bool operator !=(DatabaseType left, DatabaseType right) => !left.Equals(right);

        public static explicit operator string(DatabaseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseType other && Equals(other);
        public bool Equals(DatabaseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates that this field supports operations on `array_value`s.
    /// </summary>
    [EnumType]
    public readonly struct GoogleFirestoreAdminV1IndexFieldArrayConfig : IEquatable<GoogleFirestoreAdminV1IndexFieldArrayConfig>
    {
        private readonly string _value;

        private GoogleFirestoreAdminV1IndexFieldArrayConfig(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The index does not support additional array queries.
        /// </summary>
        public static GoogleFirestoreAdminV1IndexFieldArrayConfig ArrayConfigUnspecified { get; } = new GoogleFirestoreAdminV1IndexFieldArrayConfig("ARRAY_CONFIG_UNSPECIFIED");
        /// <summary>
        /// The index supports array containment queries.
        /// </summary>
        public static GoogleFirestoreAdminV1IndexFieldArrayConfig Contains { get; } = new GoogleFirestoreAdminV1IndexFieldArrayConfig("CONTAINS");

        public static bool operator ==(GoogleFirestoreAdminV1IndexFieldArrayConfig left, GoogleFirestoreAdminV1IndexFieldArrayConfig right) => left.Equals(right);
        public static bool operator !=(GoogleFirestoreAdminV1IndexFieldArrayConfig left, GoogleFirestoreAdminV1IndexFieldArrayConfig right) => !left.Equals(right);

        public static explicit operator string(GoogleFirestoreAdminV1IndexFieldArrayConfig value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GoogleFirestoreAdminV1IndexFieldArrayConfig other && Equals(other);
        public bool Equals(GoogleFirestoreAdminV1IndexFieldArrayConfig other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates that this field supports ordering by the specified order or comparing using =, !=, &lt;, &lt;=, &gt;, &gt;=.
    /// </summary>
    [EnumType]
    public readonly struct GoogleFirestoreAdminV1IndexFieldOrder : IEquatable<GoogleFirestoreAdminV1IndexFieldOrder>
    {
        private readonly string _value;

        private GoogleFirestoreAdminV1IndexFieldOrder(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The ordering is unspecified. Not a valid option.
        /// </summary>
        public static GoogleFirestoreAdminV1IndexFieldOrder OrderUnspecified { get; } = new GoogleFirestoreAdminV1IndexFieldOrder("ORDER_UNSPECIFIED");
        /// <summary>
        /// The field is ordered by ascending field value.
        /// </summary>
        public static GoogleFirestoreAdminV1IndexFieldOrder Ascending { get; } = new GoogleFirestoreAdminV1IndexFieldOrder("ASCENDING");
        /// <summary>
        /// The field is ordered by descending field value.
        /// </summary>
        public static GoogleFirestoreAdminV1IndexFieldOrder Descending { get; } = new GoogleFirestoreAdminV1IndexFieldOrder("DESCENDING");

        public static bool operator ==(GoogleFirestoreAdminV1IndexFieldOrder left, GoogleFirestoreAdminV1IndexFieldOrder right) => left.Equals(right);
        public static bool operator !=(GoogleFirestoreAdminV1IndexFieldOrder left, GoogleFirestoreAdminV1IndexFieldOrder right) => !left.Equals(right);

        public static explicit operator string(GoogleFirestoreAdminV1IndexFieldOrder value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GoogleFirestoreAdminV1IndexFieldOrder other && Equals(other);
        public bool Equals(GoogleFirestoreAdminV1IndexFieldOrder other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The day of week to run. DAY_OF_WEEK_UNSPECIFIED is not allowed.
    /// </summary>
    [EnumType]
    public readonly struct GoogleFirestoreAdminV1WeeklyRecurrenceDay : IEquatable<GoogleFirestoreAdminV1WeeklyRecurrenceDay>
    {
        private readonly string _value;

        private GoogleFirestoreAdminV1WeeklyRecurrenceDay(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The day of the week is unspecified.
        /// </summary>
        public static GoogleFirestoreAdminV1WeeklyRecurrenceDay DayOfWeekUnspecified { get; } = new GoogleFirestoreAdminV1WeeklyRecurrenceDay("DAY_OF_WEEK_UNSPECIFIED");
        /// <summary>
        /// Monday
        /// </summary>
        public static GoogleFirestoreAdminV1WeeklyRecurrenceDay Monday { get; } = new GoogleFirestoreAdminV1WeeklyRecurrenceDay("MONDAY");
        /// <summary>
        /// Tuesday
        /// </summary>
        public static GoogleFirestoreAdminV1WeeklyRecurrenceDay Tuesday { get; } = new GoogleFirestoreAdminV1WeeklyRecurrenceDay("TUESDAY");
        /// <summary>
        /// Wednesday
        /// </summary>
        public static GoogleFirestoreAdminV1WeeklyRecurrenceDay Wednesday { get; } = new GoogleFirestoreAdminV1WeeklyRecurrenceDay("WEDNESDAY");
        /// <summary>
        /// Thursday
        /// </summary>
        public static GoogleFirestoreAdminV1WeeklyRecurrenceDay Thursday { get; } = new GoogleFirestoreAdminV1WeeklyRecurrenceDay("THURSDAY");
        /// <summary>
        /// Friday
        /// </summary>
        public static GoogleFirestoreAdminV1WeeklyRecurrenceDay Friday { get; } = new GoogleFirestoreAdminV1WeeklyRecurrenceDay("FRIDAY");
        /// <summary>
        /// Saturday
        /// </summary>
        public static GoogleFirestoreAdminV1WeeklyRecurrenceDay Saturday { get; } = new GoogleFirestoreAdminV1WeeklyRecurrenceDay("SATURDAY");
        /// <summary>
        /// Sunday
        /// </summary>
        public static GoogleFirestoreAdminV1WeeklyRecurrenceDay Sunday { get; } = new GoogleFirestoreAdminV1WeeklyRecurrenceDay("SUNDAY");

        public static bool operator ==(GoogleFirestoreAdminV1WeeklyRecurrenceDay left, GoogleFirestoreAdminV1WeeklyRecurrenceDay right) => left.Equals(right);
        public static bool operator !=(GoogleFirestoreAdminV1WeeklyRecurrenceDay left, GoogleFirestoreAdminV1WeeklyRecurrenceDay right) => !left.Equals(right);

        public static explicit operator string(GoogleFirestoreAdminV1WeeklyRecurrenceDay value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GoogleFirestoreAdminV1WeeklyRecurrenceDay other && Equals(other);
        public bool Equals(GoogleFirestoreAdminV1WeeklyRecurrenceDay other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The API scope supported by this index.
    /// </summary>
    [EnumType]
    public readonly struct IndexApiScope : IEquatable<IndexApiScope>
    {
        private readonly string _value;

        private IndexApiScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The index can only be used by the Firestore Native query API. This is the default.
        /// </summary>
        public static IndexApiScope AnyApi { get; } = new IndexApiScope("ANY_API");
        /// <summary>
        /// The index can only be used by the Firestore in Datastore Mode query API.
        /// </summary>
        public static IndexApiScope DatastoreModeApi { get; } = new IndexApiScope("DATASTORE_MODE_API");

        public static bool operator ==(IndexApiScope left, IndexApiScope right) => left.Equals(right);
        public static bool operator !=(IndexApiScope left, IndexApiScope right) => !left.Equals(right);

        public static explicit operator string(IndexApiScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IndexApiScope other && Equals(other);
        public bool Equals(IndexApiScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indexes with a collection query scope specified allow queries against a collection that is the child of a specific document, specified at query time, and that has the same collection id. Indexes with a collection group query scope specified allow queries against all collections descended from a specific document, specified at query time, and that have the same collection id as this index.
    /// </summary>
    [EnumType]
    public readonly struct IndexQueryScope : IEquatable<IndexQueryScope>
    {
        private readonly string _value;

        private IndexQueryScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The query scope is unspecified. Not a valid option.
        /// </summary>
        public static IndexQueryScope QueryScopeUnspecified { get; } = new IndexQueryScope("QUERY_SCOPE_UNSPECIFIED");
        /// <summary>
        /// Indexes with a collection query scope specified allow queries against a collection that is the child of a specific document, specified at query time, and that has the collection id specified by the index.
        /// </summary>
        public static IndexQueryScope Collection { get; } = new IndexQueryScope("COLLECTION");
        /// <summary>
        /// Indexes with a collection group query scope specified allow queries against all collections that has the collection id specified by the index.
        /// </summary>
        public static IndexQueryScope CollectionGroup { get; } = new IndexQueryScope("COLLECTION_GROUP");
        /// <summary>
        /// Include all the collections's ancestor in the index. Only available for Datastore Mode databases.
        /// </summary>
        public static IndexQueryScope CollectionRecursive { get; } = new IndexQueryScope("COLLECTION_RECURSIVE");

        public static bool operator ==(IndexQueryScope left, IndexQueryScope right) => left.Equals(right);
        public static bool operator !=(IndexQueryScope left, IndexQueryScope right) => !left.Equals(right);

        public static explicit operator string(IndexQueryScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IndexQueryScope other && Equals(other);
        public bool Equals(IndexQueryScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

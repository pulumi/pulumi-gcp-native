// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Monitoring.V1
{
    /// <summary>
    /// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
    /// </summary>
    [EnumType]
    public readonly struct AggregationCrossSeriesReducer : IEquatable<AggregationCrossSeriesReducer>
    {
        private readonly string _value;

        private AggregationCrossSeriesReducer(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No cross-time series reduction. The output of the Aligner is returned.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceNone { get; } = new AggregationCrossSeriesReducer("REDUCE_NONE");
        /// <summary>
        /// Reduce by computing the mean value across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric or distribution values. The value_type of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceMean { get; } = new AggregationCrossSeriesReducer("REDUCE_MEAN");
        /// <summary>
        /// Reduce by computing the minimum value across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric values. The value_type of the output is the same as the value_type of the input.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceMin { get; } = new AggregationCrossSeriesReducer("REDUCE_MIN");
        /// <summary>
        /// Reduce by computing the maximum value across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric values. The value_type of the output is the same as the value_type of the input.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceMax { get; } = new AggregationCrossSeriesReducer("REDUCE_MAX");
        /// <summary>
        /// Reduce by computing the sum across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric and distribution values. The value_type of the output is the same as the value_type of the input.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceSum { get; } = new AggregationCrossSeriesReducer("REDUCE_SUM");
        /// <summary>
        /// Reduce by computing the standard deviation across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric or distribution values. The value_type of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceStddev { get; } = new AggregationCrossSeriesReducer("REDUCE_STDDEV");
        /// <summary>
        /// Reduce by computing the number of data points across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics of numeric, Boolean, distribution, and string value_type. The value_type of the output is INT64.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceCount { get; } = new AggregationCrossSeriesReducer("REDUCE_COUNT");
        /// <summary>
        /// Reduce by computing the number of True-valued data points across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics of Boolean value_type. The value_type of the output is INT64.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceCountTrue { get; } = new AggregationCrossSeriesReducer("REDUCE_COUNT_TRUE");
        /// <summary>
        /// Reduce by computing the number of False-valued data points across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics of Boolean value_type. The value_type of the output is INT64.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceCountFalse { get; } = new AggregationCrossSeriesReducer("REDUCE_COUNT_FALSE");
        /// <summary>
        /// Reduce by computing the ratio of the number of True-valued data points to the total number of data points for each alignment period. This reducer is valid for DELTA and GAUGE metrics of Boolean value_type. The output value is in the range 0.0, 1.0 and has value_type DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceFractionTrue { get; } = new AggregationCrossSeriesReducer("REDUCE_FRACTION_TRUE");
        /// <summary>
        /// Reduce by computing the 99th percentile (https://en.wikipedia.org/wiki/Percentile) of data points across time series for each alignment period. This reducer is valid for GAUGE and DELTA metrics of numeric and distribution type. The value of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReducePercentile99 { get; } = new AggregationCrossSeriesReducer("REDUCE_PERCENTILE_99");
        /// <summary>
        /// Reduce by computing the 95th percentile (https://en.wikipedia.org/wiki/Percentile) of data points across time series for each alignment period. This reducer is valid for GAUGE and DELTA metrics of numeric and distribution type. The value of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReducePercentile95 { get; } = new AggregationCrossSeriesReducer("REDUCE_PERCENTILE_95");
        /// <summary>
        /// Reduce by computing the 50th percentile (https://en.wikipedia.org/wiki/Percentile) of data points across time series for each alignment period. This reducer is valid for GAUGE and DELTA metrics of numeric and distribution type. The value of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReducePercentile50 { get; } = new AggregationCrossSeriesReducer("REDUCE_PERCENTILE_50");
        /// <summary>
        /// Reduce by computing the 5th percentile (https://en.wikipedia.org/wiki/Percentile) of data points across time series for each alignment period. This reducer is valid for GAUGE and DELTA metrics of numeric and distribution type. The value of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReducePercentile05 { get; } = new AggregationCrossSeriesReducer("REDUCE_PERCENTILE_05");

        public static bool operator ==(AggregationCrossSeriesReducer left, AggregationCrossSeriesReducer right) => left.Equals(right);
        public static bool operator !=(AggregationCrossSeriesReducer left, AggregationCrossSeriesReducer right) => !left.Equals(right);

        public static explicit operator string(AggregationCrossSeriesReducer value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AggregationCrossSeriesReducer other && Equals(other);
        public bool Equals(AggregationCrossSeriesReducer other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
    /// </summary>
    [EnumType]
    public readonly struct AggregationPerSeriesAligner : IEquatable<AggregationPerSeriesAligner>
    {
        private readonly string _value;

        private AggregationPerSeriesAligner(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No alignment. Raw data is returned. Not valid if cross-series reduction is requested. The value_type of the result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignNone { get; } = new AggregationPerSeriesAligner("ALIGN_NONE");
        /// <summary>
        /// Align and convert to DELTA. The output is delta = y1 - y0.This alignment is valid for CUMULATIVE and DELTA metrics. If the selected alignment period results in periods with no data, then the aligned value for such a period is created by interpolation. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignDelta { get; } = new AggregationPerSeriesAligner("ALIGN_DELTA");
        /// <summary>
        /// Align and convert to a rate. The result is computed as rate = (y1 - y0)/(t1 - t0), or "delta over time". Think of this aligner as providing the slope of the line that passes through the value at the start and at the end of the alignment_period.This aligner is valid for CUMULATIVE and DELTA metrics with numeric values. If the selected alignment period results in periods with no data, then the aligned value for such a period is created by interpolation. The output is a GAUGE metric with value_type DOUBLE.If, by "rate", you mean "percentage change", see the ALIGN_PERCENT_CHANGE aligner instead.
        /// </summary>
        public static AggregationPerSeriesAligner AlignRate { get; } = new AggregationPerSeriesAligner("ALIGN_RATE");
        /// <summary>
        /// Align by interpolating between adjacent points around the alignment period boundary. This aligner is valid for GAUGE metrics with numeric values. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignInterpolate { get; } = new AggregationPerSeriesAligner("ALIGN_INTERPOLATE");
        /// <summary>
        /// Align by moving the most recent data point before the end of the alignment period to the boundary at the end of the alignment period. This aligner is valid for GAUGE metrics. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignNextOlder { get; } = new AggregationPerSeriesAligner("ALIGN_NEXT_OLDER");
        /// <summary>
        /// Align the time series by returning the minimum value in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric values. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignMin { get; } = new AggregationPerSeriesAligner("ALIGN_MIN");
        /// <summary>
        /// Align the time series by returning the maximum value in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric values. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignMax { get; } = new AggregationPerSeriesAligner("ALIGN_MAX");
        /// <summary>
        /// Align the time series by returning the mean value in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric values. The value_type of the aligned result is DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignMean { get; } = new AggregationPerSeriesAligner("ALIGN_MEAN");
        /// <summary>
        /// Align the time series by returning the number of values in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric or Boolean values. The value_type of the aligned result is INT64.
        /// </summary>
        public static AggregationPerSeriesAligner AlignCount { get; } = new AggregationPerSeriesAligner("ALIGN_COUNT");
        /// <summary>
        /// Align the time series by returning the sum of the values in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric and distribution values. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignSum { get; } = new AggregationPerSeriesAligner("ALIGN_SUM");
        /// <summary>
        /// Align the time series by returning the standard deviation of the values in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric values. The value_type of the output is DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignStddev { get; } = new AggregationPerSeriesAligner("ALIGN_STDDEV");
        /// <summary>
        /// Align the time series by returning the number of True values in each alignment period. This aligner is valid for GAUGE metrics with Boolean values. The value_type of the output is INT64.
        /// </summary>
        public static AggregationPerSeriesAligner AlignCountTrue { get; } = new AggregationPerSeriesAligner("ALIGN_COUNT_TRUE");
        /// <summary>
        /// Align the time series by returning the number of False values in each alignment period. This aligner is valid for GAUGE metrics with Boolean values. The value_type of the output is INT64.
        /// </summary>
        public static AggregationPerSeriesAligner AlignCountFalse { get; } = new AggregationPerSeriesAligner("ALIGN_COUNT_FALSE");
        /// <summary>
        /// Align the time series by returning the ratio of the number of True values to the total number of values in each alignment period. This aligner is valid for GAUGE metrics with Boolean values. The output value is in the range 0.0, 1.0 and has value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignFractionTrue { get; } = new AggregationPerSeriesAligner("ALIGN_FRACTION_TRUE");
        /// <summary>
        /// Align the time series by using percentile aggregation (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each alignment period is the 99th percentile of all data points in the period. This aligner is valid for GAUGE and DELTA metrics with distribution values. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentile99 { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENTILE_99");
        /// <summary>
        /// Align the time series by using percentile aggregation (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each alignment period is the 95th percentile of all data points in the period. This aligner is valid for GAUGE and DELTA metrics with distribution values. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentile95 { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENTILE_95");
        /// <summary>
        /// Align the time series by using percentile aggregation (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each alignment period is the 50th percentile of all data points in the period. This aligner is valid for GAUGE and DELTA metrics with distribution values. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentile50 { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENTILE_50");
        /// <summary>
        /// Align the time series by using percentile aggregation (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each alignment period is the 5th percentile of all data points in the period. This aligner is valid for GAUGE and DELTA metrics with distribution values. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentile05 { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENTILE_05");
        /// <summary>
        /// Align and convert to a percentage change. This aligner is valid for GAUGE and DELTA metrics with numeric values. This alignment returns ((current - previous)/previous) * 100, where the value of previous is determined based on the alignment_period.If the values of current and previous are both 0, then the returned value is 0. If only previous is 0, the returned value is infinity.A 10-minute moving mean is computed at each point of the alignment period prior to the above calculation to smooth the metric and prevent false positives from very short-lived spikes. The moving mean is only applicable for data whose values are &gt;= 0. Any values &lt; 0 are treated as a missing datapoint, and are ignored. While DELTA metrics are accepted by this alignment, special care should be taken that the values for the metric will always be positive. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentChange { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENT_CHANGE");

        public static bool operator ==(AggregationPerSeriesAligner left, AggregationPerSeriesAligner right) => left.Equals(right);
        public static bool operator !=(AggregationPerSeriesAligner left, AggregationPerSeriesAligner right) => !left.Equals(right);

        public static explicit operator string(AggregationPerSeriesAligner value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AggregationPerSeriesAligner other && Equals(other);
        public bool Equals(AggregationPerSeriesAligner other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The axis scale. By default, a linear scale is used.
    /// </summary>
    [EnumType]
    public readonly struct AxisScale : IEquatable<AxisScale>
    {
        private readonly string _value;

        private AxisScale(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Scale is unspecified. The view will default to LINEAR.
        /// </summary>
        public static AxisScale ScaleUnspecified { get; } = new AxisScale("SCALE_UNSPECIFIED");
        /// <summary>
        /// Linear scale.
        /// </summary>
        public static AxisScale Linear { get; } = new AxisScale("LINEAR");
        /// <summary>
        /// Logarithmic scale (base 10).
        /// </summary>
        public static AxisScale Log10 { get; } = new AxisScale("LOG10");

        public static bool operator ==(AxisScale left, AxisScale right) => left.Equals(right);
        public static bool operator !=(AxisScale left, AxisScale right) => !left.Equals(right);

        public static explicit operator string(AxisScale value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AxisScale other && Equals(other);
        public bool Equals(AxisScale other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The sort order is applied to the values of the breakdown column.
    /// </summary>
    [EnumType]
    public readonly struct BreakdownSortOrder : IEquatable<BreakdownSortOrder>
    {
        private readonly string _value;

        private BreakdownSortOrder(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// An unspecified sort order. This option is invalid when sorting is required.
        /// </summary>
        public static BreakdownSortOrder SortOrderUnspecified { get; } = new BreakdownSortOrder("SORT_ORDER_UNSPECIFIED");
        /// <summary>
        /// No sorting is applied.
        /// </summary>
        public static BreakdownSortOrder SortOrderNone { get; } = new BreakdownSortOrder("SORT_ORDER_NONE");
        /// <summary>
        /// The lowest-valued entries are selected first.
        /// </summary>
        public static BreakdownSortOrder SortOrderAscending { get; } = new BreakdownSortOrder("SORT_ORDER_ASCENDING");
        /// <summary>
        /// The highest-valued entries are selected first.
        /// </summary>
        public static BreakdownSortOrder SortOrderDescending { get; } = new BreakdownSortOrder("SORT_ORDER_DESCENDING");

        public static bool operator ==(BreakdownSortOrder left, BreakdownSortOrder right) => left.Equals(right);
        public static bool operator !=(BreakdownSortOrder left, BreakdownSortOrder right) => !left.Equals(right);

        public static explicit operator string(BreakdownSortOrder value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BreakdownSortOrder other && Equals(other);
        public bool Equals(BreakdownSortOrder other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The chart mode.
    /// </summary>
    [EnumType]
    public readonly struct ChartOptionsMode : IEquatable<ChartOptionsMode>
    {
        private readonly string _value;

        private ChartOptionsMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Mode is unspecified. The view will default to COLOR.
        /// </summary>
        public static ChartOptionsMode ModeUnspecified { get; } = new ChartOptionsMode("MODE_UNSPECIFIED");
        /// <summary>
        /// The chart distinguishes data series using different color. Line colors may get reused when there are many lines in the chart.
        /// </summary>
        public static ChartOptionsMode Color { get; } = new ChartOptionsMode("COLOR");
        /// <summary>
        /// The chart uses the Stackdriver x-ray mode, in which each data set is plotted using the same semi-transparent color.
        /// </summary>
        public static ChartOptionsMode XRay { get; } = new ChartOptionsMode("X_RAY");
        /// <summary>
        /// The chart displays statistics such as average, median, 95th percentile, and more.
        /// </summary>
        public static ChartOptionsMode Stats { get; } = new ChartOptionsMode("STATS");

        public static bool operator ==(ChartOptionsMode left, ChartOptionsMode right) => left.Equals(right);
        public static bool operator !=(ChartOptionsMode left, ChartOptionsMode right) => !left.Equals(right);

        public static explicit operator string(ChartOptionsMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ChartOptionsMode other && Equals(other);
        public bool Equals(ChartOptionsMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The specified filter type
    /// </summary>
    [EnumType]
    public readonly struct DashboardFilterFilterType : IEquatable<DashboardFilterFilterType>
    {
        private readonly string _value;

        private DashboardFilterFilterType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Filter type is unspecified. This is not valid in a well-formed request.
        /// </summary>
        public static DashboardFilterFilterType FilterTypeUnspecified { get; } = new DashboardFilterFilterType("FILTER_TYPE_UNSPECIFIED");
        /// <summary>
        /// Filter on a resource label value
        /// </summary>
        public static DashboardFilterFilterType ResourceLabel { get; } = new DashboardFilterFilterType("RESOURCE_LABEL");
        /// <summary>
        /// Filter on a metrics label value
        /// </summary>
        public static DashboardFilterFilterType MetricLabel { get; } = new DashboardFilterFilterType("METRIC_LABEL");
        /// <summary>
        /// Filter on a user metadata label value
        /// </summary>
        public static DashboardFilterFilterType UserMetadataLabel { get; } = new DashboardFilterFilterType("USER_METADATA_LABEL");
        /// <summary>
        /// Filter on a system metadata label value
        /// </summary>
        public static DashboardFilterFilterType SystemMetadataLabel { get; } = new DashboardFilterFilterType("SYSTEM_METADATA_LABEL");
        /// <summary>
        /// Filter on a group id
        /// </summary>
        public static DashboardFilterFilterType Group { get; } = new DashboardFilterFilterType("GROUP");

        public static bool operator ==(DashboardFilterFilterType left, DashboardFilterFilterType right) => left.Equals(right);
        public static bool operator !=(DashboardFilterFilterType left, DashboardFilterFilterType right) => !left.Equals(right);

        public static explicit operator string(DashboardFilterFilterType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DashboardFilterFilterType other && Equals(other);
        public bool Equals(DashboardFilterFilterType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// How this data should be plotted on the chart.
    /// </summary>
    [EnumType]
    public readonly struct DataSetPlotType : IEquatable<DataSetPlotType>
    {
        private readonly string _value;

        private DataSetPlotType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Plot type is unspecified. The view will default to LINE.
        /// </summary>
        public static DataSetPlotType PlotTypeUnspecified { get; } = new DataSetPlotType("PLOT_TYPE_UNSPECIFIED");
        /// <summary>
        /// The data is plotted as a set of lines (one line per series).
        /// </summary>
        public static DataSetPlotType Line { get; } = new DataSetPlotType("LINE");
        /// <summary>
        /// The data is plotted as a set of filled areas (one area per series), with the areas stacked vertically (the base of each area is the top of its predecessor, and the base of the first area is the x-axis). Since the areas do not overlap, each is filled with a different opaque color.
        /// </summary>
        public static DataSetPlotType StackedArea { get; } = new DataSetPlotType("STACKED_AREA");
        /// <summary>
        /// The data is plotted as a set of rectangular boxes (one box per series), with the boxes stacked vertically (the base of each box is the top of its predecessor, and the base of the first box is the x-axis). Since the boxes do not overlap, each is filled with a different opaque color.
        /// </summary>
        public static DataSetPlotType StackedBar { get; } = new DataSetPlotType("STACKED_BAR");
        /// <summary>
        /// The data is plotted as a heatmap. The series being plotted must have a DISTRIBUTION value type. The value of each bucket in the distribution is displayed as a color. This type is not currently available in the Stackdriver Monitoring application.
        /// </summary>
        public static DataSetPlotType Heatmap { get; } = new DataSetPlotType("HEATMAP");

        public static bool operator ==(DataSetPlotType left, DataSetPlotType right) => left.Equals(right);
        public static bool operator !=(DataSetPlotType left, DataSetPlotType right) => !left.Equals(right);

        public static explicit operator string(DataSetPlotType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataSetPlotType other && Equals(other);
        public bool Equals(DataSetPlotType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The target axis to use for plotting the metric.
    /// </summary>
    [EnumType]
    public readonly struct DataSetTargetAxis : IEquatable<DataSetTargetAxis>
    {
        private readonly string _value;

        private DataSetTargetAxis(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The target axis was not specified. Defaults to Y1.
        /// </summary>
        public static DataSetTargetAxis TargetAxisUnspecified { get; } = new DataSetTargetAxis("TARGET_AXIS_UNSPECIFIED");
        /// <summary>
        /// The y_axis (the right axis of chart).
        /// </summary>
        public static DataSetTargetAxis Y1 { get; } = new DataSetTargetAxis("Y1");
        /// <summary>
        /// The y2_axis (the left axis of chart).
        /// </summary>
        public static DataSetTargetAxis Y2 { get; } = new DataSetTargetAxis("Y2");

        public static bool operator ==(DataSetTargetAxis left, DataSetTargetAxis right) => left.Equals(right);
        public static bool operator !=(DataSetTargetAxis left, DataSetTargetAxis right) => !left.Equals(right);

        public static explicit operator string(DataSetTargetAxis value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataSetTargetAxis other && Equals(other);
        public bool Equals(DataSetTargetAxis other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The sort order applied to the sort column.
    /// </summary>
    [EnumType]
    public readonly struct DimensionSortOrder : IEquatable<DimensionSortOrder>
    {
        private readonly string _value;

        private DimensionSortOrder(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// An unspecified sort order. This option is invalid when sorting is required.
        /// </summary>
        public static DimensionSortOrder SortOrderUnspecified { get; } = new DimensionSortOrder("SORT_ORDER_UNSPECIFIED");
        /// <summary>
        /// No sorting is applied.
        /// </summary>
        public static DimensionSortOrder SortOrderNone { get; } = new DimensionSortOrder("SORT_ORDER_NONE");
        /// <summary>
        /// The lowest-valued entries are selected first.
        /// </summary>
        public static DimensionSortOrder SortOrderAscending { get; } = new DimensionSortOrder("SORT_ORDER_ASCENDING");
        /// <summary>
        /// The highest-valued entries are selected first.
        /// </summary>
        public static DimensionSortOrder SortOrderDescending { get; } = new DimensionSortOrder("SORT_ORDER_DESCENDING");

        public static bool operator ==(DimensionSortOrder left, DimensionSortOrder right) => left.Equals(right);
        public static bool operator !=(DimensionSortOrder left, DimensionSortOrder right) => !left.Equals(right);

        public static explicit operator string(DimensionSortOrder value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DimensionSortOrder other && Equals(other);
        public bool Equals(DimensionSortOrder other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// How to use the ranking to select time series that pass through the filter.
    /// </summary>
    [EnumType]
    public readonly struct PickTimeSeriesFilterDirection : IEquatable<PickTimeSeriesFilterDirection>
    {
        private readonly string _value;

        private PickTimeSeriesFilterDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not allowed. You must specify a different Direction if you specify a PickTimeSeriesFilter.
        /// </summary>
        public static PickTimeSeriesFilterDirection DirectionUnspecified { get; } = new PickTimeSeriesFilterDirection("DIRECTION_UNSPECIFIED");
        /// <summary>
        /// Pass the highest num_time_series ranking inputs.
        /// </summary>
        public static PickTimeSeriesFilterDirection Top { get; } = new PickTimeSeriesFilterDirection("TOP");
        /// <summary>
        /// Pass the lowest num_time_series ranking inputs.
        /// </summary>
        public static PickTimeSeriesFilterDirection Bottom { get; } = new PickTimeSeriesFilterDirection("BOTTOM");

        public static bool operator ==(PickTimeSeriesFilterDirection left, PickTimeSeriesFilterDirection right) => left.Equals(right);
        public static bool operator !=(PickTimeSeriesFilterDirection left, PickTimeSeriesFilterDirection right) => !left.Equals(right);

        public static explicit operator string(PickTimeSeriesFilterDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PickTimeSeriesFilterDirection other && Equals(other);
        public bool Equals(PickTimeSeriesFilterDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
    /// </summary>
    [EnumType]
    public readonly struct PickTimeSeriesFilterRankingMethod : IEquatable<PickTimeSeriesFilterRankingMethod>
    {
        private readonly string _value;

        private PickTimeSeriesFilterRankingMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not allowed. You must specify a different Method if you specify a PickTimeSeriesFilter.
        /// </summary>
        public static PickTimeSeriesFilterRankingMethod MethodUnspecified { get; } = new PickTimeSeriesFilterRankingMethod("METHOD_UNSPECIFIED");
        /// <summary>
        /// Select the mean of all values.
        /// </summary>
        public static PickTimeSeriesFilterRankingMethod MethodMean { get; } = new PickTimeSeriesFilterRankingMethod("METHOD_MEAN");
        /// <summary>
        /// Select the maximum value.
        /// </summary>
        public static PickTimeSeriesFilterRankingMethod MethodMax { get; } = new PickTimeSeriesFilterRankingMethod("METHOD_MAX");
        /// <summary>
        /// Select the minimum value.
        /// </summary>
        public static PickTimeSeriesFilterRankingMethod MethodMin { get; } = new PickTimeSeriesFilterRankingMethod("METHOD_MIN");
        /// <summary>
        /// Compute the sum of all values.
        /// </summary>
        public static PickTimeSeriesFilterRankingMethod MethodSum { get; } = new PickTimeSeriesFilterRankingMethod("METHOD_SUM");
        /// <summary>
        /// Select the most recent value.
        /// </summary>
        public static PickTimeSeriesFilterRankingMethod MethodLatest { get; } = new PickTimeSeriesFilterRankingMethod("METHOD_LATEST");

        public static bool operator ==(PickTimeSeriesFilterRankingMethod left, PickTimeSeriesFilterRankingMethod right) => left.Equals(right);
        public static bool operator !=(PickTimeSeriesFilterRankingMethod left, PickTimeSeriesFilterRankingMethod right) => !left.Equals(right);

        public static explicit operator string(PickTimeSeriesFilterRankingMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PickTimeSeriesFilterRankingMethod other && Equals(other);
        public bool Equals(PickTimeSeriesFilterRankingMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Indicates the visualization type for the PieChart.
    /// </summary>
    [EnumType]
    public readonly struct PieChartChartType : IEquatable<PieChartChartType>
    {
        private readonly string _value;

        private PieChartChartType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The zero value. No type specified. Do not use.
        /// </summary>
        public static PieChartChartType PieChartTypeUnspecified { get; } = new PieChartChartType("PIE_CHART_TYPE_UNSPECIFIED");
        /// <summary>
        /// A Pie type PieChart.
        /// </summary>
        public static PieChartChartType Pie { get; } = new PieChartChartType("PIE");
        /// <summary>
        /// Similar to PIE, but the DONUT type PieChart has a hole in the middle.
        /// </summary>
        public static PieChartChartType Donut { get; } = new PieChartChartType("DONUT");

        public static bool operator ==(PieChartChartType left, PieChartChartType right) => left.Equals(right);
        public static bool operator !=(PieChartChartType left, PieChartChartType right) => !left.Equals(right);

        public static explicit operator string(PieChartChartType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PieChartChartType other && Equals(other);
        public bool Equals(PieChartChartType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The type of sparkchart to show in this chartView.
    /// </summary>
    [EnumType]
    public readonly struct SparkChartViewSparkChartType : IEquatable<SparkChartViewSparkChartType>
    {
        private readonly string _value;

        private SparkChartViewSparkChartType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not allowed in well-formed requests.
        /// </summary>
        public static SparkChartViewSparkChartType SparkChartTypeUnspecified { get; } = new SparkChartViewSparkChartType("SPARK_CHART_TYPE_UNSPECIFIED");
        /// <summary>
        /// The sparkline will be rendered as a small line chart.
        /// </summary>
        public static SparkChartViewSparkChartType SparkLine { get; } = new SparkChartViewSparkChartType("SPARK_LINE");
        /// <summary>
        /// The sparkbar will be rendered as a small bar chart.
        /// </summary>
        public static SparkChartViewSparkChartType SparkBar { get; } = new SparkChartViewSparkChartType("SPARK_BAR");

        public static bool operator ==(SparkChartViewSparkChartType left, SparkChartViewSparkChartType right) => left.Equals(right);
        public static bool operator !=(SparkChartViewSparkChartType left, SparkChartViewSparkChartType right) => !left.Equals(right);

        public static explicit operator string(SparkChartViewSparkChartType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SparkChartViewSparkChartType other && Equals(other);
        public bool Equals(SparkChartViewSparkChartType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
    /// </summary>
    [EnumType]
    public readonly struct StatisticalTimeSeriesFilterRankingMethod : IEquatable<StatisticalTimeSeriesFilterRankingMethod>
    {
        private readonly string _value;

        private StatisticalTimeSeriesFilterRankingMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not allowed in well-formed requests.
        /// </summary>
        public static StatisticalTimeSeriesFilterRankingMethod MethodUnspecified { get; } = new StatisticalTimeSeriesFilterRankingMethod("METHOD_UNSPECIFIED");
        /// <summary>
        /// Compute the outlier score of each stream.
        /// </summary>
        public static StatisticalTimeSeriesFilterRankingMethod MethodClusterOutlier { get; } = new StatisticalTimeSeriesFilterRankingMethod("METHOD_CLUSTER_OUTLIER");

        public static bool operator ==(StatisticalTimeSeriesFilterRankingMethod left, StatisticalTimeSeriesFilterRankingMethod right) => left.Equals(right);
        public static bool operator !=(StatisticalTimeSeriesFilterRankingMethod left, StatisticalTimeSeriesFilterRankingMethod right) => !left.Equals(right);

        public static explicit operator string(StatisticalTimeSeriesFilterRankingMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatisticalTimeSeriesFilterRankingMethod other && Equals(other);
        public bool Equals(StatisticalTimeSeriesFilterRankingMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// How the text content is formatted.
    /// </summary>
    [EnumType]
    public readonly struct TextFormat : IEquatable<TextFormat>
    {
        private readonly string _value;

        private TextFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Format is unspecified. Defaults to MARKDOWN.
        /// </summary>
        public static TextFormat FormatUnspecified { get; } = new TextFormat("FORMAT_UNSPECIFIED");
        /// <summary>
        /// The text contains Markdown formatting.
        /// </summary>
        public static TextFormat Markdown { get; } = new TextFormat("MARKDOWN");
        /// <summary>
        /// The text contains no special formatting.
        /// </summary>
        public static TextFormat Raw { get; } = new TextFormat("RAW");

        public static bool operator ==(TextFormat left, TextFormat right) => left.Equals(right);
        public static bool operator !=(TextFormat left, TextFormat right) => !left.Equals(right);

        public static explicit operator string(TextFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TextFormat other && Equals(other);
        public bool Equals(TextFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Font sizes for both the title and content. The title will still be larger relative to the content.
    /// </summary>
    [EnumType]
    public readonly struct TextStyleFontSize : IEquatable<TextStyleFontSize>
    {
        private readonly string _value;

        private TextStyleFontSize(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No font size specified, will default to FS_LARGE
        /// </summary>
        public static TextStyleFontSize FontSizeUnspecified { get; } = new TextStyleFontSize("FONT_SIZE_UNSPECIFIED");
        /// <summary>
        /// Extra small font size
        /// </summary>
        public static TextStyleFontSize FsExtraSmall { get; } = new TextStyleFontSize("FS_EXTRA_SMALL");
        /// <summary>
        /// Small font size
        /// </summary>
        public static TextStyleFontSize FsSmall { get; } = new TextStyleFontSize("FS_SMALL");
        /// <summary>
        /// Medium font size
        /// </summary>
        public static TextStyleFontSize FsMedium { get; } = new TextStyleFontSize("FS_MEDIUM");
        /// <summary>
        /// Large font size
        /// </summary>
        public static TextStyleFontSize FsLarge { get; } = new TextStyleFontSize("FS_LARGE");
        /// <summary>
        /// Extra large font size
        /// </summary>
        public static TextStyleFontSize FsExtraLarge { get; } = new TextStyleFontSize("FS_EXTRA_LARGE");

        public static bool operator ==(TextStyleFontSize left, TextStyleFontSize right) => left.Equals(right);
        public static bool operator !=(TextStyleFontSize left, TextStyleFontSize right) => !left.Equals(right);

        public static explicit operator string(TextStyleFontSize value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TextStyleFontSize other && Equals(other);
        public bool Equals(TextStyleFontSize other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The horizontal alignment of both the title and content
    /// </summary>
    [EnumType]
    public readonly struct TextStyleHorizontalAlignment : IEquatable<TextStyleHorizontalAlignment>
    {
        private readonly string _value;

        private TextStyleHorizontalAlignment(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No horizontal alignment specified, will default to H_LEFT
        /// </summary>
        public static TextStyleHorizontalAlignment HorizontalAlignmentUnspecified { get; } = new TextStyleHorizontalAlignment("HORIZONTAL_ALIGNMENT_UNSPECIFIED");
        /// <summary>
        /// Left-align
        /// </summary>
        public static TextStyleHorizontalAlignment HLeft { get; } = new TextStyleHorizontalAlignment("H_LEFT");
        /// <summary>
        /// Center-align
        /// </summary>
        public static TextStyleHorizontalAlignment HCenter { get; } = new TextStyleHorizontalAlignment("H_CENTER");
        /// <summary>
        /// Right-align
        /// </summary>
        public static TextStyleHorizontalAlignment HRight { get; } = new TextStyleHorizontalAlignment("H_RIGHT");

        public static bool operator ==(TextStyleHorizontalAlignment left, TextStyleHorizontalAlignment right) => left.Equals(right);
        public static bool operator !=(TextStyleHorizontalAlignment left, TextStyleHorizontalAlignment right) => !left.Equals(right);

        public static explicit operator string(TextStyleHorizontalAlignment value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TextStyleHorizontalAlignment other && Equals(other);
        public bool Equals(TextStyleHorizontalAlignment other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The amount of padding around the widget
    /// </summary>
    [EnumType]
    public readonly struct TextStylePadding : IEquatable<TextStylePadding>
    {
        private readonly string _value;

        private TextStylePadding(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No padding size specified, will default to P_EXTRA_SMALL
        /// </summary>
        public static TextStylePadding PaddingSizeUnspecified { get; } = new TextStylePadding("PADDING_SIZE_UNSPECIFIED");
        /// <summary>
        /// Extra small padding
        /// </summary>
        public static TextStylePadding PExtraSmall { get; } = new TextStylePadding("P_EXTRA_SMALL");
        /// <summary>
        /// Small padding
        /// </summary>
        public static TextStylePadding PSmall { get; } = new TextStylePadding("P_SMALL");
        /// <summary>
        /// Medium padding
        /// </summary>
        public static TextStylePadding PMedium { get; } = new TextStylePadding("P_MEDIUM");
        /// <summary>
        /// Large padding
        /// </summary>
        public static TextStylePadding PLarge { get; } = new TextStylePadding("P_LARGE");
        /// <summary>
        /// Extra large padding
        /// </summary>
        public static TextStylePadding PExtraLarge { get; } = new TextStylePadding("P_EXTRA_LARGE");

        public static bool operator ==(TextStylePadding left, TextStylePadding right) => left.Equals(right);
        public static bool operator !=(TextStylePadding left, TextStylePadding right) => !left.Equals(right);

        public static explicit operator string(TextStylePadding value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TextStylePadding other && Equals(other);
        public bool Equals(TextStylePadding other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The pointer location for this widget (also sometimes called a "tail")
    /// </summary>
    [EnumType]
    public readonly struct TextStylePointerLocation : IEquatable<TextStylePointerLocation>
    {
        private readonly string _value;

        private TextStylePointerLocation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No visual pointer
        /// </summary>
        public static TextStylePointerLocation PointerLocationUnspecified { get; } = new TextStylePointerLocation("POINTER_LOCATION_UNSPECIFIED");
        /// <summary>
        /// Placed in the middle of the top of the widget
        /// </summary>
        public static TextStylePointerLocation PlTop { get; } = new TextStylePointerLocation("PL_TOP");
        /// <summary>
        /// Placed in the middle of the right side of the widget
        /// </summary>
        public static TextStylePointerLocation PlRight { get; } = new TextStylePointerLocation("PL_RIGHT");
        /// <summary>
        /// Placed in the middle of the bottom of the widget
        /// </summary>
        public static TextStylePointerLocation PlBottom { get; } = new TextStylePointerLocation("PL_BOTTOM");
        /// <summary>
        /// Placed in the middle of the left side of the widget
        /// </summary>
        public static TextStylePointerLocation PlLeft { get; } = new TextStylePointerLocation("PL_LEFT");
        /// <summary>
        /// Placed on the left side of the top of the widget
        /// </summary>
        public static TextStylePointerLocation PlTopLeft { get; } = new TextStylePointerLocation("PL_TOP_LEFT");
        /// <summary>
        /// Placed on the right side of the top of the widget
        /// </summary>
        public static TextStylePointerLocation PlTopRight { get; } = new TextStylePointerLocation("PL_TOP_RIGHT");
        /// <summary>
        /// Placed on the top of the right side of the widget
        /// </summary>
        public static TextStylePointerLocation PlRightTop { get; } = new TextStylePointerLocation("PL_RIGHT_TOP");
        /// <summary>
        /// Placed on the bottom of the right side of the widget
        /// </summary>
        public static TextStylePointerLocation PlRightBottom { get; } = new TextStylePointerLocation("PL_RIGHT_BOTTOM");
        /// <summary>
        /// Placed on the right side of the bottom of the widget
        /// </summary>
        public static TextStylePointerLocation PlBottomRight { get; } = new TextStylePointerLocation("PL_BOTTOM_RIGHT");
        /// <summary>
        /// Placed on the left side of the bottom of the widget
        /// </summary>
        public static TextStylePointerLocation PlBottomLeft { get; } = new TextStylePointerLocation("PL_BOTTOM_LEFT");
        /// <summary>
        /// Placed on the bottom of the left side of the widget
        /// </summary>
        public static TextStylePointerLocation PlLeftBottom { get; } = new TextStylePointerLocation("PL_LEFT_BOTTOM");
        /// <summary>
        /// Placed on the top of the left side of the widget
        /// </summary>
        public static TextStylePointerLocation PlLeftTop { get; } = new TextStylePointerLocation("PL_LEFT_TOP");

        public static bool operator ==(TextStylePointerLocation left, TextStylePointerLocation right) => left.Equals(right);
        public static bool operator !=(TextStylePointerLocation left, TextStylePointerLocation right) => !left.Equals(right);

        public static explicit operator string(TextStylePointerLocation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TextStylePointerLocation other && Equals(other);
        public bool Equals(TextStylePointerLocation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The vertical alignment of both the title and content
    /// </summary>
    [EnumType]
    public readonly struct TextStyleVerticalAlignment : IEquatable<TextStyleVerticalAlignment>
    {
        private readonly string _value;

        private TextStyleVerticalAlignment(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No vertical alignment specified, will default to V_TOP
        /// </summary>
        public static TextStyleVerticalAlignment VerticalAlignmentUnspecified { get; } = new TextStyleVerticalAlignment("VERTICAL_ALIGNMENT_UNSPECIFIED");
        /// <summary>
        /// Top-align
        /// </summary>
        public static TextStyleVerticalAlignment VTop { get; } = new TextStyleVerticalAlignment("V_TOP");
        /// <summary>
        /// Center-align
        /// </summary>
        public static TextStyleVerticalAlignment VCenter { get; } = new TextStyleVerticalAlignment("V_CENTER");
        /// <summary>
        /// Bottom-align
        /// </summary>
        public static TextStyleVerticalAlignment VBottom { get; } = new TextStyleVerticalAlignment("V_BOTTOM");

        public static bool operator ==(TextStyleVerticalAlignment left, TextStyleVerticalAlignment right) => left.Equals(right);
        public static bool operator !=(TextStyleVerticalAlignment left, TextStyleVerticalAlignment right) => !left.Equals(right);

        public static explicit operator string(TextStyleVerticalAlignment value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TextStyleVerticalAlignment other && Equals(other);
        public bool Equals(TextStyleVerticalAlignment other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The state color for this threshold. Color is not allowed in a XyChart.
    /// </summary>
    [EnumType]
    public readonly struct ThresholdColor : IEquatable<ThresholdColor>
    {
        private readonly string _value;

        private ThresholdColor(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Color is unspecified. Not allowed in well-formed requests.
        /// </summary>
        public static ThresholdColor ColorUnspecified { get; } = new ThresholdColor("COLOR_UNSPECIFIED");
        /// <summary>
        /// Crossing the threshold is "concerning" behavior.
        /// </summary>
        public static ThresholdColor Yellow { get; } = new ThresholdColor("YELLOW");
        /// <summary>
        /// Crossing the threshold is "emergency" behavior.
        /// </summary>
        public static ThresholdColor Red { get; } = new ThresholdColor("RED");

        public static bool operator ==(ThresholdColor left, ThresholdColor right) => left.Equals(right);
        public static bool operator !=(ThresholdColor left, ThresholdColor right) => !left.Equals(right);

        public static explicit operator string(ThresholdColor value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ThresholdColor other && Equals(other);
        public bool Equals(ThresholdColor other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The direction for the current threshold. Direction is not allowed in a XyChart.
    /// </summary>
    [EnumType]
    public readonly struct ThresholdDirection : IEquatable<ThresholdDirection>
    {
        private readonly string _value;

        private ThresholdDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not allowed in well-formed requests.
        /// </summary>
        public static ThresholdDirection DirectionUnspecified { get; } = new ThresholdDirection("DIRECTION_UNSPECIFIED");
        /// <summary>
        /// The threshold will be considered crossed if the actual value is above the threshold value.
        /// </summary>
        public static ThresholdDirection Above { get; } = new ThresholdDirection("ABOVE");
        /// <summary>
        /// The threshold will be considered crossed if the actual value is below the threshold value.
        /// </summary>
        public static ThresholdDirection Below { get; } = new ThresholdDirection("BELOW");

        public static bool operator ==(ThresholdDirection left, ThresholdDirection right) => left.Equals(right);
        public static bool operator !=(ThresholdDirection left, ThresholdDirection right) => !left.Equals(right);

        public static explicit operator string(ThresholdDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ThresholdDirection other && Equals(other);
        public bool Equals(ThresholdDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
    /// </summary>
    [EnumType]
    public readonly struct ThresholdTargetAxis : IEquatable<ThresholdTargetAxis>
    {
        private readonly string _value;

        private ThresholdTargetAxis(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The target axis was not specified. Defaults to Y1.
        /// </summary>
        public static ThresholdTargetAxis TargetAxisUnspecified { get; } = new ThresholdTargetAxis("TARGET_AXIS_UNSPECIFIED");
        /// <summary>
        /// The y_axis (the right axis of chart).
        /// </summary>
        public static ThresholdTargetAxis Y1 { get; } = new ThresholdTargetAxis("Y1");
        /// <summary>
        /// The y2_axis (the left axis of chart).
        /// </summary>
        public static ThresholdTargetAxis Y2 { get; } = new ThresholdTargetAxis("Y2");

        public static bool operator ==(ThresholdTargetAxis left, ThresholdTargetAxis right) => left.Equals(right);
        public static bool operator !=(ThresholdTargetAxis left, ThresholdTargetAxis right) => !left.Equals(right);

        public static explicit operator string(ThresholdTargetAxis value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ThresholdTargetAxis other && Equals(other);
        public bool Equals(ThresholdTargetAxis other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Store rendering strategy
    /// </summary>
    [EnumType]
    public readonly struct TimeSeriesTableMetricVisualization : IEquatable<TimeSeriesTableMetricVisualization>
    {
        private readonly string _value;

        private TimeSeriesTableMetricVisualization(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified state
        /// </summary>
        public static TimeSeriesTableMetricVisualization MetricVisualizationUnspecified { get; } = new TimeSeriesTableMetricVisualization("METRIC_VISUALIZATION_UNSPECIFIED");
        /// <summary>
        /// Default text rendering
        /// </summary>
        public static TimeSeriesTableMetricVisualization Number { get; } = new TimeSeriesTableMetricVisualization("NUMBER");
        /// <summary>
        /// Horizontal bar rendering
        /// </summary>
        public static TimeSeriesTableMetricVisualization Bar { get; } = new TimeSeriesTableMetricVisualization("BAR");

        public static bool operator ==(TimeSeriesTableMetricVisualization left, TimeSeriesTableMetricVisualization right) => left.Equals(right);
        public static bool operator !=(TimeSeriesTableMetricVisualization left, TimeSeriesTableMetricVisualization right) => !left.Equals(right);

        public static explicit operator string(TimeSeriesTableMetricVisualization value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TimeSeriesTableMetricVisualization other && Equals(other);
        public bool Equals(TimeSeriesTableMetricVisualization other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

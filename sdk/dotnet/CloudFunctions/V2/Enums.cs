// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.CloudFunctions.V2
{
    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct AuditLogConfigLogType : IEquatable<AuditLogConfigLogType>
    {
        private readonly string _value;

        private AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default case. Should never be this.
        /// </summary>
        public static AuditLogConfigLogType LogTypeUnspecified { get; } = new AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");
        /// <summary>
        /// Admin reads. Example: CloudIAM getIamPolicy
        /// </summary>
        public static AuditLogConfigLogType AdminRead { get; } = new AuditLogConfigLogType("ADMIN_READ");
        /// <summary>
        /// Data writes. Example: CloudSQL Users create
        /// </summary>
        public static AuditLogConfigLogType DataWrite { get; } = new AuditLogConfigLogType("DATA_WRITE");
        /// <summary>
        /// Data reads. Example: CloudSQL Users list
        /// </summary>
        public static AuditLogConfigLogType DataRead { get; } = new AuditLogConfigLogType("DATA_READ");

        public static bool operator ==(AuditLogConfigLogType left, AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(AuditLogConfigLogType left, AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuditLogConfigLogType other && Equals(other);
        public bool Equals(AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Docker Registry to use for this deployment. This configuration is only applicable to 1st Gen functions, 2nd Gen functions can only use Artifact Registry. If `docker_repository` field is specified, this field will be automatically set as `ARTIFACT_REGISTRY`. If unspecified, it currently defaults to `CONTAINER_REGISTRY`. This field may be overridden by the backend for eligible deployments.
    /// </summary>
    [EnumType]
    public readonly struct BuildConfigDockerRegistry : IEquatable<BuildConfigDockerRegistry>
    {
        private readonly string _value;

        private BuildConfigDockerRegistry(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified.
        /// </summary>
        public static BuildConfigDockerRegistry DockerRegistryUnspecified { get; } = new BuildConfigDockerRegistry("DOCKER_REGISTRY_UNSPECIFIED");
        /// <summary>
        /// Docker images will be stored in multi-regional Container Registry repositories named `gcf`.
        /// </summary>
        public static BuildConfigDockerRegistry ContainerRegistry { get; } = new BuildConfigDockerRegistry("CONTAINER_REGISTRY");
        /// <summary>
        /// Docker images will be stored in regional Artifact Registry repositories. By default, GCF will create and use repositories named `gcf-artifacts` in every region in which a function is deployed. But the repository to use can also be specified by the user using the `docker_repository` field.
        /// </summary>
        public static BuildConfigDockerRegistry ArtifactRegistry { get; } = new BuildConfigDockerRegistry("ARTIFACT_REGISTRY");

        public static bool operator ==(BuildConfigDockerRegistry left, BuildConfigDockerRegistry right) => left.Equals(right);
        public static bool operator !=(BuildConfigDockerRegistry left, BuildConfigDockerRegistry right) => !left.Equals(right);

        public static explicit operator string(BuildConfigDockerRegistry value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BuildConfigDockerRegistry other && Equals(other);
        public bool Equals(BuildConfigDockerRegistry other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. If unset, then defaults to ignoring failures (i.e. not retrying them).
    /// </summary>
    [EnumType]
    public readonly struct EventTriggerRetryPolicy : IEquatable<EventTriggerRetryPolicy>
    {
        private readonly string _value;

        private EventTriggerRetryPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified.
        /// </summary>
        public static EventTriggerRetryPolicy RetryPolicyUnspecified { get; } = new EventTriggerRetryPolicy("RETRY_POLICY_UNSPECIFIED");
        /// <summary>
        /// Do not retry.
        /// </summary>
        public static EventTriggerRetryPolicy RetryPolicyDoNotRetry { get; } = new EventTriggerRetryPolicy("RETRY_POLICY_DO_NOT_RETRY");
        /// <summary>
        /// Retry on any failure, retry up to 7 days with an exponential backoff (capped at 10 seconds).
        /// </summary>
        public static EventTriggerRetryPolicy RetryPolicyRetry { get; } = new EventTriggerRetryPolicy("RETRY_POLICY_RETRY");

        public static bool operator ==(EventTriggerRetryPolicy left, EventTriggerRetryPolicy right) => left.Equals(right);
        public static bool operator !=(EventTriggerRetryPolicy left, EventTriggerRetryPolicy right) => !left.Equals(right);

        public static explicit operator string(EventTriggerRetryPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventTriggerRetryPolicy other && Equals(other);
        public bool Equals(EventTriggerRetryPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describe whether the function is 1st Gen or 2nd Gen.
    /// </summary>
    [EnumType]
    public readonly struct FunctionEnvironment : IEquatable<FunctionEnvironment>
    {
        private readonly string _value;

        private FunctionEnvironment(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified
        /// </summary>
        public static FunctionEnvironment EnvironmentUnspecified { get; } = new FunctionEnvironment("ENVIRONMENT_UNSPECIFIED");
        /// <summary>
        /// Gen 1
        /// </summary>
        public static FunctionEnvironment Gen1 { get; } = new FunctionEnvironment("GEN_1");
        /// <summary>
        /// Gen 2
        /// </summary>
        public static FunctionEnvironment Gen2 { get; } = new FunctionEnvironment("GEN_2");

        public static bool operator ==(FunctionEnvironment left, FunctionEnvironment right) => left.Equals(right);
        public static bool operator !=(FunctionEnvironment left, FunctionEnvironment right) => !left.Equals(right);

        public static explicit operator string(FunctionEnvironment value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FunctionEnvironment other && Equals(other);
        public bool Equals(FunctionEnvironment other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The ingress settings for the function, controlling what traffic can reach it.
    /// </summary>
    [EnumType]
    public readonly struct ServiceConfigIngressSettings : IEquatable<ServiceConfigIngressSettings>
    {
        private readonly string _value;

        private ServiceConfigIngressSettings(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified.
        /// </summary>
        public static ServiceConfigIngressSettings IngressSettingsUnspecified { get; } = new ServiceConfigIngressSettings("INGRESS_SETTINGS_UNSPECIFIED");
        /// <summary>
        /// Allow HTTP traffic from public and private sources.
        /// </summary>
        public static ServiceConfigIngressSettings AllowAll { get; } = new ServiceConfigIngressSettings("ALLOW_ALL");
        /// <summary>
        /// Allow HTTP traffic from only private VPC sources.
        /// </summary>
        public static ServiceConfigIngressSettings AllowInternalOnly { get; } = new ServiceConfigIngressSettings("ALLOW_INTERNAL_ONLY");
        /// <summary>
        /// Allow HTTP traffic from private VPC sources and through GCLB.
        /// </summary>
        public static ServiceConfigIngressSettings AllowInternalAndGclb { get; } = new ServiceConfigIngressSettings("ALLOW_INTERNAL_AND_GCLB");

        public static bool operator ==(ServiceConfigIngressSettings left, ServiceConfigIngressSettings right) => left.Equals(right);
        public static bool operator !=(ServiceConfigIngressSettings left, ServiceConfigIngressSettings right) => !left.Equals(right);

        public static explicit operator string(ServiceConfigIngressSettings value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceConfigIngressSettings other && Equals(other);
        public bool Equals(ServiceConfigIngressSettings other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Security level configure whether the function only accepts https. This configuration is only applicable to 1st Gen functions with Http trigger. By default https is optional for 1st Gen functions; 2nd Gen functions are https ONLY.
    /// </summary>
    [EnumType]
    public readonly struct ServiceConfigSecurityLevel : IEquatable<ServiceConfigSecurityLevel>
    {
        private readonly string _value;

        private ServiceConfigSecurityLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified.
        /// </summary>
        public static ServiceConfigSecurityLevel SecurityLevelUnspecified { get; } = new ServiceConfigSecurityLevel("SECURITY_LEVEL_UNSPECIFIED");
        /// <summary>
        /// Requests for a URL that match this handler that do not use HTTPS are automatically redirected to the HTTPS URL with the same path. Query parameters are reserved for the redirect.
        /// </summary>
        public static ServiceConfigSecurityLevel SecureAlways { get; } = new ServiceConfigSecurityLevel("SECURE_ALWAYS");
        /// <summary>
        /// Both HTTP and HTTPS requests with URLs that match the handler succeed without redirects. The application can examine the request to determine which protocol was used and respond accordingly.
        /// </summary>
        public static ServiceConfigSecurityLevel SecureOptional { get; } = new ServiceConfigSecurityLevel("SECURE_OPTIONAL");

        public static bool operator ==(ServiceConfigSecurityLevel left, ServiceConfigSecurityLevel right) => left.Equals(right);
        public static bool operator !=(ServiceConfigSecurityLevel left, ServiceConfigSecurityLevel right) => !left.Equals(right);

        public static explicit operator string(ServiceConfigSecurityLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceConfigSecurityLevel other && Equals(other);
        public bool Equals(ServiceConfigSecurityLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The egress settings for the connector, controlling what traffic is diverted through it.
    /// </summary>
    [EnumType]
    public readonly struct ServiceConfigVpcConnectorEgressSettings : IEquatable<ServiceConfigVpcConnectorEgressSettings>
    {
        private readonly string _value;

        private ServiceConfigVpcConnectorEgressSettings(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified.
        /// </summary>
        public static ServiceConfigVpcConnectorEgressSettings VpcConnectorEgressSettingsUnspecified { get; } = new ServiceConfigVpcConnectorEgressSettings("VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED");
        /// <summary>
        /// Use the VPC Access Connector only for private IP space from RFC1918.
        /// </summary>
        public static ServiceConfigVpcConnectorEgressSettings PrivateRangesOnly { get; } = new ServiceConfigVpcConnectorEgressSettings("PRIVATE_RANGES_ONLY");
        /// <summary>
        /// Force the use of VPC Access Connector for all egress traffic from the function.
        /// </summary>
        public static ServiceConfigVpcConnectorEgressSettings AllTraffic { get; } = new ServiceConfigVpcConnectorEgressSettings("ALL_TRAFFIC");

        public static bool operator ==(ServiceConfigVpcConnectorEgressSettings left, ServiceConfigVpcConnectorEgressSettings right) => left.Equals(right);
        public static bool operator !=(ServiceConfigVpcConnectorEgressSettings left, ServiceConfigVpcConnectorEgressSettings right) => !left.Equals(right);

        public static explicit operator string(ServiceConfigVpcConnectorEgressSettings value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceConfigVpcConnectorEgressSettings other && Equals(other);
        public bool Equals(ServiceConfigVpcConnectorEgressSettings other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

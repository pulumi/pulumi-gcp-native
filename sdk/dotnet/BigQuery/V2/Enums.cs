// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.BigQuery.V2
{
    /// <summary>
    /// Optional. Defaults to FIXED_TYPE.
    /// </summary>
    [EnumType]
    public readonly struct ArgumentArgumentKind : IEquatable<ArgumentArgumentKind>
    {
        private readonly string _value;

        private ArgumentArgumentKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static ArgumentArgumentKind ArgumentKindUnspecified { get; } = new ArgumentArgumentKind("ARGUMENT_KIND_UNSPECIFIED");
        /// <summary>
        /// The argument is a variable with fully specified type, which can be a struct or an array, but not a table.
        /// </summary>
        public static ArgumentArgumentKind FixedType { get; } = new ArgumentArgumentKind("FIXED_TYPE");
        /// <summary>
        /// The argument is any type, including struct or array, but not a table. To be added: FIXED_TABLE, ANY_TABLE
        /// </summary>
        public static ArgumentArgumentKind AnyType { get; } = new ArgumentArgumentKind("ANY_TYPE");

        public static bool operator ==(ArgumentArgumentKind left, ArgumentArgumentKind right) => left.Equals(right);
        public static bool operator !=(ArgumentArgumentKind left, ArgumentArgumentKind right) => !left.Equals(right);

        public static explicit operator string(ArgumentArgumentKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ArgumentArgumentKind other && Equals(other);
        public bool Equals(ArgumentArgumentKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Specifies whether the argument is input or output. Can be set for procedures only.
    /// </summary>
    [EnumType]
    public readonly struct ArgumentMode : IEquatable<ArgumentMode>
    {
        private readonly string _value;

        private ArgumentMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static ArgumentMode ModeUnspecified { get; } = new ArgumentMode("MODE_UNSPECIFIED");
        /// <summary>
        /// The argument is input-only.
        /// </summary>
        public static ArgumentMode In { get; } = new ArgumentMode("IN");
        /// <summary>
        /// The argument is output-only.
        /// </summary>
        public static ArgumentMode Out { get; } = new ArgumentMode("OUT");
        /// <summary>
        /// The argument is both an input and an output.
        /// </summary>
        public static ArgumentMode Inout { get; } = new ArgumentMode("INOUT");

        public static bool operator ==(ArgumentMode left, ArgumentMode right) => left.Equals(right);
        public static bool operator !=(ArgumentMode left, ArgumentMode right) => !left.Equals(right);

        public static explicit operator string(ArgumentMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ArgumentMode other && Equals(other);
        public bool Equals(ArgumentMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct AuditLogConfigLogType : IEquatable<AuditLogConfigLogType>
    {
        private readonly string _value;

        private AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default case. Should never be this.
        /// </summary>
        public static AuditLogConfigLogType LogTypeUnspecified { get; } = new AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");
        /// <summary>
        /// Admin reads. Example: CloudIAM getIamPolicy
        /// </summary>
        public static AuditLogConfigLogType AdminRead { get; } = new AuditLogConfigLogType("ADMIN_READ");
        /// <summary>
        /// Data writes. Example: CloudSQL Users create
        /// </summary>
        public static AuditLogConfigLogType DataWrite { get; } = new AuditLogConfigLogType("DATA_WRITE");
        /// <summary>
        /// Data reads. Example: CloudSQL Users list
        /// </summary>
        public static AuditLogConfigLogType DataRead { get; } = new AuditLogConfigLogType("DATA_READ");

        public static bool operator ==(AuditLogConfigLogType left, AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(AuditLogConfigLogType left, AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuditLogConfigLogType other && Equals(other);
        public bool Equals(AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The file format the table data is stored in.
    /// </summary>
    [EnumType]
    public readonly struct BigLakeConfigurationFileFormat : IEquatable<BigLakeConfigurationFileFormat>
    {
        private readonly string _value;

        private BigLakeConfigurationFileFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default Value.
        /// </summary>
        public static BigLakeConfigurationFileFormat FileFormatUnspecified { get; } = new BigLakeConfigurationFileFormat("FILE_FORMAT_UNSPECIFIED");
        /// <summary>
        /// Apache Parquet format.
        /// </summary>
        public static BigLakeConfigurationFileFormat Parquet { get; } = new BigLakeConfigurationFileFormat("PARQUET");

        public static bool operator ==(BigLakeConfigurationFileFormat left, BigLakeConfigurationFileFormat right) => left.Equals(right);
        public static bool operator !=(BigLakeConfigurationFileFormat left, BigLakeConfigurationFileFormat right) => !left.Equals(right);

        public static explicit operator string(BigLakeConfigurationFileFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BigLakeConfigurationFileFormat other && Equals(other);
        public bool Equals(BigLakeConfigurationFileFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The table format the metadata only snapshots are stored in.
    /// </summary>
    [EnumType]
    public readonly struct BigLakeConfigurationTableFormat : IEquatable<BigLakeConfigurationTableFormat>
    {
        private readonly string _value;

        private BigLakeConfigurationTableFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default Value.
        /// </summary>
        public static BigLakeConfigurationTableFormat TableFormatUnspecified { get; } = new BigLakeConfigurationTableFormat("TABLE_FORMAT_UNSPECIFIED");
        /// <summary>
        /// Apache Iceberg format.
        /// </summary>
        public static BigLakeConfigurationTableFormat Iceberg { get; } = new BigLakeConfigurationTableFormat("ICEBERG");

        public static bool operator ==(BigLakeConfigurationTableFormat left, BigLakeConfigurationTableFormat right) => left.Equals(right);
        public static bool operator !=(BigLakeConfigurationTableFormat left, BigLakeConfigurationTableFormat right) => !left.Equals(right);

        public static explicit operator string(BigLakeConfigurationTableFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BigLakeConfigurationTableFormat other && Equals(other);
        public bool Equals(BigLakeConfigurationTableFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct DatasetAccessEntryTargetTypesItem : IEquatable<DatasetAccessEntryTargetTypesItem>
    {
        private readonly string _value;

        private DatasetAccessEntryTargetTypesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use. You must set a target type explicitly.
        /// </summary>
        public static DatasetAccessEntryTargetTypesItem TargetTypeUnspecified { get; } = new DatasetAccessEntryTargetTypesItem("TARGET_TYPE_UNSPECIFIED");
        /// <summary>
        /// This entry applies to views in the dataset.
        /// </summary>
        public static DatasetAccessEntryTargetTypesItem Views { get; } = new DatasetAccessEntryTargetTypesItem("VIEWS");
        /// <summary>
        /// This entry applies to routines in the dataset.
        /// </summary>
        public static DatasetAccessEntryTargetTypesItem Routines { get; } = new DatasetAccessEntryTargetTypesItem("ROUTINES");

        public static bool operator ==(DatasetAccessEntryTargetTypesItem left, DatasetAccessEntryTargetTypesItem right) => left.Equals(right);
        public static bool operator !=(DatasetAccessEntryTargetTypesItem left, DatasetAccessEntryTargetTypesItem right) => !left.Equals(right);

        public static explicit operator string(DatasetAccessEntryTargetTypesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatasetAccessEntryTargetTypesItem other && Equals(other);
        public bool Equals(DatasetAccessEntryTargetTypesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Defines the default rounding mode specification of new tables created within this dataset. During table creation, if this field is specified, the table within this dataset will inherit the default rounding mode of the dataset. Setting the default rounding mode on a table overrides this option. Existing tables in the dataset are unaffected. If columns are defined during that table creation, they will immediately inherit the table's default rounding mode, unless otherwise specified.
    /// </summary>
    [EnumType]
    public readonly struct DatasetDefaultRoundingMode : IEquatable<DatasetDefaultRoundingMode>
    {
        private readonly string _value;

        private DatasetDefaultRoundingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified will default to using ROUND_HALF_AWAY_FROM_ZERO.
        /// </summary>
        public static DatasetDefaultRoundingMode RoundingModeUnspecified { get; } = new DatasetDefaultRoundingMode("ROUNDING_MODE_UNSPECIFIED");
        /// <summary>
        /// ROUND_HALF_AWAY_FROM_ZERO rounds half values away from zero when applying precision and scale upon writing of NUMERIC and BIGNUMERIC values. For Scale: 0 1.1, 1.2, 1.3, 1.4 =&gt; 1 1.5, 1.6, 1.7, 1.8, 1.9 =&gt; 2
        /// </summary>
        public static DatasetDefaultRoundingMode RoundHalfAwayFromZero { get; } = new DatasetDefaultRoundingMode("ROUND_HALF_AWAY_FROM_ZERO");
        /// <summary>
        /// ROUND_HALF_EVEN rounds half values to the nearest even value when applying precision and scale upon writing of NUMERIC and BIGNUMERIC values. For Scale: 0 1.1, 1.2, 1.3, 1.4 =&gt; 1 1.5 =&gt; 2 1.6, 1.7, 1.8, 1.9 =&gt; 2 2.5 =&gt; 2
        /// </summary>
        public static DatasetDefaultRoundingMode RoundHalfEven { get; } = new DatasetDefaultRoundingMode("ROUND_HALF_EVEN");

        public static bool operator ==(DatasetDefaultRoundingMode left, DatasetDefaultRoundingMode right) => left.Equals(right);
        public static bool operator !=(DatasetDefaultRoundingMode left, DatasetDefaultRoundingMode right) => !left.Equals(right);

        public static explicit operator string(DatasetDefaultRoundingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatasetDefaultRoundingMode other && Equals(other);
        public bool Equals(DatasetDefaultRoundingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Updates storage_billing_model for the dataset.
    /// </summary>
    [EnumType]
    public readonly struct DatasetStorageBillingModel : IEquatable<DatasetStorageBillingModel>
    {
        private readonly string _value;

        private DatasetStorageBillingModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Value not set.
        /// </summary>
        public static DatasetStorageBillingModel StorageBillingModelUnspecified { get; } = new DatasetStorageBillingModel("STORAGE_BILLING_MODEL_UNSPECIFIED");
        /// <summary>
        /// Billing for logical bytes.
        /// </summary>
        public static DatasetStorageBillingModel Logical { get; } = new DatasetStorageBillingModel("LOGICAL");
        /// <summary>
        /// Billing for physical bytes.
        /// </summary>
        public static DatasetStorageBillingModel Physical { get; } = new DatasetStorageBillingModel("PHYSICAL");

        public static bool operator ==(DatasetStorageBillingModel left, DatasetStorageBillingModel right) => left.Equals(right);
        public static bool operator !=(DatasetStorageBillingModel left, DatasetStorageBillingModel right) => !left.Equals(right);

        public static explicit operator string(DatasetStorageBillingModel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatasetStorageBillingModel other && Equals(other);
        public bool Equals(DatasetStorageBillingModel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct ExternalDataConfigurationDecimalTargetTypesItem : IEquatable<ExternalDataConfigurationDecimalTargetTypesItem>
    {
        private readonly string _value;

        private ExternalDataConfigurationDecimalTargetTypesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Invalid type.
        /// </summary>
        public static ExternalDataConfigurationDecimalTargetTypesItem DecimalTargetTypeUnspecified { get; } = new ExternalDataConfigurationDecimalTargetTypesItem("DECIMAL_TARGET_TYPE_UNSPECIFIED");
        /// <summary>
        /// Decimal values could be converted to NUMERIC type.
        /// </summary>
        public static ExternalDataConfigurationDecimalTargetTypesItem Numeric { get; } = new ExternalDataConfigurationDecimalTargetTypesItem("NUMERIC");
        /// <summary>
        /// Decimal values could be converted to BIGNUMERIC type.
        /// </summary>
        public static ExternalDataConfigurationDecimalTargetTypesItem Bignumeric { get; } = new ExternalDataConfigurationDecimalTargetTypesItem("BIGNUMERIC");
        /// <summary>
        /// Decimal values could be converted to STRING type.
        /// </summary>
        public static ExternalDataConfigurationDecimalTargetTypesItem String { get; } = new ExternalDataConfigurationDecimalTargetTypesItem("STRING");

        public static bool operator ==(ExternalDataConfigurationDecimalTargetTypesItem left, ExternalDataConfigurationDecimalTargetTypesItem right) => left.Equals(right);
        public static bool operator !=(ExternalDataConfigurationDecimalTargetTypesItem left, ExternalDataConfigurationDecimalTargetTypesItem right) => !left.Equals(right);

        public static explicit operator string(ExternalDataConfigurationDecimalTargetTypesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExternalDataConfigurationDecimalTargetTypesItem other && Equals(other);
        public bool Equals(ExternalDataConfigurationDecimalTargetTypesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Specifies how source URIs are interpreted for constructing the file set to load. By default source URIs are expanded against the underlying storage. Other options include specifying manifest files. Only applicable to object storage systems.
    /// </summary>
    [EnumType]
    public readonly struct ExternalDataConfigurationFileSetSpecType : IEquatable<ExternalDataConfigurationFileSetSpecType>
    {
        private readonly string _value;

        private ExternalDataConfigurationFileSetSpecType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This option expands source URIs by listing files from the object store. It is the default behavior if FileSetSpecType is not set.
        /// </summary>
        public static ExternalDataConfigurationFileSetSpecType FileSetSpecTypeFileSystemMatch { get; } = new ExternalDataConfigurationFileSetSpecType("FILE_SET_SPEC_TYPE_FILE_SYSTEM_MATCH");
        /// <summary>
        /// This option indicates that the provided URIs are newline-delimited manifest files, with one URI per line. Wildcard URIs are not supported.
        /// </summary>
        public static ExternalDataConfigurationFileSetSpecType FileSetSpecTypeNewLineDelimitedManifest { get; } = new ExternalDataConfigurationFileSetSpecType("FILE_SET_SPEC_TYPE_NEW_LINE_DELIMITED_MANIFEST");

        public static bool operator ==(ExternalDataConfigurationFileSetSpecType left, ExternalDataConfigurationFileSetSpecType right) => left.Equals(right);
        public static bool operator !=(ExternalDataConfigurationFileSetSpecType left, ExternalDataConfigurationFileSetSpecType right) => !left.Equals(right);

        public static explicit operator string(ExternalDataConfigurationFileSetSpecType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExternalDataConfigurationFileSetSpecType other && Equals(other);
        public bool Equals(ExternalDataConfigurationFileSetSpecType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Load option to be used together with source_format newline-delimited JSON to indicate that a variant of JSON is being loaded. To load newline-delimited GeoJSON, specify GEOJSON (and source_format must be set to NEWLINE_DELIMITED_JSON).
    /// </summary>
    [EnumType]
    public readonly struct ExternalDataConfigurationJsonExtension : IEquatable<ExternalDataConfigurationJsonExtension>
    {
        private readonly string _value;

        private ExternalDataConfigurationJsonExtension(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default if provided value is not one included in the enum, or the value is not specified. The source formate is parsed without any modification.
        /// </summary>
        public static ExternalDataConfigurationJsonExtension JsonExtensionUnspecified { get; } = new ExternalDataConfigurationJsonExtension("JSON_EXTENSION_UNSPECIFIED");
        /// <summary>
        /// Use GeoJSON variant of JSON. See https://tools.ietf.org/html/rfc7946.
        /// </summary>
        public static ExternalDataConfigurationJsonExtension Geojson { get; } = new ExternalDataConfigurationJsonExtension("GEOJSON");

        public static bool operator ==(ExternalDataConfigurationJsonExtension left, ExternalDataConfigurationJsonExtension right) => left.Equals(right);
        public static bool operator !=(ExternalDataConfigurationJsonExtension left, ExternalDataConfigurationJsonExtension right) => !left.Equals(right);

        public static explicit operator string(ExternalDataConfigurationJsonExtension value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExternalDataConfigurationJsonExtension other && Equals(other);
        public bool Equals(ExternalDataConfigurationJsonExtension other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Metadata Cache Mode for the table. Set this to enable caching of metadata from external data source.
    /// </summary>
    [EnumType]
    public readonly struct ExternalDataConfigurationMetadataCacheMode : IEquatable<ExternalDataConfigurationMetadataCacheMode>
    {
        private readonly string _value;

        private ExternalDataConfigurationMetadataCacheMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified metadata cache mode.
        /// </summary>
        public static ExternalDataConfigurationMetadataCacheMode MetadataCacheModeUnspecified { get; } = new ExternalDataConfigurationMetadataCacheMode("METADATA_CACHE_MODE_UNSPECIFIED");
        /// <summary>
        /// Set this mode to trigger automatic background refresh of metadata cache from the external source. Queries will use the latest available cache version within the table's maxStaleness interval.
        /// </summary>
        public static ExternalDataConfigurationMetadataCacheMode Automatic { get; } = new ExternalDataConfigurationMetadataCacheMode("AUTOMATIC");
        /// <summary>
        /// Set this mode to enable triggering manual refresh of the metadata cache from external source. Queries will use the latest manually triggered cache version within the table's maxStaleness interval.
        /// </summary>
        public static ExternalDataConfigurationMetadataCacheMode Manual { get; } = new ExternalDataConfigurationMetadataCacheMode("MANUAL");

        public static bool operator ==(ExternalDataConfigurationMetadataCacheMode left, ExternalDataConfigurationMetadataCacheMode right) => left.Equals(right);
        public static bool operator !=(ExternalDataConfigurationMetadataCacheMode left, ExternalDataConfigurationMetadataCacheMode right) => !left.Equals(right);

        public static explicit operator string(ExternalDataConfigurationMetadataCacheMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExternalDataConfigurationMetadataCacheMode other && Equals(other);
        public bool Equals(ExternalDataConfigurationMetadataCacheMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. ObjectMetadata is used to create Object Tables. Object Tables contain a listing of objects (with their metadata) found at the source_uris. If ObjectMetadata is set, source_format should be omitted. Currently SIMPLE is the only supported Object Metadata type.
    /// </summary>
    [EnumType]
    public readonly struct ExternalDataConfigurationObjectMetadata : IEquatable<ExternalDataConfigurationObjectMetadata>
    {
        private readonly string _value;

        private ExternalDataConfigurationObjectMetadata(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified by default.
        /// </summary>
        public static ExternalDataConfigurationObjectMetadata ObjectMetadataUnspecified { get; } = new ExternalDataConfigurationObjectMetadata("OBJECT_METADATA_UNSPECIFIED");
        /// <summary>
        /// A synonym for `SIMPLE`.
        /// </summary>
        public static ExternalDataConfigurationObjectMetadata Directory { get; } = new ExternalDataConfigurationObjectMetadata("DIRECTORY");
        /// <summary>
        /// Directory listing of objects.
        /// </summary>
        public static ExternalDataConfigurationObjectMetadata Simple { get; } = new ExternalDataConfigurationObjectMetadata("SIMPLE");

        public static bool operator ==(ExternalDataConfigurationObjectMetadata left, ExternalDataConfigurationObjectMetadata right) => left.Equals(right);
        public static bool operator !=(ExternalDataConfigurationObjectMetadata left, ExternalDataConfigurationObjectMetadata right) => !left.Equals(right);

        public static explicit operator string(ExternalDataConfigurationObjectMetadata value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExternalDataConfigurationObjectMetadata other && Equals(other);
        public bool Equals(ExternalDataConfigurationObjectMetadata other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct JobConfigurationLoadDecimalTargetTypesItem : IEquatable<JobConfigurationLoadDecimalTargetTypesItem>
    {
        private readonly string _value;

        private JobConfigurationLoadDecimalTargetTypesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Invalid type.
        /// </summary>
        public static JobConfigurationLoadDecimalTargetTypesItem DecimalTargetTypeUnspecified { get; } = new JobConfigurationLoadDecimalTargetTypesItem("DECIMAL_TARGET_TYPE_UNSPECIFIED");
        /// <summary>
        /// Decimal values could be converted to NUMERIC type.
        /// </summary>
        public static JobConfigurationLoadDecimalTargetTypesItem Numeric { get; } = new JobConfigurationLoadDecimalTargetTypesItem("NUMERIC");
        /// <summary>
        /// Decimal values could be converted to BIGNUMERIC type.
        /// </summary>
        public static JobConfigurationLoadDecimalTargetTypesItem Bignumeric { get; } = new JobConfigurationLoadDecimalTargetTypesItem("BIGNUMERIC");
        /// <summary>
        /// Decimal values could be converted to STRING type.
        /// </summary>
        public static JobConfigurationLoadDecimalTargetTypesItem String { get; } = new JobConfigurationLoadDecimalTargetTypesItem("STRING");

        public static bool operator ==(JobConfigurationLoadDecimalTargetTypesItem left, JobConfigurationLoadDecimalTargetTypesItem right) => left.Equals(right);
        public static bool operator !=(JobConfigurationLoadDecimalTargetTypesItem left, JobConfigurationLoadDecimalTargetTypesItem right) => !left.Equals(right);

        public static explicit operator string(JobConfigurationLoadDecimalTargetTypesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobConfigurationLoadDecimalTargetTypesItem other && Equals(other);
        public bool Equals(JobConfigurationLoadDecimalTargetTypesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Specifies how source URIs are interpreted for constructing the file set to load. By default, source URIs are expanded against the underlying storage. You can also specify manifest files to control how the file set is constructed. This option is only applicable to object storage systems.
    /// </summary>
    [EnumType]
    public readonly struct JobConfigurationLoadFileSetSpecType : IEquatable<JobConfigurationLoadFileSetSpecType>
    {
        private readonly string _value;

        private JobConfigurationLoadFileSetSpecType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This option expands source URIs by listing files from the object store. It is the default behavior if FileSetSpecType is not set.
        /// </summary>
        public static JobConfigurationLoadFileSetSpecType FileSetSpecTypeFileSystemMatch { get; } = new JobConfigurationLoadFileSetSpecType("FILE_SET_SPEC_TYPE_FILE_SYSTEM_MATCH");
        /// <summary>
        /// This option indicates that the provided URIs are newline-delimited manifest files, with one URI per line. Wildcard URIs are not supported.
        /// </summary>
        public static JobConfigurationLoadFileSetSpecType FileSetSpecTypeNewLineDelimitedManifest { get; } = new JobConfigurationLoadFileSetSpecType("FILE_SET_SPEC_TYPE_NEW_LINE_DELIMITED_MANIFEST");

        public static bool operator ==(JobConfigurationLoadFileSetSpecType left, JobConfigurationLoadFileSetSpecType right) => left.Equals(right);
        public static bool operator !=(JobConfigurationLoadFileSetSpecType left, JobConfigurationLoadFileSetSpecType right) => !left.Equals(right);

        public static explicit operator string(JobConfigurationLoadFileSetSpecType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobConfigurationLoadFileSetSpecType other && Equals(other);
        public bool Equals(JobConfigurationLoadFileSetSpecType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Load option to be used together with source_format newline-delimited JSON to indicate that a variant of JSON is being loaded. To load newline-delimited GeoJSON, specify GEOJSON (and source_format must be set to NEWLINE_DELIMITED_JSON).
    /// </summary>
    [EnumType]
    public readonly struct JobConfigurationLoadJsonExtension : IEquatable<JobConfigurationLoadJsonExtension>
    {
        private readonly string _value;

        private JobConfigurationLoadJsonExtension(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default if provided value is not one included in the enum, or the value is not specified. The source formate is parsed without any modification.
        /// </summary>
        public static JobConfigurationLoadJsonExtension JsonExtensionUnspecified { get; } = new JobConfigurationLoadJsonExtension("JSON_EXTENSION_UNSPECIFIED");
        /// <summary>
        /// Use GeoJSON variant of JSON. See https://tools.ietf.org/html/rfc7946.
        /// </summary>
        public static JobConfigurationLoadJsonExtension Geojson { get; } = new JobConfigurationLoadJsonExtension("GEOJSON");

        public static bool operator ==(JobConfigurationLoadJsonExtension left, JobConfigurationLoadJsonExtension right) => left.Equals(right);
        public static bool operator !=(JobConfigurationLoadJsonExtension left, JobConfigurationLoadJsonExtension right) => !left.Equals(right);

        public static explicit operator string(JobConfigurationLoadJsonExtension value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobConfigurationLoadJsonExtension other && Equals(other);
        public bool Equals(JobConfigurationLoadJsonExtension other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Supported operation types in table copy job.
    /// </summary>
    [EnumType]
    public readonly struct JobConfigurationTableCopyOperationType : IEquatable<JobConfigurationTableCopyOperationType>
    {
        private readonly string _value;

        private JobConfigurationTableCopyOperationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified operation type.
        /// </summary>
        public static JobConfigurationTableCopyOperationType OperationTypeUnspecified { get; } = new JobConfigurationTableCopyOperationType("OPERATION_TYPE_UNSPECIFIED");
        /// <summary>
        /// The source and destination table have the same table type.
        /// </summary>
        public static JobConfigurationTableCopyOperationType Copy { get; } = new JobConfigurationTableCopyOperationType("COPY");
        /// <summary>
        /// The source table type is TABLE and the destination table type is SNAPSHOT.
        /// </summary>
        public static JobConfigurationTableCopyOperationType Snapshot { get; } = new JobConfigurationTableCopyOperationType("SNAPSHOT");
        /// <summary>
        /// The source table type is SNAPSHOT and the destination table type is TABLE.
        /// </summary>
        public static JobConfigurationTableCopyOperationType Restore { get; } = new JobConfigurationTableCopyOperationType("RESTORE");
        /// <summary>
        /// The source and destination table have the same table type, but only bill for unique data.
        /// </summary>
        public static JobConfigurationTableCopyOperationType Clone { get; } = new JobConfigurationTableCopyOperationType("CLONE");

        public static bool operator ==(JobConfigurationTableCopyOperationType left, JobConfigurationTableCopyOperationType right) => left.Equals(right);
        public static bool operator !=(JobConfigurationTableCopyOperationType left, JobConfigurationTableCopyOperationType right) => !left.Equals(right);

        public static explicit operator string(JobConfigurationTableCopyOperationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobConfigurationTableCopyOperationType other && Equals(other);
        public bool Equals(JobConfigurationTableCopyOperationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. If set to `DATA_MASKING`, the function is validated and made available as a masking function. For more information, see [Create custom masking routines](https://cloud.google.com/bigquery/docs/user-defined-functions#custom-mask).
    /// </summary>
    [EnumType]
    public readonly struct RoutineDataGovernanceType : IEquatable<RoutineDataGovernanceType>
    {
        private readonly string _value;

        private RoutineDataGovernanceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The data governance type is unspecified.
        /// </summary>
        public static RoutineDataGovernanceType DataGovernanceTypeUnspecified { get; } = new RoutineDataGovernanceType("DATA_GOVERNANCE_TYPE_UNSPECIFIED");
        /// <summary>
        /// The data governance type is data masking.
        /// </summary>
        public static RoutineDataGovernanceType DataMasking { get; } = new RoutineDataGovernanceType("DATA_MASKING");

        public static bool operator ==(RoutineDataGovernanceType left, RoutineDataGovernanceType right) => left.Equals(right);
        public static bool operator !=(RoutineDataGovernanceType left, RoutineDataGovernanceType right) => !left.Equals(right);

        public static explicit operator string(RoutineDataGovernanceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RoutineDataGovernanceType other && Equals(other);
        public bool Equals(RoutineDataGovernanceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The determinism level of the JavaScript UDF, if defined.
    /// </summary>
    [EnumType]
    public readonly struct RoutineDeterminismLevel : IEquatable<RoutineDeterminismLevel>
    {
        private readonly string _value;

        private RoutineDeterminismLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The determinism of the UDF is unspecified.
        /// </summary>
        public static RoutineDeterminismLevel DeterminismLevelUnspecified { get; } = new RoutineDeterminismLevel("DETERMINISM_LEVEL_UNSPECIFIED");
        /// <summary>
        /// The UDF is deterministic, meaning that 2 function calls with the same inputs always produce the same result, even across 2 query runs.
        /// </summary>
        public static RoutineDeterminismLevel Deterministic { get; } = new RoutineDeterminismLevel("DETERMINISTIC");
        /// <summary>
        /// The UDF is not deterministic.
        /// </summary>
        public static RoutineDeterminismLevel NotDeterministic { get; } = new RoutineDeterminismLevel("NOT_DETERMINISTIC");

        public static bool operator ==(RoutineDeterminismLevel left, RoutineDeterminismLevel right) => left.Equals(right);
        public static bool operator !=(RoutineDeterminismLevel left, RoutineDeterminismLevel right) => !left.Equals(right);

        public static explicit operator string(RoutineDeterminismLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RoutineDeterminismLevel other && Equals(other);
        public bool Equals(RoutineDeterminismLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Defaults to "SQL" if remote_function_options field is absent, not set otherwise.
    /// </summary>
    [EnumType]
    public readonly struct RoutineLanguage : IEquatable<RoutineLanguage>
    {
        private readonly string _value;

        private RoutineLanguage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static RoutineLanguage LanguageUnspecified { get; } = new RoutineLanguage("LANGUAGE_UNSPECIFIED");
        /// <summary>
        /// SQL language.
        /// </summary>
        public static RoutineLanguage Sql { get; } = new RoutineLanguage("SQL");
        /// <summary>
        /// JavaScript language.
        /// </summary>
        public static RoutineLanguage Javascript { get; } = new RoutineLanguage("JAVASCRIPT");
        /// <summary>
        /// Python language.
        /// </summary>
        public static RoutineLanguage Python { get; } = new RoutineLanguage("PYTHON");
        /// <summary>
        /// Java language.
        /// </summary>
        public static RoutineLanguage Java { get; } = new RoutineLanguage("JAVA");
        /// <summary>
        /// Scala language.
        /// </summary>
        public static RoutineLanguage Scala { get; } = new RoutineLanguage("SCALA");

        public static bool operator ==(RoutineLanguage left, RoutineLanguage right) => left.Equals(right);
        public static bool operator !=(RoutineLanguage left, RoutineLanguage right) => !left.Equals(right);

        public static explicit operator string(RoutineLanguage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RoutineLanguage other && Equals(other);
        public bool Equals(RoutineLanguage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The type of routine.
    /// </summary>
    [EnumType]
    public readonly struct RoutineRoutineType : IEquatable<RoutineRoutineType>
    {
        private readonly string _value;

        private RoutineRoutineType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static RoutineRoutineType RoutineTypeUnspecified { get; } = new RoutineRoutineType("ROUTINE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Non-built-in persistent scalar function.
        /// </summary>
        public static RoutineRoutineType ScalarFunction { get; } = new RoutineRoutineType("SCALAR_FUNCTION");
        /// <summary>
        /// Stored procedure.
        /// </summary>
        public static RoutineRoutineType Procedure { get; } = new RoutineRoutineType("PROCEDURE");
        /// <summary>
        /// Non-built-in persistent TVF.
        /// </summary>
        public static RoutineRoutineType TableValuedFunction { get; } = new RoutineRoutineType("TABLE_VALUED_FUNCTION");
        /// <summary>
        /// Non-built-in persistent aggregate function.
        /// </summary>
        public static RoutineRoutineType AggregateFunction { get; } = new RoutineRoutineType("AGGREGATE_FUNCTION");

        public static bool operator ==(RoutineRoutineType left, RoutineRoutineType right) => left.Equals(right);
        public static bool operator !=(RoutineRoutineType left, RoutineRoutineType right) => !left.Equals(right);

        public static explicit operator string(RoutineRoutineType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RoutineRoutineType other && Equals(other);
        public bool Equals(RoutineRoutineType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The security mode of the routine, if defined. If not defined, the security mode is automatically determined from the routine's configuration.
    /// </summary>
    [EnumType]
    public readonly struct RoutineSecurityMode : IEquatable<RoutineSecurityMode>
    {
        private readonly string _value;

        private RoutineSecurityMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The security mode of the routine is unspecified.
        /// </summary>
        public static RoutineSecurityMode SecurityModeUnspecified { get; } = new RoutineSecurityMode("SECURITY_MODE_UNSPECIFIED");
        /// <summary>
        /// The routine is to be executed with the privileges of the user who defines it.
        /// </summary>
        public static RoutineSecurityMode Definer { get; } = new RoutineSecurityMode("DEFINER");
        /// <summary>
        /// The routine is to be executed with the privileges of the user who invokes it.
        /// </summary>
        public static RoutineSecurityMode Invoker { get; } = new RoutineSecurityMode("INVOKER");

        public static bool operator ==(RoutineSecurityMode left, RoutineSecurityMode right) => left.Equals(right);
        public static bool operator !=(RoutineSecurityMode left, RoutineSecurityMode right) => !left.Equals(right);

        public static explicit operator string(RoutineSecurityMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RoutineSecurityMode other && Equals(other);
        public bool Equals(RoutineSecurityMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines which statement in the script represents the "key result", used to populate the schema and query results of the script job. Default is LAST.
    /// </summary>
    [EnumType]
    public readonly struct ScriptOptionsKeyResultStatement : IEquatable<ScriptOptionsKeyResultStatement>
    {
        private readonly string _value;

        private ScriptOptionsKeyResultStatement(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static ScriptOptionsKeyResultStatement KeyResultStatementKindUnspecified { get; } = new ScriptOptionsKeyResultStatement("KEY_RESULT_STATEMENT_KIND_UNSPECIFIED");
        /// <summary>
        /// The last result determines the key result.
        /// </summary>
        public static ScriptOptionsKeyResultStatement Last { get; } = new ScriptOptionsKeyResultStatement("LAST");
        /// <summary>
        /// The first SELECT statement determines the key result.
        /// </summary>
        public static ScriptOptionsKeyResultStatement FirstSelect { get; } = new ScriptOptionsKeyResultStatement("FIRST_SELECT");

        public static bool operator ==(ScriptOptionsKeyResultStatement left, ScriptOptionsKeyResultStatement right) => left.Equals(right);
        public static bool operator !=(ScriptOptionsKeyResultStatement left, ScriptOptionsKeyResultStatement right) => !left.Equals(right);

        public static explicit operator string(ScriptOptionsKeyResultStatement value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScriptOptionsKeyResultStatement other && Equals(other);
        public bool Equals(ScriptOptionsKeyResultStatement other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The top level type of this field. Can be any GoogleSQL data type (e.g., "INT64", "DATE", "ARRAY").
    /// </summary>
    [EnumType]
    public readonly struct StandardSqlDataTypeTypeKind : IEquatable<StandardSqlDataTypeTypeKind>
    {
        private readonly string _value;

        private StandardSqlDataTypeTypeKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Invalid type.
        /// </summary>
        public static StandardSqlDataTypeTypeKind TypeKindUnspecified { get; } = new StandardSqlDataTypeTypeKind("TYPE_KIND_UNSPECIFIED");
        /// <summary>
        /// Encoded as a string in decimal format.
        /// </summary>
        public static StandardSqlDataTypeTypeKind Int64 { get; } = new StandardSqlDataTypeTypeKind("INT64");
        /// <summary>
        /// Encoded as a boolean "false" or "true".
        /// </summary>
        public static StandardSqlDataTypeTypeKind Bool { get; } = new StandardSqlDataTypeTypeKind("BOOL");
        /// <summary>
        /// Encoded as a number, or string "NaN", "Infinity" or "-Infinity".
        /// </summary>
        public static StandardSqlDataTypeTypeKind Float64 { get; } = new StandardSqlDataTypeTypeKind("FLOAT64");
        /// <summary>
        /// Encoded as a string value.
        /// </summary>
        public static StandardSqlDataTypeTypeKind String { get; } = new StandardSqlDataTypeTypeKind("STRING");
        /// <summary>
        /// Encoded as a base64 string per RFC 4648, section 4.
        /// </summary>
        public static StandardSqlDataTypeTypeKind Bytes { get; } = new StandardSqlDataTypeTypeKind("BYTES");
        /// <summary>
        /// Encoded as an RFC 3339 timestamp with mandatory "Z" time zone string: 1985-04-12T23:20:50.52Z
        /// </summary>
        public static StandardSqlDataTypeTypeKind Timestamp { get; } = new StandardSqlDataTypeTypeKind("TIMESTAMP");
        /// <summary>
        /// Encoded as RFC 3339 full-date format string: 1985-04-12
        /// </summary>
        public static StandardSqlDataTypeTypeKind Date { get; } = new StandardSqlDataTypeTypeKind("DATE");
        /// <summary>
        /// Encoded as RFC 3339 partial-time format string: 23:20:50.52
        /// </summary>
        public static StandardSqlDataTypeTypeKind Time { get; } = new StandardSqlDataTypeTypeKind("TIME");
        /// <summary>
        /// Encoded as RFC 3339 full-date "T" partial-time: 1985-04-12T23:20:50.52
        /// </summary>
        public static StandardSqlDataTypeTypeKind Datetime { get; } = new StandardSqlDataTypeTypeKind("DATETIME");
        /// <summary>
        /// Encoded as fully qualified 3 part: 0-5 15 2:30:45.6
        /// </summary>
        public static StandardSqlDataTypeTypeKind Interval { get; } = new StandardSqlDataTypeTypeKind("INTERVAL");
        /// <summary>
        /// Encoded as WKT
        /// </summary>
        public static StandardSqlDataTypeTypeKind Geography { get; } = new StandardSqlDataTypeTypeKind("GEOGRAPHY");
        /// <summary>
        /// Encoded as a decimal string.
        /// </summary>
        public static StandardSqlDataTypeTypeKind Numeric { get; } = new StandardSqlDataTypeTypeKind("NUMERIC");
        /// <summary>
        /// Encoded as a decimal string.
        /// </summary>
        public static StandardSqlDataTypeTypeKind Bignumeric { get; } = new StandardSqlDataTypeTypeKind("BIGNUMERIC");
        /// <summary>
        /// Encoded as a string.
        /// </summary>
        public static StandardSqlDataTypeTypeKind Json { get; } = new StandardSqlDataTypeTypeKind("JSON");
        /// <summary>
        /// Encoded as a list with types matching Type.array_type.
        /// </summary>
        public static StandardSqlDataTypeTypeKind Array { get; } = new StandardSqlDataTypeTypeKind("ARRAY");
        /// <summary>
        /// Encoded as a list with fields of type Type.struct_type[i]. List is used because a JSON object cannot have duplicate field names.
        /// </summary>
        public static StandardSqlDataTypeTypeKind Struct { get; } = new StandardSqlDataTypeTypeKind("STRUCT");
        /// <summary>
        /// Encoded as a pair with types matching range_element_type. Pairs must begin with "[", end with ")", and be separated by ", ".
        /// </summary>
        public static StandardSqlDataTypeTypeKind Range { get; } = new StandardSqlDataTypeTypeKind("RANGE");

        public static bool operator ==(StandardSqlDataTypeTypeKind left, StandardSqlDataTypeTypeKind right) => left.Equals(right);
        public static bool operator !=(StandardSqlDataTypeTypeKind left, StandardSqlDataTypeTypeKind right) => !left.Equals(right);

        public static explicit operator string(StandardSqlDataTypeTypeKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StandardSqlDataTypeTypeKind other && Equals(other);
        public bool Equals(StandardSqlDataTypeTypeKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Defines the default rounding mode specification of new decimal fields (NUMERIC OR BIGNUMERIC) in the table. During table creation or update, if a decimal field is added to this table without an explicit rounding mode specified, then the field inherits the table default rounding mode. Changing this field doesn't affect existing fields.
    /// </summary>
    [EnumType]
    public readonly struct TableDefaultRoundingMode : IEquatable<TableDefaultRoundingMode>
    {
        private readonly string _value;

        private TableDefaultRoundingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified will default to using ROUND_HALF_AWAY_FROM_ZERO.
        /// </summary>
        public static TableDefaultRoundingMode RoundingModeUnspecified { get; } = new TableDefaultRoundingMode("ROUNDING_MODE_UNSPECIFIED");
        /// <summary>
        /// ROUND_HALF_AWAY_FROM_ZERO rounds half values away from zero when applying precision and scale upon writing of NUMERIC and BIGNUMERIC values. For Scale: 0 1.1, 1.2, 1.3, 1.4 =&gt; 1 1.5, 1.6, 1.7, 1.8, 1.9 =&gt; 2
        /// </summary>
        public static TableDefaultRoundingMode RoundHalfAwayFromZero { get; } = new TableDefaultRoundingMode("ROUND_HALF_AWAY_FROM_ZERO");
        /// <summary>
        /// ROUND_HALF_EVEN rounds half values to the nearest even value when applying precision and scale upon writing of NUMERIC and BIGNUMERIC values. For Scale: 0 1.1, 1.2, 1.3, 1.4 =&gt; 1 1.5 =&gt; 2 1.6, 1.7, 1.8, 1.9 =&gt; 2 2.5 =&gt; 2
        /// </summary>
        public static TableDefaultRoundingMode RoundHalfEven { get; } = new TableDefaultRoundingMode("ROUND_HALF_EVEN");

        public static bool operator ==(TableDefaultRoundingMode left, TableDefaultRoundingMode right) => left.Equals(right);
        public static bool operator !=(TableDefaultRoundingMode left, TableDefaultRoundingMode right) => !left.Equals(right);

        public static explicit operator string(TableDefaultRoundingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TableDefaultRoundingMode other && Equals(other);
        public bool Equals(TableDefaultRoundingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Specifies the rounding mode to be used when storing values of NUMERIC and BIGNUMERIC type.
    /// </summary>
    [EnumType]
    public readonly struct TableFieldSchemaRoundingMode : IEquatable<TableFieldSchemaRoundingMode>
    {
        private readonly string _value;

        private TableFieldSchemaRoundingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified will default to using ROUND_HALF_AWAY_FROM_ZERO.
        /// </summary>
        public static TableFieldSchemaRoundingMode RoundingModeUnspecified { get; } = new TableFieldSchemaRoundingMode("ROUNDING_MODE_UNSPECIFIED");
        /// <summary>
        /// ROUND_HALF_AWAY_FROM_ZERO rounds half values away from zero when applying precision and scale upon writing of NUMERIC and BIGNUMERIC values. For Scale: 0 1.1, 1.2, 1.3, 1.4 =&gt; 1 1.5, 1.6, 1.7, 1.8, 1.9 =&gt; 2
        /// </summary>
        public static TableFieldSchemaRoundingMode RoundHalfAwayFromZero { get; } = new TableFieldSchemaRoundingMode("ROUND_HALF_AWAY_FROM_ZERO");
        /// <summary>
        /// ROUND_HALF_EVEN rounds half values to the nearest even value when applying precision and scale upon writing of NUMERIC and BIGNUMERIC values. For Scale: 0 1.1, 1.2, 1.3, 1.4 =&gt; 1 1.5 =&gt; 2 1.6, 1.7, 1.8, 1.9 =&gt; 2 2.5 =&gt; 2
        /// </summary>
        public static TableFieldSchemaRoundingMode RoundHalfEven { get; } = new TableFieldSchemaRoundingMode("ROUND_HALF_EVEN");

        public static bool operator ==(TableFieldSchemaRoundingMode left, TableFieldSchemaRoundingMode right) => left.Equals(right);
        public static bool operator !=(TableFieldSchemaRoundingMode left, TableFieldSchemaRoundingMode right) => !left.Equals(right);

        public static explicit operator string(TableFieldSchemaRoundingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TableFieldSchemaRoundingMode other && Equals(other);
        public bool Equals(TableFieldSchemaRoundingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.BigQuery.V2
{
    /// <summary>
    /// Optional. Defaults to FIXED_TYPE.
    /// </summary>
    [EnumType]
    public readonly struct ArgumentArgumentKind : IEquatable<ArgumentArgumentKind>
    {
        private readonly string _value;

        private ArgumentArgumentKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ArgumentArgumentKind ArgumentKindUnspecified { get; } = new ArgumentArgumentKind("ARGUMENT_KIND_UNSPECIFIED");
        /// <summary>
        /// The argument is a variable with fully specified type, which can be a struct or an array, but not a table.
        /// </summary>
        public static ArgumentArgumentKind FixedType { get; } = new ArgumentArgumentKind("FIXED_TYPE");
        /// <summary>
        /// The argument is any type, including struct or array, but not a table. To be added: FIXED_TABLE, ANY_TABLE
        /// </summary>
        public static ArgumentArgumentKind AnyType { get; } = new ArgumentArgumentKind("ANY_TYPE");

        public static bool operator ==(ArgumentArgumentKind left, ArgumentArgumentKind right) => left.Equals(right);
        public static bool operator !=(ArgumentArgumentKind left, ArgumentArgumentKind right) => !left.Equals(right);

        public static explicit operator string(ArgumentArgumentKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ArgumentArgumentKind other && Equals(other);
        public bool Equals(ArgumentArgumentKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Specifies whether the argument is input or output. Can be set for procedures only.
    /// </summary>
    [EnumType]
    public readonly struct ArgumentMode : IEquatable<ArgumentMode>
    {
        private readonly string _value;

        private ArgumentMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ArgumentMode ModeUnspecified { get; } = new ArgumentMode("MODE_UNSPECIFIED");
        /// <summary>
        /// The argument is input-only.
        /// </summary>
        public static ArgumentMode In { get; } = new ArgumentMode("IN");
        /// <summary>
        /// The argument is output-only.
        /// </summary>
        public static ArgumentMode Out { get; } = new ArgumentMode("OUT");
        /// <summary>
        /// The argument is both an input and an output.
        /// </summary>
        public static ArgumentMode Inout { get; } = new ArgumentMode("INOUT");

        public static bool operator ==(ArgumentMode left, ArgumentMode right) => left.Equals(right);
        public static bool operator !=(ArgumentMode left, ArgumentMode right) => !left.Equals(right);

        public static explicit operator string(ArgumentMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ArgumentMode other && Equals(other);
        public bool Equals(ArgumentMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct AuditLogConfigLogType : IEquatable<AuditLogConfigLogType>
    {
        private readonly string _value;

        private AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default case. Should never be this.
        /// </summary>
        public static AuditLogConfigLogType LogTypeUnspecified { get; } = new AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");
        /// <summary>
        /// Admin reads. Example: CloudIAM getIamPolicy
        /// </summary>
        public static AuditLogConfigLogType AdminRead { get; } = new AuditLogConfigLogType("ADMIN_READ");
        /// <summary>
        /// Data writes. Example: CloudSQL Users create
        /// </summary>
        public static AuditLogConfigLogType DataWrite { get; } = new AuditLogConfigLogType("DATA_WRITE");
        /// <summary>
        /// Data reads. Example: CloudSQL Users list
        /// </summary>
        public static AuditLogConfigLogType DataRead { get; } = new AuditLogConfigLogType("DATA_READ");

        public static bool operator ==(AuditLogConfigLogType left, AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(AuditLogConfigLogType left, AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuditLogConfigLogType other && Equals(other);
        public bool Equals(AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct DatasetAccessEntryTargetTypesItem : IEquatable<DatasetAccessEntryTargetTypesItem>
    {
        private readonly string _value;

        private DatasetAccessEntryTargetTypesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use. You must set a target type explicitly.
        /// </summary>
        public static DatasetAccessEntryTargetTypesItem TargetTypeUnspecified { get; } = new DatasetAccessEntryTargetTypesItem("TARGET_TYPE_UNSPECIFIED");
        /// <summary>
        /// This entry applies to views in the dataset.
        /// </summary>
        public static DatasetAccessEntryTargetTypesItem Views { get; } = new DatasetAccessEntryTargetTypesItem("VIEWS");

        public static bool operator ==(DatasetAccessEntryTargetTypesItem left, DatasetAccessEntryTargetTypesItem right) => left.Equals(right);
        public static bool operator !=(DatasetAccessEntryTargetTypesItem left, DatasetAccessEntryTargetTypesItem right) => !left.Equals(right);

        public static explicit operator string(DatasetAccessEntryTargetTypesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatasetAccessEntryTargetTypesItem other && Equals(other);
        public bool Equals(DatasetAccessEntryTargetTypesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The determinism level of the JavaScript UDF, if defined.
    /// </summary>
    [EnumType]
    public readonly struct RoutineDeterminismLevel : IEquatable<RoutineDeterminismLevel>
    {
        private readonly string _value;

        private RoutineDeterminismLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The determinism of the UDF is unspecified.
        /// </summary>
        public static RoutineDeterminismLevel DeterminismLevelUnspecified { get; } = new RoutineDeterminismLevel("DETERMINISM_LEVEL_UNSPECIFIED");
        /// <summary>
        /// The UDF is deterministic, meaning that 2 function calls with the same inputs always produce the same result, even across 2 query runs.
        /// </summary>
        public static RoutineDeterminismLevel Deterministic { get; } = new RoutineDeterminismLevel("DETERMINISTIC");
        /// <summary>
        /// The UDF is not deterministic.
        /// </summary>
        public static RoutineDeterminismLevel NotDeterministic { get; } = new RoutineDeterminismLevel("NOT_DETERMINISTIC");

        public static bool operator ==(RoutineDeterminismLevel left, RoutineDeterminismLevel right) => left.Equals(right);
        public static bool operator !=(RoutineDeterminismLevel left, RoutineDeterminismLevel right) => !left.Equals(right);

        public static explicit operator string(RoutineDeterminismLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RoutineDeterminismLevel other && Equals(other);
        public bool Equals(RoutineDeterminismLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Defaults to "SQL".
    /// </summary>
    [EnumType]
    public readonly struct RoutineLanguage : IEquatable<RoutineLanguage>
    {
        private readonly string _value;

        private RoutineLanguage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RoutineLanguage LanguageUnspecified { get; } = new RoutineLanguage("LANGUAGE_UNSPECIFIED");
        /// <summary>
        /// SQL language.
        /// </summary>
        public static RoutineLanguage Sql { get; } = new RoutineLanguage("SQL");
        /// <summary>
        /// JavaScript language.
        /// </summary>
        public static RoutineLanguage Javascript { get; } = new RoutineLanguage("JAVASCRIPT");

        public static bool operator ==(RoutineLanguage left, RoutineLanguage right) => left.Equals(right);
        public static bool operator !=(RoutineLanguage left, RoutineLanguage right) => !left.Equals(right);

        public static explicit operator string(RoutineLanguage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RoutineLanguage other && Equals(other);
        public bool Equals(RoutineLanguage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The type of routine.
    /// </summary>
    [EnumType]
    public readonly struct RoutineRoutineType : IEquatable<RoutineRoutineType>
    {
        private readonly string _value;

        private RoutineRoutineType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RoutineRoutineType RoutineTypeUnspecified { get; } = new RoutineRoutineType("ROUTINE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Non-builtin permanent scalar function.
        /// </summary>
        public static RoutineRoutineType ScalarFunction { get; } = new RoutineRoutineType("SCALAR_FUNCTION");
        /// <summary>
        /// Stored procedure.
        /// </summary>
        public static RoutineRoutineType Procedure { get; } = new RoutineRoutineType("PROCEDURE");
        /// <summary>
        /// Non-builtin permanent TVF.
        /// </summary>
        public static RoutineRoutineType TableValuedFunction { get; } = new RoutineRoutineType("TABLE_VALUED_FUNCTION");

        public static bool operator ==(RoutineRoutineType left, RoutineRoutineType right) => left.Equals(right);
        public static bool operator !=(RoutineRoutineType left, RoutineRoutineType right) => !left.Equals(right);

        public static explicit operator string(RoutineRoutineType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RoutineRoutineType other && Equals(other);
        public bool Equals(RoutineRoutineType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The top level type of this field. Can be any standard SQL data type (e.g., "INT64", "DATE", "ARRAY").
    /// </summary>
    [EnumType]
    public readonly struct StandardSqlDataTypeTypeKind : IEquatable<StandardSqlDataTypeTypeKind>
    {
        private readonly string _value;

        private StandardSqlDataTypeTypeKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Invalid type.
        /// </summary>
        public static StandardSqlDataTypeTypeKind TypeKindUnspecified { get; } = new StandardSqlDataTypeTypeKind("TYPE_KIND_UNSPECIFIED");
        /// <summary>
        /// Encoded as a string in decimal format.
        /// </summary>
        public static StandardSqlDataTypeTypeKind Int64 { get; } = new StandardSqlDataTypeTypeKind("INT64");
        /// <summary>
        /// Encoded as a boolean "false" or "true".
        /// </summary>
        public static StandardSqlDataTypeTypeKind Bool { get; } = new StandardSqlDataTypeTypeKind("BOOL");
        /// <summary>
        /// Encoded as a number, or string "NaN", "Infinity" or "-Infinity".
        /// </summary>
        public static StandardSqlDataTypeTypeKind Float64 { get; } = new StandardSqlDataTypeTypeKind("FLOAT64");
        /// <summary>
        /// Encoded as a string value.
        /// </summary>
        public static StandardSqlDataTypeTypeKind String { get; } = new StandardSqlDataTypeTypeKind("STRING");
        /// <summary>
        /// Encoded as a base64 string per RFC 4648, section 4.
        /// </summary>
        public static StandardSqlDataTypeTypeKind Bytes { get; } = new StandardSqlDataTypeTypeKind("BYTES");
        /// <summary>
        /// Encoded as an RFC 3339 timestamp with mandatory "Z" time zone string: 1985-04-12T23:20:50.52Z
        /// </summary>
        public static StandardSqlDataTypeTypeKind Timestamp { get; } = new StandardSqlDataTypeTypeKind("TIMESTAMP");
        /// <summary>
        /// Encoded as RFC 3339 full-date format string: 1985-04-12
        /// </summary>
        public static StandardSqlDataTypeTypeKind Date { get; } = new StandardSqlDataTypeTypeKind("DATE");
        /// <summary>
        /// Encoded as RFC 3339 partial-time format string: 23:20:50.52
        /// </summary>
        public static StandardSqlDataTypeTypeKind Time { get; } = new StandardSqlDataTypeTypeKind("TIME");
        /// <summary>
        /// Encoded as RFC 3339 full-date "T" partial-time: 1985-04-12T23:20:50.52
        /// </summary>
        public static StandardSqlDataTypeTypeKind Datetime { get; } = new StandardSqlDataTypeTypeKind("DATETIME");
        /// <summary>
        /// Encoded as fully qualified 3 part: 0-5 15 2:30:45.6
        /// </summary>
        public static StandardSqlDataTypeTypeKind Interval { get; } = new StandardSqlDataTypeTypeKind("INTERVAL");
        /// <summary>
        /// Encoded as WKT
        /// </summary>
        public static StandardSqlDataTypeTypeKind Geography { get; } = new StandardSqlDataTypeTypeKind("GEOGRAPHY");
        /// <summary>
        /// Encoded as a decimal string.
        /// </summary>
        public static StandardSqlDataTypeTypeKind Numeric { get; } = new StandardSqlDataTypeTypeKind("NUMERIC");
        /// <summary>
        /// Encoded as a decimal string.
        /// </summary>
        public static StandardSqlDataTypeTypeKind Bignumeric { get; } = new StandardSqlDataTypeTypeKind("BIGNUMERIC");
        /// <summary>
        /// Encoded as a string.
        /// </summary>
        public static StandardSqlDataTypeTypeKind Json { get; } = new StandardSqlDataTypeTypeKind("JSON");
        /// <summary>
        /// Encoded as a list with types matching Type.array_type.
        /// </summary>
        public static StandardSqlDataTypeTypeKind Array { get; } = new StandardSqlDataTypeTypeKind("ARRAY");
        /// <summary>
        /// Encoded as a list with fields of type Type.struct_type[i]. List is used because a JSON object cannot have duplicate field names.
        /// </summary>
        public static StandardSqlDataTypeTypeKind Struct { get; } = new StandardSqlDataTypeTypeKind("STRUCT");

        public static bool operator ==(StandardSqlDataTypeTypeKind left, StandardSqlDataTypeTypeKind right) => left.Equals(right);
        public static bool operator !=(StandardSqlDataTypeTypeKind left, StandardSqlDataTypeTypeKind right) => !left.Equals(right);

        public static explicit operator string(StandardSqlDataTypeTypeKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StandardSqlDataTypeTypeKind other && Equals(other);
        public bool Equals(StandardSqlDataTypeTypeKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

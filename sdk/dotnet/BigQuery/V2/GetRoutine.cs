// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.GoogleNative.BigQuery.V2
{
    public static class GetRoutine
    {
        /// <summary>
        /// Gets the specified routine resource by routine ID.
        /// </summary>
        public static Task<GetRoutineResult> InvokeAsync(GetRoutineArgs args, InvokeOptions? options = null)
            => Pulumi.Deployment.Instance.InvokeAsync<GetRoutineResult>("google-native:bigquery/v2:getRoutine", args ?? new GetRoutineArgs(), options.WithDefaults());

        /// <summary>
        /// Gets the specified routine resource by routine ID.
        /// </summary>
        public static Output<GetRoutineResult> Invoke(GetRoutineInvokeArgs args, InvokeOptions? options = null)
            => Pulumi.Deployment.Instance.Invoke<GetRoutineResult>("google-native:bigquery/v2:getRoutine", args ?? new GetRoutineInvokeArgs(), options.WithDefaults());
    }


    public sealed class GetRoutineArgs : global::Pulumi.InvokeArgs
    {
        [Input("datasetId", required: true)]
        public string DatasetId { get; set; } = null!;

        [Input("project")]
        public string? Project { get; set; }

        [Input("readMask")]
        public string? ReadMask { get; set; }

        [Input("routineId", required: true)]
        public string RoutineId { get; set; } = null!;

        public GetRoutineArgs()
        {
        }
        public static new GetRoutineArgs Empty => new GetRoutineArgs();
    }

    public sealed class GetRoutineInvokeArgs : global::Pulumi.InvokeArgs
    {
        [Input("datasetId", required: true)]
        public Input<string> DatasetId { get; set; } = null!;

        [Input("project")]
        public Input<string>? Project { get; set; }

        [Input("readMask")]
        public Input<string>? ReadMask { get; set; }

        [Input("routineId", required: true)]
        public Input<string> RoutineId { get; set; } = null!;

        public GetRoutineInvokeArgs()
        {
        }
        public static new GetRoutineInvokeArgs Empty => new GetRoutineInvokeArgs();
    }


    [OutputType]
    public sealed class GetRoutineResult
    {
        /// <summary>
        /// Optional.
        /// </summary>
        public readonly ImmutableArray<Outputs.ArgumentResponse> Arguments;
        /// <summary>
        /// The time when this routine was created, in milliseconds since the epoch.
        /// </summary>
        public readonly string CreationTime;
        /// <summary>
        /// The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, "\n", y))` The definition_body is `concat(x, "\n", y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'` The definition_body is `return "\n";\n` Note that both \n are replaced with linebreaks.
        /// </summary>
        public readonly string DefinitionBody;
        /// <summary>
        /// Optional. The description of the routine, if defined.
        /// </summary>
        public readonly string Description;
        /// <summary>
        /// Optional. The determinism level of the JavaScript UDF, if defined.
        /// </summary>
        public readonly string DeterminismLevel;
        /// <summary>
        /// A hash of this resource.
        /// </summary>
        public readonly string Etag;
        /// <summary>
        /// Optional. If language = "JAVASCRIPT", this field stores the path of the imported JAVASCRIPT libraries.
        /// </summary>
        public readonly ImmutableArray<string> ImportedLibraries;
        /// <summary>
        /// Optional. Defaults to "SQL".
        /// </summary>
        public readonly string Language;
        /// <summary>
        /// The time when this routine was last modified, in milliseconds since the epoch.
        /// </summary>
        public readonly string LastModifiedTime;
        /// <summary>
        /// Optional. Remote function specific options.
        /// </summary>
        public readonly Outputs.RemoteFunctionOptionsResponse RemoteFunctionOptions;
        /// <summary>
        /// Optional. Can be set only if routine_type = "TABLE_VALUED_FUNCTION". If absent, the return table type is inferred from definition_body at query time in each query that references this routine. If present, then the columns in the evaluated table result will be cast to match the column types specificed in return table type, at query time.
        /// </summary>
        public readonly Outputs.StandardSqlTableTypeResponse ReturnTableType;
        /// <summary>
        /// Optional if language = "SQL"; required otherwise. Cannot be set if routine_type = "TABLE_VALUED_FUNCTION". If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: "FLOAT64"}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
        /// </summary>
        public readonly Outputs.StandardSqlDataTypeResponse ReturnType;
        /// <summary>
        /// Reference describing the ID of this routine.
        /// </summary>
        public readonly Outputs.RoutineReferenceResponse RoutineReference;
        /// <summary>
        /// The type of routine.
        /// </summary>
        public readonly string RoutineType;
        /// <summary>
        /// Optional. Can be set for procedures only. If true (default), the definition body will be validated in the creation and the updates of the procedure. For procedures with an argument of ANY TYPE, the definition body validtion is not supported at creation/update time, and thus this field must be set to false explicitly.
        /// </summary>
        public readonly bool StrictMode;

        [OutputConstructor]
        private GetRoutineResult(
            ImmutableArray<Outputs.ArgumentResponse> arguments,

            string creationTime,

            string definitionBody,

            string description,

            string determinismLevel,

            string etag,

            ImmutableArray<string> importedLibraries,

            string language,

            string lastModifiedTime,

            Outputs.RemoteFunctionOptionsResponse remoteFunctionOptions,

            Outputs.StandardSqlTableTypeResponse returnTableType,

            Outputs.StandardSqlDataTypeResponse returnType,

            Outputs.RoutineReferenceResponse routineReference,

            string routineType,

            bool strictMode)
        {
            Arguments = arguments;
            CreationTime = creationTime;
            DefinitionBody = definitionBody;
            Description = description;
            DeterminismLevel = determinismLevel;
            Etag = etag;
            ImportedLibraries = importedLibraries;
            Language = language;
            LastModifiedTime = lastModifiedTime;
            RemoteFunctionOptions = remoteFunctionOptions;
            ReturnTableType = returnTableType;
            ReturnType = returnType;
            RoutineReference = routineReference;
            RoutineType = routineType;
            StrictMode = strictMode;
        }
    }
}

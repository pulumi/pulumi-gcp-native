// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Transcoder.V1
{
    /// <summary>
    /// Required. Type of fade animation: `FADE_IN` or `FADE_OUT`.
    /// </summary>
    [EnumType]
    public readonly struct AnimationFadeFadeType : IEquatable<AnimationFadeFadeType>
    {
        private readonly string _value;

        private AnimationFadeFadeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The fade type is not specified.
        /// </summary>
        public static AnimationFadeFadeType FadeTypeUnspecified { get; } = new AnimationFadeFadeType("FADE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Fade the overlay object into view.
        /// </summary>
        public static AnimationFadeFadeType FadeIn { get; } = new AnimationFadeFadeType("FADE_IN");
        /// <summary>
        /// Fade the overlay object out of view.
        /// </summary>
        public static AnimationFadeFadeType FadeOut { get; } = new AnimationFadeFadeType("FADE_OUT");

        public static bool operator ==(AnimationFadeFadeType left, AnimationFadeFadeType right) => left.Equals(right);
        public static bool operator !=(AnimationFadeFadeType left, AnimationFadeFadeType right) => !left.Equals(right);

        public static explicit operator string(AnimationFadeFadeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AnimationFadeFadeType other && Equals(other);
        public bool Equals(AnimationFadeFadeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The segment reference scheme for a `DASH` manifest. The default is `SEGMENT_LIST`.
    /// </summary>
    [EnumType]
    public readonly struct DashConfigSegmentReferenceScheme : IEquatable<DashConfigSegmentReferenceScheme>
    {
        private readonly string _value;

        private DashConfigSegmentReferenceScheme(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The segment reference scheme is not specified.
        /// </summary>
        public static DashConfigSegmentReferenceScheme SegmentReferenceSchemeUnspecified { get; } = new DashConfigSegmentReferenceScheme("SEGMENT_REFERENCE_SCHEME_UNSPECIFIED");
        /// <summary>
        /// Explicitly lists the URLs of media files for each segment. For example, if SegmentSettings.individual_segments is `true`, then the manifest contains fields similar to the following: ```xml ... ```
        /// </summary>
        public static DashConfigSegmentReferenceScheme SegmentList { get; } = new DashConfigSegmentReferenceScheme("SEGMENT_LIST");
        /// <summary>
        /// SegmentSettings.individual_segments must be set to `true` to use this segment reference scheme. Uses the DASH specification `` tag to determine the URLs of media files for each segment. For example: ```xml ... ```
        /// </summary>
        public static DashConfigSegmentReferenceScheme SegmentTemplateNumber { get; } = new DashConfigSegmentReferenceScheme("SEGMENT_TEMPLATE_NUMBER");

        public static bool operator ==(DashConfigSegmentReferenceScheme left, DashConfigSegmentReferenceScheme right) => left.Equals(right);
        public static bool operator !=(DashConfigSegmentReferenceScheme left, DashConfigSegmentReferenceScheme right) => !left.Equals(right);

        public static explicit operator string(DashConfigSegmentReferenceScheme value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DashConfigSegmentReferenceScheme other && Equals(other);
        public bool Equals(DashConfigSegmentReferenceScheme other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The processing mode of the job. The default is `PROCESSING_MODE_INTERACTIVE`.
    /// </summary>
    [EnumType]
    public readonly struct JobMode : IEquatable<JobMode>
    {
        private readonly string _value;

        private JobMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The job processing mode is not specified.
        /// </summary>
        public static JobMode ProcessingModeUnspecified { get; } = new JobMode("PROCESSING_MODE_UNSPECIFIED");
        /// <summary>
        /// The job processing mode is interactive mode. Interactive job will either be ran or rejected if quota does not allow for it.
        /// </summary>
        public static JobMode ProcessingModeInteractive { get; } = new JobMode("PROCESSING_MODE_INTERACTIVE");
        /// <summary>
        /// The job processing mode is batch mode. Batch mode allows queuing of jobs.
        /// </summary>
        public static JobMode ProcessingModeBatch { get; } = new JobMode("PROCESSING_MODE_BATCH");

        public static bool operator ==(JobMode left, JobMode right) => left.Equals(right);
        public static bool operator !=(JobMode left, JobMode right) => !left.Equals(right);

        public static explicit operator string(JobMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobMode other && Equals(other);
        public bool Equals(JobMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The optimization strategy of the job. The default is `AUTODETECT`.
    /// </summary>
    [EnumType]
    public readonly struct JobOptimization : IEquatable<JobOptimization>
    {
        private readonly string _value;

        private JobOptimization(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The optimization strategy is not specified.
        /// </summary>
        public static JobOptimization OptimizationStrategyUnspecified { get; } = new JobOptimization("OPTIMIZATION_STRATEGY_UNSPECIFIED");
        /// <summary>
        /// Prioritize job processing speed.
        /// </summary>
        public static JobOptimization Autodetect { get; } = new JobOptimization("AUTODETECT");
        /// <summary>
        /// Disable all optimizations.
        /// </summary>
        public static JobOptimization Disabled { get; } = new JobOptimization("DISABLED");

        public static bool operator ==(JobOptimization left, JobOptimization right) => left.Equals(right);
        public static bool operator !=(JobOptimization left, JobOptimization right) => !left.Equals(right);

        public static explicit operator string(JobOptimization value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JobOptimization other && Equals(other);
        public bool Equals(JobOptimization other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Type of the manifest.
    /// </summary>
    [EnumType]
    public readonly struct ManifestType : IEquatable<ManifestType>
    {
        private readonly string _value;

        private ManifestType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The manifest type is not specified.
        /// </summary>
        public static ManifestType ManifestTypeUnspecified { get; } = new ManifestType("MANIFEST_TYPE_UNSPECIFIED");
        /// <summary>
        /// Create an HLS manifest. The corresponding file extension is `.m3u8`.
        /// </summary>
        public static ManifestType Hls { get; } = new ManifestType("HLS");
        /// <summary>
        /// Create an MPEG-DASH manifest. The corresponding file extension is `.mpd`.
        /// </summary>
        public static ManifestType Dash { get; } = new ManifestType("DASH");

        public static bool operator ==(ManifestType left, ManifestType right) => left.Equals(right);
        public static bool operator !=(ManifestType left, ManifestType right) => !left.Equals(right);

        public static explicit operator string(ManifestType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ManifestType other && Equals(other);
        public bool Equals(ManifestType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

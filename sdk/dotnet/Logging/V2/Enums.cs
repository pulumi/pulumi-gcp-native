// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Logging.V2
{
    /// <summary>
    /// Deprecated. This field is unused.
    /// </summary>
    [EnumType]
    public readonly struct BillingAccountSinkOutputVersionFormat : IEquatable<BillingAccountSinkOutputVersionFormat>
    {
        private readonly string _value;

        private BillingAccountSinkOutputVersionFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// An unspecified format version that will default to V2.
        /// </summary>
        public static BillingAccountSinkOutputVersionFormat VersionFormatUnspecified { get; } = new BillingAccountSinkOutputVersionFormat("VERSION_FORMAT_UNSPECIFIED");
        /// <summary>
        /// LogEntry version 2 format.
        /// </summary>
        public static BillingAccountSinkOutputVersionFormat V2 { get; } = new BillingAccountSinkOutputVersionFormat("V2");
        /// <summary>
        /// LogEntry version 1 format.
        /// </summary>
        public static BillingAccountSinkOutputVersionFormat V1 { get; } = new BillingAccountSinkOutputVersionFormat("V1");

        public static bool operator ==(BillingAccountSinkOutputVersionFormat left, BillingAccountSinkOutputVersionFormat right) => left.Equals(right);
        public static bool operator !=(BillingAccountSinkOutputVersionFormat left, BillingAccountSinkOutputVersionFormat right) => !left.Equals(right);

        public static explicit operator string(BillingAccountSinkOutputVersionFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BillingAccountSinkOutputVersionFormat other && Equals(other);
        public bool Equals(BillingAccountSinkOutputVersionFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Deprecated. This field is unused.
    /// </summary>
    [EnumType]
    public readonly struct FolderSinkOutputVersionFormat : IEquatable<FolderSinkOutputVersionFormat>
    {
        private readonly string _value;

        private FolderSinkOutputVersionFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// An unspecified format version that will default to V2.
        /// </summary>
        public static FolderSinkOutputVersionFormat VersionFormatUnspecified { get; } = new FolderSinkOutputVersionFormat("VERSION_FORMAT_UNSPECIFIED");
        /// <summary>
        /// LogEntry version 2 format.
        /// </summary>
        public static FolderSinkOutputVersionFormat V2 { get; } = new FolderSinkOutputVersionFormat("V2");
        /// <summary>
        /// LogEntry version 1 format.
        /// </summary>
        public static FolderSinkOutputVersionFormat V1 { get; } = new FolderSinkOutputVersionFormat("V1");

        public static bool operator ==(FolderSinkOutputVersionFormat left, FolderSinkOutputVersionFormat right) => left.Equals(right);
        public static bool operator !=(FolderSinkOutputVersionFormat left, FolderSinkOutputVersionFormat right) => !left.Equals(right);

        public static explicit operator string(FolderSinkOutputVersionFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FolderSinkOutputVersionFormat other && Equals(other);
        public bool Equals(FolderSinkOutputVersionFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The type of data in this index.
    /// </summary>
    [EnumType]
    public readonly struct IndexConfigType : IEquatable<IndexConfigType>
    {
        private readonly string _value;

        private IndexConfigType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The index's type is unspecified.
        /// </summary>
        public static IndexConfigType IndexTypeUnspecified { get; } = new IndexConfigType("INDEX_TYPE_UNSPECIFIED");
        /// <summary>
        /// The index is a string-type index.
        /// </summary>
        public static IndexConfigType IndexTypeString { get; } = new IndexConfigType("INDEX_TYPE_STRING");
        /// <summary>
        /// The index is a integer-type index.
        /// </summary>
        public static IndexConfigType IndexTypeInteger { get; } = new IndexConfigType("INDEX_TYPE_INTEGER");

        public static bool operator ==(IndexConfigType left, IndexConfigType right) => left.Equals(right);
        public static bool operator !=(IndexConfigType left, IndexConfigType right) => !left.Equals(right);

        public static explicit operator string(IndexConfigType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IndexConfigType other && Equals(other);
        public bool Equals(IndexConfigType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of data that can be assigned to the label.
    /// </summary>
    [EnumType]
    public readonly struct LabelDescriptorValueType : IEquatable<LabelDescriptorValueType>
    {
        private readonly string _value;

        private LabelDescriptorValueType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// A variable-length string. This is the default.
        /// </summary>
        public static LabelDescriptorValueType String { get; } = new LabelDescriptorValueType("STRING");
        /// <summary>
        /// Boolean; true or false.
        /// </summary>
        public static LabelDescriptorValueType Bool { get; } = new LabelDescriptorValueType("BOOL");
        /// <summary>
        /// A 64-bit signed integer.
        /// </summary>
        public static LabelDescriptorValueType Int64 { get; } = new LabelDescriptorValueType("INT64");

        public static bool operator ==(LabelDescriptorValueType left, LabelDescriptorValueType right) => left.Equals(right);
        public static bool operator !=(LabelDescriptorValueType left, LabelDescriptorValueType right) => !left.Equals(right);

        public static explicit operator string(LabelDescriptorValueType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LabelDescriptorValueType other && Equals(other);
        public bool Equals(LabelDescriptorValueType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The launch stage of the metric definition.
    /// </summary>
    [EnumType]
    public readonly struct MetricDescriptorLaunchStage : IEquatable<MetricDescriptorLaunchStage>
    {
        private readonly string _value;

        private MetricDescriptorLaunchStage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use this default value.
        /// </summary>
        public static MetricDescriptorLaunchStage LaunchStageUnspecified { get; } = new MetricDescriptorLaunchStage("LAUNCH_STAGE_UNSPECIFIED");
        /// <summary>
        /// The feature is not yet implemented. Users can not use it.
        /// </summary>
        public static MetricDescriptorLaunchStage Unimplemented { get; } = new MetricDescriptorLaunchStage("UNIMPLEMENTED");
        /// <summary>
        /// Prelaunch features are hidden from users and are only visible internally.
        /// </summary>
        public static MetricDescriptorLaunchStage Prelaunch { get; } = new MetricDescriptorLaunchStage("PRELAUNCH");
        /// <summary>
        /// Early Access features are limited to a closed group of testers. To use these features, you must sign up in advance and sign a Trusted Tester agreement (which includes confidentiality provisions). These features may be unstable, changed in backward-incompatible ways, and are not guaranteed to be released.
        /// </summary>
        public static MetricDescriptorLaunchStage EarlyAccess { get; } = new MetricDescriptorLaunchStage("EARLY_ACCESS");
        /// <summary>
        /// Alpha is a limited availability test for releases before they are cleared for widespread use. By Alpha, all significant design issues are resolved and we are in the process of verifying functionality. Alpha customers need to apply for access, agree to applicable terms, and have their projects allowlisted. Alpha releases don't have to be feature complete, no SLAs are provided, and there are no technical support obligations, but they will be far enough along that customers can actually use them in test environments or for limited-use tests -- just like they would in normal production cases.
        /// </summary>
        public static MetricDescriptorLaunchStage Alpha { get; } = new MetricDescriptorLaunchStage("ALPHA");
        /// <summary>
        /// Beta is the point at which we are ready to open a release for any customer to use. There are no SLA or technical support obligations in a Beta release. Products will be complete from a feature perspective, but may have some open outstanding issues. Beta releases are suitable for limited production use cases.
        /// </summary>
        public static MetricDescriptorLaunchStage Beta { get; } = new MetricDescriptorLaunchStage("BETA");
        /// <summary>
        /// GA features are open to all developers and are considered stable and fully qualified for production use.
        /// </summary>
        public static MetricDescriptorLaunchStage Ga { get; } = new MetricDescriptorLaunchStage("GA");
        /// <summary>
        /// Deprecated features are scheduled to be shut down and removed. For more information, see the "Deprecation Policy" section of our Terms of Service (https://cloud.google.com/terms/) and the Google Cloud Platform Subject to the Deprecation Policy (https://cloud.google.com/terms/deprecation) documentation.
        /// </summary>
        public static MetricDescriptorLaunchStage Deprecated { get; } = new MetricDescriptorLaunchStage("DEPRECATED");

        public static bool operator ==(MetricDescriptorLaunchStage left, MetricDescriptorLaunchStage right) => left.Equals(right);
        public static bool operator !=(MetricDescriptorLaunchStage left, MetricDescriptorLaunchStage right) => !left.Equals(right);

        public static explicit operator string(MetricDescriptorLaunchStage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricDescriptorLaunchStage other && Equals(other);
        public bool Equals(MetricDescriptorLaunchStage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Deprecated. Must use the MetricDescriptor.launch_stage instead.
    /// </summary>
    [EnumType]
    public readonly struct MetricDescriptorMetadataLaunchStage : IEquatable<MetricDescriptorMetadataLaunchStage>
    {
        private readonly string _value;

        private MetricDescriptorMetadataLaunchStage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use this default value.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage LaunchStageUnspecified { get; } = new MetricDescriptorMetadataLaunchStage("LAUNCH_STAGE_UNSPECIFIED");
        /// <summary>
        /// The feature is not yet implemented. Users can not use it.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage Unimplemented { get; } = new MetricDescriptorMetadataLaunchStage("UNIMPLEMENTED");
        /// <summary>
        /// Prelaunch features are hidden from users and are only visible internally.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage Prelaunch { get; } = new MetricDescriptorMetadataLaunchStage("PRELAUNCH");
        /// <summary>
        /// Early Access features are limited to a closed group of testers. To use these features, you must sign up in advance and sign a Trusted Tester agreement (which includes confidentiality provisions). These features may be unstable, changed in backward-incompatible ways, and are not guaranteed to be released.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage EarlyAccess { get; } = new MetricDescriptorMetadataLaunchStage("EARLY_ACCESS");
        /// <summary>
        /// Alpha is a limited availability test for releases before they are cleared for widespread use. By Alpha, all significant design issues are resolved and we are in the process of verifying functionality. Alpha customers need to apply for access, agree to applicable terms, and have their projects allowlisted. Alpha releases don't have to be feature complete, no SLAs are provided, and there are no technical support obligations, but they will be far enough along that customers can actually use them in test environments or for limited-use tests -- just like they would in normal production cases.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage Alpha { get; } = new MetricDescriptorMetadataLaunchStage("ALPHA");
        /// <summary>
        /// Beta is the point at which we are ready to open a release for any customer to use. There are no SLA or technical support obligations in a Beta release. Products will be complete from a feature perspective, but may have some open outstanding issues. Beta releases are suitable for limited production use cases.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage Beta { get; } = new MetricDescriptorMetadataLaunchStage("BETA");
        /// <summary>
        /// GA features are open to all developers and are considered stable and fully qualified for production use.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage Ga { get; } = new MetricDescriptorMetadataLaunchStage("GA");
        /// <summary>
        /// Deprecated features are scheduled to be shut down and removed. For more information, see the "Deprecation Policy" section of our Terms of Service (https://cloud.google.com/terms/) and the Google Cloud Platform Subject to the Deprecation Policy (https://cloud.google.com/terms/deprecation) documentation.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage Deprecated { get; } = new MetricDescriptorMetadataLaunchStage("DEPRECATED");

        public static bool operator ==(MetricDescriptorMetadataLaunchStage left, MetricDescriptorMetadataLaunchStage right) => left.Equals(right);
        public static bool operator !=(MetricDescriptorMetadataLaunchStage left, MetricDescriptorMetadataLaunchStage right) => !left.Equals(right);

        public static explicit operator string(MetricDescriptorMetadataLaunchStage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricDescriptorMetadataLaunchStage other && Equals(other);
        public bool Equals(MetricDescriptorMetadataLaunchStage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the metric records instantaneous values, changes to a value, etc. Some combinations of metric_kind and value_type might not be supported.
    /// </summary>
    [EnumType]
    public readonly struct MetricDescriptorMetricKind : IEquatable<MetricDescriptorMetricKind>
    {
        private readonly string _value;

        private MetricDescriptorMetricKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use this default value.
        /// </summary>
        public static MetricDescriptorMetricKind MetricKindUnspecified { get; } = new MetricDescriptorMetricKind("METRIC_KIND_UNSPECIFIED");
        /// <summary>
        /// An instantaneous measurement of a value.
        /// </summary>
        public static MetricDescriptorMetricKind Gauge { get; } = new MetricDescriptorMetricKind("GAUGE");
        /// <summary>
        /// The change in a value during a time interval.
        /// </summary>
        public static MetricDescriptorMetricKind Delta { get; } = new MetricDescriptorMetricKind("DELTA");
        /// <summary>
        /// A value accumulated over a time interval. Cumulative measurements in a time series should have the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points.
        /// </summary>
        public static MetricDescriptorMetricKind Cumulative { get; } = new MetricDescriptorMetricKind("CUMULATIVE");

        public static bool operator ==(MetricDescriptorMetricKind left, MetricDescriptorMetricKind right) => left.Equals(right);
        public static bool operator !=(MetricDescriptorMetricKind left, MetricDescriptorMetricKind right) => !left.Equals(right);

        public static explicit operator string(MetricDescriptorMetricKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricDescriptorMetricKind other && Equals(other);
        public bool Equals(MetricDescriptorMetricKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the measurement is an integer, a floating-point number, etc. Some combinations of metric_kind and value_type might not be supported.
    /// </summary>
    [EnumType]
    public readonly struct MetricDescriptorValueType : IEquatable<MetricDescriptorValueType>
    {
        private readonly string _value;

        private MetricDescriptorValueType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use this default value.
        /// </summary>
        public static MetricDescriptorValueType ValueTypeUnspecified { get; } = new MetricDescriptorValueType("VALUE_TYPE_UNSPECIFIED");
        /// <summary>
        /// The value is a boolean. This value type can be used only if the metric kind is GAUGE.
        /// </summary>
        public static MetricDescriptorValueType Bool { get; } = new MetricDescriptorValueType("BOOL");
        /// <summary>
        /// The value is a signed 64-bit integer.
        /// </summary>
        public static MetricDescriptorValueType Int64 { get; } = new MetricDescriptorValueType("INT64");
        /// <summary>
        /// The value is a double precision floating point number.
        /// </summary>
        public static MetricDescriptorValueType Double { get; } = new MetricDescriptorValueType("DOUBLE");
        /// <summary>
        /// The value is a text string. This value type can be used only if the metric kind is GAUGE.
        /// </summary>
        public static MetricDescriptorValueType String { get; } = new MetricDescriptorValueType("STRING");
        /// <summary>
        /// The value is a Distribution.
        /// </summary>
        public static MetricDescriptorValueType Distribution { get; } = new MetricDescriptorValueType("DISTRIBUTION");
        /// <summary>
        /// The value is money.
        /// </summary>
        public static MetricDescriptorValueType Money { get; } = new MetricDescriptorValueType("MONEY");

        public static bool operator ==(MetricDescriptorValueType left, MetricDescriptorValueType right) => left.Equals(right);
        public static bool operator !=(MetricDescriptorValueType left, MetricDescriptorValueType right) => !left.Equals(right);

        public static explicit operator string(MetricDescriptorValueType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricDescriptorValueType other && Equals(other);
        public bool Equals(MetricDescriptorValueType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Deprecated. The API version that created or updated this metric. The v2 format is used by default and cannot be changed.
    /// </summary>
    [EnumType]
    public readonly struct MetricVersion : IEquatable<MetricVersion>
    {
        private readonly string _value;

        private MetricVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Logging API v2.
        /// </summary>
        public static MetricVersion V2 { get; } = new MetricVersion("V2");
        /// <summary>
        /// Logging API v1.
        /// </summary>
        public static MetricVersion V1 { get; } = new MetricVersion("V1");

        public static bool operator ==(MetricVersion left, MetricVersion right) => left.Equals(right);
        public static bool operator !=(MetricVersion left, MetricVersion right) => !left.Equals(right);

        public static explicit operator string(MetricVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricVersion other && Equals(other);
        public bool Equals(MetricVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Deprecated. This field is unused.
    /// </summary>
    [EnumType]
    public readonly struct OrganizationSinkOutputVersionFormat : IEquatable<OrganizationSinkOutputVersionFormat>
    {
        private readonly string _value;

        private OrganizationSinkOutputVersionFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// An unspecified format version that will default to V2.
        /// </summary>
        public static OrganizationSinkOutputVersionFormat VersionFormatUnspecified { get; } = new OrganizationSinkOutputVersionFormat("VERSION_FORMAT_UNSPECIFIED");
        /// <summary>
        /// LogEntry version 2 format.
        /// </summary>
        public static OrganizationSinkOutputVersionFormat V2 { get; } = new OrganizationSinkOutputVersionFormat("V2");
        /// <summary>
        /// LogEntry version 1 format.
        /// </summary>
        public static OrganizationSinkOutputVersionFormat V1 { get; } = new OrganizationSinkOutputVersionFormat("V1");

        public static bool operator ==(OrganizationSinkOutputVersionFormat left, OrganizationSinkOutputVersionFormat right) => left.Equals(right);
        public static bool operator !=(OrganizationSinkOutputVersionFormat left, OrganizationSinkOutputVersionFormat right) => !left.Equals(right);

        public static explicit operator string(OrganizationSinkOutputVersionFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OrganizationSinkOutputVersionFormat other && Equals(other);
        public bool Equals(OrganizationSinkOutputVersionFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Deprecated. This field is unused.
    /// </summary>
    [EnumType]
    public readonly struct SinkOutputVersionFormat : IEquatable<SinkOutputVersionFormat>
    {
        private readonly string _value;

        private SinkOutputVersionFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// An unspecified format version that will default to V2.
        /// </summary>
        public static SinkOutputVersionFormat VersionFormatUnspecified { get; } = new SinkOutputVersionFormat("VERSION_FORMAT_UNSPECIFIED");
        /// <summary>
        /// LogEntry version 2 format.
        /// </summary>
        public static SinkOutputVersionFormat V2 { get; } = new SinkOutputVersionFormat("V2");
        /// <summary>
        /// LogEntry version 1 format.
        /// </summary>
        public static SinkOutputVersionFormat V1 { get; } = new SinkOutputVersionFormat("V1");

        public static bool operator ==(SinkOutputVersionFormat left, SinkOutputVersionFormat right) => left.Equals(right);
        public static bool operator !=(SinkOutputVersionFormat left, SinkOutputVersionFormat right) => !left.Equals(right);

        public static explicit operator string(SinkOutputVersionFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SinkOutputVersionFormat other && Equals(other);
        public bool Equals(SinkOutputVersionFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

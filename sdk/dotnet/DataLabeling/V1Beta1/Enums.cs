// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.DataLabeling.V1Beta1
{
    /// <summary>
    /// Output only. Describes the current state of the job.
    /// </summary>
    [EnumType]
    public readonly struct EvaluationJobState : IEquatable<EvaluationJobState>
    {
        private readonly string _value;

        private EvaluationJobState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EvaluationJobState StateUnspecified { get; } = new EvaluationJobState("STATE_UNSPECIFIED");
        /// <summary>
        /// The job is scheduled to run at the configured interval. You can pause or delete the job. When the job is in this state, it samples prediction input and output from your model version into your BigQuery table as predictions occur.
        /// </summary>
        public static EvaluationJobState Scheduled { get; } = new EvaluationJobState("SCHEDULED");
        /// <summary>
        /// The job is currently running. When the job runs, Data Labeling Service does several things: 1. If you have configured your job to use Data Labeling Service for ground truth labeling, the service creates a Dataset and a labeling task for all data sampled since the last time the job ran. Human labelers provide ground truth labels for your data. Human labeling may take hours, or even days, depending on how much data has been sampled. The job remains in the `RUNNING` state during this time, and it can even be running multiple times in parallel if it gets triggered again (for example 24 hours later) before the earlier run has completed. When human labelers have finished labeling the data, the next step occurs. If you have configured your job to provide your own ground truth labels, Data Labeling Service still creates a Dataset for newly sampled data, but it expects that you have already added ground truth labels to the BigQuery table by this time. The next step occurs immediately. 2. Data Labeling Service creates an Evaluation by comparing your model version's predictions with the ground truth labels. If the job remains in this state for a long time, it continues to sample prediction data into your BigQuery table and will run again at the next interval, even if it causes the job to run multiple times in parallel.
        /// </summary>
        public static EvaluationJobState Running { get; } = new EvaluationJobState("RUNNING");
        /// <summary>
        /// The job is not sampling prediction input and output into your BigQuery table and it will not run according to its schedule. You can resume the job.
        /// </summary>
        public static EvaluationJobState Paused { get; } = new EvaluationJobState("PAUSED");
        /// <summary>
        /// The job has this state right before it is deleted.
        /// </summary>
        public static EvaluationJobState Stopped { get; } = new EvaluationJobState("STOPPED");

        public static bool operator ==(EvaluationJobState left, EvaluationJobState right) => left.Equals(right);
        public static bool operator !=(EvaluationJobState left, EvaluationJobState right) => !left.Equals(right);

        public static explicit operator string(EvaluationJobState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EvaluationJobState other && Equals(other);
        public bool Equals(EvaluationJobState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The type of how to aggregate answers.
    /// </summary>
    [EnumType]
    public readonly struct GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType : IEquatable<GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType>
    {
        private readonly string _value;

        private GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType StringAggregationTypeUnspecified { get; } = new GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType("STRING_AGGREGATION_TYPE_UNSPECIFIED");
        /// <summary>
        /// Majority vote to aggregate answers.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType MajorityVote { get; } = new GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType("MAJORITY_VOTE");
        /// <summary>
        /// Unanimous answers will be adopted.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType UnanimousVote { get; } = new GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType("UNANIMOUS_VOTE");
        /// <summary>
        /// Preserve all answers by crowd compute.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType NoAggregation { get; } = new GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType("NO_AGGREGATION");

        public static bool operator ==(GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType left, GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType right) => left.Equals(right);
        public static bool operator !=(GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType left, GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType right) => !left.Equals(right);

        public static explicit operator string(GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType other && Equals(other);
        public bool Equals(GoogleCloudDatalabelingV1beta1ImageClassificationConfigAnswerAggregationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The type of annotation to be performed on this data. You must specify this field if you are using this InputConfig in an EvaluationJob.
    /// </summary>
    [EnumType]
    public readonly struct GoogleCloudDatalabelingV1beta1InputConfigAnnotationType : IEquatable<GoogleCloudDatalabelingV1beta1InputConfigAnnotationType>
    {
        private readonly string _value;

        private GoogleCloudDatalabelingV1beta1InputConfigAnnotationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GoogleCloudDatalabelingV1beta1InputConfigAnnotationType AnnotationTypeUnspecified { get; } = new GoogleCloudDatalabelingV1beta1InputConfigAnnotationType("ANNOTATION_TYPE_UNSPECIFIED");
        /// <summary>
        /// Classification annotations in an image. Allowed for continuous evaluation.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigAnnotationType ImageClassificationAnnotation { get; } = new GoogleCloudDatalabelingV1beta1InputConfigAnnotationType("IMAGE_CLASSIFICATION_ANNOTATION");
        /// <summary>
        /// Bounding box annotations in an image. A form of image object detection. Allowed for continuous evaluation.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigAnnotationType ImageBoundingBoxAnnotation { get; } = new GoogleCloudDatalabelingV1beta1InputConfigAnnotationType("IMAGE_BOUNDING_BOX_ANNOTATION");
        /// <summary>
        /// Oriented bounding box. The box does not have to be parallel to horizontal line.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigAnnotationType ImageOrientedBoundingBoxAnnotation { get; } = new GoogleCloudDatalabelingV1beta1InputConfigAnnotationType("IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION");
        /// <summary>
        /// Bounding poly annotations in an image.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigAnnotationType ImageBoundingPolyAnnotation { get; } = new GoogleCloudDatalabelingV1beta1InputConfigAnnotationType("IMAGE_BOUNDING_POLY_ANNOTATION");
        /// <summary>
        /// Polyline annotations in an image.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigAnnotationType ImagePolylineAnnotation { get; } = new GoogleCloudDatalabelingV1beta1InputConfigAnnotationType("IMAGE_POLYLINE_ANNOTATION");
        /// <summary>
        /// Segmentation annotations in an image.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigAnnotationType ImageSegmentationAnnotation { get; } = new GoogleCloudDatalabelingV1beta1InputConfigAnnotationType("IMAGE_SEGMENTATION_ANNOTATION");
        /// <summary>
        /// Classification annotations in video shots.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigAnnotationType VideoShotsClassificationAnnotation { get; } = new GoogleCloudDatalabelingV1beta1InputConfigAnnotationType("VIDEO_SHOTS_CLASSIFICATION_ANNOTATION");
        /// <summary>
        /// Video object tracking annotation.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigAnnotationType VideoObjectTrackingAnnotation { get; } = new GoogleCloudDatalabelingV1beta1InputConfigAnnotationType("VIDEO_OBJECT_TRACKING_ANNOTATION");
        /// <summary>
        /// Video object detection annotation.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigAnnotationType VideoObjectDetectionAnnotation { get; } = new GoogleCloudDatalabelingV1beta1InputConfigAnnotationType("VIDEO_OBJECT_DETECTION_ANNOTATION");
        /// <summary>
        /// Video event annotation.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigAnnotationType VideoEventAnnotation { get; } = new GoogleCloudDatalabelingV1beta1InputConfigAnnotationType("VIDEO_EVENT_ANNOTATION");
        /// <summary>
        /// Classification for text. Allowed for continuous evaluation.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigAnnotationType TextClassificationAnnotation { get; } = new GoogleCloudDatalabelingV1beta1InputConfigAnnotationType("TEXT_CLASSIFICATION_ANNOTATION");
        /// <summary>
        /// Entity extraction for text.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigAnnotationType TextEntityExtractionAnnotation { get; } = new GoogleCloudDatalabelingV1beta1InputConfigAnnotationType("TEXT_ENTITY_EXTRACTION_ANNOTATION");
        /// <summary>
        /// General classification. Allowed for continuous evaluation.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigAnnotationType GeneralClassificationAnnotation { get; } = new GoogleCloudDatalabelingV1beta1InputConfigAnnotationType("GENERAL_CLASSIFICATION_ANNOTATION");

        public static bool operator ==(GoogleCloudDatalabelingV1beta1InputConfigAnnotationType left, GoogleCloudDatalabelingV1beta1InputConfigAnnotationType right) => left.Equals(right);
        public static bool operator !=(GoogleCloudDatalabelingV1beta1InputConfigAnnotationType left, GoogleCloudDatalabelingV1beta1InputConfigAnnotationType right) => !left.Equals(right);

        public static explicit operator string(GoogleCloudDatalabelingV1beta1InputConfigAnnotationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GoogleCloudDatalabelingV1beta1InputConfigAnnotationType other && Equals(other);
        public bool Equals(GoogleCloudDatalabelingV1beta1InputConfigAnnotationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Data type must be specifed when user tries to import data.
    /// </summary>
    [EnumType]
    public readonly struct GoogleCloudDatalabelingV1beta1InputConfigDataType : IEquatable<GoogleCloudDatalabelingV1beta1InputConfigDataType>
    {
        private readonly string _value;

        private GoogleCloudDatalabelingV1beta1InputConfigDataType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Data type is unspecified.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigDataType DataTypeUnspecified { get; } = new GoogleCloudDatalabelingV1beta1InputConfigDataType("DATA_TYPE_UNSPECIFIED");
        /// <summary>
        /// Allowed for continuous evaluation.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigDataType Image { get; } = new GoogleCloudDatalabelingV1beta1InputConfigDataType("IMAGE");
        /// <summary>
        /// Video data type.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigDataType Video { get; } = new GoogleCloudDatalabelingV1beta1InputConfigDataType("VIDEO");
        /// <summary>
        /// Allowed for continuous evaluation.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigDataType Text { get; } = new GoogleCloudDatalabelingV1beta1InputConfigDataType("TEXT");
        /// <summary>
        /// Allowed for continuous evaluation.
        /// </summary>
        public static GoogleCloudDatalabelingV1beta1InputConfigDataType GeneralData { get; } = new GoogleCloudDatalabelingV1beta1InputConfigDataType("GENERAL_DATA");

        public static bool operator ==(GoogleCloudDatalabelingV1beta1InputConfigDataType left, GoogleCloudDatalabelingV1beta1InputConfigDataType right) => left.Equals(right);
        public static bool operator !=(GoogleCloudDatalabelingV1beta1InputConfigDataType left, GoogleCloudDatalabelingV1beta1InputConfigDataType right) => !left.Equals(right);

        public static explicit operator string(GoogleCloudDatalabelingV1beta1InputConfigDataType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GoogleCloudDatalabelingV1beta1InputConfigDataType other && Equals(other);
        public bool Equals(GoogleCloudDatalabelingV1beta1InputConfigDataType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The data type of this instruction.
    /// </summary>
    [EnumType]
    public readonly struct InstructionDataType : IEquatable<InstructionDataType>
    {
        private readonly string _value;

        private InstructionDataType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Data type is unspecified.
        /// </summary>
        public static InstructionDataType DataTypeUnspecified { get; } = new InstructionDataType("DATA_TYPE_UNSPECIFIED");
        /// <summary>
        /// Allowed for continuous evaluation.
        /// </summary>
        public static InstructionDataType Image { get; } = new InstructionDataType("IMAGE");
        /// <summary>
        /// Video data type.
        /// </summary>
        public static InstructionDataType Video { get; } = new InstructionDataType("VIDEO");
        /// <summary>
        /// Allowed for continuous evaluation.
        /// </summary>
        public static InstructionDataType Text { get; } = new InstructionDataType("TEXT");
        /// <summary>
        /// Allowed for continuous evaluation.
        /// </summary>
        public static InstructionDataType GeneralData { get; } = new InstructionDataType("GENERAL_DATA");

        public static bool operator ==(InstructionDataType left, InstructionDataType right) => left.Equals(right);
        public static bool operator !=(InstructionDataType left, InstructionDataType right) => !left.Equals(right);

        public static explicit operator string(InstructionDataType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstructionDataType other && Equals(other);
        public bool Equals(InstructionDataType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

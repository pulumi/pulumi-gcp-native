// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.GoogleNative.DNS.V1Beta2.Inputs
{

    /// <summary>
    /// Configures a RRSetRoutingPolicy that routes based on the geo location of the querying user.
    /// </summary>
    public sealed class RRSetRoutingPolicyGeoPolicyArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Without fencing, if health check fails for all configured items in the current geo bucket, we'll failover to the next nearest geo bucket. With fencing, if health check is enabled, as long as some targets in the current geo bucket are healthy, we'll return only the healthy targets. However, if they're all unhealthy, we won't failover to the next nearest bucket, we'll simply return all the items in the current bucket even though they're unhealthy.
        /// </summary>
        [Input("enableFencing")]
        public Input<bool>? EnableFencing { get; set; }

        [Input("items")]
        private InputList<Inputs.RRSetRoutingPolicyGeoPolicyGeoPolicyItemArgs>? _items;

        /// <summary>
        /// The primary geo routing configuration. If there are multiple items with the same location, an error is returned instead.
        /// </summary>
        public InputList<Inputs.RRSetRoutingPolicyGeoPolicyGeoPolicyItemArgs> Items
        {
            get => _items ?? (_items = new InputList<Inputs.RRSetRoutingPolicyGeoPolicyGeoPolicyItemArgs>());
            set => _items = value;
        }

        [Input("kind")]
        public Input<string>? Kind { get; set; }

        public RRSetRoutingPolicyGeoPolicyArgs()
        {
        }
        public static new RRSetRoutingPolicyGeoPolicyArgs Empty => new RRSetRoutingPolicyGeoPolicyArgs();
    }
}

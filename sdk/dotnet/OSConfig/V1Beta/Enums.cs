// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.OSConfig.V1Beta
{
    /// <summary>
    /// Type of archive files in this repository. The default behavior is DEB.
    /// </summary>
    [EnumType]
    public readonly struct AptRepositoryArchiveType : IEquatable<AptRepositoryArchiveType>
    {
        private readonly string _value;

        private AptRepositoryArchiveType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified.
        /// </summary>
        public static AptRepositoryArchiveType ArchiveTypeUnspecified { get; } = new AptRepositoryArchiveType("ARCHIVE_TYPE_UNSPECIFIED");
        /// <summary>
        /// DEB indicates that the archive contains binary files.
        /// </summary>
        public static AptRepositoryArchiveType Deb { get; } = new AptRepositoryArchiveType("DEB");
        /// <summary>
        /// DEB_SRC indicates that the archive contains source files.
        /// </summary>
        public static AptRepositoryArchiveType DebSrc { get; } = new AptRepositoryArchiveType("DEB_SRC");

        public static bool operator ==(AptRepositoryArchiveType left, AptRepositoryArchiveType right) => left.Equals(right);
        public static bool operator !=(AptRepositoryArchiveType left, AptRepositoryArchiveType right) => !left.Equals(right);

        public static explicit operator string(AptRepositoryArchiveType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AptRepositoryArchiveType other && Equals(other);
        public bool Equals(AptRepositoryArchiveType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// By changing the type to DIST, the patching is performed using `apt-get dist-upgrade` instead.
    /// </summary>
    [EnumType]
    public readonly struct AptSettingsType : IEquatable<AptSettingsType>
    {
        private readonly string _value;

        private AptSettingsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// By default, upgrade will be performed.
        /// </summary>
        public static AptSettingsType TypeUnspecified { get; } = new AptSettingsType("TYPE_UNSPECIFIED");
        /// <summary>
        /// Runs `apt-get dist-upgrade`.
        /// </summary>
        public static AptSettingsType Dist { get; } = new AptSettingsType("DIST");
        /// <summary>
        /// Runs `apt-get upgrade`.
        /// </summary>
        public static AptSettingsType Upgrade { get; } = new AptSettingsType("UPGRADE");

        public static bool operator ==(AptSettingsType left, AptSettingsType right) => left.Equals(right);
        public static bool operator !=(AptSettingsType left, AptSettingsType right) => !left.Equals(right);

        public static explicit operator string(AptSettingsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AptSettingsType other && Equals(other);
        public bool Equals(AptSettingsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with [shebang lines] (https://en.wikipedia.org/wiki/Shebang_\(Unix\)).
    /// </summary>
    [EnumType]
    public readonly struct ExecStepConfigInterpreter : IEquatable<ExecStepConfigInterpreter>
    {
        private readonly string _value;

        private ExecStepConfigInterpreter(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// If the interpreter is not specified, the value defaults to `NONE`.
        /// </summary>
        public static ExecStepConfigInterpreter InterpreterUnspecified { get; } = new ExecStepConfigInterpreter("INTERPRETER_UNSPECIFIED");
        /// <summary>
        /// Indicates that the file is run as follows on each operating system: + For Linux VMs, the file is ran as an executable and the interpreter might be parsed from the [shebang line](https://wikipedia.org/wiki/Shebang_(Unix)) of the file. + For Windows VM, this value is not supported.
        /// </summary>
        public static ExecStepConfigInterpreter None { get; } = new ExecStepConfigInterpreter("NONE");
        /// <summary>
        /// Indicates that the file is run with `/bin/sh` on Linux and `cmd` on Windows.
        /// </summary>
        public static ExecStepConfigInterpreter Shell { get; } = new ExecStepConfigInterpreter("SHELL");
        /// <summary>
        /// Indicates that the file is run with PowerShell.
        /// </summary>
        public static ExecStepConfigInterpreter Powershell { get; } = new ExecStepConfigInterpreter("POWERSHELL");

        public static bool operator ==(ExecStepConfigInterpreter left, ExecStepConfigInterpreter right) => left.Equals(right);
        public static bool operator !=(ExecStepConfigInterpreter left, ExecStepConfigInterpreter right) => !left.Equals(right);

        public static explicit operator string(ExecStepConfigInterpreter value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExecStepConfigInterpreter other && Equals(other);
        public bool Equals(ExecStepConfigInterpreter other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired_state the agent should maintain for this package. The default is to ensure the package is installed.
    /// </summary>
    [EnumType]
    public readonly struct PackageDesiredState : IEquatable<PackageDesiredState>
    {
        private readonly string _value;

        private PackageDesiredState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default is to ensure the package is installed.
        /// </summary>
        public static PackageDesiredState DesiredStateUnspecified { get; } = new PackageDesiredState("DESIRED_STATE_UNSPECIFIED");
        /// <summary>
        /// The agent ensures that the package is installed.
        /// </summary>
        public static PackageDesiredState Installed { get; } = new PackageDesiredState("INSTALLED");
        /// <summary>
        /// The agent ensures that the package is installed and periodically checks for and install any updates.
        /// </summary>
        public static PackageDesiredState Updated { get; } = new PackageDesiredState("UPDATED");
        /// <summary>
        /// The agent ensures that the package is not installed and uninstall it if detected.
        /// </summary>
        public static PackageDesiredState Removed { get; } = new PackageDesiredState("REMOVED");

        public static bool operator ==(PackageDesiredState left, PackageDesiredState right) => left.Equals(right);
        public static bool operator !=(PackageDesiredState left, PackageDesiredState right) => !left.Equals(right);

        public static explicit operator string(PackageDesiredState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PackageDesiredState other && Equals(other);
        public bool Equals(PackageDesiredState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of package manager that can be used to install this package. If a system does not have the package manager, the package is not installed or removed no error message is returned. By default, or if you specify `ANY`, the agent attempts to install and remove this package using the default package manager. This is useful when creating a policy that applies to different types of systems. The default behavior is ANY.
    /// </summary>
    [EnumType]
    public readonly struct PackageManager : IEquatable<PackageManager>
    {
        private readonly string _value;

        private PackageManager(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default behavior is ANY.
        /// </summary>
        public static PackageManager ManagerUnspecified { get; } = new PackageManager("MANAGER_UNSPECIFIED");
        /// <summary>
        /// Apply this package config using the default system package manager.
        /// </summary>
        public static PackageManager Any { get; } = new PackageManager("ANY");
        /// <summary>
        /// Apply this package config only if Apt is available on the system.
        /// </summary>
        public static PackageManager Apt { get; } = new PackageManager("APT");
        /// <summary>
        /// Apply this package config only if Yum is available on the system.
        /// </summary>
        public static PackageManager Yum { get; } = new PackageManager("YUM");
        /// <summary>
        /// Apply this package config only if Zypper is available on the system.
        /// </summary>
        public static PackageManager Zypper { get; } = new PackageManager("ZYPPER");
        /// <summary>
        /// Apply this package config only if GooGet is available on the system.
        /// </summary>
        public static PackageManager Goo { get; } = new PackageManager("GOO");

        public static bool operator ==(PackageManager left, PackageManager right) => left.Equals(right);
        public static bool operator !=(PackageManager left, PackageManager right) => !left.Equals(right);

        public static explicit operator string(PackageManager value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PackageManager other && Equals(other);
        public bool Equals(PackageManager other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Post-patch reboot settings.
    /// </summary>
    [EnumType]
    public readonly struct PatchConfigRebootConfig : IEquatable<PatchConfigRebootConfig>
    {
        private readonly string _value;

        private PatchConfigRebootConfig(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default behavior is DEFAULT.
        /// </summary>
        public static PatchConfigRebootConfig RebootConfigUnspecified { get; } = new PatchConfigRebootConfig("REBOOT_CONFIG_UNSPECIFIED");
        /// <summary>
        /// The agent decides if a reboot is necessary by checking signals such as registry keys on Windows or `/var/run/reboot-required` on APT based systems. On RPM based systems, a set of core system package install times are compared with system boot time.
        /// </summary>
        public static PatchConfigRebootConfig Default { get; } = new PatchConfigRebootConfig("DEFAULT");
        /// <summary>
        /// Always reboot the machine after the update completes.
        /// </summary>
        public static PatchConfigRebootConfig Always { get; } = new PatchConfigRebootConfig("ALWAYS");
        /// <summary>
        /// Never reboot the machine after the update completes.
        /// </summary>
        public static PatchConfigRebootConfig Never { get; } = new PatchConfigRebootConfig("NEVER");

        public static bool operator ==(PatchConfigRebootConfig left, PatchConfigRebootConfig right) => left.Equals(right);
        public static bool operator !=(PatchConfigRebootConfig left, PatchConfigRebootConfig right) => !left.Equals(right);

        public static explicit operator string(PatchConfigRebootConfig value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PatchConfigRebootConfig other && Equals(other);
        public bool Equals(PatchConfigRebootConfig other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Mode of the patch rollout.
    /// </summary>
    [EnumType]
    public readonly struct PatchRolloutMode : IEquatable<PatchRolloutMode>
    {
        private readonly string _value;

        private PatchRolloutMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Mode must be specified.
        /// </summary>
        public static PatchRolloutMode ModeUnspecified { get; } = new PatchRolloutMode("MODE_UNSPECIFIED");
        /// <summary>
        /// Patches are applied one zone at a time. The patch job begins in the region with the lowest number of targeted VMs. Within the region, patching begins in the zone with the lowest number of targeted VMs. If multiple regions (or zones within a region) have the same number of targeted VMs, a tie-breaker is achieved by sorting the regions or zones in alphabetical order.
        /// </summary>
        public static PatchRolloutMode ZoneByZone { get; } = new PatchRolloutMode("ZONE_BY_ZONE");
        /// <summary>
        /// Patches are applied to VMs in all zones at the same time.
        /// </summary>
        public static PatchRolloutMode ConcurrentZones { get; } = new PatchRolloutMode("CONCURRENT_ZONES");

        public static bool operator ==(PatchRolloutMode left, PatchRolloutMode right) => left.Equals(right);
        public static bool operator !=(PatchRolloutMode left, PatchRolloutMode right) => !left.Equals(right);

        public static explicit operator string(PatchRolloutMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PatchRolloutMode other && Equals(other);
        public bool Equals(PatchRolloutMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The frequency unit of this recurring schedule.
    /// </summary>
    [EnumType]
    public readonly struct RecurringScheduleFrequency : IEquatable<RecurringScheduleFrequency>
    {
        private readonly string _value;

        private RecurringScheduleFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Invalid. A frequency must be specified.
        /// </summary>
        public static RecurringScheduleFrequency FrequencyUnspecified { get; } = new RecurringScheduleFrequency("FREQUENCY_UNSPECIFIED");
        /// <summary>
        /// Indicates that the frequency of recurrence should be expressed in terms of weeks.
        /// </summary>
        public static RecurringScheduleFrequency Weekly { get; } = new RecurringScheduleFrequency("WEEKLY");
        /// <summary>
        /// Indicates that the frequency of recurrence should be expressed in terms of months.
        /// </summary>
        public static RecurringScheduleFrequency Monthly { get; } = new RecurringScheduleFrequency("MONTHLY");
        /// <summary>
        /// Indicates that the frequency of recurrence should be expressed in terms of days.
        /// </summary>
        public static RecurringScheduleFrequency Daily { get; } = new RecurringScheduleFrequency("DAILY");

        public static bool operator ==(RecurringScheduleFrequency left, RecurringScheduleFrequency right) => left.Equals(right);
        public static bool operator !=(RecurringScheduleFrequency left, RecurringScheduleFrequency right) => !left.Equals(right);

        public static explicit operator string(RecurringScheduleFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecurringScheduleFrequency other && Equals(other);
        public bool Equals(RecurringScheduleFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default is INSTALLED. The desired state the agent should maintain for this recipe. INSTALLED: The software recipe is installed on the instance but won't be updated to new versions. UPDATED: The software recipe is installed on the instance. The recipe is updated to a higher version, if a higher version of the recipe is assigned to this instance. REMOVE: Remove is unsupported for software recipes and attempts to create or update a recipe to the REMOVE state is rejected.
    /// </summary>
    [EnumType]
    public readonly struct SoftwareRecipeDesiredState : IEquatable<SoftwareRecipeDesiredState>
    {
        private readonly string _value;

        private SoftwareRecipeDesiredState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default is to ensure the package is installed.
        /// </summary>
        public static SoftwareRecipeDesiredState DesiredStateUnspecified { get; } = new SoftwareRecipeDesiredState("DESIRED_STATE_UNSPECIFIED");
        /// <summary>
        /// The agent ensures that the package is installed.
        /// </summary>
        public static SoftwareRecipeDesiredState Installed { get; } = new SoftwareRecipeDesiredState("INSTALLED");
        /// <summary>
        /// The agent ensures that the package is installed and periodically checks for and install any updates.
        /// </summary>
        public static SoftwareRecipeDesiredState Updated { get; } = new SoftwareRecipeDesiredState("UPDATED");
        /// <summary>
        /// The agent ensures that the package is not installed and uninstall it if detected.
        /// </summary>
        public static SoftwareRecipeDesiredState Removed { get; } = new SoftwareRecipeDesiredState("REMOVED");

        public static bool operator ==(SoftwareRecipeDesiredState left, SoftwareRecipeDesiredState right) => left.Equals(right);
        public static bool operator !=(SoftwareRecipeDesiredState left, SoftwareRecipeDesiredState right) => !left.Equals(right);

        public static explicit operator string(SoftwareRecipeDesiredState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SoftwareRecipeDesiredState other && Equals(other);
        public bool Equals(SoftwareRecipeDesiredState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The type of the archive to extract.
    /// </summary>
    [EnumType]
    public readonly struct SoftwareRecipeStepExtractArchiveType : IEquatable<SoftwareRecipeStepExtractArchiveType>
    {
        private readonly string _value;

        private SoftwareRecipeStepExtractArchiveType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates that the archive type isn't specified.
        /// </summary>
        public static SoftwareRecipeStepExtractArchiveType ArchiveTypeUnspecified { get; } = new SoftwareRecipeStepExtractArchiveType("ARCHIVE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Indicates that the archive is a tar archive with no encryption.
        /// </summary>
        public static SoftwareRecipeStepExtractArchiveType Tar { get; } = new SoftwareRecipeStepExtractArchiveType("TAR");
        /// <summary>
        /// Indicates that the archive is a tar archive with gzip encryption.
        /// </summary>
        public static SoftwareRecipeStepExtractArchiveType TarGzip { get; } = new SoftwareRecipeStepExtractArchiveType("TAR_GZIP");
        /// <summary>
        /// Indicates that the archive is a tar archive with bzip encryption.
        /// </summary>
        public static SoftwareRecipeStepExtractArchiveType TarBzip { get; } = new SoftwareRecipeStepExtractArchiveType("TAR_BZIP");
        /// <summary>
        /// Indicates that the archive is a tar archive with lzma encryption.
        /// </summary>
        public static SoftwareRecipeStepExtractArchiveType TarLzma { get; } = new SoftwareRecipeStepExtractArchiveType("TAR_LZMA");
        /// <summary>
        /// Indicates that the archive is a tar archive with xz encryption.
        /// </summary>
        public static SoftwareRecipeStepExtractArchiveType TarXz { get; } = new SoftwareRecipeStepExtractArchiveType("TAR_XZ");
        /// <summary>
        /// Indicates that the archive is a zip archive.
        /// </summary>
        public static SoftwareRecipeStepExtractArchiveType Zip { get; } = new SoftwareRecipeStepExtractArchiveType("ZIP");

        public static bool operator ==(SoftwareRecipeStepExtractArchiveType left, SoftwareRecipeStepExtractArchiveType right) => left.Equals(right);
        public static bool operator !=(SoftwareRecipeStepExtractArchiveType left, SoftwareRecipeStepExtractArchiveType right) => !left.Equals(right);

        public static explicit operator string(SoftwareRecipeStepExtractArchiveType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SoftwareRecipeStepExtractArchiveType other && Equals(other);
        public bool Equals(SoftwareRecipeStepExtractArchiveType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The script interpreter to use to run the script. If no interpreter is specified the script is executed directly, which likely only succeed for scripts with [shebang lines](https://en.wikipedia.org/wiki/Shebang_\(Unix\)).
    /// </summary>
    [EnumType]
    public readonly struct SoftwareRecipeStepRunScriptInterpreter : IEquatable<SoftwareRecipeStepRunScriptInterpreter>
    {
        private readonly string _value;

        private SoftwareRecipeStepRunScriptInterpreter(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value for ScriptType.
        /// </summary>
        public static SoftwareRecipeStepRunScriptInterpreter InterpreterUnspecified { get; } = new SoftwareRecipeStepRunScriptInterpreter("INTERPRETER_UNSPECIFIED");
        /// <summary>
        /// Indicates that the script is run with `/bin/sh` on Linux and `cmd` on windows.
        /// </summary>
        public static SoftwareRecipeStepRunScriptInterpreter Shell { get; } = new SoftwareRecipeStepRunScriptInterpreter("SHELL");
        /// <summary>
        /// Indicates that the script is run with powershell.
        /// </summary>
        public static SoftwareRecipeStepRunScriptInterpreter Powershell { get; } = new SoftwareRecipeStepRunScriptInterpreter("POWERSHELL");

        public static bool operator ==(SoftwareRecipeStepRunScriptInterpreter left, SoftwareRecipeStepRunScriptInterpreter right) => left.Equals(right);
        public static bool operator !=(SoftwareRecipeStepRunScriptInterpreter left, SoftwareRecipeStepRunScriptInterpreter right) => !left.Equals(right);

        public static explicit operator string(SoftwareRecipeStepRunScriptInterpreter value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SoftwareRecipeStepRunScriptInterpreter other && Equals(other);
        public bool Equals(SoftwareRecipeStepRunScriptInterpreter other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. A day of the week.
    /// </summary>
    [EnumType]
    public readonly struct WeekDayOfMonthDayOfWeek : IEquatable<WeekDayOfMonthDayOfWeek>
    {
        private readonly string _value;

        private WeekDayOfMonthDayOfWeek(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The day of the week is unspecified.
        /// </summary>
        public static WeekDayOfMonthDayOfWeek DayOfWeekUnspecified { get; } = new WeekDayOfMonthDayOfWeek("DAY_OF_WEEK_UNSPECIFIED");
        /// <summary>
        /// Monday
        /// </summary>
        public static WeekDayOfMonthDayOfWeek Monday { get; } = new WeekDayOfMonthDayOfWeek("MONDAY");
        /// <summary>
        /// Tuesday
        /// </summary>
        public static WeekDayOfMonthDayOfWeek Tuesday { get; } = new WeekDayOfMonthDayOfWeek("TUESDAY");
        /// <summary>
        /// Wednesday
        /// </summary>
        public static WeekDayOfMonthDayOfWeek Wednesday { get; } = new WeekDayOfMonthDayOfWeek("WEDNESDAY");
        /// <summary>
        /// Thursday
        /// </summary>
        public static WeekDayOfMonthDayOfWeek Thursday { get; } = new WeekDayOfMonthDayOfWeek("THURSDAY");
        /// <summary>
        /// Friday
        /// </summary>
        public static WeekDayOfMonthDayOfWeek Friday { get; } = new WeekDayOfMonthDayOfWeek("FRIDAY");
        /// <summary>
        /// Saturday
        /// </summary>
        public static WeekDayOfMonthDayOfWeek Saturday { get; } = new WeekDayOfMonthDayOfWeek("SATURDAY");
        /// <summary>
        /// Sunday
        /// </summary>
        public static WeekDayOfMonthDayOfWeek Sunday { get; } = new WeekDayOfMonthDayOfWeek("SUNDAY");

        public static bool operator ==(WeekDayOfMonthDayOfWeek left, WeekDayOfMonthDayOfWeek right) => left.Equals(right);
        public static bool operator !=(WeekDayOfMonthDayOfWeek left, WeekDayOfMonthDayOfWeek right) => !left.Equals(right);

        public static explicit operator string(WeekDayOfMonthDayOfWeek value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WeekDayOfMonthDayOfWeek other && Equals(other);
        public bool Equals(WeekDayOfMonthDayOfWeek other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Day of the week.
    /// </summary>
    [EnumType]
    public readonly struct WeeklyScheduleDayOfWeek : IEquatable<WeeklyScheduleDayOfWeek>
    {
        private readonly string _value;

        private WeeklyScheduleDayOfWeek(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The day of the week is unspecified.
        /// </summary>
        public static WeeklyScheduleDayOfWeek DayOfWeekUnspecified { get; } = new WeeklyScheduleDayOfWeek("DAY_OF_WEEK_UNSPECIFIED");
        /// <summary>
        /// Monday
        /// </summary>
        public static WeeklyScheduleDayOfWeek Monday { get; } = new WeeklyScheduleDayOfWeek("MONDAY");
        /// <summary>
        /// Tuesday
        /// </summary>
        public static WeeklyScheduleDayOfWeek Tuesday { get; } = new WeeklyScheduleDayOfWeek("TUESDAY");
        /// <summary>
        /// Wednesday
        /// </summary>
        public static WeeklyScheduleDayOfWeek Wednesday { get; } = new WeeklyScheduleDayOfWeek("WEDNESDAY");
        /// <summary>
        /// Thursday
        /// </summary>
        public static WeeklyScheduleDayOfWeek Thursday { get; } = new WeeklyScheduleDayOfWeek("THURSDAY");
        /// <summary>
        /// Friday
        /// </summary>
        public static WeeklyScheduleDayOfWeek Friday { get; } = new WeeklyScheduleDayOfWeek("FRIDAY");
        /// <summary>
        /// Saturday
        /// </summary>
        public static WeeklyScheduleDayOfWeek Saturday { get; } = new WeeklyScheduleDayOfWeek("SATURDAY");
        /// <summary>
        /// Sunday
        /// </summary>
        public static WeeklyScheduleDayOfWeek Sunday { get; } = new WeeklyScheduleDayOfWeek("SUNDAY");

        public static bool operator ==(WeeklyScheduleDayOfWeek left, WeeklyScheduleDayOfWeek right) => left.Equals(right);
        public static bool operator !=(WeeklyScheduleDayOfWeek left, WeeklyScheduleDayOfWeek right) => !left.Equals(right);

        public static explicit operator string(WeeklyScheduleDayOfWeek value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WeeklyScheduleDayOfWeek other && Equals(other);
        public bool Equals(WeeklyScheduleDayOfWeek other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct WindowsUpdateSettingsClassificationsItem : IEquatable<WindowsUpdateSettingsClassificationsItem>
    {
        private readonly string _value;

        private WindowsUpdateSettingsClassificationsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Invalid. If classifications are included, they must be specified.
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem ClassificationUnspecified { get; } = new WindowsUpdateSettingsClassificationsItem("CLASSIFICATION_UNSPECIFIED");
        /// <summary>
        /// "A widely released fix for a specific problem that addresses a critical, non-security-related bug." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem Critical { get; } = new WindowsUpdateSettingsClassificationsItem("CRITICAL");
        /// <summary>
        /// "A widely released fix for a product-specific, security-related vulnerability. Security vulnerabilities are rated by their severity. The severity rating is indicated in the Microsoft security bulletin as critical, important, moderate, or low." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem Security { get; } = new WindowsUpdateSettingsClassificationsItem("SECURITY");
        /// <summary>
        /// "A widely released and frequent software update that contains additions to a product's definition database. Definition databases are often used to detect objects that have specific attributes, such as malicious code, phishing websites, or junk mail." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem Definition { get; } = new WindowsUpdateSettingsClassificationsItem("DEFINITION");
        /// <summary>
        /// "Software that controls the input and output of a device." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem Driver { get; } = new WindowsUpdateSettingsClassificationsItem("DRIVER");
        /// <summary>
        /// "New product functionality that is first distributed outside the context of a product release and that is typically included in the next full product release." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem FeaturePack { get; } = new WindowsUpdateSettingsClassificationsItem("FEATURE_PACK");
        /// <summary>
        /// "A tested, cumulative set of all hotfixes, security updates, critical updates, and updates. Additionally, service packs may contain additional fixes for problems that are found internally since the release of the product. Service packs my also contain a limited number of customer-requested design changes or features." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem ServicePack { get; } = new WindowsUpdateSettingsClassificationsItem("SERVICE_PACK");
        /// <summary>
        /// "A utility or feature that helps complete a task or set of tasks." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem Tool { get; } = new WindowsUpdateSettingsClassificationsItem("TOOL");
        /// <summary>
        /// "A tested, cumulative set of hotfixes, security updates, critical updates, and updates that are packaged together for easy deployment. A rollup generally targets a specific area, such as security, or a component of a product, such as Internet Information Services (IIS)." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem UpdateRollup { get; } = new WindowsUpdateSettingsClassificationsItem("UPDATE_ROLLUP");
        /// <summary>
        /// "A widely released fix for a specific problem. An update addresses a noncritical, non-security-related bug." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem Update { get; } = new WindowsUpdateSettingsClassificationsItem("UPDATE");

        public static bool operator ==(WindowsUpdateSettingsClassificationsItem left, WindowsUpdateSettingsClassificationsItem right) => left.Equals(right);
        public static bool operator !=(WindowsUpdateSettingsClassificationsItem left, WindowsUpdateSettingsClassificationsItem right) => !left.Equals(right);

        public static explicit operator string(WindowsUpdateSettingsClassificationsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WindowsUpdateSettingsClassificationsItem other && Equals(other);
        public bool Equals(WindowsUpdateSettingsClassificationsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

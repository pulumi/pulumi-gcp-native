// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.OSConfig.V1
{
    /// <summary>
    /// By changing the type to DIST, the patching is performed using `apt-get dist-upgrade` instead.
    /// </summary>
    [EnumType]
    public readonly struct AptSettingsType : IEquatable<AptSettingsType>
    {
        private readonly string _value;

        private AptSettingsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// By default, upgrade will be performed.
        /// </summary>
        public static AptSettingsType TypeUnspecified { get; } = new AptSettingsType("TYPE_UNSPECIFIED");
        /// <summary>
        /// Runs `apt-get dist-upgrade`.
        /// </summary>
        public static AptSettingsType Dist { get; } = new AptSettingsType("DIST");
        /// <summary>
        /// Runs `apt-get upgrade`.
        /// </summary>
        public static AptSettingsType Upgrade { get; } = new AptSettingsType("UPGRADE");

        public static bool operator ==(AptSettingsType left, AptSettingsType right) => left.Equals(right);
        public static bool operator !=(AptSettingsType left, AptSettingsType right) => !left.Equals(right);

        public static explicit operator string(AptSettingsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AptSettingsType other && Equals(other);
        public bool Equals(AptSettingsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The script interpreter to use to run the script. If no interpreter is specified the script will be executed directly, which will likely only succeed for scripts with [shebang lines] (https://en.wikipedia.org/wiki/Shebang_\(Unix\)).
    /// </summary>
    [EnumType]
    public readonly struct ExecStepConfigInterpreter : IEquatable<ExecStepConfigInterpreter>
    {
        private readonly string _value;

        private ExecStepConfigInterpreter(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// If the interpreter is not specified, the value defaults to `NONE`.
        /// </summary>
        public static ExecStepConfigInterpreter InterpreterUnspecified { get; } = new ExecStepConfigInterpreter("INTERPRETER_UNSPECIFIED");
        /// <summary>
        /// Indicates that the file is run as follows on each operating system: + For Linux VMs, the file is ran as an executable and the interpreter might be parsed from the [shebang line](https://wikipedia.org/wiki/Shebang_(Unix)) of the file. + For Windows VM, this value is not supported.
        /// </summary>
        public static ExecStepConfigInterpreter None { get; } = new ExecStepConfigInterpreter("NONE");
        /// <summary>
        /// Indicates that the file is run with `/bin/sh` on Linux and `cmd` on Windows.
        /// </summary>
        public static ExecStepConfigInterpreter Shell { get; } = new ExecStepConfigInterpreter("SHELL");
        /// <summary>
        /// Indicates that the file is run with PowerShell.
        /// </summary>
        public static ExecStepConfigInterpreter Powershell { get; } = new ExecStepConfigInterpreter("POWERSHELL");

        public static bool operator ==(ExecStepConfigInterpreter left, ExecStepConfigInterpreter right) => left.Equals(right);
        public static bool operator !=(ExecStepConfigInterpreter left, ExecStepConfigInterpreter right) => !left.Equals(right);

        public static explicit operator string(ExecStepConfigInterpreter value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExecStepConfigInterpreter other && Equals(other);
        public bool Equals(ExecStepConfigInterpreter other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Policy mode
    /// </summary>
    [EnumType]
    public readonly struct OSPolicyMode : IEquatable<OSPolicyMode>
    {
        private readonly string _value;

        private OSPolicyMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Invalid mode
        /// </summary>
        public static OSPolicyMode ModeUnspecified { get; } = new OSPolicyMode("MODE_UNSPECIFIED");
        /// <summary>
        /// This mode checks if the configuration resources in the policy are in their desired state. No actions are performed if they are not in the desired state. This mode is used for reporting purposes.
        /// </summary>
        public static OSPolicyMode Validation { get; } = new OSPolicyMode("VALIDATION");
        /// <summary>
        /// This mode checks if the configuration resources in the policy are in their desired state, and if not, enforces the desired state.
        /// </summary>
        public static OSPolicyMode Enforcement { get; } = new OSPolicyMode("ENFORCEMENT");

        public static bool operator ==(OSPolicyMode left, OSPolicyMode right) => left.Equals(right);
        public static bool operator !=(OSPolicyMode left, OSPolicyMode right) => !left.Equals(right);

        public static explicit operator string(OSPolicyMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSPolicyMode other && Equals(other);
        public bool Equals(OSPolicyMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The script interpreter to use.
    /// </summary>
    [EnumType]
    public readonly struct OSPolicyResourceExecResourceExecInterpreter : IEquatable<OSPolicyResourceExecResourceExecInterpreter>
    {
        private readonly string _value;

        private OSPolicyResourceExecResourceExecInterpreter(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Invalid value, the request will return validation error.
        /// </summary>
        public static OSPolicyResourceExecResourceExecInterpreter InterpreterUnspecified { get; } = new OSPolicyResourceExecResourceExecInterpreter("INTERPRETER_UNSPECIFIED");
        /// <summary>
        /// If an interpreter is not specified, the source is executed directly. This execution, without an interpreter, only succeeds for executables and scripts that have shebang lines.
        /// </summary>
        public static OSPolicyResourceExecResourceExecInterpreter None { get; } = new OSPolicyResourceExecResourceExecInterpreter("NONE");
        /// <summary>
        /// Indicates that the script runs with `/bin/sh` on Linux and `cmd.exe` on Windows.
        /// </summary>
        public static OSPolicyResourceExecResourceExecInterpreter Shell { get; } = new OSPolicyResourceExecResourceExecInterpreter("SHELL");
        /// <summary>
        /// Indicates that the script runs with PowerShell.
        /// </summary>
        public static OSPolicyResourceExecResourceExecInterpreter Powershell { get; } = new OSPolicyResourceExecResourceExecInterpreter("POWERSHELL");

        public static bool operator ==(OSPolicyResourceExecResourceExecInterpreter left, OSPolicyResourceExecResourceExecInterpreter right) => left.Equals(right);
        public static bool operator !=(OSPolicyResourceExecResourceExecInterpreter left, OSPolicyResourceExecResourceExecInterpreter right) => !left.Equals(right);

        public static explicit operator string(OSPolicyResourceExecResourceExecInterpreter value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSPolicyResourceExecResourceExecInterpreter other && Equals(other);
        public bool Equals(OSPolicyResourceExecResourceExecInterpreter other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Desired state of the file.
    /// </summary>
    [EnumType]
    public readonly struct OSPolicyResourceFileResourceState : IEquatable<OSPolicyResourceFileResourceState>
    {
        private readonly string _value;

        private OSPolicyResourceFileResourceState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified is invalid.
        /// </summary>
        public static OSPolicyResourceFileResourceState DesiredStateUnspecified { get; } = new OSPolicyResourceFileResourceState("DESIRED_STATE_UNSPECIFIED");
        /// <summary>
        /// Ensure file at path is present.
        /// </summary>
        public static OSPolicyResourceFileResourceState Present { get; } = new OSPolicyResourceFileResourceState("PRESENT");
        /// <summary>
        /// Ensure file at path is absent.
        /// </summary>
        public static OSPolicyResourceFileResourceState Absent { get; } = new OSPolicyResourceFileResourceState("ABSENT");
        /// <summary>
        /// Ensure the contents of the file at path matches. If the file does not exist it will be created.
        /// </summary>
        public static OSPolicyResourceFileResourceState ContentsMatch { get; } = new OSPolicyResourceFileResourceState("CONTENTS_MATCH");

        public static bool operator ==(OSPolicyResourceFileResourceState left, OSPolicyResourceFileResourceState right) => left.Equals(right);
        public static bool operator !=(OSPolicyResourceFileResourceState left, OSPolicyResourceFileResourceState right) => !left.Equals(right);

        public static explicit operator string(OSPolicyResourceFileResourceState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSPolicyResourceFileResourceState other && Equals(other);
        public bool Equals(OSPolicyResourceFileResourceState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The desired state the agent should maintain for this package.
    /// </summary>
    [EnumType]
    public readonly struct OSPolicyResourcePackageResourceDesiredState : IEquatable<OSPolicyResourcePackageResourceDesiredState>
    {
        private readonly string _value;

        private OSPolicyResourcePackageResourceDesiredState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified is invalid.
        /// </summary>
        public static OSPolicyResourcePackageResourceDesiredState DesiredStateUnspecified { get; } = new OSPolicyResourcePackageResourceDesiredState("DESIRED_STATE_UNSPECIFIED");
        /// <summary>
        /// Ensure that the package is installed.
        /// </summary>
        public static OSPolicyResourcePackageResourceDesiredState Installed { get; } = new OSPolicyResourcePackageResourceDesiredState("INSTALLED");
        /// <summary>
        /// The agent ensures that the package is not installed and uninstalls it if detected.
        /// </summary>
        public static OSPolicyResourcePackageResourceDesiredState Removed { get; } = new OSPolicyResourcePackageResourceDesiredState("REMOVED");

        public static bool operator ==(OSPolicyResourcePackageResourceDesiredState left, OSPolicyResourcePackageResourceDesiredState right) => left.Equals(right);
        public static bool operator !=(OSPolicyResourcePackageResourceDesiredState left, OSPolicyResourcePackageResourceDesiredState right) => !left.Equals(right);

        public static explicit operator string(OSPolicyResourcePackageResourceDesiredState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSPolicyResourcePackageResourceDesiredState other && Equals(other);
        public bool Equals(OSPolicyResourcePackageResourceDesiredState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Type of archive files in this repository.
    /// </summary>
    [EnumType]
    public readonly struct OSPolicyResourceRepositoryResourceAptRepositoryArchiveType : IEquatable<OSPolicyResourceRepositoryResourceAptRepositoryArchiveType>
    {
        private readonly string _value;

        private OSPolicyResourceRepositoryResourceAptRepositoryArchiveType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified is invalid.
        /// </summary>
        public static OSPolicyResourceRepositoryResourceAptRepositoryArchiveType ArchiveTypeUnspecified { get; } = new OSPolicyResourceRepositoryResourceAptRepositoryArchiveType("ARCHIVE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Deb indicates that the archive contains binary files.
        /// </summary>
        public static OSPolicyResourceRepositoryResourceAptRepositoryArchiveType Deb { get; } = new OSPolicyResourceRepositoryResourceAptRepositoryArchiveType("DEB");
        /// <summary>
        /// Deb-src indicates that the archive contains source files.
        /// </summary>
        public static OSPolicyResourceRepositoryResourceAptRepositoryArchiveType DebSrc { get; } = new OSPolicyResourceRepositoryResourceAptRepositoryArchiveType("DEB_SRC");

        public static bool operator ==(OSPolicyResourceRepositoryResourceAptRepositoryArchiveType left, OSPolicyResourceRepositoryResourceAptRepositoryArchiveType right) => left.Equals(right);
        public static bool operator !=(OSPolicyResourceRepositoryResourceAptRepositoryArchiveType left, OSPolicyResourceRepositoryResourceAptRepositoryArchiveType right) => !left.Equals(right);

        public static explicit operator string(OSPolicyResourceRepositoryResourceAptRepositoryArchiveType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSPolicyResourceRepositoryResourceAptRepositoryArchiveType other && Equals(other);
        public bool Equals(OSPolicyResourceRepositoryResourceAptRepositoryArchiveType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Post-patch reboot settings.
    /// </summary>
    [EnumType]
    public readonly struct PatchConfigRebootConfig : IEquatable<PatchConfigRebootConfig>
    {
        private readonly string _value;

        private PatchConfigRebootConfig(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default behavior is DEFAULT.
        /// </summary>
        public static PatchConfigRebootConfig RebootConfigUnspecified { get; } = new PatchConfigRebootConfig("REBOOT_CONFIG_UNSPECIFIED");
        /// <summary>
        /// The agent decides if a reboot is necessary by checking signals such as registry keys on Windows or `/var/run/reboot-required` on APT based systems. On RPM based systems, a set of core system package install times are compared with system boot time.
        /// </summary>
        public static PatchConfigRebootConfig Default { get; } = new PatchConfigRebootConfig("DEFAULT");
        /// <summary>
        /// Always reboot the machine after the update completes.
        /// </summary>
        public static PatchConfigRebootConfig Always { get; } = new PatchConfigRebootConfig("ALWAYS");
        /// <summary>
        /// Never reboot the machine after the update completes.
        /// </summary>
        public static PatchConfigRebootConfig Never { get; } = new PatchConfigRebootConfig("NEVER");

        public static bool operator ==(PatchConfigRebootConfig left, PatchConfigRebootConfig right) => left.Equals(right);
        public static bool operator !=(PatchConfigRebootConfig left, PatchConfigRebootConfig right) => !left.Equals(right);

        public static explicit operator string(PatchConfigRebootConfig value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PatchConfigRebootConfig other && Equals(other);
        public bool Equals(PatchConfigRebootConfig other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Mode of the patch rollout.
    /// </summary>
    [EnumType]
    public readonly struct PatchRolloutMode : IEquatable<PatchRolloutMode>
    {
        private readonly string _value;

        private PatchRolloutMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Mode must be specified.
        /// </summary>
        public static PatchRolloutMode ModeUnspecified { get; } = new PatchRolloutMode("MODE_UNSPECIFIED");
        /// <summary>
        /// Patches are applied one zone at a time. The patch job begins in the region with the lowest number of targeted VMs. Within the region, patching begins in the zone with the lowest number of targeted VMs. If multiple regions (or zones within a region) have the same number of targeted VMs, a tie-breaker is achieved by sorting the regions or zones in alphabetical order.
        /// </summary>
        public static PatchRolloutMode ZoneByZone { get; } = new PatchRolloutMode("ZONE_BY_ZONE");
        /// <summary>
        /// Patches are applied to VMs in all zones at the same time.
        /// </summary>
        public static PatchRolloutMode ConcurrentZones { get; } = new PatchRolloutMode("CONCURRENT_ZONES");

        public static bool operator ==(PatchRolloutMode left, PatchRolloutMode right) => left.Equals(right);
        public static bool operator !=(PatchRolloutMode left, PatchRolloutMode right) => !left.Equals(right);

        public static explicit operator string(PatchRolloutMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PatchRolloutMode other && Equals(other);
        public bool Equals(PatchRolloutMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The frequency unit of this recurring schedule.
    /// </summary>
    [EnumType]
    public readonly struct RecurringScheduleFrequency : IEquatable<RecurringScheduleFrequency>
    {
        private readonly string _value;

        private RecurringScheduleFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Invalid. A frequency must be specified.
        /// </summary>
        public static RecurringScheduleFrequency FrequencyUnspecified { get; } = new RecurringScheduleFrequency("FREQUENCY_UNSPECIFIED");
        /// <summary>
        /// Indicates that the frequency of recurrence should be expressed in terms of weeks.
        /// </summary>
        public static RecurringScheduleFrequency Weekly { get; } = new RecurringScheduleFrequency("WEEKLY");
        /// <summary>
        /// Indicates that the frequency of recurrence should be expressed in terms of months.
        /// </summary>
        public static RecurringScheduleFrequency Monthly { get; } = new RecurringScheduleFrequency("MONTHLY");
        /// <summary>
        /// Indicates that the frequency of recurrence should be expressed in terms of days.
        /// </summary>
        public static RecurringScheduleFrequency Daily { get; } = new RecurringScheduleFrequency("DAILY");

        public static bool operator ==(RecurringScheduleFrequency left, RecurringScheduleFrequency right) => left.Equals(right);
        public static bool operator !=(RecurringScheduleFrequency left, RecurringScheduleFrequency right) => !left.Equals(right);

        public static explicit operator string(RecurringScheduleFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecurringScheduleFrequency other && Equals(other);
        public bool Equals(RecurringScheduleFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. A day of the week.
    /// </summary>
    [EnumType]
    public readonly struct WeekDayOfMonthDayOfWeek : IEquatable<WeekDayOfMonthDayOfWeek>
    {
        private readonly string _value;

        private WeekDayOfMonthDayOfWeek(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The day of the week is unspecified.
        /// </summary>
        public static WeekDayOfMonthDayOfWeek DayOfWeekUnspecified { get; } = new WeekDayOfMonthDayOfWeek("DAY_OF_WEEK_UNSPECIFIED");
        /// <summary>
        /// Monday
        /// </summary>
        public static WeekDayOfMonthDayOfWeek Monday { get; } = new WeekDayOfMonthDayOfWeek("MONDAY");
        /// <summary>
        /// Tuesday
        /// </summary>
        public static WeekDayOfMonthDayOfWeek Tuesday { get; } = new WeekDayOfMonthDayOfWeek("TUESDAY");
        /// <summary>
        /// Wednesday
        /// </summary>
        public static WeekDayOfMonthDayOfWeek Wednesday { get; } = new WeekDayOfMonthDayOfWeek("WEDNESDAY");
        /// <summary>
        /// Thursday
        /// </summary>
        public static WeekDayOfMonthDayOfWeek Thursday { get; } = new WeekDayOfMonthDayOfWeek("THURSDAY");
        /// <summary>
        /// Friday
        /// </summary>
        public static WeekDayOfMonthDayOfWeek Friday { get; } = new WeekDayOfMonthDayOfWeek("FRIDAY");
        /// <summary>
        /// Saturday
        /// </summary>
        public static WeekDayOfMonthDayOfWeek Saturday { get; } = new WeekDayOfMonthDayOfWeek("SATURDAY");
        /// <summary>
        /// Sunday
        /// </summary>
        public static WeekDayOfMonthDayOfWeek Sunday { get; } = new WeekDayOfMonthDayOfWeek("SUNDAY");

        public static bool operator ==(WeekDayOfMonthDayOfWeek left, WeekDayOfMonthDayOfWeek right) => left.Equals(right);
        public static bool operator !=(WeekDayOfMonthDayOfWeek left, WeekDayOfMonthDayOfWeek right) => !left.Equals(right);

        public static explicit operator string(WeekDayOfMonthDayOfWeek value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WeekDayOfMonthDayOfWeek other && Equals(other);
        public bool Equals(WeekDayOfMonthDayOfWeek other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Day of the week.
    /// </summary>
    [EnumType]
    public readonly struct WeeklyScheduleDayOfWeek : IEquatable<WeeklyScheduleDayOfWeek>
    {
        private readonly string _value;

        private WeeklyScheduleDayOfWeek(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The day of the week is unspecified.
        /// </summary>
        public static WeeklyScheduleDayOfWeek DayOfWeekUnspecified { get; } = new WeeklyScheduleDayOfWeek("DAY_OF_WEEK_UNSPECIFIED");
        /// <summary>
        /// Monday
        /// </summary>
        public static WeeklyScheduleDayOfWeek Monday { get; } = new WeeklyScheduleDayOfWeek("MONDAY");
        /// <summary>
        /// Tuesday
        /// </summary>
        public static WeeklyScheduleDayOfWeek Tuesday { get; } = new WeeklyScheduleDayOfWeek("TUESDAY");
        /// <summary>
        /// Wednesday
        /// </summary>
        public static WeeklyScheduleDayOfWeek Wednesday { get; } = new WeeklyScheduleDayOfWeek("WEDNESDAY");
        /// <summary>
        /// Thursday
        /// </summary>
        public static WeeklyScheduleDayOfWeek Thursday { get; } = new WeeklyScheduleDayOfWeek("THURSDAY");
        /// <summary>
        /// Friday
        /// </summary>
        public static WeeklyScheduleDayOfWeek Friday { get; } = new WeeklyScheduleDayOfWeek("FRIDAY");
        /// <summary>
        /// Saturday
        /// </summary>
        public static WeeklyScheduleDayOfWeek Saturday { get; } = new WeeklyScheduleDayOfWeek("SATURDAY");
        /// <summary>
        /// Sunday
        /// </summary>
        public static WeeklyScheduleDayOfWeek Sunday { get; } = new WeeklyScheduleDayOfWeek("SUNDAY");

        public static bool operator ==(WeeklyScheduleDayOfWeek left, WeeklyScheduleDayOfWeek right) => left.Equals(right);
        public static bool operator !=(WeeklyScheduleDayOfWeek left, WeeklyScheduleDayOfWeek right) => !left.Equals(right);

        public static explicit operator string(WeeklyScheduleDayOfWeek value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WeeklyScheduleDayOfWeek other && Equals(other);
        public bool Equals(WeeklyScheduleDayOfWeek other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct WindowsUpdateSettingsClassificationsItem : IEquatable<WindowsUpdateSettingsClassificationsItem>
    {
        private readonly string _value;

        private WindowsUpdateSettingsClassificationsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Invalid. If classifications are included, they must be specified.
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem ClassificationUnspecified { get; } = new WindowsUpdateSettingsClassificationsItem("CLASSIFICATION_UNSPECIFIED");
        /// <summary>
        /// "A widely released fix for a specific problem that addresses a critical, non-security-related bug." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem Critical { get; } = new WindowsUpdateSettingsClassificationsItem("CRITICAL");
        /// <summary>
        /// "A widely released fix for a product-specific, security-related vulnerability. Security vulnerabilities are rated by their severity. The severity rating is indicated in the Microsoft security bulletin as critical, important, moderate, or low." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem Security { get; } = new WindowsUpdateSettingsClassificationsItem("SECURITY");
        /// <summary>
        /// "A widely released and frequent software update that contains additions to a product's definition database. Definition databases are often used to detect objects that have specific attributes, such as malicious code, phishing websites, or junk mail." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem Definition { get; } = new WindowsUpdateSettingsClassificationsItem("DEFINITION");
        /// <summary>
        /// "Software that controls the input and output of a device." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem Driver { get; } = new WindowsUpdateSettingsClassificationsItem("DRIVER");
        /// <summary>
        /// "New product functionality that is first distributed outside the context of a product release and that is typically included in the next full product release." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem FeaturePack { get; } = new WindowsUpdateSettingsClassificationsItem("FEATURE_PACK");
        /// <summary>
        /// "A tested, cumulative set of all hotfixes, security updates, critical updates, and updates. Additionally, service packs may contain additional fixes for problems that are found internally since the release of the product. Service packs my also contain a limited number of customer-requested design changes or features." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem ServicePack { get; } = new WindowsUpdateSettingsClassificationsItem("SERVICE_PACK");
        /// <summary>
        /// "A utility or feature that helps complete a task or set of tasks." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem Tool { get; } = new WindowsUpdateSettingsClassificationsItem("TOOL");
        /// <summary>
        /// "A tested, cumulative set of hotfixes, security updates, critical updates, and updates that are packaged together for easy deployment. A rollup generally targets a specific area, such as security, or a component of a product, such as Internet Information Services (IIS)." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem UpdateRollup { get; } = new WindowsUpdateSettingsClassificationsItem("UPDATE_ROLLUP");
        /// <summary>
        /// "A widely released fix for a specific problem. An update addresses a noncritical, non-security-related bug." [1]
        /// </summary>
        public static WindowsUpdateSettingsClassificationsItem Update { get; } = new WindowsUpdateSettingsClassificationsItem("UPDATE");

        public static bool operator ==(WindowsUpdateSettingsClassificationsItem left, WindowsUpdateSettingsClassificationsItem right) => left.Equals(right);
        public static bool operator !=(WindowsUpdateSettingsClassificationsItem left, WindowsUpdateSettingsClassificationsItem right) => !left.Equals(right);

        public static explicit operator string(WindowsUpdateSettingsClassificationsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WindowsUpdateSettingsClassificationsItem other && Equals(other);
        public bool Equals(WindowsUpdateSettingsClassificationsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

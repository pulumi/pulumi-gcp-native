// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.GoogleNative.AccessContextManager.V1
{
    /// <summary>
    /// Create a Service Perimeter. The longrunning operation from this RPC will have a successful status once the Service Perimeter has propagated to long-lasting storage. Service Perimeters containing errors will result in an error response for the first error encountered.
    /// </summary>
    [GoogleNativeResourceType("google-native:accesscontextmanager/v1:AccessPolicyServicePerimeter")]
    public partial class AccessPolicyServicePerimeter : Pulumi.CustomResource
    {
        /// <summary>
        /// Description of the `ServicePerimeter` and its use. Does not affect behavior.
        /// </summary>
        [Output("description")]
        public Output<string> Description { get; private set; } = null!;

        /// <summary>
        /// Required. Resource name for the ServicePerimeter. The `short_name` component must begin with a letter and only include alphanumeric and '_'. Format: `accessPolicies/{policy_id}/servicePerimeters/{short_name}`
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Perimeter type indicator. A single project is allowed to be a member of single regular perimeter, but multiple service perimeter bridges. A project cannot be a included in a perimeter bridge without being included in regular perimeter. For perimeter bridges, the restricted service list as well as access level lists must be empty.
        /// </summary>
        [Output("perimeterType")]
        public Output<string> PerimeterType { get; private set; } = null!;

        /// <summary>
        /// Proposed (or dry run) ServicePerimeter configuration. This configuration allows to specify and test ServicePerimeter configuration without enforcing actual access restrictions. Only allowed to be set when the "use_explicit_dry_run_spec" flag is set.
        /// </summary>
        [Output("spec")]
        public Output<Outputs.ServicePerimeterConfigResponse> Spec { get; private set; } = null!;

        /// <summary>
        /// Current ServicePerimeter configuration. Specifies sets of resources, restricted services and access levels that determine perimeter content and boundaries.
        /// </summary>
        [Output("status")]
        public Output<Outputs.ServicePerimeterConfigResponse> Status { get; private set; } = null!;

        /// <summary>
        /// Human readable title. Must be unique within the Policy.
        /// </summary>
        [Output("title")]
        public Output<string> Title { get; private set; } = null!;

        /// <summary>
        /// Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists for all Service Perimeters, and that spec is identical to the status for those Service Perimeters. When this flag is set, it inhibits the generation of the implicit spec, thereby allowing the user to explicitly provide a configuration ("spec") to use in a dry-run version of the Service Perimeter. This allows the user to test changes to the enforced config ("status") without actually enforcing them. This testing is done through analyzing the differences between currently enforced and suggested restrictions. use_explicit_dry_run_spec must bet set to True if any of the fields in the spec are set to non-default values.
        /// </summary>
        [Output("useExplicitDryRunSpec")]
        public Output<bool> UseExplicitDryRunSpec { get; private set; } = null!;


        /// <summary>
        /// Create a AccessPolicyServicePerimeter resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public AccessPolicyServicePerimeter(string name, AccessPolicyServicePerimeterArgs args, CustomResourceOptions? options = null)
            : base("google-native:accesscontextmanager/v1:AccessPolicyServicePerimeter", name, args ?? new AccessPolicyServicePerimeterArgs(), MakeResourceOptions(options, ""))
        {
        }

        private AccessPolicyServicePerimeter(string name, Input<string> id, CustomResourceOptions? options = null)
            : base("google-native:accesscontextmanager/v1:AccessPolicyServicePerimeter", name, null, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing AccessPolicyServicePerimeter resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static AccessPolicyServicePerimeter Get(string name, Input<string> id, CustomResourceOptions? options = null)
        {
            return new AccessPolicyServicePerimeter(name, id, options);
        }
    }

    public sealed class AccessPolicyServicePerimeterArgs : Pulumi.ResourceArgs
    {
        [Input("accessPolicyId", required: true)]
        public Input<string> AccessPolicyId { get; set; } = null!;

        /// <summary>
        /// Description of the `ServicePerimeter` and its use. Does not affect behavior.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Required. Resource name for the ServicePerimeter. The `short_name` component must begin with a letter and only include alphanumeric and '_'. Format: `accessPolicies/{policy_id}/servicePerimeters/{short_name}`
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Perimeter type indicator. A single project is allowed to be a member of single regular perimeter, but multiple service perimeter bridges. A project cannot be a included in a perimeter bridge without being included in regular perimeter. For perimeter bridges, the restricted service list as well as access level lists must be empty.
        /// </summary>
        [Input("perimeterType")]
        public Input<string>? PerimeterType { get; set; }

        [Input("servicePerimeterId", required: true)]
        public Input<string> ServicePerimeterId { get; set; } = null!;

        /// <summary>
        /// Proposed (or dry run) ServicePerimeter configuration. This configuration allows to specify and test ServicePerimeter configuration without enforcing actual access restrictions. Only allowed to be set when the "use_explicit_dry_run_spec" flag is set.
        /// </summary>
        [Input("spec")]
        public Input<Inputs.ServicePerimeterConfigArgs>? Spec { get; set; }

        /// <summary>
        /// Current ServicePerimeter configuration. Specifies sets of resources, restricted services and access levels that determine perimeter content and boundaries.
        /// </summary>
        [Input("status")]
        public Input<Inputs.ServicePerimeterConfigArgs>? Status { get; set; }

        /// <summary>
        /// Human readable title. Must be unique within the Policy.
        /// </summary>
        [Input("title")]
        public Input<string>? Title { get; set; }

        /// <summary>
        /// Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists for all Service Perimeters, and that spec is identical to the status for those Service Perimeters. When this flag is set, it inhibits the generation of the implicit spec, thereby allowing the user to explicitly provide a configuration ("spec") to use in a dry-run version of the Service Perimeter. This allows the user to test changes to the enforced config ("status") without actually enforcing them. This testing is done through analyzing the differences between currently enforced and suggested restrictions. use_explicit_dry_run_spec must bet set to True if any of the fields in the spec are set to non-default values.
        /// </summary>
        [Input("useExplicitDryRunSpec")]
        public Input<bool>? UseExplicitDryRunSpec { get; set; }

        public AccessPolicyServicePerimeterArgs()
        {
        }
    }
}

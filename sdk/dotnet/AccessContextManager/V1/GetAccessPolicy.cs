// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi.Utilities;

namespace Pulumi.GoogleNative.AccessContextManager.V1
{
    public static class GetAccessPolicy
    {
        /// <summary>
        /// Returns an access policy based on the name.
        /// </summary>
        public static Task<GetAccessPolicyResult> InvokeAsync(GetAccessPolicyArgs args, InvokeOptions? options = null)
            => Pulumi.Deployment.Instance.InvokeAsync<GetAccessPolicyResult>("google-native:accesscontextmanager/v1:getAccessPolicy", args ?? new GetAccessPolicyArgs(), options.WithDefaults());

        /// <summary>
        /// Returns an access policy based on the name.
        /// </summary>
        public static Output<GetAccessPolicyResult> Invoke(GetAccessPolicyInvokeArgs args, InvokeOptions? options = null)
            => Pulumi.Deployment.Instance.Invoke<GetAccessPolicyResult>("google-native:accesscontextmanager/v1:getAccessPolicy", args ?? new GetAccessPolicyInvokeArgs(), options.WithDefaults());
    }


    public sealed class GetAccessPolicyArgs : Pulumi.InvokeArgs
    {
        [Input("accessPolicyId", required: true)]
        public string AccessPolicyId { get; set; } = null!;

        public GetAccessPolicyArgs()
        {
        }
    }

    public sealed class GetAccessPolicyInvokeArgs : Pulumi.InvokeArgs
    {
        [Input("accessPolicyId", required: true)]
        public Input<string> AccessPolicyId { get; set; } = null!;

        public GetAccessPolicyInvokeArgs()
        {
        }
    }


    [OutputType]
    public sealed class GetAccessPolicyResult
    {
        /// <summary>
        /// An opaque identifier for the current version of the `AccessPolicy`. This will always be a strongly validated etag, meaning that two Access Polices will be identical if and only if their etags are identical. Clients should not expect this to be in any specific format.
        /// </summary>
        public readonly string Etag;
        /// <summary>
        /// Resource name of the `AccessPolicy`. Format: `accessPolicies/{access_policy}`
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// The parent of this `AccessPolicy` in the Cloud Resource Hierarchy. Currently immutable once created. Format: `organizations/{organization_id}`
        /// </summary>
        public readonly string Parent;
        /// <summary>
        /// The scopes of a policy define which resources an ACM policy can restrict, and where ACM resources can be referenced. For example, a policy with scopes=["folders/123"] has the following behavior: - vpcsc perimeters can only restrict projects within folders/123 - access levels can only be referenced by resources within folders/123. If empty, there are no limitations on which resources can be restricted by an ACM policy, and there are no limitations on where ACM resources can be referenced. Only one policy can include a given scope (attempting to create a second policy which includes "folders/123" will result in an error). Currently, scopes cannot be modified after a policy is created. Currently, policies can only have a single scope. Format: list of `folders/{folder_number}` or `projects/{project_number}`
        /// </summary>
        public readonly ImmutableArray<string> Scopes;
        /// <summary>
        /// Human readable title. Does not affect behavior.
        /// </summary>
        public readonly string Title;

        [OutputConstructor]
        private GetAccessPolicyResult(
            string etag,

            string name,

            string parent,

            ImmutableArray<string> scopes,

            string title)
        {
            Etag = etag;
            Name = name;
            Parent = parent;
            Scopes = scopes;
            Title = title;
        }
    }
}

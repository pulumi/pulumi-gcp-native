// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.AlloyDB.V1Beta
{
    /// <summary>
    /// The backup type, which suggests the trigger for the backup.
    /// </summary>
    [EnumType]
    public readonly struct BackupType : IEquatable<BackupType>
    {
        private readonly string _value;

        private BackupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Backup Type is unknown.
        /// </summary>
        public static BackupType TypeUnspecified { get; } = new BackupType("TYPE_UNSPECIFIED");
        /// <summary>
        /// ON_DEMAND backups that were triggered by the customer (e.g., not AUTOMATED).
        /// </summary>
        public static BackupType OnDemand { get; } = new BackupType("ON_DEMAND");
        /// <summary>
        /// AUTOMATED backups triggered by the automated backups scheduler pursuant to an automated backup policy.
        /// </summary>
        public static BackupType Automated { get; } = new BackupType("AUTOMATED");
        /// <summary>
        /// CONTINUOUS backups triggered by the automated backups scheduler due to a continuous backup policy.
        /// </summary>
        public static BackupType Continuous { get; } = new BackupType("CONTINUOUS");

        public static bool operator ==(BackupType left, BackupType right) => left.Equals(right);
        public static bool operator !=(BackupType left, BackupType right) => !left.Equals(right);

        public static explicit operator string(BackupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackupType other && Equals(other);
        public bool Equals(BackupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The database engine major version. This is an optional field and it is populated at the Cluster creation time. If a database version is not supplied at cluster creation time, then a default database version will be used.
    /// </summary>
    [EnumType]
    public readonly struct ClusterDatabaseVersion : IEquatable<ClusterDatabaseVersion>
    {
        private readonly string _value;

        private ClusterDatabaseVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is an unknown database version.
        /// </summary>
        public static ClusterDatabaseVersion DatabaseVersionUnspecified { get; } = new ClusterDatabaseVersion("DATABASE_VERSION_UNSPECIFIED");
        /// <summary>
        /// DEPRECATED - The database version is Postgres 13.
        /// </summary>
        public static ClusterDatabaseVersion Postgres13 { get; } = new ClusterDatabaseVersion("POSTGRES_13");
        /// <summary>
        /// The database version is Postgres 14.
        /// </summary>
        public static ClusterDatabaseVersion Postgres14 { get; } = new ClusterDatabaseVersion("POSTGRES_14");
        /// <summary>
        /// The database version is Postgres 15.
        /// </summary>
        public static ClusterDatabaseVersion Postgres15 { get; } = new ClusterDatabaseVersion("POSTGRES_15");

        public static bool operator ==(ClusterDatabaseVersion left, ClusterDatabaseVersion right) => left.Equals(right);
        public static bool operator !=(ClusterDatabaseVersion left, ClusterDatabaseVersion right) => !left.Equals(right);

        public static explicit operator string(ClusterDatabaseVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterDatabaseVersion other && Equals(other);
        public bool Equals(ClusterDatabaseVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Availability type of an Instance. If empty, defaults to REGIONAL for primary instances. For read pools, availability_type is always UNSPECIFIED. Instances in the read pools are evenly distributed across available zones within the region (i.e. read pools with more than one node will have a node in at least two zones).
    /// </summary>
    [EnumType]
    public readonly struct InstanceAvailabilityType : IEquatable<InstanceAvailabilityType>
    {
        private readonly string _value;

        private InstanceAvailabilityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is an unknown Availability type.
        /// </summary>
        public static InstanceAvailabilityType AvailabilityTypeUnspecified { get; } = new InstanceAvailabilityType("AVAILABILITY_TYPE_UNSPECIFIED");
        /// <summary>
        /// Zonal available instance.
        /// </summary>
        public static InstanceAvailabilityType Zonal { get; } = new InstanceAvailabilityType("ZONAL");
        /// <summary>
        /// Regional (or Highly) available instance.
        /// </summary>
        public static InstanceAvailabilityType Regional { get; } = new InstanceAvailabilityType("REGIONAL");

        public static bool operator ==(InstanceAvailabilityType left, InstanceAvailabilityType right) => left.Equals(right);
        public static bool operator !=(InstanceAvailabilityType left, InstanceAvailabilityType right) => !left.Equals(right);

        public static explicit operator string(InstanceAvailabilityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceAvailabilityType other && Equals(other);
        public bool Equals(InstanceAvailabilityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The type of the instance. Specified at creation time.
    /// </summary>
    [EnumType]
    public readonly struct InstanceInstanceType : IEquatable<InstanceInstanceType>
    {
        private readonly string _value;

        private InstanceInstanceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The type of the instance is unknown.
        /// </summary>
        public static InstanceInstanceType InstanceTypeUnspecified { get; } = new InstanceInstanceType("INSTANCE_TYPE_UNSPECIFIED");
        /// <summary>
        /// PRIMARY instances support read and write operations.
        /// </summary>
        public static InstanceInstanceType Primary { get; } = new InstanceInstanceType("PRIMARY");
        /// <summary>
        /// READ POOL instances support read operations only. Each read pool instance consists of one or more homogeneous nodes. * Read pool of size 1 can only have zonal availability. * Read pools with node count of 2 or more can have regional availability (nodes are present in 2 or more zones in a region).
        /// </summary>
        public static InstanceInstanceType ReadPool { get; } = new InstanceInstanceType("READ_POOL");
        /// <summary>
        /// SECONDARY instances support read operations only. SECONDARY instance is a cross-region read replica
        /// </summary>
        public static InstanceInstanceType Secondary { get; } = new InstanceInstanceType("SECONDARY");

        public static bool operator ==(InstanceInstanceType left, InstanceInstanceType right) => left.Equals(right);
        public static bool operator !=(InstanceInstanceType left, InstanceInstanceType right) => !left.Equals(right);

        public static explicit operator string(InstanceInstanceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceInstanceType other && Equals(other);
        public bool Equals(InstanceInstanceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Certificate Authority (CA) source. Only CA_SOURCE_MANAGED is supported currently, and is the default value.
    /// </summary>
    [EnumType]
    public readonly struct SslConfigCaSource : IEquatable<SslConfigCaSource>
    {
        private readonly string _value;

        private SslConfigCaSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Certificate Authority (CA) source not specified. Defaults to CA_SOURCE_MANAGED.
        /// </summary>
        public static SslConfigCaSource CaSourceUnspecified { get; } = new SslConfigCaSource("CA_SOURCE_UNSPECIFIED");
        /// <summary>
        /// Certificate Authority (CA) managed by the AlloyDB Cluster.
        /// </summary>
        public static SslConfigCaSource CaSourceManaged { get; } = new SslConfigCaSource("CA_SOURCE_MANAGED");

        public static bool operator ==(SslConfigCaSource left, SslConfigCaSource right) => left.Equals(right);
        public static bool operator !=(SslConfigCaSource left, SslConfigCaSource right) => !left.Equals(right);

        public static explicit operator string(SslConfigCaSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SslConfigCaSource other && Equals(other);
        public bool Equals(SslConfigCaSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. SSL mode. Specifies client-server SSL/TLS connection behavior.
    /// </summary>
    [EnumType]
    public readonly struct SslConfigSslMode : IEquatable<SslConfigSslMode>
    {
        private readonly string _value;

        private SslConfigSslMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// SSL mode not specified. Defaults to ENCRYPTED_ONLY.
        /// </summary>
        public static SslConfigSslMode SslModeUnspecified { get; } = new SslConfigSslMode("SSL_MODE_UNSPECIFIED");
        /// <summary>
        /// SSL connections are optional. CA verification not enforced.
        /// </summary>
        public static SslConfigSslMode SslModeAllow { get; } = new SslConfigSslMode("SSL_MODE_ALLOW");
        /// <summary>
        /// SSL connections are required. CA verification not enforced. Clients may use locally self-signed certificates (default psql client behavior).
        /// </summary>
        public static SslConfigSslMode SslModeRequire { get; } = new SslConfigSslMode("SSL_MODE_REQUIRE");
        /// <summary>
        /// SSL connections are required. CA verification enforced. Clients must have certificates signed by a Cluster CA, e.g. via GenerateClientCertificate.
        /// </summary>
        public static SslConfigSslMode SslModeVerifyCa { get; } = new SslConfigSslMode("SSL_MODE_VERIFY_CA");
        /// <summary>
        /// SSL connections are optional. CA verification not enforced.
        /// </summary>
        public static SslConfigSslMode AllowUnencryptedAndEncrypted { get; } = new SslConfigSslMode("ALLOW_UNENCRYPTED_AND_ENCRYPTED");
        /// <summary>
        /// SSL connections are required. CA verification not enforced.
        /// </summary>
        public static SslConfigSslMode EncryptedOnly { get; } = new SslConfigSslMode("ENCRYPTED_ONLY");

        public static bool operator ==(SslConfigSslMode left, SslConfigSslMode right) => left.Equals(right);
        public static bool operator !=(SslConfigSslMode left, SslConfigSslMode right) => !left.Equals(right);

        public static explicit operator string(SslConfigSslMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SslConfigSslMode other && Equals(other);
        public bool Equals(SslConfigSslMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Mode for updating the instance.
    /// </summary>
    [EnumType]
    public readonly struct UpdatePolicyMode : IEquatable<UpdatePolicyMode>
    {
        private readonly string _value;

        private UpdatePolicyMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Mode is unknown.
        /// </summary>
        public static UpdatePolicyMode ModeUnspecified { get; } = new UpdatePolicyMode("MODE_UNSPECIFIED");
        /// <summary>
        /// Least disruptive way to apply the update.
        /// </summary>
        public static UpdatePolicyMode Default { get; } = new UpdatePolicyMode("DEFAULT");
        /// <summary>
        /// Performs a forced update when applicable. This will be fast but may incur a downtime.
        /// </summary>
        public static UpdatePolicyMode ForceApply { get; } = new UpdatePolicyMode("FORCE_APPLY");

        public static bool operator ==(UpdatePolicyMode left, UpdatePolicyMode right) => left.Equals(right);
        public static bool operator !=(UpdatePolicyMode left, UpdatePolicyMode right) => !left.Equals(right);

        public static explicit operator string(UpdatePolicyMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UpdatePolicyMode other && Equals(other);
        public bool Equals(UpdatePolicyMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Type of this user.
    /// </summary>
    [EnumType]
    public readonly struct UserUserType : IEquatable<UserUserType>
    {
        private readonly string _value;

        private UserUserType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified user type.
        /// </summary>
        public static UserUserType UserTypeUnspecified { get; } = new UserUserType("USER_TYPE_UNSPECIFIED");
        /// <summary>
        /// The default user type that authenticates via password-based authentication.
        /// </summary>
        public static UserUserType AlloydbBuiltIn { get; } = new UserUserType("ALLOYDB_BUILT_IN");
        /// <summary>
        /// Database user that can authenticate via IAM-Based authentication.
        /// </summary>
        public static UserUserType AlloydbIamUser { get; } = new UserUserType("ALLOYDB_IAM_USER");

        public static bool operator ==(UserUserType left, UserUserType right) => left.Equals(right);
        public static bool operator !=(UserUserType left, UserUserType right) => !left.Equals(right);

        public static explicit operator string(UserUserType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UserUserType other && Equals(other);
        public bool Equals(UserUserType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct WeeklyScheduleDaysOfWeekItem : IEquatable<WeeklyScheduleDaysOfWeekItem>
    {
        private readonly string _value;

        private WeeklyScheduleDaysOfWeekItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The day of the week is unspecified.
        /// </summary>
        public static WeeklyScheduleDaysOfWeekItem DayOfWeekUnspecified { get; } = new WeeklyScheduleDaysOfWeekItem("DAY_OF_WEEK_UNSPECIFIED");
        /// <summary>
        /// Monday
        /// </summary>
        public static WeeklyScheduleDaysOfWeekItem Monday { get; } = new WeeklyScheduleDaysOfWeekItem("MONDAY");
        /// <summary>
        /// Tuesday
        /// </summary>
        public static WeeklyScheduleDaysOfWeekItem Tuesday { get; } = new WeeklyScheduleDaysOfWeekItem("TUESDAY");
        /// <summary>
        /// Wednesday
        /// </summary>
        public static WeeklyScheduleDaysOfWeekItem Wednesday { get; } = new WeeklyScheduleDaysOfWeekItem("WEDNESDAY");
        /// <summary>
        /// Thursday
        /// </summary>
        public static WeeklyScheduleDaysOfWeekItem Thursday { get; } = new WeeklyScheduleDaysOfWeekItem("THURSDAY");
        /// <summary>
        /// Friday
        /// </summary>
        public static WeeklyScheduleDaysOfWeekItem Friday { get; } = new WeeklyScheduleDaysOfWeekItem("FRIDAY");
        /// <summary>
        /// Saturday
        /// </summary>
        public static WeeklyScheduleDaysOfWeekItem Saturday { get; } = new WeeklyScheduleDaysOfWeekItem("SATURDAY");
        /// <summary>
        /// Sunday
        /// </summary>
        public static WeeklyScheduleDaysOfWeekItem Sunday { get; } = new WeeklyScheduleDaysOfWeekItem("SUNDAY");

        public static bool operator ==(WeeklyScheduleDaysOfWeekItem left, WeeklyScheduleDaysOfWeekItem right) => left.Equals(right);
        public static bool operator !=(WeeklyScheduleDaysOfWeekItem left, WeeklyScheduleDaysOfWeekItem right) => !left.Equals(right);

        public static explicit operator string(WeeklyScheduleDaysOfWeekItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WeeklyScheduleDaysOfWeekItem other && Equals(other);
        public bool Equals(WeeklyScheduleDaysOfWeekItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

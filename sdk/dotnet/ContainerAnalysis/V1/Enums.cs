// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.ContainerAnalysis.V1
{
    /// <summary>
    /// The alias kind.
    /// </summary>
    [EnumType]
    public readonly struct AliasContextKind : IEquatable<AliasContextKind>
    {
        private readonly string _value;

        private AliasContextKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static AliasContextKind KindUnspecified { get; } = new AliasContextKind("KIND_UNSPECIFIED");
        /// <summary>
        /// Git tag.
        /// </summary>
        public static AliasContextKind Fixed { get; } = new AliasContextKind("FIXED");
        /// <summary>
        /// Git branch.
        /// </summary>
        public static AliasContextKind Movable { get; } = new AliasContextKind("MOVABLE");
        /// <summary>
        /// Used to specify non-standard aliases. For example, if a Git repo has a ref named "refs/foo/bar".
        /// </summary>
        public static AliasContextKind Other { get; } = new AliasContextKind("OTHER");

        public static bool operator ==(AliasContextKind left, AliasContextKind right) => left.Equals(right);
        public static bool operator !=(AliasContextKind left, AliasContextKind right) => !left.Equals(right);

        public static explicit operator string(AliasContextKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AliasContextKind other && Equals(other);
        public bool Equals(AliasContextKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Provides the state of this Vulnerability assessment.
    /// </summary>
    [EnumType]
    public readonly struct AssessmentState : IEquatable<AssessmentState>
    {
        private readonly string _value;

        private AssessmentState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No state is specified.
        /// </summary>
        public static AssessmentState StateUnspecified { get; } = new AssessmentState("STATE_UNSPECIFIED");
        /// <summary>
        /// This product is known to be affected by this vulnerability.
        /// </summary>
        public static AssessmentState Affected { get; } = new AssessmentState("AFFECTED");
        /// <summary>
        /// This product is known to be not affected by this vulnerability.
        /// </summary>
        public static AssessmentState NotAffected { get; } = new AssessmentState("NOT_AFFECTED");
        /// <summary>
        /// This product contains a fix for this vulnerability.
        /// </summary>
        public static AssessmentState Fixed { get; } = new AssessmentState("FIXED");
        /// <summary>
        /// It is not known yet whether these versions are or are not affected by the vulnerability. However, it is still under investigation.
        /// </summary>
        public static AssessmentState UnderInvestigation { get; } = new AssessmentState("UNDER_INVESTIGATION");

        public static bool operator ==(AssessmentState left, AssessmentState right) => left.Equals(right);
        public static bool operator !=(AssessmentState left, AssessmentState right) => !left.Equals(right);

        public static explicit operator string(AssessmentState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AssessmentState other && Equals(other);
        public bool Equals(AssessmentState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSAttackComplexity : IEquatable<CVSSAttackComplexity>
    {
        private readonly string _value;

        private CVSSAttackComplexity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSAttackComplexity AttackComplexityUnspecified { get; } = new CVSSAttackComplexity("ATTACK_COMPLEXITY_UNSPECIFIED");
        public static CVSSAttackComplexity AttackComplexityLow { get; } = new CVSSAttackComplexity("ATTACK_COMPLEXITY_LOW");
        public static CVSSAttackComplexity AttackComplexityHigh { get; } = new CVSSAttackComplexity("ATTACK_COMPLEXITY_HIGH");

        public static bool operator ==(CVSSAttackComplexity left, CVSSAttackComplexity right) => left.Equals(right);
        public static bool operator !=(CVSSAttackComplexity left, CVSSAttackComplexity right) => !left.Equals(right);

        public static explicit operator string(CVSSAttackComplexity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSAttackComplexity other && Equals(other);
        public bool Equals(CVSSAttackComplexity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Base Metrics Represents the intrinsic characteristics of a vulnerability that are constant over time and across user environments.
    /// </summary>
    [EnumType]
    public readonly struct CVSSAttackVector : IEquatable<CVSSAttackVector>
    {
        private readonly string _value;

        private CVSSAttackVector(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSAttackVector AttackVectorUnspecified { get; } = new CVSSAttackVector("ATTACK_VECTOR_UNSPECIFIED");
        public static CVSSAttackVector AttackVectorNetwork { get; } = new CVSSAttackVector("ATTACK_VECTOR_NETWORK");
        public static CVSSAttackVector AttackVectorAdjacent { get; } = new CVSSAttackVector("ATTACK_VECTOR_ADJACENT");
        public static CVSSAttackVector AttackVectorLocal { get; } = new CVSSAttackVector("ATTACK_VECTOR_LOCAL");
        public static CVSSAttackVector AttackVectorPhysical { get; } = new CVSSAttackVector("ATTACK_VECTOR_PHYSICAL");

        public static bool operator ==(CVSSAttackVector left, CVSSAttackVector right) => left.Equals(right);
        public static bool operator !=(CVSSAttackVector left, CVSSAttackVector right) => !left.Equals(right);

        public static explicit operator string(CVSSAttackVector value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSAttackVector other && Equals(other);
        public bool Equals(CVSSAttackVector other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSAuthentication : IEquatable<CVSSAuthentication>
    {
        private readonly string _value;

        private CVSSAuthentication(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSAuthentication AuthenticationUnspecified { get; } = new CVSSAuthentication("AUTHENTICATION_UNSPECIFIED");
        public static CVSSAuthentication AuthenticationMultiple { get; } = new CVSSAuthentication("AUTHENTICATION_MULTIPLE");
        public static CVSSAuthentication AuthenticationSingle { get; } = new CVSSAuthentication("AUTHENTICATION_SINGLE");
        public static CVSSAuthentication AuthenticationNone { get; } = new CVSSAuthentication("AUTHENTICATION_NONE");

        public static bool operator ==(CVSSAuthentication left, CVSSAuthentication right) => left.Equals(right);
        public static bool operator !=(CVSSAuthentication left, CVSSAuthentication right) => !left.Equals(right);

        public static explicit operator string(CVSSAuthentication value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSAuthentication other && Equals(other);
        public bool Equals(CVSSAuthentication other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSAvailabilityImpact : IEquatable<CVSSAvailabilityImpact>
    {
        private readonly string _value;

        private CVSSAvailabilityImpact(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSAvailabilityImpact ImpactUnspecified { get; } = new CVSSAvailabilityImpact("IMPACT_UNSPECIFIED");
        public static CVSSAvailabilityImpact ImpactHigh { get; } = new CVSSAvailabilityImpact("IMPACT_HIGH");
        public static CVSSAvailabilityImpact ImpactLow { get; } = new CVSSAvailabilityImpact("IMPACT_LOW");
        public static CVSSAvailabilityImpact ImpactNone { get; } = new CVSSAvailabilityImpact("IMPACT_NONE");

        public static bool operator ==(CVSSAvailabilityImpact left, CVSSAvailabilityImpact right) => left.Equals(right);
        public static bool operator !=(CVSSAvailabilityImpact left, CVSSAvailabilityImpact right) => !left.Equals(right);

        public static explicit operator string(CVSSAvailabilityImpact value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSAvailabilityImpact other && Equals(other);
        public bool Equals(CVSSAvailabilityImpact other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSConfidentialityImpact : IEquatable<CVSSConfidentialityImpact>
    {
        private readonly string _value;

        private CVSSConfidentialityImpact(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSConfidentialityImpact ImpactUnspecified { get; } = new CVSSConfidentialityImpact("IMPACT_UNSPECIFIED");
        public static CVSSConfidentialityImpact ImpactHigh { get; } = new CVSSConfidentialityImpact("IMPACT_HIGH");
        public static CVSSConfidentialityImpact ImpactLow { get; } = new CVSSConfidentialityImpact("IMPACT_LOW");
        public static CVSSConfidentialityImpact ImpactNone { get; } = new CVSSConfidentialityImpact("IMPACT_NONE");

        public static bool operator ==(CVSSConfidentialityImpact left, CVSSConfidentialityImpact right) => left.Equals(right);
        public static bool operator !=(CVSSConfidentialityImpact left, CVSSConfidentialityImpact right) => !left.Equals(right);

        public static explicit operator string(CVSSConfidentialityImpact value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSConfidentialityImpact other && Equals(other);
        public bool Equals(CVSSConfidentialityImpact other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSIntegrityImpact : IEquatable<CVSSIntegrityImpact>
    {
        private readonly string _value;

        private CVSSIntegrityImpact(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSIntegrityImpact ImpactUnspecified { get; } = new CVSSIntegrityImpact("IMPACT_UNSPECIFIED");
        public static CVSSIntegrityImpact ImpactHigh { get; } = new CVSSIntegrityImpact("IMPACT_HIGH");
        public static CVSSIntegrityImpact ImpactLow { get; } = new CVSSIntegrityImpact("IMPACT_LOW");
        public static CVSSIntegrityImpact ImpactNone { get; } = new CVSSIntegrityImpact("IMPACT_NONE");

        public static bool operator ==(CVSSIntegrityImpact left, CVSSIntegrityImpact right) => left.Equals(right);
        public static bool operator !=(CVSSIntegrityImpact left, CVSSIntegrityImpact right) => !left.Equals(right);

        public static explicit operator string(CVSSIntegrityImpact value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSIntegrityImpact other && Equals(other);
        public bool Equals(CVSSIntegrityImpact other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSPrivilegesRequired : IEquatable<CVSSPrivilegesRequired>
    {
        private readonly string _value;

        private CVSSPrivilegesRequired(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSPrivilegesRequired PrivilegesRequiredUnspecified { get; } = new CVSSPrivilegesRequired("PRIVILEGES_REQUIRED_UNSPECIFIED");
        public static CVSSPrivilegesRequired PrivilegesRequiredNone { get; } = new CVSSPrivilegesRequired("PRIVILEGES_REQUIRED_NONE");
        public static CVSSPrivilegesRequired PrivilegesRequiredLow { get; } = new CVSSPrivilegesRequired("PRIVILEGES_REQUIRED_LOW");
        public static CVSSPrivilegesRequired PrivilegesRequiredHigh { get; } = new CVSSPrivilegesRequired("PRIVILEGES_REQUIRED_HIGH");

        public static bool operator ==(CVSSPrivilegesRequired left, CVSSPrivilegesRequired right) => left.Equals(right);
        public static bool operator !=(CVSSPrivilegesRequired left, CVSSPrivilegesRequired right) => !left.Equals(right);

        public static explicit operator string(CVSSPrivilegesRequired value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSPrivilegesRequired other && Equals(other);
        public bool Equals(CVSSPrivilegesRequired other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSScope : IEquatable<CVSSScope>
    {
        private readonly string _value;

        private CVSSScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSScope ScopeUnspecified { get; } = new CVSSScope("SCOPE_UNSPECIFIED");
        public static CVSSScope ScopeUnchanged { get; } = new CVSSScope("SCOPE_UNCHANGED");
        public static CVSSScope ScopeChanged { get; } = new CVSSScope("SCOPE_CHANGED");

        public static bool operator ==(CVSSScope left, CVSSScope right) => left.Equals(right);
        public static bool operator !=(CVSSScope left, CVSSScope right) => !left.Equals(right);

        public static explicit operator string(CVSSScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSScope other && Equals(other);
        public bool Equals(CVSSScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSUserInteraction : IEquatable<CVSSUserInteraction>
    {
        private readonly string _value;

        private CVSSUserInteraction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSUserInteraction UserInteractionUnspecified { get; } = new CVSSUserInteraction("USER_INTERACTION_UNSPECIFIED");
        public static CVSSUserInteraction UserInteractionNone { get; } = new CVSSUserInteraction("USER_INTERACTION_NONE");
        public static CVSSUserInteraction UserInteractionRequired { get; } = new CVSSUserInteraction("USER_INTERACTION_REQUIRED");

        public static bool operator ==(CVSSUserInteraction left, CVSSUserInteraction right) => left.Equals(right);
        public static bool operator !=(CVSSUserInteraction left, CVSSUserInteraction right) => !left.Equals(right);

        public static explicit operator string(CVSSUserInteraction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSUserInteraction other && Equals(other);
        public bool Equals(CVSSUserInteraction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSv3AttackComplexity : IEquatable<CVSSv3AttackComplexity>
    {
        private readonly string _value;

        private CVSSv3AttackComplexity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3AttackComplexity AttackComplexityUnspecified { get; } = new CVSSv3AttackComplexity("ATTACK_COMPLEXITY_UNSPECIFIED");
        public static CVSSv3AttackComplexity AttackComplexityLow { get; } = new CVSSv3AttackComplexity("ATTACK_COMPLEXITY_LOW");
        public static CVSSv3AttackComplexity AttackComplexityHigh { get; } = new CVSSv3AttackComplexity("ATTACK_COMPLEXITY_HIGH");

        public static bool operator ==(CVSSv3AttackComplexity left, CVSSv3AttackComplexity right) => left.Equals(right);
        public static bool operator !=(CVSSv3AttackComplexity left, CVSSv3AttackComplexity right) => !left.Equals(right);

        public static explicit operator string(CVSSv3AttackComplexity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3AttackComplexity other && Equals(other);
        public bool Equals(CVSSv3AttackComplexity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Base Metrics Represents the intrinsic characteristics of a vulnerability that are constant over time and across user environments.
    /// </summary>
    [EnumType]
    public readonly struct CVSSv3AttackVector : IEquatable<CVSSv3AttackVector>
    {
        private readonly string _value;

        private CVSSv3AttackVector(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3AttackVector AttackVectorUnspecified { get; } = new CVSSv3AttackVector("ATTACK_VECTOR_UNSPECIFIED");
        public static CVSSv3AttackVector AttackVectorNetwork { get; } = new CVSSv3AttackVector("ATTACK_VECTOR_NETWORK");
        public static CVSSv3AttackVector AttackVectorAdjacent { get; } = new CVSSv3AttackVector("ATTACK_VECTOR_ADJACENT");
        public static CVSSv3AttackVector AttackVectorLocal { get; } = new CVSSv3AttackVector("ATTACK_VECTOR_LOCAL");
        public static CVSSv3AttackVector AttackVectorPhysical { get; } = new CVSSv3AttackVector("ATTACK_VECTOR_PHYSICAL");

        public static bool operator ==(CVSSv3AttackVector left, CVSSv3AttackVector right) => left.Equals(right);
        public static bool operator !=(CVSSv3AttackVector left, CVSSv3AttackVector right) => !left.Equals(right);

        public static explicit operator string(CVSSv3AttackVector value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3AttackVector other && Equals(other);
        public bool Equals(CVSSv3AttackVector other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSv3AvailabilityImpact : IEquatable<CVSSv3AvailabilityImpact>
    {
        private readonly string _value;

        private CVSSv3AvailabilityImpact(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3AvailabilityImpact ImpactUnspecified { get; } = new CVSSv3AvailabilityImpact("IMPACT_UNSPECIFIED");
        public static CVSSv3AvailabilityImpact ImpactHigh { get; } = new CVSSv3AvailabilityImpact("IMPACT_HIGH");
        public static CVSSv3AvailabilityImpact ImpactLow { get; } = new CVSSv3AvailabilityImpact("IMPACT_LOW");
        public static CVSSv3AvailabilityImpact ImpactNone { get; } = new CVSSv3AvailabilityImpact("IMPACT_NONE");

        public static bool operator ==(CVSSv3AvailabilityImpact left, CVSSv3AvailabilityImpact right) => left.Equals(right);
        public static bool operator !=(CVSSv3AvailabilityImpact left, CVSSv3AvailabilityImpact right) => !left.Equals(right);

        public static explicit operator string(CVSSv3AvailabilityImpact value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3AvailabilityImpact other && Equals(other);
        public bool Equals(CVSSv3AvailabilityImpact other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSv3ConfidentialityImpact : IEquatable<CVSSv3ConfidentialityImpact>
    {
        private readonly string _value;

        private CVSSv3ConfidentialityImpact(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3ConfidentialityImpact ImpactUnspecified { get; } = new CVSSv3ConfidentialityImpact("IMPACT_UNSPECIFIED");
        public static CVSSv3ConfidentialityImpact ImpactHigh { get; } = new CVSSv3ConfidentialityImpact("IMPACT_HIGH");
        public static CVSSv3ConfidentialityImpact ImpactLow { get; } = new CVSSv3ConfidentialityImpact("IMPACT_LOW");
        public static CVSSv3ConfidentialityImpact ImpactNone { get; } = new CVSSv3ConfidentialityImpact("IMPACT_NONE");

        public static bool operator ==(CVSSv3ConfidentialityImpact left, CVSSv3ConfidentialityImpact right) => left.Equals(right);
        public static bool operator !=(CVSSv3ConfidentialityImpact left, CVSSv3ConfidentialityImpact right) => !left.Equals(right);

        public static explicit operator string(CVSSv3ConfidentialityImpact value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3ConfidentialityImpact other && Equals(other);
        public bool Equals(CVSSv3ConfidentialityImpact other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSv3IntegrityImpact : IEquatable<CVSSv3IntegrityImpact>
    {
        private readonly string _value;

        private CVSSv3IntegrityImpact(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3IntegrityImpact ImpactUnspecified { get; } = new CVSSv3IntegrityImpact("IMPACT_UNSPECIFIED");
        public static CVSSv3IntegrityImpact ImpactHigh { get; } = new CVSSv3IntegrityImpact("IMPACT_HIGH");
        public static CVSSv3IntegrityImpact ImpactLow { get; } = new CVSSv3IntegrityImpact("IMPACT_LOW");
        public static CVSSv3IntegrityImpact ImpactNone { get; } = new CVSSv3IntegrityImpact("IMPACT_NONE");

        public static bool operator ==(CVSSv3IntegrityImpact left, CVSSv3IntegrityImpact right) => left.Equals(right);
        public static bool operator !=(CVSSv3IntegrityImpact left, CVSSv3IntegrityImpact right) => !left.Equals(right);

        public static explicit operator string(CVSSv3IntegrityImpact value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3IntegrityImpact other && Equals(other);
        public bool Equals(CVSSv3IntegrityImpact other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSv3PrivilegesRequired : IEquatable<CVSSv3PrivilegesRequired>
    {
        private readonly string _value;

        private CVSSv3PrivilegesRequired(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3PrivilegesRequired PrivilegesRequiredUnspecified { get; } = new CVSSv3PrivilegesRequired("PRIVILEGES_REQUIRED_UNSPECIFIED");
        public static CVSSv3PrivilegesRequired PrivilegesRequiredNone { get; } = new CVSSv3PrivilegesRequired("PRIVILEGES_REQUIRED_NONE");
        public static CVSSv3PrivilegesRequired PrivilegesRequiredLow { get; } = new CVSSv3PrivilegesRequired("PRIVILEGES_REQUIRED_LOW");
        public static CVSSv3PrivilegesRequired PrivilegesRequiredHigh { get; } = new CVSSv3PrivilegesRequired("PRIVILEGES_REQUIRED_HIGH");

        public static bool operator ==(CVSSv3PrivilegesRequired left, CVSSv3PrivilegesRequired right) => left.Equals(right);
        public static bool operator !=(CVSSv3PrivilegesRequired left, CVSSv3PrivilegesRequired right) => !left.Equals(right);

        public static explicit operator string(CVSSv3PrivilegesRequired value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3PrivilegesRequired other && Equals(other);
        public bool Equals(CVSSv3PrivilegesRequired other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSv3Scope : IEquatable<CVSSv3Scope>
    {
        private readonly string _value;

        private CVSSv3Scope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3Scope ScopeUnspecified { get; } = new CVSSv3Scope("SCOPE_UNSPECIFIED");
        public static CVSSv3Scope ScopeUnchanged { get; } = new CVSSv3Scope("SCOPE_UNCHANGED");
        public static CVSSv3Scope ScopeChanged { get; } = new CVSSv3Scope("SCOPE_CHANGED");

        public static bool operator ==(CVSSv3Scope left, CVSSv3Scope right) => left.Equals(right);
        public static bool operator !=(CVSSv3Scope left, CVSSv3Scope right) => !left.Equals(right);

        public static explicit operator string(CVSSv3Scope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3Scope other && Equals(other);
        public bool Equals(CVSSv3Scope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSv3UserInteraction : IEquatable<CVSSv3UserInteraction>
    {
        private readonly string _value;

        private CVSSv3UserInteraction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3UserInteraction UserInteractionUnspecified { get; } = new CVSSv3UserInteraction("USER_INTERACTION_UNSPECIFIED");
        public static CVSSv3UserInteraction UserInteractionNone { get; } = new CVSSv3UserInteraction("USER_INTERACTION_NONE");
        public static CVSSv3UserInteraction UserInteractionRequired { get; } = new CVSSv3UserInteraction("USER_INTERACTION_REQUIRED");

        public static bool operator ==(CVSSv3UserInteraction left, CVSSv3UserInteraction right) => left.Equals(right);
        public static bool operator !=(CVSSv3UserInteraction left, CVSSv3UserInteraction right) => !left.Equals(right);

        public static explicit operator string(CVSSv3UserInteraction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3UserInteraction other && Equals(other);
        public bool Equals(CVSSv3UserInteraction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CisBenchmarkSeverity : IEquatable<CisBenchmarkSeverity>
    {
        private readonly string _value;

        private CisBenchmarkSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static CisBenchmarkSeverity SeverityUnspecified { get; } = new CisBenchmarkSeverity("SEVERITY_UNSPECIFIED");
        /// <summary>
        /// Minimal severity.
        /// </summary>
        public static CisBenchmarkSeverity Minimal { get; } = new CisBenchmarkSeverity("MINIMAL");
        /// <summary>
        /// Low severity.
        /// </summary>
        public static CisBenchmarkSeverity Low { get; } = new CisBenchmarkSeverity("LOW");
        /// <summary>
        /// Medium severity.
        /// </summary>
        public static CisBenchmarkSeverity Medium { get; } = new CisBenchmarkSeverity("MEDIUM");
        /// <summary>
        /// High severity.
        /// </summary>
        public static CisBenchmarkSeverity High { get; } = new CisBenchmarkSeverity("HIGH");
        /// <summary>
        /// Critical severity.
        /// </summary>
        public static CisBenchmarkSeverity Critical { get; } = new CisBenchmarkSeverity("CRITICAL");

        public static bool operator ==(CisBenchmarkSeverity left, CisBenchmarkSeverity right) => left.Equals(right);
        public static bool operator !=(CisBenchmarkSeverity left, CisBenchmarkSeverity right) => !left.Equals(right);

        public static explicit operator string(CisBenchmarkSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CisBenchmarkSeverity other && Equals(other);
        public bool Equals(CisBenchmarkSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Platform hosting this deployment.
    /// </summary>
    [EnumType]
    public readonly struct DeploymentOccurrencePlatform : IEquatable<DeploymentOccurrencePlatform>
    {
        private readonly string _value;

        private DeploymentOccurrencePlatform(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static DeploymentOccurrencePlatform PlatformUnspecified { get; } = new DeploymentOccurrencePlatform("PLATFORM_UNSPECIFIED");
        /// <summary>
        /// Google Container Engine.
        /// </summary>
        public static DeploymentOccurrencePlatform Gke { get; } = new DeploymentOccurrencePlatform("GKE");
        /// <summary>
        /// Google App Engine: Flexible Environment.
        /// </summary>
        public static DeploymentOccurrencePlatform Flex { get; } = new DeploymentOccurrencePlatform("FLEX");
        /// <summary>
        /// Custom user-defined platform.
        /// </summary>
        public static DeploymentOccurrencePlatform Custom { get; } = new DeploymentOccurrencePlatform("CUSTOM");

        public static bool operator ==(DeploymentOccurrencePlatform left, DeploymentOccurrencePlatform right) => left.Equals(right);
        public static bool operator !=(DeploymentOccurrencePlatform left, DeploymentOccurrencePlatform right) => !left.Equals(right);

        public static explicit operator string(DeploymentOccurrencePlatform value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeploymentOccurrencePlatform other && Equals(other);
        public bool Equals(DeploymentOccurrencePlatform other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Immutable. The kind of analysis that is handled by this discovery.
    /// </summary>
    [EnumType]
    public readonly struct DiscoveryNoteAnalysisKind : IEquatable<DiscoveryNoteAnalysisKind>
    {
        private readonly string _value;

        private DiscoveryNoteAnalysisKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This value is unused.
        /// </summary>
        public static DiscoveryNoteAnalysisKind NoteKindUnspecified { get; } = new DiscoveryNoteAnalysisKind("NOTE_KIND_UNSPECIFIED");
        /// <summary>
        /// The note and occurrence represent a package vulnerability.
        /// </summary>
        public static DiscoveryNoteAnalysisKind Vulnerability { get; } = new DiscoveryNoteAnalysisKind("VULNERABILITY");
        /// <summary>
        /// The note and occurrence assert build provenance.
        /// </summary>
        public static DiscoveryNoteAnalysisKind Build { get; } = new DiscoveryNoteAnalysisKind("BUILD");
        /// <summary>
        /// This represents an image basis relationship.
        /// </summary>
        public static DiscoveryNoteAnalysisKind Image { get; } = new DiscoveryNoteAnalysisKind("IMAGE");
        /// <summary>
        /// This represents a package installed via a package manager.
        /// </summary>
        public static DiscoveryNoteAnalysisKind Package { get; } = new DiscoveryNoteAnalysisKind("PACKAGE");
        /// <summary>
        /// The note and occurrence track deployment events.
        /// </summary>
        public static DiscoveryNoteAnalysisKind Deployment { get; } = new DiscoveryNoteAnalysisKind("DEPLOYMENT");
        /// <summary>
        /// The note and occurrence track the initial discovery status of a resource.
        /// </summary>
        public static DiscoveryNoteAnalysisKind Discovery { get; } = new DiscoveryNoteAnalysisKind("DISCOVERY");
        /// <summary>
        /// This represents a logical "role" that can attest to artifacts.
        /// </summary>
        public static DiscoveryNoteAnalysisKind Attestation { get; } = new DiscoveryNoteAnalysisKind("ATTESTATION");
        /// <summary>
        /// This represents an available package upgrade.
        /// </summary>
        public static DiscoveryNoteAnalysisKind Upgrade { get; } = new DiscoveryNoteAnalysisKind("UPGRADE");
        /// <summary>
        /// This represents a Compliance Note
        /// </summary>
        public static DiscoveryNoteAnalysisKind Compliance { get; } = new DiscoveryNoteAnalysisKind("COMPLIANCE");
        /// <summary>
        /// This represents a DSSE attestation Note
        /// </summary>
        public static DiscoveryNoteAnalysisKind DsseAttestation { get; } = new DiscoveryNoteAnalysisKind("DSSE_ATTESTATION");
        /// <summary>
        /// This represents a Vulnerability Assessment.
        /// </summary>
        public static DiscoveryNoteAnalysisKind VulnerabilityAssessment { get; } = new DiscoveryNoteAnalysisKind("VULNERABILITY_ASSESSMENT");

        public static bool operator ==(DiscoveryNoteAnalysisKind left, DiscoveryNoteAnalysisKind right) => left.Equals(right);
        public static bool operator !=(DiscoveryNoteAnalysisKind left, DiscoveryNoteAnalysisKind right) => !left.Equals(right);

        public static explicit operator string(DiscoveryNoteAnalysisKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiscoveryNoteAnalysisKind other && Equals(other);
        public bool Equals(DiscoveryNoteAnalysisKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of discovery for the resource.
    /// </summary>
    [EnumType]
    public readonly struct DiscoveryOccurrenceAnalysisStatus : IEquatable<DiscoveryOccurrenceAnalysisStatus>
    {
        private readonly string _value;

        private DiscoveryOccurrenceAnalysisStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static DiscoveryOccurrenceAnalysisStatus AnalysisStatusUnspecified { get; } = new DiscoveryOccurrenceAnalysisStatus("ANALYSIS_STATUS_UNSPECIFIED");
        /// <summary>
        /// Resource is known but no action has been taken yet.
        /// </summary>
        public static DiscoveryOccurrenceAnalysisStatus Pending { get; } = new DiscoveryOccurrenceAnalysisStatus("PENDING");
        /// <summary>
        /// Resource is being analyzed.
        /// </summary>
        public static DiscoveryOccurrenceAnalysisStatus Scanning { get; } = new DiscoveryOccurrenceAnalysisStatus("SCANNING");
        /// <summary>
        /// Analysis has finished successfully.
        /// </summary>
        public static DiscoveryOccurrenceAnalysisStatus FinishedSuccess { get; } = new DiscoveryOccurrenceAnalysisStatus("FINISHED_SUCCESS");
        /// <summary>
        /// Analysis has completed.
        /// </summary>
        public static DiscoveryOccurrenceAnalysisStatus Complete { get; } = new DiscoveryOccurrenceAnalysisStatus("COMPLETE");
        /// <summary>
        /// Analysis has finished unsuccessfully, the analysis itself is in a bad state.
        /// </summary>
        public static DiscoveryOccurrenceAnalysisStatus FinishedFailed { get; } = new DiscoveryOccurrenceAnalysisStatus("FINISHED_FAILED");
        /// <summary>
        /// The resource is known not to be supported.
        /// </summary>
        public static DiscoveryOccurrenceAnalysisStatus FinishedUnsupported { get; } = new DiscoveryOccurrenceAnalysisStatus("FINISHED_UNSUPPORTED");

        public static bool operator ==(DiscoveryOccurrenceAnalysisStatus left, DiscoveryOccurrenceAnalysisStatus right) => left.Equals(right);
        public static bool operator !=(DiscoveryOccurrenceAnalysisStatus left, DiscoveryOccurrenceAnalysisStatus right) => !left.Equals(right);

        public static explicit operator string(DiscoveryOccurrenceAnalysisStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiscoveryOccurrenceAnalysisStatus other && Equals(other);
        public bool Equals(DiscoveryOccurrenceAnalysisStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the resource is continuously analyzed.
    /// </summary>
    [EnumType]
    public readonly struct DiscoveryOccurrenceContinuousAnalysis : IEquatable<DiscoveryOccurrenceContinuousAnalysis>
    {
        private readonly string _value;

        private DiscoveryOccurrenceContinuousAnalysis(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static DiscoveryOccurrenceContinuousAnalysis ContinuousAnalysisUnspecified { get; } = new DiscoveryOccurrenceContinuousAnalysis("CONTINUOUS_ANALYSIS_UNSPECIFIED");
        /// <summary>
        /// The resource is continuously analyzed.
        /// </summary>
        public static DiscoveryOccurrenceContinuousAnalysis Active { get; } = new DiscoveryOccurrenceContinuousAnalysis("ACTIVE");
        /// <summary>
        /// The resource is ignored for continuous analysis.
        /// </summary>
        public static DiscoveryOccurrenceContinuousAnalysis Inactive { get; } = new DiscoveryOccurrenceContinuousAnalysis("INACTIVE");

        public static bool operator ==(DiscoveryOccurrenceContinuousAnalysis left, DiscoveryOccurrenceContinuousAnalysis right) => left.Equals(right);
        public static bool operator !=(DiscoveryOccurrenceContinuousAnalysis left, DiscoveryOccurrenceContinuousAnalysis right) => !left.Equals(right);

        public static explicit operator string(DiscoveryOccurrenceContinuousAnalysis value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiscoveryOccurrenceContinuousAnalysis other && Equals(other);
        public bool Equals(DiscoveryOccurrenceContinuousAnalysis other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The CPU architecture for which packages in this distribution channel were built.
    /// </summary>
    [EnumType]
    public readonly struct DistributionArchitecture : IEquatable<DistributionArchitecture>
    {
        private readonly string _value;

        private DistributionArchitecture(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown architecture.
        /// </summary>
        public static DistributionArchitecture ArchitectureUnspecified { get; } = new DistributionArchitecture("ARCHITECTURE_UNSPECIFIED");
        /// <summary>
        /// X86 architecture.
        /// </summary>
        public static DistributionArchitecture X86 { get; } = new DistributionArchitecture("X86");
        /// <summary>
        /// X64 architecture.
        /// </summary>
        public static DistributionArchitecture X64 { get; } = new DistributionArchitecture("X64");

        public static bool operator ==(DistributionArchitecture left, DistributionArchitecture right) => left.Equals(right);
        public static bool operator !=(DistributionArchitecture left, DistributionArchitecture right) => !left.Equals(right);

        public static explicit operator string(DistributionArchitecture value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionArchitecture other && Equals(other);
        public bool Equals(DistributionArchitecture other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The justification type for this vulnerability.
    /// </summary>
    [EnumType]
    public readonly struct JustificationJustificationType : IEquatable<JustificationJustificationType>
    {
        private readonly string _value;

        private JustificationJustificationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// JUSTIFICATION_TYPE_UNSPECIFIED.
        /// </summary>
        public static JustificationJustificationType JustificationTypeUnspecified { get; } = new JustificationJustificationType("JUSTIFICATION_TYPE_UNSPECIFIED");
        /// <summary>
        /// The vulnerable component is not present in the product.
        /// </summary>
        public static JustificationJustificationType ComponentNotPresent { get; } = new JustificationJustificationType("COMPONENT_NOT_PRESENT");
        /// <summary>
        /// The vulnerable code is not present. Typically this case occurs when source code is configured or built in a way that excludes the vulnerable code.
        /// </summary>
        public static JustificationJustificationType VulnerableCodeNotPresent { get; } = new JustificationJustificationType("VULNERABLE_CODE_NOT_PRESENT");
        /// <summary>
        /// The vulnerable code can not be executed. Typically this case occurs when the product includes the vulnerable code but does not call or use the vulnerable code.
        /// </summary>
        public static JustificationJustificationType VulnerableCodeNotInExecutePath { get; } = new JustificationJustificationType("VULNERABLE_CODE_NOT_IN_EXECUTE_PATH");
        /// <summary>
        /// The vulnerable code cannot be controlled by an attacker to exploit the vulnerability.
        /// </summary>
        public static JustificationJustificationType VulnerableCodeCannotBeControlledByAdversary { get; } = new JustificationJustificationType("VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY");
        /// <summary>
        /// The product includes built-in protections or features that prevent exploitation of the vulnerability. These built-in protections cannot be subverted by the attacker and cannot be configured or disabled by the user. These mitigations completely prevent exploitation based on known attack vectors.
        /// </summary>
        public static JustificationJustificationType InlineMitigationsAlreadyExist { get; } = new JustificationJustificationType("INLINE_MITIGATIONS_ALREADY_EXIST");

        public static bool operator ==(JustificationJustificationType left, JustificationJustificationType right) => left.Equals(right);
        public static bool operator !=(JustificationJustificationType left, JustificationJustificationType right) => !left.Equals(right);

        public static explicit operator string(JustificationJustificationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JustificationJustificationType other && Equals(other);
        public bool Equals(JustificationJustificationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The CPU architecture for which packages in this distribution channel were built. Architecture will be blank for language packages.
    /// </summary>
    [EnumType]
    public readonly struct PackageNoteArchitecture : IEquatable<PackageNoteArchitecture>
    {
        private readonly string _value;

        private PackageNoteArchitecture(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown architecture.
        /// </summary>
        public static PackageNoteArchitecture ArchitectureUnspecified { get; } = new PackageNoteArchitecture("ARCHITECTURE_UNSPECIFIED");
        /// <summary>
        /// X86 architecture.
        /// </summary>
        public static PackageNoteArchitecture X86 { get; } = new PackageNoteArchitecture("X86");
        /// <summary>
        /// X64 architecture.
        /// </summary>
        public static PackageNoteArchitecture X64 { get; } = new PackageNoteArchitecture("X64");

        public static bool operator ==(PackageNoteArchitecture left, PackageNoteArchitecture right) => left.Equals(right);
        public static bool operator !=(PackageNoteArchitecture left, PackageNoteArchitecture right) => !left.Equals(right);

        public static explicit operator string(PackageNoteArchitecture value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PackageNoteArchitecture other && Equals(other);
        public bool Equals(PackageNoteArchitecture other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of remediation that can be applied.
    /// </summary>
    [EnumType]
    public readonly struct RemediationRemediationType : IEquatable<RemediationRemediationType>
    {
        private readonly string _value;

        private RemediationRemediationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No remediation type specified.
        /// </summary>
        public static RemediationRemediationType RemediationTypeUnspecified { get; } = new RemediationRemediationType("REMEDIATION_TYPE_UNSPECIFIED");
        /// <summary>
        /// A MITIGATION is available.
        /// </summary>
        public static RemediationRemediationType Mitigation { get; } = new RemediationRemediationType("MITIGATION");
        /// <summary>
        /// No fix is planned.
        /// </summary>
        public static RemediationRemediationType NoFixPlanned { get; } = new RemediationRemediationType("NO_FIX_PLANNED");
        /// <summary>
        /// Not available.
        /// </summary>
        public static RemediationRemediationType NoneAvailable { get; } = new RemediationRemediationType("NONE_AVAILABLE");
        /// <summary>
        /// A vendor fix is available.
        /// </summary>
        public static RemediationRemediationType VendorFix { get; } = new RemediationRemediationType("VENDOR_FIX");
        /// <summary>
        /// A workaround is available.
        /// </summary>
        public static RemediationRemediationType Workaround { get; } = new RemediationRemediationType("WORKAROUND");

        public static bool operator ==(RemediationRemediationType left, RemediationRemediationType right) => left.Equals(right);
        public static bool operator !=(RemediationRemediationType left, RemediationRemediationType right) => !left.Equals(right);

        public static explicit operator string(RemediationRemediationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RemediationRemediationType other && Equals(other);
        public bool Equals(RemediationRemediationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Distinguishes between sentinel MIN/MAX versions and normal versions.
    /// </summary>
    [EnumType]
    public readonly struct VersionKind : IEquatable<VersionKind>
    {
        private readonly string _value;

        private VersionKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static VersionKind VersionKindUnspecified { get; } = new VersionKind("VERSION_KIND_UNSPECIFIED");
        /// <summary>
        /// A standard package version.
        /// </summary>
        public static VersionKind Normal { get; } = new VersionKind("NORMAL");
        /// <summary>
        /// A special version representing negative infinity.
        /// </summary>
        public static VersionKind Minimum { get; } = new VersionKind("MINIMUM");
        /// <summary>
        /// A special version representing positive infinity.
        /// </summary>
        public static VersionKind Maximum { get; } = new VersionKind("MAXIMUM");

        public static bool operator ==(VersionKind left, VersionKind right) => left.Equals(right);
        public static bool operator !=(VersionKind left, VersionKind right) => !left.Equals(right);

        public static explicit operator string(VersionKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VersionKind other && Equals(other);
        public bool Equals(VersionKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Provides the state of this Vulnerability assessment.
    /// </summary>
    [EnumType]
    public readonly struct VexAssessmentState : IEquatable<VexAssessmentState>
    {
        private readonly string _value;

        private VexAssessmentState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No state is specified.
        /// </summary>
        public static VexAssessmentState StateUnspecified { get; } = new VexAssessmentState("STATE_UNSPECIFIED");
        /// <summary>
        /// This product is known to be affected by this vulnerability.
        /// </summary>
        public static VexAssessmentState Affected { get; } = new VexAssessmentState("AFFECTED");
        /// <summary>
        /// This product is known to be not affected by this vulnerability.
        /// </summary>
        public static VexAssessmentState NotAffected { get; } = new VexAssessmentState("NOT_AFFECTED");
        /// <summary>
        /// This product contains a fix for this vulnerability.
        /// </summary>
        public static VexAssessmentState Fixed { get; } = new VexAssessmentState("FIXED");
        /// <summary>
        /// It is not known yet whether these versions are or are not affected by the vulnerability. However, it is still under investigation.
        /// </summary>
        public static VexAssessmentState UnderInvestigation { get; } = new VexAssessmentState("UNDER_INVESTIGATION");

        public static bool operator ==(VexAssessmentState left, VexAssessmentState right) => left.Equals(right);
        public static bool operator !=(VexAssessmentState left, VexAssessmentState right) => !left.Equals(right);

        public static explicit operator string(VexAssessmentState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VexAssessmentState other && Equals(other);
        public bool Equals(VexAssessmentState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// CVSS version used to populate cvss_score and severity.
    /// </summary>
    [EnumType]
    public readonly struct VulnerabilityNoteCvssVersion : IEquatable<VulnerabilityNoteCvssVersion>
    {
        private readonly string _value;

        private VulnerabilityNoteCvssVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VulnerabilityNoteCvssVersion CvssVersionUnspecified { get; } = new VulnerabilityNoteCvssVersion("CVSS_VERSION_UNSPECIFIED");
        public static VulnerabilityNoteCvssVersion CvssVersion2 { get; } = new VulnerabilityNoteCvssVersion("CVSS_VERSION_2");
        public static VulnerabilityNoteCvssVersion CvssVersion3 { get; } = new VulnerabilityNoteCvssVersion("CVSS_VERSION_3");

        public static bool operator ==(VulnerabilityNoteCvssVersion left, VulnerabilityNoteCvssVersion right) => left.Equals(right);
        public static bool operator !=(VulnerabilityNoteCvssVersion left, VulnerabilityNoteCvssVersion right) => !left.Equals(right);

        public static explicit operator string(VulnerabilityNoteCvssVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VulnerabilityNoteCvssVersion other && Equals(other);
        public bool Equals(VulnerabilityNoteCvssVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The note provider assigned severity of this vulnerability.
    /// </summary>
    [EnumType]
    public readonly struct VulnerabilityNoteSeverity : IEquatable<VulnerabilityNoteSeverity>
    {
        private readonly string _value;

        private VulnerabilityNoteSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static VulnerabilityNoteSeverity SeverityUnspecified { get; } = new VulnerabilityNoteSeverity("SEVERITY_UNSPECIFIED");
        /// <summary>
        /// Minimal severity.
        /// </summary>
        public static VulnerabilityNoteSeverity Minimal { get; } = new VulnerabilityNoteSeverity("MINIMAL");
        /// <summary>
        /// Low severity.
        /// </summary>
        public static VulnerabilityNoteSeverity Low { get; } = new VulnerabilityNoteSeverity("LOW");
        /// <summary>
        /// Medium severity.
        /// </summary>
        public static VulnerabilityNoteSeverity Medium { get; } = new VulnerabilityNoteSeverity("MEDIUM");
        /// <summary>
        /// High severity.
        /// </summary>
        public static VulnerabilityNoteSeverity High { get; } = new VulnerabilityNoteSeverity("HIGH");
        /// <summary>
        /// Critical severity.
        /// </summary>
        public static VulnerabilityNoteSeverity Critical { get; } = new VulnerabilityNoteSeverity("CRITICAL");

        public static bool operator ==(VulnerabilityNoteSeverity left, VulnerabilityNoteSeverity right) => left.Equals(right);
        public static bool operator !=(VulnerabilityNoteSeverity left, VulnerabilityNoteSeverity right) => !left.Equals(right);

        public static explicit operator string(VulnerabilityNoteSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VulnerabilityNoteSeverity other && Equals(other);
        public bool Equals(VulnerabilityNoteSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The distro assigned severity for this vulnerability when it is available, otherwise this is the note provider assigned severity. When there are multiple PackageIssues for this vulnerability, they can have different effective severities because some might be provided by the distro while others are provided by the language ecosystem for a language pack. For this reason, it is advised to use the effective severity on the PackageIssue level. In the case where multiple PackageIssues have differing effective severities, this field should be the highest severity for any of the PackageIssues.
    /// </summary>
    [EnumType]
    public readonly struct VulnerabilityOccurrenceEffectiveSeverity : IEquatable<VulnerabilityOccurrenceEffectiveSeverity>
    {
        private readonly string _value;

        private VulnerabilityOccurrenceEffectiveSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static VulnerabilityOccurrenceEffectiveSeverity SeverityUnspecified { get; } = new VulnerabilityOccurrenceEffectiveSeverity("SEVERITY_UNSPECIFIED");
        /// <summary>
        /// Minimal severity.
        /// </summary>
        public static VulnerabilityOccurrenceEffectiveSeverity Minimal { get; } = new VulnerabilityOccurrenceEffectiveSeverity("MINIMAL");
        /// <summary>
        /// Low severity.
        /// </summary>
        public static VulnerabilityOccurrenceEffectiveSeverity Low { get; } = new VulnerabilityOccurrenceEffectiveSeverity("LOW");
        /// <summary>
        /// Medium severity.
        /// </summary>
        public static VulnerabilityOccurrenceEffectiveSeverity Medium { get; } = new VulnerabilityOccurrenceEffectiveSeverity("MEDIUM");
        /// <summary>
        /// High severity.
        /// </summary>
        public static VulnerabilityOccurrenceEffectiveSeverity High { get; } = new VulnerabilityOccurrenceEffectiveSeverity("HIGH");
        /// <summary>
        /// Critical severity.
        /// </summary>
        public static VulnerabilityOccurrenceEffectiveSeverity Critical { get; } = new VulnerabilityOccurrenceEffectiveSeverity("CRITICAL");

        public static bool operator ==(VulnerabilityOccurrenceEffectiveSeverity left, VulnerabilityOccurrenceEffectiveSeverity right) => left.Equals(right);
        public static bool operator !=(VulnerabilityOccurrenceEffectiveSeverity left, VulnerabilityOccurrenceEffectiveSeverity right) => !left.Equals(right);

        public static explicit operator string(VulnerabilityOccurrenceEffectiveSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VulnerabilityOccurrenceEffectiveSeverity other && Equals(other);
        public bool Equals(VulnerabilityOccurrenceEffectiveSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

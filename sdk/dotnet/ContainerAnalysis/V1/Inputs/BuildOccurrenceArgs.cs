// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.GoogleNative.ContainerAnalysis.V1.Inputs
{

    /// <summary>
    /// Details of a build occurrence.
    /// </summary>
    public sealed class BuildOccurrenceArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// In-Toto Slsa Provenance V1 represents a slsa provenance meeting the slsa spec, wrapped in an in-toto statement. This allows for direct jsonification of a to-spec in-toto slsa statement with a to-spec slsa provenance.
        /// </summary>
        [Input("inTotoSlsaProvenanceV1")]
        public Input<Inputs.InTotoSlsaProvenanceV1Args>? InTotoSlsaProvenanceV1 { get; set; }

        /// <summary>
        /// Deprecated. See InTotoStatement for the replacement. In-toto Provenance representation as defined in spec.
        /// </summary>
        [Input("intotoProvenance")]
        public Input<Inputs.InTotoProvenanceArgs>? IntotoProvenance { get; set; }

        /// <summary>
        /// In-toto Statement representation as defined in spec. The intoto_statement can contain any type of provenance. The serialized payload of the statement can be stored and signed in the Occurrence's envelope.
        /// </summary>
        [Input("intotoStatement")]
        public Input<Inputs.InTotoStatementArgs>? IntotoStatement { get; set; }

        /// <summary>
        /// The actual provenance for the build.
        /// </summary>
        [Input("provenance")]
        public Input<Inputs.BuildProvenanceArgs>? Provenance { get; set; }

        /// <summary>
        /// Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
        /// </summary>
        [Input("provenanceBytes")]
        public Input<string>? ProvenanceBytes { get; set; }

        public BuildOccurrenceArgs()
        {
        }
        public static new BuildOccurrenceArgs Empty => new BuildOccurrenceArgs();
    }
}

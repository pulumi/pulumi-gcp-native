// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.ContainerAnalysis.V1Alpha1
{
    /// <summary>
    /// The type of the key, either stored in `public_key` or referenced in `key_id`
    /// </summary>
    [EnumType]
    public readonly struct BuildSignatureKeyType : IEquatable<BuildSignatureKeyType>
    {
        private readonly string _value;

        private BuildSignatureKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// `KeyType` is not set.
        /// </summary>
        public static BuildSignatureKeyType KeyTypeUnspecified { get; } = new BuildSignatureKeyType("KEY_TYPE_UNSPECIFIED");
        /// <summary>
        /// `PGP ASCII Armored` public key.
        /// </summary>
        public static BuildSignatureKeyType PgpAsciiArmored { get; } = new BuildSignatureKeyType("PGP_ASCII_ARMORED");
        /// <summary>
        /// `PKIX PEM` public key.
        /// </summary>
        public static BuildSignatureKeyType PkixPem { get; } = new BuildSignatureKeyType("PKIX_PEM");

        public static bool operator ==(BuildSignatureKeyType left, BuildSignatureKeyType right) => left.Equals(right);
        public static bool operator !=(BuildSignatureKeyType left, BuildSignatureKeyType right) => !left.Equals(right);

        public static explicit operator string(BuildSignatureKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BuildSignatureKeyType other && Equals(other);
        public bool Equals(BuildSignatureKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The severity level of this CIS benchmark check.
    /// </summary>
    [EnumType]
    public readonly struct CisBenchmarkSeverity : IEquatable<CisBenchmarkSeverity>
    {
        private readonly string _value;

        private CisBenchmarkSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown Impact
        /// </summary>
        public static CisBenchmarkSeverity SeverityUnspecified { get; } = new CisBenchmarkSeverity("SEVERITY_UNSPECIFIED");
        /// <summary>
        /// Minimal Impact
        /// </summary>
        public static CisBenchmarkSeverity Minimal { get; } = new CisBenchmarkSeverity("MINIMAL");
        /// <summary>
        /// Low Impact
        /// </summary>
        public static CisBenchmarkSeverity Low { get; } = new CisBenchmarkSeverity("LOW");
        /// <summary>
        /// Medium Impact
        /// </summary>
        public static CisBenchmarkSeverity Medium { get; } = new CisBenchmarkSeverity("MEDIUM");
        /// <summary>
        /// High Impact
        /// </summary>
        public static CisBenchmarkSeverity High { get; } = new CisBenchmarkSeverity("HIGH");
        /// <summary>
        /// Critical Impact
        /// </summary>
        public static CisBenchmarkSeverity Critical { get; } = new CisBenchmarkSeverity("CRITICAL");

        public static bool operator ==(CisBenchmarkSeverity left, CisBenchmarkSeverity right) => left.Equals(right);
        public static bool operator !=(CisBenchmarkSeverity left, CisBenchmarkSeverity right) => !left.Equals(right);

        public static explicit operator string(CisBenchmarkSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CisBenchmarkSeverity other && Equals(other);
        public bool Equals(CisBenchmarkSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Platform hosting this deployment.
    /// </summary>
    [EnumType]
    public readonly struct DeploymentPlatform : IEquatable<DeploymentPlatform>
    {
        private readonly string _value;

        private DeploymentPlatform(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown
        /// </summary>
        public static DeploymentPlatform PlatformUnspecified { get; } = new DeploymentPlatform("PLATFORM_UNSPECIFIED");
        /// <summary>
        /// Google Container Engine
        /// </summary>
        public static DeploymentPlatform Gke { get; } = new DeploymentPlatform("GKE");
        /// <summary>
        /// Google App Engine: Flexible Environment
        /// </summary>
        public static DeploymentPlatform Flex { get; } = new DeploymentPlatform("FLEX");
        /// <summary>
        /// Custom user-defined platform
        /// </summary>
        public static DeploymentPlatform Custom { get; } = new DeploymentPlatform("CUSTOM");

        public static bool operator ==(DeploymentPlatform left, DeploymentPlatform right) => left.Equals(right);
        public static bool operator !=(DeploymentPlatform left, DeploymentPlatform right) => !left.Equals(right);

        public static explicit operator string(DeploymentPlatform value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeploymentPlatform other && Equals(other);
        public bool Equals(DeploymentPlatform other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of discovery for the resource.
    /// </summary>
    [EnumType]
    public readonly struct DiscoveredAnalysisStatus : IEquatable<DiscoveredAnalysisStatus>
    {
        private readonly string _value;

        private DiscoveredAnalysisStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown
        /// </summary>
        public static DiscoveredAnalysisStatus AnalysisStatusUnspecified { get; } = new DiscoveredAnalysisStatus("ANALYSIS_STATUS_UNSPECIFIED");
        /// <summary>
        /// Resource is known but no action has been taken yet.
        /// </summary>
        public static DiscoveredAnalysisStatus Pending { get; } = new DiscoveredAnalysisStatus("PENDING");
        /// <summary>
        /// Resource is being analyzed.
        /// </summary>
        public static DiscoveredAnalysisStatus Scanning { get; } = new DiscoveredAnalysisStatus("SCANNING");
        /// <summary>
        /// Analysis has finished successfully.
        /// </summary>
        public static DiscoveredAnalysisStatus FinishedSuccess { get; } = new DiscoveredAnalysisStatus("FINISHED_SUCCESS");
        /// <summary>
        /// Analysis has finished unsuccessfully, the analysis itself is in a bad state.
        /// </summary>
        public static DiscoveredAnalysisStatus FinishedFailed { get; } = new DiscoveredAnalysisStatus("FINISHED_FAILED");
        /// <summary>
        /// The resource is known not to be supported.
        /// </summary>
        public static DiscoveredAnalysisStatus FinishedUnsupported { get; } = new DiscoveredAnalysisStatus("FINISHED_UNSUPPORTED");

        public static bool operator ==(DiscoveredAnalysisStatus left, DiscoveredAnalysisStatus right) => left.Equals(right);
        public static bool operator !=(DiscoveredAnalysisStatus left, DiscoveredAnalysisStatus right) => !left.Equals(right);

        public static explicit operator string(DiscoveredAnalysisStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiscoveredAnalysisStatus other && Equals(other);
        public bool Equals(DiscoveredAnalysisStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the resource is continuously analyzed.
    /// </summary>
    [EnumType]
    public readonly struct DiscoveredContinuousAnalysis : IEquatable<DiscoveredContinuousAnalysis>
    {
        private readonly string _value;

        private DiscoveredContinuousAnalysis(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown
        /// </summary>
        public static DiscoveredContinuousAnalysis ContinuousAnalysisUnspecified { get; } = new DiscoveredContinuousAnalysis("CONTINUOUS_ANALYSIS_UNSPECIFIED");
        /// <summary>
        /// The resource is continuously analyzed.
        /// </summary>
        public static DiscoveredContinuousAnalysis Active { get; } = new DiscoveredContinuousAnalysis("ACTIVE");
        /// <summary>
        /// The resource is ignored for continuous analysis.
        /// </summary>
        public static DiscoveredContinuousAnalysis Inactive { get; } = new DiscoveredContinuousAnalysis("INACTIVE");

        public static bool operator ==(DiscoveredContinuousAnalysis left, DiscoveredContinuousAnalysis right) => left.Equals(right);
        public static bool operator !=(DiscoveredContinuousAnalysis left, DiscoveredContinuousAnalysis right) => !left.Equals(right);

        public static explicit operator string(DiscoveredContinuousAnalysis value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiscoveredContinuousAnalysis other && Equals(other);
        public bool Equals(DiscoveredContinuousAnalysis other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kind of analysis that is handled by this discovery.
    /// </summary>
    [EnumType]
    public readonly struct DiscoveryAnalysisKind : IEquatable<DiscoveryAnalysisKind>
    {
        private readonly string _value;

        private DiscoveryAnalysisKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown
        /// </summary>
        public static DiscoveryAnalysisKind KindUnspecified { get; } = new DiscoveryAnalysisKind("KIND_UNSPECIFIED");
        /// <summary>
        /// The note and occurrence represent a package vulnerability.
        /// </summary>
        public static DiscoveryAnalysisKind PackageVulnerability { get; } = new DiscoveryAnalysisKind("PACKAGE_VULNERABILITY");
        /// <summary>
        /// The note and occurrence assert build provenance.
        /// </summary>
        public static DiscoveryAnalysisKind BuildDetails { get; } = new DiscoveryAnalysisKind("BUILD_DETAILS");
        /// <summary>
        /// This represents an image basis relationship.
        /// </summary>
        public static DiscoveryAnalysisKind ImageBasis { get; } = new DiscoveryAnalysisKind("IMAGE_BASIS");
        /// <summary>
        /// This represents a package installed via a package manager.
        /// </summary>
        public static DiscoveryAnalysisKind PackageManager { get; } = new DiscoveryAnalysisKind("PACKAGE_MANAGER");
        /// <summary>
        /// The note and occurrence track deployment events.
        /// </summary>
        public static DiscoveryAnalysisKind Deployable { get; } = new DiscoveryAnalysisKind("DEPLOYABLE");
        /// <summary>
        /// The note and occurrence track the initial discovery status of a resource.
        /// </summary>
        public static DiscoveryAnalysisKind Discovery { get; } = new DiscoveryAnalysisKind("DISCOVERY");
        /// <summary>
        /// This represents a logical "role" that can attest to artifacts.
        /// </summary>
        public static DiscoveryAnalysisKind AttestationAuthority { get; } = new DiscoveryAnalysisKind("ATTESTATION_AUTHORITY");
        /// <summary>
        /// This represents an available software upgrade.
        /// </summary>
        public static DiscoveryAnalysisKind Upgrade { get; } = new DiscoveryAnalysisKind("UPGRADE");
        /// <summary>
        /// This represents a compliance check that can be applied to a resource.
        /// </summary>
        public static DiscoveryAnalysisKind Compliance { get; } = new DiscoveryAnalysisKind("COMPLIANCE");

        public static bool operator ==(DiscoveryAnalysisKind left, DiscoveryAnalysisKind right) => left.Equals(right);
        public static bool operator !=(DiscoveryAnalysisKind left, DiscoveryAnalysisKind right) => !left.Equals(right);

        public static explicit operator string(DiscoveryAnalysisKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiscoveryAnalysisKind other && Equals(other);
        public bool Equals(DiscoveryAnalysisKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The CPU architecture for which packages in this distribution channel were built
    /// </summary>
    [EnumType]
    public readonly struct DistributionArchitecture : IEquatable<DistributionArchitecture>
    {
        private readonly string _value;

        private DistributionArchitecture(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown architecture
        /// </summary>
        public static DistributionArchitecture ArchitectureUnspecified { get; } = new DistributionArchitecture("ARCHITECTURE_UNSPECIFIED");
        /// <summary>
        /// X86 architecture
        /// </summary>
        public static DistributionArchitecture X86 { get; } = new DistributionArchitecture("X86");
        /// <summary>
        /// X64 architecture
        /// </summary>
        public static DistributionArchitecture X64 { get; } = new DistributionArchitecture("X64");

        public static bool operator ==(DistributionArchitecture left, DistributionArchitecture right) => left.Equals(right);
        public static bool operator !=(DistributionArchitecture left, DistributionArchitecture right) => !left.Equals(right);

        public static explicit operator string(DistributionArchitecture value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionArchitecture other && Equals(other);
        public bool Equals(DistributionArchitecture other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The alias kind.
    /// </summary>
    [EnumType]
    public readonly struct GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind : IEquatable<GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind>
    {
        private readonly string _value;

        private GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind KindUnspecified { get; } = new GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind("KIND_UNSPECIFIED");
        /// <summary>
        /// Git tag.
        /// </summary>
        public static GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind Fixed { get; } = new GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind("FIXED");
        /// <summary>
        /// Git branch.
        /// </summary>
        public static GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind Movable { get; } = new GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind("MOVABLE");
        /// <summary>
        /// Used to specify non-standard aliases. For example, if a Git repo has a ref named "refs/foo/bar".
        /// </summary>
        public static GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind Other { get; } = new GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind("OTHER");

        public static bool operator ==(GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind left, GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind right) => left.Equals(right);
        public static bool operator !=(GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind left, GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind right) => !left.Equals(right);

        public static explicit operator string(GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind other && Equals(other);
        public bool Equals(GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of hash that was performed.
    /// </summary>
    [EnumType]
    public readonly struct HashType : IEquatable<HashType>
    {
        private readonly string _value;

        private HashType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No hash requested.
        /// </summary>
        public static HashType None { get; } = new HashType("NONE");
        /// <summary>
        /// A sha256 hash.
        /// </summary>
        public static HashType Sha256 { get; } = new HashType("SHA256");

        public static bool operator ==(HashType left, HashType right) => left.Equals(right);
        public static bool operator !=(HashType left, HashType right) => !left.Equals(right);

        public static explicit operator string(HashType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HashType other && Equals(other);
        public bool Equals(HashType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The recovered Dockerfile directive used to construct this layer.
    /// </summary>
    [EnumType]
    public readonly struct LayerDirective : IEquatable<LayerDirective>
    {
        private readonly string _value;

        private LayerDirective(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value for unsupported/missing directive
        /// </summary>
        public static LayerDirective DirectiveUnspecified { get; } = new LayerDirective("DIRECTIVE_UNSPECIFIED");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Maintainer { get; } = new LayerDirective("MAINTAINER");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Run { get; } = new LayerDirective("RUN");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Cmd { get; } = new LayerDirective("CMD");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Label { get; } = new LayerDirective("LABEL");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Expose { get; } = new LayerDirective("EXPOSE");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Env { get; } = new LayerDirective("ENV");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Add { get; } = new LayerDirective("ADD");
        /// <summary>
        /// https://docs.docker.com/reference/builder/#copy
        /// </summary>
        public static LayerDirective Copy { get; } = new LayerDirective("COPY");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Entrypoint { get; } = new LayerDirective("ENTRYPOINT");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Volume { get; } = new LayerDirective("VOLUME");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective User { get; } = new LayerDirective("USER");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Workdir { get; } = new LayerDirective("WORKDIR");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Arg { get; } = new LayerDirective("ARG");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Onbuild { get; } = new LayerDirective("ONBUILD");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Stopsignal { get; } = new LayerDirective("STOPSIGNAL");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Healthcheck { get; } = new LayerDirective("HEALTHCHECK");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Shell { get; } = new LayerDirective("SHELL");

        public static bool operator ==(LayerDirective left, LayerDirective right) => left.Equals(right);
        public static bool operator !=(LayerDirective left, LayerDirective right) => !left.Equals(right);

        public static explicit operator string(LayerDirective value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LayerDirective other && Equals(other);
        public bool Equals(LayerDirective other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
    /// </summary>
    [EnumType]
    public readonly struct PgpSignedAttestationContentType : IEquatable<PgpSignedAttestationContentType>
    {
        private readonly string _value;

        private PgpSignedAttestationContentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// `ContentType` is not set.
        /// </summary>
        public static PgpSignedAttestationContentType ContentTypeUnspecified { get; } = new PgpSignedAttestationContentType("CONTENT_TYPE_UNSPECIFIED");
        /// <summary>
        /// Atomic format attestation signature. See https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md The payload extracted from `signature` is a JSON blob conforming to the linked schema.
        /// </summary>
        public static PgpSignedAttestationContentType SimpleSigningJson { get; } = new PgpSignedAttestationContentType("SIMPLE_SIGNING_JSON");

        public static bool operator ==(PgpSignedAttestationContentType left, PgpSignedAttestationContentType right) => left.Equals(right);
        public static bool operator !=(PgpSignedAttestationContentType left, PgpSignedAttestationContentType right) => !left.Equals(right);

        public static explicit operator string(PgpSignedAttestationContentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PgpSignedAttestationContentType other && Equals(other);
        public bool Equals(PgpSignedAttestationContentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Distinguish between sentinel MIN/MAX versions and normal versions. If kind is not NORMAL, then the other fields are ignored.
    /// </summary>
    [EnumType]
    public readonly struct VersionKind : IEquatable<VersionKind>
    {
        private readonly string _value;

        private VersionKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// A standard package version, defined by the other fields.
        /// </summary>
        public static VersionKind Normal { get; } = new VersionKind("NORMAL");
        /// <summary>
        /// A special version representing negative infinity, other fields are ignored.
        /// </summary>
        public static VersionKind Minimum { get; } = new VersionKind("MINIMUM");
        /// <summary>
        /// A special version representing positive infinity, other fields are ignored.
        /// </summary>
        public static VersionKind Maximum { get; } = new VersionKind("MAXIMUM");

        public static bool operator ==(VersionKind left, VersionKind right) => left.Equals(right);
        public static bool operator !=(VersionKind left, VersionKind right) => !left.Equals(right);

        public static explicit operator string(VersionKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VersionKind other && Equals(other);
        public bool Equals(VersionKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The distro assigned severity for this vulnerability when that is available and note provider assigned severity when distro has not yet assigned a severity for this vulnerability.
    /// </summary>
    [EnumType]
    public readonly struct VulnerabilityDetailsEffectiveSeverity : IEquatable<VulnerabilityDetailsEffectiveSeverity>
    {
        private readonly string _value;

        private VulnerabilityDetailsEffectiveSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown Impact
        /// </summary>
        public static VulnerabilityDetailsEffectiveSeverity SeverityUnspecified { get; } = new VulnerabilityDetailsEffectiveSeverity("SEVERITY_UNSPECIFIED");
        /// <summary>
        /// Minimal Impact
        /// </summary>
        public static VulnerabilityDetailsEffectiveSeverity Minimal { get; } = new VulnerabilityDetailsEffectiveSeverity("MINIMAL");
        /// <summary>
        /// Low Impact
        /// </summary>
        public static VulnerabilityDetailsEffectiveSeverity Low { get; } = new VulnerabilityDetailsEffectiveSeverity("LOW");
        /// <summary>
        /// Medium Impact
        /// </summary>
        public static VulnerabilityDetailsEffectiveSeverity Medium { get; } = new VulnerabilityDetailsEffectiveSeverity("MEDIUM");
        /// <summary>
        /// High Impact
        /// </summary>
        public static VulnerabilityDetailsEffectiveSeverity High { get; } = new VulnerabilityDetailsEffectiveSeverity("HIGH");
        /// <summary>
        /// Critical Impact
        /// </summary>
        public static VulnerabilityDetailsEffectiveSeverity Critical { get; } = new VulnerabilityDetailsEffectiveSeverity("CRITICAL");

        public static bool operator ==(VulnerabilityDetailsEffectiveSeverity left, VulnerabilityDetailsEffectiveSeverity right) => left.Equals(right);
        public static bool operator !=(VulnerabilityDetailsEffectiveSeverity left, VulnerabilityDetailsEffectiveSeverity right) => !left.Equals(right);

        public static explicit operator string(VulnerabilityDetailsEffectiveSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VulnerabilityDetailsEffectiveSeverity other && Equals(other);
        public bool Equals(VulnerabilityDetailsEffectiveSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Note provider assigned impact of the vulnerability
    /// </summary>
    [EnumType]
    public readonly struct VulnerabilityTypeSeverity : IEquatable<VulnerabilityTypeSeverity>
    {
        private readonly string _value;

        private VulnerabilityTypeSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown Impact
        /// </summary>
        public static VulnerabilityTypeSeverity SeverityUnspecified { get; } = new VulnerabilityTypeSeverity("SEVERITY_UNSPECIFIED");
        /// <summary>
        /// Minimal Impact
        /// </summary>
        public static VulnerabilityTypeSeverity Minimal { get; } = new VulnerabilityTypeSeverity("MINIMAL");
        /// <summary>
        /// Low Impact
        /// </summary>
        public static VulnerabilityTypeSeverity Low { get; } = new VulnerabilityTypeSeverity("LOW");
        /// <summary>
        /// Medium Impact
        /// </summary>
        public static VulnerabilityTypeSeverity Medium { get; } = new VulnerabilityTypeSeverity("MEDIUM");
        /// <summary>
        /// High Impact
        /// </summary>
        public static VulnerabilityTypeSeverity High { get; } = new VulnerabilityTypeSeverity("HIGH");
        /// <summary>
        /// Critical Impact
        /// </summary>
        public static VulnerabilityTypeSeverity Critical { get; } = new VulnerabilityTypeSeverity("CRITICAL");

        public static bool operator ==(VulnerabilityTypeSeverity left, VulnerabilityTypeSeverity right) => left.Equals(right);
        public static bool operator !=(VulnerabilityTypeSeverity left, VulnerabilityTypeSeverity right) => !left.Equals(right);

        public static explicit operator string(VulnerabilityTypeSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VulnerabilityTypeSeverity other && Equals(other);
        public bool Equals(VulnerabilityTypeSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

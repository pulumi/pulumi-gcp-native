// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.ContainerAnalysis.V1Alpha1
{
    /// <summary>
    /// Provides the state of this Vulnerability assessment.
    /// </summary>
    [EnumType]
    public readonly struct AssessmentState : IEquatable<AssessmentState>
    {
        private readonly string _value;

        private AssessmentState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No state is specified.
        /// </summary>
        public static AssessmentState StateUnspecified { get; } = new AssessmentState("STATE_UNSPECIFIED");
        /// <summary>
        /// This product is known to be affected by this vulnerability.
        /// </summary>
        public static AssessmentState Affected { get; } = new AssessmentState("AFFECTED");
        /// <summary>
        /// This product is known to be not affected by this vulnerability.
        /// </summary>
        public static AssessmentState NotAffected { get; } = new AssessmentState("NOT_AFFECTED");
        /// <summary>
        /// This product contains a fix for this vulnerability.
        /// </summary>
        public static AssessmentState Fixed { get; } = new AssessmentState("FIXED");
        /// <summary>
        /// It is not known yet whether these versions are or are not affected by the vulnerability. However, it is still under investigation.
        /// </summary>
        public static AssessmentState UnderInvestigation { get; } = new AssessmentState("UNDER_INVESTIGATION");

        public static bool operator ==(AssessmentState left, AssessmentState right) => left.Equals(right);
        public static bool operator !=(AssessmentState left, AssessmentState right) => !left.Equals(right);

        public static explicit operator string(AssessmentState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AssessmentState other && Equals(other);
        public bool Equals(AssessmentState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the key, either stored in `public_key` or referenced in `key_id`
    /// </summary>
    [EnumType]
    public readonly struct BuildSignatureKeyType : IEquatable<BuildSignatureKeyType>
    {
        private readonly string _value;

        private BuildSignatureKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// `KeyType` is not set.
        /// </summary>
        public static BuildSignatureKeyType KeyTypeUnspecified { get; } = new BuildSignatureKeyType("KEY_TYPE_UNSPECIFIED");
        /// <summary>
        /// `PGP ASCII Armored` public key.
        /// </summary>
        public static BuildSignatureKeyType PgpAsciiArmored { get; } = new BuildSignatureKeyType("PGP_ASCII_ARMORED");
        /// <summary>
        /// `PKIX PEM` public key.
        /// </summary>
        public static BuildSignatureKeyType PkixPem { get; } = new BuildSignatureKeyType("PKIX_PEM");

        public static bool operator ==(BuildSignatureKeyType left, BuildSignatureKeyType right) => left.Equals(right);
        public static bool operator !=(BuildSignatureKeyType left, BuildSignatureKeyType right) => !left.Equals(right);

        public static explicit operator string(BuildSignatureKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BuildSignatureKeyType other && Equals(other);
        public bool Equals(BuildSignatureKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defined in CVSS v3, CVSS v2
    /// </summary>
    [EnumType]
    public readonly struct CVSSAttackComplexity : IEquatable<CVSSAttackComplexity>
    {
        private readonly string _value;

        private CVSSAttackComplexity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Defined in CVSS v3, CVSS v2
        /// </summary>
        public static CVSSAttackComplexity AttackComplexityUnspecified { get; } = new CVSSAttackComplexity("ATTACK_COMPLEXITY_UNSPECIFIED");
        /// <summary>
        /// Defined in CVSS v3, CVSS v2
        /// </summary>
        public static CVSSAttackComplexity AttackComplexityLow { get; } = new CVSSAttackComplexity("ATTACK_COMPLEXITY_LOW");
        /// <summary>
        /// Defined in CVSS v3, CVSS v2
        /// </summary>
        public static CVSSAttackComplexity AttackComplexityHigh { get; } = new CVSSAttackComplexity("ATTACK_COMPLEXITY_HIGH");
        /// <summary>
        /// Defined in CVSS v2
        /// </summary>
        public static CVSSAttackComplexity AttackComplexityMedium { get; } = new CVSSAttackComplexity("ATTACK_COMPLEXITY_MEDIUM");

        public static bool operator ==(CVSSAttackComplexity left, CVSSAttackComplexity right) => left.Equals(right);
        public static bool operator !=(CVSSAttackComplexity left, CVSSAttackComplexity right) => !left.Equals(right);

        public static explicit operator string(CVSSAttackComplexity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSAttackComplexity other && Equals(other);
        public bool Equals(CVSSAttackComplexity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Base Metrics Represents the intrinsic characteristics of a vulnerability that are constant over time and across user environments. Defined in CVSS v3, CVSS v2
    /// </summary>
    [EnumType]
    public readonly struct CVSSAttackVector : IEquatable<CVSSAttackVector>
    {
        private readonly string _value;

        private CVSSAttackVector(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Defined in CVSS v3, CVSS v2
        /// </summary>
        public static CVSSAttackVector AttackVectorUnspecified { get; } = new CVSSAttackVector("ATTACK_VECTOR_UNSPECIFIED");
        /// <summary>
        /// Defined in CVSS v3, CVSS v2
        /// </summary>
        public static CVSSAttackVector AttackVectorNetwork { get; } = new CVSSAttackVector("ATTACK_VECTOR_NETWORK");
        /// <summary>
        /// Defined in CVSS v3, CVSS v2
        /// </summary>
        public static CVSSAttackVector AttackVectorAdjacent { get; } = new CVSSAttackVector("ATTACK_VECTOR_ADJACENT");
        /// <summary>
        /// Defined in CVSS v3, CVSS v2
        /// </summary>
        public static CVSSAttackVector AttackVectorLocal { get; } = new CVSSAttackVector("ATTACK_VECTOR_LOCAL");
        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSAttackVector AttackVectorPhysical { get; } = new CVSSAttackVector("ATTACK_VECTOR_PHYSICAL");

        public static bool operator ==(CVSSAttackVector left, CVSSAttackVector right) => left.Equals(right);
        public static bool operator !=(CVSSAttackVector left, CVSSAttackVector right) => !left.Equals(right);

        public static explicit operator string(CVSSAttackVector value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSAttackVector other && Equals(other);
        public bool Equals(CVSSAttackVector other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defined in CVSS v2
    /// </summary>
    [EnumType]
    public readonly struct CVSSAuthentication : IEquatable<CVSSAuthentication>
    {
        private readonly string _value;

        private CVSSAuthentication(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Defined in CVSS v2
        /// </summary>
        public static CVSSAuthentication AuthenticationUnspecified { get; } = new CVSSAuthentication("AUTHENTICATION_UNSPECIFIED");
        /// <summary>
        /// Defined in CVSS v2
        /// </summary>
        public static CVSSAuthentication AuthenticationMultiple { get; } = new CVSSAuthentication("AUTHENTICATION_MULTIPLE");
        /// <summary>
        /// Defined in CVSS v2
        /// </summary>
        public static CVSSAuthentication AuthenticationSingle { get; } = new CVSSAuthentication("AUTHENTICATION_SINGLE");
        /// <summary>
        /// Defined in CVSS v2
        /// </summary>
        public static CVSSAuthentication AuthenticationNone { get; } = new CVSSAuthentication("AUTHENTICATION_NONE");

        public static bool operator ==(CVSSAuthentication left, CVSSAuthentication right) => left.Equals(right);
        public static bool operator !=(CVSSAuthentication left, CVSSAuthentication right) => !left.Equals(right);

        public static explicit operator string(CVSSAuthentication value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSAuthentication other && Equals(other);
        public bool Equals(CVSSAuthentication other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defined in CVSS v3, CVSS v2
    /// </summary>
    [EnumType]
    public readonly struct CVSSAvailabilityImpact : IEquatable<CVSSAvailabilityImpact>
    {
        private readonly string _value;

        private CVSSAvailabilityImpact(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Defined in CVSS v3, CVSS v2
        /// </summary>
        public static CVSSAvailabilityImpact ImpactUnspecified { get; } = new CVSSAvailabilityImpact("IMPACT_UNSPECIFIED");
        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSAvailabilityImpact ImpactHigh { get; } = new CVSSAvailabilityImpact("IMPACT_HIGH");
        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSAvailabilityImpact ImpactLow { get; } = new CVSSAvailabilityImpact("IMPACT_LOW");
        /// <summary>
        /// Defined in CVSS v3, CVSS v2
        /// </summary>
        public static CVSSAvailabilityImpact ImpactNone { get; } = new CVSSAvailabilityImpact("IMPACT_NONE");
        /// <summary>
        /// Defined in CVSS v2
        /// </summary>
        public static CVSSAvailabilityImpact ImpactPartial { get; } = new CVSSAvailabilityImpact("IMPACT_PARTIAL");
        /// <summary>
        /// Defined in CVSS v2
        /// </summary>
        public static CVSSAvailabilityImpact ImpactComplete { get; } = new CVSSAvailabilityImpact("IMPACT_COMPLETE");

        public static bool operator ==(CVSSAvailabilityImpact left, CVSSAvailabilityImpact right) => left.Equals(right);
        public static bool operator !=(CVSSAvailabilityImpact left, CVSSAvailabilityImpact right) => !left.Equals(right);

        public static explicit operator string(CVSSAvailabilityImpact value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSAvailabilityImpact other && Equals(other);
        public bool Equals(CVSSAvailabilityImpact other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defined in CVSS v3, CVSS v2
    /// </summary>
    [EnumType]
    public readonly struct CVSSConfidentialityImpact : IEquatable<CVSSConfidentialityImpact>
    {
        private readonly string _value;

        private CVSSConfidentialityImpact(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Defined in CVSS v3, CVSS v2
        /// </summary>
        public static CVSSConfidentialityImpact ImpactUnspecified { get; } = new CVSSConfidentialityImpact("IMPACT_UNSPECIFIED");
        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSConfidentialityImpact ImpactHigh { get; } = new CVSSConfidentialityImpact("IMPACT_HIGH");
        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSConfidentialityImpact ImpactLow { get; } = new CVSSConfidentialityImpact("IMPACT_LOW");
        /// <summary>
        /// Defined in CVSS v3, CVSS v2
        /// </summary>
        public static CVSSConfidentialityImpact ImpactNone { get; } = new CVSSConfidentialityImpact("IMPACT_NONE");
        /// <summary>
        /// Defined in CVSS v2
        /// </summary>
        public static CVSSConfidentialityImpact ImpactPartial { get; } = new CVSSConfidentialityImpact("IMPACT_PARTIAL");
        /// <summary>
        /// Defined in CVSS v2
        /// </summary>
        public static CVSSConfidentialityImpact ImpactComplete { get; } = new CVSSConfidentialityImpact("IMPACT_COMPLETE");

        public static bool operator ==(CVSSConfidentialityImpact left, CVSSConfidentialityImpact right) => left.Equals(right);
        public static bool operator !=(CVSSConfidentialityImpact left, CVSSConfidentialityImpact right) => !left.Equals(right);

        public static explicit operator string(CVSSConfidentialityImpact value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSConfidentialityImpact other && Equals(other);
        public bool Equals(CVSSConfidentialityImpact other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defined in CVSS v3, CVSS v2
    /// </summary>
    [EnumType]
    public readonly struct CVSSIntegrityImpact : IEquatable<CVSSIntegrityImpact>
    {
        private readonly string _value;

        private CVSSIntegrityImpact(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Defined in CVSS v3, CVSS v2
        /// </summary>
        public static CVSSIntegrityImpact ImpactUnspecified { get; } = new CVSSIntegrityImpact("IMPACT_UNSPECIFIED");
        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSIntegrityImpact ImpactHigh { get; } = new CVSSIntegrityImpact("IMPACT_HIGH");
        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSIntegrityImpact ImpactLow { get; } = new CVSSIntegrityImpact("IMPACT_LOW");
        /// <summary>
        /// Defined in CVSS v3, CVSS v2
        /// </summary>
        public static CVSSIntegrityImpact ImpactNone { get; } = new CVSSIntegrityImpact("IMPACT_NONE");
        /// <summary>
        /// Defined in CVSS v2
        /// </summary>
        public static CVSSIntegrityImpact ImpactPartial { get; } = new CVSSIntegrityImpact("IMPACT_PARTIAL");
        /// <summary>
        /// Defined in CVSS v2
        /// </summary>
        public static CVSSIntegrityImpact ImpactComplete { get; } = new CVSSIntegrityImpact("IMPACT_COMPLETE");

        public static bool operator ==(CVSSIntegrityImpact left, CVSSIntegrityImpact right) => left.Equals(right);
        public static bool operator !=(CVSSIntegrityImpact left, CVSSIntegrityImpact right) => !left.Equals(right);

        public static explicit operator string(CVSSIntegrityImpact value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSIntegrityImpact other && Equals(other);
        public bool Equals(CVSSIntegrityImpact other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defined in CVSS v3
    /// </summary>
    [EnumType]
    public readonly struct CVSSPrivilegesRequired : IEquatable<CVSSPrivilegesRequired>
    {
        private readonly string _value;

        private CVSSPrivilegesRequired(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSPrivilegesRequired PrivilegesRequiredUnspecified { get; } = new CVSSPrivilegesRequired("PRIVILEGES_REQUIRED_UNSPECIFIED");
        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSPrivilegesRequired PrivilegesRequiredNone { get; } = new CVSSPrivilegesRequired("PRIVILEGES_REQUIRED_NONE");
        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSPrivilegesRequired PrivilegesRequiredLow { get; } = new CVSSPrivilegesRequired("PRIVILEGES_REQUIRED_LOW");
        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSPrivilegesRequired PrivilegesRequiredHigh { get; } = new CVSSPrivilegesRequired("PRIVILEGES_REQUIRED_HIGH");

        public static bool operator ==(CVSSPrivilegesRequired left, CVSSPrivilegesRequired right) => left.Equals(right);
        public static bool operator !=(CVSSPrivilegesRequired left, CVSSPrivilegesRequired right) => !left.Equals(right);

        public static explicit operator string(CVSSPrivilegesRequired value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSPrivilegesRequired other && Equals(other);
        public bool Equals(CVSSPrivilegesRequired other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defined in CVSS v3
    /// </summary>
    [EnumType]
    public readonly struct CVSSScope : IEquatable<CVSSScope>
    {
        private readonly string _value;

        private CVSSScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSScope ScopeUnspecified { get; } = new CVSSScope("SCOPE_UNSPECIFIED");
        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSScope ScopeUnchanged { get; } = new CVSSScope("SCOPE_UNCHANGED");
        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSScope ScopeChanged { get; } = new CVSSScope("SCOPE_CHANGED");

        public static bool operator ==(CVSSScope left, CVSSScope right) => left.Equals(right);
        public static bool operator !=(CVSSScope left, CVSSScope right) => !left.Equals(right);

        public static explicit operator string(CVSSScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSScope other && Equals(other);
        public bool Equals(CVSSScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defined in CVSS v3
    /// </summary>
    [EnumType]
    public readonly struct CVSSUserInteraction : IEquatable<CVSSUserInteraction>
    {
        private readonly string _value;

        private CVSSUserInteraction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSUserInteraction UserInteractionUnspecified { get; } = new CVSSUserInteraction("USER_INTERACTION_UNSPECIFIED");
        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSUserInteraction UserInteractionNone { get; } = new CVSSUserInteraction("USER_INTERACTION_NONE");
        /// <summary>
        /// Defined in CVSS v3
        /// </summary>
        public static CVSSUserInteraction UserInteractionRequired { get; } = new CVSSUserInteraction("USER_INTERACTION_REQUIRED");

        public static bool operator ==(CVSSUserInteraction left, CVSSUserInteraction right) => left.Equals(right);
        public static bool operator !=(CVSSUserInteraction left, CVSSUserInteraction right) => !left.Equals(right);

        public static explicit operator string(CVSSUserInteraction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSUserInteraction other && Equals(other);
        public bool Equals(CVSSUserInteraction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The severity level of this CIS benchmark check.
    /// </summary>
    [EnumType]
    public readonly struct CisBenchmarkSeverity : IEquatable<CisBenchmarkSeverity>
    {
        private readonly string _value;

        private CisBenchmarkSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown Impact
        /// </summary>
        public static CisBenchmarkSeverity SeverityUnspecified { get; } = new CisBenchmarkSeverity("SEVERITY_UNSPECIFIED");
        /// <summary>
        /// Minimal Impact
        /// </summary>
        public static CisBenchmarkSeverity Minimal { get; } = new CisBenchmarkSeverity("MINIMAL");
        /// <summary>
        /// Low Impact
        /// </summary>
        public static CisBenchmarkSeverity Low { get; } = new CisBenchmarkSeverity("LOW");
        /// <summary>
        /// Medium Impact
        /// </summary>
        public static CisBenchmarkSeverity Medium { get; } = new CisBenchmarkSeverity("MEDIUM");
        /// <summary>
        /// High Impact
        /// </summary>
        public static CisBenchmarkSeverity High { get; } = new CisBenchmarkSeverity("HIGH");
        /// <summary>
        /// Critical Impact
        /// </summary>
        public static CisBenchmarkSeverity Critical { get; } = new CisBenchmarkSeverity("CRITICAL");

        public static bool operator ==(CisBenchmarkSeverity left, CisBenchmarkSeverity right) => left.Equals(right);
        public static bool operator !=(CisBenchmarkSeverity left, CisBenchmarkSeverity right) => !left.Equals(right);

        public static explicit operator string(CisBenchmarkSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CisBenchmarkSeverity other && Equals(other);
        public bool Equals(CisBenchmarkSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Platform hosting this deployment.
    /// </summary>
    [EnumType]
    public readonly struct DeploymentPlatform : IEquatable<DeploymentPlatform>
    {
        private readonly string _value;

        private DeploymentPlatform(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown
        /// </summary>
        public static DeploymentPlatform PlatformUnspecified { get; } = new DeploymentPlatform("PLATFORM_UNSPECIFIED");
        /// <summary>
        /// Google Container Engine
        /// </summary>
        public static DeploymentPlatform Gke { get; } = new DeploymentPlatform("GKE");
        /// <summary>
        /// Google App Engine: Flexible Environment
        /// </summary>
        public static DeploymentPlatform Flex { get; } = new DeploymentPlatform("FLEX");
        /// <summary>
        /// Custom user-defined platform
        /// </summary>
        public static DeploymentPlatform Custom { get; } = new DeploymentPlatform("CUSTOM");

        public static bool operator ==(DeploymentPlatform left, DeploymentPlatform right) => left.Equals(right);
        public static bool operator !=(DeploymentPlatform left, DeploymentPlatform right) => !left.Equals(right);

        public static explicit operator string(DeploymentPlatform value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeploymentPlatform other && Equals(other);
        public bool Equals(DeploymentPlatform other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of discovery for the resource.
    /// </summary>
    [EnumType]
    public readonly struct DiscoveredAnalysisStatus : IEquatable<DiscoveredAnalysisStatus>
    {
        private readonly string _value;

        private DiscoveredAnalysisStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown
        /// </summary>
        public static DiscoveredAnalysisStatus AnalysisStatusUnspecified { get; } = new DiscoveredAnalysisStatus("ANALYSIS_STATUS_UNSPECIFIED");
        /// <summary>
        /// Resource is known but no action has been taken yet.
        /// </summary>
        public static DiscoveredAnalysisStatus Pending { get; } = new DiscoveredAnalysisStatus("PENDING");
        /// <summary>
        /// Resource is being analyzed.
        /// </summary>
        public static DiscoveredAnalysisStatus Scanning { get; } = new DiscoveredAnalysisStatus("SCANNING");
        /// <summary>
        /// Analysis has completed
        /// </summary>
        public static DiscoveredAnalysisStatus Complete { get; } = new DiscoveredAnalysisStatus("COMPLETE");
        /// <summary>
        /// Analysis has finished successfully.
        /// </summary>
        public static DiscoveredAnalysisStatus FinishedSuccess { get; } = new DiscoveredAnalysisStatus("FINISHED_SUCCESS");
        /// <summary>
        /// Analysis has finished unsuccessfully, the analysis itself is in a bad state.
        /// </summary>
        public static DiscoveredAnalysisStatus FinishedFailed { get; } = new DiscoveredAnalysisStatus("FINISHED_FAILED");
        /// <summary>
        /// The resource is known not to be supported.
        /// </summary>
        public static DiscoveredAnalysisStatus FinishedUnsupported { get; } = new DiscoveredAnalysisStatus("FINISHED_UNSUPPORTED");

        public static bool operator ==(DiscoveredAnalysisStatus left, DiscoveredAnalysisStatus right) => left.Equals(right);
        public static bool operator !=(DiscoveredAnalysisStatus left, DiscoveredAnalysisStatus right) => !left.Equals(right);

        public static explicit operator string(DiscoveredAnalysisStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiscoveredAnalysisStatus other && Equals(other);
        public bool Equals(DiscoveredAnalysisStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the resource is continuously analyzed.
    /// </summary>
    [EnumType]
    public readonly struct DiscoveredContinuousAnalysis : IEquatable<DiscoveredContinuousAnalysis>
    {
        private readonly string _value;

        private DiscoveredContinuousAnalysis(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown
        /// </summary>
        public static DiscoveredContinuousAnalysis ContinuousAnalysisUnspecified { get; } = new DiscoveredContinuousAnalysis("CONTINUOUS_ANALYSIS_UNSPECIFIED");
        /// <summary>
        /// The resource is continuously analyzed.
        /// </summary>
        public static DiscoveredContinuousAnalysis Active { get; } = new DiscoveredContinuousAnalysis("ACTIVE");
        /// <summary>
        /// The resource is ignored for continuous analysis.
        /// </summary>
        public static DiscoveredContinuousAnalysis Inactive { get; } = new DiscoveredContinuousAnalysis("INACTIVE");

        public static bool operator ==(DiscoveredContinuousAnalysis left, DiscoveredContinuousAnalysis right) => left.Equals(right);
        public static bool operator !=(DiscoveredContinuousAnalysis left, DiscoveredContinuousAnalysis right) => !left.Equals(right);

        public static explicit operator string(DiscoveredContinuousAnalysis value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiscoveredContinuousAnalysis other && Equals(other);
        public bool Equals(DiscoveredContinuousAnalysis other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kind of analysis that is handled by this discovery.
    /// </summary>
    [EnumType]
    public readonly struct DiscoveryAnalysisKind : IEquatable<DiscoveryAnalysisKind>
    {
        private readonly string _value;

        private DiscoveryAnalysisKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown
        /// </summary>
        public static DiscoveryAnalysisKind KindUnspecified { get; } = new DiscoveryAnalysisKind("KIND_UNSPECIFIED");
        /// <summary>
        /// The note and occurrence represent a package vulnerability.
        /// </summary>
        public static DiscoveryAnalysisKind PackageVulnerability { get; } = new DiscoveryAnalysisKind("PACKAGE_VULNERABILITY");
        /// <summary>
        /// The note and occurrence assert build provenance.
        /// </summary>
        public static DiscoveryAnalysisKind BuildDetails { get; } = new DiscoveryAnalysisKind("BUILD_DETAILS");
        /// <summary>
        /// This represents an image basis relationship.
        /// </summary>
        public static DiscoveryAnalysisKind ImageBasis { get; } = new DiscoveryAnalysisKind("IMAGE_BASIS");
        /// <summary>
        /// This represents a package installed via a package manager.
        /// </summary>
        public static DiscoveryAnalysisKind PackageManager { get; } = new DiscoveryAnalysisKind("PACKAGE_MANAGER");
        /// <summary>
        /// The note and occurrence track deployment events.
        /// </summary>
        public static DiscoveryAnalysisKind Deployable { get; } = new DiscoveryAnalysisKind("DEPLOYABLE");
        /// <summary>
        /// The note and occurrence track the initial discovery status of a resource.
        /// </summary>
        public static DiscoveryAnalysisKind Discovery { get; } = new DiscoveryAnalysisKind("DISCOVERY");
        /// <summary>
        /// This represents a logical "role" that can attest to artifacts.
        /// </summary>
        public static DiscoveryAnalysisKind AttestationAuthority { get; } = new DiscoveryAnalysisKind("ATTESTATION_AUTHORITY");
        /// <summary>
        /// This represents an available software upgrade.
        /// </summary>
        public static DiscoveryAnalysisKind Upgrade { get; } = new DiscoveryAnalysisKind("UPGRADE");
        /// <summary>
        /// This represents a compliance check that can be applied to a resource.
        /// </summary>
        public static DiscoveryAnalysisKind Compliance { get; } = new DiscoveryAnalysisKind("COMPLIANCE");
        /// <summary>
        /// This represents a software bill of materials.
        /// </summary>
        public static DiscoveryAnalysisKind Sbom { get; } = new DiscoveryAnalysisKind("SBOM");
        /// <summary>
        /// This represents an SPDX Package.
        /// </summary>
        public static DiscoveryAnalysisKind SpdxPackage { get; } = new DiscoveryAnalysisKind("SPDX_PACKAGE");
        /// <summary>
        /// This represents an SPDX File.
        /// </summary>
        public static DiscoveryAnalysisKind SpdxFile { get; } = new DiscoveryAnalysisKind("SPDX_FILE");
        /// <summary>
        /// This represents an SPDX Relationship.
        /// </summary>
        public static DiscoveryAnalysisKind SpdxRelationship { get; } = new DiscoveryAnalysisKind("SPDX_RELATIONSHIP");
        /// <summary>
        /// This represents a DSSE attestation Note
        /// </summary>
        public static DiscoveryAnalysisKind DsseAttestation { get; } = new DiscoveryAnalysisKind("DSSE_ATTESTATION");
        /// <summary>
        /// This represents a Vulnerability Assessment.
        /// </summary>
        public static DiscoveryAnalysisKind VulnerabilityAssessment { get; } = new DiscoveryAnalysisKind("VULNERABILITY_ASSESSMENT");
        /// <summary>
        /// This represents a reference to an SBOM.
        /// </summary>
        public static DiscoveryAnalysisKind SbomReference { get; } = new DiscoveryAnalysisKind("SBOM_REFERENCE");

        public static bool operator ==(DiscoveryAnalysisKind left, DiscoveryAnalysisKind right) => left.Equals(right);
        public static bool operator !=(DiscoveryAnalysisKind left, DiscoveryAnalysisKind right) => !left.Equals(right);

        public static explicit operator string(DiscoveryAnalysisKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiscoveryAnalysisKind other && Equals(other);
        public bool Equals(DiscoveryAnalysisKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The CPU architecture for which packages in this distribution channel were built
    /// </summary>
    [EnumType]
    public readonly struct DistributionArchitecture : IEquatable<DistributionArchitecture>
    {
        private readonly string _value;

        private DistributionArchitecture(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown architecture
        /// </summary>
        public static DistributionArchitecture ArchitectureUnspecified { get; } = new DistributionArchitecture("ARCHITECTURE_UNSPECIFIED");
        /// <summary>
        /// X86 architecture
        /// </summary>
        public static DistributionArchitecture X86 { get; } = new DistributionArchitecture("X86");
        /// <summary>
        /// X64 architecture
        /// </summary>
        public static DistributionArchitecture X64 { get; } = new DistributionArchitecture("X64");

        public static bool operator ==(DistributionArchitecture left, DistributionArchitecture right) => left.Equals(right);
        public static bool operator !=(DistributionArchitecture left, DistributionArchitecture right) => !left.Equals(right);

        public static explicit operator string(DistributionArchitecture value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionArchitecture other && Equals(other);
        public bool Equals(DistributionArchitecture other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package
    /// </summary>
    [EnumType]
    public readonly struct ExternalRefCategory : IEquatable<ExternalRefCategory>
    {
        private readonly string _value;

        private ExternalRefCategory(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified
        /// </summary>
        public static ExternalRefCategory CategoryUnspecified { get; } = new ExternalRefCategory("CATEGORY_UNSPECIFIED");
        /// <summary>
        /// Security (e.g. cpe22Type, cpe23Type)
        /// </summary>
        public static ExternalRefCategory Security { get; } = new ExternalRefCategory("SECURITY");
        /// <summary>
        /// Package Manager (e.g. maven-central, npm, nuget, bower, purl)
        /// </summary>
        public static ExternalRefCategory PackageManager { get; } = new ExternalRefCategory("PACKAGE_MANAGER");
        /// <summary>
        /// Persistent-Id (e.g. swh)
        /// </summary>
        public static ExternalRefCategory PersistentId { get; } = new ExternalRefCategory("PERSISTENT_ID");
        /// <summary>
        /// Other
        /// </summary>
        public static ExternalRefCategory Other { get; } = new ExternalRefCategory("OTHER");

        public static bool operator ==(ExternalRefCategory left, ExternalRefCategory right) => left.Equals(right);
        public static bool operator !=(ExternalRefCategory left, ExternalRefCategory right) => !left.Equals(right);

        public static explicit operator string(ExternalRefCategory value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExternalRefCategory other && Equals(other);
        public bool Equals(ExternalRefCategory other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This field provides information about the type of file identified
    /// </summary>
    [EnumType]
    public readonly struct FileNoteFileType : IEquatable<FileNoteFileType>
    {
        private readonly string _value;

        private FileNoteFileType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified
        /// </summary>
        public static FileNoteFileType FileTypeUnspecified { get; } = new FileNoteFileType("FILE_TYPE_UNSPECIFIED");
        /// <summary>
        /// The file is human readable source code (.c, .html, etc.)
        /// </summary>
        public static FileNoteFileType Source { get; } = new FileNoteFileType("SOURCE");
        /// <summary>
        /// The file is a compiled object, target image or binary executable (.o, .a, etc.)
        /// </summary>
        public static FileNoteFileType Binary { get; } = new FileNoteFileType("BINARY");
        /// <summary>
        /// The file represents an archive (.tar, .jar, etc.)
        /// </summary>
        public static FileNoteFileType Archive { get; } = new FileNoteFileType("ARCHIVE");
        /// <summary>
        /// The file is associated with a specific application type (MIME type of application/*)
        /// </summary>
        public static FileNoteFileType Application { get; } = new FileNoteFileType("APPLICATION");
        /// <summary>
        /// The file is associated with an audio file (MIME type of audio/* , e.g. .mp3)
        /// </summary>
        public static FileNoteFileType Audio { get; } = new FileNoteFileType("AUDIO");
        /// <summary>
        /// The file is associated with an picture image file (MIME type of image/*, e.g., .jpg, .gif)
        /// </summary>
        public static FileNoteFileType Image { get; } = new FileNoteFileType("IMAGE");
        /// <summary>
        /// The file is human readable text file (MIME type of text/*)
        /// </summary>
        public static FileNoteFileType Text { get; } = new FileNoteFileType("TEXT");
        /// <summary>
        /// The file is associated with a video file type (MIME type of video/*)
        /// </summary>
        public static FileNoteFileType Video { get; } = new FileNoteFileType("VIDEO");
        /// <summary>
        /// The file serves as documentation
        /// </summary>
        public static FileNoteFileType Documentation { get; } = new FileNoteFileType("DOCUMENTATION");
        /// <summary>
        /// The file is an SPDX document
        /// </summary>
        public static FileNoteFileType Spdx { get; } = new FileNoteFileType("SPDX");
        /// <summary>
        /// The file doesn't fit into the above categories (generated artifacts, data files, etc.)
        /// </summary>
        public static FileNoteFileType Other { get; } = new FileNoteFileType("OTHER");

        public static bool operator ==(FileNoteFileType left, FileNoteFileType right) => left.Equals(right);
        public static bool operator !=(FileNoteFileType left, FileNoteFileType right) => !left.Equals(right);

        public static explicit operator string(FileNoteFileType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FileNoteFileType other && Equals(other);
        public bool Equals(FileNoteFileType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The alias kind.
    /// </summary>
    [EnumType]
    public readonly struct GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind : IEquatable<GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind>
    {
        private readonly string _value;

        private GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind KindUnspecified { get; } = new GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind("KIND_UNSPECIFIED");
        /// <summary>
        /// Git tag.
        /// </summary>
        public static GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind Fixed { get; } = new GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind("FIXED");
        /// <summary>
        /// Git branch.
        /// </summary>
        public static GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind Movable { get; } = new GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind("MOVABLE");
        /// <summary>
        /// Used to specify non-standard aliases. For example, if a Git repo has a ref named "refs/foo/bar".
        /// </summary>
        public static GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind Other { get; } = new GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind("OTHER");

        public static bool operator ==(GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind left, GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind right) => left.Equals(right);
        public static bool operator !=(GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind left, GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind right) => !left.Equals(right);

        public static explicit operator string(GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind other && Equals(other);
        public bool Equals(GoogleDevtoolsContaineranalysisV1alpha1AliasContextKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of hash that was performed.
    /// </summary>
    [EnumType]
    public readonly struct HashType : IEquatable<HashType>
    {
        private readonly string _value;

        private HashType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No hash requested.
        /// </summary>
        public static HashType None { get; } = new HashType("NONE");
        /// <summary>
        /// A sha256 hash.
        /// </summary>
        public static HashType Sha256 { get; } = new HashType("SHA256");

        public static bool operator ==(HashType left, HashType right) => left.Equals(right);
        public static bool operator !=(HashType left, HashType right) => !left.Equals(right);

        public static explicit operator string(HashType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HashType other && Equals(other);
        public bool Equals(HashType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The field that is set in the API proto.
    /// </summary>
    [EnumType]
    public readonly struct IdentifierHelperField : IEquatable<IdentifierHelperField>
    {
        private readonly string _value;

        private IdentifierHelperField(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The helper isn't set.
        /// </summary>
        public static IdentifierHelperField IdentifierHelperFieldUnspecified { get; } = new IdentifierHelperField("IDENTIFIER_HELPER_FIELD_UNSPECIFIED");
        /// <summary>
        /// The generic_uri one-of field is set.
        /// </summary>
        public static IdentifierHelperField GenericUri { get; } = new IdentifierHelperField("GENERIC_URI");

        public static bool operator ==(IdentifierHelperField left, IdentifierHelperField right) => left.Equals(right);
        public static bool operator !=(IdentifierHelperField left, IdentifierHelperField right) => !left.Equals(right);

        public static explicit operator string(IdentifierHelperField value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdentifierHelperField other && Equals(other);
        public bool Equals(IdentifierHelperField other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The justification type for this vulnerability.
    /// </summary>
    [EnumType]
    public readonly struct JustificationJustificationType : IEquatable<JustificationJustificationType>
    {
        private readonly string _value;

        private JustificationJustificationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// JUSTIFICATION_TYPE_UNSPECIFIED.
        /// </summary>
        public static JustificationJustificationType JustificationTypeUnspecified { get; } = new JustificationJustificationType("JUSTIFICATION_TYPE_UNSPECIFIED");
        /// <summary>
        /// The vulnerable component is not present in the product.
        /// </summary>
        public static JustificationJustificationType ComponentNotPresent { get; } = new JustificationJustificationType("COMPONENT_NOT_PRESENT");
        /// <summary>
        /// The vulnerable code is not present. Typically this case occurs when source code is configured or built in a way that excludes the vulnerable code.
        /// </summary>
        public static JustificationJustificationType VulnerableCodeNotPresent { get; } = new JustificationJustificationType("VULNERABLE_CODE_NOT_PRESENT");
        /// <summary>
        /// The vulnerable code can not be executed. Typically this case occurs when the product includes the vulnerable code but does not call or use the vulnerable code.
        /// </summary>
        public static JustificationJustificationType VulnerableCodeNotInExecutePath { get; } = new JustificationJustificationType("VULNERABLE_CODE_NOT_IN_EXECUTE_PATH");
        /// <summary>
        /// The vulnerable code cannot be controlled by an attacker to exploit the vulnerability.
        /// </summary>
        public static JustificationJustificationType VulnerableCodeCannotBeControlledByAdversary { get; } = new JustificationJustificationType("VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY");
        /// <summary>
        /// The product includes built-in protections or features that prevent exploitation of the vulnerability. These built-in protections cannot be subverted by the attacker and cannot be configured or disabled by the user. These mitigations completely prevent exploitation based on known attack vectors.
        /// </summary>
        public static JustificationJustificationType InlineMitigationsAlreadyExist { get; } = new JustificationJustificationType("INLINE_MITIGATIONS_ALREADY_EXIST");

        public static bool operator ==(JustificationJustificationType left, JustificationJustificationType right) => left.Equals(right);
        public static bool operator !=(JustificationJustificationType left, JustificationJustificationType right) => !left.Equals(right);

        public static explicit operator string(JustificationJustificationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JustificationJustificationType other && Equals(other);
        public bool Equals(JustificationJustificationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The recovered Dockerfile directive used to construct this layer.
    /// </summary>
    [EnumType]
    public readonly struct LayerDirective : IEquatable<LayerDirective>
    {
        private readonly string _value;

        private LayerDirective(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value for unsupported/missing directive
        /// </summary>
        public static LayerDirective DirectiveUnspecified { get; } = new LayerDirective("DIRECTIVE_UNSPECIFIED");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Maintainer { get; } = new LayerDirective("MAINTAINER");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Run { get; } = new LayerDirective("RUN");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Cmd { get; } = new LayerDirective("CMD");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Label { get; } = new LayerDirective("LABEL");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Expose { get; } = new LayerDirective("EXPOSE");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Env { get; } = new LayerDirective("ENV");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Add { get; } = new LayerDirective("ADD");
        /// <summary>
        /// https://docs.docker.com/reference/builder/#copy
        /// </summary>
        public static LayerDirective Copy { get; } = new LayerDirective("COPY");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Entrypoint { get; } = new LayerDirective("ENTRYPOINT");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Volume { get; } = new LayerDirective("VOLUME");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective User { get; } = new LayerDirective("USER");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Workdir { get; } = new LayerDirective("WORKDIR");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Arg { get; } = new LayerDirective("ARG");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Onbuild { get; } = new LayerDirective("ONBUILD");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Stopsignal { get; } = new LayerDirective("STOPSIGNAL");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Healthcheck { get; } = new LayerDirective("HEALTHCHECK");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Shell { get; } = new LayerDirective("SHELL");

        public static bool operator ==(LayerDirective left, LayerDirective right) => left.Equals(right);
        public static bool operator !=(LayerDirective left, LayerDirective right) => !left.Equals(right);

        public static explicit operator string(LayerDirective value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LayerDirective other && Equals(other);
        public bool Equals(LayerDirective other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The CPU architecture for which packages in this distribution channel were built. Architecture will be blank for language packages.
    /// </summary>
    [EnumType]
    public readonly struct PackageArchitecture : IEquatable<PackageArchitecture>
    {
        private readonly string _value;

        private PackageArchitecture(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown architecture
        /// </summary>
        public static PackageArchitecture ArchitectureUnspecified { get; } = new PackageArchitecture("ARCHITECTURE_UNSPECIFIED");
        /// <summary>
        /// X86 architecture
        /// </summary>
        public static PackageArchitecture X86 { get; } = new PackageArchitecture("X86");
        /// <summary>
        /// X64 architecture
        /// </summary>
        public static PackageArchitecture X64 { get; } = new PackageArchitecture("X64");

        public static bool operator ==(PackageArchitecture left, PackageArchitecture right) => left.Equals(right);
        public static bool operator !=(PackageArchitecture left, PackageArchitecture right) => !left.Equals(right);

        public static explicit operator string(PackageArchitecture value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PackageArchitecture other && Equals(other);
        public bool Equals(PackageArchitecture other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
    /// </summary>
    [EnumType]
    public readonly struct PgpSignedAttestationContentType : IEquatable<PgpSignedAttestationContentType>
    {
        private readonly string _value;

        private PgpSignedAttestationContentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// `ContentType` is not set.
        /// </summary>
        public static PgpSignedAttestationContentType ContentTypeUnspecified { get; } = new PgpSignedAttestationContentType("CONTENT_TYPE_UNSPECIFIED");
        /// <summary>
        /// Atomic format attestation signature. See https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md The payload extracted from `signature` is a JSON blob conforming to the linked schema.
        /// </summary>
        public static PgpSignedAttestationContentType SimpleSigningJson { get; } = new PgpSignedAttestationContentType("SIMPLE_SIGNING_JSON");

        public static bool operator ==(PgpSignedAttestationContentType left, PgpSignedAttestationContentType right) => left.Equals(right);
        public static bool operator !=(PgpSignedAttestationContentType left, PgpSignedAttestationContentType right) => !left.Equals(right);

        public static explicit operator string(PgpSignedAttestationContentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PgpSignedAttestationContentType other && Equals(other);
        public bool Equals(PgpSignedAttestationContentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of relationship between the source and target SPDX elements
    /// </summary>
    [EnumType]
    public readonly struct RelationshipNoteType : IEquatable<RelationshipNoteType>
    {
        private readonly string _value;

        private RelationshipNoteType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified
        /// </summary>
        public static RelationshipNoteType RelationshipTypeUnspecified { get; } = new RelationshipNoteType("RELATIONSHIP_TYPE_UNSPECIFIED");
        /// <summary>
        /// Is to be used when SPDXRef-DOCUMENT describes SPDXRef-A
        /// </summary>
        public static RelationshipNoteType Describes { get; } = new RelationshipNoteType("DESCRIBES");
        /// <summary>
        /// Is to be used when SPDXRef-A is described by SPDXREF-Document
        /// </summary>
        public static RelationshipNoteType DescribedBy { get; } = new RelationshipNoteType("DESCRIBED_BY");
        /// <summary>
        /// Is to be used when SPDXRef-A contains SPDXRef-B
        /// </summary>
        public static RelationshipNoteType Contains { get; } = new RelationshipNoteType("CONTAINS");
        /// <summary>
        /// Is to be used when SPDXRef-A is contained by SPDXRef-B
        /// </summary>
        public static RelationshipNoteType ContainedBy { get; } = new RelationshipNoteType("CONTAINED_BY");
        /// <summary>
        /// Is to be used when SPDXRef-A depends on SPDXRef-B
        /// </summary>
        public static RelationshipNoteType DependsOn { get; } = new RelationshipNoteType("DEPENDS_ON");
        /// <summary>
        /// Is to be used when SPDXRef-A is dependency of SPDXRef-B
        /// </summary>
        public static RelationshipNoteType DependencyOf { get; } = new RelationshipNoteType("DEPENDENCY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a manifest file that lists a set of dependencies for SPDXRef-B
        /// </summary>
        public static RelationshipNoteType DependencyManifestOf { get; } = new RelationshipNoteType("DEPENDENCY_MANIFEST_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a build dependency of SPDXRef-B
        /// </summary>
        public static RelationshipNoteType BuildDependencyOf { get; } = new RelationshipNoteType("BUILD_DEPENDENCY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a development dependency of SPDXRef-B
        /// </summary>
        public static RelationshipNoteType DevDependencyOf { get; } = new RelationshipNoteType("DEV_DEPENDENCY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is an optional dependency of SPDXRef-B
        /// </summary>
        public static RelationshipNoteType OptionalDependencyOf { get; } = new RelationshipNoteType("OPTIONAL_DEPENDENCY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a to be provided dependency of SPDXRef-B
        /// </summary>
        public static RelationshipNoteType ProvidedDependencyOf { get; } = new RelationshipNoteType("PROVIDED_DEPENDENCY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a test dependency of SPDXRef-B
        /// </summary>
        public static RelationshipNoteType TestDependencyOf { get; } = new RelationshipNoteType("TEST_DEPENDENCY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a dependency required for the execution of SPDXRef-B
        /// </summary>
        public static RelationshipNoteType RuntimeDependencyOf { get; } = new RelationshipNoteType("RUNTIME_DEPENDENCY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is an example of SPDXRef-B
        /// </summary>
        public static RelationshipNoteType ExampleOf { get; } = new RelationshipNoteType("EXAMPLE_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A generates SPDXRef-B
        /// </summary>
        public static RelationshipNoteType Generates { get; } = new RelationshipNoteType("GENERATES");
        /// <summary>
        /// Is to be used when SPDXRef-A was generated from SPDXRef-B
        /// </summary>
        public static RelationshipNoteType GeneratedFrom { get; } = new RelationshipNoteType("GENERATED_FROM");
        /// <summary>
        /// Is to be used when SPDXRef-A is an ancestor (same lineage but pre-dates) SPDXRef-B
        /// </summary>
        public static RelationshipNoteType AncestorOf { get; } = new RelationshipNoteType("ANCESTOR_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a descendant of (same lineage but postdates) SPDXRef-B
        /// </summary>
        public static RelationshipNoteType DescendantOf { get; } = new RelationshipNoteType("DESCENDANT_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a variant of (same lineage but not clear which came first) SPDXRef-B
        /// </summary>
        public static RelationshipNoteType VariantOf { get; } = new RelationshipNoteType("VARIANT_OF");
        /// <summary>
        /// Is to be used when distributing SPDXRef-A requires that SPDXRef-B also be distributed
        /// </summary>
        public static RelationshipNoteType DistributionArtifact { get; } = new RelationshipNoteType("DISTRIBUTION_ARTIFACT");
        /// <summary>
        /// Is to be used when SPDXRef-A is a patch file for (to be applied to) SPDXRef-B
        /// </summary>
        public static RelationshipNoteType PatchFor { get; } = new RelationshipNoteType("PATCH_FOR");
        /// <summary>
        /// Is to be used when SPDXRef-A is a patch file that has been applied to SPDXRef-B
        /// </summary>
        public static RelationshipNoteType PatchApplied { get; } = new RelationshipNoteType("PATCH_APPLIED");
        /// <summary>
        /// Is to be used when SPDXRef-A is an exact copy of SPDXRef-B
        /// </summary>
        public static RelationshipNoteType CopyOf { get; } = new RelationshipNoteType("COPY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a file that was added to SPDXRef-B
        /// </summary>
        public static RelationshipNoteType FileAdded { get; } = new RelationshipNoteType("FILE_ADDED");
        /// <summary>
        /// Is to be used when SPDXRef-A is a file that was deleted from SPDXRef-B
        /// </summary>
        public static RelationshipNoteType FileDeleted { get; } = new RelationshipNoteType("FILE_DELETED");
        /// <summary>
        /// Is to be used when SPDXRef-A is a file that was modified from SPDXRef-B
        /// </summary>
        public static RelationshipNoteType FileModified { get; } = new RelationshipNoteType("FILE_MODIFIED");
        /// <summary>
        /// Is to be used when SPDXRef-A is expanded from the archive SPDXRef-B
        /// </summary>
        public static RelationshipNoteType ExpandedFromArchive { get; } = new RelationshipNoteType("EXPANDED_FROM_ARCHIVE");
        /// <summary>
        /// Is to be used when SPDXRef-A dynamically links to SPDXRef-B
        /// </summary>
        public static RelationshipNoteType DynamicLink { get; } = new RelationshipNoteType("DYNAMIC_LINK");
        /// <summary>
        /// Is to be used when SPDXRef-A statically links to SPDXRef-B
        /// </summary>
        public static RelationshipNoteType StaticLink { get; } = new RelationshipNoteType("STATIC_LINK");
        /// <summary>
        /// Is to be used when SPDXRef-A is a data file used in SPDXRef-B
        /// </summary>
        public static RelationshipNoteType DataFileOf { get; } = new RelationshipNoteType("DATA_FILE_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a test case used in testing SPDXRef-B
        /// </summary>
        public static RelationshipNoteType TestCaseOf { get; } = new RelationshipNoteType("TEST_CASE_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is used to build SPDXRef-B
        /// </summary>
        public static RelationshipNoteType BuildToolOf { get; } = new RelationshipNoteType("BUILD_TOOL_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is used as a development tool for SPDXRef-B
        /// </summary>
        public static RelationshipNoteType DevToolOf { get; } = new RelationshipNoteType("DEV_TOOL_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is used for testing SPDXRef-B
        /// </summary>
        public static RelationshipNoteType TestOf { get; } = new RelationshipNoteType("TEST_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is used as a test tool for SPDXRef-B
        /// </summary>
        public static RelationshipNoteType TestToolOf { get; } = new RelationshipNoteType("TEST_TOOL_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A provides documentation of SPDXRef-B
        /// </summary>
        public static RelationshipNoteType DocumentationOf { get; } = new RelationshipNoteType("DOCUMENTATION_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is an optional component of SPDXRef-B
        /// </summary>
        public static RelationshipNoteType OptionalComponentOf { get; } = new RelationshipNoteType("OPTIONAL_COMPONENT_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a metafile of SPDXRef-B
        /// </summary>
        public static RelationshipNoteType MetafileOf { get; } = new RelationshipNoteType("METAFILE_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is used as a package as part of SPDXRef-B
        /// </summary>
        public static RelationshipNoteType PackageOf { get; } = new RelationshipNoteType("PACKAGE_OF");
        /// <summary>
        /// Is to be used when (current) SPDXRef-DOCUMENT amends the SPDX information in SPDXRef-B
        /// </summary>
        public static RelationshipNoteType Amends { get; } = new RelationshipNoteType("AMENDS");
        /// <summary>
        /// Is to be used when SPDXRef-A is a prerequisite for SPDXRef-B
        /// </summary>
        public static RelationshipNoteType PrerequisiteFor { get; } = new RelationshipNoteType("PREREQUISITE_FOR");
        /// <summary>
        /// Is to be used when SPDXRef-A has as a prerequisite SPDXRef-B
        /// </summary>
        public static RelationshipNoteType HasPrerequisite { get; } = new RelationshipNoteType("HAS_PREREQUISITE");
        /// <summary>
        /// Is to be used for a relationship which has not been defined in the formal SPDX specification. A description of the relationship should be included in the Relationship comments field
        /// </summary>
        public static RelationshipNoteType Other { get; } = new RelationshipNoteType("OTHER");

        public static bool operator ==(RelationshipNoteType left, RelationshipNoteType right) => left.Equals(right);
        public static bool operator !=(RelationshipNoteType left, RelationshipNoteType right) => !left.Equals(right);

        public static explicit operator string(RelationshipNoteType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RelationshipNoteType other && Equals(other);
        public bool Equals(RelationshipNoteType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of remediation that can be applied.
    /// </summary>
    [EnumType]
    public readonly struct RemediationRemediationType : IEquatable<RemediationRemediationType>
    {
        private readonly string _value;

        private RemediationRemediationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No remediation type specified.
        /// </summary>
        public static RemediationRemediationType RemediationTypeUnspecified { get; } = new RemediationRemediationType("REMEDIATION_TYPE_UNSPECIFIED");
        /// <summary>
        /// A MITIGATION is available.
        /// </summary>
        public static RemediationRemediationType Mitigation { get; } = new RemediationRemediationType("MITIGATION");
        /// <summary>
        /// No fix is planned.
        /// </summary>
        public static RemediationRemediationType NoFixPlanned { get; } = new RemediationRemediationType("NO_FIX_PLANNED");
        /// <summary>
        /// Not available.
        /// </summary>
        public static RemediationRemediationType NoneAvailable { get; } = new RemediationRemediationType("NONE_AVAILABLE");
        /// <summary>
        /// A vendor fix is available.
        /// </summary>
        public static RemediationRemediationType VendorFix { get; } = new RemediationRemediationType("VENDOR_FIX");
        /// <summary>
        /// A workaround is available.
        /// </summary>
        public static RemediationRemediationType Workaround { get; } = new RemediationRemediationType("WORKAROUND");

        public static bool operator ==(RemediationRemediationType left, RemediationRemediationType right) => left.Equals(right);
        public static bool operator !=(RemediationRemediationType left, RemediationRemediationType right) => !left.Equals(right);

        public static explicit operator string(RemediationRemediationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RemediationRemediationType other && Equals(other);
        public bool Equals(RemediationRemediationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Distinguish between sentinel MIN/MAX versions and normal versions. If kind is not NORMAL, then the other fields are ignored.
    /// </summary>
    [EnumType]
    public readonly struct VersionKind : IEquatable<VersionKind>
    {
        private readonly string _value;

        private VersionKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// A standard package version, defined by the other fields.
        /// </summary>
        public static VersionKind Normal { get; } = new VersionKind("NORMAL");
        /// <summary>
        /// A special version representing negative infinity, other fields are ignored.
        /// </summary>
        public static VersionKind Minimum { get; } = new VersionKind("MINIMUM");
        /// <summary>
        /// A special version representing positive infinity, other fields are ignored.
        /// </summary>
        public static VersionKind Maximum { get; } = new VersionKind("MAXIMUM");

        public static bool operator ==(VersionKind left, VersionKind right) => left.Equals(right);
        public static bool operator !=(VersionKind left, VersionKind right) => !left.Equals(right);

        public static explicit operator string(VersionKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VersionKind other && Equals(other);
        public bool Equals(VersionKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Provides the state of this Vulnerability assessment.
    /// </summary>
    [EnumType]
    public readonly struct VexAssessmentState : IEquatable<VexAssessmentState>
    {
        private readonly string _value;

        private VexAssessmentState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No state is specified.
        /// </summary>
        public static VexAssessmentState StateUnspecified { get; } = new VexAssessmentState("STATE_UNSPECIFIED");
        /// <summary>
        /// This product is known to be affected by this vulnerability.
        /// </summary>
        public static VexAssessmentState Affected { get; } = new VexAssessmentState("AFFECTED");
        /// <summary>
        /// This product is known to be not affected by this vulnerability.
        /// </summary>
        public static VexAssessmentState NotAffected { get; } = new VexAssessmentState("NOT_AFFECTED");
        /// <summary>
        /// This product contains a fix for this vulnerability.
        /// </summary>
        public static VexAssessmentState Fixed { get; } = new VexAssessmentState("FIXED");
        /// <summary>
        /// It is not known yet whether these versions are or are not affected by the vulnerability. However, it is still under investigation.
        /// </summary>
        public static VexAssessmentState UnderInvestigation { get; } = new VexAssessmentState("UNDER_INVESTIGATION");

        public static bool operator ==(VexAssessmentState left, VexAssessmentState right) => left.Equals(right);
        public static bool operator !=(VexAssessmentState left, VexAssessmentState right) => !left.Equals(right);

        public static explicit operator string(VexAssessmentState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VexAssessmentState other && Equals(other);
        public bool Equals(VexAssessmentState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The distro assigned severity for this vulnerability when that is available and note provider assigned severity when distro has not yet assigned a severity for this vulnerability. When there are multiple package issues for this vulnerability, they can have different effective severities because some might come from the distro and some might come from installed language packs (e.g. Maven JARs or Go binaries). For this reason, it is advised to use the effective severity on the PackageIssue level, as this field may eventually be deprecated. In the case where multiple PackageIssues have different effective severities, the one set here will be the highest severity of any of the PackageIssues.
    /// </summary>
    [EnumType]
    public readonly struct VulnerabilityDetailsEffectiveSeverity : IEquatable<VulnerabilityDetailsEffectiveSeverity>
    {
        private readonly string _value;

        private VulnerabilityDetailsEffectiveSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown Impact
        /// </summary>
        public static VulnerabilityDetailsEffectiveSeverity SeverityUnspecified { get; } = new VulnerabilityDetailsEffectiveSeverity("SEVERITY_UNSPECIFIED");
        /// <summary>
        /// Minimal Impact
        /// </summary>
        public static VulnerabilityDetailsEffectiveSeverity Minimal { get; } = new VulnerabilityDetailsEffectiveSeverity("MINIMAL");
        /// <summary>
        /// Low Impact
        /// </summary>
        public static VulnerabilityDetailsEffectiveSeverity Low { get; } = new VulnerabilityDetailsEffectiveSeverity("LOW");
        /// <summary>
        /// Medium Impact
        /// </summary>
        public static VulnerabilityDetailsEffectiveSeverity Medium { get; } = new VulnerabilityDetailsEffectiveSeverity("MEDIUM");
        /// <summary>
        /// High Impact
        /// </summary>
        public static VulnerabilityDetailsEffectiveSeverity High { get; } = new VulnerabilityDetailsEffectiveSeverity("HIGH");
        /// <summary>
        /// Critical Impact
        /// </summary>
        public static VulnerabilityDetailsEffectiveSeverity Critical { get; } = new VulnerabilityDetailsEffectiveSeverity("CRITICAL");

        public static bool operator ==(VulnerabilityDetailsEffectiveSeverity left, VulnerabilityDetailsEffectiveSeverity right) => left.Equals(right);
        public static bool operator !=(VulnerabilityDetailsEffectiveSeverity left, VulnerabilityDetailsEffectiveSeverity right) => !left.Equals(right);

        public static explicit operator string(VulnerabilityDetailsEffectiveSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VulnerabilityDetailsEffectiveSeverity other && Equals(other);
        public bool Equals(VulnerabilityDetailsEffectiveSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// CVSS version used to populate cvss_score and severity.
    /// </summary>
    [EnumType]
    public readonly struct VulnerabilityTypeCvssVersion : IEquatable<VulnerabilityTypeCvssVersion>
    {
        private readonly string _value;

        private VulnerabilityTypeCvssVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// CVSS Version unspecified.
        /// </summary>
        public static VulnerabilityTypeCvssVersion CvssVersionUnspecified { get; } = new VulnerabilityTypeCvssVersion("CVSS_VERSION_UNSPECIFIED");
        /// <summary>
        /// CVSS v2.
        /// </summary>
        public static VulnerabilityTypeCvssVersion CvssVersion2 { get; } = new VulnerabilityTypeCvssVersion("CVSS_VERSION_2");
        /// <summary>
        /// CVSS v3.
        /// </summary>
        public static VulnerabilityTypeCvssVersion CvssVersion3 { get; } = new VulnerabilityTypeCvssVersion("CVSS_VERSION_3");

        public static bool operator ==(VulnerabilityTypeCvssVersion left, VulnerabilityTypeCvssVersion right) => left.Equals(right);
        public static bool operator !=(VulnerabilityTypeCvssVersion left, VulnerabilityTypeCvssVersion right) => !left.Equals(right);

        public static explicit operator string(VulnerabilityTypeCvssVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VulnerabilityTypeCvssVersion other && Equals(other);
        public bool Equals(VulnerabilityTypeCvssVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Note provider assigned impact of the vulnerability
    /// </summary>
    [EnumType]
    public readonly struct VulnerabilityTypeSeverity : IEquatable<VulnerabilityTypeSeverity>
    {
        private readonly string _value;

        private VulnerabilityTypeSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown Impact
        /// </summary>
        public static VulnerabilityTypeSeverity SeverityUnspecified { get; } = new VulnerabilityTypeSeverity("SEVERITY_UNSPECIFIED");
        /// <summary>
        /// Minimal Impact
        /// </summary>
        public static VulnerabilityTypeSeverity Minimal { get; } = new VulnerabilityTypeSeverity("MINIMAL");
        /// <summary>
        /// Low Impact
        /// </summary>
        public static VulnerabilityTypeSeverity Low { get; } = new VulnerabilityTypeSeverity("LOW");
        /// <summary>
        /// Medium Impact
        /// </summary>
        public static VulnerabilityTypeSeverity Medium { get; } = new VulnerabilityTypeSeverity("MEDIUM");
        /// <summary>
        /// High Impact
        /// </summary>
        public static VulnerabilityTypeSeverity High { get; } = new VulnerabilityTypeSeverity("HIGH");
        /// <summary>
        /// Critical Impact
        /// </summary>
        public static VulnerabilityTypeSeverity Critical { get; } = new VulnerabilityTypeSeverity("CRITICAL");

        public static bool operator ==(VulnerabilityTypeSeverity left, VulnerabilityTypeSeverity right) => left.Equals(right);
        public static bool operator !=(VulnerabilityTypeSeverity left, VulnerabilityTypeSeverity right) => !left.Equals(right);

        public static explicit operator string(VulnerabilityTypeSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VulnerabilityTypeSeverity other && Equals(other);
        public bool Equals(VulnerabilityTypeSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

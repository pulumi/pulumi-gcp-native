// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.VMwareEngine.V1
{
    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct AuditLogConfigLogType : IEquatable<AuditLogConfigLogType>
    {
        private readonly string _value;

        private AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default case. Should never be this.
        /// </summary>
        public static AuditLogConfigLogType LogTypeUnspecified { get; } = new AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");
        /// <summary>
        /// Admin reads. Example: CloudIAM getIamPolicy
        /// </summary>
        public static AuditLogConfigLogType AdminRead { get; } = new AuditLogConfigLogType("ADMIN_READ");
        /// <summary>
        /// Data writes. Example: CloudSQL Users create
        /// </summary>
        public static AuditLogConfigLogType DataWrite { get; } = new AuditLogConfigLogType("DATA_WRITE");
        /// <summary>
        /// Data reads. Example: CloudSQL Users list
        /// </summary>
        public static AuditLogConfigLogType DataRead { get; } = new AuditLogConfigLogType("DATA_READ");

        public static bool operator ==(AuditLogConfigLogType left, AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(AuditLogConfigLogType left, AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuditLogConfigLogType other && Equals(other);
        public bool Equals(AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The action that the external access rule performs.
    /// </summary>
    [EnumType]
    public readonly struct ExternalAccessRuleAction : IEquatable<ExternalAccessRuleAction>
    {
        private readonly string _value;

        private ExternalAccessRuleAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Defaults to allow.
        /// </summary>
        public static ExternalAccessRuleAction ActionUnspecified { get; } = new ExternalAccessRuleAction("ACTION_UNSPECIFIED");
        /// <summary>
        /// Allows connections that match the other specified components.
        /// </summary>
        public static ExternalAccessRuleAction Allow { get; } = new ExternalAccessRuleAction("ALLOW");
        /// <summary>
        /// Blocks connections that match the other specified components.
        /// </summary>
        public static ExternalAccessRuleAction Deny { get; } = new ExternalAccessRuleAction("DENY");

        public static bool operator ==(ExternalAccessRuleAction left, ExternalAccessRuleAction right) => left.Equals(right);
        public static bool operator !=(ExternalAccessRuleAction left, ExternalAccessRuleAction right) => !left.Equals(right);

        public static explicit operator string(ExternalAccessRuleAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExternalAccessRuleAction other && Equals(other);
        public bool Equals(ExternalAccessRuleAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Protocol used by vCenter to send logs to a logging server.
    /// </summary>
    [EnumType]
    public readonly struct LoggingServerProtocol : IEquatable<LoggingServerProtocol>
    {
        private readonly string _value;

        private LoggingServerProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified communications protocol. This is the default value.
        /// </summary>
        public static LoggingServerProtocol ProtocolUnspecified { get; } = new LoggingServerProtocol("PROTOCOL_UNSPECIFIED");
        /// <summary>
        /// UDP
        /// </summary>
        public static LoggingServerProtocol Udp { get; } = new LoggingServerProtocol("UDP");
        /// <summary>
        /// TCP
        /// </summary>
        public static LoggingServerProtocol Tcp { get; } = new LoggingServerProtocol("TCP");

        public static bool operator ==(LoggingServerProtocol left, LoggingServerProtocol right) => left.Equals(right);
        public static bool operator !=(LoggingServerProtocol left, LoggingServerProtocol right) => !left.Equals(right);

        public static explicit operator string(LoggingServerProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingServerProtocol other && Equals(other);
        public bool Equals(LoggingServerProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The type of component that produces logs that will be forwarded to this logging server.
    /// </summary>
    [EnumType]
    public readonly struct LoggingServerSourceType : IEquatable<LoggingServerSourceType>
    {
        private readonly string _value;

        private LoggingServerSourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default value. This value should never be used.
        /// </summary>
        public static LoggingServerSourceType SourceTypeUnspecified { get; } = new LoggingServerSourceType("SOURCE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Logs produced by ESXI hosts
        /// </summary>
        public static LoggingServerSourceType Esxi { get; } = new LoggingServerSourceType("ESXI");
        /// <summary>
        /// Logs produced by vCenter server
        /// </summary>
        public static LoggingServerSourceType Vcsa { get; } = new LoggingServerSourceType("VCSA");

        public static bool operator ==(LoggingServerSourceType left, LoggingServerSourceType right) => left.Equals(right);
        public static bool operator !=(LoggingServerSourceType left, LoggingServerSourceType right) => !left.Equals(right);

        public static explicit operator string(LoggingServerSourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingServerSourceType other && Equals(other);
        public bool Equals(LoggingServerSourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The type of the network to peer with the VMware Engine network.
    /// </summary>
    [EnumType]
    public readonly struct NetworkPeeringPeerNetworkType : IEquatable<NetworkPeeringPeerNetworkType>
    {
        private readonly string _value;

        private NetworkPeeringPeerNetworkType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified
        /// </summary>
        public static NetworkPeeringPeerNetworkType PeerNetworkTypeUnspecified { get; } = new NetworkPeeringPeerNetworkType("PEER_NETWORK_TYPE_UNSPECIFIED");
        /// <summary>
        /// Peering connection used for connecting to another VPC network established by the same user. For example, a peering connection to another VPC network in the same project or to an on-premises network.
        /// </summary>
        public static NetworkPeeringPeerNetworkType Standard { get; } = new NetworkPeeringPeerNetworkType("STANDARD");
        /// <summary>
        /// Peering connection used for connecting to another VMware Engine network.
        /// </summary>
        public static NetworkPeeringPeerNetworkType VmwareEngineNetwork { get; } = new NetworkPeeringPeerNetworkType("VMWARE_ENGINE_NETWORK");
        /// <summary>
        /// Peering connection used for establishing [private services access](https://cloud.google.com/vpc/docs/private-services-access).
        /// </summary>
        public static NetworkPeeringPeerNetworkType PrivateServicesAccess { get; } = new NetworkPeeringPeerNetworkType("PRIVATE_SERVICES_ACCESS");
        /// <summary>
        /// Peering connection used for connecting to NetApp Cloud Volumes.
        /// </summary>
        public static NetworkPeeringPeerNetworkType NetappCloudVolumes { get; } = new NetworkPeeringPeerNetworkType("NETAPP_CLOUD_VOLUMES");
        /// <summary>
        /// Peering connection used for connecting to third-party services. Most third-party services require manual setup of reverse peering on the VPC network associated with the third-party service.
        /// </summary>
        public static NetworkPeeringPeerNetworkType ThirdPartyService { get; } = new NetworkPeeringPeerNetworkType("THIRD_PARTY_SERVICE");
        /// <summary>
        /// Peering connection used for connecting to Dell PowerScale Filers
        /// </summary>
        public static NetworkPeeringPeerNetworkType DellPowerscale { get; } = new NetworkPeeringPeerNetworkType("DELL_POWERSCALE");

        public static bool operator ==(NetworkPeeringPeerNetworkType left, NetworkPeeringPeerNetworkType right) => left.Equals(right);
        public static bool operator !=(NetworkPeeringPeerNetworkType left, NetworkPeeringPeerNetworkType right) => !left.Equals(right);

        public static explicit operator string(NetworkPeeringPeerNetworkType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkPeeringPeerNetworkType other && Equals(other);
        public bool Equals(NetworkPeeringPeerNetworkType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Type of the private cloud. Defaults to STANDARD.
    /// </summary>
    [EnumType]
    public readonly struct PrivateCloudType : IEquatable<PrivateCloudType>
    {
        private readonly string _value;

        private PrivateCloudType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Standard private is a zonal resource, with 3+ nodes. Default type.
        /// </summary>
        public static PrivateCloudType Standard { get; } = new PrivateCloudType("STANDARD");
        /// <summary>
        /// Time limited private cloud is a zonal resource, can have only 1 node and has limited life span. Will be deleted after defined period of time, can be converted into standard private cloud by expanding it up to 3 or more nodes.
        /// </summary>
        public static PrivateCloudType TimeLimited { get; } = new PrivateCloudType("TIME_LIMITED");
        /// <summary>
        /// Stretched private cloud is a regional resource with redundancy, with a minimum of 6 nodes, nodes count has to be even.
        /// </summary>
        public static PrivateCloudType Stretched { get; } = new PrivateCloudType("STRETCHED");

        public static bool operator ==(PrivateCloudType left, PrivateCloudType right) => left.Equals(right);
        public static bool operator !=(PrivateCloudType left, PrivateCloudType right) => !left.Equals(right);

        public static explicit operator string(PrivateCloudType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateCloudType other && Equals(other);
        public bool Equals(PrivateCloudType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Routing Mode. Default value is set to GLOBAL. For type = PRIVATE_SERVICE_ACCESS, this field can be set to GLOBAL or REGIONAL, for other types only GLOBAL is supported.
    /// </summary>
    [EnumType]
    public readonly struct PrivateConnectionRoutingMode : IEquatable<PrivateConnectionRoutingMode>
    {
        private readonly string _value;

        private PrivateConnectionRoutingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default value. This value should never be used.
        /// </summary>
        public static PrivateConnectionRoutingMode RoutingModeUnspecified { get; } = new PrivateConnectionRoutingMode("ROUTING_MODE_UNSPECIFIED");
        /// <summary>
        /// Global Routing Mode
        /// </summary>
        public static PrivateConnectionRoutingMode Global { get; } = new PrivateConnectionRoutingMode("GLOBAL");
        /// <summary>
        /// Regional Routing Mode
        /// </summary>
        public static PrivateConnectionRoutingMode Regional { get; } = new PrivateConnectionRoutingMode("REGIONAL");

        public static bool operator ==(PrivateConnectionRoutingMode left, PrivateConnectionRoutingMode right) => left.Equals(right);
        public static bool operator !=(PrivateConnectionRoutingMode left, PrivateConnectionRoutingMode right) => !left.Equals(right);

        public static explicit operator string(PrivateConnectionRoutingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateConnectionRoutingMode other && Equals(other);
        public bool Equals(PrivateConnectionRoutingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Private connection type.
    /// </summary>
    [EnumType]
    public readonly struct PrivateConnectionType : IEquatable<PrivateConnectionType>
    {
        private readonly string _value;

        private PrivateConnectionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default value. This value should never be used.
        /// </summary>
        public static PrivateConnectionType TypeUnspecified { get; } = new PrivateConnectionType("TYPE_UNSPECIFIED");
        /// <summary>
        /// Connection used for establishing [private services access](https://cloud.google.com/vpc/docs/private-services-access).
        /// </summary>
        public static PrivateConnectionType PrivateServiceAccess { get; } = new PrivateConnectionType("PRIVATE_SERVICE_ACCESS");
        /// <summary>
        /// Connection used for connecting to NetApp Cloud Volumes.
        /// </summary>
        public static PrivateConnectionType NetappCloudVolumes { get; } = new PrivateConnectionType("NETAPP_CLOUD_VOLUMES");
        /// <summary>
        /// Connection used for connecting to Dell PowerScale.
        /// </summary>
        public static PrivateConnectionType DellPowerscale { get; } = new PrivateConnectionType("DELL_POWERSCALE");
        /// <summary>
        /// Connection used for connecting to third-party services.
        /// </summary>
        public static PrivateConnectionType ThirdPartyService { get; } = new PrivateConnectionType("THIRD_PARTY_SERVICE");

        public static bool operator ==(PrivateConnectionType left, PrivateConnectionType right) => left.Equals(right);
        public static bool operator !=(PrivateConnectionType left, PrivateConnectionType right) => !left.Equals(right);

        public static explicit operator string(PrivateConnectionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrivateConnectionType other && Equals(other);
        public bool Equals(PrivateConnectionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. VMware Engine network type.
    /// </summary>
    [EnumType]
    public readonly struct VmwareEngineNetworkType : IEquatable<VmwareEngineNetworkType>
    {
        private readonly string _value;

        private VmwareEngineNetworkType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default value. This value should never be used.
        /// </summary>
        public static VmwareEngineNetworkType TypeUnspecified { get; } = new VmwareEngineNetworkType("TYPE_UNSPECIFIED");
        /// <summary>
        /// Network type used by private clouds created in projects without a network of type `STANDARD`. This network type is no longer used for new VMware Engine private cloud deployments.
        /// </summary>
        public static VmwareEngineNetworkType Legacy { get; } = new VmwareEngineNetworkType("LEGACY");
        /// <summary>
        /// Standard network type used for private cloud connectivity.
        /// </summary>
        public static VmwareEngineNetworkType Standard { get; } = new VmwareEngineNetworkType("STANDARD");

        public static bool operator ==(VmwareEngineNetworkType left, VmwareEngineNetworkType right) => left.Equals(right);
        public static bool operator !=(VmwareEngineNetworkType left, VmwareEngineNetworkType right) => !left.Equals(right);

        public static explicit operator string(VmwareEngineNetworkType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VmwareEngineNetworkType other && Equals(other);
        public bool Equals(VmwareEngineNetworkType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

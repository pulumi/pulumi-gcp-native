// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.GoogleNative.CloudBuild.V1
{
    /// <summary>
    /// Creates a new `BuildTrigger`. This API is experimental.
    /// </summary>
    [GoogleNativeResourceType("google-native:cloudbuild/v1:Trigger")]
    public partial class Trigger : Pulumi.CustomResource
    {
        /// <summary>
        /// Configuration for manual approval to start a build invocation of this BuildTrigger.
        /// </summary>
        [Output("approvalConfig")]
        public Output<Outputs.ApprovalConfigResponse> ApprovalConfig { get; private set; } = null!;

        /// <summary>
        /// Autodetect build configuration. The following precedence is used (case insensitive): 1. cloudbuild.yaml 2. cloudbuild.yml 3. cloudbuild.json 4. Dockerfile Currently only available for GitHub App Triggers.
        /// </summary>
        [Output("autodetect")]
        public Output<bool> Autodetect { get; private set; } = null!;

        /// <summary>
        /// BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
        /// </summary>
        [Output("bitbucketServerTriggerConfig")]
        public Output<Outputs.BitbucketServerTriggerConfigResponse> BitbucketServerTriggerConfig { get; private set; } = null!;

        /// <summary>
        /// Contents of the build template.
        /// </summary>
        [Output("build")]
        public Output<Outputs.BuildResponse> Build { get; private set; } = null!;

        /// <summary>
        /// Time when the trigger was created.
        /// </summary>
        [Output("createTime")]
        public Output<string> CreateTime { get; private set; } = null!;

        /// <summary>
        /// Human-readable description of this trigger.
        /// </summary>
        [Output("description")]
        public Output<string> Description { get; private set; } = null!;

        /// <summary>
        /// If true, the trigger will never automatically execute a build.
        /// </summary>
        [Output("disabled")]
        public Output<bool> Disabled { get; private set; } = null!;

        /// <summary>
        /// EventType allows the user to explicitly set the type of event to which this BuildTrigger should respond. This field will be validated against the rest of the configuration if it is set.
        /// </summary>
        [Output("eventType")]
        public Output<string> EventType { get; private set; } = null!;

        /// <summary>
        /// Path, from the source root, to the build configuration file (i.e. cloudbuild.yaml).
        /// </summary>
        [Output("filename")]
        public Output<string> Filename { get; private set; } = null!;

        /// <summary>
        /// A Common Expression Language string.
        /// </summary>
        [Output("filter")]
        public Output<string> Filter { get; private set; } = null!;

        /// <summary>
        /// The file source describing the local or remote Build template.
        /// </summary>
        [Output("gitFileSource")]
        public Output<Outputs.GitFileSourceResponse> GitFileSource { get; private set; } = null!;

        /// <summary>
        /// GitHubEventsConfig describes the configuration of a trigger that creates a build whenever a GitHub event is received. Mutually exclusive with `trigger_template`.
        /// </summary>
        [Output("github")]
        public Output<Outputs.GitHubEventsConfigResponse> Github { get; private set; } = null!;

        /// <summary>
        /// ignored_files and included_files are file glob matches using https://golang.org/pkg/path/filepath/#Match extended with support for "**". If ignored_files and changed files are both empty, then they are not used to determine whether or not to trigger a build. If ignored_files is not empty, then we ignore any files that match any of the ignored_file globs. If the change has no files that are outside of the ignored_files globs, then we do not trigger a build.
        /// </summary>
        [Output("ignoredFiles")]
        public Output<ImmutableArray<string>> IgnoredFiles { get; private set; } = null!;

        /// <summary>
        /// If any of the files altered in the commit pass the ignored_files filter and included_files is empty, then as far as this filter is concerned, we should trigger the build. If any of the files altered in the commit pass the ignored_files filter and included_files is not empty, then we make sure that at least one of those files matches a included_files glob. If not, then we do not trigger a build.
        /// </summary>
        [Output("includedFiles")]
        public Output<ImmutableArray<string>> IncludedFiles { get; private set; } = null!;

        /// <summary>
        /// User-assigned name of the trigger. Must be unique within the project. Trigger names must meet the following requirements: + They must contain only alphanumeric characters and dashes. + They can be 1-64 characters long. + They must begin and end with an alphanumeric character.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// PubsubConfig describes the configuration of a trigger that creates a build whenever a Pub/Sub message is published.
        /// </summary>
        [Output("pubsubConfig")]
        public Output<Outputs.PubsubConfigResponse> PubsubConfig { get; private set; } = null!;

        /// <summary>
        /// The `Trigger` name with format: `projects/{project}/locations/{location}/triggers/{trigger}`, where {trigger} is a unique identifier generated by the service.
        /// </summary>
        [Output("resourceName")]
        public Output<string> ResourceName { get; private set; } = null!;

        /// <summary>
        /// The service account used for all user-controlled operations including UpdateBuildTrigger, RunBuildTrigger, CreateBuild, and CancelBuild. If no service account is set, then the standard Cloud Build service account ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead. Format: `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}`
        /// </summary>
        [Output("serviceAccount")]
        public Output<string> ServiceAccount { get; private set; } = null!;

        /// <summary>
        /// The repo and ref of the repository from which to build. This field is used only for those triggers that do not respond to SCM events. Triggers that respond to such events build source at whatever commit caused the event. This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
        /// </summary>
        [Output("sourceToBuild")]
        public Output<Outputs.GitRepoSourceResponse> SourceToBuild { get; private set; } = null!;

        /// <summary>
        /// Substitutions for Build resource. The keys must match the following regular expression: `^_[A-Z0-9_]+$`.
        /// </summary>
        [Output("substitutions")]
        public Output<ImmutableDictionary<string, string>> Substitutions { get; private set; } = null!;

        /// <summary>
        /// Tags for annotation of a `BuildTrigger`
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<string>> Tags { get; private set; } = null!;

        /// <summary>
        /// Template describing the types of source changes to trigger a build. Branch and tag names in trigger templates are interpreted as regular expressions. Any branch or tag change that matches that regular expression will trigger a build. Mutually exclusive with `github`.
        /// </summary>
        [Output("triggerTemplate")]
        public Output<Outputs.RepoSourceResponse> TriggerTemplate { get; private set; } = null!;

        /// <summary>
        /// WebhookConfig describes the configuration of a trigger that creates a build whenever a webhook is sent to a trigger's webhook URL.
        /// </summary>
        [Output("webhookConfig")]
        public Output<Outputs.WebhookConfigResponse> WebhookConfig { get; private set; } = null!;


        /// <summary>
        /// Create a Trigger resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Trigger(string name, TriggerArgs args, CustomResourceOptions? options = null)
            : base("google-native:cloudbuild/v1:Trigger", name, args ?? new TriggerArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Trigger(string name, Input<string> id, CustomResourceOptions? options = null)
            : base("google-native:cloudbuild/v1:Trigger", name, null, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Trigger resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Trigger Get(string name, Input<string> id, CustomResourceOptions? options = null)
        {
            return new Trigger(name, id, options);
        }
    }

    public sealed class TriggerArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Configuration for manual approval to start a build invocation of this BuildTrigger.
        /// </summary>
        [Input("approvalConfig")]
        public Input<Inputs.ApprovalConfigArgs>? ApprovalConfig { get; set; }

        /// <summary>
        /// Autodetect build configuration. The following precedence is used (case insensitive): 1. cloudbuild.yaml 2. cloudbuild.yml 3. cloudbuild.json 4. Dockerfile Currently only available for GitHub App Triggers.
        /// </summary>
        [Input("autodetect")]
        public Input<bool>? Autodetect { get; set; }

        /// <summary>
        /// BitbucketServerTriggerConfig describes the configuration of a trigger that creates a build whenever a Bitbucket Server event is received.
        /// </summary>
        [Input("bitbucketServerTriggerConfig")]
        public Input<Inputs.BitbucketServerTriggerConfigArgs>? BitbucketServerTriggerConfig { get; set; }

        /// <summary>
        /// Contents of the build template.
        /// </summary>
        [Input("build")]
        public Input<Inputs.BuildArgs>? Build { get; set; }

        /// <summary>
        /// Human-readable description of this trigger.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// If true, the trigger will never automatically execute a build.
        /// </summary>
        [Input("disabled")]
        public Input<bool>? Disabled { get; set; }

        /// <summary>
        /// EventType allows the user to explicitly set the type of event to which this BuildTrigger should respond. This field will be validated against the rest of the configuration if it is set.
        /// </summary>
        [Input("eventType")]
        public Input<Pulumi.GoogleNative.CloudBuild.V1.TriggerEventType>? EventType { get; set; }

        /// <summary>
        /// Path, from the source root, to the build configuration file (i.e. cloudbuild.yaml).
        /// </summary>
        [Input("filename")]
        public Input<string>? Filename { get; set; }

        /// <summary>
        /// A Common Expression Language string.
        /// </summary>
        [Input("filter")]
        public Input<string>? Filter { get; set; }

        /// <summary>
        /// The file source describing the local or remote Build template.
        /// </summary>
        [Input("gitFileSource")]
        public Input<Inputs.GitFileSourceArgs>? GitFileSource { get; set; }

        /// <summary>
        /// GitHubEventsConfig describes the configuration of a trigger that creates a build whenever a GitHub event is received. Mutually exclusive with `trigger_template`.
        /// </summary>
        [Input("github")]
        public Input<Inputs.GitHubEventsConfigArgs>? Github { get; set; }

        [Input("ignoredFiles")]
        private InputList<string>? _ignoredFiles;

        /// <summary>
        /// ignored_files and included_files are file glob matches using https://golang.org/pkg/path/filepath/#Match extended with support for "**". If ignored_files and changed files are both empty, then they are not used to determine whether or not to trigger a build. If ignored_files is not empty, then we ignore any files that match any of the ignored_file globs. If the change has no files that are outside of the ignored_files globs, then we do not trigger a build.
        /// </summary>
        public InputList<string> IgnoredFiles
        {
            get => _ignoredFiles ?? (_ignoredFiles = new InputList<string>());
            set => _ignoredFiles = value;
        }

        [Input("includedFiles")]
        private InputList<string>? _includedFiles;

        /// <summary>
        /// If any of the files altered in the commit pass the ignored_files filter and included_files is empty, then as far as this filter is concerned, we should trigger the build. If any of the files altered in the commit pass the ignored_files filter and included_files is not empty, then we make sure that at least one of those files matches a included_files glob. If not, then we do not trigger a build.
        /// </summary>
        public InputList<string> IncludedFiles
        {
            get => _includedFiles ?? (_includedFiles = new InputList<string>());
            set => _includedFiles = value;
        }

        [Input("location")]
        public Input<string>? Location { get; set; }

        /// <summary>
        /// User-assigned name of the trigger. Must be unique within the project. Trigger names must meet the following requirements: + They must contain only alphanumeric characters and dashes. + They can be 1-64 characters long. + They must begin and end with an alphanumeric character.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("project")]
        public Input<string>? Project { get; set; }

        [Input("projectId", required: true)]
        public Input<string> ProjectId { get; set; } = null!;

        /// <summary>
        /// PubsubConfig describes the configuration of a trigger that creates a build whenever a Pub/Sub message is published.
        /// </summary>
        [Input("pubsubConfig")]
        public Input<Inputs.PubsubConfigArgs>? PubsubConfig { get; set; }

        /// <summary>
        /// The `Trigger` name with format: `projects/{project}/locations/{location}/triggers/{trigger}`, where {trigger} is a unique identifier generated by the service.
        /// </summary>
        [Input("resourceName")]
        public Input<string>? ResourceName { get; set; }

        /// <summary>
        /// The service account used for all user-controlled operations including UpdateBuildTrigger, RunBuildTrigger, CreateBuild, and CancelBuild. If no service account is set, then the standard Cloud Build service account ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead. Format: `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}`
        /// </summary>
        [Input("serviceAccount")]
        public Input<string>? ServiceAccount { get; set; }

        /// <summary>
        /// The repo and ref of the repository from which to build. This field is used only for those triggers that do not respond to SCM events. Triggers that respond to such events build source at whatever commit caused the event. This field is currently only used by Webhook, Pub/Sub, Manual, and Cron triggers.
        /// </summary>
        [Input("sourceToBuild")]
        public Input<Inputs.GitRepoSourceArgs>? SourceToBuild { get; set; }

        [Input("substitutions")]
        private InputMap<string>? _substitutions;

        /// <summary>
        /// Substitutions for Build resource. The keys must match the following regular expression: `^_[A-Z0-9_]+$`.
        /// </summary>
        public InputMap<string> Substitutions
        {
            get => _substitutions ?? (_substitutions = new InputMap<string>());
            set => _substitutions = value;
        }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// Tags for annotation of a `BuildTrigger`
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Template describing the types of source changes to trigger a build. Branch and tag names in trigger templates are interpreted as regular expressions. Any branch or tag change that matches that regular expression will trigger a build. Mutually exclusive with `github`.
        /// </summary>
        [Input("triggerTemplate")]
        public Input<Inputs.RepoSourceArgs>? TriggerTemplate { get; set; }

        /// <summary>
        /// WebhookConfig describes the configuration of a trigger that creates a build whenever a webhook is sent to a trigger's webhook URL.
        /// </summary>
        [Input("webhookConfig")]
        public Input<Inputs.WebhookConfigArgs>? WebhookConfig { get; set; }

        public TriggerArgs()
        {
        }
    }
}

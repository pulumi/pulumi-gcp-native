// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.CloudBuild.V1
{
    /// <summary>
    /// Optional. Option to specify how default logs buckets are setup.
    /// </summary>
    [EnumType]
    public readonly struct BuildOptionsDefaultLogsBucketBehavior : IEquatable<BuildOptionsDefaultLogsBucketBehavior>
    {
        private readonly string _value;

        private BuildOptionsDefaultLogsBucketBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified.
        /// </summary>
        public static BuildOptionsDefaultLogsBucketBehavior DefaultLogsBucketBehaviorUnspecified { get; } = new BuildOptionsDefaultLogsBucketBehavior("DEFAULT_LOGS_BUCKET_BEHAVIOR_UNSPECIFIED");
        /// <summary>
        /// Bucket is located in user-owned project in the same region as the build. The builder service account must have access to create and write to GCS buckets in the build project.
        /// </summary>
        public static BuildOptionsDefaultLogsBucketBehavior RegionalUserOwnedBucket { get; } = new BuildOptionsDefaultLogsBucketBehavior("REGIONAL_USER_OWNED_BUCKET");

        public static bool operator ==(BuildOptionsDefaultLogsBucketBehavior left, BuildOptionsDefaultLogsBucketBehavior right) => left.Equals(right);
        public static bool operator !=(BuildOptionsDefaultLogsBucketBehavior left, BuildOptionsDefaultLogsBucketBehavior right) => !left.Equals(right);

        public static explicit operator string(BuildOptionsDefaultLogsBucketBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BuildOptionsDefaultLogsBucketBehavior other && Equals(other);
        public bool Equals(BuildOptionsDefaultLogsBucketBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Option to define build log streaming behavior to Google Cloud Storage.
    /// </summary>
    [EnumType]
    public readonly struct BuildOptionsLogStreamingOption : IEquatable<BuildOptionsLogStreamingOption>
    {
        private readonly string _value;

        private BuildOptionsLogStreamingOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Service may automatically determine build log streaming behavior.
        /// </summary>
        public static BuildOptionsLogStreamingOption StreamDefault { get; } = new BuildOptionsLogStreamingOption("STREAM_DEFAULT");
        /// <summary>
        /// Build logs should be streamed to Google Cloud Storage.
        /// </summary>
        public static BuildOptionsLogStreamingOption StreamOn { get; } = new BuildOptionsLogStreamingOption("STREAM_ON");
        /// <summary>
        /// Build logs should not be streamed to Google Cloud Storage; they will be written when the build is completed.
        /// </summary>
        public static BuildOptionsLogStreamingOption StreamOff { get; } = new BuildOptionsLogStreamingOption("STREAM_OFF");

        public static bool operator ==(BuildOptionsLogStreamingOption left, BuildOptionsLogStreamingOption right) => left.Equals(right);
        public static bool operator !=(BuildOptionsLogStreamingOption left, BuildOptionsLogStreamingOption right) => !left.Equals(right);

        public static explicit operator string(BuildOptionsLogStreamingOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BuildOptionsLogStreamingOption other && Equals(other);
        public bool Equals(BuildOptionsLogStreamingOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Option to specify the logging mode, which determines if and where build logs are stored.
    /// </summary>
    [EnumType]
    public readonly struct BuildOptionsLogging : IEquatable<BuildOptionsLogging>
    {
        private readonly string _value;

        private BuildOptionsLogging(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The service determines the logging mode. The default is `LEGACY`. Do not rely on the default logging behavior as it may change in the future.
        /// </summary>
        public static BuildOptionsLogging LoggingUnspecified { get; } = new BuildOptionsLogging("LOGGING_UNSPECIFIED");
        /// <summary>
        /// Build logs are stored in Cloud Logging and Cloud Storage.
        /// </summary>
        public static BuildOptionsLogging Legacy { get; } = new BuildOptionsLogging("LEGACY");
        /// <summary>
        /// Build logs are stored in Cloud Storage.
        /// </summary>
        public static BuildOptionsLogging GcsOnly { get; } = new BuildOptionsLogging("GCS_ONLY");
        /// <summary>
        /// This option is the same as CLOUD_LOGGING_ONLY.
        /// </summary>
        public static BuildOptionsLogging StackdriverOnly { get; } = new BuildOptionsLogging("STACKDRIVER_ONLY");
        /// <summary>
        /// Build logs are stored in Cloud Logging. Selecting this option will not allow [logs streaming](https://cloud.google.com/sdk/gcloud/reference/builds/log).
        /// </summary>
        public static BuildOptionsLogging CloudLoggingOnly { get; } = new BuildOptionsLogging("CLOUD_LOGGING_ONLY");
        /// <summary>
        /// Turn off all logging. No build logs will be captured.
        /// </summary>
        public static BuildOptionsLogging None { get; } = new BuildOptionsLogging("NONE");

        public static bool operator ==(BuildOptionsLogging left, BuildOptionsLogging right) => left.Equals(right);
        public static bool operator !=(BuildOptionsLogging left, BuildOptionsLogging right) => !left.Equals(right);

        public static explicit operator string(BuildOptionsLogging value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BuildOptionsLogging other && Equals(other);
        public bool Equals(BuildOptionsLogging other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Compute Engine machine type on which to run the build.
    /// </summary>
    [EnumType]
    public readonly struct BuildOptionsMachineType : IEquatable<BuildOptionsMachineType>
    {
        private readonly string _value;

        private BuildOptionsMachineType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Standard machine type.
        /// </summary>
        public static BuildOptionsMachineType Unspecified { get; } = new BuildOptionsMachineType("UNSPECIFIED");
        /// <summary>
        /// Highcpu machine with 8 CPUs.
        /// </summary>
        public static BuildOptionsMachineType N1Highcpu8 { get; } = new BuildOptionsMachineType("N1_HIGHCPU_8");
        /// <summary>
        /// Highcpu machine with 32 CPUs.
        /// </summary>
        public static BuildOptionsMachineType N1Highcpu32 { get; } = new BuildOptionsMachineType("N1_HIGHCPU_32");
        /// <summary>
        /// Highcpu e2 machine with 8 CPUs.
        /// </summary>
        public static BuildOptionsMachineType E2Highcpu8 { get; } = new BuildOptionsMachineType("E2_HIGHCPU_8");
        /// <summary>
        /// Highcpu e2 machine with 32 CPUs.
        /// </summary>
        public static BuildOptionsMachineType E2Highcpu32 { get; } = new BuildOptionsMachineType("E2_HIGHCPU_32");

        public static bool operator ==(BuildOptionsMachineType left, BuildOptionsMachineType right) => left.Equals(right);
        public static bool operator !=(BuildOptionsMachineType left, BuildOptionsMachineType right) => !left.Equals(right);

        public static explicit operator string(BuildOptionsMachineType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BuildOptionsMachineType other && Equals(other);
        public bool Equals(BuildOptionsMachineType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Requested verifiability options.
    /// </summary>
    [EnumType]
    public readonly struct BuildOptionsRequestedVerifyOption : IEquatable<BuildOptionsRequestedVerifyOption>
    {
        private readonly string _value;

        private BuildOptionsRequestedVerifyOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not a verifiable build (the default).
        /// </summary>
        public static BuildOptionsRequestedVerifyOption NotVerified { get; } = new BuildOptionsRequestedVerifyOption("NOT_VERIFIED");
        /// <summary>
        /// Build must be verified.
        /// </summary>
        public static BuildOptionsRequestedVerifyOption Verified { get; } = new BuildOptionsRequestedVerifyOption("VERIFIED");

        public static bool operator ==(BuildOptionsRequestedVerifyOption left, BuildOptionsRequestedVerifyOption right) => left.Equals(right);
        public static bool operator !=(BuildOptionsRequestedVerifyOption left, BuildOptionsRequestedVerifyOption right) => !left.Equals(right);

        public static explicit operator string(BuildOptionsRequestedVerifyOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BuildOptionsRequestedVerifyOption other && Equals(other);
        public bool Equals(BuildOptionsRequestedVerifyOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct BuildOptionsSourceProvenanceHashItem : IEquatable<BuildOptionsSourceProvenanceHashItem>
    {
        private readonly string _value;

        private BuildOptionsSourceProvenanceHashItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No hash requested.
        /// </summary>
        public static BuildOptionsSourceProvenanceHashItem None { get; } = new BuildOptionsSourceProvenanceHashItem("NONE");
        /// <summary>
        /// Use a sha256 hash.
        /// </summary>
        public static BuildOptionsSourceProvenanceHashItem Sha256 { get; } = new BuildOptionsSourceProvenanceHashItem("SHA256");
        /// <summary>
        /// Use a md5 hash.
        /// </summary>
        public static BuildOptionsSourceProvenanceHashItem Md5 { get; } = new BuildOptionsSourceProvenanceHashItem("MD5");
        /// <summary>
        /// Use a sha512 hash.
        /// </summary>
        public static BuildOptionsSourceProvenanceHashItem Sha512 { get; } = new BuildOptionsSourceProvenanceHashItem("SHA512");

        public static bool operator ==(BuildOptionsSourceProvenanceHashItem left, BuildOptionsSourceProvenanceHashItem right) => left.Equals(right);
        public static bool operator !=(BuildOptionsSourceProvenanceHashItem left, BuildOptionsSourceProvenanceHashItem right) => !left.Equals(right);

        public static explicit operator string(BuildOptionsSourceProvenanceHashItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BuildOptionsSourceProvenanceHashItem other && Equals(other);
        public bool Equals(BuildOptionsSourceProvenanceHashItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Option to specify behavior when there is an error in the substitution checks. NOTE: this is always set to ALLOW_LOOSE for triggered builds and cannot be overridden in the build configuration file.
    /// </summary>
    [EnumType]
    public readonly struct BuildOptionsSubstitutionOption : IEquatable<BuildOptionsSubstitutionOption>
    {
        private readonly string _value;

        private BuildOptionsSubstitutionOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Fails the build if error in substitutions checks, like missing a substitution in the template or in the map.
        /// </summary>
        public static BuildOptionsSubstitutionOption MustMatch { get; } = new BuildOptionsSubstitutionOption("MUST_MATCH");
        /// <summary>
        /// Do not fail the build if error in substitutions checks.
        /// </summary>
        public static BuildOptionsSubstitutionOption AllowLoose { get; } = new BuildOptionsSubstitutionOption("ALLOW_LOOSE");

        public static bool operator ==(BuildOptionsSubstitutionOption left, BuildOptionsSubstitutionOption right) => left.Equals(right);
        public static bool operator !=(BuildOptionsSubstitutionOption left, BuildOptionsSubstitutionOption right) => !left.Equals(right);

        public static explicit operator string(BuildOptionsSubstitutionOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BuildOptionsSubstitutionOption other && Equals(other);
        public bool Equals(BuildOptionsSubstitutionOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// See RepoType above.
    /// </summary>
    [EnumType]
    public readonly struct GitFileSourceRepoType : IEquatable<GitFileSourceRepoType>
    {
        private readonly string _value;

        private GitFileSourceRepoType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default, unknown repo type. Don't use it, instead use one of the other repo types.
        /// </summary>
        public static GitFileSourceRepoType Unknown { get; } = new GitFileSourceRepoType("UNKNOWN");
        /// <summary>
        /// A Google Cloud Source Repositories-hosted repo.
        /// </summary>
        public static GitFileSourceRepoType CloudSourceRepositories { get; } = new GitFileSourceRepoType("CLOUD_SOURCE_REPOSITORIES");
        /// <summary>
        /// A GitHub-hosted repo not necessarily on "github.com" (i.e. GitHub Enterprise).
        /// </summary>
        public static GitFileSourceRepoType Github { get; } = new GitFileSourceRepoType("GITHUB");
        /// <summary>
        /// A Bitbucket Server-hosted repo.
        /// </summary>
        public static GitFileSourceRepoType BitbucketServer { get; } = new GitFileSourceRepoType("BITBUCKET_SERVER");
        /// <summary>
        /// A GitLab-hosted repo.
        /// </summary>
        public static GitFileSourceRepoType Gitlab { get; } = new GitFileSourceRepoType("GITLAB");

        public static bool operator ==(GitFileSourceRepoType left, GitFileSourceRepoType right) => left.Equals(right);
        public static bool operator !=(GitFileSourceRepoType left, GitFileSourceRepoType right) => !left.Equals(right);

        public static explicit operator string(GitFileSourceRepoType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GitFileSourceRepoType other && Equals(other);
        public bool Equals(GitFileSourceRepoType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// See RepoType below.
    /// </summary>
    [EnumType]
    public readonly struct GitRepoSourceRepoType : IEquatable<GitRepoSourceRepoType>
    {
        private readonly string _value;

        private GitRepoSourceRepoType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default, unknown repo type. Don't use it, instead use one of the other repo types.
        /// </summary>
        public static GitRepoSourceRepoType Unknown { get; } = new GitRepoSourceRepoType("UNKNOWN");
        /// <summary>
        /// A Google Cloud Source Repositories-hosted repo.
        /// </summary>
        public static GitRepoSourceRepoType CloudSourceRepositories { get; } = new GitRepoSourceRepoType("CLOUD_SOURCE_REPOSITORIES");
        /// <summary>
        /// A GitHub-hosted repo not necessarily on "github.com" (i.e. GitHub Enterprise).
        /// </summary>
        public static GitRepoSourceRepoType Github { get; } = new GitRepoSourceRepoType("GITHUB");
        /// <summary>
        /// A Bitbucket Server-hosted repo.
        /// </summary>
        public static GitRepoSourceRepoType BitbucketServer { get; } = new GitRepoSourceRepoType("BITBUCKET_SERVER");
        /// <summary>
        /// A GitLab-hosted repo.
        /// </summary>
        public static GitRepoSourceRepoType Gitlab { get; } = new GitRepoSourceRepoType("GITLAB");

        public static bool operator ==(GitRepoSourceRepoType left, GitRepoSourceRepoType right) => left.Equals(right);
        public static bool operator !=(GitRepoSourceRepoType left, GitRepoSourceRepoType right) => !left.Equals(right);

        public static explicit operator string(GitRepoSourceRepoType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GitRepoSourceRepoType other && Equals(other);
        public bool Equals(GitRepoSourceRepoType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Option to configure network egress for the workers.
    /// </summary>
    [EnumType]
    public readonly struct NetworkConfigEgressOption : IEquatable<NetworkConfigEgressOption>
    {
        private readonly string _value;

        private NetworkConfigEgressOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// If set, defaults to PUBLIC_EGRESS.
        /// </summary>
        public static NetworkConfigEgressOption EgressOptionUnspecified { get; } = new NetworkConfigEgressOption("EGRESS_OPTION_UNSPECIFIED");
        /// <summary>
        /// If set, workers are created without any public address, which prevents network egress to public IPs unless a network proxy is configured.
        /// </summary>
        public static NetworkConfigEgressOption NoPublicEgress { get; } = new NetworkConfigEgressOption("NO_PUBLIC_EGRESS");
        /// <summary>
        /// If set, workers are created with a public address which allows for public internet egress.
        /// </summary>
        public static NetworkConfigEgressOption PublicEgress { get; } = new NetworkConfigEgressOption("PUBLIC_EGRESS");

        public static bool operator ==(NetworkConfigEgressOption left, NetworkConfigEgressOption right) => left.Equals(right);
        public static bool operator !=(NetworkConfigEgressOption left, NetworkConfigEgressOption right) => !left.Equals(right);

        public static explicit operator string(NetworkConfigEgressOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkConfigEgressOption other && Equals(other);
        public bool Equals(NetworkConfigEgressOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Potential issues with the underlying Pub/Sub subscription configuration. Only populated on get requests.
    /// </summary>
    [EnumType]
    public readonly struct PubsubConfigState : IEquatable<PubsubConfigState>
    {
        private readonly string _value;

        private PubsubConfigState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The subscription configuration has not been checked.
        /// </summary>
        public static PubsubConfigState StateUnspecified { get; } = new PubsubConfigState("STATE_UNSPECIFIED");
        /// <summary>
        /// The Pub/Sub subscription is properly configured.
        /// </summary>
        public static PubsubConfigState Ok { get; } = new PubsubConfigState("OK");
        /// <summary>
        /// The subscription has been deleted.
        /// </summary>
        public static PubsubConfigState SubscriptionDeleted { get; } = new PubsubConfigState("SUBSCRIPTION_DELETED");
        /// <summary>
        /// The topic has been deleted.
        /// </summary>
        public static PubsubConfigState TopicDeleted { get; } = new PubsubConfigState("TOPIC_DELETED");
        /// <summary>
        /// Some of the subscription's field are misconfigured.
        /// </summary>
        public static PubsubConfigState SubscriptionMisconfigured { get; } = new PubsubConfigState("SUBSCRIPTION_MISCONFIGURED");

        public static bool operator ==(PubsubConfigState left, PubsubConfigState right) => left.Equals(right);
        public static bool operator !=(PubsubConfigState left, PubsubConfigState right) => !left.Equals(right);

        public static explicit operator string(PubsubConfigState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PubsubConfigState other && Equals(other);
        public bool Equals(PubsubConfigState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Configure builds to run whether a repository owner or collaborator need to comment `/gcbrun`.
    /// </summary>
    [EnumType]
    public readonly struct PullRequestFilterCommentControl : IEquatable<PullRequestFilterCommentControl>
    {
        private readonly string _value;

        private PullRequestFilterCommentControl(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not require comments on Pull Requests before builds are triggered.
        /// </summary>
        public static PullRequestFilterCommentControl CommentsDisabled { get; } = new PullRequestFilterCommentControl("COMMENTS_DISABLED");
        /// <summary>
        /// Enforce that repository owners or collaborators must comment on Pull Requests before builds are triggered.
        /// </summary>
        public static PullRequestFilterCommentControl CommentsEnabled { get; } = new PullRequestFilterCommentControl("COMMENTS_ENABLED");
        /// <summary>
        /// Enforce that repository owners or collaborators must comment on external contributors' Pull Requests before builds are triggered.
        /// </summary>
        public static PullRequestFilterCommentControl CommentsEnabledForExternalContributorsOnly { get; } = new PullRequestFilterCommentControl("COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY");

        public static bool operator ==(PullRequestFilterCommentControl left, PullRequestFilterCommentControl right) => left.Equals(right);
        public static bool operator !=(PullRequestFilterCommentControl left, PullRequestFilterCommentControl right) => !left.Equals(right);

        public static explicit operator string(PullRequestFilterCommentControl value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PullRequestFilterCommentControl other && Equals(other);
        public bool Equals(PullRequestFilterCommentControl other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// EventType allows the user to explicitly set the type of event to which this BuildTrigger should respond. This field will be validated against the rest of the configuration if it is set.
    /// </summary>
    [EnumType]
    public readonly struct TriggerEventType : IEquatable<TriggerEventType>
    {
        private readonly string _value;

        private TriggerEventType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// EVENT_TYPE_UNSPECIFIED event_types are ignored.
        /// </summary>
        public static TriggerEventType EventTypeUnspecified { get; } = new TriggerEventType("EVENT_TYPE_UNSPECIFIED");
        /// <summary>
        /// REPO corresponds to the supported VCS integrations.
        /// </summary>
        public static TriggerEventType Repo { get; } = new TriggerEventType("REPO");
        /// <summary>
        /// WEBHOOK corresponds to webhook triggers.
        /// </summary>
        public static TriggerEventType Webhook { get; } = new TriggerEventType("WEBHOOK");
        /// <summary>
        /// PUBSUB corresponds to pubsub triggers.
        /// </summary>
        public static TriggerEventType Pubsub { get; } = new TriggerEventType("PUBSUB");
        /// <summary>
        /// MANUAL corresponds to manual-only invoked triggers.
        /// </summary>
        public static TriggerEventType Manual { get; } = new TriggerEventType("MANUAL");

        public static bool operator ==(TriggerEventType left, TriggerEventType right) => left.Equals(right);
        public static bool operator !=(TriggerEventType left, TriggerEventType right) => !left.Equals(right);

        public static explicit operator string(TriggerEventType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TriggerEventType other && Equals(other);
        public bool Equals(TriggerEventType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If set to INCLUDE_BUILD_LOGS_WITH_STATUS, log url will be shown on GitHub page when build status is final. Setting this field to INCLUDE_BUILD_LOGS_WITH_STATUS for non GitHub triggers results in INVALID_ARGUMENT error.
    /// </summary>
    [EnumType]
    public readonly struct TriggerIncludeBuildLogs : IEquatable<TriggerIncludeBuildLogs>
    {
        private readonly string _value;

        private TriggerIncludeBuildLogs(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Build logs will not be shown on GitHub.
        /// </summary>
        public static TriggerIncludeBuildLogs IncludeBuildLogsUnspecified { get; } = new TriggerIncludeBuildLogs("INCLUDE_BUILD_LOGS_UNSPECIFIED");
        /// <summary>
        /// Build logs will be shown on GitHub.
        /// </summary>
        public static TriggerIncludeBuildLogs IncludeBuildLogsWithStatus { get; } = new TriggerIncludeBuildLogs("INCLUDE_BUILD_LOGS_WITH_STATUS");

        public static bool operator ==(TriggerIncludeBuildLogs left, TriggerIncludeBuildLogs right) => left.Equals(right);
        public static bool operator !=(TriggerIncludeBuildLogs left, TriggerIncludeBuildLogs right) => !left.Equals(right);

        public static explicit operator string(TriggerIncludeBuildLogs value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TriggerIncludeBuildLogs other && Equals(other);
        public bool Equals(TriggerIncludeBuildLogs other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Potential issues with the underlying Pub/Sub subscription configuration. Only populated on get requests.
    /// </summary>
    [EnumType]
    public readonly struct WebhookConfigState : IEquatable<WebhookConfigState>
    {
        private readonly string _value;

        private WebhookConfigState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The webhook auth configuration not been checked.
        /// </summary>
        public static WebhookConfigState StateUnspecified { get; } = new WebhookConfigState("STATE_UNSPECIFIED");
        /// <summary>
        /// The auth configuration is properly setup.
        /// </summary>
        public static WebhookConfigState Ok { get; } = new WebhookConfigState("OK");
        /// <summary>
        /// The secret provided in auth_method has been deleted.
        /// </summary>
        public static WebhookConfigState SecretDeleted { get; } = new WebhookConfigState("SECRET_DELETED");

        public static bool operator ==(WebhookConfigState left, WebhookConfigState right) => left.Equals(right);
        public static bool operator !=(WebhookConfigState left, WebhookConfigState right) => !left.Equals(right);

        public static explicit operator string(WebhookConfigState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebhookConfigState other && Equals(other);
        public bool Equals(WebhookConfigState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

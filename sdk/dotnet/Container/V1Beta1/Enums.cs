// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Container.V1Beta1
{
    /// <summary>
    /// Mode of operation for binauthz policy evaluation. Currently the only options are equivalent to enable/disable. If unspecified, defaults to DISABLED.
    /// </summary>
    [EnumType]
    public readonly struct BinaryAuthorizationEvaluationMode : IEquatable<BinaryAuthorizationEvaluationMode>
    {
        private readonly string _value;

        private BinaryAuthorizationEvaluationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value, equivalent to DISABLED.
        /// </summary>
        public static BinaryAuthorizationEvaluationMode EvaluationModeUnspecified { get; } = new BinaryAuthorizationEvaluationMode("EVALUATION_MODE_UNSPECIFIED");
        /// <summary>
        /// Disable BinaryAuthorization
        /// </summary>
        public static BinaryAuthorizationEvaluationMode Disabled { get; } = new BinaryAuthorizationEvaluationMode("DISABLED");
        /// <summary>
        /// If enabled, enforce Kubernetes admission requests with BinAuthz using the project's singleton policy. Equivalent to bool enabled=true.
        /// </summary>
        public static BinaryAuthorizationEvaluationMode ProjectSingletonPolicyEnforce { get; } = new BinaryAuthorizationEvaluationMode("PROJECT_SINGLETON_POLICY_ENFORCE");

        public static bool operator ==(BinaryAuthorizationEvaluationMode left, BinaryAuthorizationEvaluationMode right) => left.Equals(right);
        public static bool operator !=(BinaryAuthorizationEvaluationMode left, BinaryAuthorizationEvaluationMode right) => !left.Equals(right);

        public static explicit operator string(BinaryAuthorizationEvaluationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BinaryAuthorizationEvaluationMode other && Equals(other);
        public bool Equals(BinaryAuthorizationEvaluationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Which load balancer type is installed for Cloud Run.
    /// </summary>
    [EnumType]
    public readonly struct CloudRunConfigLoadBalancerType : IEquatable<CloudRunConfigLoadBalancerType>
    {
        private readonly string _value;

        private CloudRunConfigLoadBalancerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Load balancer type for Cloud Run is unspecified.
        /// </summary>
        public static CloudRunConfigLoadBalancerType LoadBalancerTypeUnspecified { get; } = new CloudRunConfigLoadBalancerType("LOAD_BALANCER_TYPE_UNSPECIFIED");
        /// <summary>
        /// Install external load balancer for Cloud Run.
        /// </summary>
        public static CloudRunConfigLoadBalancerType LoadBalancerTypeExternal { get; } = new CloudRunConfigLoadBalancerType("LOAD_BALANCER_TYPE_EXTERNAL");
        /// <summary>
        /// Install internal load balancer for Cloud Run.
        /// </summary>
        public static CloudRunConfigLoadBalancerType LoadBalancerTypeInternal { get; } = new CloudRunConfigLoadBalancerType("LOAD_BALANCER_TYPE_INTERNAL");

        public static bool operator ==(CloudRunConfigLoadBalancerType left, CloudRunConfigLoadBalancerType right) => left.Equals(right);
        public static bool operator !=(CloudRunConfigLoadBalancerType left, CloudRunConfigLoadBalancerType right) => !left.Equals(right);

        public static explicit operator string(CloudRunConfigLoadBalancerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CloudRunConfigLoadBalancerType other && Equals(other);
        public bool Equals(CloudRunConfigLoadBalancerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines autoscaling behaviour.
    /// </summary>
    [EnumType]
    public readonly struct ClusterAutoscalingAutoscalingProfile : IEquatable<ClusterAutoscalingAutoscalingProfile>
    {
        private readonly string _value;

        private ClusterAutoscalingAutoscalingProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No change to autoscaling configuration.
        /// </summary>
        public static ClusterAutoscalingAutoscalingProfile ProfileUnspecified { get; } = new ClusterAutoscalingAutoscalingProfile("PROFILE_UNSPECIFIED");
        /// <summary>
        /// Prioritize optimizing utilization of resources.
        /// </summary>
        public static ClusterAutoscalingAutoscalingProfile OptimizeUtilization { get; } = new ClusterAutoscalingAutoscalingProfile("OPTIMIZE_UTILIZATION");
        /// <summary>
        /// Use default (balanced) autoscaling configuration.
        /// </summary>
        public static ClusterAutoscalingAutoscalingProfile Balanced { get; } = new ClusterAutoscalingAutoscalingProfile("BALANCED");

        public static bool operator ==(ClusterAutoscalingAutoscalingProfile left, ClusterAutoscalingAutoscalingProfile right) => left.Equals(right);
        public static bool operator !=(ClusterAutoscalingAutoscalingProfile left, ClusterAutoscalingAutoscalingProfile right) => !left.Equals(right);

        public static explicit operator string(ClusterAutoscalingAutoscalingProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterAutoscalingAutoscalingProfile other && Equals(other);
        public bool Equals(ClusterAutoscalingAutoscalingProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the integration.
    /// </summary>
    [EnumType]
    public readonly struct ClusterTelemetryType : IEquatable<ClusterTelemetryType>
    {
        private readonly string _value;

        private ClusterTelemetryType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set.
        /// </summary>
        public static ClusterTelemetryType Unspecified { get; } = new ClusterTelemetryType("UNSPECIFIED");
        /// <summary>
        /// Monitoring integration is disabled.
        /// </summary>
        public static ClusterTelemetryType Disabled { get; } = new ClusterTelemetryType("DISABLED");
        /// <summary>
        /// Monitoring integration is enabled.
        /// </summary>
        public static ClusterTelemetryType Enabled { get; } = new ClusterTelemetryType("ENABLED");
        /// <summary>
        /// Only system components are monitored and logged.
        /// </summary>
        public static ClusterTelemetryType SystemOnly { get; } = new ClusterTelemetryType("SYSTEM_ONLY");

        public static bool operator ==(ClusterTelemetryType left, ClusterTelemetryType right) => left.Equals(right);
        public static bool operator !=(ClusterTelemetryType left, ClusterTelemetryType right) => !left.Equals(right);

        public static explicit operator string(ClusterTelemetryType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterTelemetryType other && Equals(other);
        public bool Equals(ClusterTelemetryType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired datapath provider for the cluster.
    /// </summary>
    [EnumType]
    public readonly struct ClusterUpdateDesiredDatapathProvider : IEquatable<ClusterUpdateDesiredDatapathProvider>
    {
        private readonly string _value;

        private ClusterUpdateDesiredDatapathProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static ClusterUpdateDesiredDatapathProvider DatapathProviderUnspecified { get; } = new ClusterUpdateDesiredDatapathProvider("DATAPATH_PROVIDER_UNSPECIFIED");
        /// <summary>
        /// Use the IPTables implementation based on kube-proxy.
        /// </summary>
        public static ClusterUpdateDesiredDatapathProvider LegacyDatapath { get; } = new ClusterUpdateDesiredDatapathProvider("LEGACY_DATAPATH");
        /// <summary>
        /// Use the eBPF based GKE Dataplane V2 with additional features. See the [GKE Dataplane V2 documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2) for more.
        /// </summary>
        public static ClusterUpdateDesiredDatapathProvider AdvancedDatapath { get; } = new ClusterUpdateDesiredDatapathProvider("ADVANCED_DATAPATH");

        public static bool operator ==(ClusterUpdateDesiredDatapathProvider left, ClusterUpdateDesiredDatapathProvider right) => left.Equals(right);
        public static bool operator !=(ClusterUpdateDesiredDatapathProvider left, ClusterUpdateDesiredDatapathProvider right) => !left.Equals(right);

        public static explicit operator string(ClusterUpdateDesiredDatapathProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterUpdateDesiredDatapathProvider other && Equals(other);
        public bool Equals(ClusterUpdateDesiredDatapathProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired state of IPv6 connectivity to Google Services.
    /// </summary>
    [EnumType]
    public readonly struct ClusterUpdateDesiredPrivateIpv6GoogleAccess : IEquatable<ClusterUpdateDesiredPrivateIpv6GoogleAccess>
    {
        private readonly string _value;

        private ClusterUpdateDesiredPrivateIpv6GoogleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. Same as DISABLED
        /// </summary>
        public static ClusterUpdateDesiredPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessUnspecified { get; } = new ClusterUpdateDesiredPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED");
        /// <summary>
        /// No private access to or from Google Services
        /// </summary>
        public static ClusterUpdateDesiredPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessDisabled { get; } = new ClusterUpdateDesiredPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED");
        /// <summary>
        /// Enables private IPv6 access to Google Services from GKE
        /// </summary>
        public static ClusterUpdateDesiredPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessToGoogle { get; } = new ClusterUpdateDesiredPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE");
        /// <summary>
        /// Enables priate IPv6 access to and from Google Services
        /// </summary>
        public static ClusterUpdateDesiredPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessBidirectional { get; } = new ClusterUpdateDesiredPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL");

        public static bool operator ==(ClusterUpdateDesiredPrivateIpv6GoogleAccess left, ClusterUpdateDesiredPrivateIpv6GoogleAccess right) => left.Equals(right);
        public static bool operator !=(ClusterUpdateDesiredPrivateIpv6GoogleAccess left, ClusterUpdateDesiredPrivateIpv6GoogleAccess right) => !left.Equals(right);

        public static explicit operator string(ClusterUpdateDesiredPrivateIpv6GoogleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterUpdateDesiredPrivateIpv6GoogleAccess other && Equals(other);
        public bool Equals(ClusterUpdateDesiredPrivateIpv6GoogleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// cluster_dns indicates which in-cluster DNS provider should be used.
    /// </summary>
    [EnumType]
    public readonly struct DNSConfigClusterDns : IEquatable<DNSConfigClusterDns>
    {
        private readonly string _value;

        private DNSConfigClusterDns(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value
        /// </summary>
        public static DNSConfigClusterDns ProviderUnspecified { get; } = new DNSConfigClusterDns("PROVIDER_UNSPECIFIED");
        /// <summary>
        /// Use GKE default DNS provider(kube-dns) for DNS resolution.
        /// </summary>
        public static DNSConfigClusterDns PlatformDefault { get; } = new DNSConfigClusterDns("PLATFORM_DEFAULT");
        /// <summary>
        /// Use CloudDNS for DNS resolution.
        /// </summary>
        public static DNSConfigClusterDns CloudDns { get; } = new DNSConfigClusterDns("CLOUD_DNS");

        public static bool operator ==(DNSConfigClusterDns left, DNSConfigClusterDns right) => left.Equals(right);
        public static bool operator !=(DNSConfigClusterDns left, DNSConfigClusterDns right) => !left.Equals(right);

        public static explicit operator string(DNSConfigClusterDns value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DNSConfigClusterDns other && Equals(other);
        public bool Equals(DNSConfigClusterDns other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// cluster_dns_scope indicates the scope of access to cluster DNS records.
    /// </summary>
    [EnumType]
    public readonly struct DNSConfigClusterDnsScope : IEquatable<DNSConfigClusterDnsScope>
    {
        private readonly string _value;

        private DNSConfigClusterDnsScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value, will be inferred as cluster scope.
        /// </summary>
        public static DNSConfigClusterDnsScope DnsScopeUnspecified { get; } = new DNSConfigClusterDnsScope("DNS_SCOPE_UNSPECIFIED");
        /// <summary>
        /// DNS records are accessible from within the cluster.
        /// </summary>
        public static DNSConfigClusterDnsScope ClusterScope { get; } = new DNSConfigClusterDnsScope("CLUSTER_SCOPE");
        /// <summary>
        /// DNS records are accessible from within the VPC.
        /// </summary>
        public static DNSConfigClusterDnsScope VpcScope { get; } = new DNSConfigClusterDnsScope("VPC_SCOPE");

        public static bool operator ==(DNSConfigClusterDnsScope left, DNSConfigClusterDnsScope right) => left.Equals(right);
        public static bool operator !=(DNSConfigClusterDnsScope left, DNSConfigClusterDnsScope right) => !left.Equals(right);

        public static explicit operator string(DNSConfigClusterDnsScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DNSConfigClusterDnsScope other && Equals(other);
        public bool Equals(DNSConfigClusterDnsScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Denotes the state of etcd encryption.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseEncryptionState : IEquatable<DatabaseEncryptionState>
    {
        private readonly string _value;

        private DatabaseEncryptionState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Should never be set
        /// </summary>
        public static DatabaseEncryptionState Unknown { get; } = new DatabaseEncryptionState("UNKNOWN");
        /// <summary>
        /// Secrets in etcd are encrypted.
        /// </summary>
        public static DatabaseEncryptionState Encrypted { get; } = new DatabaseEncryptionState("ENCRYPTED");
        /// <summary>
        /// Secrets in etcd are stored in plain text (at etcd level) - this is unrelated to Compute Engine level full disk encryption.
        /// </summary>
        public static DatabaseEncryptionState Decrypted { get; } = new DatabaseEncryptionState("DECRYPTED");

        public static bool operator ==(DatabaseEncryptionState left, DatabaseEncryptionState right) => left.Equals(right);
        public static bool operator !=(DatabaseEncryptionState left, DatabaseEncryptionState right) => !left.Equals(right);

        public static explicit operator string(DatabaseEncryptionState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseEncryptionState other && Equals(other);
        public bool Equals(DatabaseEncryptionState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct FilterEventTypeItem : IEquatable<FilterEventTypeItem>
    {
        private readonly string _value;

        private FilterEventTypeItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set, will be ignored.
        /// </summary>
        public static FilterEventTypeItem EventTypeUnspecified { get; } = new FilterEventTypeItem("EVENT_TYPE_UNSPECIFIED");
        /// <summary>
        /// Corresponds with UpgradeAvailableEvent.
        /// </summary>
        public static FilterEventTypeItem UpgradeAvailableEvent { get; } = new FilterEventTypeItem("UPGRADE_AVAILABLE_EVENT");
        /// <summary>
        /// Corresponds with UpgradeEvent.
        /// </summary>
        public static FilterEventTypeItem UpgradeEvent { get; } = new FilterEventTypeItem("UPGRADE_EVENT");
        /// <summary>
        /// Corresponds with SecurityBulletinEvent.
        /// </summary>
        public static FilterEventTypeItem SecurityBulletinEvent { get; } = new FilterEventTypeItem("SECURITY_BULLETIN_EVENT");

        public static bool operator ==(FilterEventTypeItem left, FilterEventTypeItem right) => left.Equals(right);
        public static bool operator !=(FilterEventTypeItem left, FilterEventTypeItem right) => !left.Equals(right);

        public static explicit operator string(FilterEventTypeItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FilterEventTypeItem other && Equals(other);
        public bool Equals(FilterEventTypeItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of GPU sharing strategy to enable on the GPU node.
    /// </summary>
    [EnumType]
    public readonly struct GPUSharingConfigGpuSharingStrategy : IEquatable<GPUSharingConfigGpuSharingStrategy>
    {
        private readonly string _value;

        private GPUSharingConfigGpuSharingStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static GPUSharingConfigGpuSharingStrategy GpuSharingStrategyUnspecified { get; } = new GPUSharingConfigGpuSharingStrategy("GPU_SHARING_STRATEGY_UNSPECIFIED");
        /// <summary>
        /// GPUs are time-shared between containers.
        /// </summary>
        public static GPUSharingConfigGpuSharingStrategy TimeSharing { get; } = new GPUSharingConfigGpuSharingStrategy("TIME_SHARING");

        public static bool operator ==(GPUSharingConfigGpuSharingStrategy left, GPUSharingConfigGpuSharingStrategy right) => left.Equals(right);
        public static bool operator !=(GPUSharingConfigGpuSharingStrategy left, GPUSharingConfigGpuSharingStrategy right) => !left.Equals(right);

        public static explicit operator string(GPUSharingConfigGpuSharingStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GPUSharingConfigGpuSharingStrategy other && Equals(other);
        public bool Equals(GPUSharingConfigGpuSharingStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The ipv6 access type (internal or external) when create_subnetwork is true
    /// </summary>
    [EnumType]
    public readonly struct IPAllocationPolicyIpv6AccessType : IEquatable<IPAllocationPolicyIpv6AccessType>
    {
        private readonly string _value;

        private IPAllocationPolicyIpv6AccessType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value, will be defaulted as type external.
        /// </summary>
        public static IPAllocationPolicyIpv6AccessType Ipv6AccessTypeUnspecified { get; } = new IPAllocationPolicyIpv6AccessType("IPV6_ACCESS_TYPE_UNSPECIFIED");
        /// <summary>
        /// Access type internal (all v6 addresses are internal IPs)
        /// </summary>
        public static IPAllocationPolicyIpv6AccessType Internal { get; } = new IPAllocationPolicyIpv6AccessType("INTERNAL");
        /// <summary>
        /// Access type external (all v6 addresses are external IPs)
        /// </summary>
        public static IPAllocationPolicyIpv6AccessType External { get; } = new IPAllocationPolicyIpv6AccessType("EXTERNAL");

        public static bool operator ==(IPAllocationPolicyIpv6AccessType left, IPAllocationPolicyIpv6AccessType right) => left.Equals(right);
        public static bool operator !=(IPAllocationPolicyIpv6AccessType left, IPAllocationPolicyIpv6AccessType right) => !left.Equals(right);

        public static explicit operator string(IPAllocationPolicyIpv6AccessType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPAllocationPolicyIpv6AccessType other && Equals(other);
        public bool Equals(IPAllocationPolicyIpv6AccessType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// IP stack type
    /// </summary>
    [EnumType]
    public readonly struct IPAllocationPolicyStackType : IEquatable<IPAllocationPolicyStackType>
    {
        private readonly string _value;

        private IPAllocationPolicyStackType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// By default, the clusters will be IPV4 only
        /// </summary>
        public static IPAllocationPolicyStackType StackTypeUnspecified { get; } = new IPAllocationPolicyStackType("STACK_TYPE_UNSPECIFIED");
        /// <summary>
        /// The value used if the cluster is a IPV4 only
        /// </summary>
        public static IPAllocationPolicyStackType Ipv4 { get; } = new IPAllocationPolicyStackType("IPV4");
        /// <summary>
        /// The value used if the cluster is a dual stack cluster
        /// </summary>
        public static IPAllocationPolicyStackType Ipv4Ipv6 { get; } = new IPAllocationPolicyStackType("IPV4_IPV6");

        public static bool operator ==(IPAllocationPolicyStackType left, IPAllocationPolicyStackType right) => left.Equals(right);
        public static bool operator !=(IPAllocationPolicyStackType left, IPAllocationPolicyStackType right) => !left.Equals(right);

        public static explicit operator string(IPAllocationPolicyStackType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPAllocationPolicyStackType other && Equals(other);
        public bool Equals(IPAllocationPolicyStackType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The specified Istio auth mode, either none, or mutual TLS.
    /// </summary>
    [EnumType]
    public readonly struct IstioConfigAuth : IEquatable<IstioConfigAuth>
    {
        private readonly string _value;

        private IstioConfigAuth(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// auth not enabled
        /// </summary>
        public static IstioConfigAuth AuthNone { get; } = new IstioConfigAuth("AUTH_NONE");
        /// <summary>
        /// auth mutual TLS enabled
        /// </summary>
        public static IstioConfigAuth AuthMutualTls { get; } = new IstioConfigAuth("AUTH_MUTUAL_TLS");

        public static bool operator ==(IstioConfigAuth left, IstioConfigAuth right) => left.Equals(right);
        public static bool operator !=(IstioConfigAuth left, IstioConfigAuth right) => !left.Equals(right);

        public static explicit operator string(IstioConfigAuth value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IstioConfigAuth other && Equals(other);
        public bool Equals(IstioConfigAuth other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct LoggingComponentConfigEnableComponentsItem : IEquatable<LoggingComponentConfigEnableComponentsItem>
    {
        private readonly string _value;

        private LoggingComponentConfigEnableComponentsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This shouldn't be used.
        /// </summary>
        public static LoggingComponentConfigEnableComponentsItem ComponentUnspecified { get; } = new LoggingComponentConfigEnableComponentsItem("COMPONENT_UNSPECIFIED");
        /// <summary>
        /// system components
        /// </summary>
        public static LoggingComponentConfigEnableComponentsItem SystemComponents { get; } = new LoggingComponentConfigEnableComponentsItem("SYSTEM_COMPONENTS");
        /// <summary>
        /// workloads
        /// </summary>
        public static LoggingComponentConfigEnableComponentsItem Workloads { get; } = new LoggingComponentConfigEnableComponentsItem("WORKLOADS");

        public static bool operator ==(LoggingComponentConfigEnableComponentsItem left, LoggingComponentConfigEnableComponentsItem right) => left.Equals(right);
        public static bool operator !=(LoggingComponentConfigEnableComponentsItem left, LoggingComponentConfigEnableComponentsItem right) => !left.Equals(right);

        public static explicit operator string(LoggingComponentConfigEnableComponentsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingComponentConfigEnableComponentsItem other && Equals(other);
        public bool Equals(LoggingComponentConfigEnableComponentsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Scope specifies the upgrade scope which upgrades are blocked by the exclusion.
    /// </summary>
    [EnumType]
    public readonly struct MaintenanceExclusionOptionsScope : IEquatable<MaintenanceExclusionOptionsScope>
    {
        private readonly string _value;

        private MaintenanceExclusionOptionsScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// NO_UPGRADES excludes all upgrades, including patch upgrades and minor upgrades across control planes and nodes. This is the default exclusion behavior.
        /// </summary>
        public static MaintenanceExclusionOptionsScope NoUpgrades { get; } = new MaintenanceExclusionOptionsScope("NO_UPGRADES");
        /// <summary>
        /// NO_MINOR_UPGRADES excludes all minor upgrades for the cluster, only patches are allowed.
        /// </summary>
        public static MaintenanceExclusionOptionsScope NoMinorUpgrades { get; } = new MaintenanceExclusionOptionsScope("NO_MINOR_UPGRADES");
        /// <summary>
        /// NO_MINOR_OR_NODE_UPGRADES excludes all minor upgrades for the cluster, and also exclude all node pool upgrades. Only control plane patches are allowed.
        /// </summary>
        public static MaintenanceExclusionOptionsScope NoMinorOrNodeUpgrades { get; } = new MaintenanceExclusionOptionsScope("NO_MINOR_OR_NODE_UPGRADES");

        public static bool operator ==(MaintenanceExclusionOptionsScope left, MaintenanceExclusionOptionsScope right) => left.Equals(right);
        public static bool operator !=(MaintenanceExclusionOptionsScope left, MaintenanceExclusionOptionsScope right) => !left.Equals(right);

        public static explicit operator string(MaintenanceExclusionOptionsScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MaintenanceExclusionOptionsScope other && Equals(other);
        public bool Equals(MaintenanceExclusionOptionsScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct MonitoringComponentConfigEnableComponentsItem : IEquatable<MonitoringComponentConfigEnableComponentsItem>
    {
        private readonly string _value;

        private MonitoringComponentConfigEnableComponentsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This shouldn't be used.
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem ComponentUnspecified { get; } = new MonitoringComponentConfigEnableComponentsItem("COMPONENT_UNSPECIFIED");
        /// <summary>
        /// system components
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem SystemComponents { get; } = new MonitoringComponentConfigEnableComponentsItem("SYSTEM_COMPONENTS");
        /// <summary>
        /// Deprecated: Use Google Cloud Managed Service for Prometheus.
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem Workloads { get; } = new MonitoringComponentConfigEnableComponentsItem("WORKLOADS");

        public static bool operator ==(MonitoringComponentConfigEnableComponentsItem left, MonitoringComponentConfigEnableComponentsItem right) => left.Equals(right);
        public static bool operator !=(MonitoringComponentConfigEnableComponentsItem left, MonitoringComponentConfigEnableComponentsItem right) => !left.Equals(right);

        public static explicit operator string(MonitoringComponentConfigEnableComponentsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MonitoringComponentConfigEnableComponentsItem other && Equals(other);
        public bool Equals(MonitoringComponentConfigEnableComponentsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired datapath provider for this cluster. By default, uses the IPTables-based kube-proxy implementation.
    /// </summary>
    [EnumType]
    public readonly struct NetworkConfigDatapathProvider : IEquatable<NetworkConfigDatapathProvider>
    {
        private readonly string _value;

        private NetworkConfigDatapathProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static NetworkConfigDatapathProvider DatapathProviderUnspecified { get; } = new NetworkConfigDatapathProvider("DATAPATH_PROVIDER_UNSPECIFIED");
        /// <summary>
        /// Use the IPTables implementation based on kube-proxy.
        /// </summary>
        public static NetworkConfigDatapathProvider LegacyDatapath { get; } = new NetworkConfigDatapathProvider("LEGACY_DATAPATH");
        /// <summary>
        /// Use the eBPF based GKE Dataplane V2 with additional features. See the [GKE Dataplane V2 documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2) for more.
        /// </summary>
        public static NetworkConfigDatapathProvider AdvancedDatapath { get; } = new NetworkConfigDatapathProvider("ADVANCED_DATAPATH");

        public static bool operator ==(NetworkConfigDatapathProvider left, NetworkConfigDatapathProvider right) => left.Equals(right);
        public static bool operator !=(NetworkConfigDatapathProvider left, NetworkConfigDatapathProvider right) => !left.Equals(right);

        public static explicit operator string(NetworkConfigDatapathProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkConfigDatapathProvider other && Equals(other);
        public bool Equals(NetworkConfigDatapathProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4)
    /// </summary>
    [EnumType]
    public readonly struct NetworkConfigPrivateIpv6GoogleAccess : IEquatable<NetworkConfigPrivateIpv6GoogleAccess>
    {
        private readonly string _value;

        private NetworkConfigPrivateIpv6GoogleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. Same as DISABLED
        /// </summary>
        public static NetworkConfigPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessUnspecified { get; } = new NetworkConfigPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED");
        /// <summary>
        /// No private access to or from Google Services
        /// </summary>
        public static NetworkConfigPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessDisabled { get; } = new NetworkConfigPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED");
        /// <summary>
        /// Enables private IPv6 access to Google Services from GKE
        /// </summary>
        public static NetworkConfigPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessToGoogle { get; } = new NetworkConfigPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE");
        /// <summary>
        /// Enables priate IPv6 access to and from Google Services
        /// </summary>
        public static NetworkConfigPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessBidirectional { get; } = new NetworkConfigPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL");

        public static bool operator ==(NetworkConfigPrivateIpv6GoogleAccess left, NetworkConfigPrivateIpv6GoogleAccess right) => left.Equals(right);
        public static bool operator !=(NetworkConfigPrivateIpv6GoogleAccess left, NetworkConfigPrivateIpv6GoogleAccess right) => !left.Equals(right);

        public static explicit operator string(NetworkConfigPrivateIpv6GoogleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkConfigPrivateIpv6GoogleAccess other && Equals(other);
        public bool Equals(NetworkConfigPrivateIpv6GoogleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the network bandwidth tier for the NodePool for traffic to external/public IP addresses.
    /// </summary>
    [EnumType]
    public readonly struct NetworkPerformanceConfigExternalIpEgressBandwidthTier : IEquatable<NetworkPerformanceConfigExternalIpEgressBandwidthTier>
    {
        private readonly string _value;

        private NetworkPerformanceConfigExternalIpEgressBandwidthTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value
        /// </summary>
        public static NetworkPerformanceConfigExternalIpEgressBandwidthTier TierUnspecified { get; } = new NetworkPerformanceConfigExternalIpEgressBandwidthTier("TIER_UNSPECIFIED");
        /// <summary>
        /// Higher bandwidth, actual values based on VM size.
        /// </summary>
        public static NetworkPerformanceConfigExternalIpEgressBandwidthTier Tier1 { get; } = new NetworkPerformanceConfigExternalIpEgressBandwidthTier("TIER_1");

        public static bool operator ==(NetworkPerformanceConfigExternalIpEgressBandwidthTier left, NetworkPerformanceConfigExternalIpEgressBandwidthTier right) => left.Equals(right);
        public static bool operator !=(NetworkPerformanceConfigExternalIpEgressBandwidthTier left, NetworkPerformanceConfigExternalIpEgressBandwidthTier right) => !left.Equals(right);

        public static explicit operator string(NetworkPerformanceConfigExternalIpEgressBandwidthTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkPerformanceConfigExternalIpEgressBandwidthTier other && Equals(other);
        public bool Equals(NetworkPerformanceConfigExternalIpEgressBandwidthTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the total network bandwidth tier for the NodePool.
    /// </summary>
    [EnumType]
    public readonly struct NetworkPerformanceConfigTotalEgressBandwidthTier : IEquatable<NetworkPerformanceConfigTotalEgressBandwidthTier>
    {
        private readonly string _value;

        private NetworkPerformanceConfigTotalEgressBandwidthTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value
        /// </summary>
        public static NetworkPerformanceConfigTotalEgressBandwidthTier TierUnspecified { get; } = new NetworkPerformanceConfigTotalEgressBandwidthTier("TIER_UNSPECIFIED");
        /// <summary>
        /// Higher bandwidth, actual values based on VM size.
        /// </summary>
        public static NetworkPerformanceConfigTotalEgressBandwidthTier Tier1 { get; } = new NetworkPerformanceConfigTotalEgressBandwidthTier("TIER_1");

        public static bool operator ==(NetworkPerformanceConfigTotalEgressBandwidthTier left, NetworkPerformanceConfigTotalEgressBandwidthTier right) => left.Equals(right);
        public static bool operator !=(NetworkPerformanceConfigTotalEgressBandwidthTier left, NetworkPerformanceConfigTotalEgressBandwidthTier right) => !left.Equals(right);

        public static explicit operator string(NetworkPerformanceConfigTotalEgressBandwidthTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkPerformanceConfigTotalEgressBandwidthTier other && Equals(other);
        public bool Equals(NetworkPerformanceConfigTotalEgressBandwidthTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The selected network policy provider.
    /// </summary>
    [EnumType]
    public readonly struct NetworkPolicyProvider : IEquatable<NetworkPolicyProvider>
    {
        private readonly string _value;

        private NetworkPolicyProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set
        /// </summary>
        public static NetworkPolicyProvider ProviderUnspecified { get; } = new NetworkPolicyProvider("PROVIDER_UNSPECIFIED");
        /// <summary>
        /// Tigera (Calico Felix).
        /// </summary>
        public static NetworkPolicyProvider Calico { get; } = new NetworkPolicyProvider("CALICO");

        public static bool operator ==(NetworkPolicyProvider left, NetworkPolicyProvider right) => left.Equals(right);
        public static bool operator !=(NetworkPolicyProvider left, NetworkPolicyProvider right) => !left.Equals(right);

        public static explicit operator string(NetworkPolicyProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkPolicyProvider other && Equals(other);
        public bool Equals(NetworkPolicyProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Effect for taint.
    /// </summary>
    [EnumType]
    public readonly struct NodeTaintEffect : IEquatable<NodeTaintEffect>
    {
        private readonly string _value;

        private NodeTaintEffect(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set
        /// </summary>
        public static NodeTaintEffect EffectUnspecified { get; } = new NodeTaintEffect("EFFECT_UNSPECIFIED");
        /// <summary>
        /// NoSchedule
        /// </summary>
        public static NodeTaintEffect NoSchedule { get; } = new NodeTaintEffect("NO_SCHEDULE");
        /// <summary>
        /// PreferNoSchedule
        /// </summary>
        public static NodeTaintEffect PreferNoSchedule { get; } = new NodeTaintEffect("PREFER_NO_SCHEDULE");
        /// <summary>
        /// NoExecute
        /// </summary>
        public static NodeTaintEffect NoExecute { get; } = new NodeTaintEffect("NO_EXECUTE");

        public static bool operator ==(NodeTaintEffect left, NodeTaintEffect right) => left.Equals(right);
        public static bool operator !=(NodeTaintEffect left, NodeTaintEffect right) => !left.Equals(right);

        public static explicit operator string(NodeTaintEffect value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeTaintEffect other && Equals(other);
        public bool Equals(NodeTaintEffect other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of placement.
    /// </summary>
    [EnumType]
    public readonly struct PlacementPolicyType : IEquatable<PlacementPolicyType>
    {
        private readonly string _value;

        private PlacementPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// TYPE_UNSPECIFIED specifies no requirements on nodes placement.
        /// </summary>
        public static PlacementPolicyType TypeUnspecified { get; } = new PlacementPolicyType("TYPE_UNSPECIFIED");
        /// <summary>
        /// COMPACT specifies node placement in the same availability domain to ensure low communication latency.
        /// </summary>
        public static PlacementPolicyType Compact { get; } = new PlacementPolicyType("COMPACT");

        public static bool operator ==(PlacementPolicyType left, PlacementPolicyType right) => left.Equals(right);
        public static bool operator !=(PlacementPolicyType left, PlacementPolicyType right) => !left.Equals(right);

        public static explicit operator string(PlacementPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PlacementPolicyType other && Equals(other);
        public bool Equals(PlacementPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// channel specifies which release channel the cluster is subscribed to.
    /// </summary>
    [EnumType]
    public readonly struct ReleaseChannelChannel : IEquatable<ReleaseChannelChannel>
    {
        private readonly string _value;

        private ReleaseChannelChannel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No channel specified.
        /// </summary>
        public static ReleaseChannelChannel Unspecified { get; } = new ReleaseChannelChannel("UNSPECIFIED");
        /// <summary>
        /// RAPID channel is offered on an early access basis for customers who want to test new releases. WARNING: Versions available in the RAPID Channel may be subject to unresolved issues with no known workaround and are not subject to any SLAs.
        /// </summary>
        public static ReleaseChannelChannel Rapid { get; } = new ReleaseChannelChannel("RAPID");
        /// <summary>
        /// Clusters subscribed to REGULAR receive versions that are considered GA quality. REGULAR is intended for production users who want to take advantage of new features.
        /// </summary>
        public static ReleaseChannelChannel Regular { get; } = new ReleaseChannelChannel("REGULAR");
        /// <summary>
        /// Clusters subscribed to STABLE receive versions that are known to be stable and reliable in production.
        /// </summary>
        public static ReleaseChannelChannel Stable { get; } = new ReleaseChannelChannel("STABLE");

        public static bool operator ==(ReleaseChannelChannel left, ReleaseChannelChannel right) => left.Equals(right);
        public static bool operator !=(ReleaseChannelChannel left, ReleaseChannelChannel right) => !left.Equals(right);

        public static explicit operator string(ReleaseChannelChannel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReleaseChannelChannel other && Equals(other);
        public bool Equals(ReleaseChannelChannel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Corresponds to the type of reservation consumption.
    /// </summary>
    [EnumType]
    public readonly struct ReservationAffinityConsumeReservationType : IEquatable<ReservationAffinityConsumeReservationType>
    {
        private readonly string _value;

        private ReservationAffinityConsumeReservationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This should not be used.
        /// </summary>
        public static ReservationAffinityConsumeReservationType Unspecified { get; } = new ReservationAffinityConsumeReservationType("UNSPECIFIED");
        /// <summary>
        /// Do not consume from any reserved capacity.
        /// </summary>
        public static ReservationAffinityConsumeReservationType NoReservation { get; } = new ReservationAffinityConsumeReservationType("NO_RESERVATION");
        /// <summary>
        /// Consume any reservation available.
        /// </summary>
        public static ReservationAffinityConsumeReservationType AnyReservation { get; } = new ReservationAffinityConsumeReservationType("ANY_RESERVATION");
        /// <summary>
        /// Must consume from a specific reservation. Must specify key value fields for specifying the reservations.
        /// </summary>
        public static ReservationAffinityConsumeReservationType SpecificReservation { get; } = new ReservationAffinityConsumeReservationType("SPECIFIC_RESERVATION");

        public static bool operator ==(ReservationAffinityConsumeReservationType left, ReservationAffinityConsumeReservationType right) => left.Equals(right);
        public static bool operator !=(ReservationAffinityConsumeReservationType left, ReservationAffinityConsumeReservationType right) => !left.Equals(right);

        public static explicit operator string(ReservationAffinityConsumeReservationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReservationAffinityConsumeReservationType other && Equals(other);
        public bool Equals(ReservationAffinityConsumeReservationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the sandbox to use for the node.
    /// </summary>
    [EnumType]
    public readonly struct SandboxConfigType : IEquatable<SandboxConfigType>
    {
        private readonly string _value;

        private SandboxConfigType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This should not be used.
        /// </summary>
        public static SandboxConfigType Unspecified { get; } = new SandboxConfigType("UNSPECIFIED");
        /// <summary>
        /// Run sandbox using gvisor.
        /// </summary>
        public static SandboxConfigType Gvisor { get; } = new SandboxConfigType("GVISOR");

        public static bool operator ==(SandboxConfigType left, SandboxConfigType right) => left.Equals(right);
        public static bool operator !=(SandboxConfigType left, SandboxConfigType right) => !left.Equals(right);

        public static explicit operator string(SandboxConfigType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SandboxConfigType other && Equals(other);
        public bool Equals(SandboxConfigType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Canonical code of the condition.
    /// </summary>
    [EnumType]
    public readonly struct StatusConditionCanonicalCode : IEquatable<StatusConditionCanonicalCode>
    {
        private readonly string _value;

        private StatusConditionCanonicalCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not an error; returned on success HTTP Mapping: 200 OK
        /// </summary>
        public static StatusConditionCanonicalCode Ok { get; } = new StatusConditionCanonicalCode("OK");
        /// <summary>
        /// The operation was cancelled, typically by the caller. HTTP Mapping: 499 Client Closed Request
        /// </summary>
        public static StatusConditionCanonicalCode Cancelled { get; } = new StatusConditionCanonicalCode("CANCELLED");
        /// <summary>
        /// Unknown error. For example, this error may be returned when a `Status` value received from another address space belongs to an error space that is not known in this address space. Also errors raised by APIs that do not return enough error information may be converted to this error. HTTP Mapping: 500 Internal Server Error
        /// </summary>
        public static StatusConditionCanonicalCode Unknown { get; } = new StatusConditionCanonicalCode("UNKNOWN");
        /// <summary>
        /// The client specified an invalid argument. Note that this differs from `FAILED_PRECONDITION`. `INVALID_ARGUMENT` indicates arguments that are problematic regardless of the state of the system (e.g., a malformed file name). HTTP Mapping: 400 Bad Request
        /// </summary>
        public static StatusConditionCanonicalCode InvalidArgument { get; } = new StatusConditionCanonicalCode("INVALID_ARGUMENT");
        /// <summary>
        /// The deadline expired before the operation could complete. For operations that change the state of the system, this error may be returned even if the operation has completed successfully. For example, a successful response from a server could have been delayed long enough for the deadline to expire. HTTP Mapping: 504 Gateway Timeout
        /// </summary>
        public static StatusConditionCanonicalCode DeadlineExceeded { get; } = new StatusConditionCanonicalCode("DEADLINE_EXCEEDED");
        /// <summary>
        /// Some requested entity (e.g., file or directory) was not found. Note to server developers: if a request is denied for an entire class of users, such as gradual feature rollout or undocumented allowlist, `NOT_FOUND` may be used. If a request is denied for some users within a class of users, such as user-based access control, `PERMISSION_DENIED` must be used. HTTP Mapping: 404 Not Found
        /// </summary>
        public static StatusConditionCanonicalCode NotFound { get; } = new StatusConditionCanonicalCode("NOT_FOUND");
        /// <summary>
        /// The entity that a client attempted to create (e.g., file or directory) already exists. HTTP Mapping: 409 Conflict
        /// </summary>
        public static StatusConditionCanonicalCode AlreadyExists { get; } = new StatusConditionCanonicalCode("ALREADY_EXISTS");
        /// <summary>
        /// The caller does not have permission to execute the specified operation. `PERMISSION_DENIED` must not be used for rejections caused by exhausting some resource (use `RESOURCE_EXHAUSTED` instead for those errors). `PERMISSION_DENIED` must not be used if the caller can not be identified (use `UNAUTHENTICATED` instead for those errors). This error code does not imply the request is valid or the requested entity exists or satisfies other pre-conditions. HTTP Mapping: 403 Forbidden
        /// </summary>
        public static StatusConditionCanonicalCode PermissionDenied { get; } = new StatusConditionCanonicalCode("PERMISSION_DENIED");
        /// <summary>
        /// The request does not have valid authentication credentials for the operation. HTTP Mapping: 401 Unauthorized
        /// </summary>
        public static StatusConditionCanonicalCode Unauthenticated { get; } = new StatusConditionCanonicalCode("UNAUTHENTICATED");
        /// <summary>
        /// Some resource has been exhausted, perhaps a per-user quota, or perhaps the entire file system is out of space. HTTP Mapping: 429 Too Many Requests
        /// </summary>
        public static StatusConditionCanonicalCode ResourceExhausted { get; } = new StatusConditionCanonicalCode("RESOURCE_EXHAUSTED");
        /// <summary>
        /// The operation was rejected because the system is not in a state required for the operation's execution. For example, the directory to be deleted is non-empty, an rmdir operation is applied to a non-directory, etc. Service implementors can use the following guidelines to decide between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`: (a) Use `UNAVAILABLE` if the client can retry just the failing call. (b) Use `ABORTED` if the client should retry at a higher level. For example, when a client-specified test-and-set fails, indicating the client should restart a read-modify-write sequence. (c) Use `FAILED_PRECONDITION` if the client should not retry until the system state has been explicitly fixed. For example, if an "rmdir" fails because the directory is non-empty, `FAILED_PRECONDITION` should be returned since the client should not retry unless the files are deleted from the directory. HTTP Mapping: 400 Bad Request
        /// </summary>
        public static StatusConditionCanonicalCode FailedPrecondition { get; } = new StatusConditionCanonicalCode("FAILED_PRECONDITION");
        /// <summary>
        /// The operation was aborted, typically due to a concurrency issue such as a sequencer check failure or transaction abort. See the guidelines above for deciding between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`. HTTP Mapping: 409 Conflict
        /// </summary>
        public static StatusConditionCanonicalCode Aborted { get; } = new StatusConditionCanonicalCode("ABORTED");
        /// <summary>
        /// The operation was attempted past the valid range. E.g., seeking or reading past end-of-file. Unlike `INVALID_ARGUMENT`, this error indicates a problem that may be fixed if the system state changes. For example, a 32-bit file system will generate `INVALID_ARGUMENT` if asked to read at an offset that is not in the range [0,2^32-1], but it will generate `OUT_OF_RANGE` if asked to read from an offset past the current file size. There is a fair bit of overlap between `FAILED_PRECONDITION` and `OUT_OF_RANGE`. We recommend using `OUT_OF_RANGE` (the more specific error) when it applies so that callers who are iterating through a space can easily look for an `OUT_OF_RANGE` error to detect when they are done. HTTP Mapping: 400 Bad Request
        /// </summary>
        public static StatusConditionCanonicalCode OutOfRange { get; } = new StatusConditionCanonicalCode("OUT_OF_RANGE");
        /// <summary>
        /// The operation is not implemented or is not supported/enabled in this service. HTTP Mapping: 501 Not Implemented
        /// </summary>
        public static StatusConditionCanonicalCode Unimplemented { get; } = new StatusConditionCanonicalCode("UNIMPLEMENTED");
        /// <summary>
        /// Internal errors. This means that some invariants expected by the underlying system have been broken. This error code is reserved for serious errors. HTTP Mapping: 500 Internal Server Error
        /// </summary>
        public static StatusConditionCanonicalCode Internal { get; } = new StatusConditionCanonicalCode("INTERNAL");
        /// <summary>
        /// The service is currently unavailable. This is most likely a transient condition, which can be corrected by retrying with a backoff. Note that it is not always safe to retry non-idempotent operations. See the guidelines above for deciding between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`. HTTP Mapping: 503 Service Unavailable
        /// </summary>
        public static StatusConditionCanonicalCode Unavailable { get; } = new StatusConditionCanonicalCode("UNAVAILABLE");
        /// <summary>
        /// Unrecoverable data loss or corruption. HTTP Mapping: 500 Internal Server Error
        /// </summary>
        public static StatusConditionCanonicalCode DataLoss { get; } = new StatusConditionCanonicalCode("DATA_LOSS");

        public static bool operator ==(StatusConditionCanonicalCode left, StatusConditionCanonicalCode right) => left.Equals(right);
        public static bool operator !=(StatusConditionCanonicalCode left, StatusConditionCanonicalCode right) => !left.Equals(right);

        public static explicit operator string(StatusConditionCanonicalCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatusConditionCanonicalCode other && Equals(other);
        public bool Equals(StatusConditionCanonicalCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Machine-friendly representation of the condition Deprecated. Use canonical_code instead.
    /// </summary>
    [EnumType]
    public readonly struct StatusConditionCode : IEquatable<StatusConditionCode>
    {
        private readonly string _value;

        private StatusConditionCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// UNKNOWN indicates a generic condition.
        /// </summary>
        public static StatusConditionCode Unknown { get; } = new StatusConditionCode("UNKNOWN");
        /// <summary>
        /// GCE_STOCKOUT indicates that Google Compute Engine resources are temporarily unavailable.
        /// </summary>
        public static StatusConditionCode GceStockout { get; } = new StatusConditionCode("GCE_STOCKOUT");
        /// <summary>
        /// GKE_SERVICE_ACCOUNT_DELETED indicates that the user deleted their robot service account.
        /// </summary>
        public static StatusConditionCode GkeServiceAccountDeleted { get; } = new StatusConditionCode("GKE_SERVICE_ACCOUNT_DELETED");
        /// <summary>
        /// Google Compute Engine quota was exceeded.
        /// </summary>
        public static StatusConditionCode GceQuotaExceeded { get; } = new StatusConditionCode("GCE_QUOTA_EXCEEDED");
        /// <summary>
        /// Cluster state was manually changed by an SRE due to a system logic error.
        /// </summary>
        public static StatusConditionCode SetByOperator { get; } = new StatusConditionCode("SET_BY_OPERATOR");
        /// <summary>
        /// Unable to perform an encrypt operation against the CloudKMS key used for etcd level encryption.
        /// </summary>
        public static StatusConditionCode CloudKmsKeyError { get; } = new StatusConditionCode("CLOUD_KMS_KEY_ERROR");
        /// <summary>
        /// Cluster CA is expiring soon. More codes TBA
        /// </summary>
        public static StatusConditionCode CaExpiring { get; } = new StatusConditionCode("CA_EXPIRING");

        public static bool operator ==(StatusConditionCode left, StatusConditionCode right) => left.Equals(right);
        public static bool operator !=(StatusConditionCode left, StatusConditionCode right) => !left.Equals(right);

        public static explicit operator string(StatusConditionCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatusConditionCode other && Equals(other);
        public bool Equals(StatusConditionCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sets which mode of auditing should be used for the cluster's workloads.
    /// </summary>
    [EnumType]
    public readonly struct WorkloadConfigAuditMode : IEquatable<WorkloadConfigAuditMode>
    {
        private readonly string _value;

        private WorkloadConfigAuditMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value meaning that no mode has been specified.
        /// </summary>
        public static WorkloadConfigAuditMode ModeUnspecified { get; } = new WorkloadConfigAuditMode("MODE_UNSPECIFIED");
        /// <summary>
        /// This disables Workload Configuration auditing on the cluster, meaning that nothing is surfaced.
        /// </summary>
        public static WorkloadConfigAuditMode Disabled { get; } = new WorkloadConfigAuditMode("DISABLED");
        /// <summary>
        /// Applies the default set of policy auditing to a cluster's workloads.
        /// </summary>
        public static WorkloadConfigAuditMode Basic { get; } = new WorkloadConfigAuditMode("BASIC");
        /// <summary>
        /// Surfaces configurations that are not in line with the Pod Security Standard Baseline policy.
        /// </summary>
        public static WorkloadConfigAuditMode Baseline { get; } = new WorkloadConfigAuditMode("BASELINE");
        /// <summary>
        /// Surfaces configurations that are not in line with the Pod Security Standard Restricted policy.
        /// </summary>
        public static WorkloadConfigAuditMode Restricted { get; } = new WorkloadConfigAuditMode("RESTRICTED");

        public static bool operator ==(WorkloadConfigAuditMode left, WorkloadConfigAuditMode right) => left.Equals(right);
        public static bool operator !=(WorkloadConfigAuditMode left, WorkloadConfigAuditMode right) => !left.Equals(right);

        public static explicit operator string(WorkloadConfigAuditMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WorkloadConfigAuditMode other && Equals(other);
        public bool Equals(WorkloadConfigAuditMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Mode is the configuration for how to expose metadata to workloads running on the node pool.
    /// </summary>
    [EnumType]
    public readonly struct WorkloadMetadataConfigMode : IEquatable<WorkloadMetadataConfigMode>
    {
        private readonly string _value;

        private WorkloadMetadataConfigMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set.
        /// </summary>
        public static WorkloadMetadataConfigMode ModeUnspecified { get; } = new WorkloadMetadataConfigMode("MODE_UNSPECIFIED");
        /// <summary>
        /// Expose all Compute Engine metadata to pods.
        /// </summary>
        public static WorkloadMetadataConfigMode GceMetadata { get; } = new WorkloadMetadataConfigMode("GCE_METADATA");
        /// <summary>
        /// Run the GKE Metadata Server on this node. The GKE Metadata Server exposes a metadata API to workloads that is compatible with the V1 Compute Metadata APIs exposed by the Compute Engine and App Engine Metadata Servers. This feature can only be enabled if Workload Identity is enabled at the cluster level.
        /// </summary>
        public static WorkloadMetadataConfigMode GkeMetadata { get; } = new WorkloadMetadataConfigMode("GKE_METADATA");

        public static bool operator ==(WorkloadMetadataConfigMode left, WorkloadMetadataConfigMode right) => left.Equals(right);
        public static bool operator !=(WorkloadMetadataConfigMode left, WorkloadMetadataConfigMode right) => !left.Equals(right);

        public static explicit operator string(WorkloadMetadataConfigMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WorkloadMetadataConfigMode other && Equals(other);
        public bool Equals(WorkloadMetadataConfigMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// NodeMetadata is the configuration for how to expose metadata to the workloads running on the node.
    /// </summary>
    [EnumType]
    public readonly struct WorkloadMetadataConfigNodeMetadata : IEquatable<WorkloadMetadataConfigNodeMetadata>
    {
        private readonly string _value;

        private WorkloadMetadataConfigNodeMetadata(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set.
        /// </summary>
        public static WorkloadMetadataConfigNodeMetadata Unspecified { get; } = new WorkloadMetadataConfigNodeMetadata("UNSPECIFIED");
        /// <summary>
        /// Prevent workloads not in hostNetwork from accessing certain VM metadata, specifically kube-env, which contains Kubelet credentials, and the instance identity token. Metadata concealment is a temporary security solution available while the bootstrapping process for cluster nodes is being redesigned with significant security improvements. This feature is scheduled to be deprecated in the future and later removed.
        /// </summary>
        public static WorkloadMetadataConfigNodeMetadata Secure { get; } = new WorkloadMetadataConfigNodeMetadata("SECURE");
        /// <summary>
        /// Expose all VM metadata to pods.
        /// </summary>
        public static WorkloadMetadataConfigNodeMetadata Expose { get; } = new WorkloadMetadataConfigNodeMetadata("EXPOSE");
        /// <summary>
        /// Run the GKE Metadata Server on this node. The GKE Metadata Server exposes a metadata API to workloads that is compatible with the V1 Compute Metadata APIs exposed by the Compute Engine and App Engine Metadata Servers. This feature can only be enabled if Workload Identity is enabled at the cluster level.
        /// </summary>
        public static WorkloadMetadataConfigNodeMetadata GkeMetadataServer { get; } = new WorkloadMetadataConfigNodeMetadata("GKE_METADATA_SERVER");

        public static bool operator ==(WorkloadMetadataConfigNodeMetadata left, WorkloadMetadataConfigNodeMetadata right) => left.Equals(right);
        public static bool operator !=(WorkloadMetadataConfigNodeMetadata left, WorkloadMetadataConfigNodeMetadata right) => !left.Equals(right);

        public static explicit operator string(WorkloadMetadataConfigNodeMetadata value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WorkloadMetadataConfigNodeMetadata other && Equals(other);
        public bool Equals(WorkloadMetadataConfigNodeMetadata other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

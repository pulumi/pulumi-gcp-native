// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Container.V1
{
    /// <summary>
    /// Method used to make Relay available
    /// </summary>
    [EnumType]
    public readonly struct AdvancedDatapathObservabilityConfigRelayMode : IEquatable<AdvancedDatapathObservabilityConfigRelayMode>
    {
        private readonly string _value;

        private AdvancedDatapathObservabilityConfigRelayMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This shouldn't be used.
        /// </summary>
        public static AdvancedDatapathObservabilityConfigRelayMode RelayModeUnspecified { get; } = new AdvancedDatapathObservabilityConfigRelayMode("RELAY_MODE_UNSPECIFIED");
        /// <summary>
        /// disabled
        /// </summary>
        public static AdvancedDatapathObservabilityConfigRelayMode Disabled { get; } = new AdvancedDatapathObservabilityConfigRelayMode("DISABLED");
        /// <summary>
        /// exposed via internal load balancer
        /// </summary>
        public static AdvancedDatapathObservabilityConfigRelayMode InternalVpcLb { get; } = new AdvancedDatapathObservabilityConfigRelayMode("INTERNAL_VPC_LB");
        /// <summary>
        /// exposed via external load balancer
        /// </summary>
        public static AdvancedDatapathObservabilityConfigRelayMode ExternalLb { get; } = new AdvancedDatapathObservabilityConfigRelayMode("EXTERNAL_LB");

        public static bool operator ==(AdvancedDatapathObservabilityConfigRelayMode left, AdvancedDatapathObservabilityConfigRelayMode right) => left.Equals(right);
        public static bool operator !=(AdvancedDatapathObservabilityConfigRelayMode left, AdvancedDatapathObservabilityConfigRelayMode right) => !left.Equals(right);

        public static explicit operator string(AdvancedDatapathObservabilityConfigRelayMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AdvancedDatapathObservabilityConfigRelayMode other && Equals(other);
        public bool Equals(AdvancedDatapathObservabilityConfigRelayMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Mode of operation for binauthz policy evaluation. If unspecified, defaults to DISABLED.
    /// </summary>
    [EnumType]
    public readonly struct BinaryAuthorizationEvaluationMode : IEquatable<BinaryAuthorizationEvaluationMode>
    {
        private readonly string _value;

        private BinaryAuthorizationEvaluationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value
        /// </summary>
        public static BinaryAuthorizationEvaluationMode EvaluationModeUnspecified { get; } = new BinaryAuthorizationEvaluationMode("EVALUATION_MODE_UNSPECIFIED");
        /// <summary>
        /// Disable BinaryAuthorization
        /// </summary>
        public static BinaryAuthorizationEvaluationMode Disabled { get; } = new BinaryAuthorizationEvaluationMode("DISABLED");
        /// <summary>
        /// Enforce Kubernetes admission requests with BinaryAuthorization using the project's singleton policy. This is equivalent to setting the enabled boolean to true.
        /// </summary>
        public static BinaryAuthorizationEvaluationMode ProjectSingletonPolicyEnforce { get; } = new BinaryAuthorizationEvaluationMode("PROJECT_SINGLETON_POLICY_ENFORCE");

        public static bool operator ==(BinaryAuthorizationEvaluationMode left, BinaryAuthorizationEvaluationMode right) => left.Equals(right);
        public static bool operator !=(BinaryAuthorizationEvaluationMode left, BinaryAuthorizationEvaluationMode right) => !left.Equals(right);

        public static explicit operator string(BinaryAuthorizationEvaluationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BinaryAuthorizationEvaluationMode other && Equals(other);
        public bool Equals(BinaryAuthorizationEvaluationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Which load balancer type is installed for Cloud Run.
    /// </summary>
    [EnumType]
    public readonly struct CloudRunConfigLoadBalancerType : IEquatable<CloudRunConfigLoadBalancerType>
    {
        private readonly string _value;

        private CloudRunConfigLoadBalancerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Load balancer type for Cloud Run is unspecified.
        /// </summary>
        public static CloudRunConfigLoadBalancerType LoadBalancerTypeUnspecified { get; } = new CloudRunConfigLoadBalancerType("LOAD_BALANCER_TYPE_UNSPECIFIED");
        /// <summary>
        /// Install external load balancer for Cloud Run.
        /// </summary>
        public static CloudRunConfigLoadBalancerType LoadBalancerTypeExternal { get; } = new CloudRunConfigLoadBalancerType("LOAD_BALANCER_TYPE_EXTERNAL");
        /// <summary>
        /// Install internal load balancer for Cloud Run.
        /// </summary>
        public static CloudRunConfigLoadBalancerType LoadBalancerTypeInternal { get; } = new CloudRunConfigLoadBalancerType("LOAD_BALANCER_TYPE_INTERNAL");

        public static bool operator ==(CloudRunConfigLoadBalancerType left, CloudRunConfigLoadBalancerType right) => left.Equals(right);
        public static bool operator !=(CloudRunConfigLoadBalancerType left, CloudRunConfigLoadBalancerType right) => !left.Equals(right);

        public static explicit operator string(CloudRunConfigLoadBalancerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CloudRunConfigLoadBalancerType other && Equals(other);
        public bool Equals(CloudRunConfigLoadBalancerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines autoscaling behaviour.
    /// </summary>
    [EnumType]
    public readonly struct ClusterAutoscalingAutoscalingProfile : IEquatable<ClusterAutoscalingAutoscalingProfile>
    {
        private readonly string _value;

        private ClusterAutoscalingAutoscalingProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No change to autoscaling configuration.
        /// </summary>
        public static ClusterAutoscalingAutoscalingProfile ProfileUnspecified { get; } = new ClusterAutoscalingAutoscalingProfile("PROFILE_UNSPECIFIED");
        /// <summary>
        /// Prioritize optimizing utilization of resources.
        /// </summary>
        public static ClusterAutoscalingAutoscalingProfile OptimizeUtilization { get; } = new ClusterAutoscalingAutoscalingProfile("OPTIMIZE_UTILIZATION");
        /// <summary>
        /// Use default (balanced) autoscaling configuration.
        /// </summary>
        public static ClusterAutoscalingAutoscalingProfile Balanced { get; } = new ClusterAutoscalingAutoscalingProfile("BALANCED");

        public static bool operator ==(ClusterAutoscalingAutoscalingProfile left, ClusterAutoscalingAutoscalingProfile right) => left.Equals(right);
        public static bool operator !=(ClusterAutoscalingAutoscalingProfile left, ClusterAutoscalingAutoscalingProfile right) => !left.Equals(right);

        public static explicit operator string(ClusterAutoscalingAutoscalingProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterAutoscalingAutoscalingProfile other && Equals(other);
        public bool Equals(ClusterAutoscalingAutoscalingProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the total network bandwidth tier for NodePools in the cluster.
    /// </summary>
    [EnumType]
    public readonly struct ClusterNetworkPerformanceConfigTotalEgressBandwidthTier : IEquatable<ClusterNetworkPerformanceConfigTotalEgressBandwidthTier>
    {
        private readonly string _value;

        private ClusterNetworkPerformanceConfigTotalEgressBandwidthTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value
        /// </summary>
        public static ClusterNetworkPerformanceConfigTotalEgressBandwidthTier TierUnspecified { get; } = new ClusterNetworkPerformanceConfigTotalEgressBandwidthTier("TIER_UNSPECIFIED");
        /// <summary>
        /// Higher bandwidth, actual values based on VM size.
        /// </summary>
        public static ClusterNetworkPerformanceConfigTotalEgressBandwidthTier Tier1 { get; } = new ClusterNetworkPerformanceConfigTotalEgressBandwidthTier("TIER_1");

        public static bool operator ==(ClusterNetworkPerformanceConfigTotalEgressBandwidthTier left, ClusterNetworkPerformanceConfigTotalEgressBandwidthTier right) => left.Equals(right);
        public static bool operator !=(ClusterNetworkPerformanceConfigTotalEgressBandwidthTier left, ClusterNetworkPerformanceConfigTotalEgressBandwidthTier right) => !left.Equals(right);

        public static explicit operator string(ClusterNetworkPerformanceConfigTotalEgressBandwidthTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterNetworkPerformanceConfigTotalEgressBandwidthTier other && Equals(other);
        public bool Equals(ClusterNetworkPerformanceConfigTotalEgressBandwidthTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired datapath provider for the cluster.
    /// </summary>
    [EnumType]
    public readonly struct ClusterUpdateDesiredDatapathProvider : IEquatable<ClusterUpdateDesiredDatapathProvider>
    {
        private readonly string _value;

        private ClusterUpdateDesiredDatapathProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static ClusterUpdateDesiredDatapathProvider DatapathProviderUnspecified { get; } = new ClusterUpdateDesiredDatapathProvider("DATAPATH_PROVIDER_UNSPECIFIED");
        /// <summary>
        /// Use the IPTables implementation based on kube-proxy.
        /// </summary>
        public static ClusterUpdateDesiredDatapathProvider LegacyDatapath { get; } = new ClusterUpdateDesiredDatapathProvider("LEGACY_DATAPATH");
        /// <summary>
        /// Use the eBPF based GKE Dataplane V2 with additional features. See the [GKE Dataplane V2 documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2) for more.
        /// </summary>
        public static ClusterUpdateDesiredDatapathProvider AdvancedDatapath { get; } = new ClusterUpdateDesiredDatapathProvider("ADVANCED_DATAPATH");

        public static bool operator ==(ClusterUpdateDesiredDatapathProvider left, ClusterUpdateDesiredDatapathProvider right) => left.Equals(right);
        public static bool operator !=(ClusterUpdateDesiredDatapathProvider left, ClusterUpdateDesiredDatapathProvider right) => !left.Equals(right);

        public static explicit operator string(ClusterUpdateDesiredDatapathProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterUpdateDesiredDatapathProvider other && Equals(other);
        public bool Equals(ClusterUpdateDesiredDatapathProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired state of IPv6 connectivity to Google Services.
    /// </summary>
    [EnumType]
    public readonly struct ClusterUpdateDesiredPrivateIpv6GoogleAccess : IEquatable<ClusterUpdateDesiredPrivateIpv6GoogleAccess>
    {
        private readonly string _value;

        private ClusterUpdateDesiredPrivateIpv6GoogleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. Same as DISABLED
        /// </summary>
        public static ClusterUpdateDesiredPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessUnspecified { get; } = new ClusterUpdateDesiredPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED");
        /// <summary>
        /// No private access to or from Google Services
        /// </summary>
        public static ClusterUpdateDesiredPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessDisabled { get; } = new ClusterUpdateDesiredPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED");
        /// <summary>
        /// Enables private IPv6 access to Google Services from GKE
        /// </summary>
        public static ClusterUpdateDesiredPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessToGoogle { get; } = new ClusterUpdateDesiredPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE");
        /// <summary>
        /// Enables private IPv6 access to and from Google Services
        /// </summary>
        public static ClusterUpdateDesiredPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessBidirectional { get; } = new ClusterUpdateDesiredPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL");

        public static bool operator ==(ClusterUpdateDesiredPrivateIpv6GoogleAccess left, ClusterUpdateDesiredPrivateIpv6GoogleAccess right) => left.Equals(right);
        public static bool operator !=(ClusterUpdateDesiredPrivateIpv6GoogleAccess left, ClusterUpdateDesiredPrivateIpv6GoogleAccess right) => !left.Equals(right);

        public static explicit operator string(ClusterUpdateDesiredPrivateIpv6GoogleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterUpdateDesiredPrivateIpv6GoogleAccess other && Equals(other);
        public bool Equals(ClusterUpdateDesiredPrivateIpv6GoogleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired stack type of the cluster. If a stack type is provided and does not match the current stack type of the cluster, update will attempt to change the stack type to the new type.
    /// </summary>
    [EnumType]
    public readonly struct ClusterUpdateDesiredStackType : IEquatable<ClusterUpdateDesiredStackType>
    {
        private readonly string _value;

        private ClusterUpdateDesiredStackType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value, will be defaulted as IPV4 only
        /// </summary>
        public static ClusterUpdateDesiredStackType StackTypeUnspecified { get; } = new ClusterUpdateDesiredStackType("STACK_TYPE_UNSPECIFIED");
        /// <summary>
        /// Cluster is IPV4 only
        /// </summary>
        public static ClusterUpdateDesiredStackType Ipv4 { get; } = new ClusterUpdateDesiredStackType("IPV4");
        /// <summary>
        /// Cluster can use both IPv4 and IPv6
        /// </summary>
        public static ClusterUpdateDesiredStackType Ipv4Ipv6 { get; } = new ClusterUpdateDesiredStackType("IPV4_IPV6");

        public static bool operator ==(ClusterUpdateDesiredStackType left, ClusterUpdateDesiredStackType right) => left.Equals(right);
        public static bool operator !=(ClusterUpdateDesiredStackType left, ClusterUpdateDesiredStackType right) => !left.Equals(right);

        public static explicit operator string(ClusterUpdateDesiredStackType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterUpdateDesiredStackType other && Equals(other);
        public bool Equals(ClusterUpdateDesiredStackType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// cluster_dns indicates which in-cluster DNS provider should be used.
    /// </summary>
    [EnumType]
    public readonly struct DNSConfigClusterDns : IEquatable<DNSConfigClusterDns>
    {
        private readonly string _value;

        private DNSConfigClusterDns(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value
        /// </summary>
        public static DNSConfigClusterDns ProviderUnspecified { get; } = new DNSConfigClusterDns("PROVIDER_UNSPECIFIED");
        /// <summary>
        /// Use GKE default DNS provider(kube-dns) for DNS resolution.
        /// </summary>
        public static DNSConfigClusterDns PlatformDefault { get; } = new DNSConfigClusterDns("PLATFORM_DEFAULT");
        /// <summary>
        /// Use CloudDNS for DNS resolution.
        /// </summary>
        public static DNSConfigClusterDns CloudDns { get; } = new DNSConfigClusterDns("CLOUD_DNS");
        /// <summary>
        /// Use KubeDNS for DNS resolution.
        /// </summary>
        public static DNSConfigClusterDns KubeDns { get; } = new DNSConfigClusterDns("KUBE_DNS");

        public static bool operator ==(DNSConfigClusterDns left, DNSConfigClusterDns right) => left.Equals(right);
        public static bool operator !=(DNSConfigClusterDns left, DNSConfigClusterDns right) => !left.Equals(right);

        public static explicit operator string(DNSConfigClusterDns value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DNSConfigClusterDns other && Equals(other);
        public bool Equals(DNSConfigClusterDns other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// cluster_dns_scope indicates the scope of access to cluster DNS records.
    /// </summary>
    [EnumType]
    public readonly struct DNSConfigClusterDnsScope : IEquatable<DNSConfigClusterDnsScope>
    {
        private readonly string _value;

        private DNSConfigClusterDnsScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value, will be inferred as cluster scope.
        /// </summary>
        public static DNSConfigClusterDnsScope DnsScopeUnspecified { get; } = new DNSConfigClusterDnsScope("DNS_SCOPE_UNSPECIFIED");
        /// <summary>
        /// DNS records are accessible from within the cluster.
        /// </summary>
        public static DNSConfigClusterDnsScope ClusterScope { get; } = new DNSConfigClusterDnsScope("CLUSTER_SCOPE");
        /// <summary>
        /// DNS records are accessible from within the VPC.
        /// </summary>
        public static DNSConfigClusterDnsScope VpcScope { get; } = new DNSConfigClusterDnsScope("VPC_SCOPE");

        public static bool operator ==(DNSConfigClusterDnsScope left, DNSConfigClusterDnsScope right) => left.Equals(right);
        public static bool operator !=(DNSConfigClusterDnsScope left, DNSConfigClusterDnsScope right) => !left.Equals(right);

        public static explicit operator string(DNSConfigClusterDnsScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DNSConfigClusterDnsScope other && Equals(other);
        public bool Equals(DNSConfigClusterDnsScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired state of etcd encryption.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseEncryptionState : IEquatable<DatabaseEncryptionState>
    {
        private readonly string _value;

        private DatabaseEncryptionState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Should never be set
        /// </summary>
        public static DatabaseEncryptionState Unknown { get; } = new DatabaseEncryptionState("UNKNOWN");
        /// <summary>
        /// Secrets in etcd are encrypted.
        /// </summary>
        public static DatabaseEncryptionState Encrypted { get; } = new DatabaseEncryptionState("ENCRYPTED");
        /// <summary>
        /// Secrets in etcd are stored in plain text (at etcd level) - this is unrelated to Compute Engine level full disk encryption.
        /// </summary>
        public static DatabaseEncryptionState Decrypted { get; } = new DatabaseEncryptionState("DECRYPTED");

        public static bool operator ==(DatabaseEncryptionState left, DatabaseEncryptionState right) => left.Equals(right);
        public static bool operator !=(DatabaseEncryptionState left, DatabaseEncryptionState right) => !left.Equals(right);

        public static explicit operator string(DatabaseEncryptionState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseEncryptionState other && Equals(other);
        public bool Equals(DatabaseEncryptionState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct FilterEventTypeItem : IEquatable<FilterEventTypeItem>
    {
        private readonly string _value;

        private FilterEventTypeItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set, will be ignored.
        /// </summary>
        public static FilterEventTypeItem EventTypeUnspecified { get; } = new FilterEventTypeItem("EVENT_TYPE_UNSPECIFIED");
        /// <summary>
        /// Corresponds with UpgradeAvailableEvent.
        /// </summary>
        public static FilterEventTypeItem UpgradeAvailableEvent { get; } = new FilterEventTypeItem("UPGRADE_AVAILABLE_EVENT");
        /// <summary>
        /// Corresponds with UpgradeEvent.
        /// </summary>
        public static FilterEventTypeItem UpgradeEvent { get; } = new FilterEventTypeItem("UPGRADE_EVENT");
        /// <summary>
        /// Corresponds with SecurityBulletinEvent.
        /// </summary>
        public static FilterEventTypeItem SecurityBulletinEvent { get; } = new FilterEventTypeItem("SECURITY_BULLETIN_EVENT");

        public static bool operator ==(FilterEventTypeItem left, FilterEventTypeItem right) => left.Equals(right);
        public static bool operator !=(FilterEventTypeItem left, FilterEventTypeItem right) => !left.Equals(right);

        public static explicit operator string(FilterEventTypeItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FilterEventTypeItem other && Equals(other);
        public bool Equals(FilterEventTypeItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Mode for how the GPU driver is installed.
    /// </summary>
    [EnumType]
    public readonly struct GPUDriverInstallationConfigGpuDriverVersion : IEquatable<GPUDriverInstallationConfigGpuDriverVersion>
    {
        private readonly string _value;

        private GPUDriverInstallationConfigGpuDriverVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value is to not install any GPU driver.
        /// </summary>
        public static GPUDriverInstallationConfigGpuDriverVersion GpuDriverVersionUnspecified { get; } = new GPUDriverInstallationConfigGpuDriverVersion("GPU_DRIVER_VERSION_UNSPECIFIED");
        /// <summary>
        /// Disable GPU driver auto installation and needs manual installation
        /// </summary>
        public static GPUDriverInstallationConfigGpuDriverVersion InstallationDisabled { get; } = new GPUDriverInstallationConfigGpuDriverVersion("INSTALLATION_DISABLED");
        /// <summary>
        /// "Default" GPU driver in COS and Ubuntu.
        /// </summary>
        public static GPUDriverInstallationConfigGpuDriverVersion Default { get; } = new GPUDriverInstallationConfigGpuDriverVersion("DEFAULT");
        /// <summary>
        /// "Latest" GPU driver in COS.
        /// </summary>
        public static GPUDriverInstallationConfigGpuDriverVersion Latest { get; } = new GPUDriverInstallationConfigGpuDriverVersion("LATEST");

        public static bool operator ==(GPUDriverInstallationConfigGpuDriverVersion left, GPUDriverInstallationConfigGpuDriverVersion right) => left.Equals(right);
        public static bool operator !=(GPUDriverInstallationConfigGpuDriverVersion left, GPUDriverInstallationConfigGpuDriverVersion right) => !left.Equals(right);

        public static explicit operator string(GPUDriverInstallationConfigGpuDriverVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GPUDriverInstallationConfigGpuDriverVersion other && Equals(other);
        public bool Equals(GPUDriverInstallationConfigGpuDriverVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of GPU sharing strategy to enable on the GPU node.
    /// </summary>
    [EnumType]
    public readonly struct GPUSharingConfigGpuSharingStrategy : IEquatable<GPUSharingConfigGpuSharingStrategy>
    {
        private readonly string _value;

        private GPUSharingConfigGpuSharingStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static GPUSharingConfigGpuSharingStrategy GpuSharingStrategyUnspecified { get; } = new GPUSharingConfigGpuSharingStrategy("GPU_SHARING_STRATEGY_UNSPECIFIED");
        /// <summary>
        /// GPUs are time-shared between containers.
        /// </summary>
        public static GPUSharingConfigGpuSharingStrategy TimeSharing { get; } = new GPUSharingConfigGpuSharingStrategy("TIME_SHARING");

        public static bool operator ==(GPUSharingConfigGpuSharingStrategy left, GPUSharingConfigGpuSharingStrategy right) => left.Equals(right);
        public static bool operator !=(GPUSharingConfigGpuSharingStrategy left, GPUSharingConfigGpuSharingStrategy right) => !left.Equals(right);

        public static explicit operator string(GPUSharingConfigGpuSharingStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GPUSharingConfigGpuSharingStrategy other && Equals(other);
        public bool Equals(GPUSharingConfigGpuSharingStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Gateway API release channel to use for Gateway API.
    /// </summary>
    [EnumType]
    public readonly struct GatewayAPIConfigChannel : IEquatable<GatewayAPIConfigChannel>
    {
        private readonly string _value;

        private GatewayAPIConfigChannel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static GatewayAPIConfigChannel ChannelUnspecified { get; } = new GatewayAPIConfigChannel("CHANNEL_UNSPECIFIED");
        /// <summary>
        /// Gateway API support is disabled
        /// </summary>
        public static GatewayAPIConfigChannel ChannelDisabled { get; } = new GatewayAPIConfigChannel("CHANNEL_DISABLED");
        /// <summary>
        /// Gateway API support is enabled, experimental CRDs are installed
        /// </summary>
        public static GatewayAPIConfigChannel ChannelExperimental { get; } = new GatewayAPIConfigChannel("CHANNEL_EXPERIMENTAL");
        /// <summary>
        /// Gateway API support is enabled, standard CRDs are installed
        /// </summary>
        public static GatewayAPIConfigChannel ChannelStandard { get; } = new GatewayAPIConfigChannel("CHANNEL_STANDARD");

        public static bool operator ==(GatewayAPIConfigChannel left, GatewayAPIConfigChannel right) => left.Equals(right);
        public static bool operator !=(GatewayAPIConfigChannel left, GatewayAPIConfigChannel right) => !left.Equals(right);

        public static explicit operator string(GatewayAPIConfigChannel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GatewayAPIConfigChannel other && Equals(other);
        public bool Equals(GatewayAPIConfigChannel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The ipv6 access type (internal or external) when create_subnetwork is true
    /// </summary>
    [EnumType]
    public readonly struct IPAllocationPolicyIpv6AccessType : IEquatable<IPAllocationPolicyIpv6AccessType>
    {
        private readonly string _value;

        private IPAllocationPolicyIpv6AccessType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value, will be defaulted as type external.
        /// </summary>
        public static IPAllocationPolicyIpv6AccessType Ipv6AccessTypeUnspecified { get; } = new IPAllocationPolicyIpv6AccessType("IPV6_ACCESS_TYPE_UNSPECIFIED");
        /// <summary>
        /// Access type internal (all v6 addresses are internal IPs)
        /// </summary>
        public static IPAllocationPolicyIpv6AccessType Internal { get; } = new IPAllocationPolicyIpv6AccessType("INTERNAL");
        /// <summary>
        /// Access type external (all v6 addresses are external IPs)
        /// </summary>
        public static IPAllocationPolicyIpv6AccessType External { get; } = new IPAllocationPolicyIpv6AccessType("EXTERNAL");

        public static bool operator ==(IPAllocationPolicyIpv6AccessType left, IPAllocationPolicyIpv6AccessType right) => left.Equals(right);
        public static bool operator !=(IPAllocationPolicyIpv6AccessType left, IPAllocationPolicyIpv6AccessType right) => !left.Equals(right);

        public static explicit operator string(IPAllocationPolicyIpv6AccessType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPAllocationPolicyIpv6AccessType other && Equals(other);
        public bool Equals(IPAllocationPolicyIpv6AccessType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP stack type of the cluster
    /// </summary>
    [EnumType]
    public readonly struct IPAllocationPolicyStackType : IEquatable<IPAllocationPolicyStackType>
    {
        private readonly string _value;

        private IPAllocationPolicyStackType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value, will be defaulted as IPV4 only
        /// </summary>
        public static IPAllocationPolicyStackType StackTypeUnspecified { get; } = new IPAllocationPolicyStackType("STACK_TYPE_UNSPECIFIED");
        /// <summary>
        /// Cluster is IPV4 only
        /// </summary>
        public static IPAllocationPolicyStackType Ipv4 { get; } = new IPAllocationPolicyStackType("IPV4");
        /// <summary>
        /// Cluster can use both IPv4 and IPv6
        /// </summary>
        public static IPAllocationPolicyStackType Ipv4Ipv6 { get; } = new IPAllocationPolicyStackType("IPV4_IPV6");

        public static bool operator ==(IPAllocationPolicyStackType left, IPAllocationPolicyStackType right) => left.Equals(right);
        public static bool operator !=(IPAllocationPolicyStackType left, IPAllocationPolicyStackType right) => !left.Equals(right);

        public static explicit operator string(IPAllocationPolicyStackType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPAllocationPolicyStackType other && Equals(other);
        public bool Equals(IPAllocationPolicyStackType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// cgroup_mode specifies the cgroup mode to be used on the node.
    /// </summary>
    [EnumType]
    public readonly struct LinuxNodeConfigCgroupMode : IEquatable<LinuxNodeConfigCgroupMode>
    {
        private readonly string _value;

        private LinuxNodeConfigCgroupMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// CGROUP_MODE_UNSPECIFIED is when unspecified cgroup configuration is used. The default for the GKE node OS image will be used.
        /// </summary>
        public static LinuxNodeConfigCgroupMode CgroupModeUnspecified { get; } = new LinuxNodeConfigCgroupMode("CGROUP_MODE_UNSPECIFIED");
        /// <summary>
        /// CGROUP_MODE_V1 specifies to use cgroupv1 for the cgroup configuration on the node image.
        /// </summary>
        public static LinuxNodeConfigCgroupMode CgroupModeV1 { get; } = new LinuxNodeConfigCgroupMode("CGROUP_MODE_V1");
        /// <summary>
        /// CGROUP_MODE_V2 specifies to use cgroupv2 for the cgroup configuration on the node image.
        /// </summary>
        public static LinuxNodeConfigCgroupMode CgroupModeV2 { get; } = new LinuxNodeConfigCgroupMode("CGROUP_MODE_V2");

        public static bool operator ==(LinuxNodeConfigCgroupMode left, LinuxNodeConfigCgroupMode right) => left.Equals(right);
        public static bool operator !=(LinuxNodeConfigCgroupMode left, LinuxNodeConfigCgroupMode right) => !left.Equals(right);

        public static explicit operator string(LinuxNodeConfigCgroupMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LinuxNodeConfigCgroupMode other && Equals(other);
        public bool Equals(LinuxNodeConfigCgroupMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct LoggingComponentConfigEnableComponentsItem : IEquatable<LoggingComponentConfigEnableComponentsItem>
    {
        private readonly string _value;

        private LoggingComponentConfigEnableComponentsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This shouldn't be used.
        /// </summary>
        public static LoggingComponentConfigEnableComponentsItem ComponentUnspecified { get; } = new LoggingComponentConfigEnableComponentsItem("COMPONENT_UNSPECIFIED");
        /// <summary>
        /// system components
        /// </summary>
        public static LoggingComponentConfigEnableComponentsItem SystemComponents { get; } = new LoggingComponentConfigEnableComponentsItem("SYSTEM_COMPONENTS");
        /// <summary>
        /// workloads
        /// </summary>
        public static LoggingComponentConfigEnableComponentsItem Workloads { get; } = new LoggingComponentConfigEnableComponentsItem("WORKLOADS");
        /// <summary>
        /// kube-apiserver
        /// </summary>
        public static LoggingComponentConfigEnableComponentsItem Apiserver { get; } = new LoggingComponentConfigEnableComponentsItem("APISERVER");
        /// <summary>
        /// kube-scheduler
        /// </summary>
        public static LoggingComponentConfigEnableComponentsItem Scheduler { get; } = new LoggingComponentConfigEnableComponentsItem("SCHEDULER");
        /// <summary>
        /// kube-controller-manager
        /// </summary>
        public static LoggingComponentConfigEnableComponentsItem ControllerManager { get; } = new LoggingComponentConfigEnableComponentsItem("CONTROLLER_MANAGER");

        public static bool operator ==(LoggingComponentConfigEnableComponentsItem left, LoggingComponentConfigEnableComponentsItem right) => left.Equals(right);
        public static bool operator !=(LoggingComponentConfigEnableComponentsItem left, LoggingComponentConfigEnableComponentsItem right) => !left.Equals(right);

        public static explicit operator string(LoggingComponentConfigEnableComponentsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingComponentConfigEnableComponentsItem other && Equals(other);
        public bool Equals(LoggingComponentConfigEnableComponentsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Logging variant deployed on nodes.
    /// </summary>
    [EnumType]
    public readonly struct LoggingVariantConfigVariant : IEquatable<LoggingVariantConfigVariant>
    {
        private readonly string _value;

        private LoggingVariantConfigVariant(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This shouldn't be used.
        /// </summary>
        public static LoggingVariantConfigVariant VariantUnspecified { get; } = new LoggingVariantConfigVariant("VARIANT_UNSPECIFIED");
        /// <summary>
        /// default logging variant.
        /// </summary>
        public static LoggingVariantConfigVariant Default { get; } = new LoggingVariantConfigVariant("DEFAULT");
        /// <summary>
        /// maximum logging throughput variant.
        /// </summary>
        public static LoggingVariantConfigVariant MaxThroughput { get; } = new LoggingVariantConfigVariant("MAX_THROUGHPUT");

        public static bool operator ==(LoggingVariantConfigVariant left, LoggingVariantConfigVariant right) => left.Equals(right);
        public static bool operator !=(LoggingVariantConfigVariant left, LoggingVariantConfigVariant right) => !left.Equals(right);

        public static explicit operator string(LoggingVariantConfigVariant value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingVariantConfigVariant other && Equals(other);
        public bool Equals(LoggingVariantConfigVariant other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Scope specifies the upgrade scope which upgrades are blocked by the exclusion.
    /// </summary>
    [EnumType]
    public readonly struct MaintenanceExclusionOptionsScope : IEquatable<MaintenanceExclusionOptionsScope>
    {
        private readonly string _value;

        private MaintenanceExclusionOptionsScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// NO_UPGRADES excludes all upgrades, including patch upgrades and minor upgrades across control planes and nodes. This is the default exclusion behavior.
        /// </summary>
        public static MaintenanceExclusionOptionsScope NoUpgrades { get; } = new MaintenanceExclusionOptionsScope("NO_UPGRADES");
        /// <summary>
        /// NO_MINOR_UPGRADES excludes all minor upgrades for the cluster, only patches are allowed.
        /// </summary>
        public static MaintenanceExclusionOptionsScope NoMinorUpgrades { get; } = new MaintenanceExclusionOptionsScope("NO_MINOR_UPGRADES");
        /// <summary>
        /// NO_MINOR_OR_NODE_UPGRADES excludes all minor upgrades for the cluster, and also exclude all node pool upgrades. Only control plane patches are allowed.
        /// </summary>
        public static MaintenanceExclusionOptionsScope NoMinorOrNodeUpgrades { get; } = new MaintenanceExclusionOptionsScope("NO_MINOR_OR_NODE_UPGRADES");

        public static bool operator ==(MaintenanceExclusionOptionsScope left, MaintenanceExclusionOptionsScope right) => left.Equals(right);
        public static bool operator !=(MaintenanceExclusionOptionsScope left, MaintenanceExclusionOptionsScope right) => !left.Equals(right);

        public static explicit operator string(MaintenanceExclusionOptionsScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MaintenanceExclusionOptionsScope other && Equals(other);
        public bool Equals(MaintenanceExclusionOptionsScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct MonitoringComponentConfigEnableComponentsItem : IEquatable<MonitoringComponentConfigEnableComponentsItem>
    {
        private readonly string _value;

        private MonitoringComponentConfigEnableComponentsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This shouldn't be used.
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem ComponentUnspecified { get; } = new MonitoringComponentConfigEnableComponentsItem("COMPONENT_UNSPECIFIED");
        /// <summary>
        /// system components
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem SystemComponents { get; } = new MonitoringComponentConfigEnableComponentsItem("SYSTEM_COMPONENTS");
        /// <summary>
        /// kube-apiserver
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem Apiserver { get; } = new MonitoringComponentConfigEnableComponentsItem("APISERVER");
        /// <summary>
        /// kube-scheduler
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem Scheduler { get; } = new MonitoringComponentConfigEnableComponentsItem("SCHEDULER");
        /// <summary>
        /// kube-controller-manager
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem ControllerManager { get; } = new MonitoringComponentConfigEnableComponentsItem("CONTROLLER_MANAGER");
        /// <summary>
        /// Storage
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem Storage { get; } = new MonitoringComponentConfigEnableComponentsItem("STORAGE");
        /// <summary>
        /// Horizontal Pod Autoscaling
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem Hpa { get; } = new MonitoringComponentConfigEnableComponentsItem("HPA");
        /// <summary>
        /// Pod
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem Pod { get; } = new MonitoringComponentConfigEnableComponentsItem("POD");
        /// <summary>
        /// DaemonSet
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem Daemonset { get; } = new MonitoringComponentConfigEnableComponentsItem("DAEMONSET");
        /// <summary>
        /// Deployment
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem Deployment { get; } = new MonitoringComponentConfigEnableComponentsItem("DEPLOYMENT");
        /// <summary>
        /// Statefulset
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem Statefulset { get; } = new MonitoringComponentConfigEnableComponentsItem("STATEFULSET");

        public static bool operator ==(MonitoringComponentConfigEnableComponentsItem left, MonitoringComponentConfigEnableComponentsItem right) => left.Equals(right);
        public static bool operator !=(MonitoringComponentConfigEnableComponentsItem left, MonitoringComponentConfigEnableComponentsItem right) => !left.Equals(right);

        public static explicit operator string(MonitoringComponentConfigEnableComponentsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MonitoringComponentConfigEnableComponentsItem other && Equals(other);
        public bool Equals(MonitoringComponentConfigEnableComponentsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired datapath provider for this cluster. By default, uses the IPTables-based kube-proxy implementation.
    /// </summary>
    [EnumType]
    public readonly struct NetworkConfigDatapathProvider : IEquatable<NetworkConfigDatapathProvider>
    {
        private readonly string _value;

        private NetworkConfigDatapathProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static NetworkConfigDatapathProvider DatapathProviderUnspecified { get; } = new NetworkConfigDatapathProvider("DATAPATH_PROVIDER_UNSPECIFIED");
        /// <summary>
        /// Use the IPTables implementation based on kube-proxy.
        /// </summary>
        public static NetworkConfigDatapathProvider LegacyDatapath { get; } = new NetworkConfigDatapathProvider("LEGACY_DATAPATH");
        /// <summary>
        /// Use the eBPF based GKE Dataplane V2 with additional features. See the [GKE Dataplane V2 documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2) for more.
        /// </summary>
        public static NetworkConfigDatapathProvider AdvancedDatapath { get; } = new NetworkConfigDatapathProvider("ADVANCED_DATAPATH");

        public static bool operator ==(NetworkConfigDatapathProvider left, NetworkConfigDatapathProvider right) => left.Equals(right);
        public static bool operator !=(NetworkConfigDatapathProvider left, NetworkConfigDatapathProvider right) => !left.Equals(right);

        public static explicit operator string(NetworkConfigDatapathProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkConfigDatapathProvider other && Equals(other);
        public bool Equals(NetworkConfigDatapathProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4)
    /// </summary>
    [EnumType]
    public readonly struct NetworkConfigPrivateIpv6GoogleAccess : IEquatable<NetworkConfigPrivateIpv6GoogleAccess>
    {
        private readonly string _value;

        private NetworkConfigPrivateIpv6GoogleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. Same as DISABLED
        /// </summary>
        public static NetworkConfigPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessUnspecified { get; } = new NetworkConfigPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED");
        /// <summary>
        /// No private access to or from Google Services
        /// </summary>
        public static NetworkConfigPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessDisabled { get; } = new NetworkConfigPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED");
        /// <summary>
        /// Enables private IPv6 access to Google Services from GKE
        /// </summary>
        public static NetworkConfigPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessToGoogle { get; } = new NetworkConfigPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE");
        /// <summary>
        /// Enables private IPv6 access to and from Google Services
        /// </summary>
        public static NetworkConfigPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessBidirectional { get; } = new NetworkConfigPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL");

        public static bool operator ==(NetworkConfigPrivateIpv6GoogleAccess left, NetworkConfigPrivateIpv6GoogleAccess right) => left.Equals(right);
        public static bool operator !=(NetworkConfigPrivateIpv6GoogleAccess left, NetworkConfigPrivateIpv6GoogleAccess right) => !left.Equals(right);

        public static explicit operator string(NetworkConfigPrivateIpv6GoogleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkConfigPrivateIpv6GoogleAccess other && Equals(other);
        public bool Equals(NetworkConfigPrivateIpv6GoogleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the total network bandwidth tier for the NodePool.
    /// </summary>
    [EnumType]
    public readonly struct NetworkPerformanceConfigTotalEgressBandwidthTier : IEquatable<NetworkPerformanceConfigTotalEgressBandwidthTier>
    {
        private readonly string _value;

        private NetworkPerformanceConfigTotalEgressBandwidthTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value
        /// </summary>
        public static NetworkPerformanceConfigTotalEgressBandwidthTier TierUnspecified { get; } = new NetworkPerformanceConfigTotalEgressBandwidthTier("TIER_UNSPECIFIED");
        /// <summary>
        /// Higher bandwidth, actual values based on VM size.
        /// </summary>
        public static NetworkPerformanceConfigTotalEgressBandwidthTier Tier1 { get; } = new NetworkPerformanceConfigTotalEgressBandwidthTier("TIER_1");

        public static bool operator ==(NetworkPerformanceConfigTotalEgressBandwidthTier left, NetworkPerformanceConfigTotalEgressBandwidthTier right) => left.Equals(right);
        public static bool operator !=(NetworkPerformanceConfigTotalEgressBandwidthTier left, NetworkPerformanceConfigTotalEgressBandwidthTier right) => !left.Equals(right);

        public static explicit operator string(NetworkPerformanceConfigTotalEgressBandwidthTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkPerformanceConfigTotalEgressBandwidthTier other && Equals(other);
        public bool Equals(NetworkPerformanceConfigTotalEgressBandwidthTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The selected network policy provider.
    /// </summary>
    [EnumType]
    public readonly struct NetworkPolicyProvider : IEquatable<NetworkPolicyProvider>
    {
        private readonly string _value;

        private NetworkPolicyProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set
        /// </summary>
        public static NetworkPolicyProvider ProviderUnspecified { get; } = new NetworkPolicyProvider("PROVIDER_UNSPECIFIED");
        /// <summary>
        /// Tigera (Calico Felix).
        /// </summary>
        public static NetworkPolicyProvider Calico { get; } = new NetworkPolicyProvider("CALICO");

        public static bool operator ==(NetworkPolicyProvider left, NetworkPolicyProvider right) => left.Equals(right);
        public static bool operator !=(NetworkPolicyProvider left, NetworkPolicyProvider right) => !left.Equals(right);

        public static explicit operator string(NetworkPolicyProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkPolicyProvider other && Equals(other);
        public bool Equals(NetworkPolicyProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Operator for NodeAffinity.
    /// </summary>
    [EnumType]
    public readonly struct NodeAffinityOperator : IEquatable<NodeAffinityOperator>
    {
        private readonly string _value;

        private NodeAffinityOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Invalid or unspecified affinity operator.
        /// </summary>
        public static NodeAffinityOperator OperatorUnspecified { get; } = new NodeAffinityOperator("OPERATOR_UNSPECIFIED");
        /// <summary>
        /// Affinity operator.
        /// </summary>
        public static NodeAffinityOperator In { get; } = new NodeAffinityOperator("IN");
        /// <summary>
        /// Anti-affinity operator.
        /// </summary>
        public static NodeAffinityOperator NotIn { get; } = new NodeAffinityOperator("NOT_IN");

        public static bool operator ==(NodeAffinityOperator left, NodeAffinityOperator right) => left.Equals(right);
        public static bool operator !=(NodeAffinityOperator left, NodeAffinityOperator right) => !left.Equals(right);

        public static explicit operator string(NodeAffinityOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeAffinityOperator other && Equals(other);
        public bool Equals(NodeAffinityOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Location policy used when scaling up a nodepool.
    /// </summary>
    [EnumType]
    public readonly struct NodePoolAutoscalingLocationPolicy : IEquatable<NodePoolAutoscalingLocationPolicy>
    {
        private readonly string _value;

        private NodePoolAutoscalingLocationPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set.
        /// </summary>
        public static NodePoolAutoscalingLocationPolicy LocationPolicyUnspecified { get; } = new NodePoolAutoscalingLocationPolicy("LOCATION_POLICY_UNSPECIFIED");
        /// <summary>
        /// BALANCED is a best effort policy that aims to balance the sizes of different zones.
        /// </summary>
        public static NodePoolAutoscalingLocationPolicy Balanced { get; } = new NodePoolAutoscalingLocationPolicy("BALANCED");
        /// <summary>
        /// ANY policy picks zones that have the highest capacity available.
        /// </summary>
        public static NodePoolAutoscalingLocationPolicy Any { get; } = new NodePoolAutoscalingLocationPolicy("ANY");

        public static bool operator ==(NodePoolAutoscalingLocationPolicy left, NodePoolAutoscalingLocationPolicy right) => left.Equals(right);
        public static bool operator !=(NodePoolAutoscalingLocationPolicy left, NodePoolAutoscalingLocationPolicy right) => !left.Equals(right);

        public static explicit operator string(NodePoolAutoscalingLocationPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodePoolAutoscalingLocationPolicy other && Equals(other);
        public bool Equals(NodePoolAutoscalingLocationPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Effect for taint.
    /// </summary>
    [EnumType]
    public readonly struct NodeTaintEffect : IEquatable<NodeTaintEffect>
    {
        private readonly string _value;

        private NodeTaintEffect(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set
        /// </summary>
        public static NodeTaintEffect EffectUnspecified { get; } = new NodeTaintEffect("EFFECT_UNSPECIFIED");
        /// <summary>
        /// NoSchedule
        /// </summary>
        public static NodeTaintEffect NoSchedule { get; } = new NodeTaintEffect("NO_SCHEDULE");
        /// <summary>
        /// PreferNoSchedule
        /// </summary>
        public static NodeTaintEffect PreferNoSchedule { get; } = new NodeTaintEffect("PREFER_NO_SCHEDULE");
        /// <summary>
        /// NoExecute
        /// </summary>
        public static NodeTaintEffect NoExecute { get; } = new NodeTaintEffect("NO_EXECUTE");

        public static bool operator ==(NodeTaintEffect left, NodeTaintEffect right) => left.Equals(right);
        public static bool operator !=(NodeTaintEffect left, NodeTaintEffect right) => !left.Equals(right);

        public static explicit operator string(NodeTaintEffect value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeTaintEffect other && Equals(other);
        public bool Equals(NodeTaintEffect other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of placement.
    /// </summary>
    [EnumType]
    public readonly struct PlacementPolicyType : IEquatable<PlacementPolicyType>
    {
        private readonly string _value;

        private PlacementPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// TYPE_UNSPECIFIED specifies no requirements on nodes placement.
        /// </summary>
        public static PlacementPolicyType TypeUnspecified { get; } = new PlacementPolicyType("TYPE_UNSPECIFIED");
        /// <summary>
        /// COMPACT specifies node placement in the same availability domain to ensure low communication latency.
        /// </summary>
        public static PlacementPolicyType Compact { get; } = new PlacementPolicyType("COMPACT");

        public static bool operator ==(PlacementPolicyType left, PlacementPolicyType right) => left.Equals(right);
        public static bool operator !=(PlacementPolicyType left, PlacementPolicyType right) => !left.Equals(right);

        public static explicit operator string(PlacementPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PlacementPolicyType other && Equals(other);
        public bool Equals(PlacementPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// channel specifies which release channel the cluster is subscribed to.
    /// </summary>
    [EnumType]
    public readonly struct ReleaseChannelChannel : IEquatable<ReleaseChannelChannel>
    {
        private readonly string _value;

        private ReleaseChannelChannel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No channel specified.
        /// </summary>
        public static ReleaseChannelChannel Unspecified { get; } = new ReleaseChannelChannel("UNSPECIFIED");
        /// <summary>
        /// RAPID channel is offered on an early access basis for customers who want to test new releases. WARNING: Versions available in the RAPID Channel may be subject to unresolved issues with no known workaround and are not subject to any SLAs.
        /// </summary>
        public static ReleaseChannelChannel Rapid { get; } = new ReleaseChannelChannel("RAPID");
        /// <summary>
        /// Clusters subscribed to REGULAR receive versions that are considered GA quality. REGULAR is intended for production users who want to take advantage of new features.
        /// </summary>
        public static ReleaseChannelChannel Regular { get; } = new ReleaseChannelChannel("REGULAR");
        /// <summary>
        /// Clusters subscribed to STABLE receive versions that are known to be stable and reliable in production.
        /// </summary>
        public static ReleaseChannelChannel Stable { get; } = new ReleaseChannelChannel("STABLE");

        public static bool operator ==(ReleaseChannelChannel left, ReleaseChannelChannel right) => left.Equals(right);
        public static bool operator !=(ReleaseChannelChannel left, ReleaseChannelChannel right) => !left.Equals(right);

        public static explicit operator string(ReleaseChannelChannel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReleaseChannelChannel other && Equals(other);
        public bool Equals(ReleaseChannelChannel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Corresponds to the type of reservation consumption.
    /// </summary>
    [EnumType]
    public readonly struct ReservationAffinityConsumeReservationType : IEquatable<ReservationAffinityConsumeReservationType>
    {
        private readonly string _value;

        private ReservationAffinityConsumeReservationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This should not be used.
        /// </summary>
        public static ReservationAffinityConsumeReservationType Unspecified { get; } = new ReservationAffinityConsumeReservationType("UNSPECIFIED");
        /// <summary>
        /// Do not consume from any reserved capacity.
        /// </summary>
        public static ReservationAffinityConsumeReservationType NoReservation { get; } = new ReservationAffinityConsumeReservationType("NO_RESERVATION");
        /// <summary>
        /// Consume any reservation available.
        /// </summary>
        public static ReservationAffinityConsumeReservationType AnyReservation { get; } = new ReservationAffinityConsumeReservationType("ANY_RESERVATION");
        /// <summary>
        /// Must consume from a specific reservation. Must specify key value fields for specifying the reservations.
        /// </summary>
        public static ReservationAffinityConsumeReservationType SpecificReservation { get; } = new ReservationAffinityConsumeReservationType("SPECIFIC_RESERVATION");

        public static bool operator ==(ReservationAffinityConsumeReservationType left, ReservationAffinityConsumeReservationType right) => left.Equals(right);
        public static bool operator !=(ReservationAffinityConsumeReservationType left, ReservationAffinityConsumeReservationType right) => !left.Equals(right);

        public static explicit operator string(ReservationAffinityConsumeReservationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReservationAffinityConsumeReservationType other && Equals(other);
        public bool Equals(ReservationAffinityConsumeReservationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the sandbox to use for the node.
    /// </summary>
    [EnumType]
    public readonly struct SandboxConfigType : IEquatable<SandboxConfigType>
    {
        private readonly string _value;

        private SandboxConfigType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This should not be used.
        /// </summary>
        public static SandboxConfigType Unspecified { get; } = new SandboxConfigType("UNSPECIFIED");
        /// <summary>
        /// Run sandbox using gvisor.
        /// </summary>
        public static SandboxConfigType Gvisor { get; } = new SandboxConfigType("GVISOR");

        public static bool operator ==(SandboxConfigType left, SandboxConfigType right) => left.Equals(right);
        public static bool operator !=(SandboxConfigType left, SandboxConfigType right) => !left.Equals(right);

        public static explicit operator string(SandboxConfigType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SandboxConfigType other && Equals(other);
        public bool Equals(SandboxConfigType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sets which mode to use for Security Posture features.
    /// </summary>
    [EnumType]
    public readonly struct SecurityPostureConfigMode : IEquatable<SecurityPostureConfigMode>
    {
        private readonly string _value;

        private SecurityPostureConfigMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value not specified.
        /// </summary>
        public static SecurityPostureConfigMode ModeUnspecified { get; } = new SecurityPostureConfigMode("MODE_UNSPECIFIED");
        /// <summary>
        /// Disables Security Posture features on the cluster.
        /// </summary>
        public static SecurityPostureConfigMode Disabled { get; } = new SecurityPostureConfigMode("DISABLED");
        /// <summary>
        /// Applies Security Posture features on the cluster.
        /// </summary>
        public static SecurityPostureConfigMode Basic { get; } = new SecurityPostureConfigMode("BASIC");

        public static bool operator ==(SecurityPostureConfigMode left, SecurityPostureConfigMode right) => left.Equals(right);
        public static bool operator !=(SecurityPostureConfigMode left, SecurityPostureConfigMode right) => !left.Equals(right);

        public static explicit operator string(SecurityPostureConfigMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPostureConfigMode other && Equals(other);
        public bool Equals(SecurityPostureConfigMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sets which mode to use for vulnerability scanning.
    /// </summary>
    [EnumType]
    public readonly struct SecurityPostureConfigVulnerabilityMode : IEquatable<SecurityPostureConfigVulnerabilityMode>
    {
        private readonly string _value;

        private SecurityPostureConfigVulnerabilityMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value not specified.
        /// </summary>
        public static SecurityPostureConfigVulnerabilityMode VulnerabilityModeUnspecified { get; } = new SecurityPostureConfigVulnerabilityMode("VULNERABILITY_MODE_UNSPECIFIED");
        /// <summary>
        /// Disables vulnerability scanning on the cluster.
        /// </summary>
        public static SecurityPostureConfigVulnerabilityMode VulnerabilityDisabled { get; } = new SecurityPostureConfigVulnerabilityMode("VULNERABILITY_DISABLED");
        /// <summary>
        /// Applies basic vulnerability scanning on the cluster.
        /// </summary>
        public static SecurityPostureConfigVulnerabilityMode VulnerabilityBasic { get; } = new SecurityPostureConfigVulnerabilityMode("VULNERABILITY_BASIC");

        public static bool operator ==(SecurityPostureConfigVulnerabilityMode left, SecurityPostureConfigVulnerabilityMode right) => left.Equals(right);
        public static bool operator !=(SecurityPostureConfigVulnerabilityMode left, SecurityPostureConfigVulnerabilityMode right) => !left.Equals(right);

        public static explicit operator string(SecurityPostureConfigVulnerabilityMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPostureConfigVulnerabilityMode other && Equals(other);
        public bool Equals(SecurityPostureConfigVulnerabilityMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Canonical code of the condition.
    /// </summary>
    [EnumType]
    public readonly struct StatusConditionCanonicalCode : IEquatable<StatusConditionCanonicalCode>
    {
        private readonly string _value;

        private StatusConditionCanonicalCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not an error; returned on success. HTTP Mapping: 200 OK
        /// </summary>
        public static StatusConditionCanonicalCode Ok { get; } = new StatusConditionCanonicalCode("OK");
        /// <summary>
        /// The operation was cancelled, typically by the caller. HTTP Mapping: 499 Client Closed Request
        /// </summary>
        public static StatusConditionCanonicalCode Cancelled { get; } = new StatusConditionCanonicalCode("CANCELLED");
        /// <summary>
        /// Unknown error. For example, this error may be returned when a `Status` value received from another address space belongs to an error space that is not known in this address space. Also errors raised by APIs that do not return enough error information may be converted to this error. HTTP Mapping: 500 Internal Server Error
        /// </summary>
        public static StatusConditionCanonicalCode Unknown { get; } = new StatusConditionCanonicalCode("UNKNOWN");
        /// <summary>
        /// The client specified an invalid argument. Note that this differs from `FAILED_PRECONDITION`. `INVALID_ARGUMENT` indicates arguments that are problematic regardless of the state of the system (e.g., a malformed file name). HTTP Mapping: 400 Bad Request
        /// </summary>
        public static StatusConditionCanonicalCode InvalidArgument { get; } = new StatusConditionCanonicalCode("INVALID_ARGUMENT");
        /// <summary>
        /// The deadline expired before the operation could complete. For operations that change the state of the system, this error may be returned even if the operation has completed successfully. For example, a successful response from a server could have been delayed long enough for the deadline to expire. HTTP Mapping: 504 Gateway Timeout
        /// </summary>
        public static StatusConditionCanonicalCode DeadlineExceeded { get; } = new StatusConditionCanonicalCode("DEADLINE_EXCEEDED");
        /// <summary>
        /// Some requested entity (e.g., file or directory) was not found. Note to server developers: if a request is denied for an entire class of users, such as gradual feature rollout or undocumented allowlist, `NOT_FOUND` may be used. If a request is denied for some users within a class of users, such as user-based access control, `PERMISSION_DENIED` must be used. HTTP Mapping: 404 Not Found
        /// </summary>
        public static StatusConditionCanonicalCode NotFound { get; } = new StatusConditionCanonicalCode("NOT_FOUND");
        /// <summary>
        /// The entity that a client attempted to create (e.g., file or directory) already exists. HTTP Mapping: 409 Conflict
        /// </summary>
        public static StatusConditionCanonicalCode AlreadyExists { get; } = new StatusConditionCanonicalCode("ALREADY_EXISTS");
        /// <summary>
        /// The caller does not have permission to execute the specified operation. `PERMISSION_DENIED` must not be used for rejections caused by exhausting some resource (use `RESOURCE_EXHAUSTED` instead for those errors). `PERMISSION_DENIED` must not be used if the caller can not be identified (use `UNAUTHENTICATED` instead for those errors). This error code does not imply the request is valid or the requested entity exists or satisfies other pre-conditions. HTTP Mapping: 403 Forbidden
        /// </summary>
        public static StatusConditionCanonicalCode PermissionDenied { get; } = new StatusConditionCanonicalCode("PERMISSION_DENIED");
        /// <summary>
        /// The request does not have valid authentication credentials for the operation. HTTP Mapping: 401 Unauthorized
        /// </summary>
        public static StatusConditionCanonicalCode Unauthenticated { get; } = new StatusConditionCanonicalCode("UNAUTHENTICATED");
        /// <summary>
        /// Some resource has been exhausted, perhaps a per-user quota, or perhaps the entire file system is out of space. HTTP Mapping: 429 Too Many Requests
        /// </summary>
        public static StatusConditionCanonicalCode ResourceExhausted { get; } = new StatusConditionCanonicalCode("RESOURCE_EXHAUSTED");
        /// <summary>
        /// The operation was rejected because the system is not in a state required for the operation's execution. For example, the directory to be deleted is non-empty, an rmdir operation is applied to a non-directory, etc. Service implementors can use the following guidelines to decide between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`: (a) Use `UNAVAILABLE` if the client can retry just the failing call. (b) Use `ABORTED` if the client should retry at a higher level. For example, when a client-specified test-and-set fails, indicating the client should restart a read-modify-write sequence. (c) Use `FAILED_PRECONDITION` if the client should not retry until the system state has been explicitly fixed. For example, if an "rmdir" fails because the directory is non-empty, `FAILED_PRECONDITION` should be returned since the client should not retry unless the files are deleted from the directory. HTTP Mapping: 400 Bad Request
        /// </summary>
        public static StatusConditionCanonicalCode FailedPrecondition { get; } = new StatusConditionCanonicalCode("FAILED_PRECONDITION");
        /// <summary>
        /// The operation was aborted, typically due to a concurrency issue such as a sequencer check failure or transaction abort. See the guidelines above for deciding between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`. HTTP Mapping: 409 Conflict
        /// </summary>
        public static StatusConditionCanonicalCode Aborted { get; } = new StatusConditionCanonicalCode("ABORTED");
        /// <summary>
        /// The operation was attempted past the valid range. E.g., seeking or reading past end-of-file. Unlike `INVALID_ARGUMENT`, this error indicates a problem that may be fixed if the system state changes. For example, a 32-bit file system will generate `INVALID_ARGUMENT` if asked to read at an offset that is not in the range [0,2^32-1], but it will generate `OUT_OF_RANGE` if asked to read from an offset past the current file size. There is a fair bit of overlap between `FAILED_PRECONDITION` and `OUT_OF_RANGE`. We recommend using `OUT_OF_RANGE` (the more specific error) when it applies so that callers who are iterating through a space can easily look for an `OUT_OF_RANGE` error to detect when they are done. HTTP Mapping: 400 Bad Request
        /// </summary>
        public static StatusConditionCanonicalCode OutOfRange { get; } = new StatusConditionCanonicalCode("OUT_OF_RANGE");
        /// <summary>
        /// The operation is not implemented or is not supported/enabled in this service. HTTP Mapping: 501 Not Implemented
        /// </summary>
        public static StatusConditionCanonicalCode Unimplemented { get; } = new StatusConditionCanonicalCode("UNIMPLEMENTED");
        /// <summary>
        /// Internal errors. This means that some invariants expected by the underlying system have been broken. This error code is reserved for serious errors. HTTP Mapping: 500 Internal Server Error
        /// </summary>
        public static StatusConditionCanonicalCode Internal { get; } = new StatusConditionCanonicalCode("INTERNAL");
        /// <summary>
        /// The service is currently unavailable. This is most likely a transient condition, which can be corrected by retrying with a backoff. Note that it is not always safe to retry non-idempotent operations. See the guidelines above for deciding between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`. HTTP Mapping: 503 Service Unavailable
        /// </summary>
        public static StatusConditionCanonicalCode Unavailable { get; } = new StatusConditionCanonicalCode("UNAVAILABLE");
        /// <summary>
        /// Unrecoverable data loss or corruption. HTTP Mapping: 500 Internal Server Error
        /// </summary>
        public static StatusConditionCanonicalCode DataLoss { get; } = new StatusConditionCanonicalCode("DATA_LOSS");

        public static bool operator ==(StatusConditionCanonicalCode left, StatusConditionCanonicalCode right) => left.Equals(right);
        public static bool operator !=(StatusConditionCanonicalCode left, StatusConditionCanonicalCode right) => !left.Equals(right);

        public static explicit operator string(StatusConditionCanonicalCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatusConditionCanonicalCode other && Equals(other);
        public bool Equals(StatusConditionCanonicalCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Machine-friendly representation of the condition Deprecated. Use canonical_code instead.
    /// </summary>
    [EnumType]
    public readonly struct StatusConditionCode : IEquatable<StatusConditionCode>
    {
        private readonly string _value;

        private StatusConditionCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// UNKNOWN indicates a generic condition.
        /// </summary>
        public static StatusConditionCode Unknown { get; } = new StatusConditionCode("UNKNOWN");
        /// <summary>
        /// GCE_STOCKOUT indicates that Google Compute Engine resources are temporarily unavailable.
        /// </summary>
        public static StatusConditionCode GceStockout { get; } = new StatusConditionCode("GCE_STOCKOUT");
        /// <summary>
        /// GKE_SERVICE_ACCOUNT_DELETED indicates that the user deleted their robot service account.
        /// </summary>
        public static StatusConditionCode GkeServiceAccountDeleted { get; } = new StatusConditionCode("GKE_SERVICE_ACCOUNT_DELETED");
        /// <summary>
        /// Google Compute Engine quota was exceeded.
        /// </summary>
        public static StatusConditionCode GceQuotaExceeded { get; } = new StatusConditionCode("GCE_QUOTA_EXCEEDED");
        /// <summary>
        /// Cluster state was manually changed by an SRE due to a system logic error.
        /// </summary>
        public static StatusConditionCode SetByOperator { get; } = new StatusConditionCode("SET_BY_OPERATOR");
        /// <summary>
        /// Unable to perform an encrypt operation against the CloudKMS key used for etcd level encryption.
        /// </summary>
        public static StatusConditionCode CloudKmsKeyError { get; } = new StatusConditionCode("CLOUD_KMS_KEY_ERROR");
        /// <summary>
        /// Cluster CA is expiring soon.
        /// </summary>
        public static StatusConditionCode CaExpiring { get; } = new StatusConditionCode("CA_EXPIRING");

        public static bool operator ==(StatusConditionCode left, StatusConditionCode right) => left.Equals(right);
        public static bool operator !=(StatusConditionCode left, StatusConditionCode right) => !left.Equals(right);

        public static explicit operator string(StatusConditionCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatusConditionCode other && Equals(other);
        public bool Equals(StatusConditionCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Update strategy of the node pool.
    /// </summary>
    [EnumType]
    public readonly struct UpgradeSettingsStrategy : IEquatable<UpgradeSettingsStrategy>
    {
        private readonly string _value;

        private UpgradeSettingsStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value if unset. GKE internally defaults the update strategy to SURGE for unspecified strategies.
        /// </summary>
        public static UpgradeSettingsStrategy NodePoolUpdateStrategyUnspecified { get; } = new UpgradeSettingsStrategy("NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED");
        /// <summary>
        /// blue-green upgrade.
        /// </summary>
        public static UpgradeSettingsStrategy BlueGreen { get; } = new UpgradeSettingsStrategy("BLUE_GREEN");
        /// <summary>
        /// SURGE is the traditional way of upgrade a node pool. max_surge and max_unavailable determines the level of upgrade parallelism.
        /// </summary>
        public static UpgradeSettingsStrategy Surge { get; } = new UpgradeSettingsStrategy("SURGE");

        public static bool operator ==(UpgradeSettingsStrategy left, UpgradeSettingsStrategy right) => left.Equals(right);
        public static bool operator !=(UpgradeSettingsStrategy left, UpgradeSettingsStrategy right) => !left.Equals(right);

        public static explicit operator string(UpgradeSettingsStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UpgradeSettingsStrategy other && Equals(other);
        public bool Equals(UpgradeSettingsStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// OSVersion specifies the Windows node config to be used on the node
    /// </summary>
    [EnumType]
    public readonly struct WindowsNodeConfigOsVersion : IEquatable<WindowsNodeConfigOsVersion>
    {
        private readonly string _value;

        private WindowsNodeConfigOsVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// When OSVersion is not specified
        /// </summary>
        public static WindowsNodeConfigOsVersion OsVersionUnspecified { get; } = new WindowsNodeConfigOsVersion("OS_VERSION_UNSPECIFIED");
        /// <summary>
        /// LTSC2019 specifies to use LTSC2019 as the Windows Servercore Base Image
        /// </summary>
        public static WindowsNodeConfigOsVersion OsVersionLtsc2019 { get; } = new WindowsNodeConfigOsVersion("OS_VERSION_LTSC2019");
        /// <summary>
        /// LTSC2022 specifies to use LTSC2022 as the Windows Servercore Base Image
        /// </summary>
        public static WindowsNodeConfigOsVersion OsVersionLtsc2022 { get; } = new WindowsNodeConfigOsVersion("OS_VERSION_LTSC2022");

        public static bool operator ==(WindowsNodeConfigOsVersion left, WindowsNodeConfigOsVersion right) => left.Equals(right);
        public static bool operator !=(WindowsNodeConfigOsVersion left, WindowsNodeConfigOsVersion right) => !left.Equals(right);

        public static explicit operator string(WindowsNodeConfigOsVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WindowsNodeConfigOsVersion other && Equals(other);
        public bool Equals(WindowsNodeConfigOsVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Mode is the configuration for how to expose metadata to workloads running on the node pool.
    /// </summary>
    [EnumType]
    public readonly struct WorkloadMetadataConfigMode : IEquatable<WorkloadMetadataConfigMode>
    {
        private readonly string _value;

        private WorkloadMetadataConfigMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set.
        /// </summary>
        public static WorkloadMetadataConfigMode ModeUnspecified { get; } = new WorkloadMetadataConfigMode("MODE_UNSPECIFIED");
        /// <summary>
        /// Expose all Compute Engine metadata to pods.
        /// </summary>
        public static WorkloadMetadataConfigMode GceMetadata { get; } = new WorkloadMetadataConfigMode("GCE_METADATA");
        /// <summary>
        /// Run the GKE Metadata Server on this node. The GKE Metadata Server exposes a metadata API to workloads that is compatible with the V1 Compute Metadata APIs exposed by the Compute Engine and App Engine Metadata Servers. This feature can only be enabled if Workload Identity is enabled at the cluster level.
        /// </summary>
        public static WorkloadMetadataConfigMode GkeMetadata { get; } = new WorkloadMetadataConfigMode("GKE_METADATA");

        public static bool operator ==(WorkloadMetadataConfigMode left, WorkloadMetadataConfigMode right) => left.Equals(right);
        public static bool operator !=(WorkloadMetadataConfigMode left, WorkloadMetadataConfigMode right) => !left.Equals(right);

        public static explicit operator string(WorkloadMetadataConfigMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WorkloadMetadataConfigMode other && Equals(other);
        public bool Equals(WorkloadMetadataConfigMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

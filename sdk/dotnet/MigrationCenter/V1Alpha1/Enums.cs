// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.MigrationCenter.V1Alpha1
{
    /// <summary>
    /// License type to consider when calculating costs for virtual machine insights and recommendations. If unspecified, costs are calculated based on the default licensing plan.
    /// </summary>
    [EnumType]
    public readonly struct ComputeEnginePreferencesLicenseType : IEquatable<ComputeEnginePreferencesLicenseType>
    {
        private readonly string _value;

        private ComputeEnginePreferencesLicenseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified (default value).
        /// </summary>
        public static ComputeEnginePreferencesLicenseType LicenseTypeUnspecified { get; } = new ComputeEnginePreferencesLicenseType("LICENSE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Default Google Cloud licensing plan. Licensing is charged per usage. This a good value to start with.
        /// </summary>
        public static ComputeEnginePreferencesLicenseType LicenseTypeDefault { get; } = new ComputeEnginePreferencesLicenseType("LICENSE_TYPE_DEFAULT");
        /// <summary>
        /// Bring-your-own-license (BYOL) plan. User provides the OS license.
        /// </summary>
        public static ComputeEnginePreferencesLicenseType LicenseTypeBringYourOwnLicense { get; } = new ComputeEnginePreferencesLicenseType("LICENSE_TYPE_BRING_YOUR_OWN_LICENSE");

        public static bool operator ==(ComputeEnginePreferencesLicenseType left, ComputeEnginePreferencesLicenseType right) => left.Equals(right);
        public static bool operator !=(ComputeEnginePreferencesLicenseType left, ComputeEnginePreferencesLicenseType right) => !left.Equals(right);

        public static explicit operator string(ComputeEnginePreferencesLicenseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeEnginePreferencesLicenseType other && Equals(other);
        public bool Equals(ComputeEnginePreferencesLicenseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Persistent disk type to use. If unspecified (default), all types are considered, based on available usage data.
    /// </summary>
    [EnumType]
    public readonly struct ComputeEnginePreferencesPersistentDiskType : IEquatable<ComputeEnginePreferencesPersistentDiskType>
    {
        private readonly string _value;

        private ComputeEnginePreferencesPersistentDiskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified (default value). Selecting this value allows the system to use any disk type according to reported usage. This a good value to start with.
        /// </summary>
        public static ComputeEnginePreferencesPersistentDiskType PersistentDiskTypeUnspecified { get; } = new ComputeEnginePreferencesPersistentDiskType("PERSISTENT_DISK_TYPE_UNSPECIFIED");
        /// <summary>
        /// Standard HDD Persistent Disk.
        /// </summary>
        public static ComputeEnginePreferencesPersistentDiskType PersistentDiskTypeStandard { get; } = new ComputeEnginePreferencesPersistentDiskType("PERSISTENT_DISK_TYPE_STANDARD");
        /// <summary>
        /// Balanced Persistent Disk.
        /// </summary>
        public static ComputeEnginePreferencesPersistentDiskType PersistentDiskTypeBalanced { get; } = new ComputeEnginePreferencesPersistentDiskType("PERSISTENT_DISK_TYPE_BALANCED");
        /// <summary>
        /// SSD Persistent Disk.
        /// </summary>
        public static ComputeEnginePreferencesPersistentDiskType PersistentDiskTypeSsd { get; } = new ComputeEnginePreferencesPersistentDiskType("PERSISTENT_DISK_TYPE_SSD");

        public static bool operator ==(ComputeEnginePreferencesPersistentDiskType left, ComputeEnginePreferencesPersistentDiskType right) => left.Equals(right);
        public static bool operator !=(ComputeEnginePreferencesPersistentDiskType left, ComputeEnginePreferencesPersistentDiskType right) => !left.Equals(right);

        public static explicit operator string(ComputeEnginePreferencesPersistentDiskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeEnginePreferencesPersistentDiskType other && Equals(other);
        public bool Equals(ComputeEnginePreferencesPersistentDiskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The import job format.
    /// </summary>
    [EnumType]
    public readonly struct GCSPayloadInfoFormat : IEquatable<GCSPayloadInfoFormat>
    {
        private readonly string _value;

        private GCSPayloadInfoFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static GCSPayloadInfoFormat ImportJobFormatUnspecified { get; } = new GCSPayloadInfoFormat("IMPORT_JOB_FORMAT_UNSPECIFIED");
        /// <summary>
        /// Configuration management DB format.
        /// </summary>
        public static GCSPayloadInfoFormat ImportJobFormatCmdb { get; } = new GCSPayloadInfoFormat("IMPORT_JOB_FORMAT_CMDB");
        /// <summary>
        /// RVTools format (XLSX).
        /// </summary>
        public static GCSPayloadInfoFormat ImportJobFormatRvtoolsXlsx { get; } = new GCSPayloadInfoFormat("IMPORT_JOB_FORMAT_RVTOOLS_XLSX");
        /// <summary>
        /// RVTools format (CSV).
        /// </summary>
        public static GCSPayloadInfoFormat ImportJobFormatRvtoolsCsv { get; } = new GCSPayloadInfoFormat("IMPORT_JOB_FORMAT_RVTOOLS_CSV");
        /// <summary>
        /// CSV format exported from AWS using the AWS collection script.
        /// </summary>
        public static GCSPayloadInfoFormat ImportJobFormatExportedAwsCsv { get; } = new GCSPayloadInfoFormat("IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV");
        /// <summary>
        /// CSV format exported from Azure using the Azure collection script.
        /// </summary>
        public static GCSPayloadInfoFormat ImportJobFormatExportedAzureCsv { get; } = new GCSPayloadInfoFormat("IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV");
        /// <summary>
        /// CSV format created manually. For more information, see Manually create and upload data tables.
        /// </summary>
        public static GCSPayloadInfoFormat ImportJobFormatManualCsv { get; } = new GCSPayloadInfoFormat("IMPORT_JOB_FORMAT_MANUAL_CSV");

        public static bool operator ==(GCSPayloadInfoFormat left, GCSPayloadInfoFormat right) => left.Equals(right);
        public static bool operator !=(GCSPayloadInfoFormat left, GCSPayloadInfoFormat right) => !left.Equals(right);

        public static explicit operator string(GCSPayloadInfoFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GCSPayloadInfoFormat other && Equals(other);
        public bool Equals(GCSPayloadInfoFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The payload format.
    /// </summary>
    [EnumType]
    public readonly struct ImportDataFileFormat : IEquatable<ImportDataFileFormat>
    {
        private readonly string _value;

        private ImportDataFileFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static ImportDataFileFormat ImportJobFormatUnspecified { get; } = new ImportDataFileFormat("IMPORT_JOB_FORMAT_UNSPECIFIED");
        /// <summary>
        /// Configuration management DB format.
        /// </summary>
        public static ImportDataFileFormat ImportJobFormatCmdb { get; } = new ImportDataFileFormat("IMPORT_JOB_FORMAT_CMDB");
        /// <summary>
        /// RVTools format (XLSX).
        /// </summary>
        public static ImportDataFileFormat ImportJobFormatRvtoolsXlsx { get; } = new ImportDataFileFormat("IMPORT_JOB_FORMAT_RVTOOLS_XLSX");
        /// <summary>
        /// RVTools format (CSV).
        /// </summary>
        public static ImportDataFileFormat ImportJobFormatRvtoolsCsv { get; } = new ImportDataFileFormat("IMPORT_JOB_FORMAT_RVTOOLS_CSV");
        /// <summary>
        /// CSV format exported from AWS using the AWS collection script.
        /// </summary>
        public static ImportDataFileFormat ImportJobFormatExportedAwsCsv { get; } = new ImportDataFileFormat("IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV");
        /// <summary>
        /// CSV format exported from Azure using the Azure collection script.
        /// </summary>
        public static ImportDataFileFormat ImportJobFormatExportedAzureCsv { get; } = new ImportDataFileFormat("IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV");
        /// <summary>
        /// CSV format created manually. For more information, see Manually create and upload data tables.
        /// </summary>
        public static ImportDataFileFormat ImportJobFormatManualCsv { get; } = new ImportDataFileFormat("IMPORT_JOB_FORMAT_MANUAL_CSV");

        public static bool operator ==(ImportDataFileFormat left, ImportDataFileFormat right) => left.Equals(right);
        public static bool operator !=(ImportDataFileFormat left, ImportDataFileFormat right) => !left.Equals(right);

        public static explicit operator string(ImportDataFileFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImportDataFileFormat other && Equals(other);
        public bool Equals(ImportDataFileFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The import job format.
    /// </summary>
    [EnumType]
    public readonly struct InlinePayloadInfoFormat : IEquatable<InlinePayloadInfoFormat>
    {
        private readonly string _value;

        private InlinePayloadInfoFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static InlinePayloadInfoFormat ImportJobFormatUnspecified { get; } = new InlinePayloadInfoFormat("IMPORT_JOB_FORMAT_UNSPECIFIED");
        /// <summary>
        /// Configuration management DB format.
        /// </summary>
        public static InlinePayloadInfoFormat ImportJobFormatCmdb { get; } = new InlinePayloadInfoFormat("IMPORT_JOB_FORMAT_CMDB");
        /// <summary>
        /// RVTools format (XLSX).
        /// </summary>
        public static InlinePayloadInfoFormat ImportJobFormatRvtoolsXlsx { get; } = new InlinePayloadInfoFormat("IMPORT_JOB_FORMAT_RVTOOLS_XLSX");
        /// <summary>
        /// RVTools format (CSV).
        /// </summary>
        public static InlinePayloadInfoFormat ImportJobFormatRvtoolsCsv { get; } = new InlinePayloadInfoFormat("IMPORT_JOB_FORMAT_RVTOOLS_CSV");
        /// <summary>
        /// CSV format exported from AWS using the AWS collection script.
        /// </summary>
        public static InlinePayloadInfoFormat ImportJobFormatExportedAwsCsv { get; } = new InlinePayloadInfoFormat("IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV");
        /// <summary>
        /// CSV format exported from Azure using the Azure collection script.
        /// </summary>
        public static InlinePayloadInfoFormat ImportJobFormatExportedAzureCsv { get; } = new InlinePayloadInfoFormat("IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV");
        /// <summary>
        /// CSV format created manually. For more information, see Manually create and upload data tables.
        /// </summary>
        public static InlinePayloadInfoFormat ImportJobFormatManualCsv { get; } = new InlinePayloadInfoFormat("IMPORT_JOB_FORMAT_MANUAL_CSV");

        public static bool operator ==(InlinePayloadInfoFormat left, InlinePayloadInfoFormat right) => left.Equals(right);
        public static bool operator !=(InlinePayloadInfoFormat left, InlinePayloadInfoFormat right) => !left.Equals(right);

        public static explicit operator string(InlinePayloadInfoFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InlinePayloadInfoFormat other && Equals(other);
        public bool Equals(InlinePayloadInfoFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Report creation state.
    /// </summary>
    [EnumType]
    public readonly struct ReportState : IEquatable<ReportState>
    {
        private readonly string _value;

        private ReportState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default Report creation state.
        /// </summary>
        public static ReportState StateUnspecified { get; } = new ReportState("STATE_UNSPECIFIED");
        /// <summary>
        /// Creating Report.
        /// </summary>
        public static ReportState Pending { get; } = new ReportState("PENDING");
        /// <summary>
        /// Successfully created Report.
        /// </summary>
        public static ReportState Succeeded { get; } = new ReportState("SUCCEEDED");
        /// <summary>
        /// Failed to create Report.
        /// </summary>
        public static ReportState Failed { get; } = new ReportState("FAILED");

        public static bool operator ==(ReportState left, ReportState right) => left.Equals(right);
        public static bool operator !=(ReportState left, ReportState right) => !left.Equals(right);

        public static explicit operator string(ReportState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReportState other && Equals(other);
        public bool Equals(ReportState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Report type.
    /// </summary>
    [EnumType]
    public readonly struct ReportType : IEquatable<ReportType>
    {
        private readonly string _value;

        private ReportType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default Report type.
        /// </summary>
        public static ReportType TypeUnspecified { get; } = new ReportType("TYPE_UNSPECIFIED");
        /// <summary>
        /// Total cost of ownership Report type.
        /// </summary>
        public static ReportType TotalCostOfOwnership { get; } = new ReportType("TOTAL_COST_OF_OWNERSHIP");

        public static bool operator ==(ReportType left, ReportType right) => left.Equals(right);
        public static bool operator !=(ReportType left, ReportType right) => !left.Equals(right);

        public static explicit operator string(ReportType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReportType other && Equals(other);
        public bool Equals(ReportType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Data source type.
    /// </summary>
    [EnumType]
    public readonly struct SourceType : IEquatable<SourceType>
    {
        private readonly string _value;

        private SourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified
        /// </summary>
        public static SourceType SourceTypeUnknown { get; } = new SourceType("SOURCE_TYPE_UNKNOWN");
        /// <summary>
        /// Manually uploaded file (e.g. CSV)
        /// </summary>
        public static SourceType SourceTypeUpload { get; } = new SourceType("SOURCE_TYPE_UPLOAD");
        /// <summary>
        /// Guest-level info
        /// </summary>
        public static SourceType SourceTypeGuestOsScan { get; } = new SourceType("SOURCE_TYPE_GUEST_OS_SCAN");
        /// <summary>
        /// Inventory-level scan
        /// </summary>
        public static SourceType SourceTypeInventoryScan { get; } = new SourceType("SOURCE_TYPE_INVENTORY_SCAN");
        /// <summary>
        /// Third-party owned sources.
        /// </summary>
        public static SourceType SourceTypeCustom { get; } = new SourceType("SOURCE_TYPE_CUSTOM");

        public static bool operator ==(SourceType left, SourceType right) => left.Equals(right);
        public static bool operator !=(SourceType left, SourceType right) => !left.Equals(right);

        public static explicit operator string(SourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SourceType other && Equals(other);
        public bool Equals(SourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Commitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachinePreferencesCommitmentPlan : IEquatable<VirtualMachinePreferencesCommitmentPlan>
    {
        private readonly string _value;

        private VirtualMachinePreferencesCommitmentPlan(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified commitment plan.
        /// </summary>
        public static VirtualMachinePreferencesCommitmentPlan CommitmentPlanUnspecified { get; } = new VirtualMachinePreferencesCommitmentPlan("COMMITMENT_PLAN_UNSPECIFIED");
        /// <summary>
        /// No commitment plan.
        /// </summary>
        public static VirtualMachinePreferencesCommitmentPlan CommitmentPlanNone { get; } = new VirtualMachinePreferencesCommitmentPlan("COMMITMENT_PLAN_NONE");
        /// <summary>
        /// 1 year commitment.
        /// </summary>
        public static VirtualMachinePreferencesCommitmentPlan CommitmentPlanOneYear { get; } = new VirtualMachinePreferencesCommitmentPlan("COMMITMENT_PLAN_ONE_YEAR");
        /// <summary>
        /// 3 years commitment.
        /// </summary>
        public static VirtualMachinePreferencesCommitmentPlan CommitmentPlanThreeYears { get; } = new VirtualMachinePreferencesCommitmentPlan("COMMITMENT_PLAN_THREE_YEARS");

        public static bool operator ==(VirtualMachinePreferencesCommitmentPlan left, VirtualMachinePreferencesCommitmentPlan right) => left.Equals(right);
        public static bool operator !=(VirtualMachinePreferencesCommitmentPlan left, VirtualMachinePreferencesCommitmentPlan right) => !left.Equals(right);

        public static explicit operator string(VirtualMachinePreferencesCommitmentPlan value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachinePreferencesCommitmentPlan other && Equals(other);
        public bool Equals(VirtualMachinePreferencesCommitmentPlan other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sizing optimization strategy specifies the preferred strategy used when extrapolating usage data to calculate insights and recommendations for a virtual machine. If you are unsure which value to set, a moderate sizing optimization strategy is often a good value to start with.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachinePreferencesSizingOptimizationStrategy : IEquatable<VirtualMachinePreferencesSizingOptimizationStrategy>
    {
        private readonly string _value;

        private VirtualMachinePreferencesSizingOptimizationStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified (default value).
        /// </summary>
        public static VirtualMachinePreferencesSizingOptimizationStrategy SizingOptimizationStrategyUnspecified { get; } = new VirtualMachinePreferencesSizingOptimizationStrategy("SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED");
        /// <summary>
        /// No optimization applied. Virtual machine sizing matches as closely as possible the machine shape on the source site, not considering any actual performance data.
        /// </summary>
        public static VirtualMachinePreferencesSizingOptimizationStrategy SizingOptimizationStrategySameAsSource { get; } = new VirtualMachinePreferencesSizingOptimizationStrategy("SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE");
        /// <summary>
        /// Virtual machine sizing will match the reported usage and shape, with some slack. This a good value to start with.
        /// </summary>
        public static VirtualMachinePreferencesSizingOptimizationStrategy SizingOptimizationStrategyModerate { get; } = new VirtualMachinePreferencesSizingOptimizationStrategy("SIZING_OPTIMIZATION_STRATEGY_MODERATE");
        /// <summary>
        /// Virtual machine sizing will match the reported usage, with little slack. Using this option can help reduce costs.
        /// </summary>
        public static VirtualMachinePreferencesSizingOptimizationStrategy SizingOptimizationStrategyAggressive { get; } = new VirtualMachinePreferencesSizingOptimizationStrategy("SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE");

        public static bool operator ==(VirtualMachinePreferencesSizingOptimizationStrategy left, VirtualMachinePreferencesSizingOptimizationStrategy right) => left.Equals(right);
        public static bool operator !=(VirtualMachinePreferencesSizingOptimizationStrategy left, VirtualMachinePreferencesSizingOptimizationStrategy right) => !left.Equals(right);

        public static explicit operator string(VirtualMachinePreferencesSizingOptimizationStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachinePreferencesSizingOptimizationStrategy other && Equals(other);
        public bool Equals(VirtualMachinePreferencesSizingOptimizationStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

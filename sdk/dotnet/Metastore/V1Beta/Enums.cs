// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Metastore.V1Beta
{
    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct AuditLogConfigLogType : IEquatable<AuditLogConfigLogType>
    {
        private readonly string _value;

        private AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default case. Should never be this.
        /// </summary>
        public static AuditLogConfigLogType LogTypeUnspecified { get; } = new AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");
        /// <summary>
        /// Admin reads. Example: CloudIAM getIamPolicy
        /// </summary>
        public static AuditLogConfigLogType AdminRead { get; } = new AuditLogConfigLogType("ADMIN_READ");
        /// <summary>
        /// Data writes. Example: CloudSQL Users create
        /// </summary>
        public static AuditLogConfigLogType DataWrite { get; } = new AuditLogConfigLogType("DATA_WRITE");
        /// <summary>
        /// Data reads. Example: CloudSQL Users list
        /// </summary>
        public static AuditLogConfigLogType DataRead { get; } = new AuditLogConfigLogType("DATA_READ");

        public static bool operator ==(AuditLogConfigLogType left, AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(AuditLogConfigLogType left, AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuditLogConfigLogType other && Equals(other);
        public bool Equals(AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the backend metastore.
    /// </summary>
    [EnumType]
    public readonly struct BackendMetastoreMetastoreType : IEquatable<BackendMetastoreMetastoreType>
    {
        private readonly string _value;

        private BackendMetastoreMetastoreType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The metastore type is not set.
        /// </summary>
        public static BackendMetastoreMetastoreType MetastoreTypeUnspecified { get; } = new BackendMetastoreMetastoreType("METASTORE_TYPE_UNSPECIFIED");
        /// <summary>
        /// The backend metastore is Dataplex.
        /// </summary>
        public static BackendMetastoreMetastoreType Dataplex { get; } = new BackendMetastoreMetastoreType("DATAPLEX");
        /// <summary>
        /// The backend metastore is BigQuery.
        /// </summary>
        public static BackendMetastoreMetastoreType Bigquery { get; } = new BackendMetastoreMetastoreType("BIGQUERY");
        /// <summary>
        /// The backend metastore is Dataproc Metastore.
        /// </summary>
        public static BackendMetastoreMetastoreType DataprocMetastore { get; } = new BackendMetastoreMetastoreType("DATAPROC_METASTORE");

        public static bool operator ==(BackendMetastoreMetastoreType left, BackendMetastoreMetastoreType right) => left.Equals(right);
        public static bool operator !=(BackendMetastoreMetastoreType left, BackendMetastoreMetastoreType right) => !left.Equals(right);

        public static explicit operator string(BackendMetastoreMetastoreType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendMetastoreMetastoreType other && Equals(other);
        public bool Equals(BackendMetastoreMetastoreType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the database.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseDumpDatabaseType : IEquatable<DatabaseDumpDatabaseType>
    {
        private readonly string _value;

        private DatabaseDumpDatabaseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The type of the source database is unknown.
        /// </summary>
        public static DatabaseDumpDatabaseType DatabaseTypeUnspecified { get; } = new DatabaseDumpDatabaseType("DATABASE_TYPE_UNSPECIFIED");
        /// <summary>
        /// The type of the source database is MySQL.
        /// </summary>
        public static DatabaseDumpDatabaseType Mysql { get; } = new DatabaseDumpDatabaseType("MYSQL");

        public static bool operator ==(DatabaseDumpDatabaseType left, DatabaseDumpDatabaseType right) => left.Equals(right);
        public static bool operator !=(DatabaseDumpDatabaseType left, DatabaseDumpDatabaseType right) => !left.Equals(right);

        public static explicit operator string(DatabaseDumpDatabaseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseDumpDatabaseType other && Equals(other);
        public bool Equals(DatabaseDumpDatabaseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The type of the database dump. If unspecified, defaults to MYSQL.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseDumpType : IEquatable<DatabaseDumpType>
    {
        private readonly string _value;

        private DatabaseDumpType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The type of the database dump is unknown.
        /// </summary>
        public static DatabaseDumpType TypeUnspecified { get; } = new DatabaseDumpType("TYPE_UNSPECIFIED");
        /// <summary>
        /// Database dump is a MySQL dump file.
        /// </summary>
        public static DatabaseDumpType Mysql { get; } = new DatabaseDumpType("MYSQL");
        /// <summary>
        /// Database dump contains Avro files.
        /// </summary>
        public static DatabaseDumpType Avro { get; } = new DatabaseDumpType("AVRO");

        public static bool operator ==(DatabaseDumpType left, DatabaseDumpType right) => left.Equals(right);
        public static bool operator !=(DatabaseDumpType left, DatabaseDumpType right) => !left.Equals(right);

        public static explicit operator string(DatabaseDumpType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseDumpType other && Equals(other);
        public bool Equals(DatabaseDumpType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol to use for the metastore service endpoint. If unspecified, defaults to THRIFT.
    /// </summary>
    [EnumType]
    public readonly struct HiveMetastoreConfigEndpointProtocol : IEquatable<HiveMetastoreConfigEndpointProtocol>
    {
        private readonly string _value;

        private HiveMetastoreConfigEndpointProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The protocol is not set.
        /// </summary>
        public static HiveMetastoreConfigEndpointProtocol EndpointProtocolUnspecified { get; } = new HiveMetastoreConfigEndpointProtocol("ENDPOINT_PROTOCOL_UNSPECIFIED");
        /// <summary>
        /// Use the legacy Apache Thrift protocol for the metastore service endpoint.
        /// </summary>
        public static HiveMetastoreConfigEndpointProtocol Thrift { get; } = new HiveMetastoreConfigEndpointProtocol("THRIFT");
        /// <summary>
        /// Use the modernized gRPC protocol for the metastore service endpoint.
        /// </summary>
        public static HiveMetastoreConfigEndpointProtocol Grpc { get; } = new HiveMetastoreConfigEndpointProtocol("GRPC");

        public static bool operator ==(HiveMetastoreConfigEndpointProtocol left, HiveMetastoreConfigEndpointProtocol right) => left.Equals(right);
        public static bool operator !=(HiveMetastoreConfigEndpointProtocol left, HiveMetastoreConfigEndpointProtocol right) => !left.Equals(right);

        public static explicit operator string(HiveMetastoreConfigEndpointProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HiveMetastoreConfigEndpointProtocol other && Equals(other);
        public bool Equals(HiveMetastoreConfigEndpointProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The day of week, when the window starts.
    /// </summary>
    [EnumType]
    public readonly struct MaintenanceWindowDayOfWeek : IEquatable<MaintenanceWindowDayOfWeek>
    {
        private readonly string _value;

        private MaintenanceWindowDayOfWeek(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The day of the week is unspecified.
        /// </summary>
        public static MaintenanceWindowDayOfWeek DayOfWeekUnspecified { get; } = new MaintenanceWindowDayOfWeek("DAY_OF_WEEK_UNSPECIFIED");
        /// <summary>
        /// Monday
        /// </summary>
        public static MaintenanceWindowDayOfWeek Monday { get; } = new MaintenanceWindowDayOfWeek("MONDAY");
        /// <summary>
        /// Tuesday
        /// </summary>
        public static MaintenanceWindowDayOfWeek Tuesday { get; } = new MaintenanceWindowDayOfWeek("TUESDAY");
        /// <summary>
        /// Wednesday
        /// </summary>
        public static MaintenanceWindowDayOfWeek Wednesday { get; } = new MaintenanceWindowDayOfWeek("WEDNESDAY");
        /// <summary>
        /// Thursday
        /// </summary>
        public static MaintenanceWindowDayOfWeek Thursday { get; } = new MaintenanceWindowDayOfWeek("THURSDAY");
        /// <summary>
        /// Friday
        /// </summary>
        public static MaintenanceWindowDayOfWeek Friday { get; } = new MaintenanceWindowDayOfWeek("FRIDAY");
        /// <summary>
        /// Saturday
        /// </summary>
        public static MaintenanceWindowDayOfWeek Saturday { get; } = new MaintenanceWindowDayOfWeek("SATURDAY");
        /// <summary>
        /// Sunday
        /// </summary>
        public static MaintenanceWindowDayOfWeek Sunday { get; } = new MaintenanceWindowDayOfWeek("SUNDAY");

        public static bool operator ==(MaintenanceWindowDayOfWeek left, MaintenanceWindowDayOfWeek right) => left.Equals(right);
        public static bool operator !=(MaintenanceWindowDayOfWeek left, MaintenanceWindowDayOfWeek right) => !left.Equals(right);

        public static explicit operator string(MaintenanceWindowDayOfWeek value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MaintenanceWindowDayOfWeek other && Equals(other);
        public bool Equals(MaintenanceWindowDayOfWeek other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// An enum of readable instance sizes, with each instance size mapping to a float value (e.g. InstanceSize.EXTRA_SMALL = scaling_factor(0.1))
    /// </summary>
    [EnumType]
    public readonly struct ScalingConfigInstanceSize : IEquatable<ScalingConfigInstanceSize>
    {
        private readonly string _value;

        private ScalingConfigInstanceSize(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified instance size
        /// </summary>
        public static ScalingConfigInstanceSize InstanceSizeUnspecified { get; } = new ScalingConfigInstanceSize("INSTANCE_SIZE_UNSPECIFIED");
        /// <summary>
        /// Extra small instance size, maps to a scaling factor of 0.1.
        /// </summary>
        public static ScalingConfigInstanceSize ExtraSmall { get; } = new ScalingConfigInstanceSize("EXTRA_SMALL");
        /// <summary>
        /// Small instance size, maps to a scaling factor of 0.5.
        /// </summary>
        public static ScalingConfigInstanceSize Small { get; } = new ScalingConfigInstanceSize("SMALL");
        /// <summary>
        /// Medium instance size, maps to a scaling factor of 1.0.
        /// </summary>
        public static ScalingConfigInstanceSize Medium { get; } = new ScalingConfigInstanceSize("MEDIUM");
        /// <summary>
        /// Large instance size, maps to a scaling factor of 3.0.
        /// </summary>
        public static ScalingConfigInstanceSize Large { get; } = new ScalingConfigInstanceSize("LARGE");
        /// <summary>
        /// Extra large instance size, maps to a scaling factor of 6.0.
        /// </summary>
        public static ScalingConfigInstanceSize ExtraLarge { get; } = new ScalingConfigInstanceSize("EXTRA_LARGE");

        public static bool operator ==(ScalingConfigInstanceSize left, ScalingConfigInstanceSize right) => left.Equals(right);
        public static bool operator !=(ScalingConfigInstanceSize left, ScalingConfigInstanceSize right) => !left.Equals(right);

        public static explicit operator string(ScalingConfigInstanceSize value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ScalingConfigInstanceSize other && Equals(other);
        public bool Equals(ScalingConfigInstanceSize other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Immutable. The database type that the Metastore service stores its data.
    /// </summary>
    [EnumType]
    public readonly struct ServiceDatabaseType : IEquatable<ServiceDatabaseType>
    {
        private readonly string _value;

        private ServiceDatabaseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The DATABASE_TYPE is not set.
        /// </summary>
        public static ServiceDatabaseType DatabaseTypeUnspecified { get; } = new ServiceDatabaseType("DATABASE_TYPE_UNSPECIFIED");
        /// <summary>
        /// MySQL is used to persist the metastore data.
        /// </summary>
        public static ServiceDatabaseType Mysql { get; } = new ServiceDatabaseType("MYSQL");
        /// <summary>
        /// Spanner is used to persist the metastore data.
        /// </summary>
        public static ServiceDatabaseType Spanner { get; } = new ServiceDatabaseType("SPANNER");

        public static bool operator ==(ServiceDatabaseType left, ServiceDatabaseType right) => left.Equals(right);
        public static bool operator !=(ServiceDatabaseType left, ServiceDatabaseType right) => !left.Equals(right);

        public static explicit operator string(ServiceDatabaseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceDatabaseType other && Equals(other);
        public bool Equals(ServiceDatabaseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Immutable. The release channel of the service. If unspecified, defaults to STABLE.
    /// </summary>
    [EnumType]
    public readonly struct ServiceReleaseChannel : IEquatable<ServiceReleaseChannel>
    {
        private readonly string _value;

        private ServiceReleaseChannel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Release channel is not specified.
        /// </summary>
        public static ServiceReleaseChannel ReleaseChannelUnspecified { get; } = new ServiceReleaseChannel("RELEASE_CHANNEL_UNSPECIFIED");
        /// <summary>
        /// The CANARY release channel contains the newest features, which may be unstable and subject to unresolved issues with no known workarounds. Services using the CANARY release channel are not subject to any SLAs.
        /// </summary>
        public static ServiceReleaseChannel Canary { get; } = new ServiceReleaseChannel("CANARY");
        /// <summary>
        /// The STABLE release channel contains features that are considered stable and have been validated for production use.
        /// </summary>
        public static ServiceReleaseChannel Stable { get; } = new ServiceReleaseChannel("STABLE");

        public static bool operator ==(ServiceReleaseChannel left, ServiceReleaseChannel right) => left.Equals(right);
        public static bool operator !=(ServiceReleaseChannel left, ServiceReleaseChannel right) => !left.Equals(right);

        public static explicit operator string(ServiceReleaseChannel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceReleaseChannel other && Equals(other);
        public bool Equals(ServiceReleaseChannel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The tier of the service.
    /// </summary>
    [EnumType]
    public readonly struct ServiceTier : IEquatable<ServiceTier>
    {
        private readonly string _value;

        private ServiceTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The tier is not set.
        /// </summary>
        public static ServiceTier TierUnspecified { get; } = new ServiceTier("TIER_UNSPECIFIED");
        /// <summary>
        /// The developer tier provides limited scalability and no fault tolerance. Good for low-cost proof-of-concept.
        /// </summary>
        public static ServiceTier Developer { get; } = new ServiceTier("DEVELOPER");
        /// <summary>
        /// The enterprise tier provides multi-zone high availability, and sufficient scalability for enterprise-level Dataproc Metastore workloads.
        /// </summary>
        public static ServiceTier Enterprise { get; } = new ServiceTier("ENTERPRISE");

        public static bool operator ==(ServiceTier left, ServiceTier right) => left.Equals(right);
        public static bool operator !=(ServiceTier left, ServiceTier right) => !left.Equals(right);

        public static explicit operator string(ServiceTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceTier other && Equals(other);
        public bool Equals(ServiceTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The output format of the Dataproc Metastore service's logs.
    /// </summary>
    [EnumType]
    public readonly struct TelemetryConfigLogFormat : IEquatable<TelemetryConfigLogFormat>
    {
        private readonly string _value;

        private TelemetryConfigLogFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The LOG_FORMAT is not set.
        /// </summary>
        public static TelemetryConfigLogFormat LogFormatUnspecified { get; } = new TelemetryConfigLogFormat("LOG_FORMAT_UNSPECIFIED");
        /// <summary>
        /// Logging output uses the legacy textPayload format.
        /// </summary>
        public static TelemetryConfigLogFormat Legacy { get; } = new TelemetryConfigLogFormat("LEGACY");
        /// <summary>
        /// Logging output uses the jsonPayload format.
        /// </summary>
        public static TelemetryConfigLogFormat Json { get; } = new TelemetryConfigLogFormat("JSON");

        public static bool operator ==(TelemetryConfigLogFormat left, TelemetryConfigLogFormat right) => left.Equals(right);
        public static bool operator !=(TelemetryConfigLogFormat left, TelemetryConfigLogFormat right) => !left.Equals(right);

        public static explicit operator string(TelemetryConfigLogFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TelemetryConfigLogFormat other && Equals(other);
        public bool Equals(TelemetryConfigLogFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Compute.Alpha
{
    /// <summary>
    /// This signifies the networking tier used for configuring this access configuration and can only take the following values: PREMIUM, STANDARD.
    /// 
    /// If an AccessConfig is specified without a valid external IP address, an ephemeral IP will be created with this networkTier.
    /// 
    /// If an AccessConfig with a valid external IP address is specified, it must match that of the networkTier associated with the Address resource owning that IP.
    /// </summary>
    [EnumType]
    public readonly struct AccessConfigNetworkTier : IEquatable<AccessConfigNetworkTier>
    {
        private readonly string _value;

        private AccessConfigNetworkTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccessConfigNetworkTier FixedStandard { get; } = new AccessConfigNetworkTier("FIXED_STANDARD");
        public static AccessConfigNetworkTier Premium { get; } = new AccessConfigNetworkTier("PREMIUM");
        public static AccessConfigNetworkTier Select { get; } = new AccessConfigNetworkTier("SELECT");
        public static AccessConfigNetworkTier Standard { get; } = new AccessConfigNetworkTier("STANDARD");
        public static AccessConfigNetworkTier StandardOverridesFixedStandard { get; } = new AccessConfigNetworkTier("STANDARD_OVERRIDES_FIXED_STANDARD");

        public static bool operator ==(AccessConfigNetworkTier left, AccessConfigNetworkTier right) => left.Equals(right);
        public static bool operator !=(AccessConfigNetworkTier left, AccessConfigNetworkTier right) => !left.Equals(right);

        public static explicit operator string(AccessConfigNetworkTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessConfigNetworkTier other && Equals(other);
        public bool Equals(AccessConfigNetworkTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of configuration. The default and only option is ONE_TO_ONE_NAT.
    /// </summary>
    [EnumType]
    public readonly struct AccessConfigType : IEquatable<AccessConfigType>
    {
        private readonly string _value;

        private AccessConfigType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccessConfigType DirectIpv6 { get; } = new AccessConfigType("DIRECT_IPV6");
        public static AccessConfigType OneToOneNat { get; } = new AccessConfigType("ONE_TO_ONE_NAT");

        public static bool operator ==(AccessConfigType left, AccessConfigType right) => left.Equals(right);
        public static bool operator !=(AccessConfigType left, AccessConfigType right) => !left.Equals(right);

        public static explicit operator string(AccessConfigType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessConfigType other && Equals(other);
        public bool Equals(AccessConfigType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of address to reserve, either INTERNAL or EXTERNAL. If unspecified, defaults to EXTERNAL.
    /// </summary>
    [EnumType]
    public readonly struct AddressAddressType : IEquatable<AddressAddressType>
    {
        private readonly string _value;

        private AddressAddressType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AddressAddressType DnsForwarding { get; } = new AddressAddressType("DNS_FORWARDING");
        public static AddressAddressType External { get; } = new AddressAddressType("EXTERNAL");
        public static AddressAddressType Internal { get; } = new AddressAddressType("INTERNAL");
        public static AddressAddressType UnspecifiedType { get; } = new AddressAddressType("UNSPECIFIED_TYPE");

        public static bool operator ==(AddressAddressType left, AddressAddressType right) => left.Equals(right);
        public static bool operator !=(AddressAddressType left, AddressAddressType right) => !left.Equals(right);

        public static explicit operator string(AddressAddressType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AddressAddressType other && Equals(other);
        public bool Equals(AddressAddressType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP version that will be used by this address. Valid options are IPV4 or IPV6. This can only be specified for a global address.
    /// </summary>
    [EnumType]
    public readonly struct AddressIpVersion : IEquatable<AddressIpVersion>
    {
        private readonly string _value;

        private AddressIpVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AddressIpVersion Ipv4 { get; } = new AddressIpVersion("IPV4");
        public static AddressIpVersion Ipv6 { get; } = new AddressIpVersion("IPV6");
        public static AddressIpVersion UnspecifiedVersion { get; } = new AddressIpVersion("UNSPECIFIED_VERSION");

        public static bool operator ==(AddressIpVersion left, AddressIpVersion right) => left.Equals(right);
        public static bool operator !=(AddressIpVersion left, AddressIpVersion right) => !left.Equals(right);

        public static explicit operator string(AddressIpVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AddressIpVersion other && Equals(other);
        public bool Equals(AddressIpVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This signifies the networking tier used for configuring this address and can only take the following values: PREMIUM or STANDARD. Global forwarding rules can only be Premium Tier. Regional forwarding rules can be either Premium or Standard Tier. Standard Tier addresses applied to regional forwarding rules can be used with any external load balancer. Regional forwarding rules in Premium Tier can only be used with a network load balancer.
    /// 
    /// If this field is not specified, it is assumed to be PREMIUM.
    /// </summary>
    [EnumType]
    public readonly struct AddressNetworkTier : IEquatable<AddressNetworkTier>
    {
        private readonly string _value;

        private AddressNetworkTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AddressNetworkTier FixedStandard { get; } = new AddressNetworkTier("FIXED_STANDARD");
        public static AddressNetworkTier Premium { get; } = new AddressNetworkTier("PREMIUM");
        public static AddressNetworkTier Select { get; } = new AddressNetworkTier("SELECT");
        public static AddressNetworkTier Standard { get; } = new AddressNetworkTier("STANDARD");
        public static AddressNetworkTier StandardOverridesFixedStandard { get; } = new AddressNetworkTier("STANDARD_OVERRIDES_FIXED_STANDARD");

        public static bool operator ==(AddressNetworkTier left, AddressNetworkTier right) => left.Equals(right);
        public static bool operator !=(AddressNetworkTier left, AddressNetworkTier right) => !left.Equals(right);

        public static explicit operator string(AddressNetworkTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AddressNetworkTier other && Equals(other);
        public bool Equals(AddressNetworkTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The purpose of this resource, which can be one of the following values:  
    /// - `GCE_ENDPOINT` for addresses that are used by VM instances, alias IP ranges, internal load balancers, and similar resources. 
    /// - `DNS_RESOLVER` for a DNS resolver address in a subnetwork 
    /// - `VPC_PEERING` for addresses that are reserved for VPC peer networks. 
    /// - `NAT_AUTO` for addresses that are external IP addresses automatically reserved for Cloud NAT. 
    /// - `IPSEC_INTERCONNECT` for addresses created from a private IP range that are reserved for a VLAN attachment in an IPsec-encrypted Cloud Interconnect configuration. These addresses are regional resources.
    /// </summary>
    [EnumType]
    public readonly struct AddressPurpose : IEquatable<AddressPurpose>
    {
        private readonly string _value;

        private AddressPurpose(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AddressPurpose DnsResolver { get; } = new AddressPurpose("DNS_RESOLVER");
        public static AddressPurpose GceEndpoint { get; } = new AddressPurpose("GCE_ENDPOINT");
        public static AddressPurpose IpsecInterconnect { get; } = new AddressPurpose("IPSEC_INTERCONNECT");
        public static AddressPurpose NatAuto { get; } = new AddressPurpose("NAT_AUTO");
        public static AddressPurpose PrivateServiceConnect { get; } = new AddressPurpose("PRIVATE_SERVICE_CONNECT");
        public static AddressPurpose PscProducerNatRange { get; } = new AddressPurpose("PSC_PRODUCER_NAT_RANGE");
        public static AddressPurpose SharedLoadbalancerVip { get; } = new AddressPurpose("SHARED_LOADBALANCER_VIP");
        public static AddressPurpose VpcPeering { get; } = new AddressPurpose("VPC_PEERING");

        public static bool operator ==(AddressPurpose left, AddressPurpose right) => left.Equals(right);
        public static bool operator !=(AddressPurpose left, AddressPurpose right) => !left.Equals(right);

        public static explicit operator string(AddressPurpose value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AddressPurpose other && Equals(other);
        public bool Equals(AddressPurpose other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the address, which can be one of RESERVING, RESERVED, or IN_USE. An address that is RESERVING is currently in the process of being reserved. A RESERVED address is currently reserved and available to use. An IN_USE address is currently being used by another resource and is not available.
    /// </summary>
    [EnumType]
    public readonly struct AddressStatus : IEquatable<AddressStatus>
    {
        private readonly string _value;

        private AddressStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AddressStatus InUse { get; } = new AddressStatus("IN_USE");
        public static AddressStatus Reserved { get; } = new AddressStatus("RESERVED");
        public static AddressStatus Reserving { get; } = new AddressStatus("RESERVING");

        public static bool operator ==(AddressStatus left, AddressStatus right) => left.Equals(right);
        public static bool operator !=(AddressStatus left, AddressStatus right) => !left.Equals(right);

        public static explicit operator string(AddressStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AddressStatus other && Equals(other);
        public bool Equals(AddressStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of sharing for this shared-reservation
    /// </summary>
    [EnumType]
    public readonly struct AllocationShareSettingsShareType : IEquatable<AllocationShareSettingsShareType>
    {
        private readonly string _value;

        private AllocationShareSettingsShareType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AllocationShareSettingsShareType Organization { get; } = new AllocationShareSettingsShareType("ORGANIZATION");
        public static AllocationShareSettingsShareType ShareTypeUnspecified { get; } = new AllocationShareSettingsShareType("SHARE_TYPE_UNSPECIFIED");
        public static AllocationShareSettingsShareType SpecificProjects { get; } = new AllocationShareSettingsShareType("SPECIFIC_PROJECTS");

        public static bool operator ==(AllocationShareSettingsShareType left, AllocationShareSettingsShareType right) => left.Equals(right);
        public static bool operator !=(AllocationShareSettingsShareType left, AllocationShareSettingsShareType right) => !left.Equals(right);

        public static explicit operator string(AllocationShareSettingsShareType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AllocationShareSettingsShareType other && Equals(other);
        public bool Equals(AllocationShareSettingsShareType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI. For performance characteristics of SCSI over NVMe, see Local SSD performance.
    /// </summary>
    [EnumType]
    public readonly struct AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface : IEquatable<AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface>
    {
        private readonly string _value;

        private AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface Nvdimm { get; } = new AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface("NVDIMM");
        public static AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface Nvme { get; } = new AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface("NVME");
        public static AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface Scsi { get; } = new AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface("SCSI");

        public static bool operator ==(AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface left, AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface right) => left.Equals(right);
        public static bool operator !=(AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface left, AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface right) => !left.Equals(right);

        public static explicit operator string(AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface other && Equals(other);
        public bool Equals(AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether this VM may be a stable fleet VM. Setting this to "Periodic" designates this VM as a Stable Fleet VM.
    /// 
    /// See go/stable-fleet-ug for more details.
    /// </summary>
    [EnumType]
    public readonly struct AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval : IEquatable<AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval>
    {
        private readonly string _value;

        private AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval Periodic { get; } = new AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval("PERIODIC");

        public static bool operator ==(AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval left, AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval right) => left.Equals(right);
        public static bool operator !=(AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval left, AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval right) => !left.Equals(right);

        public static explicit operator string(AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval other && Equals(other);
        public bool Equals(AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies which action to take on instance update with this disk. Default is to use the existing disk.
    /// </summary>
    [EnumType]
    public readonly struct AttachedDiskInitializeParamsOnUpdateAction : IEquatable<AttachedDiskInitializeParamsOnUpdateAction>
    {
        private readonly string _value;

        private AttachedDiskInitializeParamsOnUpdateAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AttachedDiskInitializeParamsOnUpdateAction RecreateDisk { get; } = new AttachedDiskInitializeParamsOnUpdateAction("RECREATE_DISK");
        public static AttachedDiskInitializeParamsOnUpdateAction RecreateDiskIfSourceChanged { get; } = new AttachedDiskInitializeParamsOnUpdateAction("RECREATE_DISK_IF_SOURCE_CHANGED");
        public static AttachedDiskInitializeParamsOnUpdateAction UseExistingDisk { get; } = new AttachedDiskInitializeParamsOnUpdateAction("USE_EXISTING_DISK");

        public static bool operator ==(AttachedDiskInitializeParamsOnUpdateAction left, AttachedDiskInitializeParamsOnUpdateAction right) => left.Equals(right);
        public static bool operator !=(AttachedDiskInitializeParamsOnUpdateAction left, AttachedDiskInitializeParamsOnUpdateAction right) => !left.Equals(right);

        public static explicit operator string(AttachedDiskInitializeParamsOnUpdateAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AttachedDiskInitializeParamsOnUpdateAction other && Equals(other);
        public bool Equals(AttachedDiskInitializeParamsOnUpdateAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI and the request will fail if you attempt to attach a persistent disk in any other format than SCSI. Local SSDs can use either NVME or SCSI. For performance characteristics of SCSI over NVMe, see Local SSD performance.
    /// </summary>
    [EnumType]
    public readonly struct AttachedDiskInterface : IEquatable<AttachedDiskInterface>
    {
        private readonly string _value;

        private AttachedDiskInterface(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AttachedDiskInterface Nvdimm { get; } = new AttachedDiskInterface("NVDIMM");
        public static AttachedDiskInterface Nvme { get; } = new AttachedDiskInterface("NVME");
        public static AttachedDiskInterface Scsi { get; } = new AttachedDiskInterface("SCSI");

        public static bool operator ==(AttachedDiskInterface left, AttachedDiskInterface right) => left.Equals(right);
        public static bool operator !=(AttachedDiskInterface left, AttachedDiskInterface right) => !left.Equals(right);

        public static explicit operator string(AttachedDiskInterface value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AttachedDiskInterface other && Equals(other);
        public bool Equals(AttachedDiskInterface other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If not specified, the default is to attach the disk in READ_WRITE mode.
    /// </summary>
    [EnumType]
    public readonly struct AttachedDiskMode : IEquatable<AttachedDiskMode>
    {
        private readonly string _value;

        private AttachedDiskMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AttachedDiskMode ReadOnly { get; } = new AttachedDiskMode("READ_ONLY");
        public static AttachedDiskMode ReadWrite { get; } = new AttachedDiskMode("READ_WRITE");

        public static bool operator ==(AttachedDiskMode left, AttachedDiskMode right) => left.Equals(right);
        public static bool operator !=(AttachedDiskMode left, AttachedDiskMode right) => !left.Equals(right);

        public static explicit operator string(AttachedDiskMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AttachedDiskMode other && Equals(other);
        public bool Equals(AttachedDiskMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// For LocalSSD disks on VM Instances in STOPPED or SUSPENDED state, this field is set to PRESERVED if the LocalSSD data has been saved to a persistent location by customer request. (see the discard_local_ssd option on Stop/Suspend). Read-only in the api.
    /// </summary>
    [EnumType]
    public readonly struct AttachedDiskSavedState : IEquatable<AttachedDiskSavedState>
    {
        private readonly string _value;

        private AttachedDiskSavedState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AttachedDiskSavedState DiskSavedStateUnspecified { get; } = new AttachedDiskSavedState("DISK_SAVED_STATE_UNSPECIFIED");
        public static AttachedDiskSavedState Preserved { get; } = new AttachedDiskSavedState("PRESERVED");

        public static bool operator ==(AttachedDiskSavedState left, AttachedDiskSavedState right) => left.Equals(right);
        public static bool operator !=(AttachedDiskSavedState left, AttachedDiskSavedState right) => !left.Equals(right);

        public static explicit operator string(AttachedDiskSavedState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AttachedDiskSavedState other && Equals(other);
        public bool Equals(AttachedDiskSavedState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of the disk, either SCRATCH or PERSISTENT. If not specified, the default is PERSISTENT.
    /// </summary>
    [EnumType]
    public readonly struct AttachedDiskType : IEquatable<AttachedDiskType>
    {
        private readonly string _value;

        private AttachedDiskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AttachedDiskType Persistent { get; } = new AttachedDiskType("PERSISTENT");
        public static AttachedDiskType Scratch { get; } = new AttachedDiskType("SCRATCH");

        public static bool operator ==(AttachedDiskType left, AttachedDiskType right) => left.Equals(right);
        public static bool operator !=(AttachedDiskType left, AttachedDiskType right) => !left.Equals(right);

        public static explicit operator string(AttachedDiskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AttachedDiskType other && Equals(other);
        public bool Equals(AttachedDiskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct AuditLogConfigLogType : IEquatable<AuditLogConfigLogType>
    {
        private readonly string _value;

        private AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AuditLogConfigLogType AdminRead { get; } = new AuditLogConfigLogType("ADMIN_READ");
        public static AuditLogConfigLogType DataRead { get; } = new AuditLogConfigLogType("DATA_READ");
        public static AuditLogConfigLogType DataWrite { get; } = new AuditLogConfigLogType("DATA_WRITE");
        public static AuditLogConfigLogType LogTypeUnspecified { get; } = new AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");

        public static bool operator ==(AuditLogConfigLogType left, AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(AuditLogConfigLogType left, AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuditLogConfigLogType other && Equals(other);
        public bool Equals(AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the permission that was checked.
    /// </summary>
    [EnumType]
    public readonly struct AuthorizationLoggingOptionsPermissionType : IEquatable<AuthorizationLoggingOptionsPermissionType>
    {
        private readonly string _value;

        private AuthorizationLoggingOptionsPermissionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AuthorizationLoggingOptionsPermissionType AdminRead { get; } = new AuthorizationLoggingOptionsPermissionType("ADMIN_READ");
        public static AuthorizationLoggingOptionsPermissionType AdminWrite { get; } = new AuthorizationLoggingOptionsPermissionType("ADMIN_WRITE");
        public static AuthorizationLoggingOptionsPermissionType DataRead { get; } = new AuthorizationLoggingOptionsPermissionType("DATA_READ");
        public static AuthorizationLoggingOptionsPermissionType DataWrite { get; } = new AuthorizationLoggingOptionsPermissionType("DATA_WRITE");
        public static AuthorizationLoggingOptionsPermissionType PermissionTypeUnspecified { get; } = new AuthorizationLoggingOptionsPermissionType("PERMISSION_TYPE_UNSPECIFIED");

        public static bool operator ==(AuthorizationLoggingOptionsPermissionType left, AuthorizationLoggingOptionsPermissionType right) => left.Equals(right);
        public static bool operator !=(AuthorizationLoggingOptionsPermissionType left, AuthorizationLoggingOptionsPermissionType right) => !left.Equals(right);

        public static explicit operator string(AuthorizationLoggingOptionsPermissionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuthorizationLoggingOptionsPermissionType other && Equals(other);
        public bool Equals(AuthorizationLoggingOptionsPermissionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the autoscaler configuration. Current set of possible values:  
    /// - PENDING: Autoscaler backend hasn't read new/updated configuration. 
    /// - DELETING: Configuration is being deleted. 
    /// - ACTIVE: Configuration is acknowledged to be effective. Some warnings might be present in the statusDetails field. 
    /// - ERROR: Configuration has errors. Actionable for users. Details are present in the statusDetails field.  New values might be added in the future.
    /// </summary>
    [EnumType]
    public readonly struct AutoscalerStatus : IEquatable<AutoscalerStatus>
    {
        private readonly string _value;

        private AutoscalerStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AutoscalerStatus Active { get; } = new AutoscalerStatus("ACTIVE");
        public static AutoscalerStatus Deleting { get; } = new AutoscalerStatus("DELETING");
        public static AutoscalerStatus Error { get; } = new AutoscalerStatus("ERROR");
        public static AutoscalerStatus Pending { get; } = new AutoscalerStatus("PENDING");

        public static bool operator ==(AutoscalerStatus left, AutoscalerStatus right) => left.Equals(right);
        public static bool operator !=(AutoscalerStatus left, AutoscalerStatus right) => !left.Equals(right);

        public static explicit operator string(AutoscalerStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoscalerStatus other && Equals(other);
        public bool Equals(AutoscalerStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of error, warning, or notice returned. Current set of possible values:  
    /// - ALL_INSTANCES_UNHEALTHY (WARNING): All instances in the instance group are unhealthy (not in RUNNING state). 
    /// - BACKEND_SERVICE_DOES_NOT_EXIST (ERROR): There is no backend service attached to the instance group. 
    /// - CAPPED_AT_MAX_NUM_REPLICAS (WARNING): Autoscaler recommends a size greater than maxNumReplicas. 
    /// - CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE (WARNING): The custom metric samples are not exported often enough to be a credible base for autoscaling. 
    /// - CUSTOM_METRIC_INVALID (ERROR): The custom metric that was specified does not exist or does not have the necessary labels. 
    /// - MIN_EQUALS_MAX (WARNING): The minNumReplicas is equal to maxNumReplicas. This means the autoscaler cannot add or remove instances from the instance group. 
    /// - MISSING_CUSTOM_METRIC_DATA_POINTS (WARNING): The autoscaler did not receive any data from the custom metric configured for autoscaling. 
    /// - MISSING_LOAD_BALANCING_DATA_POINTS (WARNING): The autoscaler is configured to scale based on a load balancing signal but the instance group has not received any requests from the load balancer. 
    /// - MODE_OFF (WARNING): Autoscaling is turned off. The number of instances in the group won't change automatically. The autoscaling configuration is preserved. 
    /// - MODE_ONLY_UP (WARNING): Autoscaling is in the "Autoscale only out" mode. The autoscaler can add instances but not remove any. 
    /// - MORE_THAN_ONE_BACKEND_SERVICE (ERROR): The instance group cannot be autoscaled because it has more than one backend service attached to it. 
    /// - NOT_ENOUGH_QUOTA_AVAILABLE (ERROR): There is insufficient quota for the necessary resources, such as CPU or number of instances. 
    /// - REGION_RESOURCE_STOCKOUT (ERROR): Shown only for regional autoscalers: there is a resource stockout in the chosen region. 
    /// - SCALING_TARGET_DOES_NOT_EXIST (ERROR): The target to be scaled does not exist. 
    /// - UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION (ERROR): Autoscaling does not work with an HTTP/S load balancer that has been configured for maxRate. 
    /// - ZONE_RESOURCE_STOCKOUT (ERROR): For zonal autoscalers: there is a resource stockout in the chosen zone. For regional autoscalers: in at least one of the zones you're using there is a resource stockout.  New values might be added in the future. Some of the values might not be available in all API versions.
    /// </summary>
    [EnumType]
    public readonly struct AutoscalerStatusDetailsType : IEquatable<AutoscalerStatusDetailsType>
    {
        private readonly string _value;

        private AutoscalerStatusDetailsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AutoscalerStatusDetailsType AllInstancesUnhealthy { get; } = new AutoscalerStatusDetailsType("ALL_INSTANCES_UNHEALTHY");
        public static AutoscalerStatusDetailsType BackendServiceDoesNotExist { get; } = new AutoscalerStatusDetailsType("BACKEND_SERVICE_DOES_NOT_EXIST");
        public static AutoscalerStatusDetailsType CappedAtMaxNumReplicas { get; } = new AutoscalerStatusDetailsType("CAPPED_AT_MAX_NUM_REPLICAS");
        public static AutoscalerStatusDetailsType CustomMetricDataPointsTooSparse { get; } = new AutoscalerStatusDetailsType("CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE");
        public static AutoscalerStatusDetailsType CustomMetricInvalid { get; } = new AutoscalerStatusDetailsType("CUSTOM_METRIC_INVALID");
        public static AutoscalerStatusDetailsType MinEqualsMax { get; } = new AutoscalerStatusDetailsType("MIN_EQUALS_MAX");
        public static AutoscalerStatusDetailsType MissingCustomMetricDataPoints { get; } = new AutoscalerStatusDetailsType("MISSING_CUSTOM_METRIC_DATA_POINTS");
        public static AutoscalerStatusDetailsType MissingLoadBalancingDataPoints { get; } = new AutoscalerStatusDetailsType("MISSING_LOAD_BALANCING_DATA_POINTS");
        public static AutoscalerStatusDetailsType ModeOff { get; } = new AutoscalerStatusDetailsType("MODE_OFF");
        public static AutoscalerStatusDetailsType ModeOnlyScaleOut { get; } = new AutoscalerStatusDetailsType("MODE_ONLY_SCALE_OUT");
        public static AutoscalerStatusDetailsType ModeOnlyUp { get; } = new AutoscalerStatusDetailsType("MODE_ONLY_UP");
        public static AutoscalerStatusDetailsType MoreThanOneBackendService { get; } = new AutoscalerStatusDetailsType("MORE_THAN_ONE_BACKEND_SERVICE");
        public static AutoscalerStatusDetailsType NotEnoughQuotaAvailable { get; } = new AutoscalerStatusDetailsType("NOT_ENOUGH_QUOTA_AVAILABLE");
        public static AutoscalerStatusDetailsType RegionResourceStockout { get; } = new AutoscalerStatusDetailsType("REGION_RESOURCE_STOCKOUT");
        public static AutoscalerStatusDetailsType ScalingTargetDoesNotExist { get; } = new AutoscalerStatusDetailsType("SCALING_TARGET_DOES_NOT_EXIST");
        public static AutoscalerStatusDetailsType ScheduledInstancesGreaterThanAutoscalerMax { get; } = new AutoscalerStatusDetailsType("SCHEDULED_INSTANCES_GREATER_THAN_AUTOSCALER_MAX");
        public static AutoscalerStatusDetailsType ScheduledInstancesLessThanAutoscalerMin { get; } = new AutoscalerStatusDetailsType("SCHEDULED_INSTANCES_LESS_THAN_AUTOSCALER_MIN");
        public static AutoscalerStatusDetailsType Unknown { get; } = new AutoscalerStatusDetailsType("UNKNOWN");
        public static AutoscalerStatusDetailsType UnsupportedMaxRateLoadBalancingConfiguration { get; } = new AutoscalerStatusDetailsType("UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION");
        public static AutoscalerStatusDetailsType ZoneResourceStockout { get; } = new AutoscalerStatusDetailsType("ZONE_RESOURCE_STOCKOUT");

        public static bool operator ==(AutoscalerStatusDetailsType left, AutoscalerStatusDetailsType right) => left.Equals(right);
        public static bool operator !=(AutoscalerStatusDetailsType left, AutoscalerStatusDetailsType right) => !left.Equals(right);

        public static explicit operator string(AutoscalerStatusDetailsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoscalerStatusDetailsType other && Equals(other);
        public bool Equals(AutoscalerStatusDetailsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are:
    /// 
    /// * NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics. * OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
    /// </summary>
    [EnumType]
    public readonly struct AutoscalingPolicyCpuUtilizationPredictiveMethod : IEquatable<AutoscalingPolicyCpuUtilizationPredictiveMethod>
    {
        private readonly string _value;

        private AutoscalingPolicyCpuUtilizationPredictiveMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AutoscalingPolicyCpuUtilizationPredictiveMethod None { get; } = new AutoscalingPolicyCpuUtilizationPredictiveMethod("NONE");
        public static AutoscalingPolicyCpuUtilizationPredictiveMethod OptimizeAvailability { get; } = new AutoscalingPolicyCpuUtilizationPredictiveMethod("OPTIMIZE_AVAILABILITY");
        public static AutoscalingPolicyCpuUtilizationPredictiveMethod PredictiveMethodUnspecified { get; } = new AutoscalingPolicyCpuUtilizationPredictiveMethod("PREDICTIVE_METHOD_UNSPECIFIED");
        public static AutoscalingPolicyCpuUtilizationPredictiveMethod Standard { get; } = new AutoscalingPolicyCpuUtilizationPredictiveMethod("STANDARD");

        public static bool operator ==(AutoscalingPolicyCpuUtilizationPredictiveMethod left, AutoscalingPolicyCpuUtilizationPredictiveMethod right) => left.Equals(right);
        public static bool operator !=(AutoscalingPolicyCpuUtilizationPredictiveMethod left, AutoscalingPolicyCpuUtilizationPredictiveMethod right) => !left.Equals(right);

        public static explicit operator string(AutoscalingPolicyCpuUtilizationPredictiveMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoscalingPolicyCpuUtilizationPredictiveMethod other && Equals(other);
        public bool Equals(AutoscalingPolicyCpuUtilizationPredictiveMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines how target utilization value is expressed for a Stackdriver Monitoring metric. Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE.
    /// </summary>
    [EnumType]
    public readonly struct AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType : IEquatable<AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType>
    {
        private readonly string _value;

        private AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType DeltaPerMinute { get; } = new AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType("DELTA_PER_MINUTE");
        public static AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType DeltaPerSecond { get; } = new AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType("DELTA_PER_SECOND");
        public static AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType Gauge { get; } = new AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType("GAUGE");

        public static bool operator ==(AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType left, AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType right) => left.Equals(right);
        public static bool operator !=(AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType left, AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType right) => !left.Equals(right);

        public static explicit operator string(AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType other && Equals(other);
        public bool Equals(AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines operating mode for this policy.
    /// </summary>
    [EnumType]
    public readonly struct AutoscalingPolicyMode : IEquatable<AutoscalingPolicyMode>
    {
        private readonly string _value;

        private AutoscalingPolicyMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AutoscalingPolicyMode Off { get; } = new AutoscalingPolicyMode("OFF");
        public static AutoscalingPolicyMode On { get; } = new AutoscalingPolicyMode("ON");
        public static AutoscalingPolicyMode OnlyScaleOut { get; } = new AutoscalingPolicyMode("ONLY_SCALE_OUT");
        public static AutoscalingPolicyMode OnlyUp { get; } = new AutoscalingPolicyMode("ONLY_UP");

        public static bool operator ==(AutoscalingPolicyMode left, AutoscalingPolicyMode right) => left.Equals(right);
        public static bool operator !=(AutoscalingPolicyMode left, AutoscalingPolicyMode right) => !left.Equals(right);

        public static explicit operator string(AutoscalingPolicyMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoscalingPolicyMode other && Equals(other);
        public bool Equals(AutoscalingPolicyMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how to determine whether the backend of a load balancer can handle additional traffic or is fully loaded. For usage guidelines, see  Connection balancing mode.
    /// </summary>
    [EnumType]
    public readonly struct BackendBalancingMode : IEquatable<BackendBalancingMode>
    {
        private readonly string _value;

        private BackendBalancingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendBalancingMode Connection { get; } = new BackendBalancingMode("CONNECTION");
        public static BackendBalancingMode Rate { get; } = new BackendBalancingMode("RATE");
        public static BackendBalancingMode Utilization { get; } = new BackendBalancingMode("UTILIZATION");

        public static bool operator ==(BackendBalancingMode left, BackendBalancingMode right) => left.Equals(right);
        public static bool operator !=(BackendBalancingMode left, BackendBalancingMode right) => !left.Equals(right);

        public static explicit operator string(BackendBalancingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendBalancingMode other && Equals(other);
        public bool Equals(BackendBalancingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the cache setting for all responses from this backend. The possible values are:
    /// 
    /// USE_ORIGIN_HEADERS Requires the origin to set valid caching headers to cache content. Responses without these headers will not be cached at Google's edge, and will require a full trip to the origin on every request, potentially impacting performance and increasing load on the origin server.
    /// 
    /// FORCE_CACHE_ALL Cache all content, ignoring any "private", "no-store" or "no-cache" directives in Cache-Control response headers. Warning: this may result in Cloud CDN caching private, per-user (user identifiable) content.
    /// 
    /// CACHE_ALL_STATIC Automatically cache static content, including common image formats, media (video and audio), and web assets (JavaScript and CSS). Requests and responses that are marked as uncacheable, as well as dynamic content (including HTML), will not be cached.
    /// </summary>
    [EnumType]
    public readonly struct BackendBucketCdnPolicyCacheMode : IEquatable<BackendBucketCdnPolicyCacheMode>
    {
        private readonly string _value;

        private BackendBucketCdnPolicyCacheMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendBucketCdnPolicyCacheMode CacheAllStatic { get; } = new BackendBucketCdnPolicyCacheMode("CACHE_ALL_STATIC");
        public static BackendBucketCdnPolicyCacheMode ForceCacheAll { get; } = new BackendBucketCdnPolicyCacheMode("FORCE_CACHE_ALL");
        public static BackendBucketCdnPolicyCacheMode InvalidCacheMode { get; } = new BackendBucketCdnPolicyCacheMode("INVALID_CACHE_MODE");
        public static BackendBucketCdnPolicyCacheMode UseOriginHeaders { get; } = new BackendBucketCdnPolicyCacheMode("USE_ORIGIN_HEADERS");

        public static bool operator ==(BackendBucketCdnPolicyCacheMode left, BackendBucketCdnPolicyCacheMode right) => left.Equals(right);
        public static bool operator !=(BackendBucketCdnPolicyCacheMode left, BackendBucketCdnPolicyCacheMode right) => !left.Equals(right);

        public static explicit operator string(BackendBucketCdnPolicyCacheMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendBucketCdnPolicyCacheMode other && Equals(other);
        public bool Equals(BackendBucketCdnPolicyCacheMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the cache setting for all responses from this backend. The possible values are:
    /// 
    /// USE_ORIGIN_HEADERS Requires the origin to set valid caching headers to cache content. Responses without these headers will not be cached at Google's edge, and will require a full trip to the origin on every request, potentially impacting performance and increasing load on the origin server.
    /// 
    /// FORCE_CACHE_ALL Cache all content, ignoring any "private", "no-store" or "no-cache" directives in Cache-Control response headers. Warning: this may result in Cloud CDN caching private, per-user (user identifiable) content.
    /// 
    /// CACHE_ALL_STATIC Automatically cache static content, including common image formats, media (video and audio), and web assets (JavaScript and CSS). Requests and responses that are marked as uncacheable, as well as dynamic content (including HTML), will not be cached.
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceCdnPolicyCacheMode : IEquatable<BackendServiceCdnPolicyCacheMode>
    {
        private readonly string _value;

        private BackendServiceCdnPolicyCacheMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendServiceCdnPolicyCacheMode CacheAllStatic { get; } = new BackendServiceCdnPolicyCacheMode("CACHE_ALL_STATIC");
        public static BackendServiceCdnPolicyCacheMode ForceCacheAll { get; } = new BackendServiceCdnPolicyCacheMode("FORCE_CACHE_ALL");
        public static BackendServiceCdnPolicyCacheMode InvalidCacheMode { get; } = new BackendServiceCdnPolicyCacheMode("INVALID_CACHE_MODE");
        public static BackendServiceCdnPolicyCacheMode UseOriginHeaders { get; } = new BackendServiceCdnPolicyCacheMode("USE_ORIGIN_HEADERS");

        public static bool operator ==(BackendServiceCdnPolicyCacheMode left, BackendServiceCdnPolicyCacheMode right) => left.Equals(right);
        public static bool operator !=(BackendServiceCdnPolicyCacheMode left, BackendServiceCdnPolicyCacheMode right) => !left.Equals(right);

        public static explicit operator string(BackendServiceCdnPolicyCacheMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceCdnPolicyCacheMode other && Equals(other);
        public bool Equals(BackendServiceCdnPolicyCacheMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies connection persistence when backends are unhealthy. The default value is DEFAULT_FOR_PROTOCOL.
    /// 
    /// If set to DEFAULT_FOR_PROTOCOL, the existing connections persist on unhealthy backends only for connection-oriented protocols (TCP and SCTP) and only if the Tracking Mode is PER_CONNECTION (default tracking mode) or the Session Affinity is configured for 5-tuple. They do not persist for UDP.
    /// 
    /// If set to NEVER_PERSIST, after a backend becomes unhealthy, the existing connections on the unhealthy backend are never persisted on the unhealthy backend. They are always diverted to newly selected healthy backends (unless all backends are unhealthy).
    /// 
    /// If set to ALWAYS_PERSIST, existing connections always persist on unhealthy backends regardless of protocol and session affinity. It is generally not recommended to use this mode overriding the default.
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends : IEquatable<BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends>
    {
        private readonly string _value;

        private BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends AlwaysPersist { get; } = new BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends("ALWAYS_PERSIST");
        public static BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends DefaultForProtocol { get; } = new BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends("DEFAULT_FOR_PROTOCOL");
        public static BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends NeverPersist { get; } = new BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends("NEVER_PERSIST");

        public static bool operator ==(BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends left, BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends right) => left.Equals(right);
        public static bool operator !=(BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends left, BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends right) => !left.Equals(right);

        public static explicit operator string(BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends other && Equals(other);
        public bool Equals(BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the key used for connection tracking. There are two options:
    /// 
    /// PER_CONNECTION: This is the default mode. The Connection Tracking is performed as per the Connection Key (default Hash Method) for the specific protocol.
    /// 
    /// PER_SESSION: The Connection Tracking is performed as per the configured Session Affinity. It matches the configured Session Affinity.
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceConnectionTrackingPolicyTrackingMode : IEquatable<BackendServiceConnectionTrackingPolicyTrackingMode>
    {
        private readonly string _value;

        private BackendServiceConnectionTrackingPolicyTrackingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendServiceConnectionTrackingPolicyTrackingMode InvalidTrackingMode { get; } = new BackendServiceConnectionTrackingPolicyTrackingMode("INVALID_TRACKING_MODE");
        public static BackendServiceConnectionTrackingPolicyTrackingMode PerConnection { get; } = new BackendServiceConnectionTrackingPolicyTrackingMode("PER_CONNECTION");
        public static BackendServiceConnectionTrackingPolicyTrackingMode PerSession { get; } = new BackendServiceConnectionTrackingPolicyTrackingMode("PER_SESSION");

        public static bool operator ==(BackendServiceConnectionTrackingPolicyTrackingMode left, BackendServiceConnectionTrackingPolicyTrackingMode right) => left.Equals(right);
        public static bool operator !=(BackendServiceConnectionTrackingPolicyTrackingMode left, BackendServiceConnectionTrackingPolicyTrackingMode right) => !left.Equals(right);

        public static explicit operator string(BackendServiceConnectionTrackingPolicyTrackingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceConnectionTrackingPolicyTrackingMode other && Equals(other);
        public bool Equals(BackendServiceConnectionTrackingPolicyTrackingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose  INTERNAL for Internal TCP/UDP Load Balancing. Choose  INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.  INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceLoadBalancingScheme : IEquatable<BackendServiceLoadBalancingScheme>
    {
        private readonly string _value;

        private BackendServiceLoadBalancingScheme(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendServiceLoadBalancingScheme External { get; } = new BackendServiceLoadBalancingScheme("EXTERNAL");
        public static BackendServiceLoadBalancingScheme ExternalManaged { get; } = new BackendServiceLoadBalancingScheme("EXTERNAL_MANAGED");
        public static BackendServiceLoadBalancingScheme Internal { get; } = new BackendServiceLoadBalancingScheme("INTERNAL");
        public static BackendServiceLoadBalancingScheme InternalManaged { get; } = new BackendServiceLoadBalancingScheme("INTERNAL_MANAGED");
        public static BackendServiceLoadBalancingScheme InternalSelfManaged { get; } = new BackendServiceLoadBalancingScheme("INTERNAL_SELF_MANAGED");
        public static BackendServiceLoadBalancingScheme InvalidLoadBalancingScheme { get; } = new BackendServiceLoadBalancingScheme("INVALID_LOAD_BALANCING_SCHEME");

        public static bool operator ==(BackendServiceLoadBalancingScheme left, BackendServiceLoadBalancingScheme right) => left.Equals(right);
        public static bool operator !=(BackendServiceLoadBalancingScheme left, BackendServiceLoadBalancingScheme right) => !left.Equals(right);

        public static explicit operator string(BackendServiceLoadBalancingScheme value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceLoadBalancingScheme other && Equals(other);
        public bool Equals(BackendServiceLoadBalancingScheme other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The load balancing algorithm used within the scope of the locality. The possible values are:  
    /// - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default. 
    /// - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests. 
    /// - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests. 
    /// - RANDOM: The load balancer selects a random healthy host. 
    /// - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer. 
    /// - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824 
    /// 
    /// This field is applicable to either:  
    /// - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED. 
    /// - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.  
    /// 
    /// If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect.
    /// 
    /// Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceLocalityLbPolicy : IEquatable<BackendServiceLocalityLbPolicy>
    {
        private readonly string _value;

        private BackendServiceLocalityLbPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendServiceLocalityLbPolicy InvalidLbPolicy { get; } = new BackendServiceLocalityLbPolicy("INVALID_LB_POLICY");
        public static BackendServiceLocalityLbPolicy LeastRequest { get; } = new BackendServiceLocalityLbPolicy("LEAST_REQUEST");
        public static BackendServiceLocalityLbPolicy Maglev { get; } = new BackendServiceLocalityLbPolicy("MAGLEV");
        public static BackendServiceLocalityLbPolicy OriginalDestination { get; } = new BackendServiceLocalityLbPolicy("ORIGINAL_DESTINATION");
        public static BackendServiceLocalityLbPolicy Random { get; } = new BackendServiceLocalityLbPolicy("RANDOM");
        public static BackendServiceLocalityLbPolicy RingHash { get; } = new BackendServiceLocalityLbPolicy("RING_HASH");
        public static BackendServiceLocalityLbPolicy RoundRobin { get; } = new BackendServiceLocalityLbPolicy("ROUND_ROBIN");

        public static bool operator ==(BackendServiceLocalityLbPolicy left, BackendServiceLocalityLbPolicy right) => left.Equals(right);
        public static bool operator !=(BackendServiceLocalityLbPolicy left, BackendServiceLocalityLbPolicy right) => !left.Equals(right);

        public static explicit operator string(BackendServiceLocalityLbPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceLocalityLbPolicy other && Equals(other);
        public bool Equals(BackendServiceLocalityLbPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol this BackendService uses to communicate with backends.
    /// 
    /// Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information.
    /// 
    /// Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceProtocol : IEquatable<BackendServiceProtocol>
    {
        private readonly string _value;

        private BackendServiceProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendServiceProtocol All { get; } = new BackendServiceProtocol("ALL");
        public static BackendServiceProtocol Grpc { get; } = new BackendServiceProtocol("GRPC");
        public static BackendServiceProtocol Http { get; } = new BackendServiceProtocol("HTTP");
        public static BackendServiceProtocol Http2 { get; } = new BackendServiceProtocol("HTTP2");
        public static BackendServiceProtocol Https { get; } = new BackendServiceProtocol("HTTPS");
        public static BackendServiceProtocol Ssl { get; } = new BackendServiceProtocol("SSL");
        public static BackendServiceProtocol Tcp { get; } = new BackendServiceProtocol("TCP");
        public static BackendServiceProtocol Udp { get; } = new BackendServiceProtocol("UDP");

        public static bool operator ==(BackendServiceProtocol left, BackendServiceProtocol right) => left.Equals(right);
        public static bool operator !=(BackendServiceProtocol left, BackendServiceProtocol right) => !left.Equals(right);

        public static explicit operator string(BackendServiceProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceProtocol other && Equals(other);
        public bool Equals(BackendServiceProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of session affinity to use. The default is NONE.
    /// 
    /// When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or  CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS.
    /// 
    /// When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
    /// 
    /// When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
    /// 
    /// Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceSessionAffinity : IEquatable<BackendServiceSessionAffinity>
    {
        private readonly string _value;

        private BackendServiceSessionAffinity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendServiceSessionAffinity ClientIp { get; } = new BackendServiceSessionAffinity("CLIENT_IP");
        public static BackendServiceSessionAffinity ClientIpNoDestination { get; } = new BackendServiceSessionAffinity("CLIENT_IP_NO_DESTINATION");
        public static BackendServiceSessionAffinity ClientIpPortProto { get; } = new BackendServiceSessionAffinity("CLIENT_IP_PORT_PROTO");
        public static BackendServiceSessionAffinity ClientIpProto { get; } = new BackendServiceSessionAffinity("CLIENT_IP_PROTO");
        public static BackendServiceSessionAffinity GeneratedCookie { get; } = new BackendServiceSessionAffinity("GENERATED_COOKIE");
        public static BackendServiceSessionAffinity HeaderField { get; } = new BackendServiceSessionAffinity("HEADER_FIELD");
        public static BackendServiceSessionAffinity HttpCookie { get; } = new BackendServiceSessionAffinity("HTTP_COOKIE");
        public static BackendServiceSessionAffinity None { get; } = new BackendServiceSessionAffinity("NONE");

        public static bool operator ==(BackendServiceSessionAffinity left, BackendServiceSessionAffinity right) => left.Equals(right);
        public static bool operator !=(BackendServiceSessionAffinity left, BackendServiceSessionAffinity right) => !left.Equals(right);

        public static explicit operator string(BackendServiceSessionAffinity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceSessionAffinity other && Equals(other);
        public bool Equals(BackendServiceSessionAffinity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of call credentials to use for GRPC requests to the SDS server. This field can be set to one of the following:  
    /// - GCE_VM: The local GCE VM service account credentials are used to access the SDS server.
    /// - FROM_PLUGIN: Custom authenticator credentials are used to access the SDS server.
    /// </summary>
    [EnumType]
    public readonly struct CallCredentialsCallCredentialType : IEquatable<CallCredentialsCallCredentialType>
    {
        private readonly string _value;

        private CallCredentialsCallCredentialType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CallCredentialsCallCredentialType FromPlugin { get; } = new CallCredentialsCallCredentialType("FROM_PLUGIN");
        public static CallCredentialsCallCredentialType GceVm { get; } = new CallCredentialsCallCredentialType("GCE_VM");
        public static CallCredentialsCallCredentialType Invalid { get; } = new CallCredentialsCallCredentialType("INVALID");

        public static bool operator ==(CallCredentialsCallCredentialType left, CallCredentialsCallCredentialType right) => left.Equals(right);
        public static bool operator !=(CallCredentialsCallCredentialType left, CallCredentialsCallCredentialType right) => !left.Equals(right);

        public static explicit operator string(CallCredentialsCallCredentialType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CallCredentialsCallCredentialType other && Equals(other);
        public bool Equals(CallCredentialsCallCredentialType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The channel credentials to access the SDS server. This field can be set to one of the following: CERTIFICATES: Use TLS certificates to access the SDS server. GCE_VM: Use local GCE VM credentials to access the SDS server.
    /// </summary>
    [EnumType]
    public readonly struct ChannelCredentialsChannelCredentialType : IEquatable<ChannelCredentialsChannelCredentialType>
    {
        private readonly string _value;

        private ChannelCredentialsChannelCredentialType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ChannelCredentialsChannelCredentialType Certificates { get; } = new ChannelCredentialsChannelCredentialType("CERTIFICATES");
        public static ChannelCredentialsChannelCredentialType GceVm { get; } = new ChannelCredentialsChannelCredentialType("GCE_VM");
        public static ChannelCredentialsChannelCredentialType Invalid { get; } = new ChannelCredentialsChannelCredentialType("INVALID");

        public static bool operator ==(ChannelCredentialsChannelCredentialType left, ChannelCredentialsChannelCredentialType right) => left.Equals(right);
        public static bool operator !=(ChannelCredentialsChannelCredentialType left, ChannelCredentialsChannelCredentialType right) => !left.Equals(right);

        public static explicit operator string(ChannelCredentialsChannelCredentialType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ChannelCredentialsChannelCredentialType other && Equals(other);
        public bool Equals(ChannelCredentialsChannelCredentialType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Trusted attributes supplied by the IAM system.
    /// </summary>
    [EnumType]
    public readonly struct ConditionIam : IEquatable<ConditionIam>
    {
        private readonly string _value;

        private ConditionIam(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConditionIam Approver { get; } = new ConditionIam("APPROVER");
        public static ConditionIam Attribution { get; } = new ConditionIam("ATTRIBUTION");
        public static ConditionIam Authority { get; } = new ConditionIam("AUTHORITY");
        public static ConditionIam CredentialsType { get; } = new ConditionIam("CREDENTIALS_TYPE");
        public static ConditionIam CredsAssertion { get; } = new ConditionIam("CREDS_ASSERTION");
        public static ConditionIam JustificationType { get; } = new ConditionIam("JUSTIFICATION_TYPE");
        public static ConditionIam NoAttr { get; } = new ConditionIam("NO_ATTR");
        public static ConditionIam SecurityRealm { get; } = new ConditionIam("SECURITY_REALM");

        public static bool operator ==(ConditionIam left, ConditionIam right) => left.Equals(right);
        public static bool operator !=(ConditionIam left, ConditionIam right) => !left.Equals(right);

        public static explicit operator string(ConditionIam value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConditionIam other && Equals(other);
        public bool Equals(ConditionIam other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// An operator to apply the subject with.
    /// </summary>
    [EnumType]
    public readonly struct ConditionOp : IEquatable<ConditionOp>
    {
        private readonly string _value;

        private ConditionOp(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConditionOp Discharged { get; } = new ConditionOp("DISCHARGED");
        public static ConditionOp EqualsValue { get; } = new ConditionOp("EQUALS");
        public static ConditionOp In { get; } = new ConditionOp("IN");
        public static ConditionOp NotEquals { get; } = new ConditionOp("NOT_EQUALS");
        public static ConditionOp NotIn { get; } = new ConditionOp("NOT_IN");
        public static ConditionOp NoOp { get; } = new ConditionOp("NO_OP");

        public static bool operator ==(ConditionOp left, ConditionOp right) => left.Equals(right);
        public static bool operator !=(ConditionOp left, ConditionOp right) => !left.Equals(right);

        public static explicit operator string(ConditionOp value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConditionOp other && Equals(other);
        public bool Equals(ConditionOp other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Trusted attributes supplied by any service that owns resources and uses the IAM system for access control.
    /// </summary>
    [EnumType]
    public readonly struct ConditionSys : IEquatable<ConditionSys>
    {
        private readonly string _value;

        private ConditionSys(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConditionSys Ip { get; } = new ConditionSys("IP");
        public static ConditionSys Name { get; } = new ConditionSys("NAME");
        public static ConditionSys NoAttr { get; } = new ConditionSys("NO_ATTR");
        public static ConditionSys Region { get; } = new ConditionSys("REGION");
        public static ConditionSys Service { get; } = new ConditionSys("SERVICE");

        public static bool operator ==(ConditionSys left, ConditionSys right) => left.Equals(right);
        public static bool operator !=(ConditionSys left, ConditionSys right) => !left.Equals(right);

        public static explicit operator string(ConditionSys value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConditionSys other && Equals(other);
        public bool Equals(ConditionSys other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The deprecation state of this resource. This can be ACTIVE, DEPRECATED, OBSOLETE, or DELETED. Operations which communicate the end of life date for an image, can use ACTIVE. Operations which create a new resource using a DEPRECATED resource will return successfully, but with a warning indicating the deprecated resource and recommending its replacement. Operations which use OBSOLETE or DELETED resources will be rejected and result in an error.
    /// </summary>
    [EnumType]
    public readonly struct DeprecationStatusState : IEquatable<DeprecationStatusState>
    {
        private readonly string _value;

        private DeprecationStatusState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DeprecationStatusState Active { get; } = new DeprecationStatusState("ACTIVE");
        public static DeprecationStatusState Deleted { get; } = new DeprecationStatusState("DELETED");
        public static DeprecationStatusState Deprecated { get; } = new DeprecationStatusState("DEPRECATED");
        public static DeprecationStatusState Obsolete { get; } = new DeprecationStatusState("OBSOLETE");

        public static bool operator ==(DeprecationStatusState left, DeprecationStatusState right) => left.Equals(right);
        public static bool operator !=(DeprecationStatusState left, DeprecationStatusState right) => !left.Equals(right);

        public static explicit operator string(DeprecationStatusState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeprecationStatusState other && Equals(other);
        public bool Equals(DeprecationStatusState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether to include the disk and what image to use. Possible values are:  
    /// - source-image: to use the same image that was used to create the source instance's corresponding disk. Applicable to the boot disk and additional read-write disks. 
    /// - source-image-family: to use the same image family that was used to create the source instance's corresponding disk. Applicable to the boot disk and additional read-write disks. 
    /// - custom-image: to use a user-provided image url for disk creation. Applicable to the boot disk and additional read-write disks. 
    /// - attach-read-only: to attach a read-only disk. Applicable to read-only disks. 
    /// - do-not-include: to exclude a disk from the template. Applicable to additional read-write disks, local SSDs, and read-only disks.
    /// </summary>
    [EnumType]
    public readonly struct DiskInstantiationConfigInstantiateFrom : IEquatable<DiskInstantiationConfigInstantiateFrom>
    {
        private readonly string _value;

        private DiskInstantiationConfigInstantiateFrom(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiskInstantiationConfigInstantiateFrom AttachReadOnly { get; } = new DiskInstantiationConfigInstantiateFrom("ATTACH_READ_ONLY");
        public static DiskInstantiationConfigInstantiateFrom Blank { get; } = new DiskInstantiationConfigInstantiateFrom("BLANK");
        public static DiskInstantiationConfigInstantiateFrom CustomImage { get; } = new DiskInstantiationConfigInstantiateFrom("CUSTOM_IMAGE");
        public static DiskInstantiationConfigInstantiateFrom Default { get; } = new DiskInstantiationConfigInstantiateFrom("DEFAULT");
        public static DiskInstantiationConfigInstantiateFrom DoNotInclude { get; } = new DiskInstantiationConfigInstantiateFrom("DO_NOT_INCLUDE");
        public static DiskInstantiationConfigInstantiateFrom SourceImage { get; } = new DiskInstantiationConfigInstantiateFrom("SOURCE_IMAGE");
        public static DiskInstantiationConfigInstantiateFrom SourceImageFamily { get; } = new DiskInstantiationConfigInstantiateFrom("SOURCE_IMAGE_FAMILY");

        public static bool operator ==(DiskInstantiationConfigInstantiateFrom left, DiskInstantiationConfigInstantiateFrom right) => left.Equals(right);
        public static bool operator !=(DiskInstantiationConfigInstantiateFrom left, DiskInstantiationConfigInstantiateFrom right) => !left.Equals(right);

        public static explicit operator string(DiskInstantiationConfigInstantiateFrom value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskInstantiationConfigInstantiateFrom other && Equals(other);
        public bool Equals(DiskInstantiationConfigInstantiateFrom other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI.
    /// </summary>
    [EnumType]
    public readonly struct DiskInterface : IEquatable<DiskInterface>
    {
        private readonly string _value;

        private DiskInterface(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiskInterface Nvme { get; } = new DiskInterface("NVME");
        public static DiskInterface Scsi { get; } = new DiskInterface("SCSI");
        public static DiskInterface Unspecified { get; } = new DiskInterface("UNSPECIFIED");

        public static bool operator ==(DiskInterface left, DiskInterface right) => left.Equals(right);
        public static bool operator !=(DiskInterface left, DiskInterface right) => !left.Equals(right);

        public static explicit operator string(DiskInterface value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskInterface other && Equals(other);
        public bool Equals(DiskInterface other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of disk creation.  
    /// - CREATING: Disk is provisioning. 
    /// - RESTORING: Source data is being copied into the disk. 
    /// - FAILED: Disk creation failed. 
    /// - READY: Disk is ready for use. 
    /// - DELETING: Disk is deleting.
    /// </summary>
    [EnumType]
    public readonly struct DiskStatus : IEquatable<DiskStatus>
    {
        private readonly string _value;

        private DiskStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DiskStatus Creating { get; } = new DiskStatus("CREATING");
        public static DiskStatus Deleting { get; } = new DiskStatus("DELETING");
        public static DiskStatus Failed { get; } = new DiskStatus("FAILED");
        public static DiskStatus Ready { get; } = new DiskStatus("READY");
        public static DiskStatus Restoring { get; } = new DiskStatus("RESTORING");

        public static bool operator ==(DiskStatus left, DiskStatus right) => left.Equals(right);
        public static bool operator !=(DiskStatus left, DiskStatus right) => !left.Equals(right);

        public static explicit operator string(DiskStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskStatus other && Equals(other);
        public bool Equals(DiskStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The distribution shape to which the group converges either proactively or on resize events (depending on the value set in updatePolicy.instanceRedistributionType).
    /// </summary>
    [EnumType]
    public readonly struct DistributionPolicyTargetShape : IEquatable<DistributionPolicyTargetShape>
    {
        private readonly string _value;

        private DistributionPolicyTargetShape(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DistributionPolicyTargetShape Any { get; } = new DistributionPolicyTargetShape("ANY");
        public static DistributionPolicyTargetShape Balanced { get; } = new DistributionPolicyTargetShape("BALANCED");
        public static DistributionPolicyTargetShape Even { get; } = new DistributionPolicyTargetShape("EVEN");

        public static bool operator ==(DistributionPolicyTargetShape left, DistributionPolicyTargetShape right) => left.Equals(right);
        public static bool operator !=(DistributionPolicyTargetShape left, DistributionPolicyTargetShape right) => !left.Equals(right);

        public static explicit operator string(DistributionPolicyTargetShape value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionPolicyTargetShape other && Equals(other);
        public bool Equals(DistributionPolicyTargetShape other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates the user-supplied redundancy type of this external VPN gateway.
    /// </summary>
    [EnumType]
    public readonly struct ExternalVpnGatewayRedundancyType : IEquatable<ExternalVpnGatewayRedundancyType>
    {
        private readonly string _value;

        private ExternalVpnGatewayRedundancyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ExternalVpnGatewayRedundancyType FourIpsRedundancy { get; } = new ExternalVpnGatewayRedundancyType("FOUR_IPS_REDUNDANCY");
        public static ExternalVpnGatewayRedundancyType SingleIpInternallyRedundant { get; } = new ExternalVpnGatewayRedundancyType("SINGLE_IP_INTERNALLY_REDUNDANT");
        public static ExternalVpnGatewayRedundancyType TwoIpsRedundancy { get; } = new ExternalVpnGatewayRedundancyType("TWO_IPS_REDUNDANCY");

        public static bool operator ==(ExternalVpnGatewayRedundancyType left, ExternalVpnGatewayRedundancyType right) => left.Equals(right);
        public static bool operator !=(ExternalVpnGatewayRedundancyType left, ExternalVpnGatewayRedundancyType right) => !left.Equals(right);

        public static explicit operator string(ExternalVpnGatewayRedundancyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExternalVpnGatewayRedundancyType other && Equals(other);
        public bool Equals(ExternalVpnGatewayRedundancyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The file type of source file.
    /// </summary>
    [EnumType]
    public readonly struct FileContentBufferFileType : IEquatable<FileContentBufferFileType>
    {
        private readonly string _value;

        private FileContentBufferFileType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FileContentBufferFileType Bin { get; } = new FileContentBufferFileType("BIN");
        public static FileContentBufferFileType Undefined { get; } = new FileContentBufferFileType("UNDEFINED");
        public static FileContentBufferFileType X509 { get; } = new FileContentBufferFileType("X509");

        public static bool operator ==(FileContentBufferFileType left, FileContentBufferFileType right) => left.Equals(right);
        public static bool operator !=(FileContentBufferFileType left, FileContentBufferFileType right) => !left.Equals(right);

        public static explicit operator string(FileContentBufferFileType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FileContentBufferFileType other && Equals(other);
        public bool Equals(FileContentBufferFileType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Direction of traffic to which this firewall applies, either `INGRESS` or `EGRESS`. The default is `INGRESS`. For `INGRESS` traffic, you cannot specify the destinationRanges field, and for `EGRESS` traffic, you cannot specify the sourceRanges or sourceTags fields.
    /// </summary>
    [EnumType]
    public readonly struct FirewallDirection : IEquatable<FirewallDirection>
    {
        private readonly string _value;

        private FirewallDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FirewallDirection Egress { get; } = new FirewallDirection("EGRESS");
        public static FirewallDirection Ingress { get; } = new FirewallDirection("INGRESS");

        public static bool operator ==(FirewallDirection left, FirewallDirection right) => left.Equals(right);
        public static bool operator !=(FirewallDirection left, FirewallDirection right) => !left.Equals(right);

        public static explicit operator string(FirewallDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FirewallDirection other && Equals(other);
        public bool Equals(FirewallDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This field can only be specified for a particular firewall rule if logging is enabled for that rule. This field denotes whether to include or exclude metadata for firewall logs.
    /// </summary>
    [EnumType]
    public readonly struct FirewallLogConfigMetadata : IEquatable<FirewallLogConfigMetadata>
    {
        private readonly string _value;

        private FirewallLogConfigMetadata(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FirewallLogConfigMetadata ExcludeAllMetadata { get; } = new FirewallLogConfigMetadata("EXCLUDE_ALL_METADATA");
        public static FirewallLogConfigMetadata IncludeAllMetadata { get; } = new FirewallLogConfigMetadata("INCLUDE_ALL_METADATA");

        public static bool operator ==(FirewallLogConfigMetadata left, FirewallLogConfigMetadata right) => left.Equals(right);
        public static bool operator !=(FirewallLogConfigMetadata left, FirewallLogConfigMetadata right) => !left.Equals(right);

        public static explicit operator string(FirewallLogConfigMetadata value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FirewallLogConfigMetadata other && Equals(other);
        public bool Equals(FirewallLogConfigMetadata other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The direction in which this rule applies.
    /// </summary>
    [EnumType]
    public readonly struct FirewallPolicyRuleDirection : IEquatable<FirewallPolicyRuleDirection>
    {
        private readonly string _value;

        private FirewallPolicyRuleDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FirewallPolicyRuleDirection Egress { get; } = new FirewallPolicyRuleDirection("EGRESS");
        public static FirewallPolicyRuleDirection Ingress { get; } = new FirewallPolicyRuleDirection("INGRESS");

        public static bool operator ==(FirewallPolicyRuleDirection left, FirewallPolicyRuleDirection right) => left.Equals(right);
        public static bool operator !=(FirewallPolicyRuleDirection left, FirewallPolicyRuleDirection right) => !left.Equals(right);

        public static explicit operator string(FirewallPolicyRuleDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FirewallPolicyRuleDirection other && Equals(other);
        public bool Equals(FirewallPolicyRuleDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] State of the secure tag, either `EFFECTIVE` or `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted or its network is deleted.
    /// </summary>
    [EnumType]
    public readonly struct FirewallPolicyRuleSecureTagState : IEquatable<FirewallPolicyRuleSecureTagState>
    {
        private readonly string _value;

        private FirewallPolicyRuleSecureTagState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FirewallPolicyRuleSecureTagState Effective { get; } = new FirewallPolicyRuleSecureTagState("EFFECTIVE");
        public static FirewallPolicyRuleSecureTagState Ineffective { get; } = new FirewallPolicyRuleSecureTagState("INEFFECTIVE");

        public static bool operator ==(FirewallPolicyRuleSecureTagState left, FirewallPolicyRuleSecureTagState right) => left.Equals(right);
        public static bool operator !=(FirewallPolicyRuleSecureTagState left, FirewallPolicyRuleSecureTagState right) => !left.Equals(right);

        public static explicit operator string(FirewallPolicyRuleSecureTagState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FirewallPolicyRuleSecureTagState other && Equals(other);
        public bool Equals(FirewallPolicyRuleSecureTagState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP protocol to which this rule applies.
    /// 
    /// For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and ICMP.
    /// 
    /// The valid IP protocols are different for different load balancing products:  
    /// - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or ALL is valid. 
    /// - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid.  
    /// - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid. 
    /// - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid. 
    /// - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP or UDP is valid.
    /// </summary>
    [EnumType]
    public readonly struct ForwardingRuleIPProtocol : IEquatable<ForwardingRuleIPProtocol>
    {
        private readonly string _value;

        private ForwardingRuleIPProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ForwardingRuleIPProtocol Ah { get; } = new ForwardingRuleIPProtocol("AH");
        public static ForwardingRuleIPProtocol All { get; } = new ForwardingRuleIPProtocol("ALL");
        public static ForwardingRuleIPProtocol Esp { get; } = new ForwardingRuleIPProtocol("ESP");
        public static ForwardingRuleIPProtocol Icmp { get; } = new ForwardingRuleIPProtocol("ICMP");
        public static ForwardingRuleIPProtocol Sctp { get; } = new ForwardingRuleIPProtocol("SCTP");
        public static ForwardingRuleIPProtocol Tcp { get; } = new ForwardingRuleIPProtocol("TCP");
        public static ForwardingRuleIPProtocol Udp { get; } = new ForwardingRuleIPProtocol("UDP");

        public static bool operator ==(ForwardingRuleIPProtocol left, ForwardingRuleIPProtocol right) => left.Equals(right);
        public static bool operator !=(ForwardingRuleIPProtocol left, ForwardingRuleIPProtocol right) => !left.Equals(right);

        public static explicit operator string(ForwardingRuleIPProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForwardingRuleIPProtocol other && Equals(other);
        public bool Equals(ForwardingRuleIPProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
    /// </summary>
    [EnumType]
    public readonly struct ForwardingRuleIpVersion : IEquatable<ForwardingRuleIpVersion>
    {
        private readonly string _value;

        private ForwardingRuleIpVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ForwardingRuleIpVersion Ipv4 { get; } = new ForwardingRuleIpVersion("IPV4");
        public static ForwardingRuleIpVersion Ipv6 { get; } = new ForwardingRuleIpVersion("IPV6");
        public static ForwardingRuleIpVersion UnspecifiedVersion { get; } = new ForwardingRuleIpVersion("UNSPECIFIED_VERSION");

        public static bool operator ==(ForwardingRuleIpVersion left, ForwardingRuleIpVersion right) => left.Equals(right);
        public static bool operator !=(ForwardingRuleIpVersion left, ForwardingRuleIpVersion right) => !left.Equals(right);

        public static explicit operator string(ForwardingRuleIpVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForwardingRuleIpVersion other && Equals(other);
        public bool Equals(ForwardingRuleIpVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the forwarding rule type.
    /// 
    ///  
    /// - EXTERNAL is used for:  
    /// - Classic Cloud VPN gateways 
    /// - Protocol forwarding to VMs from an external IP address 
    /// - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing    
    /// - INTERNAL is used for:  
    /// - Protocol forwarding to VMs from an internal IP address 
    /// - Internal TCP/UDP Load Balancing   
    /// - INTERNAL_MANAGED is used for:  
    /// - Internal HTTP(S) Load Balancing   
    /// - INTERNAL_SELF_MANAGED is used for:  
    /// - Traffic Director    
    /// 
    /// For more information about forwarding rules, refer to Forwarding rule concepts.
    /// </summary>
    [EnumType]
    public readonly struct ForwardingRuleLoadBalancingScheme : IEquatable<ForwardingRuleLoadBalancingScheme>
    {
        private readonly string _value;

        private ForwardingRuleLoadBalancingScheme(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ForwardingRuleLoadBalancingScheme External { get; } = new ForwardingRuleLoadBalancingScheme("EXTERNAL");
        public static ForwardingRuleLoadBalancingScheme ExternalManaged { get; } = new ForwardingRuleLoadBalancingScheme("EXTERNAL_MANAGED");
        public static ForwardingRuleLoadBalancingScheme Internal { get; } = new ForwardingRuleLoadBalancingScheme("INTERNAL");
        public static ForwardingRuleLoadBalancingScheme InternalManaged { get; } = new ForwardingRuleLoadBalancingScheme("INTERNAL_MANAGED");
        public static ForwardingRuleLoadBalancingScheme InternalSelfManaged { get; } = new ForwardingRuleLoadBalancingScheme("INTERNAL_SELF_MANAGED");
        public static ForwardingRuleLoadBalancingScheme Invalid { get; } = new ForwardingRuleLoadBalancingScheme("INVALID");

        public static bool operator ==(ForwardingRuleLoadBalancingScheme left, ForwardingRuleLoadBalancingScheme right) => left.Equals(right);
        public static bool operator !=(ForwardingRuleLoadBalancingScheme left, ForwardingRuleLoadBalancingScheme right) => !left.Equals(right);

        public static explicit operator string(ForwardingRuleLoadBalancingScheme value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForwardingRuleLoadBalancingScheme other && Equals(other);
        public bool Equals(ForwardingRuleLoadBalancingScheme other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD.
    /// 
    /// For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
    /// 
    /// If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
    /// </summary>
    [EnumType]
    public readonly struct ForwardingRuleNetworkTier : IEquatable<ForwardingRuleNetworkTier>
    {
        private readonly string _value;

        private ForwardingRuleNetworkTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ForwardingRuleNetworkTier FixedStandard { get; } = new ForwardingRuleNetworkTier("FIXED_STANDARD");
        public static ForwardingRuleNetworkTier Premium { get; } = new ForwardingRuleNetworkTier("PREMIUM");
        public static ForwardingRuleNetworkTier Select { get; } = new ForwardingRuleNetworkTier("SELECT");
        public static ForwardingRuleNetworkTier Standard { get; } = new ForwardingRuleNetworkTier("STANDARD");
        public static ForwardingRuleNetworkTier StandardOverridesFixedStandard { get; } = new ForwardingRuleNetworkTier("STANDARD_OVERRIDES_FIXED_STANDARD");

        public static bool operator ==(ForwardingRuleNetworkTier left, ForwardingRuleNetworkTier right) => left.Equals(right);
        public static bool operator !=(ForwardingRuleNetworkTier left, ForwardingRuleNetworkTier right) => !left.Equals(right);

        public static explicit operator string(ForwardingRuleNetworkTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForwardingRuleNetworkTier other && Equals(other);
        public bool Equals(ForwardingRuleNetworkTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct ForwardingRulePscConnectionStatus : IEquatable<ForwardingRulePscConnectionStatus>
    {
        private readonly string _value;

        private ForwardingRulePscConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ForwardingRulePscConnectionStatus Accepted { get; } = new ForwardingRulePscConnectionStatus("ACCEPTED");
        public static ForwardingRulePscConnectionStatus Closed { get; } = new ForwardingRulePscConnectionStatus("CLOSED");
        public static ForwardingRulePscConnectionStatus Pending { get; } = new ForwardingRulePscConnectionStatus("PENDING");
        public static ForwardingRulePscConnectionStatus Rejected { get; } = new ForwardingRulePscConnectionStatus("REJECTED");
        public static ForwardingRulePscConnectionStatus StatusUnspecified { get; } = new ForwardingRulePscConnectionStatus("STATUS_UNSPECIFIED");

        public static bool operator ==(ForwardingRulePscConnectionStatus left, ForwardingRulePscConnectionStatus right) => left.Equals(right);
        public static bool operator !=(ForwardingRulePscConnectionStatus left, ForwardingRulePscConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(ForwardingRulePscConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForwardingRulePscConnectionStatus other && Equals(other);
        public bool Equals(ForwardingRulePscConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how port is selected for health checking, can be one of following values:
    /// USE_FIXED_PORT: The port number in port is used for health checking.
    /// USE_NAMED_PORT: The portName is used for health checking.
    /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
    /// 
    /// 
    /// If not specified, gRPC health check follows behavior specified in port and portName fields.
    /// </summary>
    [EnumType]
    public readonly struct GRPCHealthCheckPortSpecification : IEquatable<GRPCHealthCheckPortSpecification>
    {
        private readonly string _value;

        private GRPCHealthCheckPortSpecification(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GRPCHealthCheckPortSpecification UseFixedPort { get; } = new GRPCHealthCheckPortSpecification("USE_FIXED_PORT");
        public static GRPCHealthCheckPortSpecification UseNamedPort { get; } = new GRPCHealthCheckPortSpecification("USE_NAMED_PORT");
        public static GRPCHealthCheckPortSpecification UseServingPort { get; } = new GRPCHealthCheckPortSpecification("USE_SERVING_PORT");

        public static bool operator ==(GRPCHealthCheckPortSpecification left, GRPCHealthCheckPortSpecification right) => left.Equals(right);
        public static bool operator !=(GRPCHealthCheckPortSpecification left, GRPCHealthCheckPortSpecification right) => !left.Equals(right);

        public static explicit operator string(GRPCHealthCheckPortSpecification value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GRPCHealthCheckPortSpecification other && Equals(other);
        public bool Equals(GRPCHealthCheckPortSpecification other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of address to reserve, either INTERNAL or EXTERNAL. If unspecified, defaults to EXTERNAL.
    /// </summary>
    [EnumType]
    public readonly struct GlobalAddressAddressType : IEquatable<GlobalAddressAddressType>
    {
        private readonly string _value;

        private GlobalAddressAddressType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalAddressAddressType DnsForwarding { get; } = new GlobalAddressAddressType("DNS_FORWARDING");
        public static GlobalAddressAddressType External { get; } = new GlobalAddressAddressType("EXTERNAL");
        public static GlobalAddressAddressType Internal { get; } = new GlobalAddressAddressType("INTERNAL");
        public static GlobalAddressAddressType UnspecifiedType { get; } = new GlobalAddressAddressType("UNSPECIFIED_TYPE");

        public static bool operator ==(GlobalAddressAddressType left, GlobalAddressAddressType right) => left.Equals(right);
        public static bool operator !=(GlobalAddressAddressType left, GlobalAddressAddressType right) => !left.Equals(right);

        public static explicit operator string(GlobalAddressAddressType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalAddressAddressType other && Equals(other);
        public bool Equals(GlobalAddressAddressType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP version that will be used by this address. Valid options are IPV4 or IPV6. This can only be specified for a global address.
    /// </summary>
    [EnumType]
    public readonly struct GlobalAddressIpVersion : IEquatable<GlobalAddressIpVersion>
    {
        private readonly string _value;

        private GlobalAddressIpVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalAddressIpVersion Ipv4 { get; } = new GlobalAddressIpVersion("IPV4");
        public static GlobalAddressIpVersion Ipv6 { get; } = new GlobalAddressIpVersion("IPV6");
        public static GlobalAddressIpVersion UnspecifiedVersion { get; } = new GlobalAddressIpVersion("UNSPECIFIED_VERSION");

        public static bool operator ==(GlobalAddressIpVersion left, GlobalAddressIpVersion right) => left.Equals(right);
        public static bool operator !=(GlobalAddressIpVersion left, GlobalAddressIpVersion right) => !left.Equals(right);

        public static explicit operator string(GlobalAddressIpVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalAddressIpVersion other && Equals(other);
        public bool Equals(GlobalAddressIpVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This signifies the networking tier used for configuring this address and can only take the following values: PREMIUM or STANDARD. Global forwarding rules can only be Premium Tier. Regional forwarding rules can be either Premium or Standard Tier. Standard Tier addresses applied to regional forwarding rules can be used with any external load balancer. Regional forwarding rules in Premium Tier can only be used with a network load balancer.
    /// 
    /// If this field is not specified, it is assumed to be PREMIUM.
    /// </summary>
    [EnumType]
    public readonly struct GlobalAddressNetworkTier : IEquatable<GlobalAddressNetworkTier>
    {
        private readonly string _value;

        private GlobalAddressNetworkTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalAddressNetworkTier FixedStandard { get; } = new GlobalAddressNetworkTier("FIXED_STANDARD");
        public static GlobalAddressNetworkTier Premium { get; } = new GlobalAddressNetworkTier("PREMIUM");
        public static GlobalAddressNetworkTier Select { get; } = new GlobalAddressNetworkTier("SELECT");
        public static GlobalAddressNetworkTier Standard { get; } = new GlobalAddressNetworkTier("STANDARD");
        public static GlobalAddressNetworkTier StandardOverridesFixedStandard { get; } = new GlobalAddressNetworkTier("STANDARD_OVERRIDES_FIXED_STANDARD");

        public static bool operator ==(GlobalAddressNetworkTier left, GlobalAddressNetworkTier right) => left.Equals(right);
        public static bool operator !=(GlobalAddressNetworkTier left, GlobalAddressNetworkTier right) => !left.Equals(right);

        public static explicit operator string(GlobalAddressNetworkTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalAddressNetworkTier other && Equals(other);
        public bool Equals(GlobalAddressNetworkTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The purpose of this resource, which can be one of the following values:  
    /// - `GCE_ENDPOINT` for addresses that are used by VM instances, alias IP ranges, internal load balancers, and similar resources. 
    /// - `DNS_RESOLVER` for a DNS resolver address in a subnetwork 
    /// - `VPC_PEERING` for addresses that are reserved for VPC peer networks. 
    /// - `NAT_AUTO` for addresses that are external IP addresses automatically reserved for Cloud NAT. 
    /// - `IPSEC_INTERCONNECT` for addresses created from a private IP range that are reserved for a VLAN attachment in an IPsec-encrypted Cloud Interconnect configuration. These addresses are regional resources.
    /// </summary>
    [EnumType]
    public readonly struct GlobalAddressPurpose : IEquatable<GlobalAddressPurpose>
    {
        private readonly string _value;

        private GlobalAddressPurpose(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalAddressPurpose DnsResolver { get; } = new GlobalAddressPurpose("DNS_RESOLVER");
        public static GlobalAddressPurpose GceEndpoint { get; } = new GlobalAddressPurpose("GCE_ENDPOINT");
        public static GlobalAddressPurpose IpsecInterconnect { get; } = new GlobalAddressPurpose("IPSEC_INTERCONNECT");
        public static GlobalAddressPurpose NatAuto { get; } = new GlobalAddressPurpose("NAT_AUTO");
        public static GlobalAddressPurpose PrivateServiceConnect { get; } = new GlobalAddressPurpose("PRIVATE_SERVICE_CONNECT");
        public static GlobalAddressPurpose PscProducerNatRange { get; } = new GlobalAddressPurpose("PSC_PRODUCER_NAT_RANGE");
        public static GlobalAddressPurpose SharedLoadbalancerVip { get; } = new GlobalAddressPurpose("SHARED_LOADBALANCER_VIP");
        public static GlobalAddressPurpose VpcPeering { get; } = new GlobalAddressPurpose("VPC_PEERING");

        public static bool operator ==(GlobalAddressPurpose left, GlobalAddressPurpose right) => left.Equals(right);
        public static bool operator !=(GlobalAddressPurpose left, GlobalAddressPurpose right) => !left.Equals(right);

        public static explicit operator string(GlobalAddressPurpose value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalAddressPurpose other && Equals(other);
        public bool Equals(GlobalAddressPurpose other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the address, which can be one of RESERVING, RESERVED, or IN_USE. An address that is RESERVING is currently in the process of being reserved. A RESERVED address is currently reserved and available to use. An IN_USE address is currently being used by another resource and is not available.
    /// </summary>
    [EnumType]
    public readonly struct GlobalAddressStatus : IEquatable<GlobalAddressStatus>
    {
        private readonly string _value;

        private GlobalAddressStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalAddressStatus InUse { get; } = new GlobalAddressStatus("IN_USE");
        public static GlobalAddressStatus Reserved { get; } = new GlobalAddressStatus("RESERVED");
        public static GlobalAddressStatus Reserving { get; } = new GlobalAddressStatus("RESERVING");

        public static bool operator ==(GlobalAddressStatus left, GlobalAddressStatus right) => left.Equals(right);
        public static bool operator !=(GlobalAddressStatus left, GlobalAddressStatus right) => !left.Equals(right);

        public static explicit operator string(GlobalAddressStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalAddressStatus other && Equals(other);
        public bool Equals(GlobalAddressStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP protocol to which this rule applies.
    /// 
    /// For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and ICMP.
    /// 
    /// The valid IP protocols are different for different load balancing products:  
    /// - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or ALL is valid. 
    /// - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid.  
    /// - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid. 
    /// - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid. 
    /// - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP or UDP is valid.
    /// </summary>
    [EnumType]
    public readonly struct GlobalForwardingRuleIPProtocol : IEquatable<GlobalForwardingRuleIPProtocol>
    {
        private readonly string _value;

        private GlobalForwardingRuleIPProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalForwardingRuleIPProtocol Ah { get; } = new GlobalForwardingRuleIPProtocol("AH");
        public static GlobalForwardingRuleIPProtocol All { get; } = new GlobalForwardingRuleIPProtocol("ALL");
        public static GlobalForwardingRuleIPProtocol Esp { get; } = new GlobalForwardingRuleIPProtocol("ESP");
        public static GlobalForwardingRuleIPProtocol Icmp { get; } = new GlobalForwardingRuleIPProtocol("ICMP");
        public static GlobalForwardingRuleIPProtocol Sctp { get; } = new GlobalForwardingRuleIPProtocol("SCTP");
        public static GlobalForwardingRuleIPProtocol Tcp { get; } = new GlobalForwardingRuleIPProtocol("TCP");
        public static GlobalForwardingRuleIPProtocol Udp { get; } = new GlobalForwardingRuleIPProtocol("UDP");

        public static bool operator ==(GlobalForwardingRuleIPProtocol left, GlobalForwardingRuleIPProtocol right) => left.Equals(right);
        public static bool operator !=(GlobalForwardingRuleIPProtocol left, GlobalForwardingRuleIPProtocol right) => !left.Equals(right);

        public static explicit operator string(GlobalForwardingRuleIPProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalForwardingRuleIPProtocol other && Equals(other);
        public bool Equals(GlobalForwardingRuleIPProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
    /// </summary>
    [EnumType]
    public readonly struct GlobalForwardingRuleIpVersion : IEquatable<GlobalForwardingRuleIpVersion>
    {
        private readonly string _value;

        private GlobalForwardingRuleIpVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalForwardingRuleIpVersion Ipv4 { get; } = new GlobalForwardingRuleIpVersion("IPV4");
        public static GlobalForwardingRuleIpVersion Ipv6 { get; } = new GlobalForwardingRuleIpVersion("IPV6");
        public static GlobalForwardingRuleIpVersion UnspecifiedVersion { get; } = new GlobalForwardingRuleIpVersion("UNSPECIFIED_VERSION");

        public static bool operator ==(GlobalForwardingRuleIpVersion left, GlobalForwardingRuleIpVersion right) => left.Equals(right);
        public static bool operator !=(GlobalForwardingRuleIpVersion left, GlobalForwardingRuleIpVersion right) => !left.Equals(right);

        public static explicit operator string(GlobalForwardingRuleIpVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalForwardingRuleIpVersion other && Equals(other);
        public bool Equals(GlobalForwardingRuleIpVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the forwarding rule type.
    /// 
    ///  
    /// - EXTERNAL is used for:  
    /// - Classic Cloud VPN gateways 
    /// - Protocol forwarding to VMs from an external IP address 
    /// - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing    
    /// - INTERNAL is used for:  
    /// - Protocol forwarding to VMs from an internal IP address 
    /// - Internal TCP/UDP Load Balancing   
    /// - INTERNAL_MANAGED is used for:  
    /// - Internal HTTP(S) Load Balancing   
    /// - INTERNAL_SELF_MANAGED is used for:  
    /// - Traffic Director    
    /// 
    /// For more information about forwarding rules, refer to Forwarding rule concepts.
    /// </summary>
    [EnumType]
    public readonly struct GlobalForwardingRuleLoadBalancingScheme : IEquatable<GlobalForwardingRuleLoadBalancingScheme>
    {
        private readonly string _value;

        private GlobalForwardingRuleLoadBalancingScheme(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalForwardingRuleLoadBalancingScheme External { get; } = new GlobalForwardingRuleLoadBalancingScheme("EXTERNAL");
        public static GlobalForwardingRuleLoadBalancingScheme ExternalManaged { get; } = new GlobalForwardingRuleLoadBalancingScheme("EXTERNAL_MANAGED");
        public static GlobalForwardingRuleLoadBalancingScheme Internal { get; } = new GlobalForwardingRuleLoadBalancingScheme("INTERNAL");
        public static GlobalForwardingRuleLoadBalancingScheme InternalManaged { get; } = new GlobalForwardingRuleLoadBalancingScheme("INTERNAL_MANAGED");
        public static GlobalForwardingRuleLoadBalancingScheme InternalSelfManaged { get; } = new GlobalForwardingRuleLoadBalancingScheme("INTERNAL_SELF_MANAGED");
        public static GlobalForwardingRuleLoadBalancingScheme Invalid { get; } = new GlobalForwardingRuleLoadBalancingScheme("INVALID");

        public static bool operator ==(GlobalForwardingRuleLoadBalancingScheme left, GlobalForwardingRuleLoadBalancingScheme right) => left.Equals(right);
        public static bool operator !=(GlobalForwardingRuleLoadBalancingScheme left, GlobalForwardingRuleLoadBalancingScheme right) => !left.Equals(right);

        public static explicit operator string(GlobalForwardingRuleLoadBalancingScheme value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalForwardingRuleLoadBalancingScheme other && Equals(other);
        public bool Equals(GlobalForwardingRuleLoadBalancingScheme other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD.
    /// 
    /// For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
    /// 
    /// If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
    /// </summary>
    [EnumType]
    public readonly struct GlobalForwardingRuleNetworkTier : IEquatable<GlobalForwardingRuleNetworkTier>
    {
        private readonly string _value;

        private GlobalForwardingRuleNetworkTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalForwardingRuleNetworkTier FixedStandard { get; } = new GlobalForwardingRuleNetworkTier("FIXED_STANDARD");
        public static GlobalForwardingRuleNetworkTier Premium { get; } = new GlobalForwardingRuleNetworkTier("PREMIUM");
        public static GlobalForwardingRuleNetworkTier Select { get; } = new GlobalForwardingRuleNetworkTier("SELECT");
        public static GlobalForwardingRuleNetworkTier Standard { get; } = new GlobalForwardingRuleNetworkTier("STANDARD");
        public static GlobalForwardingRuleNetworkTier StandardOverridesFixedStandard { get; } = new GlobalForwardingRuleNetworkTier("STANDARD_OVERRIDES_FIXED_STANDARD");

        public static bool operator ==(GlobalForwardingRuleNetworkTier left, GlobalForwardingRuleNetworkTier right) => left.Equals(right);
        public static bool operator !=(GlobalForwardingRuleNetworkTier left, GlobalForwardingRuleNetworkTier right) => !left.Equals(right);

        public static explicit operator string(GlobalForwardingRuleNetworkTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalForwardingRuleNetworkTier other && Equals(other);
        public bool Equals(GlobalForwardingRuleNetworkTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct GlobalForwardingRulePscConnectionStatus : IEquatable<GlobalForwardingRulePscConnectionStatus>
    {
        private readonly string _value;

        private GlobalForwardingRulePscConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalForwardingRulePscConnectionStatus Accepted { get; } = new GlobalForwardingRulePscConnectionStatus("ACCEPTED");
        public static GlobalForwardingRulePscConnectionStatus Closed { get; } = new GlobalForwardingRulePscConnectionStatus("CLOSED");
        public static GlobalForwardingRulePscConnectionStatus Pending { get; } = new GlobalForwardingRulePscConnectionStatus("PENDING");
        public static GlobalForwardingRulePscConnectionStatus Rejected { get; } = new GlobalForwardingRulePscConnectionStatus("REJECTED");
        public static GlobalForwardingRulePscConnectionStatus StatusUnspecified { get; } = new GlobalForwardingRulePscConnectionStatus("STATUS_UNSPECIFIED");

        public static bool operator ==(GlobalForwardingRulePscConnectionStatus left, GlobalForwardingRulePscConnectionStatus right) => left.Equals(right);
        public static bool operator !=(GlobalForwardingRulePscConnectionStatus left, GlobalForwardingRulePscConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(GlobalForwardingRulePscConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalForwardingRulePscConnectionStatus other && Equals(other);
        public bool Equals(GlobalForwardingRulePscConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of network endpoints in this network endpoint group. Can be one of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT, INTERNET_IP_PORT, or SERVERLESS.
    /// </summary>
    [EnumType]
    public readonly struct GlobalNetworkEndpointGroupNetworkEndpointType : IEquatable<GlobalNetworkEndpointGroupNetworkEndpointType>
    {
        private readonly string _value;

        private GlobalNetworkEndpointGroupNetworkEndpointType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalNetworkEndpointGroupNetworkEndpointType GceVmIp { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("GCE_VM_IP");
        public static GlobalNetworkEndpointGroupNetworkEndpointType GceVmIpPort { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("GCE_VM_IP_PORT");
        public static GlobalNetworkEndpointGroupNetworkEndpointType GceVmPrimaryIp { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("GCE_VM_PRIMARY_IP");
        public static GlobalNetworkEndpointGroupNetworkEndpointType InternetFqdnPort { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("INTERNET_FQDN_PORT");
        public static GlobalNetworkEndpointGroupNetworkEndpointType InternetIpPort { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("INTERNET_IP_PORT");
        public static GlobalNetworkEndpointGroupNetworkEndpointType NonGcpPrivateIpPort { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("NON_GCP_PRIVATE_IP_PORT");
        public static GlobalNetworkEndpointGroupNetworkEndpointType PrivateServiceConnect { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("PRIVATE_SERVICE_CONNECT");
        public static GlobalNetworkEndpointGroupNetworkEndpointType Serverless { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("SERVERLESS");

        public static bool operator ==(GlobalNetworkEndpointGroupNetworkEndpointType left, GlobalNetworkEndpointGroupNetworkEndpointType right) => left.Equals(right);
        public static bool operator !=(GlobalNetworkEndpointGroupNetworkEndpointType left, GlobalNetworkEndpointGroupNetworkEndpointType right) => !left.Equals(right);

        public static explicit operator string(GlobalNetworkEndpointGroupNetworkEndpointType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalNetworkEndpointGroupNetworkEndpointType other && Equals(other);
        public bool Equals(GlobalNetworkEndpointGroupNetworkEndpointType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the type of this network endpoint group. Only LOAD_BALANCING is valid for now.
    /// </summary>
    [EnumType]
    public readonly struct GlobalNetworkEndpointGroupType : IEquatable<GlobalNetworkEndpointGroupType>
    {
        private readonly string _value;

        private GlobalNetworkEndpointGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalNetworkEndpointGroupType LoadBalancing { get; } = new GlobalNetworkEndpointGroupType("LOAD_BALANCING");

        public static bool operator ==(GlobalNetworkEndpointGroupType left, GlobalNetworkEndpointGroupType right) => left.Equals(right);
        public static bool operator !=(GlobalNetworkEndpointGroupType left, GlobalNetworkEndpointGroupType right) => !left.Equals(right);

        public static explicit operator string(GlobalNetworkEndpointGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalNetworkEndpointGroupType other && Equals(other);
        public bool Equals(GlobalNetworkEndpointGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the public delegated prefix.
    /// </summary>
    [EnumType]
    public readonly struct GlobalPublicDelegatedPrefixStatus : IEquatable<GlobalPublicDelegatedPrefixStatus>
    {
        private readonly string _value;

        private GlobalPublicDelegatedPrefixStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalPublicDelegatedPrefixStatus Announced { get; } = new GlobalPublicDelegatedPrefixStatus("ANNOUNCED");
        public static GlobalPublicDelegatedPrefixStatus Deleting { get; } = new GlobalPublicDelegatedPrefixStatus("DELETING");
        public static GlobalPublicDelegatedPrefixStatus Initializing { get; } = new GlobalPublicDelegatedPrefixStatus("INITIALIZING");

        public static bool operator ==(GlobalPublicDelegatedPrefixStatus left, GlobalPublicDelegatedPrefixStatus right) => left.Equals(right);
        public static bool operator !=(GlobalPublicDelegatedPrefixStatus left, GlobalPublicDelegatedPrefixStatus right) => !left.Equals(right);

        public static explicit operator string(GlobalPublicDelegatedPrefixStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalPublicDelegatedPrefixStatus other && Equals(other);
        public bool Equals(GlobalPublicDelegatedPrefixStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The ID of a supported feature. Read  Enabling guest operating system features to see a list of available options.
    /// </summary>
    [EnumType]
    public readonly struct GuestOsFeatureType : IEquatable<GuestOsFeatureType>
    {
        private readonly string _value;

        private GuestOsFeatureType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GuestOsFeatureType BareMetalLinuxCompatible { get; } = new GuestOsFeatureType("BARE_METAL_LINUX_COMPATIBLE");
        public static GuestOsFeatureType FeatureTypeUnspecified { get; } = new GuestOsFeatureType("FEATURE_TYPE_UNSPECIFIED");
        public static GuestOsFeatureType Gvnic { get; } = new GuestOsFeatureType("GVNIC");
        public static GuestOsFeatureType MultiIpSubnet { get; } = new GuestOsFeatureType("MULTI_IP_SUBNET");
        public static GuestOsFeatureType SecureBoot { get; } = new GuestOsFeatureType("SECURE_BOOT");
        public static GuestOsFeatureType SevCapable { get; } = new GuestOsFeatureType("SEV_CAPABLE");
        public static GuestOsFeatureType UefiCompatible { get; } = new GuestOsFeatureType("UEFI_COMPATIBLE");
        public static GuestOsFeatureType VirtioScsiMultiqueue { get; } = new GuestOsFeatureType("VIRTIO_SCSI_MULTIQUEUE");
        public static GuestOsFeatureType Windows { get; } = new GuestOsFeatureType("WINDOWS");

        public static bool operator ==(GuestOsFeatureType left, GuestOsFeatureType right) => left.Equals(right);
        public static bool operator !=(GuestOsFeatureType left, GuestOsFeatureType right) => !left.Equals(right);

        public static explicit operator string(GuestOsFeatureType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GuestOsFeatureType other && Equals(other);
        public bool Equals(GuestOsFeatureType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how port is selected for health checking, can be one of following values:
    /// USE_FIXED_PORT: The port number in port is used for health checking.
    /// USE_NAMED_PORT: The portName is used for health checking.
    /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
    /// 
    /// 
    /// If not specified, HTTP2 health check follows behavior specified in port and portName fields.
    /// </summary>
    [EnumType]
    public readonly struct HTTP2HealthCheckPortSpecification : IEquatable<HTTP2HealthCheckPortSpecification>
    {
        private readonly string _value;

        private HTTP2HealthCheckPortSpecification(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HTTP2HealthCheckPortSpecification UseFixedPort { get; } = new HTTP2HealthCheckPortSpecification("USE_FIXED_PORT");
        public static HTTP2HealthCheckPortSpecification UseNamedPort { get; } = new HTTP2HealthCheckPortSpecification("USE_NAMED_PORT");
        public static HTTP2HealthCheckPortSpecification UseServingPort { get; } = new HTTP2HealthCheckPortSpecification("USE_SERVING_PORT");

        public static bool operator ==(HTTP2HealthCheckPortSpecification left, HTTP2HealthCheckPortSpecification right) => left.Equals(right);
        public static bool operator !=(HTTP2HealthCheckPortSpecification left, HTTP2HealthCheckPortSpecification right) => !left.Equals(right);

        public static explicit operator string(HTTP2HealthCheckPortSpecification value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTP2HealthCheckPortSpecification other && Equals(other);
        public bool Equals(HTTP2HealthCheckPortSpecification other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
    /// </summary>
    [EnumType]
    public readonly struct HTTP2HealthCheckProxyHeader : IEquatable<HTTP2HealthCheckProxyHeader>
    {
        private readonly string _value;

        private HTTP2HealthCheckProxyHeader(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HTTP2HealthCheckProxyHeader None { get; } = new HTTP2HealthCheckProxyHeader("NONE");
        public static HTTP2HealthCheckProxyHeader ProxyV1 { get; } = new HTTP2HealthCheckProxyHeader("PROXY_V1");

        public static bool operator ==(HTTP2HealthCheckProxyHeader left, HTTP2HealthCheckProxyHeader right) => left.Equals(right);
        public static bool operator !=(HTTP2HealthCheckProxyHeader left, HTTP2HealthCheckProxyHeader right) => !left.Equals(right);

        public static explicit operator string(HTTP2HealthCheckProxyHeader value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTP2HealthCheckProxyHeader other && Equals(other);
        public bool Equals(HTTP2HealthCheckProxyHeader other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Weight report mode. used for weighted Load Balancing.
    /// </summary>
    [EnumType]
    public readonly struct HTTP2HealthCheckWeightReportMode : IEquatable<HTTP2HealthCheckWeightReportMode>
    {
        private readonly string _value;

        private HTTP2HealthCheckWeightReportMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HTTP2HealthCheckWeightReportMode Disable { get; } = new HTTP2HealthCheckWeightReportMode("DISABLE");
        public static HTTP2HealthCheckWeightReportMode DryRun { get; } = new HTTP2HealthCheckWeightReportMode("DRY_RUN");
        public static HTTP2HealthCheckWeightReportMode Enable { get; } = new HTTP2HealthCheckWeightReportMode("ENABLE");

        public static bool operator ==(HTTP2HealthCheckWeightReportMode left, HTTP2HealthCheckWeightReportMode right) => left.Equals(right);
        public static bool operator !=(HTTP2HealthCheckWeightReportMode left, HTTP2HealthCheckWeightReportMode right) => !left.Equals(right);

        public static explicit operator string(HTTP2HealthCheckWeightReportMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTP2HealthCheckWeightReportMode other && Equals(other);
        public bool Equals(HTTP2HealthCheckWeightReportMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how port is selected for health checking, can be one of following values:
    /// USE_FIXED_PORT: The port number in port is used for health checking.
    /// USE_NAMED_PORT: The portName is used for health checking.
    /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
    /// 
    /// 
    /// If not specified, HTTP health check follows behavior specified in port and portName fields.
    /// </summary>
    [EnumType]
    public readonly struct HTTPHealthCheckPortSpecification : IEquatable<HTTPHealthCheckPortSpecification>
    {
        private readonly string _value;

        private HTTPHealthCheckPortSpecification(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HTTPHealthCheckPortSpecification UseFixedPort { get; } = new HTTPHealthCheckPortSpecification("USE_FIXED_PORT");
        public static HTTPHealthCheckPortSpecification UseNamedPort { get; } = new HTTPHealthCheckPortSpecification("USE_NAMED_PORT");
        public static HTTPHealthCheckPortSpecification UseServingPort { get; } = new HTTPHealthCheckPortSpecification("USE_SERVING_PORT");

        public static bool operator ==(HTTPHealthCheckPortSpecification left, HTTPHealthCheckPortSpecification right) => left.Equals(right);
        public static bool operator !=(HTTPHealthCheckPortSpecification left, HTTPHealthCheckPortSpecification right) => !left.Equals(right);

        public static explicit operator string(HTTPHealthCheckPortSpecification value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTPHealthCheckPortSpecification other && Equals(other);
        public bool Equals(HTTPHealthCheckPortSpecification other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
    /// </summary>
    [EnumType]
    public readonly struct HTTPHealthCheckProxyHeader : IEquatable<HTTPHealthCheckProxyHeader>
    {
        private readonly string _value;

        private HTTPHealthCheckProxyHeader(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HTTPHealthCheckProxyHeader None { get; } = new HTTPHealthCheckProxyHeader("NONE");
        public static HTTPHealthCheckProxyHeader ProxyV1 { get; } = new HTTPHealthCheckProxyHeader("PROXY_V1");

        public static bool operator ==(HTTPHealthCheckProxyHeader left, HTTPHealthCheckProxyHeader right) => left.Equals(right);
        public static bool operator !=(HTTPHealthCheckProxyHeader left, HTTPHealthCheckProxyHeader right) => !left.Equals(right);

        public static explicit operator string(HTTPHealthCheckProxyHeader value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTPHealthCheckProxyHeader other && Equals(other);
        public bool Equals(HTTPHealthCheckProxyHeader other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Weight report mode. used for weighted Load Balancing.
    /// </summary>
    [EnumType]
    public readonly struct HTTPHealthCheckWeightReportMode : IEquatable<HTTPHealthCheckWeightReportMode>
    {
        private readonly string _value;

        private HTTPHealthCheckWeightReportMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HTTPHealthCheckWeightReportMode Disable { get; } = new HTTPHealthCheckWeightReportMode("DISABLE");
        public static HTTPHealthCheckWeightReportMode DryRun { get; } = new HTTPHealthCheckWeightReportMode("DRY_RUN");
        public static HTTPHealthCheckWeightReportMode Enable { get; } = new HTTPHealthCheckWeightReportMode("ENABLE");

        public static bool operator ==(HTTPHealthCheckWeightReportMode left, HTTPHealthCheckWeightReportMode right) => left.Equals(right);
        public static bool operator !=(HTTPHealthCheckWeightReportMode left, HTTPHealthCheckWeightReportMode right) => !left.Equals(right);

        public static explicit operator string(HTTPHealthCheckWeightReportMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTPHealthCheckWeightReportMode other && Equals(other);
        public bool Equals(HTTPHealthCheckWeightReportMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how port is selected for health checking, can be one of following values:
    /// USE_FIXED_PORT: The port number in port is used for health checking.
    /// USE_NAMED_PORT: The portName is used for health checking.
    /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
    /// 
    /// 
    /// If not specified, HTTPS health check follows behavior specified in port and portName fields.
    /// </summary>
    [EnumType]
    public readonly struct HTTPSHealthCheckPortSpecification : IEquatable<HTTPSHealthCheckPortSpecification>
    {
        private readonly string _value;

        private HTTPSHealthCheckPortSpecification(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HTTPSHealthCheckPortSpecification UseFixedPort { get; } = new HTTPSHealthCheckPortSpecification("USE_FIXED_PORT");
        public static HTTPSHealthCheckPortSpecification UseNamedPort { get; } = new HTTPSHealthCheckPortSpecification("USE_NAMED_PORT");
        public static HTTPSHealthCheckPortSpecification UseServingPort { get; } = new HTTPSHealthCheckPortSpecification("USE_SERVING_PORT");

        public static bool operator ==(HTTPSHealthCheckPortSpecification left, HTTPSHealthCheckPortSpecification right) => left.Equals(right);
        public static bool operator !=(HTTPSHealthCheckPortSpecification left, HTTPSHealthCheckPortSpecification right) => !left.Equals(right);

        public static explicit operator string(HTTPSHealthCheckPortSpecification value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTPSHealthCheckPortSpecification other && Equals(other);
        public bool Equals(HTTPSHealthCheckPortSpecification other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
    /// </summary>
    [EnumType]
    public readonly struct HTTPSHealthCheckProxyHeader : IEquatable<HTTPSHealthCheckProxyHeader>
    {
        private readonly string _value;

        private HTTPSHealthCheckProxyHeader(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HTTPSHealthCheckProxyHeader None { get; } = new HTTPSHealthCheckProxyHeader("NONE");
        public static HTTPSHealthCheckProxyHeader ProxyV1 { get; } = new HTTPSHealthCheckProxyHeader("PROXY_V1");

        public static bool operator ==(HTTPSHealthCheckProxyHeader left, HTTPSHealthCheckProxyHeader right) => left.Equals(right);
        public static bool operator !=(HTTPSHealthCheckProxyHeader left, HTTPSHealthCheckProxyHeader right) => !left.Equals(right);

        public static explicit operator string(HTTPSHealthCheckProxyHeader value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTPSHealthCheckProxyHeader other && Equals(other);
        public bool Equals(HTTPSHealthCheckProxyHeader other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Weight report mode. used for weighted Load Balancing.
    /// </summary>
    [EnumType]
    public readonly struct HTTPSHealthCheckWeightReportMode : IEquatable<HTTPSHealthCheckWeightReportMode>
    {
        private readonly string _value;

        private HTTPSHealthCheckWeightReportMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HTTPSHealthCheckWeightReportMode Disable { get; } = new HTTPSHealthCheckWeightReportMode("DISABLE");
        public static HTTPSHealthCheckWeightReportMode DryRun { get; } = new HTTPSHealthCheckWeightReportMode("DRY_RUN");
        public static HTTPSHealthCheckWeightReportMode Enable { get; } = new HTTPSHealthCheckWeightReportMode("ENABLE");

        public static bool operator ==(HTTPSHealthCheckWeightReportMode left, HTTPSHealthCheckWeightReportMode right) => left.Equals(right);
        public static bool operator !=(HTTPSHealthCheckWeightReportMode left, HTTPSHealthCheckWeightReportMode right) => !left.Equals(right);

        public static explicit operator string(HTTPSHealthCheckWeightReportMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTPSHealthCheckWeightReportMode other && Equals(other);
        public bool Equals(HTTPSHealthCheckWeightReportMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS or HTTP2. If not specified, the default is TCP. Exactly one of the protocol-specific health check field must be specified, which must match type field.
    /// </summary>
    [EnumType]
    public readonly struct HealthCheckType : IEquatable<HealthCheckType>
    {
        private readonly string _value;

        private HealthCheckType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HealthCheckType Grpc { get; } = new HealthCheckType("GRPC");
        public static HealthCheckType Http { get; } = new HealthCheckType("HTTP");
        public static HealthCheckType Http2 { get; } = new HealthCheckType("HTTP2");
        public static HealthCheckType Https { get; } = new HealthCheckType("HTTPS");
        public static HealthCheckType Invalid { get; } = new HealthCheckType("INVALID");
        public static HealthCheckType Ssl { get; } = new HealthCheckType("SSL");
        public static HealthCheckType Tcp { get; } = new HealthCheckType("TCP");
        public static HealthCheckType Udp { get; } = new HealthCheckType("UDP");

        public static bool operator ==(HealthCheckType left, HealthCheckType right) => left.Equals(right);
        public static bool operator !=(HealthCheckType left, HealthCheckType right) => !left.Equals(right);

        public static explicit operator string(HealthCheckType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HealthCheckType other && Equals(other);
        public bool Equals(HealthCheckType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The HTTP Status code to use for this RedirectAction.
    /// Supported values are:  
    /// - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301. 
    /// - FOUND, which corresponds to 302. 
    /// - SEE_OTHER which corresponds to 303. 
    /// - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method will be retained. 
    /// - PERMANENT_REDIRECT, which corresponds to 308. In this case, the request method will be retained.
    /// </summary>
    [EnumType]
    public readonly struct HttpRedirectActionRedirectResponseCode : IEquatable<HttpRedirectActionRedirectResponseCode>
    {
        private readonly string _value;

        private HttpRedirectActionRedirectResponseCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HttpRedirectActionRedirectResponseCode Found { get; } = new HttpRedirectActionRedirectResponseCode("FOUND");
        public static HttpRedirectActionRedirectResponseCode MovedPermanentlyDefault { get; } = new HttpRedirectActionRedirectResponseCode("MOVED_PERMANENTLY_DEFAULT");
        public static HttpRedirectActionRedirectResponseCode PermanentRedirect { get; } = new HttpRedirectActionRedirectResponseCode("PERMANENT_REDIRECT");
        public static HttpRedirectActionRedirectResponseCode SeeOther { get; } = new HttpRedirectActionRedirectResponseCode("SEE_OTHER");
        public static HttpRedirectActionRedirectResponseCode TemporaryRedirect { get; } = new HttpRedirectActionRedirectResponseCode("TEMPORARY_REDIRECT");

        public static bool operator ==(HttpRedirectActionRedirectResponseCode left, HttpRedirectActionRedirectResponseCode right) => left.Equals(right);
        public static bool operator !=(HttpRedirectActionRedirectResponseCode left, HttpRedirectActionRedirectResponseCode right) => !left.Equals(right);

        public static explicit operator string(HttpRedirectActionRedirectResponseCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HttpRedirectActionRedirectResponseCode other && Equals(other);
        public bool Equals(HttpRedirectActionRedirectResponseCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format used to encode and transmit the block device, which should be TAR. This is just a container and transmission format and not a runtime format. Provided by the client when the disk image is created.
    /// </summary>
    [EnumType]
    public readonly struct ImageRawDiskContainerType : IEquatable<ImageRawDiskContainerType>
    {
        private readonly string _value;

        private ImageRawDiskContainerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ImageRawDiskContainerType Tar { get; } = new ImageRawDiskContainerType("TAR");

        public static bool operator ==(ImageRawDiskContainerType left, ImageRawDiskContainerType right) => left.Equals(right);
        public static bool operator !=(ImageRawDiskContainerType left, ImageRawDiskContainerType right) => !left.Equals(right);

        public static explicit operator string(ImageRawDiskContainerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImageRawDiskContainerType other && Equals(other);
        public bool Equals(ImageRawDiskContainerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the image used to create this disk. The default and only value is RAW
    /// </summary>
    [EnumType]
    public readonly struct ImageSourceType : IEquatable<ImageSourceType>
    {
        private readonly string _value;

        private ImageSourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ImageSourceType Raw { get; } = new ImageSourceType("RAW");

        public static bool operator ==(ImageSourceType left, ImageSourceType right) => left.Equals(right);
        public static bool operator !=(ImageSourceType left, ImageSourceType right) => !left.Equals(right);

        public static explicit operator string(ImageSourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImageSourceType other && Equals(other);
        public bool Equals(ImageSourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the image. An image can be used to create other resources, such as instances, only after the image has been successfully created and the status is set to READY. Possible values are FAILED, PENDING, or READY.
    /// </summary>
    [EnumType]
    public readonly struct ImageStatus : IEquatable<ImageStatus>
    {
        private readonly string _value;

        private ImageStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ImageStatus Deleting { get; } = new ImageStatus("DELETING");
        public static ImageStatus Failed { get; } = new ImageStatus("FAILED");
        public static ImageStatus Pending { get; } = new ImageStatus("PENDING");
        public static ImageStatus Ready { get; } = new ImageStatus("READY");

        public static bool operator ==(ImageStatus left, ImageStatus right) => left.Equals(right);
        public static bool operator !=(ImageStatus left, ImageStatus right) => !left.Equals(right);

        public static explicit operator string(ImageStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImageStatus other && Equals(other);
        public bool Equals(ImageStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The action to perform in case of zone failure. Only one value is supported, NO_FAILOVER. The default is NO_FAILOVER.
    /// </summary>
    [EnumType]
    public readonly struct InstanceGroupManagerFailoverAction : IEquatable<InstanceGroupManagerFailoverAction>
    {
        private readonly string _value;

        private InstanceGroupManagerFailoverAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstanceGroupManagerFailoverAction NoFailover { get; } = new InstanceGroupManagerFailoverAction("NO_FAILOVER");
        public static InstanceGroupManagerFailoverAction Unknown { get; } = new InstanceGroupManagerFailoverAction("UNKNOWN");

        public static bool operator ==(InstanceGroupManagerFailoverAction left, InstanceGroupManagerFailoverAction right) => left.Equals(right);
        public static bool operator !=(InstanceGroupManagerFailoverAction left, InstanceGroupManagerFailoverAction right) => !left.Equals(right);

        public static explicit operator string(InstanceGroupManagerFailoverAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceGroupManagerFailoverAction other && Equals(other);
        public bool Equals(InstanceGroupManagerFailoverAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The  instance redistribution policy for regional managed instance groups. Valid values are:  
    /// - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region. 
    /// - NONE: For non-autoscaled groups, proactive redistribution is disabled.
    /// </summary>
    [EnumType]
    public readonly struct InstanceGroupManagerUpdatePolicyInstanceRedistributionType : IEquatable<InstanceGroupManagerUpdatePolicyInstanceRedistributionType>
    {
        private readonly string _value;

        private InstanceGroupManagerUpdatePolicyInstanceRedistributionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstanceGroupManagerUpdatePolicyInstanceRedistributionType None { get; } = new InstanceGroupManagerUpdatePolicyInstanceRedistributionType("NONE");
        public static InstanceGroupManagerUpdatePolicyInstanceRedistributionType Proactive { get; } = new InstanceGroupManagerUpdatePolicyInstanceRedistributionType("PROACTIVE");

        public static bool operator ==(InstanceGroupManagerUpdatePolicyInstanceRedistributionType left, InstanceGroupManagerUpdatePolicyInstanceRedistributionType right) => left.Equals(right);
        public static bool operator !=(InstanceGroupManagerUpdatePolicyInstanceRedistributionType left, InstanceGroupManagerUpdatePolicyInstanceRedistributionType right) => !left.Equals(right);

        public static explicit operator string(InstanceGroupManagerUpdatePolicyInstanceRedistributionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceGroupManagerUpdatePolicyInstanceRedistributionType other && Equals(other);
        public bool Equals(InstanceGroupManagerUpdatePolicyInstanceRedistributionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Minimal action to be taken on an instance. You can specify either RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a RESTART, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
    /// </summary>
    [EnumType]
    public readonly struct InstanceGroupManagerUpdatePolicyMinimalAction : IEquatable<InstanceGroupManagerUpdatePolicyMinimalAction>
    {
        private readonly string _value;

        private InstanceGroupManagerUpdatePolicyMinimalAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstanceGroupManagerUpdatePolicyMinimalAction None { get; } = new InstanceGroupManagerUpdatePolicyMinimalAction("NONE");
        public static InstanceGroupManagerUpdatePolicyMinimalAction Refresh { get; } = new InstanceGroupManagerUpdatePolicyMinimalAction("REFRESH");
        public static InstanceGroupManagerUpdatePolicyMinimalAction Replace { get; } = new InstanceGroupManagerUpdatePolicyMinimalAction("REPLACE");
        public static InstanceGroupManagerUpdatePolicyMinimalAction Restart { get; } = new InstanceGroupManagerUpdatePolicyMinimalAction("RESTART");

        public static bool operator ==(InstanceGroupManagerUpdatePolicyMinimalAction left, InstanceGroupManagerUpdatePolicyMinimalAction right) => left.Equals(right);
        public static bool operator !=(InstanceGroupManagerUpdatePolicyMinimalAction left, InstanceGroupManagerUpdatePolicyMinimalAction right) => !left.Equals(right);

        public static explicit operator string(InstanceGroupManagerUpdatePolicyMinimalAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceGroupManagerUpdatePolicyMinimalAction other && Equals(other);
        public bool Equals(InstanceGroupManagerUpdatePolicyMinimalAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
    /// </summary>
    [EnumType]
    public readonly struct InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction : IEquatable<InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction>
    {
        private readonly string _value;

        private InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction None { get; } = new InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction("NONE");
        public static InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction Refresh { get; } = new InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction("REFRESH");
        public static InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction Replace { get; } = new InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction("REPLACE");
        public static InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction Restart { get; } = new InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction("RESTART");

        public static bool operator ==(InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction left, InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction right) => left.Equals(right);
        public static bool operator !=(InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction left, InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction right) => !left.Equals(right);

        public static explicit operator string(InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction other && Equals(other);
        public bool Equals(InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// What action should be used to replace instances. See minimal_action.REPLACE
    /// </summary>
    [EnumType]
    public readonly struct InstanceGroupManagerUpdatePolicyReplacementMethod : IEquatable<InstanceGroupManagerUpdatePolicyReplacementMethod>
    {
        private readonly string _value;

        private InstanceGroupManagerUpdatePolicyReplacementMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstanceGroupManagerUpdatePolicyReplacementMethod Recreate { get; } = new InstanceGroupManagerUpdatePolicyReplacementMethod("RECREATE");
        public static InstanceGroupManagerUpdatePolicyReplacementMethod Substitute { get; } = new InstanceGroupManagerUpdatePolicyReplacementMethod("SUBSTITUTE");

        public static bool operator ==(InstanceGroupManagerUpdatePolicyReplacementMethod left, InstanceGroupManagerUpdatePolicyReplacementMethod right) => left.Equals(right);
        public static bool operator !=(InstanceGroupManagerUpdatePolicyReplacementMethod left, InstanceGroupManagerUpdatePolicyReplacementMethod right) => !left.Equals(right);

        public static explicit operator string(InstanceGroupManagerUpdatePolicyReplacementMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceGroupManagerUpdatePolicyReplacementMethod other && Equals(other);
        public bool Equals(InstanceGroupManagerUpdatePolicyReplacementMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
    /// </summary>
    [EnumType]
    public readonly struct InstanceGroupManagerUpdatePolicyType : IEquatable<InstanceGroupManagerUpdatePolicyType>
    {
        private readonly string _value;

        private InstanceGroupManagerUpdatePolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstanceGroupManagerUpdatePolicyType Opportunistic { get; } = new InstanceGroupManagerUpdatePolicyType("OPPORTUNISTIC");
        public static InstanceGroupManagerUpdatePolicyType Proactive { get; } = new InstanceGroupManagerUpdatePolicyType("PROACTIVE");

        public static bool operator ==(InstanceGroupManagerUpdatePolicyType left, InstanceGroupManagerUpdatePolicyType right) => left.Equals(right);
        public static bool operator !=(InstanceGroupManagerUpdatePolicyType left, InstanceGroupManagerUpdatePolicyType right) => !left.Equals(right);

        public static explicit operator string(InstanceGroupManagerUpdatePolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceGroupManagerUpdatePolicyType other && Equals(other);
        public bool Equals(InstanceGroupManagerUpdatePolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// PostKeyRevocationActionType of the instance.
    /// </summary>
    [EnumType]
    public readonly struct InstancePostKeyRevocationActionType : IEquatable<InstancePostKeyRevocationActionType>
    {
        private readonly string _value;

        private InstancePostKeyRevocationActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstancePostKeyRevocationActionType Noop { get; } = new InstancePostKeyRevocationActionType("NOOP");
        public static InstancePostKeyRevocationActionType PostKeyRevocationActionTypeUnspecified { get; } = new InstancePostKeyRevocationActionType("POST_KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED");
        public static InstancePostKeyRevocationActionType Shutdown { get; } = new InstancePostKeyRevocationActionType("SHUTDOWN");

        public static bool operator ==(InstancePostKeyRevocationActionType left, InstancePostKeyRevocationActionType right) => left.Equals(right);
        public static bool operator !=(InstancePostKeyRevocationActionType left, InstancePostKeyRevocationActionType right) => !left.Equals(right);

        public static explicit operator string(InstancePostKeyRevocationActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstancePostKeyRevocationActionType other && Equals(other);
        public bool Equals(InstancePostKeyRevocationActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The private IPv6 google access type for the VM. If not specified, use  INHERIT_FROM_SUBNETWORK as default.
    /// </summary>
    [EnumType]
    public readonly struct InstancePrivateIpv6GoogleAccess : IEquatable<InstancePrivateIpv6GoogleAccess>
    {
        private readonly string _value;

        private InstancePrivateIpv6GoogleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstancePrivateIpv6GoogleAccess EnableBidirectionalAccessToGoogle { get; } = new InstancePrivateIpv6GoogleAccess("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE");
        public static InstancePrivateIpv6GoogleAccess EnableOutboundVmAccessToGoogle { get; } = new InstancePrivateIpv6GoogleAccess("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE");
        public static InstancePrivateIpv6GoogleAccess InheritFromSubnetwork { get; } = new InstancePrivateIpv6GoogleAccess("INHERIT_FROM_SUBNETWORK");

        public static bool operator ==(InstancePrivateIpv6GoogleAccess left, InstancePrivateIpv6GoogleAccess right) => left.Equals(right);
        public static bool operator !=(InstancePrivateIpv6GoogleAccess left, InstancePrivateIpv6GoogleAccess right) => !left.Equals(right);

        public static explicit operator string(InstancePrivateIpv6GoogleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstancePrivateIpv6GoogleAccess other && Equals(other);
        public bool Equals(InstancePrivateIpv6GoogleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// PostKeyRevocationActionType of the instance.
    /// </summary>
    [EnumType]
    public readonly struct InstancePropertiesPostKeyRevocationActionType : IEquatable<InstancePropertiesPostKeyRevocationActionType>
    {
        private readonly string _value;

        private InstancePropertiesPostKeyRevocationActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstancePropertiesPostKeyRevocationActionType Noop { get; } = new InstancePropertiesPostKeyRevocationActionType("NOOP");
        public static InstancePropertiesPostKeyRevocationActionType PostKeyRevocationActionTypeUnspecified { get; } = new InstancePropertiesPostKeyRevocationActionType("POST_KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED");
        public static InstancePropertiesPostKeyRevocationActionType Shutdown { get; } = new InstancePropertiesPostKeyRevocationActionType("SHUTDOWN");

        public static bool operator ==(InstancePropertiesPostKeyRevocationActionType left, InstancePropertiesPostKeyRevocationActionType right) => left.Equals(right);
        public static bool operator !=(InstancePropertiesPostKeyRevocationActionType left, InstancePropertiesPostKeyRevocationActionType right) => !left.Equals(right);

        public static explicit operator string(InstancePropertiesPostKeyRevocationActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstancePropertiesPostKeyRevocationActionType other && Equals(other);
        public bool Equals(InstancePropertiesPostKeyRevocationActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The private IPv6 google access type for VMs. If not specified, use  INHERIT_FROM_SUBNETWORK as default.
    /// </summary>
    [EnumType]
    public readonly struct InstancePropertiesPrivateIpv6GoogleAccess : IEquatable<InstancePropertiesPrivateIpv6GoogleAccess>
    {
        private readonly string _value;

        private InstancePropertiesPrivateIpv6GoogleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstancePropertiesPrivateIpv6GoogleAccess EnableBidirectionalAccessToGoogle { get; } = new InstancePropertiesPrivateIpv6GoogleAccess("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE");
        public static InstancePropertiesPrivateIpv6GoogleAccess EnableOutboundVmAccessToGoogle { get; } = new InstancePropertiesPrivateIpv6GoogleAccess("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE");
        public static InstancePropertiesPrivateIpv6GoogleAccess InheritFromSubnetwork { get; } = new InstancePropertiesPrivateIpv6GoogleAccess("INHERIT_FROM_SUBNETWORK");

        public static bool operator ==(InstancePropertiesPrivateIpv6GoogleAccess left, InstancePropertiesPrivateIpv6GoogleAccess right) => left.Equals(right);
        public static bool operator !=(InstancePropertiesPrivateIpv6GoogleAccess left, InstancePropertiesPrivateIpv6GoogleAccess right) => !left.Equals(right);

        public static explicit operator string(InstancePropertiesPrivateIpv6GoogleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstancePropertiesPrivateIpv6GoogleAccess other && Equals(other);
        public bool Equals(InstancePropertiesPrivateIpv6GoogleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the instance. One of the following values: PROVISIONING, STAGING, RUNNING, STOPPING, SUSPENDING, SUSPENDED, REPAIRING, and TERMINATED. For more information about the status of the instance, see  Instance life cycle.
    /// </summary>
    [EnumType]
    public readonly struct InstanceStatus : IEquatable<InstanceStatus>
    {
        private readonly string _value;

        private InstanceStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstanceStatus Deprovisioning { get; } = new InstanceStatus("DEPROVISIONING");
        public static InstanceStatus Provisioning { get; } = new InstanceStatus("PROVISIONING");
        public static InstanceStatus Repairing { get; } = new InstanceStatus("REPAIRING");
        public static InstanceStatus Running { get; } = new InstanceStatus("RUNNING");
        public static InstanceStatus Staging { get; } = new InstanceStatus("STAGING");
        public static InstanceStatus Stopped { get; } = new InstanceStatus("STOPPED");
        public static InstanceStatus Stopping { get; } = new InstanceStatus("STOPPING");
        public static InstanceStatus Suspended { get; } = new InstanceStatus("SUSPENDED");
        public static InstanceStatus Suspending { get; } = new InstanceStatus("SUSPENDING");
        public static InstanceStatus Terminated { get; } = new InstanceStatus("TERMINATED");

        public static bool operator ==(InstanceStatus left, InstanceStatus right) => left.Equals(right);
        public static bool operator !=(InstanceStatus left, InstanceStatus right) => !left.Equals(right);

        public static explicit operator string(InstanceStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceStatus other && Equals(other);
        public bool Equals(InstanceStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values: 
    /// - BPS_50M: 50 Mbit/s 
    /// - BPS_100M: 100 Mbit/s 
    /// - BPS_200M: 200 Mbit/s 
    /// - BPS_300M: 300 Mbit/s 
    /// - BPS_400M: 400 Mbit/s 
    /// - BPS_500M: 500 Mbit/s 
    /// - BPS_1G: 1 Gbit/s 
    /// - BPS_2G: 2 Gbit/s 
    /// - BPS_5G: 5 Gbit/s 
    /// - BPS_10G: 10 Gbit/s 
    /// - BPS_20G: 20 Gbit/s 
    /// - BPS_50G: 50 Gbit/s
    /// </summary>
    [EnumType]
    public readonly struct InterconnectAttachmentBandwidth : IEquatable<InterconnectAttachmentBandwidth>
    {
        private readonly string _value;

        private InterconnectAttachmentBandwidth(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterconnectAttachmentBandwidth Bps100m { get; } = new InterconnectAttachmentBandwidth("BPS_100M");
        public static InterconnectAttachmentBandwidth Bps10g { get; } = new InterconnectAttachmentBandwidth("BPS_10G");
        public static InterconnectAttachmentBandwidth Bps1g { get; } = new InterconnectAttachmentBandwidth("BPS_1G");
        public static InterconnectAttachmentBandwidth Bps200m { get; } = new InterconnectAttachmentBandwidth("BPS_200M");
        public static InterconnectAttachmentBandwidth Bps20g { get; } = new InterconnectAttachmentBandwidth("BPS_20G");
        public static InterconnectAttachmentBandwidth Bps2g { get; } = new InterconnectAttachmentBandwidth("BPS_2G");
        public static InterconnectAttachmentBandwidth Bps300m { get; } = new InterconnectAttachmentBandwidth("BPS_300M");
        public static InterconnectAttachmentBandwidth Bps400m { get; } = new InterconnectAttachmentBandwidth("BPS_400M");
        public static InterconnectAttachmentBandwidth Bps500m { get; } = new InterconnectAttachmentBandwidth("BPS_500M");
        public static InterconnectAttachmentBandwidth Bps50g { get; } = new InterconnectAttachmentBandwidth("BPS_50G");
        public static InterconnectAttachmentBandwidth Bps50m { get; } = new InterconnectAttachmentBandwidth("BPS_50M");
        public static InterconnectAttachmentBandwidth Bps5g { get; } = new InterconnectAttachmentBandwidth("BPS_5G");

        public static bool operator ==(InterconnectAttachmentBandwidth left, InterconnectAttachmentBandwidth right) => left.Equals(right);
        public static bool operator !=(InterconnectAttachmentBandwidth left, InterconnectAttachmentBandwidth right) => !left.Equals(right);

        public static explicit operator string(InterconnectAttachmentBandwidth value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectAttachmentBandwidth other && Equals(other);
        public bool Equals(InterconnectAttachmentBandwidth other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values: 
    /// - AVAILABILITY_DOMAIN_ANY 
    /// - AVAILABILITY_DOMAIN_1 
    /// - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectAttachmentEdgeAvailabilityDomain : IEquatable<InterconnectAttachmentEdgeAvailabilityDomain>
    {
        private readonly string _value;

        private InterconnectAttachmentEdgeAvailabilityDomain(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterconnectAttachmentEdgeAvailabilityDomain AvailabilityDomain1 { get; } = new InterconnectAttachmentEdgeAvailabilityDomain("AVAILABILITY_DOMAIN_1");
        public static InterconnectAttachmentEdgeAvailabilityDomain AvailabilityDomain2 { get; } = new InterconnectAttachmentEdgeAvailabilityDomain("AVAILABILITY_DOMAIN_2");
        public static InterconnectAttachmentEdgeAvailabilityDomain AvailabilityDomainAny { get; } = new InterconnectAttachmentEdgeAvailabilityDomain("AVAILABILITY_DOMAIN_ANY");

        public static bool operator ==(InterconnectAttachmentEdgeAvailabilityDomain left, InterconnectAttachmentEdgeAvailabilityDomain right) => left.Equals(right);
        public static bool operator !=(InterconnectAttachmentEdgeAvailabilityDomain left, InterconnectAttachmentEdgeAvailabilityDomain right) => !left.Equals(right);

        public static explicit operator string(InterconnectAttachmentEdgeAvailabilityDomain value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectAttachmentEdgeAvailabilityDomain other && Equals(other);
        public bool Equals(InterconnectAttachmentEdgeAvailabilityDomain other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates the user-supplied encryption option of this interconnect attachment: 
    /// - NONE is the default value, which means that the attachment carries unencrypted traffic. VMs can send traffic to, or receive traffic from, this type of attachment. 
    /// - IPSEC indicates that the attachment carries only traffic encrypted by an IPsec device such as an HA VPN gateway. VMs cannot directly send traffic to, or receive traffic from, such an attachment. To use IPsec-encrypted Cloud Interconnect, create the attachment using this option. 
    /// Not currently available in all Interconnect locations.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectAttachmentEncryption : IEquatable<InterconnectAttachmentEncryption>
    {
        private readonly string _value;

        private InterconnectAttachmentEncryption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterconnectAttachmentEncryption Ipsec { get; } = new InterconnectAttachmentEncryption("IPSEC");
        public static InterconnectAttachmentEncryption None { get; } = new InterconnectAttachmentEncryption("NONE");

        public static bool operator ==(InterconnectAttachmentEncryption left, InterconnectAttachmentEncryption right) => left.Equals(right);
        public static bool operator !=(InterconnectAttachmentEncryption left, InterconnectAttachmentEncryption right) => !left.Equals(right);

        public static explicit operator string(InterconnectAttachmentEncryption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectAttachmentEncryption other && Equals(other);
        public bool Equals(InterconnectAttachmentEncryption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The current status of whether or not this interconnect attachment is functional, which can take one of the following values: 
    /// - OS_ACTIVE: The attachment has been turned up and is ready to use. 
    /// - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectAttachmentOperationalStatus : IEquatable<InterconnectAttachmentOperationalStatus>
    {
        private readonly string _value;

        private InterconnectAttachmentOperationalStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterconnectAttachmentOperationalStatus OsActive { get; } = new InterconnectAttachmentOperationalStatus("OS_ACTIVE");
        public static InterconnectAttachmentOperationalStatus OsUnprovisioned { get; } = new InterconnectAttachmentOperationalStatus("OS_UNPROVISIONED");

        public static bool operator ==(InterconnectAttachmentOperationalStatus left, InterconnectAttachmentOperationalStatus right) => left.Equals(right);
        public static bool operator !=(InterconnectAttachmentOperationalStatus left, InterconnectAttachmentOperationalStatus right) => !left.Equals(right);

        public static explicit operator string(InterconnectAttachmentOperationalStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectAttachmentOperationalStatus other && Equals(other);
        public bool Equals(InterconnectAttachmentOperationalStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The current state of this attachment's functionality. Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state can take one of the following values: 
    /// - ACTIVE: The attachment has been turned up and is ready to use. 
    /// - UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete. 
    /// - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet been configured on the Partner side. 
    /// - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it. 
    /// - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is waiting for a customer to activate it. 
    /// - DEFUNCT: The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was removed, or because the other side of a Partner attachment was deleted.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectAttachmentState : IEquatable<InterconnectAttachmentState>
    {
        private readonly string _value;

        private InterconnectAttachmentState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterconnectAttachmentState Active { get; } = new InterconnectAttachmentState("ACTIVE");
        public static InterconnectAttachmentState Defunct { get; } = new InterconnectAttachmentState("DEFUNCT");
        public static InterconnectAttachmentState PartnerRequestReceived { get; } = new InterconnectAttachmentState("PARTNER_REQUEST_RECEIVED");
        public static InterconnectAttachmentState PendingCustomer { get; } = new InterconnectAttachmentState("PENDING_CUSTOMER");
        public static InterconnectAttachmentState PendingPartner { get; } = new InterconnectAttachmentState("PENDING_PARTNER");
        public static InterconnectAttachmentState StateUnspecified { get; } = new InterconnectAttachmentState("STATE_UNSPECIFIED");
        public static InterconnectAttachmentState Unprovisioned { get; } = new InterconnectAttachmentState("UNPROVISIONED");

        public static bool operator ==(InterconnectAttachmentState left, InterconnectAttachmentState right) => left.Equals(right);
        public static bool operator !=(InterconnectAttachmentState left, InterconnectAttachmentState right) => !left.Equals(right);

        public static explicit operator string(InterconnectAttachmentState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectAttachmentState other && Equals(other);
        public bool Equals(InterconnectAttachmentState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of interconnect attachment this is, which can take one of the following values: 
    /// - DEDICATED: an attachment to a Dedicated Interconnect. 
    /// - PARTNER: an attachment to a Partner Interconnect, created by the customer. 
    /// - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectAttachmentType : IEquatable<InterconnectAttachmentType>
    {
        private readonly string _value;

        private InterconnectAttachmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterconnectAttachmentType Dedicated { get; } = new InterconnectAttachmentType("DEDICATED");
        public static InterconnectAttachmentType Partner { get; } = new InterconnectAttachmentType("PARTNER");
        public static InterconnectAttachmentType PartnerProvider { get; } = new InterconnectAttachmentType("PARTNER_PROVIDER");

        public static bool operator ==(InterconnectAttachmentType left, InterconnectAttachmentType right) => left.Equals(right);
        public static bool operator !=(InterconnectAttachmentType left, InterconnectAttachmentType right) => !left.Equals(right);

        public static explicit operator string(InterconnectAttachmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectAttachmentType other && Equals(other);
        public bool Equals(InterconnectAttachmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of interconnect, which can take one of the following values: 
    /// - PARTNER: A partner-managed interconnection shared between customers though a partner. 
    /// - DEDICATED: A dedicated physical interconnection with the customer. Note that a value IT_PRIVATE has been deprecated in favor of DEDICATED.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectInterconnectType : IEquatable<InterconnectInterconnectType>
    {
        private readonly string _value;

        private InterconnectInterconnectType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterconnectInterconnectType Dedicated { get; } = new InterconnectInterconnectType("DEDICATED");
        public static InterconnectInterconnectType ItPrivate { get; } = new InterconnectInterconnectType("IT_PRIVATE");
        public static InterconnectInterconnectType Partner { get; } = new InterconnectInterconnectType("PARTNER");

        public static bool operator ==(InterconnectInterconnectType left, InterconnectInterconnectType right) => left.Equals(right);
        public static bool operator !=(InterconnectInterconnectType left, InterconnectInterconnectType right) => !left.Equals(right);

        public static explicit operator string(InterconnectInterconnectType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectInterconnectType other && Equals(other);
        public bool Equals(InterconnectInterconnectType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of link requested, which can take one of the following values: 
    /// - LINK_TYPE_ETHERNET_10G_LR: A 10G Ethernet with LR optics 
    /// - LINK_TYPE_ETHERNET_100G_LR: A 100G Ethernet with LR optics. Note that this field indicates the speed of each of the links in the bundle, not the speed of the entire bundle.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectLinkType : IEquatable<InterconnectLinkType>
    {
        private readonly string _value;

        private InterconnectLinkType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterconnectLinkType LinkTypeEthernet100gLr { get; } = new InterconnectLinkType("LINK_TYPE_ETHERNET_100G_LR");
        public static InterconnectLinkType LinkTypeEthernet10gLr { get; } = new InterconnectLinkType("LINK_TYPE_ETHERNET_10G_LR");

        public static bool operator ==(InterconnectLinkType left, InterconnectLinkType right) => left.Equals(right);
        public static bool operator !=(InterconnectLinkType left, InterconnectLinkType right) => !left.Equals(right);

        public static explicit operator string(InterconnectLinkType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectLinkType other && Equals(other);
        public bool Equals(InterconnectLinkType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The current status of this Interconnect's functionality, which can take one of the following values: 
    /// - OS_ACTIVE: A valid Interconnect, which is turned up and is ready to use. Attachments may be provisioned on this Interconnect. 
    /// - OS_UNPROVISIONED: An Interconnect that has not completed turnup. No attachments may be provisioned on this Interconnect. 
    /// - OS_UNDER_MAINTENANCE: An Interconnect that is undergoing internal maintenance. No attachments may be provisioned or updated on this Interconnect.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectOperationalStatus : IEquatable<InterconnectOperationalStatus>
    {
        private readonly string _value;

        private InterconnectOperationalStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterconnectOperationalStatus OsActive { get; } = new InterconnectOperationalStatus("OS_ACTIVE");
        public static InterconnectOperationalStatus OsUnprovisioned { get; } = new InterconnectOperationalStatus("OS_UNPROVISIONED");

        public static bool operator ==(InterconnectOperationalStatus left, InterconnectOperationalStatus right) => left.Equals(right);
        public static bool operator !=(InterconnectOperationalStatus left, InterconnectOperationalStatus right) => !left.Equals(right);

        public static explicit operator string(InterconnectOperationalStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectOperationalStatus other && Equals(other);
        public bool Equals(InterconnectOperationalStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Form this outage is expected to take, which can take one of the following values: 
    /// - OUTAGE: The Interconnect may be completely out of service for some or all of the specified window. 
    /// - PARTIAL_OUTAGE: Some circuits comprising the Interconnect as a whole should remain up, but with reduced bandwidth. Note that the versions of this enum prefixed with "IT_" have been deprecated in favor of the unprefixed values.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectOutageNotificationIssueType : IEquatable<InterconnectOutageNotificationIssueType>
    {
        private readonly string _value;

        private InterconnectOutageNotificationIssueType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterconnectOutageNotificationIssueType ItOutage { get; } = new InterconnectOutageNotificationIssueType("IT_OUTAGE");
        public static InterconnectOutageNotificationIssueType ItPartialOutage { get; } = new InterconnectOutageNotificationIssueType("IT_PARTIAL_OUTAGE");
        public static InterconnectOutageNotificationIssueType Outage { get; } = new InterconnectOutageNotificationIssueType("OUTAGE");
        public static InterconnectOutageNotificationIssueType PartialOutage { get; } = new InterconnectOutageNotificationIssueType("PARTIAL_OUTAGE");

        public static bool operator ==(InterconnectOutageNotificationIssueType left, InterconnectOutageNotificationIssueType right) => left.Equals(right);
        public static bool operator !=(InterconnectOutageNotificationIssueType left, InterconnectOutageNotificationIssueType right) => !left.Equals(right);

        public static explicit operator string(InterconnectOutageNotificationIssueType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectOutageNotificationIssueType other && Equals(other);
        public bool Equals(InterconnectOutageNotificationIssueType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The party that generated this notification, which can take the following value: 
    /// - GOOGLE: this notification as generated by Google. Note that the value of NSRC_GOOGLE has been deprecated in favor of GOOGLE.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectOutageNotificationSource : IEquatable<InterconnectOutageNotificationSource>
    {
        private readonly string _value;

        private InterconnectOutageNotificationSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterconnectOutageNotificationSource Google { get; } = new InterconnectOutageNotificationSource("GOOGLE");
        public static InterconnectOutageNotificationSource NsrcGoogle { get; } = new InterconnectOutageNotificationSource("NSRC_GOOGLE");

        public static bool operator ==(InterconnectOutageNotificationSource left, InterconnectOutageNotificationSource right) => left.Equals(right);
        public static bool operator !=(InterconnectOutageNotificationSource left, InterconnectOutageNotificationSource right) => !left.Equals(right);

        public static explicit operator string(InterconnectOutageNotificationSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectOutageNotificationSource other && Equals(other);
        public bool Equals(InterconnectOutageNotificationSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State of this notification, which can take one of the following values: 
    /// - ACTIVE: This outage notification is active. The event could be in the past, present, or future. See start_time and end_time for scheduling. 
    /// - CANCELLED: The outage associated with this notification was cancelled before the outage was due to start. Note that the versions of this enum prefixed with "NS_" have been deprecated in favor of the unprefixed values.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectOutageNotificationState : IEquatable<InterconnectOutageNotificationState>
    {
        private readonly string _value;

        private InterconnectOutageNotificationState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterconnectOutageNotificationState Active { get; } = new InterconnectOutageNotificationState("ACTIVE");
        public static InterconnectOutageNotificationState Cancelled { get; } = new InterconnectOutageNotificationState("CANCELLED");
        public static InterconnectOutageNotificationState Completed { get; } = new InterconnectOutageNotificationState("COMPLETED");
        public static InterconnectOutageNotificationState NsActive { get; } = new InterconnectOutageNotificationState("NS_ACTIVE");
        public static InterconnectOutageNotificationState NsCanceled { get; } = new InterconnectOutageNotificationState("NS_CANCELED");

        public static bool operator ==(InterconnectOutageNotificationState left, InterconnectOutageNotificationState right) => left.Equals(right);
        public static bool operator !=(InterconnectOutageNotificationState left, InterconnectOutageNotificationState right) => !left.Equals(right);

        public static explicit operator string(InterconnectOutageNotificationState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectOutageNotificationState other && Equals(other);
        public bool Equals(InterconnectOutageNotificationState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The current state of Interconnect functionality, which can take one of the following values: 
    /// - ACTIVE: The Interconnect is valid, turned up and ready to use. Attachments may be provisioned on this Interconnect. 
    /// - UNPROVISIONED: The Interconnect has not completed turnup. No attachments may be provisioned on this Interconnect. 
    /// - UNDER_MAINTENANCE: The Interconnect is undergoing internal maintenance. No attachments may be provisioned or updated on this Interconnect.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectState : IEquatable<InterconnectState>
    {
        private readonly string _value;

        private InterconnectState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterconnectState Active { get; } = new InterconnectState("ACTIVE");
        public static InterconnectState Unprovisioned { get; } = new InterconnectState("UNPROVISIONED");

        public static bool operator ==(InterconnectState left, InterconnectState right) => left.Equals(right);
        public static bool operator !=(InterconnectState left, InterconnectState right) => !left.Equals(right);

        public static explicit operator string(InterconnectState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectState other && Equals(other);
        public bool Equals(InterconnectState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The log_name to populate in the Cloud Audit Record.
    /// </summary>
    [EnumType]
    public readonly struct LogConfigCloudAuditOptionsLogName : IEquatable<LogConfigCloudAuditOptionsLogName>
    {
        private readonly string _value;

        private LogConfigCloudAuditOptionsLogName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LogConfigCloudAuditOptionsLogName AdminActivity { get; } = new LogConfigCloudAuditOptionsLogName("ADMIN_ACTIVITY");
        public static LogConfigCloudAuditOptionsLogName DataAccess { get; } = new LogConfigCloudAuditOptionsLogName("DATA_ACCESS");
        public static LogConfigCloudAuditOptionsLogName UnspecifiedLogName { get; } = new LogConfigCloudAuditOptionsLogName("UNSPECIFIED_LOG_NAME");

        public static bool operator ==(LogConfigCloudAuditOptionsLogName left, LogConfigCloudAuditOptionsLogName right) => left.Equals(right);
        public static bool operator !=(LogConfigCloudAuditOptionsLogName left, LogConfigCloudAuditOptionsLogName right) => !left.Equals(right);

        public static explicit operator string(LogConfigCloudAuditOptionsLogName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogConfigCloudAuditOptionsLogName other && Equals(other);
        public bool Equals(LogConfigCloudAuditOptionsLogName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct LogConfigDataAccessOptionsLogMode : IEquatable<LogConfigDataAccessOptionsLogMode>
    {
        private readonly string _value;

        private LogConfigDataAccessOptionsLogMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LogConfigDataAccessOptionsLogMode LogFailClosed { get; } = new LogConfigDataAccessOptionsLogMode("LOG_FAIL_CLOSED");
        public static LogConfigDataAccessOptionsLogMode LogModeUnspecified { get; } = new LogConfigDataAccessOptionsLogMode("LOG_MODE_UNSPECIFIED");

        public static bool operator ==(LogConfigDataAccessOptionsLogMode left, LogConfigDataAccessOptionsLogMode right) => left.Equals(right);
        public static bool operator !=(LogConfigDataAccessOptionsLogMode left, LogConfigDataAccessOptionsLogMode right) => !left.Equals(right);

        public static explicit operator string(LogConfigDataAccessOptionsLogMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogConfigDataAccessOptionsLogMode other && Equals(other);
        public bool Equals(LogConfigDataAccessOptionsLogMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the machine image. One of the following values: INVALID, CREATING, READY, DELETING, and UPLOADING.
    /// </summary>
    [EnumType]
    public readonly struct MachineImageStatus : IEquatable<MachineImageStatus>
    {
        private readonly string _value;

        private MachineImageStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MachineImageStatus Creating { get; } = new MachineImageStatus("CREATING");
        public static MachineImageStatus Deleting { get; } = new MachineImageStatus("DELETING");
        public static MachineImageStatus Invalid { get; } = new MachineImageStatus("INVALID");
        public static MachineImageStatus Ready { get; } = new MachineImageStatus("READY");
        public static MachineImageStatus Uploading { get; } = new MachineImageStatus("UPLOADING");

        public static bool operator ==(MachineImageStatus left, MachineImageStatus right) => left.Equals(right);
        public static bool operator !=(MachineImageStatus left, MachineImageStatus right) => !left.Equals(right);

        public static explicit operator string(MachineImageStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MachineImageStatus other && Equals(other);
        public bool Equals(MachineImageStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how individual filterLabel matches within the list of filterLabels contribute towards the overall metadataFilter match.
    /// Supported values are:  
    /// - MATCH_ANY: At least one of the filterLabels must have a matching label in the provided metadata. 
    /// - MATCH_ALL: All filterLabels must have matching labels in the provided metadata.
    /// </summary>
    [EnumType]
    public readonly struct MetadataFilterFilterMatchCriteria : IEquatable<MetadataFilterFilterMatchCriteria>
    {
        private readonly string _value;

        private MetadataFilterFilterMatchCriteria(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MetadataFilterFilterMatchCriteria MatchAll { get; } = new MetadataFilterFilterMatchCriteria("MATCH_ALL");
        public static MetadataFilterFilterMatchCriteria MatchAny { get; } = new MetadataFilterFilterMatchCriteria("MATCH_ANY");
        public static MetadataFilterFilterMatchCriteria NotSet { get; } = new MetadataFilterFilterMatchCriteria("NOT_SET");

        public static bool operator ==(MetadataFilterFilterMatchCriteria left, MetadataFilterFilterMatchCriteria right) => left.Equals(right);
        public static bool operator !=(MetadataFilterFilterMatchCriteria left, MetadataFilterFilterMatchCriteria right) => !left.Equals(right);

        public static explicit operator string(MetadataFilterFilterMatchCriteria value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetadataFilterFilterMatchCriteria other && Equals(other);
        public bool Equals(MetadataFilterFilterMatchCriteria other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of network endpoints in this network endpoint group. Can be one of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT, INTERNET_IP_PORT, or SERVERLESS.
    /// </summary>
    [EnumType]
    public readonly struct NetworkEndpointGroupNetworkEndpointType : IEquatable<NetworkEndpointGroupNetworkEndpointType>
    {
        private readonly string _value;

        private NetworkEndpointGroupNetworkEndpointType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkEndpointGroupNetworkEndpointType GceVmIp { get; } = new NetworkEndpointGroupNetworkEndpointType("GCE_VM_IP");
        public static NetworkEndpointGroupNetworkEndpointType GceVmIpPort { get; } = new NetworkEndpointGroupNetworkEndpointType("GCE_VM_IP_PORT");
        public static NetworkEndpointGroupNetworkEndpointType GceVmPrimaryIp { get; } = new NetworkEndpointGroupNetworkEndpointType("GCE_VM_PRIMARY_IP");
        public static NetworkEndpointGroupNetworkEndpointType InternetFqdnPort { get; } = new NetworkEndpointGroupNetworkEndpointType("INTERNET_FQDN_PORT");
        public static NetworkEndpointGroupNetworkEndpointType InternetIpPort { get; } = new NetworkEndpointGroupNetworkEndpointType("INTERNET_IP_PORT");
        public static NetworkEndpointGroupNetworkEndpointType NonGcpPrivateIpPort { get; } = new NetworkEndpointGroupNetworkEndpointType("NON_GCP_PRIVATE_IP_PORT");
        public static NetworkEndpointGroupNetworkEndpointType PrivateServiceConnect { get; } = new NetworkEndpointGroupNetworkEndpointType("PRIVATE_SERVICE_CONNECT");
        public static NetworkEndpointGroupNetworkEndpointType Serverless { get; } = new NetworkEndpointGroupNetworkEndpointType("SERVERLESS");

        public static bool operator ==(NetworkEndpointGroupNetworkEndpointType left, NetworkEndpointGroupNetworkEndpointType right) => left.Equals(right);
        public static bool operator !=(NetworkEndpointGroupNetworkEndpointType left, NetworkEndpointGroupNetworkEndpointType right) => !left.Equals(right);

        public static explicit operator string(NetworkEndpointGroupNetworkEndpointType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkEndpointGroupNetworkEndpointType other && Equals(other);
        public bool Equals(NetworkEndpointGroupNetworkEndpointType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the type of this network endpoint group. Only LOAD_BALANCING is valid for now.
    /// </summary>
    [EnumType]
    public readonly struct NetworkEndpointGroupType : IEquatable<NetworkEndpointGroupType>
    {
        private readonly string _value;

        private NetworkEndpointGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkEndpointGroupType LoadBalancing { get; } = new NetworkEndpointGroupType("LOAD_BALANCING");

        public static bool operator ==(NetworkEndpointGroupType left, NetworkEndpointGroupType right) => left.Equals(right);
        public static bool operator !=(NetworkEndpointGroupType left, NetworkEndpointGroupType right) => !left.Equals(right);

        public static explicit operator string(NetworkEndpointGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkEndpointGroupType other && Equals(other);
        public bool Equals(NetworkEndpointGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork.
    /// 
    /// Valid only if stackType is IPV4_IPV6.
    /// </summary>
    [EnumType]
    public readonly struct NetworkInterfaceIpv6AccessType : IEquatable<NetworkInterfaceIpv6AccessType>
    {
        private readonly string _value;

        private NetworkInterfaceIpv6AccessType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkInterfaceIpv6AccessType External { get; } = new NetworkInterfaceIpv6AccessType("EXTERNAL");
        public static NetworkInterfaceIpv6AccessType Internal { get; } = new NetworkInterfaceIpv6AccessType("INTERNAL");
        public static NetworkInterfaceIpv6AccessType UnspecifiedIpv6AccessType { get; } = new NetworkInterfaceIpv6AccessType("UNSPECIFIED_IPV6_ACCESS_TYPE");

        public static bool operator ==(NetworkInterfaceIpv6AccessType left, NetworkInterfaceIpv6AccessType right) => left.Equals(right);
        public static bool operator !=(NetworkInterfaceIpv6AccessType left, NetworkInterfaceIpv6AccessType right) => !left.Equals(right);

        public static explicit operator string(NetworkInterfaceIpv6AccessType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInterfaceIpv6AccessType other && Equals(other);
        public bool Equals(NetworkInterfaceIpv6AccessType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of vNIC to be used on this interface. This may be gVNIC or VirtioNet.
    /// </summary>
    [EnumType]
    public readonly struct NetworkInterfaceNicType : IEquatable<NetworkInterfaceNicType>
    {
        private readonly string _value;

        private NetworkInterfaceNicType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkInterfaceNicType Gvnic { get; } = new NetworkInterfaceNicType("GVNIC");
        public static NetworkInterfaceNicType UnspecifiedNicType { get; } = new NetworkInterfaceNicType("UNSPECIFIED_NIC_TYPE");
        public static NetworkInterfaceNicType VirtioNet { get; } = new NetworkInterfaceNicType("VIRTIO_NET");

        public static bool operator ==(NetworkInterfaceNicType left, NetworkInterfaceNicType right) => left.Equals(right);
        public static bool operator !=(NetworkInterfaceNicType left, NetworkInterfaceNicType right) => !left.Equals(right);

        public static explicit operator string(NetworkInterfaceNicType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInterfaceNicType other && Equals(other);
        public bool Equals(NetworkInterfaceNicType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used.
    /// 
    /// This field can be both set at instance creation and update network interface operations.
    /// </summary>
    [EnumType]
    public readonly struct NetworkInterfaceStackType : IEquatable<NetworkInterfaceStackType>
    {
        private readonly string _value;

        private NetworkInterfaceStackType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkInterfaceStackType Ipv4Ipv6 { get; } = new NetworkInterfaceStackType("IPV4_IPV6");
        public static NetworkInterfaceStackType Ipv4Only { get; } = new NetworkInterfaceStackType("IPV4_ONLY");
        public static NetworkInterfaceStackType UnspecifiedStackType { get; } = new NetworkInterfaceStackType("UNSPECIFIED_STACK_TYPE");

        public static bool operator ==(NetworkInterfaceStackType left, NetworkInterfaceStackType right) => left.Equals(right);
        public static bool operator !=(NetworkInterfaceStackType left, NetworkInterfaceStackType right) => !left.Equals(right);

        public static explicit operator string(NetworkInterfaceStackType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInterfaceStackType other && Equals(other);
        public bool Equals(NetworkInterfaceStackType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The peering is `ACTIVE` when there's a matching configuration in the peer network.
    /// </summary>
    [EnumType]
    public readonly struct NetworkPeeringState : IEquatable<NetworkPeeringState>
    {
        private readonly string _value;

        private NetworkPeeringState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkPeeringState Active { get; } = new NetworkPeeringState("ACTIVE");
        public static NetworkPeeringState Inactive { get; } = new NetworkPeeringState("INACTIVE");

        public static bool operator ==(NetworkPeeringState left, NetworkPeeringState right) => left.Equals(right);
        public static bool operator !=(NetworkPeeringState left, NetworkPeeringState right) => !left.Equals(right);

        public static explicit operator string(NetworkPeeringState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkPeeringState other && Equals(other);
        public bool Equals(NetworkPeeringState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct NetworkPerformanceConfigExternalIpEgressBandwidthTier : IEquatable<NetworkPerformanceConfigExternalIpEgressBandwidthTier>
    {
        private readonly string _value;

        private NetworkPerformanceConfigExternalIpEgressBandwidthTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkPerformanceConfigExternalIpEgressBandwidthTier Default { get; } = new NetworkPerformanceConfigExternalIpEgressBandwidthTier("DEFAULT");
        public static NetworkPerformanceConfigExternalIpEgressBandwidthTier Tier1 { get; } = new NetworkPerformanceConfigExternalIpEgressBandwidthTier("TIER_1");

        public static bool operator ==(NetworkPerformanceConfigExternalIpEgressBandwidthTier left, NetworkPerformanceConfigExternalIpEgressBandwidthTier right) => left.Equals(right);
        public static bool operator !=(NetworkPerformanceConfigExternalIpEgressBandwidthTier left, NetworkPerformanceConfigExternalIpEgressBandwidthTier right) => !left.Equals(right);

        public static explicit operator string(NetworkPerformanceConfigExternalIpEgressBandwidthTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkPerformanceConfigExternalIpEgressBandwidthTier other && Equals(other);
        public bool Equals(NetworkPerformanceConfigExternalIpEgressBandwidthTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct NetworkPerformanceConfigTotalEgressBandwidthTier : IEquatable<NetworkPerformanceConfigTotalEgressBandwidthTier>
    {
        private readonly string _value;

        private NetworkPerformanceConfigTotalEgressBandwidthTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkPerformanceConfigTotalEgressBandwidthTier Default { get; } = new NetworkPerformanceConfigTotalEgressBandwidthTier("DEFAULT");
        public static NetworkPerformanceConfigTotalEgressBandwidthTier Tier1 { get; } = new NetworkPerformanceConfigTotalEgressBandwidthTier("TIER_1");

        public static bool operator ==(NetworkPerformanceConfigTotalEgressBandwidthTier left, NetworkPerformanceConfigTotalEgressBandwidthTier right) => left.Equals(right);
        public static bool operator !=(NetworkPerformanceConfigTotalEgressBandwidthTier left, NetworkPerformanceConfigTotalEgressBandwidthTier right) => !left.Equals(right);

        public static explicit operator string(NetworkPerformanceConfigTotalEgressBandwidthTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkPerformanceConfigTotalEgressBandwidthTier other && Equals(other);
        public bool Equals(NetworkPerformanceConfigTotalEgressBandwidthTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The network-wide routing mode to use. If set to REGIONAL, this network's Cloud Routers will only advertise routes with subnets of this network in the same region as the router. If set to GLOBAL, this network's Cloud Routers will advertise routes with all subnets of this network, across regions.
    /// </summary>
    [EnumType]
    public readonly struct NetworkRoutingConfigRoutingMode : IEquatable<NetworkRoutingConfigRoutingMode>
    {
        private readonly string _value;

        private NetworkRoutingConfigRoutingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkRoutingConfigRoutingMode Global { get; } = new NetworkRoutingConfigRoutingMode("GLOBAL");
        public static NetworkRoutingConfigRoutingMode Regional { get; } = new NetworkRoutingConfigRoutingMode("REGIONAL");

        public static bool operator ==(NetworkRoutingConfigRoutingMode left, NetworkRoutingConfigRoutingMode right) => left.Equals(right);
        public static bool operator !=(NetworkRoutingConfigRoutingMode left, NetworkRoutingConfigRoutingMode right) => !left.Equals(right);

        public static explicit operator string(NetworkRoutingConfigRoutingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkRoutingConfigRoutingMode other && Equals(other);
        public bool Equals(NetworkRoutingConfigRoutingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The autoscaling mode. Set to one of: ON, OFF, or ONLY_SCALE_OUT. For more information, see  Autoscaler modes.
    /// </summary>
    [EnumType]
    public readonly struct NodeGroupAutoscalingPolicyMode : IEquatable<NodeGroupAutoscalingPolicyMode>
    {
        private readonly string _value;

        private NodeGroupAutoscalingPolicyMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NodeGroupAutoscalingPolicyMode ModeUnspecified { get; } = new NodeGroupAutoscalingPolicyMode("MODE_UNSPECIFIED");
        public static NodeGroupAutoscalingPolicyMode Off { get; } = new NodeGroupAutoscalingPolicyMode("OFF");
        public static NodeGroupAutoscalingPolicyMode On { get; } = new NodeGroupAutoscalingPolicyMode("ON");
        public static NodeGroupAutoscalingPolicyMode OnlyScaleOut { get; } = new NodeGroupAutoscalingPolicyMode("ONLY_SCALE_OUT");

        public static bool operator ==(NodeGroupAutoscalingPolicyMode left, NodeGroupAutoscalingPolicyMode right) => left.Equals(right);
        public static bool operator !=(NodeGroupAutoscalingPolicyMode left, NodeGroupAutoscalingPolicyMode right) => !left.Equals(right);

        public static explicit operator string(NodeGroupAutoscalingPolicyMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeGroupAutoscalingPolicyMode other && Equals(other);
        public bool Equals(NodeGroupAutoscalingPolicyMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how to handle instances when a node in the group undergoes maintenance. Set to one of: DEFAULT, RESTART_IN_PLACE, or MIGRATE_WITHIN_NODE_GROUP. The default value is DEFAULT. For more information, see  Maintenance policies.
    /// </summary>
    [EnumType]
    public readonly struct NodeGroupMaintenancePolicy : IEquatable<NodeGroupMaintenancePolicy>
    {
        private readonly string _value;

        private NodeGroupMaintenancePolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NodeGroupMaintenancePolicy Default { get; } = new NodeGroupMaintenancePolicy("DEFAULT");
        public static NodeGroupMaintenancePolicy MaintenancePolicyUnspecified { get; } = new NodeGroupMaintenancePolicy("MAINTENANCE_POLICY_UNSPECIFIED");
        public static NodeGroupMaintenancePolicy MigrateWithinNodeGroup { get; } = new NodeGroupMaintenancePolicy("MIGRATE_WITHIN_NODE_GROUP");
        public static NodeGroupMaintenancePolicy RestartInPlace { get; } = new NodeGroupMaintenancePolicy("RESTART_IN_PLACE");

        public static bool operator ==(NodeGroupMaintenancePolicy left, NodeGroupMaintenancePolicy right) => left.Equals(right);
        public static bool operator !=(NodeGroupMaintenancePolicy left, NodeGroupMaintenancePolicy right) => !left.Equals(right);

        public static explicit operator string(NodeGroupMaintenancePolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeGroupMaintenancePolicy other && Equals(other);
        public bool Equals(NodeGroupMaintenancePolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct NodeGroupStatus : IEquatable<NodeGroupStatus>
    {
        private readonly string _value;

        private NodeGroupStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NodeGroupStatus Creating { get; } = new NodeGroupStatus("CREATING");
        public static NodeGroupStatus Deleting { get; } = new NodeGroupStatus("DELETING");
        public static NodeGroupStatus Invalid { get; } = new NodeGroupStatus("INVALID");
        public static NodeGroupStatus Ready { get; } = new NodeGroupStatus("READY");

        public static bool operator ==(NodeGroupStatus left, NodeGroupStatus right) => left.Equals(right);
        public static bool operator !=(NodeGroupStatus left, NodeGroupStatus right) => !left.Equals(right);

        public static explicit operator string(NodeGroupStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeGroupStatus other && Equals(other);
        public bool Equals(NodeGroupStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// CPU overcommit.
    /// </summary>
    [EnumType]
    public readonly struct NodeTemplateCpuOvercommitType : IEquatable<NodeTemplateCpuOvercommitType>
    {
        private readonly string _value;

        private NodeTemplateCpuOvercommitType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NodeTemplateCpuOvercommitType CpuOvercommitTypeUnspecified { get; } = new NodeTemplateCpuOvercommitType("CPU_OVERCOMMIT_TYPE_UNSPECIFIED");
        public static NodeTemplateCpuOvercommitType Enabled { get; } = new NodeTemplateCpuOvercommitType("ENABLED");
        public static NodeTemplateCpuOvercommitType None { get; } = new NodeTemplateCpuOvercommitType("NONE");

        public static bool operator ==(NodeTemplateCpuOvercommitType left, NodeTemplateCpuOvercommitType right) => left.Equals(right);
        public static bool operator !=(NodeTemplateCpuOvercommitType left, NodeTemplateCpuOvercommitType right) => !left.Equals(right);

        public static explicit operator string(NodeTemplateCpuOvercommitType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeTemplateCpuOvercommitType other && Equals(other);
        public bool Equals(NodeTemplateCpuOvercommitType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the node template. One of the following values: CREATING, READY, and DELETING.
    /// </summary>
    [EnumType]
    public readonly struct NodeTemplateStatus : IEquatable<NodeTemplateStatus>
    {
        private readonly string _value;

        private NodeTemplateStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NodeTemplateStatus Creating { get; } = new NodeTemplateStatus("CREATING");
        public static NodeTemplateStatus Deleting { get; } = new NodeTemplateStatus("DELETING");
        public static NodeTemplateStatus Invalid { get; } = new NodeTemplateStatus("INVALID");
        public static NodeTemplateStatus Ready { get; } = new NodeTemplateStatus("READY");

        public static bool operator ==(NodeTemplateStatus left, NodeTemplateStatus right) => left.Equals(right);
        public static bool operator !=(NodeTemplateStatus left, NodeTemplateStatus right) => !left.Equals(right);

        public static explicit operator string(NodeTemplateStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeTemplateStatus other && Equals(other);
        public bool Equals(NodeTemplateStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type indicates the intended use of the security policy. CLOUD_ARMOR policies apply to backend services. FIREWALL policies apply to organizations.
    /// </summary>
    [EnumType]
    public readonly struct OrganizationSecurityPolicyType : IEquatable<OrganizationSecurityPolicyType>
    {
        private readonly string _value;

        private OrganizationSecurityPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OrganizationSecurityPolicyType CloudArmor { get; } = new OrganizationSecurityPolicyType("CLOUD_ARMOR");
        public static OrganizationSecurityPolicyType CloudArmorEdge { get; } = new OrganizationSecurityPolicyType("CLOUD_ARMOR_EDGE");
        public static OrganizationSecurityPolicyType Firewall { get; } = new OrganizationSecurityPolicyType("FIREWALL");

        public static bool operator ==(OrganizationSecurityPolicyType left, OrganizationSecurityPolicyType right) => left.Equals(right);
        public static bool operator !=(OrganizationSecurityPolicyType left, OrganizationSecurityPolicyType right) => !left.Equals(right);

        public static explicit operator string(OrganizationSecurityPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OrganizationSecurityPolicyType other && Equals(other);
        public bool Equals(OrganizationSecurityPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether or not this packet mirroring takes effect. If set to FALSE, this packet mirroring policy will not be enforced on the network.
    /// 
    /// The default is TRUE.
    /// </summary>
    [EnumType]
    public readonly struct PacketMirroringEnable : IEquatable<PacketMirroringEnable>
    {
        private readonly string _value;

        private PacketMirroringEnable(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PacketMirroringEnable False { get; } = new PacketMirroringEnable("FALSE");
        public static PacketMirroringEnable True { get; } = new PacketMirroringEnable("TRUE");

        public static bool operator ==(PacketMirroringEnable left, PacketMirroringEnable right) => left.Equals(right);
        public static bool operator !=(PacketMirroringEnable left, PacketMirroringEnable right) => !left.Equals(right);

        public static explicit operator string(PacketMirroringEnable value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PacketMirroringEnable other && Equals(other);
        public bool Equals(PacketMirroringEnable other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Direction of traffic to mirror, either INGRESS, EGRESS, or BOTH. The default is BOTH.
    /// </summary>
    [EnumType]
    public readonly struct PacketMirroringFilterDirection : IEquatable<PacketMirroringFilterDirection>
    {
        private readonly string _value;

        private PacketMirroringFilterDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PacketMirroringFilterDirection Both { get; } = new PacketMirroringFilterDirection("BOTH");
        public static PacketMirroringFilterDirection Egress { get; } = new PacketMirroringFilterDirection("EGRESS");
        public static PacketMirroringFilterDirection Ingress { get; } = new PacketMirroringFilterDirection("INGRESS");

        public static bool operator ==(PacketMirroringFilterDirection left, PacketMirroringFilterDirection right) => left.Equals(right);
        public static bool operator !=(PacketMirroringFilterDirection left, PacketMirroringFilterDirection right) => !left.Equals(right);

        public static explicit operator string(PacketMirroringFilterDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PacketMirroringFilterDirection other && Equals(other);
        public bool Equals(PacketMirroringFilterDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of the public advertised prefix.
    /// </summary>
    [EnumType]
    public readonly struct PublicAdvertisedPrefixStatus : IEquatable<PublicAdvertisedPrefixStatus>
    {
        private readonly string _value;

        private PublicAdvertisedPrefixStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicAdvertisedPrefixStatus Initial { get; } = new PublicAdvertisedPrefixStatus("INITIAL");
        public static PublicAdvertisedPrefixStatus PrefixConfigurationComplete { get; } = new PublicAdvertisedPrefixStatus("PREFIX_CONFIGURATION_COMPLETE");
        public static PublicAdvertisedPrefixStatus PrefixConfigurationInProgress { get; } = new PublicAdvertisedPrefixStatus("PREFIX_CONFIGURATION_IN_PROGRESS");
        public static PublicAdvertisedPrefixStatus PrefixRemovalInProgress { get; } = new PublicAdvertisedPrefixStatus("PREFIX_REMOVAL_IN_PROGRESS");
        public static PublicAdvertisedPrefixStatus PtrConfigured { get; } = new PublicAdvertisedPrefixStatus("PTR_CONFIGURED");
        public static PublicAdvertisedPrefixStatus ReverseDnsLookupFailed { get; } = new PublicAdvertisedPrefixStatus("REVERSE_DNS_LOOKUP_FAILED");
        public static PublicAdvertisedPrefixStatus Validated { get; } = new PublicAdvertisedPrefixStatus("VALIDATED");

        public static bool operator ==(PublicAdvertisedPrefixStatus left, PublicAdvertisedPrefixStatus right) => left.Equals(right);
        public static bool operator !=(PublicAdvertisedPrefixStatus left, PublicAdvertisedPrefixStatus right) => !left.Equals(right);

        public static explicit operator string(PublicAdvertisedPrefixStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicAdvertisedPrefixStatus other && Equals(other);
        public bool Equals(PublicAdvertisedPrefixStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the sub public delegated prefix.
    /// </summary>
    [EnumType]
    public readonly struct PublicDelegatedPrefixPublicDelegatedSubPrefixStatus : IEquatable<PublicDelegatedPrefixPublicDelegatedSubPrefixStatus>
    {
        private readonly string _value;

        private PublicDelegatedPrefixPublicDelegatedSubPrefixStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicDelegatedPrefixPublicDelegatedSubPrefixStatus Active { get; } = new PublicDelegatedPrefixPublicDelegatedSubPrefixStatus("ACTIVE");
        public static PublicDelegatedPrefixPublicDelegatedSubPrefixStatus Inactive { get; } = new PublicDelegatedPrefixPublicDelegatedSubPrefixStatus("INACTIVE");

        public static bool operator ==(PublicDelegatedPrefixPublicDelegatedSubPrefixStatus left, PublicDelegatedPrefixPublicDelegatedSubPrefixStatus right) => left.Equals(right);
        public static bool operator !=(PublicDelegatedPrefixPublicDelegatedSubPrefixStatus left, PublicDelegatedPrefixPublicDelegatedSubPrefixStatus right) => !left.Equals(right);

        public static explicit operator string(PublicDelegatedPrefixPublicDelegatedSubPrefixStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicDelegatedPrefixPublicDelegatedSubPrefixStatus other && Equals(other);
        public bool Equals(PublicDelegatedPrefixPublicDelegatedSubPrefixStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the public delegated prefix.
    /// </summary>
    [EnumType]
    public readonly struct PublicDelegatedPrefixStatus : IEquatable<PublicDelegatedPrefixStatus>
    {
        private readonly string _value;

        private PublicDelegatedPrefixStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicDelegatedPrefixStatus Announced { get; } = new PublicDelegatedPrefixStatus("ANNOUNCED");
        public static PublicDelegatedPrefixStatus Deleting { get; } = new PublicDelegatedPrefixStatus("DELETING");
        public static PublicDelegatedPrefixStatus Initializing { get; } = new PublicDelegatedPrefixStatus("INITIALIZING");

        public static bool operator ==(PublicDelegatedPrefixStatus left, PublicDelegatedPrefixStatus right) => left.Equals(right);
        public static bool operator !=(PublicDelegatedPrefixStatus left, PublicDelegatedPrefixStatus right) => !left.Equals(right);

        public static explicit operator string(PublicDelegatedPrefixStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicDelegatedPrefixStatus other && Equals(other);
        public bool Equals(PublicDelegatedPrefixStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the autoscaler configuration. Current set of possible values:  
    /// - PENDING: Autoscaler backend hasn't read new/updated configuration. 
    /// - DELETING: Configuration is being deleted. 
    /// - ACTIVE: Configuration is acknowledged to be effective. Some warnings might be present in the statusDetails field. 
    /// - ERROR: Configuration has errors. Actionable for users. Details are present in the statusDetails field.  New values might be added in the future.
    /// </summary>
    [EnumType]
    public readonly struct RegionAutoscalerStatus : IEquatable<RegionAutoscalerStatus>
    {
        private readonly string _value;

        private RegionAutoscalerStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionAutoscalerStatus Active { get; } = new RegionAutoscalerStatus("ACTIVE");
        public static RegionAutoscalerStatus Deleting { get; } = new RegionAutoscalerStatus("DELETING");
        public static RegionAutoscalerStatus Error { get; } = new RegionAutoscalerStatus("ERROR");
        public static RegionAutoscalerStatus Pending { get; } = new RegionAutoscalerStatus("PENDING");

        public static bool operator ==(RegionAutoscalerStatus left, RegionAutoscalerStatus right) => left.Equals(right);
        public static bool operator !=(RegionAutoscalerStatus left, RegionAutoscalerStatus right) => !left.Equals(right);

        public static explicit operator string(RegionAutoscalerStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionAutoscalerStatus other && Equals(other);
        public bool Equals(RegionAutoscalerStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose  INTERNAL for Internal TCP/UDP Load Balancing. Choose  INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.  INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
    /// </summary>
    [EnumType]
    public readonly struct RegionBackendServiceLoadBalancingScheme : IEquatable<RegionBackendServiceLoadBalancingScheme>
    {
        private readonly string _value;

        private RegionBackendServiceLoadBalancingScheme(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionBackendServiceLoadBalancingScheme External { get; } = new RegionBackendServiceLoadBalancingScheme("EXTERNAL");
        public static RegionBackendServiceLoadBalancingScheme ExternalManaged { get; } = new RegionBackendServiceLoadBalancingScheme("EXTERNAL_MANAGED");
        public static RegionBackendServiceLoadBalancingScheme Internal { get; } = new RegionBackendServiceLoadBalancingScheme("INTERNAL");
        public static RegionBackendServiceLoadBalancingScheme InternalManaged { get; } = new RegionBackendServiceLoadBalancingScheme("INTERNAL_MANAGED");
        public static RegionBackendServiceLoadBalancingScheme InternalSelfManaged { get; } = new RegionBackendServiceLoadBalancingScheme("INTERNAL_SELF_MANAGED");
        public static RegionBackendServiceLoadBalancingScheme InvalidLoadBalancingScheme { get; } = new RegionBackendServiceLoadBalancingScheme("INVALID_LOAD_BALANCING_SCHEME");

        public static bool operator ==(RegionBackendServiceLoadBalancingScheme left, RegionBackendServiceLoadBalancingScheme right) => left.Equals(right);
        public static bool operator !=(RegionBackendServiceLoadBalancingScheme left, RegionBackendServiceLoadBalancingScheme right) => !left.Equals(right);

        public static explicit operator string(RegionBackendServiceLoadBalancingScheme value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionBackendServiceLoadBalancingScheme other && Equals(other);
        public bool Equals(RegionBackendServiceLoadBalancingScheme other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The load balancing algorithm used within the scope of the locality. The possible values are:  
    /// - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default. 
    /// - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests. 
    /// - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests. 
    /// - RANDOM: The load balancer selects a random healthy host. 
    /// - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer. 
    /// - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824 
    /// 
    /// This field is applicable to either:  
    /// - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED. 
    /// - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.  
    /// 
    /// If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect.
    /// 
    /// Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
    /// </summary>
    [EnumType]
    public readonly struct RegionBackendServiceLocalityLbPolicy : IEquatable<RegionBackendServiceLocalityLbPolicy>
    {
        private readonly string _value;

        private RegionBackendServiceLocalityLbPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionBackendServiceLocalityLbPolicy InvalidLbPolicy { get; } = new RegionBackendServiceLocalityLbPolicy("INVALID_LB_POLICY");
        public static RegionBackendServiceLocalityLbPolicy LeastRequest { get; } = new RegionBackendServiceLocalityLbPolicy("LEAST_REQUEST");
        public static RegionBackendServiceLocalityLbPolicy Maglev { get; } = new RegionBackendServiceLocalityLbPolicy("MAGLEV");
        public static RegionBackendServiceLocalityLbPolicy OriginalDestination { get; } = new RegionBackendServiceLocalityLbPolicy("ORIGINAL_DESTINATION");
        public static RegionBackendServiceLocalityLbPolicy Random { get; } = new RegionBackendServiceLocalityLbPolicy("RANDOM");
        public static RegionBackendServiceLocalityLbPolicy RingHash { get; } = new RegionBackendServiceLocalityLbPolicy("RING_HASH");
        public static RegionBackendServiceLocalityLbPolicy RoundRobin { get; } = new RegionBackendServiceLocalityLbPolicy("ROUND_ROBIN");

        public static bool operator ==(RegionBackendServiceLocalityLbPolicy left, RegionBackendServiceLocalityLbPolicy right) => left.Equals(right);
        public static bool operator !=(RegionBackendServiceLocalityLbPolicy left, RegionBackendServiceLocalityLbPolicy right) => !left.Equals(right);

        public static explicit operator string(RegionBackendServiceLocalityLbPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionBackendServiceLocalityLbPolicy other && Equals(other);
        public bool Equals(RegionBackendServiceLocalityLbPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol this BackendService uses to communicate with backends.
    /// 
    /// Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information.
    /// 
    /// Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
    /// </summary>
    [EnumType]
    public readonly struct RegionBackendServiceProtocol : IEquatable<RegionBackendServiceProtocol>
    {
        private readonly string _value;

        private RegionBackendServiceProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionBackendServiceProtocol All { get; } = new RegionBackendServiceProtocol("ALL");
        public static RegionBackendServiceProtocol Grpc { get; } = new RegionBackendServiceProtocol("GRPC");
        public static RegionBackendServiceProtocol Http { get; } = new RegionBackendServiceProtocol("HTTP");
        public static RegionBackendServiceProtocol Http2 { get; } = new RegionBackendServiceProtocol("HTTP2");
        public static RegionBackendServiceProtocol Https { get; } = new RegionBackendServiceProtocol("HTTPS");
        public static RegionBackendServiceProtocol Ssl { get; } = new RegionBackendServiceProtocol("SSL");
        public static RegionBackendServiceProtocol Tcp { get; } = new RegionBackendServiceProtocol("TCP");
        public static RegionBackendServiceProtocol Udp { get; } = new RegionBackendServiceProtocol("UDP");

        public static bool operator ==(RegionBackendServiceProtocol left, RegionBackendServiceProtocol right) => left.Equals(right);
        public static bool operator !=(RegionBackendServiceProtocol left, RegionBackendServiceProtocol right) => !left.Equals(right);

        public static explicit operator string(RegionBackendServiceProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionBackendServiceProtocol other && Equals(other);
        public bool Equals(RegionBackendServiceProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of session affinity to use. The default is NONE.
    /// 
    /// When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or  CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS.
    /// 
    /// When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
    /// 
    /// When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
    /// 
    /// Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
    /// </summary>
    [EnumType]
    public readonly struct RegionBackendServiceSessionAffinity : IEquatable<RegionBackendServiceSessionAffinity>
    {
        private readonly string _value;

        private RegionBackendServiceSessionAffinity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionBackendServiceSessionAffinity ClientIp { get; } = new RegionBackendServiceSessionAffinity("CLIENT_IP");
        public static RegionBackendServiceSessionAffinity ClientIpNoDestination { get; } = new RegionBackendServiceSessionAffinity("CLIENT_IP_NO_DESTINATION");
        public static RegionBackendServiceSessionAffinity ClientIpPortProto { get; } = new RegionBackendServiceSessionAffinity("CLIENT_IP_PORT_PROTO");
        public static RegionBackendServiceSessionAffinity ClientIpProto { get; } = new RegionBackendServiceSessionAffinity("CLIENT_IP_PROTO");
        public static RegionBackendServiceSessionAffinity GeneratedCookie { get; } = new RegionBackendServiceSessionAffinity("GENERATED_COOKIE");
        public static RegionBackendServiceSessionAffinity HeaderField { get; } = new RegionBackendServiceSessionAffinity("HEADER_FIELD");
        public static RegionBackendServiceSessionAffinity HttpCookie { get; } = new RegionBackendServiceSessionAffinity("HTTP_COOKIE");
        public static RegionBackendServiceSessionAffinity None { get; } = new RegionBackendServiceSessionAffinity("NONE");

        public static bool operator ==(RegionBackendServiceSessionAffinity left, RegionBackendServiceSessionAffinity right) => left.Equals(right);
        public static bool operator !=(RegionBackendServiceSessionAffinity left, RegionBackendServiceSessionAffinity right) => !left.Equals(right);

        public static explicit operator string(RegionBackendServiceSessionAffinity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionBackendServiceSessionAffinity other && Equals(other);
        public bool Equals(RegionBackendServiceSessionAffinity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The category of the commitment. Category MACHINE specifies commitments composed of machine resources such as VCPU or MEMORY, listed in resources. Category LICENSE specifies commitments composed of software licenses, listed in licenseResources. Note that only MACHINE commitments should have a Type specified.
    /// </summary>
    [EnumType]
    public readonly struct RegionCommitmentCategory : IEquatable<RegionCommitmentCategory>
    {
        private readonly string _value;

        private RegionCommitmentCategory(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionCommitmentCategory CategoryUnspecified { get; } = new RegionCommitmentCategory("CATEGORY_UNSPECIFIED");
        public static RegionCommitmentCategory License { get; } = new RegionCommitmentCategory("LICENSE");
        public static RegionCommitmentCategory Machine { get; } = new RegionCommitmentCategory("MACHINE");

        public static bool operator ==(RegionCommitmentCategory left, RegionCommitmentCategory right) => left.Equals(right);
        public static bool operator !=(RegionCommitmentCategory left, RegionCommitmentCategory right) => !left.Equals(right);

        public static explicit operator string(RegionCommitmentCategory value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionCommitmentCategory other && Equals(other);
        public bool Equals(RegionCommitmentCategory other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The plan for this commitment, which determines duration and discount rate. The currently supported plans are TWELVE_MONTH (1 year), and THIRTY_SIX_MONTH (3 years).
    /// </summary>
    [EnumType]
    public readonly struct RegionCommitmentPlan : IEquatable<RegionCommitmentPlan>
    {
        private readonly string _value;

        private RegionCommitmentPlan(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionCommitmentPlan Invalid { get; } = new RegionCommitmentPlan("INVALID");
        public static RegionCommitmentPlan ThirtySixMonth { get; } = new RegionCommitmentPlan("THIRTY_SIX_MONTH");
        public static RegionCommitmentPlan TwelveMonth { get; } = new RegionCommitmentPlan("TWELVE_MONTH");

        public static bool operator ==(RegionCommitmentPlan left, RegionCommitmentPlan right) => left.Equals(right);
        public static bool operator !=(RegionCommitmentPlan left, RegionCommitmentPlan right) => !left.Equals(right);

        public static explicit operator string(RegionCommitmentPlan value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionCommitmentPlan other && Equals(other);
        public bool Equals(RegionCommitmentPlan other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] Status of the commitment with regards to eventual expiration (each commitment has an end date defined). One of the following values: NOT_YET_ACTIVE, ACTIVE, EXPIRED.
    /// </summary>
    [EnumType]
    public readonly struct RegionCommitmentStatus : IEquatable<RegionCommitmentStatus>
    {
        private readonly string _value;

        private RegionCommitmentStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionCommitmentStatus Active { get; } = new RegionCommitmentStatus("ACTIVE");
        public static RegionCommitmentStatus Creating { get; } = new RegionCommitmentStatus("CREATING");
        public static RegionCommitmentStatus Expired { get; } = new RegionCommitmentStatus("EXPIRED");
        public static RegionCommitmentStatus NotYetActive { get; } = new RegionCommitmentStatus("NOT_YET_ACTIVE");

        public static bool operator ==(RegionCommitmentStatus left, RegionCommitmentStatus right) => left.Equals(right);
        public static bool operator !=(RegionCommitmentStatus left, RegionCommitmentStatus right) => !left.Equals(right);

        public static explicit operator string(RegionCommitmentStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionCommitmentStatus other && Equals(other);
        public bool Equals(RegionCommitmentStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of commitment, which affects the discount rate and the eligible resources. Type MEMORY_OPTIMIZED specifies a commitment that will only apply to memory optimized machines. Type ACCELERATOR_OPTIMIZED specifies a commitment that will only apply to accelerator optimized machines.
    /// </summary>
    [EnumType]
    public readonly struct RegionCommitmentType : IEquatable<RegionCommitmentType>
    {
        private readonly string _value;

        private RegionCommitmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionCommitmentType AcceleratorOptimized { get; } = new RegionCommitmentType("ACCELERATOR_OPTIMIZED");
        public static RegionCommitmentType ComputeOptimized { get; } = new RegionCommitmentType("COMPUTE_OPTIMIZED");
        public static RegionCommitmentType ComputeOptimizedC2d { get; } = new RegionCommitmentType("COMPUTE_OPTIMIZED_C2D");
        public static RegionCommitmentType GeneralPurpose { get; } = new RegionCommitmentType("GENERAL_PURPOSE");
        public static RegionCommitmentType GeneralPurposeE2 { get; } = new RegionCommitmentType("GENERAL_PURPOSE_E2");
        public static RegionCommitmentType GeneralPurposeN2 { get; } = new RegionCommitmentType("GENERAL_PURPOSE_N2");
        public static RegionCommitmentType GeneralPurposeN2d { get; } = new RegionCommitmentType("GENERAL_PURPOSE_N2D");
        public static RegionCommitmentType MemoryOptimized { get; } = new RegionCommitmentType("MEMORY_OPTIMIZED");
        public static RegionCommitmentType MemoryOptimizedRegionalExtension { get; } = new RegionCommitmentType("MEMORY_OPTIMIZED_REGIONAL_EXTENSION");
        public static RegionCommitmentType TypeUnspecified { get; } = new RegionCommitmentType("TYPE_UNSPECIFIED");

        public static bool operator ==(RegionCommitmentType left, RegionCommitmentType right) => left.Equals(right);
        public static bool operator !=(RegionCommitmentType left, RegionCommitmentType right) => !left.Equals(right);

        public static explicit operator string(RegionCommitmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionCommitmentType other && Equals(other);
        public bool Equals(RegionCommitmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI.
    /// </summary>
    [EnumType]
    public readonly struct RegionDiskInterface : IEquatable<RegionDiskInterface>
    {
        private readonly string _value;

        private RegionDiskInterface(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionDiskInterface Nvme { get; } = new RegionDiskInterface("NVME");
        public static RegionDiskInterface Scsi { get; } = new RegionDiskInterface("SCSI");
        public static RegionDiskInterface Unspecified { get; } = new RegionDiskInterface("UNSPECIFIED");

        public static bool operator ==(RegionDiskInterface left, RegionDiskInterface right) => left.Equals(right);
        public static bool operator !=(RegionDiskInterface left, RegionDiskInterface right) => !left.Equals(right);

        public static explicit operator string(RegionDiskInterface value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionDiskInterface other && Equals(other);
        public bool Equals(RegionDiskInterface other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of disk creation.  
    /// - CREATING: Disk is provisioning. 
    /// - RESTORING: Source data is being copied into the disk. 
    /// - FAILED: Disk creation failed. 
    /// - READY: Disk is ready for use. 
    /// - DELETING: Disk is deleting.
    /// </summary>
    [EnumType]
    public readonly struct RegionDiskStatus : IEquatable<RegionDiskStatus>
    {
        private readonly string _value;

        private RegionDiskStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionDiskStatus Creating { get; } = new RegionDiskStatus("CREATING");
        public static RegionDiskStatus Deleting { get; } = new RegionDiskStatus("DELETING");
        public static RegionDiskStatus Failed { get; } = new RegionDiskStatus("FAILED");
        public static RegionDiskStatus Ready { get; } = new RegionDiskStatus("READY");
        public static RegionDiskStatus Restoring { get; } = new RegionDiskStatus("RESTORING");

        public static bool operator ==(RegionDiskStatus left, RegionDiskStatus right) => left.Equals(right);
        public static bool operator !=(RegionDiskStatus left, RegionDiskStatus right) => !left.Equals(right);

        public static explicit operator string(RegionDiskStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionDiskStatus other && Equals(other);
        public bool Equals(RegionDiskStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Policy for how the results from multiple health checks for the same endpoint are aggregated. Defaults to NO_AGGREGATION if unspecified.  
    /// - NO_AGGREGATION. An EndpointHealth message is returned for each backend in the health check service. 
    /// - AND. If any backend's health check reports UNHEALTHY, then UNHEALTHY is the HealthState of the entire health check service. If all backend's are healthy, the HealthState of the health check service is HEALTHY. .
    /// </summary>
    [EnumType]
    public readonly struct RegionHealthCheckServiceHealthStatusAggregationPolicy : IEquatable<RegionHealthCheckServiceHealthStatusAggregationPolicy>
    {
        private readonly string _value;

        private RegionHealthCheckServiceHealthStatusAggregationPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionHealthCheckServiceHealthStatusAggregationPolicy And { get; } = new RegionHealthCheckServiceHealthStatusAggregationPolicy("AND");
        public static RegionHealthCheckServiceHealthStatusAggregationPolicy NoAggregation { get; } = new RegionHealthCheckServiceHealthStatusAggregationPolicy("NO_AGGREGATION");

        public static bool operator ==(RegionHealthCheckServiceHealthStatusAggregationPolicy left, RegionHealthCheckServiceHealthStatusAggregationPolicy right) => left.Equals(right);
        public static bool operator !=(RegionHealthCheckServiceHealthStatusAggregationPolicy left, RegionHealthCheckServiceHealthStatusAggregationPolicy right) => !left.Equals(right);

        public static explicit operator string(RegionHealthCheckServiceHealthStatusAggregationPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionHealthCheckServiceHealthStatusAggregationPolicy other && Equals(other);
        public bool Equals(RegionHealthCheckServiceHealthStatusAggregationPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS or HTTP2. If not specified, the default is TCP. Exactly one of the protocol-specific health check field must be specified, which must match type field.
    /// </summary>
    [EnumType]
    public readonly struct RegionHealthCheckType : IEquatable<RegionHealthCheckType>
    {
        private readonly string _value;

        private RegionHealthCheckType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionHealthCheckType Grpc { get; } = new RegionHealthCheckType("GRPC");
        public static RegionHealthCheckType Http { get; } = new RegionHealthCheckType("HTTP");
        public static RegionHealthCheckType Http2 { get; } = new RegionHealthCheckType("HTTP2");
        public static RegionHealthCheckType Https { get; } = new RegionHealthCheckType("HTTPS");
        public static RegionHealthCheckType Invalid { get; } = new RegionHealthCheckType("INVALID");
        public static RegionHealthCheckType Ssl { get; } = new RegionHealthCheckType("SSL");
        public static RegionHealthCheckType Tcp { get; } = new RegionHealthCheckType("TCP");
        public static RegionHealthCheckType Udp { get; } = new RegionHealthCheckType("UDP");

        public static bool operator ==(RegionHealthCheckType left, RegionHealthCheckType right) => left.Equals(right);
        public static bool operator !=(RegionHealthCheckType left, RegionHealthCheckType right) => !left.Equals(right);

        public static explicit operator string(RegionHealthCheckType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionHealthCheckType other && Equals(other);
        public bool Equals(RegionHealthCheckType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the inPlaceSnapshot. This can be CREATING, DELETING, FAILED, or READY.
    /// </summary>
    [EnumType]
    public readonly struct RegionInPlaceSnapshotStatus : IEquatable<RegionInPlaceSnapshotStatus>
    {
        private readonly string _value;

        private RegionInPlaceSnapshotStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionInPlaceSnapshotStatus Creating { get; } = new RegionInPlaceSnapshotStatus("CREATING");
        public static RegionInPlaceSnapshotStatus Deleting { get; } = new RegionInPlaceSnapshotStatus("DELETING");
        public static RegionInPlaceSnapshotStatus Failed { get; } = new RegionInPlaceSnapshotStatus("FAILED");
        public static RegionInPlaceSnapshotStatus Ready { get; } = new RegionInPlaceSnapshotStatus("READY");

        public static bool operator ==(RegionInPlaceSnapshotStatus left, RegionInPlaceSnapshotStatus right) => left.Equals(right);
        public static bool operator !=(RegionInPlaceSnapshotStatus left, RegionInPlaceSnapshotStatus right) => !left.Equals(right);

        public static explicit operator string(RegionInPlaceSnapshotStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionInPlaceSnapshotStatus other && Equals(other);
        public bool Equals(RegionInPlaceSnapshotStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The action to perform in case of zone failure. Only one value is supported, NO_FAILOVER. The default is NO_FAILOVER.
    /// </summary>
    [EnumType]
    public readonly struct RegionInstanceGroupManagerFailoverAction : IEquatable<RegionInstanceGroupManagerFailoverAction>
    {
        private readonly string _value;

        private RegionInstanceGroupManagerFailoverAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionInstanceGroupManagerFailoverAction NoFailover { get; } = new RegionInstanceGroupManagerFailoverAction("NO_FAILOVER");
        public static RegionInstanceGroupManagerFailoverAction Unknown { get; } = new RegionInstanceGroupManagerFailoverAction("UNKNOWN");

        public static bool operator ==(RegionInstanceGroupManagerFailoverAction left, RegionInstanceGroupManagerFailoverAction right) => left.Equals(right);
        public static bool operator !=(RegionInstanceGroupManagerFailoverAction left, RegionInstanceGroupManagerFailoverAction right) => !left.Equals(right);

        public static explicit operator string(RegionInstanceGroupManagerFailoverAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionInstanceGroupManagerFailoverAction other && Equals(other);
        public bool Equals(RegionInstanceGroupManagerFailoverAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the instantSnapshot. This can be CREATING, DELETING, FAILED, or READY.
    /// </summary>
    [EnumType]
    public readonly struct RegionInstantSnapshotStatus : IEquatable<RegionInstantSnapshotStatus>
    {
        private readonly string _value;

        private RegionInstantSnapshotStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionInstantSnapshotStatus Creating { get; } = new RegionInstantSnapshotStatus("CREATING");
        public static RegionInstantSnapshotStatus Deleting { get; } = new RegionInstantSnapshotStatus("DELETING");
        public static RegionInstantSnapshotStatus Failed { get; } = new RegionInstantSnapshotStatus("FAILED");
        public static RegionInstantSnapshotStatus Ready { get; } = new RegionInstantSnapshotStatus("READY");

        public static bool operator ==(RegionInstantSnapshotStatus left, RegionInstantSnapshotStatus right) => left.Equals(right);
        public static bool operator !=(RegionInstantSnapshotStatus left, RegionInstantSnapshotStatus right) => !left.Equals(right);

        public static explicit operator string(RegionInstantSnapshotStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionInstantSnapshotStatus other && Equals(other);
        public bool Equals(RegionInstantSnapshotStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of network endpoints in this network endpoint group. Can be one of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT, INTERNET_IP_PORT, or SERVERLESS.
    /// </summary>
    [EnumType]
    public readonly struct RegionNetworkEndpointGroupNetworkEndpointType : IEquatable<RegionNetworkEndpointGroupNetworkEndpointType>
    {
        private readonly string _value;

        private RegionNetworkEndpointGroupNetworkEndpointType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionNetworkEndpointGroupNetworkEndpointType GceVmIp { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("GCE_VM_IP");
        public static RegionNetworkEndpointGroupNetworkEndpointType GceVmIpPort { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("GCE_VM_IP_PORT");
        public static RegionNetworkEndpointGroupNetworkEndpointType GceVmPrimaryIp { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("GCE_VM_PRIMARY_IP");
        public static RegionNetworkEndpointGroupNetworkEndpointType InternetFqdnPort { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("INTERNET_FQDN_PORT");
        public static RegionNetworkEndpointGroupNetworkEndpointType InternetIpPort { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("INTERNET_IP_PORT");
        public static RegionNetworkEndpointGroupNetworkEndpointType NonGcpPrivateIpPort { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("NON_GCP_PRIVATE_IP_PORT");
        public static RegionNetworkEndpointGroupNetworkEndpointType PrivateServiceConnect { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("PRIVATE_SERVICE_CONNECT");
        public static RegionNetworkEndpointGroupNetworkEndpointType Serverless { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("SERVERLESS");

        public static bool operator ==(RegionNetworkEndpointGroupNetworkEndpointType left, RegionNetworkEndpointGroupNetworkEndpointType right) => left.Equals(right);
        public static bool operator !=(RegionNetworkEndpointGroupNetworkEndpointType left, RegionNetworkEndpointGroupNetworkEndpointType right) => !left.Equals(right);

        public static explicit operator string(RegionNetworkEndpointGroupNetworkEndpointType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionNetworkEndpointGroupNetworkEndpointType other && Equals(other);
        public bool Equals(RegionNetworkEndpointGroupNetworkEndpointType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the type of this network endpoint group. Only LOAD_BALANCING is valid for now.
    /// </summary>
    [EnumType]
    public readonly struct RegionNetworkEndpointGroupType : IEquatable<RegionNetworkEndpointGroupType>
    {
        private readonly string _value;

        private RegionNetworkEndpointGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionNetworkEndpointGroupType LoadBalancing { get; } = new RegionNetworkEndpointGroupType("LOAD_BALANCING");

        public static bool operator ==(RegionNetworkEndpointGroupType left, RegionNetworkEndpointGroupType right) => left.Equals(right);
        public static bool operator !=(RegionNetworkEndpointGroupType left, RegionNetworkEndpointGroupType right) => !left.Equals(right);

        public static explicit operator string(RegionNetworkEndpointGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionNetworkEndpointGroupType other && Equals(other);
        public bool Equals(RegionNetworkEndpointGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// (Optional) Specifies the type of SSL certificate, either "SELF_MANAGED" or "MANAGED". If not specified, the certificate is self-managed and the fields certificate and private_key are used.
    /// </summary>
    [EnumType]
    public readonly struct RegionSslCertificateType : IEquatable<RegionSslCertificateType>
    {
        private readonly string _value;

        private RegionSslCertificateType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionSslCertificateType Managed { get; } = new RegionSslCertificateType("MANAGED");
        public static RegionSslCertificateType SelfManaged { get; } = new RegionSslCertificateType("SELF_MANAGED");
        public static RegionSslCertificateType TypeUnspecified { get; } = new RegionSslCertificateType("TYPE_UNSPECIFIED");

        public static bool operator ==(RegionSslCertificateType left, RegionSslCertificateType right) => left.Equals(right);
        public static bool operator !=(RegionSslCertificateType left, RegionSslCertificateType right) => !left.Equals(right);

        public static explicit operator string(RegionSslCertificateType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionSslCertificateType other && Equals(other);
        public bool Equals(RegionSslCertificateType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the QUIC override policy for this TargetHttpsProxy resource. This setting determines whether the load balancer attempts to negotiate QUIC with clients. You can specify NONE, ENABLE, or DISABLE.  
    /// - When quic-override is set to NONE, Google manages whether QUIC is used. 
    /// - When quic-override is set to ENABLE, the load balancer uses QUIC when possible. 
    /// - When quic-override is set to DISABLE, the load balancer doesn't use QUIC. 
    /// - If the quic-override flag is not specified, NONE is implied.
    /// </summary>
    [EnumType]
    public readonly struct RegionTargetHttpsProxyQuicOverride : IEquatable<RegionTargetHttpsProxyQuicOverride>
    {
        private readonly string _value;

        private RegionTargetHttpsProxyQuicOverride(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionTargetHttpsProxyQuicOverride Disable { get; } = new RegionTargetHttpsProxyQuicOverride("DISABLE");
        public static RegionTargetHttpsProxyQuicOverride Enable { get; } = new RegionTargetHttpsProxyQuicOverride("ENABLE");
        public static RegionTargetHttpsProxyQuicOverride None { get; } = new RegionTargetHttpsProxyQuicOverride("NONE");

        public static bool operator ==(RegionTargetHttpsProxyQuicOverride left, RegionTargetHttpsProxyQuicOverride right) => left.Equals(right);
        public static bool operator !=(RegionTargetHttpsProxyQuicOverride left, RegionTargetHttpsProxyQuicOverride right) => !left.Equals(right);

        public static explicit operator string(RegionTargetHttpsProxyQuicOverride value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionTargetHttpsProxyQuicOverride other && Equals(other);
        public bool Equals(RegionTargetHttpsProxyQuicOverride other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of reservation from which this instance can consume resources: ANY_RESERVATION (default), SPECIFIC_RESERVATION, or NO_RESERVATION. See  Consuming reserved instances for examples.
    /// </summary>
    [EnumType]
    public readonly struct ReservationAffinityConsumeReservationType : IEquatable<ReservationAffinityConsumeReservationType>
    {
        private readonly string _value;

        private ReservationAffinityConsumeReservationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReservationAffinityConsumeReservationType AnyReservation { get; } = new ReservationAffinityConsumeReservationType("ANY_RESERVATION");
        public static ReservationAffinityConsumeReservationType NoReservation { get; } = new ReservationAffinityConsumeReservationType("NO_RESERVATION");
        public static ReservationAffinityConsumeReservationType SpecificReservation { get; } = new ReservationAffinityConsumeReservationType("SPECIFIC_RESERVATION");
        public static ReservationAffinityConsumeReservationType SpecificThenAnyReservation { get; } = new ReservationAffinityConsumeReservationType("SPECIFIC_THEN_ANY_RESERVATION");
        public static ReservationAffinityConsumeReservationType Unspecified { get; } = new ReservationAffinityConsumeReservationType("UNSPECIFIED");

        public static bool operator ==(ReservationAffinityConsumeReservationType left, ReservationAffinityConsumeReservationType right) => left.Equals(right);
        public static bool operator !=(ReservationAffinityConsumeReservationType left, ReservationAffinityConsumeReservationType right) => !left.Equals(right);

        public static explicit operator string(ReservationAffinityConsumeReservationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReservationAffinityConsumeReservationType other && Equals(other);
        public bool Equals(ReservationAffinityConsumeReservationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the reservation.
    /// </summary>
    [EnumType]
    public readonly struct ReservationStatus : IEquatable<ReservationStatus>
    {
        private readonly string _value;

        private ReservationStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ReservationStatus Creating { get; } = new ReservationStatus("CREATING");
        public static ReservationStatus Deleting { get; } = new ReservationStatus("DELETING");
        public static ReservationStatus Invalid { get; } = new ReservationStatus("INVALID");
        public static ReservationStatus Ready { get; } = new ReservationStatus("READY");
        public static ReservationStatus Updating { get; } = new ReservationStatus("UPDATING");

        public static bool operator ==(ReservationStatus left, ReservationStatus right) => left.Equals(right);
        public static bool operator !=(ReservationStatus left, ReservationStatus right) => !left.Equals(right);

        public static explicit operator string(ReservationStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReservationStatus other && Equals(other);
        public bool Equals(ReservationStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of resource for which this commitment applies. Possible values are VCPU and MEMORY
    /// </summary>
    [EnumType]
    public readonly struct ResourceCommitmentType : IEquatable<ResourceCommitmentType>
    {
        private readonly string _value;

        private ResourceCommitmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceCommitmentType Accelerator { get; } = new ResourceCommitmentType("ACCELERATOR");
        public static ResourceCommitmentType LocalSsd { get; } = new ResourceCommitmentType("LOCAL_SSD");
        public static ResourceCommitmentType Memory { get; } = new ResourceCommitmentType("MEMORY");
        public static ResourceCommitmentType Unspecified { get; } = new ResourceCommitmentType("UNSPECIFIED");
        public static ResourceCommitmentType Vcpu { get; } = new ResourceCommitmentType("VCPU");

        public static bool operator ==(ResourceCommitmentType left, ResourceCommitmentType right) => left.Equals(right);
        public static bool operator !=(ResourceCommitmentType left, ResourceCommitmentType right) => !left.Equals(right);

        public static explicit operator string(ResourceCommitmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceCommitmentType other && Equals(other);
        public bool Equals(ResourceCommitmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies network collocation
    /// </summary>
    [EnumType]
    public readonly struct ResourcePolicyGroupPlacementPolicyCollocation : IEquatable<ResourcePolicyGroupPlacementPolicyCollocation>
    {
        private readonly string _value;

        private ResourcePolicyGroupPlacementPolicyCollocation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourcePolicyGroupPlacementPolicyCollocation Clustered { get; } = new ResourcePolicyGroupPlacementPolicyCollocation("CLUSTERED");
        public static ResourcePolicyGroupPlacementPolicyCollocation Collocated { get; } = new ResourcePolicyGroupPlacementPolicyCollocation("COLLOCATED");
        public static ResourcePolicyGroupPlacementPolicyCollocation UnspecifiedCollocation { get; } = new ResourcePolicyGroupPlacementPolicyCollocation("UNSPECIFIED_COLLOCATION");

        public static bool operator ==(ResourcePolicyGroupPlacementPolicyCollocation left, ResourcePolicyGroupPlacementPolicyCollocation right) => left.Equals(right);
        public static bool operator !=(ResourcePolicyGroupPlacementPolicyCollocation left, ResourcePolicyGroupPlacementPolicyCollocation right) => !left.Equals(right);

        public static explicit operator string(ResourcePolicyGroupPlacementPolicyCollocation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourcePolicyGroupPlacementPolicyCollocation other && Equals(other);
        public bool Equals(ResourcePolicyGroupPlacementPolicyCollocation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies network locality
    /// </summary>
    [EnumType]
    public readonly struct ResourcePolicyGroupPlacementPolicyLocality : IEquatable<ResourcePolicyGroupPlacementPolicyLocality>
    {
        private readonly string _value;

        private ResourcePolicyGroupPlacementPolicyLocality(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourcePolicyGroupPlacementPolicyLocality BestEffort { get; } = new ResourcePolicyGroupPlacementPolicyLocality("BEST_EFFORT");
        public static ResourcePolicyGroupPlacementPolicyLocality Strict { get; } = new ResourcePolicyGroupPlacementPolicyLocality("STRICT");
        public static ResourcePolicyGroupPlacementPolicyLocality UnspecifiedLocality { get; } = new ResourcePolicyGroupPlacementPolicyLocality("UNSPECIFIED_LOCALITY");

        public static bool operator ==(ResourcePolicyGroupPlacementPolicyLocality left, ResourcePolicyGroupPlacementPolicyLocality right) => left.Equals(right);
        public static bool operator !=(ResourcePolicyGroupPlacementPolicyLocality left, ResourcePolicyGroupPlacementPolicyLocality right) => !left.Equals(right);

        public static explicit operator string(ResourcePolicyGroupPlacementPolicyLocality value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourcePolicyGroupPlacementPolicyLocality other && Equals(other);
        public bool Equals(ResourcePolicyGroupPlacementPolicyLocality other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Scope specifies the availability domain to which the VMs should be spread.
    /// </summary>
    [EnumType]
    public readonly struct ResourcePolicyGroupPlacementPolicyScope : IEquatable<ResourcePolicyGroupPlacementPolicyScope>
    {
        private readonly string _value;

        private ResourcePolicyGroupPlacementPolicyScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourcePolicyGroupPlacementPolicyScope Host { get; } = new ResourcePolicyGroupPlacementPolicyScope("HOST");
        public static ResourcePolicyGroupPlacementPolicyScope UnspecifiedScope { get; } = new ResourcePolicyGroupPlacementPolicyScope("UNSPECIFIED_SCOPE");

        public static bool operator ==(ResourcePolicyGroupPlacementPolicyScope left, ResourcePolicyGroupPlacementPolicyScope right) => left.Equals(right);
        public static bool operator !=(ResourcePolicyGroupPlacementPolicyScope left, ResourcePolicyGroupPlacementPolicyScope right) => !left.Equals(right);

        public static explicit operator string(ResourcePolicyGroupPlacementPolicyScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourcePolicyGroupPlacementPolicyScope other && Equals(other);
        public bool Equals(ResourcePolicyGroupPlacementPolicyScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies instances to hosts placement relationship
    /// </summary>
    [EnumType]
    public readonly struct ResourcePolicyGroupPlacementPolicyStyle : IEquatable<ResourcePolicyGroupPlacementPolicyStyle>
    {
        private readonly string _value;

        private ResourcePolicyGroupPlacementPolicyStyle(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourcePolicyGroupPlacementPolicyStyle Compact { get; } = new ResourcePolicyGroupPlacementPolicyStyle("COMPACT");
        public static ResourcePolicyGroupPlacementPolicyStyle FullySpread { get; } = new ResourcePolicyGroupPlacementPolicyStyle("FULLY_SPREAD");
        public static ResourcePolicyGroupPlacementPolicyStyle UnspecifiedPlacementType { get; } = new ResourcePolicyGroupPlacementPolicyStyle("UNSPECIFIED_PLACEMENT_TYPE");

        public static bool operator ==(ResourcePolicyGroupPlacementPolicyStyle left, ResourcePolicyGroupPlacementPolicyStyle right) => left.Equals(right);
        public static bool operator !=(ResourcePolicyGroupPlacementPolicyStyle left, ResourcePolicyGroupPlacementPolicyStyle right) => !left.Equals(right);

        public static explicit operator string(ResourcePolicyGroupPlacementPolicyStyle value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourcePolicyGroupPlacementPolicyStyle other && Equals(other);
        public bool Equals(ResourcePolicyGroupPlacementPolicyStyle other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// TODO(b/165626794): Remove this field Specifies the behavior to apply to existing, scheduled snapshots snapshots if the policy is changed.
    /// </summary>
    [EnumType]
    public readonly struct ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch : IEquatable<ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch>
    {
        private readonly string _value;

        private ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch DoNotRetroactivelyApply { get; } = new ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch("DO_NOT_RETROACTIVELY_APPLY");
        public static ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch RetroactivelyApply { get; } = new ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch("RETROACTIVELY_APPLY");
        public static ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch UnspecifiedOnPolicySwitch { get; } = new ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch("UNSPECIFIED_ON_POLICY_SWITCH");

        public static bool operator ==(ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch left, ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch right) => left.Equals(right);
        public static bool operator !=(ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch left, ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch right) => !left.Equals(right);

        public static explicit operator string(ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch other && Equals(other);
        public bool Equals(ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnPolicySwitch other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the behavior to apply to scheduled snapshots when the source disk is deleted.
    /// </summary>
    [EnumType]
    public readonly struct ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete : IEquatable<ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete>
    {
        private readonly string _value;

        private ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete ApplyRetentionPolicy { get; } = new ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete("APPLY_RETENTION_POLICY");
        public static ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete KeepAutoSnapshots { get; } = new ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete("KEEP_AUTO_SNAPSHOTS");
        public static ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete UnspecifiedOnSourceDiskDelete { get; } = new ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete("UNSPECIFIED_ON_SOURCE_DISK_DELETE");

        public static bool operator ==(ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete left, ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete right) => left.Equals(right);
        public static bool operator !=(ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete left, ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete right) => !left.Equals(right);

        public static explicit operator string(ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete other && Equals(other);
        public bool Equals(ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of resource policy creation.
    /// </summary>
    [EnumType]
    public readonly struct ResourcePolicyStatus : IEquatable<ResourcePolicyStatus>
    {
        private readonly string _value;

        private ResourcePolicyStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourcePolicyStatus Creating { get; } = new ResourcePolicyStatus("CREATING");
        public static ResourcePolicyStatus Deleting { get; } = new ResourcePolicyStatus("DELETING");
        public static ResourcePolicyStatus Expired { get; } = new ResourcePolicyStatus("EXPIRED");
        public static ResourcePolicyStatus Invalid { get; } = new ResourcePolicyStatus("INVALID");
        public static ResourcePolicyStatus Ready { get; } = new ResourcePolicyStatus("READY");

        public static bool operator ==(ResourcePolicyStatus left, ResourcePolicyStatus right) => left.Equals(right);
        public static bool operator !=(ResourcePolicyStatus left, ResourcePolicyStatus right) => !left.Equals(right);

        public static explicit operator string(ResourcePolicyStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourcePolicyStatus other && Equals(other);
        public bool Equals(ResourcePolicyStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines a schedule that runs on specific days of the week. Specify one or more days. The following options are available: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    /// </summary>
    [EnumType]
    public readonly struct ResourcePolicyWeeklyCycleDayOfWeekDay : IEquatable<ResourcePolicyWeeklyCycleDayOfWeekDay>
    {
        private readonly string _value;

        private ResourcePolicyWeeklyCycleDayOfWeekDay(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourcePolicyWeeklyCycleDayOfWeekDay Friday { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("FRIDAY");
        public static ResourcePolicyWeeklyCycleDayOfWeekDay Invalid { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("INVALID");
        public static ResourcePolicyWeeklyCycleDayOfWeekDay Monday { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("MONDAY");
        public static ResourcePolicyWeeklyCycleDayOfWeekDay Saturday { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("SATURDAY");
        public static ResourcePolicyWeeklyCycleDayOfWeekDay Sunday { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("SUNDAY");
        public static ResourcePolicyWeeklyCycleDayOfWeekDay Thursday { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("THURSDAY");
        public static ResourcePolicyWeeklyCycleDayOfWeekDay Tuesday { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("TUESDAY");
        public static ResourcePolicyWeeklyCycleDayOfWeekDay Wednesday { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("WEDNESDAY");

        public static bool operator ==(ResourcePolicyWeeklyCycleDayOfWeekDay left, ResourcePolicyWeeklyCycleDayOfWeekDay right) => left.Equals(right);
        public static bool operator !=(ResourcePolicyWeeklyCycleDayOfWeekDay left, ResourcePolicyWeeklyCycleDayOfWeekDay right) => !left.Equals(right);

        public static explicit operator string(ResourcePolicyWeeklyCycleDayOfWeekDay value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourcePolicyWeeklyCycleDayOfWeekDay other && Equals(other);
        public bool Equals(ResourcePolicyWeeklyCycleDayOfWeekDay other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
    /// </summary>
    [EnumType]
    public readonly struct RouteWarningsItemCode : IEquatable<RouteWarningsItemCode>
    {
        private readonly string _value;

        private RouteWarningsItemCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouteWarningsItemCode CleanupFailed { get; } = new RouteWarningsItemCode("CLEANUP_FAILED");
        public static RouteWarningsItemCode DeprecatedResourceUsed { get; } = new RouteWarningsItemCode("DEPRECATED_RESOURCE_USED");
        public static RouteWarningsItemCode DeprecatedTypeUsed { get; } = new RouteWarningsItemCode("DEPRECATED_TYPE_USED");
        public static RouteWarningsItemCode DiskSizeLargerThanImageSize { get; } = new RouteWarningsItemCode("DISK_SIZE_LARGER_THAN_IMAGE_SIZE");
        public static RouteWarningsItemCode ExperimentalTypeUsed { get; } = new RouteWarningsItemCode("EXPERIMENTAL_TYPE_USED");
        public static RouteWarningsItemCode ExternalApiWarning { get; } = new RouteWarningsItemCode("EXTERNAL_API_WARNING");
        public static RouteWarningsItemCode FieldValueOverriden { get; } = new RouteWarningsItemCode("FIELD_VALUE_OVERRIDEN");
        public static RouteWarningsItemCode InjectedKernelsDeprecated { get; } = new RouteWarningsItemCode("INJECTED_KERNELS_DEPRECATED");
        public static RouteWarningsItemCode LargeDeploymentWarning { get; } = new RouteWarningsItemCode("LARGE_DEPLOYMENT_WARNING");
        public static RouteWarningsItemCode MissingTypeDependency { get; } = new RouteWarningsItemCode("MISSING_TYPE_DEPENDENCY");
        public static RouteWarningsItemCode NextHopAddressNotAssigned { get; } = new RouteWarningsItemCode("NEXT_HOP_ADDRESS_NOT_ASSIGNED");
        public static RouteWarningsItemCode NextHopCannotIpForward { get; } = new RouteWarningsItemCode("NEXT_HOP_CANNOT_IP_FORWARD");
        public static RouteWarningsItemCode NextHopInstanceNotFound { get; } = new RouteWarningsItemCode("NEXT_HOP_INSTANCE_NOT_FOUND");
        public static RouteWarningsItemCode NextHopInstanceNotOnNetwork { get; } = new RouteWarningsItemCode("NEXT_HOP_INSTANCE_NOT_ON_NETWORK");
        public static RouteWarningsItemCode NextHopNotRunning { get; } = new RouteWarningsItemCode("NEXT_HOP_NOT_RUNNING");
        public static RouteWarningsItemCode NotCriticalError { get; } = new RouteWarningsItemCode("NOT_CRITICAL_ERROR");
        public static RouteWarningsItemCode NoResultsOnPage { get; } = new RouteWarningsItemCode("NO_RESULTS_ON_PAGE");
        public static RouteWarningsItemCode PartialSuccess { get; } = new RouteWarningsItemCode("PARTIAL_SUCCESS");
        public static RouteWarningsItemCode RequiredTosAgreement { get; } = new RouteWarningsItemCode("REQUIRED_TOS_AGREEMENT");
        public static RouteWarningsItemCode ResourceInUseByOtherResourceWarning { get; } = new RouteWarningsItemCode("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING");
        public static RouteWarningsItemCode ResourceNotDeleted { get; } = new RouteWarningsItemCode("RESOURCE_NOT_DELETED");
        public static RouteWarningsItemCode SchemaValidationIgnored { get; } = new RouteWarningsItemCode("SCHEMA_VALIDATION_IGNORED");
        public static RouteWarningsItemCode SingleInstancePropertyTemplate { get; } = new RouteWarningsItemCode("SINGLE_INSTANCE_PROPERTY_TEMPLATE");
        public static RouteWarningsItemCode UndeclaredProperties { get; } = new RouteWarningsItemCode("UNDECLARED_PROPERTIES");
        public static RouteWarningsItemCode Unreachable { get; } = new RouteWarningsItemCode("UNREACHABLE");

        public static bool operator ==(RouteWarningsItemCode left, RouteWarningsItemCode right) => left.Equals(right);
        public static bool operator !=(RouteWarningsItemCode left, RouteWarningsItemCode right) => !left.Equals(right);

        public static explicit operator string(RouteWarningsItemCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouteWarningsItemCode other && Equals(other);
        public bool Equals(RouteWarningsItemCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// User-specified flag to indicate which mode to use for advertisement. The options are DEFAULT or CUSTOM.
    /// </summary>
    [EnumType]
    public readonly struct RouterBgpAdvertiseMode : IEquatable<RouterBgpAdvertiseMode>
    {
        private readonly string _value;

        private RouterBgpAdvertiseMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterBgpAdvertiseMode Custom { get; } = new RouterBgpAdvertiseMode("CUSTOM");
        public static RouterBgpAdvertiseMode Default { get; } = new RouterBgpAdvertiseMode("DEFAULT");

        public static bool operator ==(RouterBgpAdvertiseMode left, RouterBgpAdvertiseMode right) => left.Equals(right);
        public static bool operator !=(RouterBgpAdvertiseMode left, RouterBgpAdvertiseMode right) => !left.Equals(right);

        public static explicit operator string(RouterBgpAdvertiseMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpAdvertiseMode other && Equals(other);
        public bool Equals(RouterBgpAdvertiseMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterBgpAdvertisedGroupsItem : IEquatable<RouterBgpAdvertisedGroupsItem>
    {
        private readonly string _value;

        private RouterBgpAdvertisedGroupsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterBgpAdvertisedGroupsItem AllPeerVpcSubnets { get; } = new RouterBgpAdvertisedGroupsItem("ALL_PEER_VPC_SUBNETS");
        public static RouterBgpAdvertisedGroupsItem AllSubnets { get; } = new RouterBgpAdvertisedGroupsItem("ALL_SUBNETS");
        public static RouterBgpAdvertisedGroupsItem AllVpcSubnets { get; } = new RouterBgpAdvertisedGroupsItem("ALL_VPC_SUBNETS");

        public static bool operator ==(RouterBgpAdvertisedGroupsItem left, RouterBgpAdvertisedGroupsItem right) => left.Equals(right);
        public static bool operator !=(RouterBgpAdvertisedGroupsItem left, RouterBgpAdvertisedGroupsItem right) => !left.Equals(right);

        public static explicit operator string(RouterBgpAdvertisedGroupsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpAdvertisedGroupsItem other && Equals(other);
        public bool Equals(RouterBgpAdvertisedGroupsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// User-specified flag to indicate which mode to use for advertisement.
    /// </summary>
    [EnumType]
    public readonly struct RouterBgpPeerAdvertiseMode : IEquatable<RouterBgpPeerAdvertiseMode>
    {
        private readonly string _value;

        private RouterBgpPeerAdvertiseMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterBgpPeerAdvertiseMode Custom { get; } = new RouterBgpPeerAdvertiseMode("CUSTOM");
        public static RouterBgpPeerAdvertiseMode Default { get; } = new RouterBgpPeerAdvertiseMode("DEFAULT");

        public static bool operator ==(RouterBgpPeerAdvertiseMode left, RouterBgpPeerAdvertiseMode right) => left.Equals(right);
        public static bool operator !=(RouterBgpPeerAdvertiseMode left, RouterBgpPeerAdvertiseMode right) => !left.Equals(right);

        public static explicit operator string(RouterBgpPeerAdvertiseMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpPeerAdvertiseMode other && Equals(other);
        public bool Equals(RouterBgpPeerAdvertiseMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterBgpPeerAdvertisedGroupsItem : IEquatable<RouterBgpPeerAdvertisedGroupsItem>
    {
        private readonly string _value;

        private RouterBgpPeerAdvertisedGroupsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterBgpPeerAdvertisedGroupsItem AllPeerVpcSubnets { get; } = new RouterBgpPeerAdvertisedGroupsItem("ALL_PEER_VPC_SUBNETS");
        public static RouterBgpPeerAdvertisedGroupsItem AllSubnets { get; } = new RouterBgpPeerAdvertisedGroupsItem("ALL_SUBNETS");
        public static RouterBgpPeerAdvertisedGroupsItem AllVpcSubnets { get; } = new RouterBgpPeerAdvertisedGroupsItem("ALL_VPC_SUBNETS");

        public static bool operator ==(RouterBgpPeerAdvertisedGroupsItem left, RouterBgpPeerAdvertisedGroupsItem right) => left.Equals(right);
        public static bool operator !=(RouterBgpPeerAdvertisedGroupsItem left, RouterBgpPeerAdvertisedGroupsItem right) => !left.Equals(right);

        public static explicit operator string(RouterBgpPeerAdvertisedGroupsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpPeerAdvertisedGroupsItem other && Equals(other);
        public bool Equals(RouterBgpPeerAdvertisedGroupsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The BFD session initialization mode for this BGP peer. If set to ACTIVE, the Cloud Router will initiate the BFD session for this BGP peer. If set to PASSIVE, the Cloud Router will wait for the peer router to initiate the BFD session for this BGP peer. If set to DISABLED, BFD is disabled for this BGP peer. The default is PASSIVE.
    /// </summary>
    [EnumType]
    public readonly struct RouterBgpPeerBfdMode : IEquatable<RouterBgpPeerBfdMode>
    {
        private readonly string _value;

        private RouterBgpPeerBfdMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterBgpPeerBfdMode Active { get; } = new RouterBgpPeerBfdMode("ACTIVE");
        public static RouterBgpPeerBfdMode Disabled { get; } = new RouterBgpPeerBfdMode("DISABLED");
        public static RouterBgpPeerBfdMode Passive { get; } = new RouterBgpPeerBfdMode("PASSIVE");

        public static bool operator ==(RouterBgpPeerBfdMode left, RouterBgpPeerBfdMode right) => left.Equals(right);
        public static bool operator !=(RouterBgpPeerBfdMode left, RouterBgpPeerBfdMode right) => !left.Equals(right);

        public static explicit operator string(RouterBgpPeerBfdMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpPeerBfdMode other && Equals(other);
        public bool Equals(RouterBgpPeerBfdMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The BFD packet mode for this BGP peer. If set to CONTROL_AND_ECHO, BFD echo mode is enabled for this BGP peer. In this mode, if the peer router also has BFD echo mode enabled, BFD echo packets will be sent to the other router. If the peer router does not have BFD echo mode enabled, only control packets will be sent. If set to CONTROL_ONLY, BFD echo mode is disabled for this BGP peer. If this router and the peer router have a multihop connection, this should be set to CONTROL_ONLY as BFD echo mode is only supported on singlehop connections. The default is CONTROL_AND_ECHO.
    /// </summary>
    [EnumType]
    public readonly struct RouterBgpPeerBfdPacketMode : IEquatable<RouterBgpPeerBfdPacketMode>
    {
        private readonly string _value;

        private RouterBgpPeerBfdPacketMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterBgpPeerBfdPacketMode ControlAndEcho { get; } = new RouterBgpPeerBfdPacketMode("CONTROL_AND_ECHO");
        public static RouterBgpPeerBfdPacketMode ControlOnly { get; } = new RouterBgpPeerBfdPacketMode("CONTROL_ONLY");

        public static bool operator ==(RouterBgpPeerBfdPacketMode left, RouterBgpPeerBfdPacketMode right) => left.Equals(right);
        public static bool operator !=(RouterBgpPeerBfdPacketMode left, RouterBgpPeerBfdPacketMode right) => !left.Equals(right);

        public static explicit operator string(RouterBgpPeerBfdPacketMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpPeerBfdPacketMode other && Equals(other);
        public bool Equals(RouterBgpPeerBfdPacketMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The BFD session initialization mode for this BGP peer.
    /// Not currently available publicly.
    /// If set to ACTIVE, the Cloud Router will initiate the BFD session for this BGP peer. If set to PASSIVE, the Cloud Router will wait for the peer router to initiate the BFD session for this BGP peer. If set to DISABLED, BFD is disabled for this BGP peer. The default is PASSIVE.
    /// </summary>
    [EnumType]
    public readonly struct RouterBgpPeerBfdSessionInitializationMode : IEquatable<RouterBgpPeerBfdSessionInitializationMode>
    {
        private readonly string _value;

        private RouterBgpPeerBfdSessionInitializationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterBgpPeerBfdSessionInitializationMode Active { get; } = new RouterBgpPeerBfdSessionInitializationMode("ACTIVE");
        public static RouterBgpPeerBfdSessionInitializationMode Disabled { get; } = new RouterBgpPeerBfdSessionInitializationMode("DISABLED");
        public static RouterBgpPeerBfdSessionInitializationMode Passive { get; } = new RouterBgpPeerBfdSessionInitializationMode("PASSIVE");

        public static bool operator ==(RouterBgpPeerBfdSessionInitializationMode left, RouterBgpPeerBfdSessionInitializationMode right) => left.Equals(right);
        public static bool operator !=(RouterBgpPeerBfdSessionInitializationMode left, RouterBgpPeerBfdSessionInitializationMode right) => !left.Equals(right);

        public static explicit operator string(RouterBgpPeerBfdSessionInitializationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpPeerBfdSessionInitializationMode other && Equals(other);
        public bool Equals(RouterBgpPeerBfdSessionInitializationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of the BGP peer connection.
    /// Not currently available publicly.
    /// If set to FALSE, any active session with the peer is terminated and all associated routing information is removed. If set to TRUE, the peer connection can be established with routing information. The default is TRUE.
    /// </summary>
    [EnumType]
    public readonly struct RouterBgpPeerEnable : IEquatable<RouterBgpPeerEnable>
    {
        private readonly string _value;

        private RouterBgpPeerEnable(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterBgpPeerEnable False { get; } = new RouterBgpPeerEnable("FALSE");
        public static RouterBgpPeerEnable True { get; } = new RouterBgpPeerEnable("TRUE");

        public static bool operator ==(RouterBgpPeerEnable left, RouterBgpPeerEnable right) => left.Equals(right);
        public static bool operator !=(RouterBgpPeerEnable left, RouterBgpPeerEnable right) => !left.Equals(right);

        public static explicit operator string(RouterBgpPeerEnable value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpPeerEnable other && Equals(other);
        public bool Equals(RouterBgpPeerEnable other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The resource that configures and manages this BGP peer. 
    /// - MANAGED_BY_USER is the default value and can be managed by you or other users 
    /// - MANAGED_BY_ATTACHMENT is a BGP peer that is configured and managed by Cloud Interconnect, specifically by an InterconnectAttachment of type PARTNER. Google automatically creates, updates, and deletes this type of BGP peer when the PARTNER InterconnectAttachment is created, updated, or deleted.
    /// </summary>
    [EnumType]
    public readonly struct RouterBgpPeerManagementType : IEquatable<RouterBgpPeerManagementType>
    {
        private readonly string _value;

        private RouterBgpPeerManagementType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterBgpPeerManagementType ManagedByAttachment { get; } = new RouterBgpPeerManagementType("MANAGED_BY_ATTACHMENT");
        public static RouterBgpPeerManagementType ManagedByUser { get; } = new RouterBgpPeerManagementType("MANAGED_BY_USER");

        public static bool operator ==(RouterBgpPeerManagementType left, RouterBgpPeerManagementType right) => left.Equals(right);
        public static bool operator !=(RouterBgpPeerManagementType left, RouterBgpPeerManagementType right) => !left.Equals(right);

        public static explicit operator string(RouterBgpPeerManagementType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpPeerManagementType other && Equals(other);
        public bool Equals(RouterBgpPeerManagementType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The resource that configures and manages this interface. 
    /// - MANAGED_BY_USER is the default value and can be managed directly by users. 
    /// - MANAGED_BY_ATTACHMENT is an interface that is configured and managed by Cloud Interconnect, specifically, by an InterconnectAttachment of type PARTNER. Google automatically creates, updates, and deletes this type of interface when the PARTNER InterconnectAttachment is created, updated, or deleted.
    /// </summary>
    [EnumType]
    public readonly struct RouterInterfaceManagementType : IEquatable<RouterInterfaceManagementType>
    {
        private readonly string _value;

        private RouterInterfaceManagementType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterInterfaceManagementType ManagedByAttachment { get; } = new RouterInterfaceManagementType("MANAGED_BY_ATTACHMENT");
        public static RouterInterfaceManagementType ManagedByUser { get; } = new RouterInterfaceManagementType("MANAGED_BY_USER");

        public static bool operator ==(RouterInterfaceManagementType left, RouterInterfaceManagementType right) => left.Equals(right);
        public static bool operator !=(RouterInterfaceManagementType left, RouterInterfaceManagementType right) => !left.Equals(right);

        public static explicit operator string(RouterInterfaceManagementType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterInterfaceManagementType other && Equals(other);
        public bool Equals(RouterInterfaceManagementType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the desired filtering of logs on this NAT. If unspecified, logs are exported for all connections handled by this NAT. This option can take one of the following values: 
    /// - ERRORS_ONLY: Export logs only for connection failures. 
    /// - TRANSLATIONS_ONLY: Export logs only for successful connections. 
    /// - ALL: Export logs for all connections, successful and unsuccessful.
    /// </summary>
    [EnumType]
    public readonly struct RouterNatLogConfigFilter : IEquatable<RouterNatLogConfigFilter>
    {
        private readonly string _value;

        private RouterNatLogConfigFilter(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterNatLogConfigFilter All { get; } = new RouterNatLogConfigFilter("ALL");
        public static RouterNatLogConfigFilter ErrorsOnly { get; } = new RouterNatLogConfigFilter("ERRORS_ONLY");
        public static RouterNatLogConfigFilter TranslationsOnly { get; } = new RouterNatLogConfigFilter("TRANSLATIONS_ONLY");

        public static bool operator ==(RouterNatLogConfigFilter left, RouterNatLogConfigFilter right) => left.Equals(right);
        public static bool operator !=(RouterNatLogConfigFilter left, RouterNatLogConfigFilter right) => !left.Equals(right);

        public static explicit operator string(RouterNatLogConfigFilter value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterNatLogConfigFilter other && Equals(other);
        public bool Equals(RouterNatLogConfigFilter other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the NatIpAllocateOption, which can take one of the following values: 
    /// - MANUAL_ONLY: Uses only Nat IP addresses provided by customers. When there are not enough specified Nat IPs, the Nat service fails for new VMs. 
    /// - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform; customers can't specify any Nat IPs. When choosing AUTO_ONLY, then nat_ip should be empty.
    /// </summary>
    [EnumType]
    public readonly struct RouterNatNatIpAllocateOption : IEquatable<RouterNatNatIpAllocateOption>
    {
        private readonly string _value;

        private RouterNatNatIpAllocateOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterNatNatIpAllocateOption AutoOnly { get; } = new RouterNatNatIpAllocateOption("AUTO_ONLY");
        public static RouterNatNatIpAllocateOption ManualOnly { get; } = new RouterNatNatIpAllocateOption("MANUAL_ONLY");

        public static bool operator ==(RouterNatNatIpAllocateOption left, RouterNatNatIpAllocateOption right) => left.Equals(right);
        public static bool operator !=(RouterNatNatIpAllocateOption left, RouterNatNatIpAllocateOption right) => !left.Equals(right);

        public static explicit operator string(RouterNatNatIpAllocateOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterNatNatIpAllocateOption other && Equals(other);
        public bool Equals(RouterNatNatIpAllocateOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the Nat option, which can take one of the following values: 
    /// - ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork are allowed to Nat. 
    /// - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the primary IP ranges in every Subnetwork are allowed to Nat. 
    /// - LIST_OF_SUBNETWORKS: A list of Subnetworks are allowed to Nat (specified in the field subnetwork below) The default is SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note that if this field contains ALL_SUBNETWORKS_ALL_IP_RANGES or ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any other Router.Nat section in any Router for this network in this region.
    /// </summary>
    [EnumType]
    public readonly struct RouterNatSourceSubnetworkIpRangesToNat : IEquatable<RouterNatSourceSubnetworkIpRangesToNat>
    {
        private readonly string _value;

        private RouterNatSourceSubnetworkIpRangesToNat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterNatSourceSubnetworkIpRangesToNat AllSubnetworksAllIpRanges { get; } = new RouterNatSourceSubnetworkIpRangesToNat("ALL_SUBNETWORKS_ALL_IP_RANGES");
        public static RouterNatSourceSubnetworkIpRangesToNat AllSubnetworksAllPrimaryIpRanges { get; } = new RouterNatSourceSubnetworkIpRangesToNat("ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES");
        public static RouterNatSourceSubnetworkIpRangesToNat ListOfSubnetworks { get; } = new RouterNatSourceSubnetworkIpRangesToNat("LIST_OF_SUBNETWORKS");

        public static bool operator ==(RouterNatSourceSubnetworkIpRangesToNat left, RouterNatSourceSubnetworkIpRangesToNat right) => left.Equals(right);
        public static bool operator !=(RouterNatSourceSubnetworkIpRangesToNat left, RouterNatSourceSubnetworkIpRangesToNat right) => !left.Equals(right);

        public static explicit operator string(RouterNatSourceSubnetworkIpRangesToNat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterNatSourceSubnetworkIpRangesToNat other && Equals(other);
        public bool Equals(RouterNatSourceSubnetworkIpRangesToNat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterNatSubnetworkToNatSourceIpRangesToNatItem : IEquatable<RouterNatSubnetworkToNatSourceIpRangesToNatItem>
    {
        private readonly string _value;

        private RouterNatSubnetworkToNatSourceIpRangesToNatItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterNatSubnetworkToNatSourceIpRangesToNatItem AllIpRanges { get; } = new RouterNatSubnetworkToNatSourceIpRangesToNatItem("ALL_IP_RANGES");
        public static RouterNatSubnetworkToNatSourceIpRangesToNatItem ListOfSecondaryIpRanges { get; } = new RouterNatSubnetworkToNatSourceIpRangesToNatItem("LIST_OF_SECONDARY_IP_RANGES");
        public static RouterNatSubnetworkToNatSourceIpRangesToNatItem PrimaryIpRange { get; } = new RouterNatSubnetworkToNatSourceIpRangesToNatItem("PRIMARY_IP_RANGE");

        public static bool operator ==(RouterNatSubnetworkToNatSourceIpRangesToNatItem left, RouterNatSubnetworkToNatSourceIpRangesToNatItem right) => left.Equals(right);
        public static bool operator !=(RouterNatSubnetworkToNatSourceIpRangesToNatItem left, RouterNatSubnetworkToNatSourceIpRangesToNatItem right) => !left.Equals(right);

        public static explicit operator string(RouterNatSubnetworkToNatSourceIpRangesToNatItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterNatSubnetworkToNatSourceIpRangesToNatItem other && Equals(other);
        public bool Equals(RouterNatSubnetworkToNatSourceIpRangesToNatItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required
    /// </summary>
    [EnumType]
    public readonly struct RuleAction : IEquatable<RuleAction>
    {
        private readonly string _value;

        private RuleAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleAction Allow { get; } = new RuleAction("ALLOW");
        public static RuleAction AllowWithLog { get; } = new RuleAction("ALLOW_WITH_LOG");
        public static RuleAction Deny { get; } = new RuleAction("DENY");
        public static RuleAction DenyWithLog { get; } = new RuleAction("DENY_WITH_LOG");
        public static RuleAction Log { get; } = new RuleAction("LOG");
        public static RuleAction NoAction { get; } = new RuleAction("NO_ACTION");

        public static bool operator ==(RuleAction left, RuleAction right) => left.Equals(right);
        public static bool operator !=(RuleAction left, RuleAction right) => !left.Equals(right);

        public static explicit operator string(RuleAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleAction other && Equals(other);
        public bool Equals(RuleAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how port is selected for health checking, can be one of following values:
    /// USE_FIXED_PORT: The port number in port is used for health checking.
    /// USE_NAMED_PORT: The portName is used for health checking.
    /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
    /// 
    /// 
    /// If not specified, SSL health check follows behavior specified in port and portName fields.
    /// </summary>
    [EnumType]
    public readonly struct SSLHealthCheckPortSpecification : IEquatable<SSLHealthCheckPortSpecification>
    {
        private readonly string _value;

        private SSLHealthCheckPortSpecification(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SSLHealthCheckPortSpecification UseFixedPort { get; } = new SSLHealthCheckPortSpecification("USE_FIXED_PORT");
        public static SSLHealthCheckPortSpecification UseNamedPort { get; } = new SSLHealthCheckPortSpecification("USE_NAMED_PORT");
        public static SSLHealthCheckPortSpecification UseServingPort { get; } = new SSLHealthCheckPortSpecification("USE_SERVING_PORT");

        public static bool operator ==(SSLHealthCheckPortSpecification left, SSLHealthCheckPortSpecification right) => left.Equals(right);
        public static bool operator !=(SSLHealthCheckPortSpecification left, SSLHealthCheckPortSpecification right) => !left.Equals(right);

        public static explicit operator string(SSLHealthCheckPortSpecification value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SSLHealthCheckPortSpecification other && Equals(other);
        public bool Equals(SSLHealthCheckPortSpecification other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
    /// </summary>
    [EnumType]
    public readonly struct SSLHealthCheckProxyHeader : IEquatable<SSLHealthCheckProxyHeader>
    {
        private readonly string _value;

        private SSLHealthCheckProxyHeader(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SSLHealthCheckProxyHeader None { get; } = new SSLHealthCheckProxyHeader("NONE");
        public static SSLHealthCheckProxyHeader ProxyV1 { get; } = new SSLHealthCheckProxyHeader("PROXY_V1");

        public static bool operator ==(SSLHealthCheckProxyHeader left, SSLHealthCheckProxyHeader right) => left.Equals(right);
        public static bool operator !=(SSLHealthCheckProxyHeader left, SSLHealthCheckProxyHeader right) => !left.Equals(right);

        public static explicit operator string(SSLHealthCheckProxyHeader value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SSLHealthCheckProxyHeader other && Equals(other);
        public bool Equals(SSLHealthCheckProxyHeader other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME.
    /// </summary>
    [EnumType]
    public readonly struct SavedAttachedDiskInterface : IEquatable<SavedAttachedDiskInterface>
    {
        private readonly string _value;

        private SavedAttachedDiskInterface(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SavedAttachedDiskInterface Nvdimm { get; } = new SavedAttachedDiskInterface("NVDIMM");
        public static SavedAttachedDiskInterface Nvme { get; } = new SavedAttachedDiskInterface("NVME");
        public static SavedAttachedDiskInterface Scsi { get; } = new SavedAttachedDiskInterface("SCSI");

        public static bool operator ==(SavedAttachedDiskInterface left, SavedAttachedDiskInterface right) => left.Equals(right);
        public static bool operator !=(SavedAttachedDiskInterface left, SavedAttachedDiskInterface right) => !left.Equals(right);

        public static explicit operator string(SavedAttachedDiskInterface value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SavedAttachedDiskInterface other && Equals(other);
        public bool Equals(SavedAttachedDiskInterface other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The mode in which this disk is attached to the source instance, either READ_WRITE or READ_ONLY.
    /// </summary>
    [EnumType]
    public readonly struct SavedAttachedDiskMode : IEquatable<SavedAttachedDiskMode>
    {
        private readonly string _value;

        private SavedAttachedDiskMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SavedAttachedDiskMode ReadOnly { get; } = new SavedAttachedDiskMode("READ_ONLY");
        public static SavedAttachedDiskMode ReadWrite { get; } = new SavedAttachedDiskMode("READ_WRITE");

        public static bool operator ==(SavedAttachedDiskMode left, SavedAttachedDiskMode right) => left.Equals(right);
        public static bool operator !=(SavedAttachedDiskMode left, SavedAttachedDiskMode right) => !left.Equals(right);

        public static explicit operator string(SavedAttachedDiskMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SavedAttachedDiskMode other && Equals(other);
        public bool Equals(SavedAttachedDiskMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] An indicator whether storageBytes is in a stable state or it is being adjusted as a result of shared storage reallocation. This status can either be UPDATING, meaning the size of the snapshot is being updated, or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
    /// </summary>
    [EnumType]
    public readonly struct SavedAttachedDiskStorageBytesStatus : IEquatable<SavedAttachedDiskStorageBytesStatus>
    {
        private readonly string _value;

        private SavedAttachedDiskStorageBytesStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SavedAttachedDiskStorageBytesStatus Updating { get; } = new SavedAttachedDiskStorageBytesStatus("UPDATING");
        public static SavedAttachedDiskStorageBytesStatus UpToDate { get; } = new SavedAttachedDiskStorageBytesStatus("UP_TO_DATE");

        public static bool operator ==(SavedAttachedDiskStorageBytesStatus left, SavedAttachedDiskStorageBytesStatus right) => left.Equals(right);
        public static bool operator !=(SavedAttachedDiskStorageBytesStatus left, SavedAttachedDiskStorageBytesStatus right) => !left.Equals(right);

        public static explicit operator string(SavedAttachedDiskStorageBytesStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SavedAttachedDiskStorageBytesStatus other && Equals(other);
        public bool Equals(SavedAttachedDiskStorageBytesStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of the attached disk, either SCRATCH or PERSISTENT.
    /// </summary>
    [EnumType]
    public readonly struct SavedAttachedDiskType : IEquatable<SavedAttachedDiskType>
    {
        private readonly string _value;

        private SavedAttachedDiskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SavedAttachedDiskType Persistent { get; } = new SavedAttachedDiskType("PERSISTENT");
        public static SavedAttachedDiskType Scratch { get; } = new SavedAttachedDiskType("SCRATCH");

        public static bool operator ==(SavedAttachedDiskType left, SavedAttachedDiskType right) => left.Equals(right);
        public static bool operator !=(SavedAttachedDiskType left, SavedAttachedDiskType right) => !left.Equals(right);

        public static explicit operator string(SavedAttachedDiskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SavedAttachedDiskType other && Equals(other);
        public bool Equals(SavedAttachedDiskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether this VM may be a stable fleet VM. Setting this to "Periodic" designates this VM as a Stable Fleet VM.
    /// 
    /// See go/stable-fleet-ug for more details.
    /// </summary>
    [EnumType]
    public readonly struct SchedulingMaintenanceInterval : IEquatable<SchedulingMaintenanceInterval>
    {
        private readonly string _value;

        private SchedulingMaintenanceInterval(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SchedulingMaintenanceInterval Periodic { get; } = new SchedulingMaintenanceInterval("PERIODIC");

        public static bool operator ==(SchedulingMaintenanceInterval left, SchedulingMaintenanceInterval right) => left.Equals(right);
        public static bool operator !=(SchedulingMaintenanceInterval left, SchedulingMaintenanceInterval right) => !left.Equals(right);

        public static explicit operator string(SchedulingMaintenanceInterval value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SchedulingMaintenanceInterval other && Equals(other);
        public bool Equals(SchedulingMaintenanceInterval other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines the operation of node selection. Valid operators are IN for affinity and NOT_IN for anti-affinity.
    /// </summary>
    [EnumType]
    public readonly struct SchedulingNodeAffinityOperator : IEquatable<SchedulingNodeAffinityOperator>
    {
        private readonly string _value;

        private SchedulingNodeAffinityOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SchedulingNodeAffinityOperator In { get; } = new SchedulingNodeAffinityOperator("IN");
        public static SchedulingNodeAffinityOperator NotIn { get; } = new SchedulingNodeAffinityOperator("NOT_IN");
        public static SchedulingNodeAffinityOperator OperatorUnspecified { get; } = new SchedulingNodeAffinityOperator("OPERATOR_UNSPECIFIED");

        public static bool operator ==(SchedulingNodeAffinityOperator left, SchedulingNodeAffinityOperator right) => left.Equals(right);
        public static bool operator !=(SchedulingNodeAffinityOperator left, SchedulingNodeAffinityOperator right) => !left.Equals(right);

        public static explicit operator string(SchedulingNodeAffinityOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SchedulingNodeAffinityOperator other && Equals(other);
        public bool Equals(SchedulingNodeAffinityOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines the maintenance behavior for this instance. For standard instances, the default behavior is MIGRATE. For preemptible instances, the default and only possible behavior is TERMINATE. For more information, see Setting Instance Scheduling Options.
    /// </summary>
    [EnumType]
    public readonly struct SchedulingOnHostMaintenance : IEquatable<SchedulingOnHostMaintenance>
    {
        private readonly string _value;

        private SchedulingOnHostMaintenance(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SchedulingOnHostMaintenance Migrate { get; } = new SchedulingOnHostMaintenance("MIGRATE");
        public static SchedulingOnHostMaintenance Terminate { get; } = new SchedulingOnHostMaintenance("TERMINATE");

        public static bool operator ==(SchedulingOnHostMaintenance left, SchedulingOnHostMaintenance right) => left.Equals(right);
        public static bool operator !=(SchedulingOnHostMaintenance left, SchedulingOnHostMaintenance right) => !left.Equals(right);

        public static explicit operator string(SchedulingOnHostMaintenance value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SchedulingOnHostMaintenance other && Equals(other);
        public bool Equals(SchedulingOnHostMaintenance other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Rule visibility can be one of the following: STANDARD - opaque rules. (default) PREMIUM - transparent rules.
    /// </summary>
    [EnumType]
    public readonly struct SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility : IEquatable<SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility>
    {
        private readonly string _value;

        private SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility Premium { get; } = new SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility("PREMIUM");
        public static SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility Standard { get; } = new SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility("STANDARD");

        public static bool operator ==(SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility left, SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility right) => left.Equals(right);
        public static bool operator !=(SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility left, SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility right) => !left.Equals(right);

        public static explicit operator string(SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility other && Equals(other);
        public bool Equals(SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The direction in which this rule applies. This field may only be specified when versioned_expr is set to FIREWALL.
    /// </summary>
    [EnumType]
    public readonly struct SecurityPolicyRuleDirection : IEquatable<SecurityPolicyRuleDirection>
    {
        private readonly string _value;

        private SecurityPolicyRuleDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityPolicyRuleDirection Egress { get; } = new SecurityPolicyRuleDirection("EGRESS");
        public static SecurityPolicyRuleDirection Ingress { get; } = new SecurityPolicyRuleDirection("INGRESS");

        public static bool operator ==(SecurityPolicyRuleDirection left, SecurityPolicyRuleDirection right) => left.Equals(right);
        public static bool operator !=(SecurityPolicyRuleDirection left, SecurityPolicyRuleDirection right) => !left.Equals(right);

        public static explicit operator string(SecurityPolicyRuleDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPolicyRuleDirection other && Equals(other);
        public bool Equals(SecurityPolicyRuleDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Preconfigured versioned expression. If this field is specified, config must also be specified. Available preconfigured expressions along with their requirements are: SRC_IPS_V1 - must specify the corresponding src_ip_range field in config.
    /// </summary>
    [EnumType]
    public readonly struct SecurityPolicyRuleMatcherVersionedExpr : IEquatable<SecurityPolicyRuleMatcherVersionedExpr>
    {
        private readonly string _value;

        private SecurityPolicyRuleMatcherVersionedExpr(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityPolicyRuleMatcherVersionedExpr Firewall { get; } = new SecurityPolicyRuleMatcherVersionedExpr("FIREWALL");
        public static SecurityPolicyRuleMatcherVersionedExpr SrcIpsV1 { get; } = new SecurityPolicyRuleMatcherVersionedExpr("SRC_IPS_V1");

        public static bool operator ==(SecurityPolicyRuleMatcherVersionedExpr left, SecurityPolicyRuleMatcherVersionedExpr right) => left.Equals(right);
        public static bool operator !=(SecurityPolicyRuleMatcherVersionedExpr left, SecurityPolicyRuleMatcherVersionedExpr right) => !left.Equals(right);

        public static explicit operator string(SecurityPolicyRuleMatcherVersionedExpr value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPolicyRuleMatcherVersionedExpr other && Equals(other);
        public bool Equals(SecurityPolicyRuleMatcherVersionedExpr other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines the key to enforce the threshold_rps limit on. If key is "IP", each IP has this limit enforced separately, whereas "ALL_IPs" means a single limit is applied to all requests matching this rule.
    /// </summary>
    [EnumType]
    public readonly struct SecurityPolicyRuleRateLimitOptionsEnforceOnKey : IEquatable<SecurityPolicyRuleRateLimitOptionsEnforceOnKey>
    {
        private readonly string _value;

        private SecurityPolicyRuleRateLimitOptionsEnforceOnKey(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityPolicyRuleRateLimitOptionsEnforceOnKey AllIps { get; } = new SecurityPolicyRuleRateLimitOptionsEnforceOnKey("ALL_IPS");
        public static SecurityPolicyRuleRateLimitOptionsEnforceOnKey Ip { get; } = new SecurityPolicyRuleRateLimitOptionsEnforceOnKey("IP");

        public static bool operator ==(SecurityPolicyRuleRateLimitOptionsEnforceOnKey left, SecurityPolicyRuleRateLimitOptionsEnforceOnKey right) => left.Equals(right);
        public static bool operator !=(SecurityPolicyRuleRateLimitOptionsEnforceOnKey left, SecurityPolicyRuleRateLimitOptionsEnforceOnKey right) => !left.Equals(right);

        public static explicit operator string(SecurityPolicyRuleRateLimitOptionsEnforceOnKey value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPolicyRuleRateLimitOptionsEnforceOnKey other && Equals(other);
        public bool Equals(SecurityPolicyRuleRateLimitOptionsEnforceOnKey other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type indicates the intended use of the security policy. CLOUD_ARMOR policies apply to backend services. FIREWALL policies apply to organizations.
    /// </summary>
    [EnumType]
    public readonly struct SecurityPolicyType : IEquatable<SecurityPolicyType>
    {
        private readonly string _value;

        private SecurityPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityPolicyType CloudArmor { get; } = new SecurityPolicyType("CLOUD_ARMOR");
        public static SecurityPolicyType CloudArmorEdge { get; } = new SecurityPolicyType("CLOUD_ARMOR_EDGE");
        public static SecurityPolicyType Firewall { get; } = new SecurityPolicyType("FIREWALL");

        public static bool operator ==(SecurityPolicyType left, SecurityPolicyType right) => left.Equals(right);
        public static bool operator !=(SecurityPolicyType left, SecurityPolicyType right) => !left.Equals(right);

        public static explicit operator string(SecurityPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPolicyType other && Equals(other);
        public bool Equals(SecurityPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct ServerBindingType : IEquatable<ServerBindingType>
    {
        private readonly string _value;

        private ServerBindingType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServerBindingType RestartNodeOnAnyServer { get; } = new ServerBindingType("RESTART_NODE_ON_ANY_SERVER");
        public static ServerBindingType RestartNodeOnMinimalServers { get; } = new ServerBindingType("RESTART_NODE_ON_MINIMAL_SERVERS");
        public static ServerBindingType ServerBindingTypeUnspecified { get; } = new ServerBindingType("SERVER_BINDING_TYPE_UNSPECIFIED");

        public static bool operator ==(ServerBindingType left, ServerBindingType right) => left.Equals(right);
        public static bool operator !=(ServerBindingType left, ServerBindingType right) => !left.Equals(right);

        public static explicit operator string(ServerBindingType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServerBindingType other && Equals(other);
        public bool Equals(ServerBindingType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether connections should be secured using TLS. The value of this field determines how TLS is enforced. This field can be set to one of the following:  
    /// - SIMPLE Secure connections with standard TLS semantics.  
    /// - MUTUAL Secure connections to the backends using mutual TLS by presenting client certificates for authentication.
    /// </summary>
    [EnumType]
    public readonly struct ServerTlsSettingsTlsMode : IEquatable<ServerTlsSettingsTlsMode>
    {
        private readonly string _value;

        private ServerTlsSettingsTlsMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServerTlsSettingsTlsMode Invalid { get; } = new ServerTlsSettingsTlsMode("INVALID");
        public static ServerTlsSettingsTlsMode Mutual { get; } = new ServerTlsSettingsTlsMode("MUTUAL");
        public static ServerTlsSettingsTlsMode Simple { get; } = new ServerTlsSettingsTlsMode("SIMPLE");

        public static bool operator ==(ServerTlsSettingsTlsMode left, ServerTlsSettingsTlsMode right) => left.Equals(right);
        public static bool operator !=(ServerTlsSettingsTlsMode left, ServerTlsSettingsTlsMode right) => !left.Equals(right);

        public static explicit operator string(ServerTlsSettingsTlsMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServerTlsSettingsTlsMode other && Equals(other);
        public bool Equals(ServerTlsSettingsTlsMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of a connected endpoint to this service attachment.
    /// </summary>
    [EnumType]
    public readonly struct ServiceAttachmentConnectedEndpointStatus : IEquatable<ServiceAttachmentConnectedEndpointStatus>
    {
        private readonly string _value;

        private ServiceAttachmentConnectedEndpointStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceAttachmentConnectedEndpointStatus Accepted { get; } = new ServiceAttachmentConnectedEndpointStatus("ACCEPTED");
        public static ServiceAttachmentConnectedEndpointStatus Closed { get; } = new ServiceAttachmentConnectedEndpointStatus("CLOSED");
        public static ServiceAttachmentConnectedEndpointStatus Pending { get; } = new ServiceAttachmentConnectedEndpointStatus("PENDING");
        public static ServiceAttachmentConnectedEndpointStatus Rejected { get; } = new ServiceAttachmentConnectedEndpointStatus("REJECTED");
        public static ServiceAttachmentConnectedEndpointStatus StatusUnspecified { get; } = new ServiceAttachmentConnectedEndpointStatus("STATUS_UNSPECIFIED");

        public static bool operator ==(ServiceAttachmentConnectedEndpointStatus left, ServiceAttachmentConnectedEndpointStatus right) => left.Equals(right);
        public static bool operator !=(ServiceAttachmentConnectedEndpointStatus left, ServiceAttachmentConnectedEndpointStatus right) => !left.Equals(right);

        public static explicit operator string(ServiceAttachmentConnectedEndpointStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceAttachmentConnectedEndpointStatus other && Equals(other);
        public bool Equals(ServiceAttachmentConnectedEndpointStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The connection preference of service attachment. The value can be set to ACCEPT_AUTOMATIC. An ACCEPT_AUTOMATIC service attachment is one that always accepts the connection from consumer forwarding rules.
    /// </summary>
    [EnumType]
    public readonly struct ServiceAttachmentConnectionPreference : IEquatable<ServiceAttachmentConnectionPreference>
    {
        private readonly string _value;

        private ServiceAttachmentConnectionPreference(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceAttachmentConnectionPreference AcceptAutomatic { get; } = new ServiceAttachmentConnectionPreference("ACCEPT_AUTOMATIC");
        public static ServiceAttachmentConnectionPreference AcceptManual { get; } = new ServiceAttachmentConnectionPreference("ACCEPT_MANUAL");
        public static ServiceAttachmentConnectionPreference ConnectionPreferenceUnspecified { get; } = new ServiceAttachmentConnectionPreference("CONNECTION_PREFERENCE_UNSPECIFIED");

        public static bool operator ==(ServiceAttachmentConnectionPreference left, ServiceAttachmentConnectionPreference right) => left.Equals(right);
        public static bool operator !=(ServiceAttachmentConnectionPreference left, ServiceAttachmentConnectionPreference right) => !left.Equals(right);

        public static explicit operator string(ServiceAttachmentConnectionPreference value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceAttachmentConnectionPreference other && Equals(other);
        public bool Equals(ServiceAttachmentConnectionPreference other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of the forwarding rule.
    /// </summary>
    [EnumType]
    public readonly struct ServiceAttachmentConsumerForwardingRuleStatus : IEquatable<ServiceAttachmentConsumerForwardingRuleStatus>
    {
        private readonly string _value;

        private ServiceAttachmentConsumerForwardingRuleStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceAttachmentConsumerForwardingRuleStatus Accepted { get; } = new ServiceAttachmentConsumerForwardingRuleStatus("ACCEPTED");
        public static ServiceAttachmentConsumerForwardingRuleStatus Closed { get; } = new ServiceAttachmentConsumerForwardingRuleStatus("CLOSED");
        public static ServiceAttachmentConsumerForwardingRuleStatus Pending { get; } = new ServiceAttachmentConsumerForwardingRuleStatus("PENDING");
        public static ServiceAttachmentConsumerForwardingRuleStatus Rejected { get; } = new ServiceAttachmentConsumerForwardingRuleStatus("REJECTED");
        public static ServiceAttachmentConsumerForwardingRuleStatus StatusUnspecified { get; } = new ServiceAttachmentConsumerForwardingRuleStatus("STATUS_UNSPECIFIED");

        public static bool operator ==(ServiceAttachmentConsumerForwardingRuleStatus left, ServiceAttachmentConsumerForwardingRuleStatus right) => left.Equals(right);
        public static bool operator !=(ServiceAttachmentConsumerForwardingRuleStatus left, ServiceAttachmentConsumerForwardingRuleStatus right) => !left.Equals(right);

        public static explicit operator string(ServiceAttachmentConsumerForwardingRuleStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceAttachmentConsumerForwardingRuleStatus other && Equals(other);
        public bool Equals(ServiceAttachmentConsumerForwardingRuleStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the snapshot. This can be CREATING, DELETING, FAILED, READY, or UPLOADING.
    /// </summary>
    [EnumType]
    public readonly struct SnapshotStatus : IEquatable<SnapshotStatus>
    {
        private readonly string _value;

        private SnapshotStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SnapshotStatus Creating { get; } = new SnapshotStatus("CREATING");
        public static SnapshotStatus Deleting { get; } = new SnapshotStatus("DELETING");
        public static SnapshotStatus Failed { get; } = new SnapshotStatus("FAILED");
        public static SnapshotStatus Ready { get; } = new SnapshotStatus("READY");
        public static SnapshotStatus Uploading { get; } = new SnapshotStatus("UPLOADING");

        public static bool operator ==(SnapshotStatus left, SnapshotStatus right) => left.Equals(right);
        public static bool operator !=(SnapshotStatus left, SnapshotStatus right) => !left.Equals(right);

        public static explicit operator string(SnapshotStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SnapshotStatus other && Equals(other);
        public bool Equals(SnapshotStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] An indicator whether storageBytes is in a stable state or it is being adjusted as a result of shared storage reallocation. This status can either be UPDATING, meaning the size of the snapshot is being updated, or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
    /// </summary>
    [EnumType]
    public readonly struct SnapshotStorageBytesStatus : IEquatable<SnapshotStorageBytesStatus>
    {
        private readonly string _value;

        private SnapshotStorageBytesStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SnapshotStorageBytesStatus Updating { get; } = new SnapshotStorageBytesStatus("UPDATING");
        public static SnapshotStorageBytesStatus UpToDate { get; } = new SnapshotStorageBytesStatus("UP_TO_DATE");

        public static bool operator ==(SnapshotStorageBytesStatus left, SnapshotStorageBytesStatus right) => left.Equals(right);
        public static bool operator !=(SnapshotStorageBytesStatus left, SnapshotStorageBytesStatus right) => !left.Equals(right);

        public static explicit operator string(SnapshotStorageBytesStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SnapshotStorageBytesStatus other && Equals(other);
        public bool Equals(SnapshotStorageBytesStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// PostKeyRevocationActionType of the instance.
    /// </summary>
    [EnumType]
    public readonly struct SourceInstancePropertiesPostKeyRevocationActionType : IEquatable<SourceInstancePropertiesPostKeyRevocationActionType>
    {
        private readonly string _value;

        private SourceInstancePropertiesPostKeyRevocationActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SourceInstancePropertiesPostKeyRevocationActionType Noop { get; } = new SourceInstancePropertiesPostKeyRevocationActionType("NOOP");
        public static SourceInstancePropertiesPostKeyRevocationActionType PostKeyRevocationActionTypeUnspecified { get; } = new SourceInstancePropertiesPostKeyRevocationActionType("POST_KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED");
        public static SourceInstancePropertiesPostKeyRevocationActionType Shutdown { get; } = new SourceInstancePropertiesPostKeyRevocationActionType("SHUTDOWN");

        public static bool operator ==(SourceInstancePropertiesPostKeyRevocationActionType left, SourceInstancePropertiesPostKeyRevocationActionType right) => left.Equals(right);
        public static bool operator !=(SourceInstancePropertiesPostKeyRevocationActionType left, SourceInstancePropertiesPostKeyRevocationActionType right) => !left.Equals(right);

        public static explicit operator string(SourceInstancePropertiesPostKeyRevocationActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SourceInstancePropertiesPostKeyRevocationActionType other && Equals(other);
        public bool Equals(SourceInstancePropertiesPostKeyRevocationActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output only] Status of the managed certificate resource.
    /// </summary>
    [EnumType]
    public readonly struct SslCertificateManagedSslCertificateStatus : IEquatable<SslCertificateManagedSslCertificateStatus>
    {
        private readonly string _value;

        private SslCertificateManagedSslCertificateStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SslCertificateManagedSslCertificateStatus Active { get; } = new SslCertificateManagedSslCertificateStatus("ACTIVE");
        public static SslCertificateManagedSslCertificateStatus ManagedCertificateStatusUnspecified { get; } = new SslCertificateManagedSslCertificateStatus("MANAGED_CERTIFICATE_STATUS_UNSPECIFIED");
        public static SslCertificateManagedSslCertificateStatus Provisioning { get; } = new SslCertificateManagedSslCertificateStatus("PROVISIONING");
        public static SslCertificateManagedSslCertificateStatus ProvisioningFailed { get; } = new SslCertificateManagedSslCertificateStatus("PROVISIONING_FAILED");
        public static SslCertificateManagedSslCertificateStatus ProvisioningFailedPermanently { get; } = new SslCertificateManagedSslCertificateStatus("PROVISIONING_FAILED_PERMANENTLY");
        public static SslCertificateManagedSslCertificateStatus RenewalFailed { get; } = new SslCertificateManagedSslCertificateStatus("RENEWAL_FAILED");

        public static bool operator ==(SslCertificateManagedSslCertificateStatus left, SslCertificateManagedSslCertificateStatus right) => left.Equals(right);
        public static bool operator !=(SslCertificateManagedSslCertificateStatus left, SslCertificateManagedSslCertificateStatus right) => !left.Equals(right);

        public static explicit operator string(SslCertificateManagedSslCertificateStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SslCertificateManagedSslCertificateStatus other && Equals(other);
        public bool Equals(SslCertificateManagedSslCertificateStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// (Optional) Specifies the type of SSL certificate, either "SELF_MANAGED" or "MANAGED". If not specified, the certificate is self-managed and the fields certificate and private_key are used.
    /// </summary>
    [EnumType]
    public readonly struct SslCertificateType : IEquatable<SslCertificateType>
    {
        private readonly string _value;

        private SslCertificateType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SslCertificateType Managed { get; } = new SslCertificateType("MANAGED");
        public static SslCertificateType SelfManaged { get; } = new SslCertificateType("SELF_MANAGED");
        public static SslCertificateType TypeUnspecified { get; } = new SslCertificateType("TYPE_UNSPECIFIED");

        public static bool operator ==(SslCertificateType left, SslCertificateType right) => left.Equals(right);
        public static bool operator !=(SslCertificateType left, SslCertificateType right) => !left.Equals(right);

        public static explicit operator string(SslCertificateType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SslCertificateType other && Equals(other);
        public bool Equals(SslCertificateType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The minimum version of SSL protocol that can be used by the clients to establish a connection with the load balancer. This can be one of TLS_1_0, TLS_1_1, TLS_1_2.
    /// </summary>
    [EnumType]
    public readonly struct SslPolicyMinTlsVersion : IEquatable<SslPolicyMinTlsVersion>
    {
        private readonly string _value;

        private SslPolicyMinTlsVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SslPolicyMinTlsVersion Tls10 { get; } = new SslPolicyMinTlsVersion("TLS_1_0");
        public static SslPolicyMinTlsVersion Tls11 { get; } = new SslPolicyMinTlsVersion("TLS_1_1");
        public static SslPolicyMinTlsVersion Tls12 { get; } = new SslPolicyMinTlsVersion("TLS_1_2");

        public static bool operator ==(SslPolicyMinTlsVersion left, SslPolicyMinTlsVersion right) => left.Equals(right);
        public static bool operator !=(SslPolicyMinTlsVersion left, SslPolicyMinTlsVersion right) => !left.Equals(right);

        public static explicit operator string(SslPolicyMinTlsVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SslPolicyMinTlsVersion other && Equals(other);
        public bool Equals(SslPolicyMinTlsVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Profile specifies the set of SSL features that can be used by the load balancer when negotiating SSL with clients. This can be one of COMPATIBLE, MODERN, RESTRICTED, or CUSTOM. If using CUSTOM, the set of SSL features to enable must be specified in the customFeatures field.
    /// </summary>
    [EnumType]
    public readonly struct SslPolicyProfile : IEquatable<SslPolicyProfile>
    {
        private readonly string _value;

        private SslPolicyProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SslPolicyProfile Compatible { get; } = new SslPolicyProfile("COMPATIBLE");
        public static SslPolicyProfile Custom { get; } = new SslPolicyProfile("CUSTOM");
        public static SslPolicyProfile Modern { get; } = new SslPolicyProfile("MODERN");
        public static SslPolicyProfile Restricted { get; } = new SslPolicyProfile("RESTRICTED");

        public static bool operator ==(SslPolicyProfile left, SslPolicyProfile right) => left.Equals(right);
        public static bool operator !=(SslPolicyProfile left, SslPolicyProfile right) => !left.Equals(right);

        public static explicit operator string(SslPolicyProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SslPolicyProfile other && Equals(other);
        public bool Equals(SslPolicyProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
    /// </summary>
    [EnumType]
    public readonly struct SslPolicyWarningsItemCode : IEquatable<SslPolicyWarningsItemCode>
    {
        private readonly string _value;

        private SslPolicyWarningsItemCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SslPolicyWarningsItemCode CleanupFailed { get; } = new SslPolicyWarningsItemCode("CLEANUP_FAILED");
        public static SslPolicyWarningsItemCode DeprecatedResourceUsed { get; } = new SslPolicyWarningsItemCode("DEPRECATED_RESOURCE_USED");
        public static SslPolicyWarningsItemCode DeprecatedTypeUsed { get; } = new SslPolicyWarningsItemCode("DEPRECATED_TYPE_USED");
        public static SslPolicyWarningsItemCode DiskSizeLargerThanImageSize { get; } = new SslPolicyWarningsItemCode("DISK_SIZE_LARGER_THAN_IMAGE_SIZE");
        public static SslPolicyWarningsItemCode ExperimentalTypeUsed { get; } = new SslPolicyWarningsItemCode("EXPERIMENTAL_TYPE_USED");
        public static SslPolicyWarningsItemCode ExternalApiWarning { get; } = new SslPolicyWarningsItemCode("EXTERNAL_API_WARNING");
        public static SslPolicyWarningsItemCode FieldValueOverriden { get; } = new SslPolicyWarningsItemCode("FIELD_VALUE_OVERRIDEN");
        public static SslPolicyWarningsItemCode InjectedKernelsDeprecated { get; } = new SslPolicyWarningsItemCode("INJECTED_KERNELS_DEPRECATED");
        public static SslPolicyWarningsItemCode LargeDeploymentWarning { get; } = new SslPolicyWarningsItemCode("LARGE_DEPLOYMENT_WARNING");
        public static SslPolicyWarningsItemCode MissingTypeDependency { get; } = new SslPolicyWarningsItemCode("MISSING_TYPE_DEPENDENCY");
        public static SslPolicyWarningsItemCode NextHopAddressNotAssigned { get; } = new SslPolicyWarningsItemCode("NEXT_HOP_ADDRESS_NOT_ASSIGNED");
        public static SslPolicyWarningsItemCode NextHopCannotIpForward { get; } = new SslPolicyWarningsItemCode("NEXT_HOP_CANNOT_IP_FORWARD");
        public static SslPolicyWarningsItemCode NextHopInstanceNotFound { get; } = new SslPolicyWarningsItemCode("NEXT_HOP_INSTANCE_NOT_FOUND");
        public static SslPolicyWarningsItemCode NextHopInstanceNotOnNetwork { get; } = new SslPolicyWarningsItemCode("NEXT_HOP_INSTANCE_NOT_ON_NETWORK");
        public static SslPolicyWarningsItemCode NextHopNotRunning { get; } = new SslPolicyWarningsItemCode("NEXT_HOP_NOT_RUNNING");
        public static SslPolicyWarningsItemCode NotCriticalError { get; } = new SslPolicyWarningsItemCode("NOT_CRITICAL_ERROR");
        public static SslPolicyWarningsItemCode NoResultsOnPage { get; } = new SslPolicyWarningsItemCode("NO_RESULTS_ON_PAGE");
        public static SslPolicyWarningsItemCode PartialSuccess { get; } = new SslPolicyWarningsItemCode("PARTIAL_SUCCESS");
        public static SslPolicyWarningsItemCode RequiredTosAgreement { get; } = new SslPolicyWarningsItemCode("REQUIRED_TOS_AGREEMENT");
        public static SslPolicyWarningsItemCode ResourceInUseByOtherResourceWarning { get; } = new SslPolicyWarningsItemCode("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING");
        public static SslPolicyWarningsItemCode ResourceNotDeleted { get; } = new SslPolicyWarningsItemCode("RESOURCE_NOT_DELETED");
        public static SslPolicyWarningsItemCode SchemaValidationIgnored { get; } = new SslPolicyWarningsItemCode("SCHEMA_VALIDATION_IGNORED");
        public static SslPolicyWarningsItemCode SingleInstancePropertyTemplate { get; } = new SslPolicyWarningsItemCode("SINGLE_INSTANCE_PROPERTY_TEMPLATE");
        public static SslPolicyWarningsItemCode UndeclaredProperties { get; } = new SslPolicyWarningsItemCode("UNDECLARED_PROPERTIES");
        public static SslPolicyWarningsItemCode Unreachable { get; } = new SslPolicyWarningsItemCode("UNREACHABLE");

        public static bool operator ==(SslPolicyWarningsItemCode left, SslPolicyWarningsItemCode right) => left.Equals(right);
        public static bool operator !=(SslPolicyWarningsItemCode left, SslPolicyWarningsItemCode right) => !left.Equals(right);

        public static explicit operator string(SslPolicyWarningsItemCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SslPolicyWarningsItemCode other && Equals(other);
        public bool Equals(SslPolicyWarningsItemCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Can only be specified if VPC flow logging for this subnetwork is enabled. Sets the aggregation interval for collecting flow logs. Increasing the interval time reduces the amount of generated flow logs for long-lasting connections. Default is an interval of 5 seconds per connection. Valid values: INTERVAL_5_SEC, INTERVAL_30_SEC, INTERVAL_1_MIN, INTERVAL_5_MIN, INTERVAL_10_MIN, INTERVAL_15_MIN.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkAggregationInterval : IEquatable<SubnetworkAggregationInterval>
    {
        private readonly string _value;

        private SubnetworkAggregationInterval(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubnetworkAggregationInterval Interval10Min { get; } = new SubnetworkAggregationInterval("INTERVAL_10_MIN");
        public static SubnetworkAggregationInterval Interval15Min { get; } = new SubnetworkAggregationInterval("INTERVAL_15_MIN");
        public static SubnetworkAggregationInterval Interval1Min { get; } = new SubnetworkAggregationInterval("INTERVAL_1_MIN");
        public static SubnetworkAggregationInterval Interval30Sec { get; } = new SubnetworkAggregationInterval("INTERVAL_30_SEC");
        public static SubnetworkAggregationInterval Interval5Min { get; } = new SubnetworkAggregationInterval("INTERVAL_5_MIN");
        public static SubnetworkAggregationInterval Interval5Sec { get; } = new SubnetworkAggregationInterval("INTERVAL_5_SEC");

        public static bool operator ==(SubnetworkAggregationInterval left, SubnetworkAggregationInterval right) => left.Equals(right);
        public static bool operator !=(SubnetworkAggregationInterval left, SubnetworkAggregationInterval right) => !left.Equals(right);

        public static explicit operator string(SubnetworkAggregationInterval value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkAggregationInterval other && Equals(other);
        public bool Equals(SubnetworkAggregationInterval other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation or the first time the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then this subnet cannot enable direct path.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkIpv6AccessType : IEquatable<SubnetworkIpv6AccessType>
    {
        private readonly string _value;

        private SubnetworkIpv6AccessType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubnetworkIpv6AccessType External { get; } = new SubnetworkIpv6AccessType("EXTERNAL");
        public static SubnetworkIpv6AccessType Internal { get; } = new SubnetworkIpv6AccessType("INTERNAL");
        public static SubnetworkIpv6AccessType UnspecifiedIpv6AccessType { get; } = new SubnetworkIpv6AccessType("UNSPECIFIED_IPV6_ACCESS_TYPE");

        public static bool operator ==(SubnetworkIpv6AccessType left, SubnetworkIpv6AccessType right) => left.Equals(right);
        public static bool operator !=(SubnetworkIpv6AccessType left, SubnetworkIpv6AccessType right) => !left.Equals(right);

        public static explicit operator string(SubnetworkIpv6AccessType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkIpv6AccessType other && Equals(other);
        public bool Equals(SubnetworkIpv6AccessType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Can only be specified if VPC flow logging for this subnetwork is enabled. Toggles the aggregation interval for collecting flow logs. Increasing the interval time will reduce the amount of generated flow logs for long lasting connections. Default is an interval of 5 seconds per connection.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkLogConfigAggregationInterval : IEquatable<SubnetworkLogConfigAggregationInterval>
    {
        private readonly string _value;

        private SubnetworkLogConfigAggregationInterval(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubnetworkLogConfigAggregationInterval Interval10Min { get; } = new SubnetworkLogConfigAggregationInterval("INTERVAL_10_MIN");
        public static SubnetworkLogConfigAggregationInterval Interval15Min { get; } = new SubnetworkLogConfigAggregationInterval("INTERVAL_15_MIN");
        public static SubnetworkLogConfigAggregationInterval Interval1Min { get; } = new SubnetworkLogConfigAggregationInterval("INTERVAL_1_MIN");
        public static SubnetworkLogConfigAggregationInterval Interval30Sec { get; } = new SubnetworkLogConfigAggregationInterval("INTERVAL_30_SEC");
        public static SubnetworkLogConfigAggregationInterval Interval5Min { get; } = new SubnetworkLogConfigAggregationInterval("INTERVAL_5_MIN");
        public static SubnetworkLogConfigAggregationInterval Interval5Sec { get; } = new SubnetworkLogConfigAggregationInterval("INTERVAL_5_SEC");

        public static bool operator ==(SubnetworkLogConfigAggregationInterval left, SubnetworkLogConfigAggregationInterval right) => left.Equals(right);
        public static bool operator !=(SubnetworkLogConfigAggregationInterval left, SubnetworkLogConfigAggregationInterval right) => !left.Equals(right);

        public static explicit operator string(SubnetworkLogConfigAggregationInterval value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkLogConfigAggregationInterval other && Equals(other);
        public bool Equals(SubnetworkLogConfigAggregationInterval other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Can only be specified if VPC flow logs for this subnetwork is enabled. Configures whether all, none or a subset of metadata fields should be added to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkLogConfigMetadata : IEquatable<SubnetworkLogConfigMetadata>
    {
        private readonly string _value;

        private SubnetworkLogConfigMetadata(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubnetworkLogConfigMetadata CustomMetadata { get; } = new SubnetworkLogConfigMetadata("CUSTOM_METADATA");
        public static SubnetworkLogConfigMetadata ExcludeAllMetadata { get; } = new SubnetworkLogConfigMetadata("EXCLUDE_ALL_METADATA");
        public static SubnetworkLogConfigMetadata IncludeAllMetadata { get; } = new SubnetworkLogConfigMetadata("INCLUDE_ALL_METADATA");

        public static bool operator ==(SubnetworkLogConfigMetadata left, SubnetworkLogConfigMetadata right) => left.Equals(right);
        public static bool operator !=(SubnetworkLogConfigMetadata left, SubnetworkLogConfigMetadata right) => !left.Equals(right);

        public static explicit operator string(SubnetworkLogConfigMetadata value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkLogConfigMetadata other && Equals(other);
        public bool Equals(SubnetworkLogConfigMetadata other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Can only be specified if VPC flow logging for this subnetwork is enabled. Configures whether metadata fields should be added to the reported VPC flow logs. Options are INCLUDE_ALL_METADATA, EXCLUDE_ALL_METADATA, and CUSTOM_METADATA. Default is EXCLUDE_ALL_METADATA.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkMetadata : IEquatable<SubnetworkMetadata>
    {
        private readonly string _value;

        private SubnetworkMetadata(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubnetworkMetadata ExcludeAllMetadata { get; } = new SubnetworkMetadata("EXCLUDE_ALL_METADATA");
        public static SubnetworkMetadata IncludeAllMetadata { get; } = new SubnetworkMetadata("INCLUDE_ALL_METADATA");

        public static bool operator ==(SubnetworkMetadata left, SubnetworkMetadata right) => left.Equals(right);
        public static bool operator !=(SubnetworkMetadata left, SubnetworkMetadata right) => !left.Equals(right);

        public static explicit operator string(SubnetworkMetadata value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkMetadata other && Equals(other);
        public bool Equals(SubnetworkMetadata other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The private IPv6 google access type for the VMs in this subnet. This is an expanded field of enablePrivateV6Access. If both fields are set, privateIpv6GoogleAccess will take priority.
    /// 
    /// This field can be both set at resource creation time and updated using patch.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkPrivateIpv6GoogleAccess : IEquatable<SubnetworkPrivateIpv6GoogleAccess>
    {
        private readonly string _value;

        private SubnetworkPrivateIpv6GoogleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubnetworkPrivateIpv6GoogleAccess DisableGoogleAccess { get; } = new SubnetworkPrivateIpv6GoogleAccess("DISABLE_GOOGLE_ACCESS");
        public static SubnetworkPrivateIpv6GoogleAccess EnableBidirectionalAccessToGoogle { get; } = new SubnetworkPrivateIpv6GoogleAccess("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE");
        public static SubnetworkPrivateIpv6GoogleAccess EnableOutboundVmAccessToGoogle { get; } = new SubnetworkPrivateIpv6GoogleAccess("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE");
        public static SubnetworkPrivateIpv6GoogleAccess EnableOutboundVmAccessToGoogleForServiceAccounts { get; } = new SubnetworkPrivateIpv6GoogleAccess("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE_FOR_SERVICE_ACCOUNTS");

        public static bool operator ==(SubnetworkPrivateIpv6GoogleAccess left, SubnetworkPrivateIpv6GoogleAccess right) => left.Equals(right);
        public static bool operator !=(SubnetworkPrivateIpv6GoogleAccess left, SubnetworkPrivateIpv6GoogleAccess right) => !left.Equals(right);

        public static explicit operator string(SubnetworkPrivateIpv6GoogleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkPrivateIpv6GoogleAccess other && Equals(other);
        public bool Equals(SubnetworkPrivateIpv6GoogleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The purpose of the resource. This field can be either PRIVATE_RFC_1918 or INTERNAL_HTTPS_LOAD_BALANCER. A subnetwork with purpose set to INTERNAL_HTTPS_LOAD_BALANCER is a user-created subnetwork that is reserved for Internal HTTP(S) Load Balancing. If unspecified, the purpose defaults to PRIVATE_RFC_1918. The enableFlowLogs field isn't supported with the purpose field set to INTERNAL_HTTPS_LOAD_BALANCER.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkPurpose : IEquatable<SubnetworkPurpose>
    {
        private readonly string _value;

        private SubnetworkPurpose(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubnetworkPurpose Aggregate { get; } = new SubnetworkPurpose("AGGREGATE");
        public static SubnetworkPurpose CloudExtension { get; } = new SubnetworkPurpose("CLOUD_EXTENSION");
        public static SubnetworkPurpose InternalHttpsLoadBalancer { get; } = new SubnetworkPurpose("INTERNAL_HTTPS_LOAD_BALANCER");
        public static SubnetworkPurpose Private { get; } = new SubnetworkPurpose("PRIVATE");
        public static SubnetworkPurpose PrivateRfc1918 { get; } = new SubnetworkPurpose("PRIVATE_RFC_1918");
        public static SubnetworkPurpose PrivateServiceConnect { get; } = new SubnetworkPurpose("PRIVATE_SERVICE_CONNECT");

        public static bool operator ==(SubnetworkPurpose left, SubnetworkPurpose right) => left.Equals(right);
        public static bool operator !=(SubnetworkPurpose left, SubnetworkPurpose right) => !left.Equals(right);

        public static explicit operator string(SubnetworkPurpose value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkPurpose other && Equals(other);
        public bool Equals(SubnetworkPurpose other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The role of subnetwork. Currently, this field is only used when purpose = INTERNAL_HTTPS_LOAD_BALANCER. The value can be set to ACTIVE or BACKUP. An ACTIVE subnetwork is one that is currently being used for Internal HTTP(S) Load Balancing. A BACKUP subnetwork is one that is ready to be promoted to ACTIVE or is currently draining. This field can be updated with a patch request.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkRole : IEquatable<SubnetworkRole>
    {
        private readonly string _value;

        private SubnetworkRole(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubnetworkRole Active { get; } = new SubnetworkRole("ACTIVE");
        public static SubnetworkRole Backup { get; } = new SubnetworkRole("BACKUP");

        public static bool operator ==(SubnetworkRole left, SubnetworkRole right) => left.Equals(right);
        public static bool operator !=(SubnetworkRole left, SubnetworkRole right) => !left.Equals(right);

        public static explicit operator string(SubnetworkRole value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkRole other && Equals(other);
        public bool Equals(SubnetworkRole other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The stack type for this subnet to identify whether the IPv6 feature is enabled or not. If not specified IPV4_ONLY will be used.
    /// 
    /// This field can be both set at resource creation time and updated using patch.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkStackType : IEquatable<SubnetworkStackType>
    {
        private readonly string _value;

        private SubnetworkStackType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubnetworkStackType Ipv4Ipv6 { get; } = new SubnetworkStackType("IPV4_IPV6");
        public static SubnetworkStackType Ipv4Only { get; } = new SubnetworkStackType("IPV4_ONLY");
        public static SubnetworkStackType UnspecifiedStackType { get; } = new SubnetworkStackType("UNSPECIFIED_STACK_TYPE");

        public static bool operator ==(SubnetworkStackType left, SubnetworkStackType right) => left.Equals(right);
        public static bool operator !=(SubnetworkStackType left, SubnetworkStackType right) => !left.Equals(right);

        public static explicit operator string(SubnetworkStackType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkStackType other && Equals(other);
        public bool Equals(SubnetworkStackType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The state of the subnetwork, which can be one of the following values: READY: Subnetwork is created and ready to use DRAINING: only applicable to subnetworks that have the purpose set to INTERNAL_HTTPS_LOAD_BALANCER and indicates that connections to the load balancer are being drained. A subnetwork that is draining cannot be used or modified until it reaches a status of READY CREATING: Subnetwork is provisioning DELETING: Subnetwork is being deleted UPDATING: Subnetwork is being updated
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkState : IEquatable<SubnetworkState>
    {
        private readonly string _value;

        private SubnetworkState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubnetworkState Draining { get; } = new SubnetworkState("DRAINING");
        public static SubnetworkState Ready { get; } = new SubnetworkState("READY");

        public static bool operator ==(SubnetworkState left, SubnetworkState right) => left.Equals(right);
        public static bool operator !=(SubnetworkState left, SubnetworkState right) => !left.Equals(right);

        public static explicit operator string(SubnetworkState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkState other && Equals(other);
        public bool Equals(SubnetworkState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct SubsettingPolicy : IEquatable<SubsettingPolicy>
    {
        private readonly string _value;

        private SubsettingPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubsettingPolicy ConsistentHashSubsetting { get; } = new SubsettingPolicy("CONSISTENT_HASH_SUBSETTING");
        public static SubsettingPolicy None { get; } = new SubsettingPolicy("NONE");

        public static bool operator ==(SubsettingPolicy left, SubsettingPolicy right) => left.Equals(right);
        public static bool operator !=(SubsettingPolicy left, SubsettingPolicy right) => !left.Equals(right);

        public static explicit operator string(SubsettingPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubsettingPolicy other && Equals(other);
        public bool Equals(SubsettingPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how port is selected for health checking, can be one of following values:
    /// USE_FIXED_PORT: The port number in port is used for health checking.
    /// USE_NAMED_PORT: The portName is used for health checking.
    /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
    /// 
    /// 
    /// If not specified, TCP health check follows behavior specified in port and portName fields.
    /// </summary>
    [EnumType]
    public readonly struct TCPHealthCheckPortSpecification : IEquatable<TCPHealthCheckPortSpecification>
    {
        private readonly string _value;

        private TCPHealthCheckPortSpecification(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TCPHealthCheckPortSpecification UseFixedPort { get; } = new TCPHealthCheckPortSpecification("USE_FIXED_PORT");
        public static TCPHealthCheckPortSpecification UseNamedPort { get; } = new TCPHealthCheckPortSpecification("USE_NAMED_PORT");
        public static TCPHealthCheckPortSpecification UseServingPort { get; } = new TCPHealthCheckPortSpecification("USE_SERVING_PORT");

        public static bool operator ==(TCPHealthCheckPortSpecification left, TCPHealthCheckPortSpecification right) => left.Equals(right);
        public static bool operator !=(TCPHealthCheckPortSpecification left, TCPHealthCheckPortSpecification right) => !left.Equals(right);

        public static explicit operator string(TCPHealthCheckPortSpecification value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TCPHealthCheckPortSpecification other && Equals(other);
        public bool Equals(TCPHealthCheckPortSpecification other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
    /// </summary>
    [EnumType]
    public readonly struct TCPHealthCheckProxyHeader : IEquatable<TCPHealthCheckProxyHeader>
    {
        private readonly string _value;

        private TCPHealthCheckProxyHeader(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TCPHealthCheckProxyHeader None { get; } = new TCPHealthCheckProxyHeader("NONE");
        public static TCPHealthCheckProxyHeader ProxyV1 { get; } = new TCPHealthCheckProxyHeader("PROXY_V1");

        public static bool operator ==(TCPHealthCheckProxyHeader left, TCPHealthCheckProxyHeader right) => left.Equals(right);
        public static bool operator !=(TCPHealthCheckProxyHeader left, TCPHealthCheckProxyHeader right) => !left.Equals(right);

        public static explicit operator string(TCPHealthCheckProxyHeader value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TCPHealthCheckProxyHeader other && Equals(other);
        public bool Equals(TCPHealthCheckProxyHeader other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the QUIC override policy for this TargetHttpsProxy resource. This setting determines whether the load balancer attempts to negotiate QUIC with clients. You can specify NONE, ENABLE, or DISABLE.  
    /// - When quic-override is set to NONE, Google manages whether QUIC is used. 
    /// - When quic-override is set to ENABLE, the load balancer uses QUIC when possible. 
    /// - When quic-override is set to DISABLE, the load balancer doesn't use QUIC. 
    /// - If the quic-override flag is not specified, NONE is implied.
    /// </summary>
    [EnumType]
    public readonly struct TargetHttpsProxyQuicOverride : IEquatable<TargetHttpsProxyQuicOverride>
    {
        private readonly string _value;

        private TargetHttpsProxyQuicOverride(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TargetHttpsProxyQuicOverride Disable { get; } = new TargetHttpsProxyQuicOverride("DISABLE");
        public static TargetHttpsProxyQuicOverride Enable { get; } = new TargetHttpsProxyQuicOverride("ENABLE");
        public static TargetHttpsProxyQuicOverride None { get; } = new TargetHttpsProxyQuicOverride("NONE");

        public static bool operator ==(TargetHttpsProxyQuicOverride left, TargetHttpsProxyQuicOverride right) => left.Equals(right);
        public static bool operator !=(TargetHttpsProxyQuicOverride left, TargetHttpsProxyQuicOverride right) => !left.Equals(right);

        public static explicit operator string(TargetHttpsProxyQuicOverride value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetHttpsProxyQuicOverride other && Equals(other);
        public bool Equals(TargetHttpsProxyQuicOverride other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// NAT option controlling how IPs are NAT'ed to the instance. Currently only NO_NAT (default value) is supported.
    /// </summary>
    [EnumType]
    public readonly struct TargetInstanceNatPolicy : IEquatable<TargetInstanceNatPolicy>
    {
        private readonly string _value;

        private TargetInstanceNatPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TargetInstanceNatPolicy NoNat { get; } = new TargetInstanceNatPolicy("NO_NAT");

        public static bool operator ==(TargetInstanceNatPolicy left, TargetInstanceNatPolicy right) => left.Equals(right);
        public static bool operator !=(TargetInstanceNatPolicy left, TargetInstanceNatPolicy right) => !left.Equals(right);

        public static explicit operator string(TargetInstanceNatPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetInstanceNatPolicy other && Equals(other);
        public bool Equals(TargetInstanceNatPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Session affinity option, must be one of the following values:
    /// NONE: Connections from the same client IP may go to any instance in the pool.
    /// CLIENT_IP: Connections from the same client IP will go to the same instance in the pool while that instance remains healthy.
    /// CLIENT_IP_PROTO: Connections from the same client IP with the same IP protocol will go to the same instance in the pool while that instance remains healthy.
    /// </summary>
    [EnumType]
    public readonly struct TargetPoolSessionAffinity : IEquatable<TargetPoolSessionAffinity>
    {
        private readonly string _value;

        private TargetPoolSessionAffinity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TargetPoolSessionAffinity ClientIp { get; } = new TargetPoolSessionAffinity("CLIENT_IP");
        public static TargetPoolSessionAffinity ClientIpNoDestination { get; } = new TargetPoolSessionAffinity("CLIENT_IP_NO_DESTINATION");
        public static TargetPoolSessionAffinity ClientIpPortProto { get; } = new TargetPoolSessionAffinity("CLIENT_IP_PORT_PROTO");
        public static TargetPoolSessionAffinity ClientIpProto { get; } = new TargetPoolSessionAffinity("CLIENT_IP_PROTO");
        public static TargetPoolSessionAffinity GeneratedCookie { get; } = new TargetPoolSessionAffinity("GENERATED_COOKIE");
        public static TargetPoolSessionAffinity HeaderField { get; } = new TargetPoolSessionAffinity("HEADER_FIELD");
        public static TargetPoolSessionAffinity HttpCookie { get; } = new TargetPoolSessionAffinity("HTTP_COOKIE");
        public static TargetPoolSessionAffinity None { get; } = new TargetPoolSessionAffinity("NONE");

        public static bool operator ==(TargetPoolSessionAffinity left, TargetPoolSessionAffinity right) => left.Equals(right);
        public static bool operator !=(TargetPoolSessionAffinity left, TargetPoolSessionAffinity right) => !left.Equals(right);

        public static explicit operator string(TargetPoolSessionAffinity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetPoolSessionAffinity other && Equals(other);
        public bool Equals(TargetPoolSessionAffinity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
    /// </summary>
    [EnumType]
    public readonly struct TargetSslProxyProxyHeader : IEquatable<TargetSslProxyProxyHeader>
    {
        private readonly string _value;

        private TargetSslProxyProxyHeader(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TargetSslProxyProxyHeader None { get; } = new TargetSslProxyProxyHeader("NONE");
        public static TargetSslProxyProxyHeader ProxyV1 { get; } = new TargetSslProxyProxyHeader("PROXY_V1");

        public static bool operator ==(TargetSslProxyProxyHeader left, TargetSslProxyProxyHeader right) => left.Equals(right);
        public static bool operator !=(TargetSslProxyProxyHeader left, TargetSslProxyProxyHeader right) => !left.Equals(right);

        public static explicit operator string(TargetSslProxyProxyHeader value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetSslProxyProxyHeader other && Equals(other);
        public bool Equals(TargetSslProxyProxyHeader other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
    /// </summary>
    [EnumType]
    public readonly struct TargetTcpProxyProxyHeader : IEquatable<TargetTcpProxyProxyHeader>
    {
        private readonly string _value;

        private TargetTcpProxyProxyHeader(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TargetTcpProxyProxyHeader None { get; } = new TargetTcpProxyProxyHeader("NONE");
        public static TargetTcpProxyProxyHeader ProxyV1 { get; } = new TargetTcpProxyProxyHeader("PROXY_V1");

        public static bool operator ==(TargetTcpProxyProxyHeader left, TargetTcpProxyProxyHeader right) => left.Equals(right);
        public static bool operator !=(TargetTcpProxyProxyHeader left, TargetTcpProxyProxyHeader right) => !left.Equals(right);

        public static explicit operator string(TargetTcpProxyProxyHeader value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetTcpProxyProxyHeader other && Equals(other);
        public bool Equals(TargetTcpProxyProxyHeader other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the VPN gateway, which can be one of the following: CREATING, READY, FAILED, or DELETING.
    /// </summary>
    [EnumType]
    public readonly struct TargetVpnGatewayStatus : IEquatable<TargetVpnGatewayStatus>
    {
        private readonly string _value;

        private TargetVpnGatewayStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TargetVpnGatewayStatus Creating { get; } = new TargetVpnGatewayStatus("CREATING");
        public static TargetVpnGatewayStatus Deleting { get; } = new TargetVpnGatewayStatus("DELETING");
        public static TargetVpnGatewayStatus Failed { get; } = new TargetVpnGatewayStatus("FAILED");
        public static TargetVpnGatewayStatus Ready { get; } = new TargetVpnGatewayStatus("READY");

        public static bool operator ==(TargetVpnGatewayStatus left, TargetVpnGatewayStatus right) => left.Equals(right);
        public static bool operator !=(TargetVpnGatewayStatus left, TargetVpnGatewayStatus right) => !left.Equals(right);

        public static explicit operator string(TargetVpnGatewayStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetVpnGatewayStatus other && Equals(other);
        public bool Equals(TargetVpnGatewayStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines how TLS certificates are obtained.
    /// </summary>
    [EnumType]
    public readonly struct TlsCertificateContextCertificateSource : IEquatable<TlsCertificateContextCertificateSource>
    {
        private readonly string _value;

        private TlsCertificateContextCertificateSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TlsCertificateContextCertificateSource Invalid { get; } = new TlsCertificateContextCertificateSource("INVALID");
        public static TlsCertificateContextCertificateSource UsePath { get; } = new TlsCertificateContextCertificateSource("USE_PATH");
        public static TlsCertificateContextCertificateSource UseSds { get; } = new TlsCertificateContextCertificateSource("USE_SDS");

        public static bool operator ==(TlsCertificateContextCertificateSource left, TlsCertificateContextCertificateSource right) => left.Equals(right);
        public static bool operator !=(TlsCertificateContextCertificateSource left, TlsCertificateContextCertificateSource right) => !left.Equals(right);

        public static explicit operator string(TlsCertificateContextCertificateSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TlsCertificateContextCertificateSource other && Equals(other);
        public bool Equals(TlsCertificateContextCertificateSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines how TLS certificates are obtained.
    /// </summary>
    [EnumType]
    public readonly struct TlsValidationContextValidationSource : IEquatable<TlsValidationContextValidationSource>
    {
        private readonly string _value;

        private TlsValidationContextValidationSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TlsValidationContextValidationSource Invalid { get; } = new TlsValidationContextValidationSource("INVALID");
        public static TlsValidationContextValidationSource UsePath { get; } = new TlsValidationContextValidationSource("USE_PATH");
        public static TlsValidationContextValidationSource UseSds { get; } = new TlsValidationContextValidationSource("USE_SDS");

        public static bool operator ==(TlsValidationContextValidationSource left, TlsValidationContextValidationSource right) => left.Equals(right);
        public static bool operator !=(TlsValidationContextValidationSource left, TlsValidationContextValidationSource right) => !left.Equals(right);

        public static explicit operator string(TlsValidationContextValidationSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TlsValidationContextValidationSource other && Equals(other);
        public bool Equals(TlsValidationContextValidationSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines the type of maintenance.
    /// </summary>
    [EnumType]
    public readonly struct UpcomingMaintenanceType : IEquatable<UpcomingMaintenanceType>
    {
        private readonly string _value;

        private UpcomingMaintenanceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UpcomingMaintenanceType Scheduled { get; } = new UpcomingMaintenanceType("SCHEDULED");
        public static UpcomingMaintenanceType UnknownType { get; } = new UpcomingMaintenanceType("UNKNOWN_TYPE");
        public static UpcomingMaintenanceType Unscheduled { get; } = new UpcomingMaintenanceType("UNSCHEDULED");

        public static bool operator ==(UpcomingMaintenanceType left, UpcomingMaintenanceType right) => left.Equals(right);
        public static bool operator !=(UpcomingMaintenanceType left, UpcomingMaintenanceType right) => !left.Equals(right);

        public static explicit operator string(UpcomingMaintenanceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UpcomingMaintenanceType other && Equals(other);
        public bool Equals(UpcomingMaintenanceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the VPN tunnel, which can be one of the following: 
    /// - PROVISIONING: Resource is being allocated for the VPN tunnel. 
    /// - WAITING_FOR_FULL_CONFIG: Waiting to receive all VPN-related configs from the user. Network, TargetVpnGateway, VpnTunnel, ForwardingRule, and Route resources are needed to setup the VPN tunnel. 
    /// - FIRST_HANDSHAKE: Successful first handshake with the peer VPN. 
    /// - ESTABLISHED: Secure session is successfully established with the peer VPN. 
    /// - NETWORK_ERROR: Deprecated, replaced by NO_INCOMING_PACKETS 
    /// - AUTHORIZATION_ERROR: Auth error (for example, bad shared secret). 
    /// - NEGOTIATION_FAILURE: Handshake failed. 
    /// - DEPROVISIONING: Resources are being deallocated for the VPN tunnel. 
    /// - FAILED: Tunnel creation has failed and the tunnel is not ready to be used. 
    /// - NO_INCOMING_PACKETS: No incoming packets from peer. 
    /// - REJECTED: Tunnel configuration was rejected, can be result of being denied access. 
    /// - ALLOCATING_RESOURCES: Cloud VPN is in the process of allocating all required resources. 
    /// - STOPPED: Tunnel is stopped due to its Forwarding Rules being deleted for Classic VPN tunnels or the project is in frozen state. 
    /// - PEER_IDENTITY_MISMATCH: Peer identity does not match peer IP, probably behind NAT. 
    /// - TS_NARROWING_NOT_ALLOWED: Traffic selector narrowing not allowed for an HA-VPN tunnel.
    /// </summary>
    [EnumType]
    public readonly struct VpnTunnelStatus : IEquatable<VpnTunnelStatus>
    {
        private readonly string _value;

        private VpnTunnelStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpnTunnelStatus AllocatingResources { get; } = new VpnTunnelStatus("ALLOCATING_RESOURCES");
        public static VpnTunnelStatus AuthorizationError { get; } = new VpnTunnelStatus("AUTHORIZATION_ERROR");
        public static VpnTunnelStatus Deprovisioning { get; } = new VpnTunnelStatus("DEPROVISIONING");
        public static VpnTunnelStatus Established { get; } = new VpnTunnelStatus("ESTABLISHED");
        public static VpnTunnelStatus Failed { get; } = new VpnTunnelStatus("FAILED");
        public static VpnTunnelStatus FirstHandshake { get; } = new VpnTunnelStatus("FIRST_HANDSHAKE");
        public static VpnTunnelStatus NegotiationFailure { get; } = new VpnTunnelStatus("NEGOTIATION_FAILURE");
        public static VpnTunnelStatus NetworkError { get; } = new VpnTunnelStatus("NETWORK_ERROR");
        public static VpnTunnelStatus NoIncomingPackets { get; } = new VpnTunnelStatus("NO_INCOMING_PACKETS");
        public static VpnTunnelStatus Provisioning { get; } = new VpnTunnelStatus("PROVISIONING");
        public static VpnTunnelStatus Rejected { get; } = new VpnTunnelStatus("REJECTED");
        public static VpnTunnelStatus Stopped { get; } = new VpnTunnelStatus("STOPPED");
        public static VpnTunnelStatus WaitingForFullConfig { get; } = new VpnTunnelStatus("WAITING_FOR_FULL_CONFIG");

        public static bool operator ==(VpnTunnelStatus left, VpnTunnelStatus right) => left.Equals(right);
        public static bool operator !=(VpnTunnelStatus left, VpnTunnelStatus right) => !left.Equals(right);

        public static explicit operator string(VpnTunnelStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpnTunnelStatus other && Equals(other);
        public bool Equals(VpnTunnelStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the inPlaceSnapshot. This can be CREATING, DELETING, FAILED, or READY.
    /// </summary>
    [EnumType]
    public readonly struct ZoneInPlaceSnapshotStatus : IEquatable<ZoneInPlaceSnapshotStatus>
    {
        private readonly string _value;

        private ZoneInPlaceSnapshotStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ZoneInPlaceSnapshotStatus Creating { get; } = new ZoneInPlaceSnapshotStatus("CREATING");
        public static ZoneInPlaceSnapshotStatus Deleting { get; } = new ZoneInPlaceSnapshotStatus("DELETING");
        public static ZoneInPlaceSnapshotStatus Failed { get; } = new ZoneInPlaceSnapshotStatus("FAILED");
        public static ZoneInPlaceSnapshotStatus Ready { get; } = new ZoneInPlaceSnapshotStatus("READY");

        public static bool operator ==(ZoneInPlaceSnapshotStatus left, ZoneInPlaceSnapshotStatus right) => left.Equals(right);
        public static bool operator !=(ZoneInPlaceSnapshotStatus left, ZoneInPlaceSnapshotStatus right) => !left.Equals(right);

        public static explicit operator string(ZoneInPlaceSnapshotStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ZoneInPlaceSnapshotStatus other && Equals(other);
        public bool Equals(ZoneInPlaceSnapshotStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// [Output Only] The status of the instantSnapshot. This can be CREATING, DELETING, FAILED, or READY.
    /// </summary>
    [EnumType]
    public readonly struct ZoneInstantSnapshotStatus : IEquatable<ZoneInstantSnapshotStatus>
    {
        private readonly string _value;

        private ZoneInstantSnapshotStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ZoneInstantSnapshotStatus Creating { get; } = new ZoneInstantSnapshotStatus("CREATING");
        public static ZoneInstantSnapshotStatus Deleting { get; } = new ZoneInstantSnapshotStatus("DELETING");
        public static ZoneInstantSnapshotStatus Failed { get; } = new ZoneInstantSnapshotStatus("FAILED");
        public static ZoneInstantSnapshotStatus Ready { get; } = new ZoneInstantSnapshotStatus("READY");

        public static bool operator ==(ZoneInstantSnapshotStatus left, ZoneInstantSnapshotStatus right) => left.Equals(right);
        public static bool operator !=(ZoneInstantSnapshotStatus left, ZoneInstantSnapshotStatus right) => !left.Equals(right);

        public static explicit operator string(ZoneInstantSnapshotStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ZoneInstantSnapshotStatus other && Equals(other);
        public bool Equals(ZoneInstantSnapshotStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

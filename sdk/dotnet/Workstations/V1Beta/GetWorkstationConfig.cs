// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.GoogleNative.Workstations.V1Beta
{
    public static class GetWorkstationConfig
    {
        /// <summary>
        /// Returns the requested workstation configuration.
        /// </summary>
        public static Task<GetWorkstationConfigResult> InvokeAsync(GetWorkstationConfigArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.InvokeAsync<GetWorkstationConfigResult>("google-native:workstations/v1beta:getWorkstationConfig", args ?? new GetWorkstationConfigArgs(), options.WithDefaults());

        /// <summary>
        /// Returns the requested workstation configuration.
        /// </summary>
        public static Output<GetWorkstationConfigResult> Invoke(GetWorkstationConfigInvokeArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.Invoke<GetWorkstationConfigResult>("google-native:workstations/v1beta:getWorkstationConfig", args ?? new GetWorkstationConfigInvokeArgs(), options.WithDefaults());
    }


    public sealed class GetWorkstationConfigArgs : global::Pulumi.InvokeArgs
    {
        [Input("location", required: true)]
        public string Location { get; set; } = null!;

        [Input("project")]
        public string? Project { get; set; }

        [Input("workstationClusterId", required: true)]
        public string WorkstationClusterId { get; set; } = null!;

        [Input("workstationConfigId", required: true)]
        public string WorkstationConfigId { get; set; } = null!;

        public GetWorkstationConfigArgs()
        {
        }
        public static new GetWorkstationConfigArgs Empty => new GetWorkstationConfigArgs();
    }

    public sealed class GetWorkstationConfigInvokeArgs : global::Pulumi.InvokeArgs
    {
        [Input("location", required: true)]
        public Input<string> Location { get; set; } = null!;

        [Input("project")]
        public Input<string>? Project { get; set; }

        [Input("workstationClusterId", required: true)]
        public Input<string> WorkstationClusterId { get; set; } = null!;

        [Input("workstationConfigId", required: true)]
        public Input<string> WorkstationConfigId { get; set; } = null!;

        public GetWorkstationConfigInvokeArgs()
        {
        }
        public static new GetWorkstationConfigInvokeArgs Empty => new GetWorkstationConfigInvokeArgs();
    }


    [OutputType]
    public sealed class GetWorkstationConfigResult
    {
        /// <summary>
        /// Client-specified annotations.
        /// </summary>
        public readonly ImmutableDictionary<string, string> Annotations;
        /// <summary>
        /// Status conditions describing the current resource state.
        /// </summary>
        public readonly ImmutableArray<Outputs.StatusResponse> Conditions;
        /// <summary>
        /// Container that will be run for each workstation using this configuration when that workstation is started.
        /// </summary>
        public readonly Outputs.ContainerResponse Container;
        /// <summary>
        /// Time when this resource was created.
        /// </summary>
        public readonly string CreateTime;
        /// <summary>
        /// Whether this resource is in degraded mode, in which case it may require user action to restore full functionality. Details can be found in the `conditions` field.
        /// </summary>
        public readonly bool Degraded;
        /// <summary>
        /// Time when this resource was soft-deleted.
        /// </summary>
        public readonly string DeleteTime;
        /// <summary>
        /// Human-readable name for this resource.
        /// </summary>
        public readonly string DisplayName;
        /// <summary>
        /// Whether to enable linux auditd logging on the workstation. When enabled, a service account must also be specified that has logging.buckets.write permission on the project. Operating system audit logging is distinct from [Cloud Audit Logs](https://cloud.google.com/workstations/docs/audit-logging).
        /// </summary>
        public readonly bool EnableAuditAgent;
        /// <summary>
        /// Immutable. Encrypts resources of this workstation configuration using a customer-managed encryption key. If specified, the boot disk of the Compute Engine instance and the persistent disk are encrypted using this encryption key. If this field is not set, the disks are encrypted using a generated key. Customer-managed encryption keys do not protect disk metadata. If the customer-managed encryption key is rotated, when the workstation instance is stopped, the system attempts to recreate the persistent disk with the new version of the key. Be sure to keep older versions of the key until the persistent disk is recreated. Otherwise, data on the persistent disk will be lost. If the encryption key is revoked, the workstation session will automatically be stopped within 7 hours. Immutable after the workstation configuration is created.
        /// </summary>
        public readonly Outputs.CustomerEncryptionKeyResponse EncryptionKey;
        /// <summary>
        /// Checksum computed by the server. May be sent on update and delete requests to make sure that the client has an up-to-date value before proceeding.
        /// </summary>
        public readonly string Etag;
        /// <summary>
        /// Runtime host for the workstation.
        /// </summary>
        public readonly Outputs.HostResponse Host;
        /// <summary>
        /// How long to wait before automatically stopping an instance that hasn't received any user traffic. A value of 0 indicates that this instance should never time out due to idleness. Defaults to 20 minutes.
        /// </summary>
        public readonly string IdleTimeout;
        /// <summary>
        /// Client-specified labels that are applied to the resource and that are also propagated to the underlying Compute Engine resources.
        /// </summary>
        public readonly ImmutableDictionary<string, string> Labels;
        /// <summary>
        /// Full name of this resource.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// Directories to persist across workstation sessions.
        /// </summary>
        public readonly ImmutableArray<Outputs.PersistentDirectoryResponse> PersistentDirectories;
        /// <summary>
        /// Readiness checks to perform when starting a workstation using this workstation configuration. Mark a workstation as running only after all specified readiness checks return 200 status codes.
        /// </summary>
        public readonly ImmutableArray<Outputs.ReadinessCheckResponse> ReadinessChecks;
        /// <summary>
        /// Indicates whether this resource is currently being updated to match its intended state.
        /// </summary>
        public readonly bool Reconciling;
        /// <summary>
        /// How long to wait before automatically stopping a workstation after it started. A value of 0 indicates that workstations using this configuration should never time out. Must be greater than 0 and less than 24 hours if encryption_key is set. Defaults to 12 hours.
        /// </summary>
        public readonly string RunningTimeout;
        /// <summary>
        /// A system-assigned unique identified for this resource.
        /// </summary>
        public readonly string Uid;
        /// <summary>
        /// Time when this resource was most recently updated.
        /// </summary>
        public readonly string UpdateTime;

        [OutputConstructor]
        private GetWorkstationConfigResult(
            ImmutableDictionary<string, string> annotations,

            ImmutableArray<Outputs.StatusResponse> conditions,

            Outputs.ContainerResponse container,

            string createTime,

            bool degraded,

            string deleteTime,

            string displayName,

            bool enableAuditAgent,

            Outputs.CustomerEncryptionKeyResponse encryptionKey,

            string etag,

            Outputs.HostResponse host,

            string idleTimeout,

            ImmutableDictionary<string, string> labels,

            string name,

            ImmutableArray<Outputs.PersistentDirectoryResponse> persistentDirectories,

            ImmutableArray<Outputs.ReadinessCheckResponse> readinessChecks,

            bool reconciling,

            string runningTimeout,

            string uid,

            string updateTime)
        {
            Annotations = annotations;
            Conditions = conditions;
            Container = container;
            CreateTime = createTime;
            Degraded = degraded;
            DeleteTime = deleteTime;
            DisplayName = displayName;
            EnableAuditAgent = enableAuditAgent;
            EncryptionKey = encryptionKey;
            Etag = etag;
            Host = host;
            IdleTimeout = idleTimeout;
            Labels = labels;
            Name = name;
            PersistentDirectories = persistentDirectories;
            ReadinessChecks = readinessChecks;
            Reconciling = reconciling;
            RunningTimeout = runningTimeout;
            Uid = uid;
            UpdateTime = updateTime;
        }
    }
}

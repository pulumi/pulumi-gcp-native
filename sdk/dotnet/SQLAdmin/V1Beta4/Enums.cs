// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.SQLAdmin.V1Beta4
{
    /// <summary>
    /// The unit that 'retained_backups' represents.
    /// </summary>
    [EnumType]
    public readonly struct BackupRetentionSettingsRetentionUnit : IEquatable<BackupRetentionSettingsRetentionUnit>
    {
        private readonly string _value;

        private BackupRetentionSettingsRetentionUnit(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Backup retention unit is unspecified, will be treated as COUNT.
        /// </summary>
        public static BackupRetentionSettingsRetentionUnit RetentionUnitUnspecified { get; } = new BackupRetentionSettingsRetentionUnit("RETENTION_UNIT_UNSPECIFIED");
        /// <summary>
        /// Retention will be by count, eg. "retain the most recent 7 backups".
        /// </summary>
        public static BackupRetentionSettingsRetentionUnit Count { get; } = new BackupRetentionSettingsRetentionUnit("COUNT");

        public static bool operator ==(BackupRetentionSettingsRetentionUnit left, BackupRetentionSettingsRetentionUnit right) => left.Equals(right);
        public static bool operator !=(BackupRetentionSettingsRetentionUnit left, BackupRetentionSettingsRetentionUnit right) => !left.Equals(right);

        public static explicit operator string(BackupRetentionSettingsRetentionUnit value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackupRetentionSettingsRetentionUnit other && Equals(other);
        public bool Equals(BackupRetentionSettingsRetentionUnit other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the kind of backup, PHYSICAL or DEFAULT_SNAPSHOT.
    /// </summary>
    [EnumType]
    public readonly struct BackupRunBackupKind : IEquatable<BackupRunBackupKind>
    {
        private readonly string _value;

        private BackupRunBackupKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is an unknown BackupKind.
        /// </summary>
        public static BackupRunBackupKind SqlBackupKindUnspecified { get; } = new BackupRunBackupKind("SQL_BACKUP_KIND_UNSPECIFIED");
        /// <summary>
        /// The snapshot based backups
        /// </summary>
        public static BackupRunBackupKind Snapshot { get; } = new BackupRunBackupKind("SNAPSHOT");
        /// <summary>
        /// Physical backups
        /// </summary>
        public static BackupRunBackupKind Physical { get; } = new BackupRunBackupKind("PHYSICAL");

        public static bool operator ==(BackupRunBackupKind left, BackupRunBackupKind right) => left.Equals(right);
        public static bool operator !=(BackupRunBackupKind left, BackupRunBackupKind right) => !left.Equals(right);

        public static explicit operator string(BackupRunBackupKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackupRunBackupKind other && Equals(other);
        public bool Equals(BackupRunBackupKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of this run.
    /// </summary>
    [EnumType]
    public readonly struct BackupRunStatus : IEquatable<BackupRunStatus>
    {
        private readonly string _value;

        private BackupRunStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The status of the run is unknown.
        /// </summary>
        public static BackupRunStatus SqlBackupRunStatusUnspecified { get; } = new BackupRunStatus("SQL_BACKUP_RUN_STATUS_UNSPECIFIED");
        /// <summary>
        /// The backup operation was enqueued.
        /// </summary>
        public static BackupRunStatus Enqueued { get; } = new BackupRunStatus("ENQUEUED");
        /// <summary>
        /// The backup is overdue across a given backup window. Indicates a problem. Example: Long-running operation in progress during the whole window.
        /// </summary>
        public static BackupRunStatus Overdue { get; } = new BackupRunStatus("OVERDUE");
        /// <summary>
        /// The backup is in progress.
        /// </summary>
        public static BackupRunStatus Running { get; } = new BackupRunStatus("RUNNING");
        /// <summary>
        /// The backup failed.
        /// </summary>
        public static BackupRunStatus Failed { get; } = new BackupRunStatus("FAILED");
        /// <summary>
        /// The backup was successful.
        /// </summary>
        public static BackupRunStatus Successful { get; } = new BackupRunStatus("SUCCESSFUL");
        /// <summary>
        /// The backup was skipped (without problems) for a given backup window. Example: Instance was idle.
        /// </summary>
        public static BackupRunStatus Skipped { get; } = new BackupRunStatus("SKIPPED");
        /// <summary>
        /// The backup is about to be deleted.
        /// </summary>
        public static BackupRunStatus DeletionPending { get; } = new BackupRunStatus("DELETION_PENDING");
        /// <summary>
        /// The backup deletion failed.
        /// </summary>
        public static BackupRunStatus DeletionFailed { get; } = new BackupRunStatus("DELETION_FAILED");
        /// <summary>
        /// The backup has been deleted.
        /// </summary>
        public static BackupRunStatus Deleted { get; } = new BackupRunStatus("DELETED");

        public static bool operator ==(BackupRunStatus left, BackupRunStatus right) => left.Equals(right);
        public static bool operator !=(BackupRunStatus left, BackupRunStatus right) => !left.Equals(right);

        public static explicit operator string(BackupRunStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackupRunStatus other && Equals(other);
        public bool Equals(BackupRunStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of this run; can be either "AUTOMATED" or "ON_DEMAND". This field defaults to "ON_DEMAND" and is ignored, when specified for insert requests.
    /// </summary>
    [EnumType]
    public readonly struct BackupRunType : IEquatable<BackupRunType>
    {
        private readonly string _value;

        private BackupRunType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is an unknown BackupRun type.
        /// </summary>
        public static BackupRunType SqlBackupRunTypeUnspecified { get; } = new BackupRunType("SQL_BACKUP_RUN_TYPE_UNSPECIFIED");
        /// <summary>
        /// The backup schedule automatically triggers a backup.
        /// </summary>
        public static BackupRunType Automated { get; } = new BackupRunType("AUTOMATED");
        /// <summary>
        /// The user manually triggers a backup.
        /// </summary>
        public static BackupRunType OnDemand { get; } = new BackupRunType("ON_DEMAND");

        public static bool operator ==(BackupRunType left, BackupRunType right) => left.Equals(right);
        public static bool operator !=(BackupRunType left, BackupRunType right) => !left.Equals(right);

        public static explicit operator string(BackupRunType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackupRunType other && Equals(other);
        public bool Equals(BackupRunType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The backend type. `SECOND_GEN`: Cloud SQL database instance. `EXTERNAL`: A database server that is not managed by Google. This property is read-only; use the `tier` property in the `settings` object to determine the database type.
    /// </summary>
    [EnumType]
    public readonly struct InstanceBackendType : IEquatable<InstanceBackendType>
    {
        private readonly string _value;

        private InstanceBackendType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is an unknown backend type for instance.
        /// </summary>
        public static InstanceBackendType SqlBackendTypeUnspecified { get; } = new InstanceBackendType("SQL_BACKEND_TYPE_UNSPECIFIED");
        /// <summary>
        /// V1 speckle instance.
        /// </summary>
        public static InstanceBackendType FirstGen { get; } = new InstanceBackendType("FIRST_GEN");
        /// <summary>
        /// V2 speckle instance.
        /// </summary>
        public static InstanceBackendType SecondGen { get; } = new InstanceBackendType("SECOND_GEN");
        /// <summary>
        /// On premises instance.
        /// </summary>
        public static InstanceBackendType External { get; } = new InstanceBackendType("EXTERNAL");

        public static bool operator ==(InstanceBackendType left, InstanceBackendType right) => left.Equals(right);
        public static bool operator !=(InstanceBackendType left, InstanceBackendType right) => !left.Equals(right);

        public static explicit operator string(InstanceBackendType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceBackendType other && Equals(other);
        public bool Equals(InstanceBackendType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The database engine type and version. The `databaseVersion` field cannot be changed after instance creation.
    /// </summary>
    [EnumType]
    public readonly struct InstanceDatabaseVersion : IEquatable<InstanceDatabaseVersion>
    {
        private readonly string _value;

        private InstanceDatabaseVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is an unknown database version.
        /// </summary>
        public static InstanceDatabaseVersion SqlDatabaseVersionUnspecified { get; } = new InstanceDatabaseVersion("SQL_DATABASE_VERSION_UNSPECIFIED");
        /// <summary>
        /// The database version is MySQL 5.1.
        /// </summary>
        public static InstanceDatabaseVersion Mysql51 { get; } = new InstanceDatabaseVersion("MYSQL_5_1");
        /// <summary>
        /// The database version is MySQL 5.5.
        /// </summary>
        public static InstanceDatabaseVersion Mysql55 { get; } = new InstanceDatabaseVersion("MYSQL_5_5");
        /// <summary>
        /// The database version is MySQL 5.6.
        /// </summary>
        public static InstanceDatabaseVersion Mysql56 { get; } = new InstanceDatabaseVersion("MYSQL_5_6");
        /// <summary>
        /// The database version is MySQL 5.7.
        /// </summary>
        public static InstanceDatabaseVersion Mysql57 { get; } = new InstanceDatabaseVersion("MYSQL_5_7");
        /// <summary>
        /// The database version is PostgreSQL 9.6.
        /// </summary>
        public static InstanceDatabaseVersion Postgres96 { get; } = new InstanceDatabaseVersion("POSTGRES_9_6");
        /// <summary>
        /// The database version is PostgreSQL 11.
        /// </summary>
        public static InstanceDatabaseVersion Postgres11 { get; } = new InstanceDatabaseVersion("POSTGRES_11");
        /// <summary>
        /// The database version is SQL Server 2017 Standard.
        /// </summary>
        public static InstanceDatabaseVersion Sqlserver2017Standard { get; } = new InstanceDatabaseVersion("SQLSERVER_2017_STANDARD");
        /// <summary>
        /// The database version is SQL Server 2017 Enterprise.
        /// </summary>
        public static InstanceDatabaseVersion Sqlserver2017Enterprise { get; } = new InstanceDatabaseVersion("SQLSERVER_2017_ENTERPRISE");
        /// <summary>
        /// The database version is SQL Server 2017 Express.
        /// </summary>
        public static InstanceDatabaseVersion Sqlserver2017Express { get; } = new InstanceDatabaseVersion("SQLSERVER_2017_EXPRESS");
        /// <summary>
        /// The database version is SQL Server 2017 Web.
        /// </summary>
        public static InstanceDatabaseVersion Sqlserver2017Web { get; } = new InstanceDatabaseVersion("SQLSERVER_2017_WEB");
        /// <summary>
        /// The database version is PostgreSQL 10.
        /// </summary>
        public static InstanceDatabaseVersion Postgres10 { get; } = new InstanceDatabaseVersion("POSTGRES_10");
        /// <summary>
        /// The database version is PostgreSQL 12.
        /// </summary>
        public static InstanceDatabaseVersion Postgres12 { get; } = new InstanceDatabaseVersion("POSTGRES_12");
        /// <summary>
        /// The database version is MySQL 8.
        /// </summary>
        public static InstanceDatabaseVersion Mysql80 { get; } = new InstanceDatabaseVersion("MYSQL_8_0");
        /// <summary>
        /// The database major version is MySQL 8.0 and the minor version is 18.
        /// </summary>
        public static InstanceDatabaseVersion Mysql8018 { get; } = new InstanceDatabaseVersion("MYSQL_8_0_18");
        /// <summary>
        /// The database major version is MySQL 8.0 and the minor version is 26.
        /// </summary>
        public static InstanceDatabaseVersion Mysql8026 { get; } = new InstanceDatabaseVersion("MYSQL_8_0_26");
        /// <summary>
        /// The database major version is MySQL 8.0 and the minor version is 27.
        /// </summary>
        public static InstanceDatabaseVersion Mysql8027 { get; } = new InstanceDatabaseVersion("MYSQL_8_0_27");
        /// <summary>
        /// The database major version is MySQL 8.0 and the minor version is 28.
        /// </summary>
        public static InstanceDatabaseVersion Mysql8028 { get; } = new InstanceDatabaseVersion("MYSQL_8_0_28");
        /// <summary>
        /// The database major version is MySQL 8.0 and the minor version is 29.
        /// </summary>
        public static InstanceDatabaseVersion Mysql8029 { get; } = new InstanceDatabaseVersion("MYSQL_8_0_29");
        /// <summary>
        /// The database version is PostgreSQL 13.
        /// </summary>
        public static InstanceDatabaseVersion Postgres13 { get; } = new InstanceDatabaseVersion("POSTGRES_13");
        /// <summary>
        /// The database version is PostgreSQL 14.
        /// </summary>
        public static InstanceDatabaseVersion Postgres14 { get; } = new InstanceDatabaseVersion("POSTGRES_14");
        /// <summary>
        /// The database version is SQL Server 2019 Standard.
        /// </summary>
        public static InstanceDatabaseVersion Sqlserver2019Standard { get; } = new InstanceDatabaseVersion("SQLSERVER_2019_STANDARD");
        /// <summary>
        /// The database version is SQL Server 2019 Enterprise.
        /// </summary>
        public static InstanceDatabaseVersion Sqlserver2019Enterprise { get; } = new InstanceDatabaseVersion("SQLSERVER_2019_ENTERPRISE");
        /// <summary>
        /// The database version is SQL Server 2019 Express.
        /// </summary>
        public static InstanceDatabaseVersion Sqlserver2019Express { get; } = new InstanceDatabaseVersion("SQLSERVER_2019_EXPRESS");
        /// <summary>
        /// The database version is SQL Server 2019 Web.
        /// </summary>
        public static InstanceDatabaseVersion Sqlserver2019Web { get; } = new InstanceDatabaseVersion("SQLSERVER_2019_WEB");

        public static bool operator ==(InstanceDatabaseVersion left, InstanceDatabaseVersion right) => left.Equals(right);
        public static bool operator !=(InstanceDatabaseVersion left, InstanceDatabaseVersion right) => !left.Equals(right);

        public static explicit operator string(InstanceDatabaseVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceDatabaseVersion other && Equals(other);
        public bool Equals(InstanceDatabaseVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The instance type.
    /// </summary>
    [EnumType]
    public readonly struct InstanceInstanceType : IEquatable<InstanceInstanceType>
    {
        private readonly string _value;

        private InstanceInstanceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is an unknown Cloud SQL instance type.
        /// </summary>
        public static InstanceInstanceType SqlInstanceTypeUnspecified { get; } = new InstanceInstanceType("SQL_INSTANCE_TYPE_UNSPECIFIED");
        /// <summary>
        /// A regular Cloud SQL instance that is not replicating from a primary instance.
        /// </summary>
        public static InstanceInstanceType CloudSqlInstance { get; } = new InstanceInstanceType("CLOUD_SQL_INSTANCE");
        /// <summary>
        /// An instance running on the customer's premises that is not managed by Cloud SQL.
        /// </summary>
        public static InstanceInstanceType OnPremisesInstance { get; } = new InstanceInstanceType("ON_PREMISES_INSTANCE");
        /// <summary>
        /// A Cloud SQL instance acting as a read-replica.
        /// </summary>
        public static InstanceInstanceType ReadReplicaInstance { get; } = new InstanceInstanceType("READ_REPLICA_INSTANCE");

        public static bool operator ==(InstanceInstanceType left, InstanceInstanceType right) => left.Equals(right);
        public static bool operator !=(InstanceInstanceType left, InstanceInstanceType right) => !left.Equals(right);

        public static explicit operator string(InstanceInstanceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceInstanceType other && Equals(other);
        public bool Equals(InstanceInstanceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The current serving state of the Cloud SQL instance.
    /// </summary>
    [EnumType]
    public readonly struct InstanceState : IEquatable<InstanceState>
    {
        private readonly string _value;

        private InstanceState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The state of the instance is unknown.
        /// </summary>
        public static InstanceState SqlInstanceStateUnspecified { get; } = new InstanceState("SQL_INSTANCE_STATE_UNSPECIFIED");
        /// <summary>
        /// The instance is running, or has been stopped by owner.
        /// </summary>
        public static InstanceState Runnable { get; } = new InstanceState("RUNNABLE");
        /// <summary>
        /// The instance is not available, for example due to problems with billing.
        /// </summary>
        public static InstanceState Suspended { get; } = new InstanceState("SUSPENDED");
        /// <summary>
        /// The instance is being deleted.
        /// </summary>
        public static InstanceState PendingDelete { get; } = new InstanceState("PENDING_DELETE");
        /// <summary>
        /// The instance is being created.
        /// </summary>
        public static InstanceState PendingCreate { get; } = new InstanceState("PENDING_CREATE");
        /// <summary>
        /// The instance is down for maintenance.
        /// </summary>
        public static InstanceState Maintenance { get; } = new InstanceState("MAINTENANCE");
        /// <summary>
        /// The creation of the instance failed or a fatal error occurred during maintenance.
        /// </summary>
        public static InstanceState Failed { get; } = new InstanceState("FAILED");
        /// <summary>
        /// Deprecated
        /// </summary>
        public static InstanceState OnlineMaintenance { get; } = new InstanceState("ONLINE_MAINTENANCE");

        public static bool operator ==(InstanceState left, InstanceState right) => left.Equals(right);
        public static bool operator !=(InstanceState left, InstanceState right) => !left.Equals(right);

        public static explicit operator string(InstanceState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceState other && Equals(other);
        public bool Equals(InstanceState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct InstanceSuspensionReasonItem : IEquatable<InstanceSuspensionReasonItem>
    {
        private readonly string _value;

        private InstanceSuspensionReasonItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is an unknown suspension reason.
        /// </summary>
        public static InstanceSuspensionReasonItem SqlSuspensionReasonUnspecified { get; } = new InstanceSuspensionReasonItem("SQL_SUSPENSION_REASON_UNSPECIFIED");
        /// <summary>
        /// The instance is suspended due to billing issues (for example:, GCP account issue)
        /// </summary>
        public static InstanceSuspensionReasonItem BillingIssue { get; } = new InstanceSuspensionReasonItem("BILLING_ISSUE");
        /// <summary>
        /// The instance is suspended due to illegal content (for example:, child pornography, copyrighted material, etc.).
        /// </summary>
        public static InstanceSuspensionReasonItem LegalIssue { get; } = new InstanceSuspensionReasonItem("LEGAL_ISSUE");
        /// <summary>
        /// The instance is causing operational issues (for example:, causing the database to crash).
        /// </summary>
        public static InstanceSuspensionReasonItem OperationalIssue { get; } = new InstanceSuspensionReasonItem("OPERATIONAL_ISSUE");
        /// <summary>
        /// The KMS key used by the instance is either revoked or denied access to
        /// </summary>
        public static InstanceSuspensionReasonItem KmsKeyIssue { get; } = new InstanceSuspensionReasonItem("KMS_KEY_ISSUE");

        public static bool operator ==(InstanceSuspensionReasonItem left, InstanceSuspensionReasonItem right) => left.Equals(right);
        public static bool operator !=(InstanceSuspensionReasonItem left, InstanceSuspensionReasonItem right) => !left.Equals(right);

        public static explicit operator string(InstanceSuspensionReasonItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceSuspensionReasonItem other && Equals(other);
        public bool Equals(InstanceSuspensionReasonItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of this IP address. A `PRIMARY` address is a public address that can accept incoming connections. A `PRIVATE` address is a private address that can accept incoming connections. An `OUTGOING` address is the source address of connections originating from the instance, if supported.
    /// </summary>
    [EnumType]
    public readonly struct IpMappingType : IEquatable<IpMappingType>
    {
        private readonly string _value;

        private IpMappingType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is an unknown IP address type.
        /// </summary>
        public static IpMappingType SqlIpAddressTypeUnspecified { get; } = new IpMappingType("SQL_IP_ADDRESS_TYPE_UNSPECIFIED");
        /// <summary>
        /// IP address the customer is supposed to connect to. Usually this is the load balancer's IP address
        /// </summary>
        public static IpMappingType Primary { get; } = new IpMappingType("PRIMARY");
        /// <summary>
        /// Source IP address of the connection a read replica establishes to its external primary instance. This IP address can be allowlisted by the customer in case it has a firewall that filters incoming connection to its on premises primary instance.
        /// </summary>
        public static IpMappingType Outgoing { get; } = new IpMappingType("OUTGOING");
        /// <summary>
        /// Private IP used when using private IPs and network peering.
        /// </summary>
        public static IpMappingType Private { get; } = new IpMappingType("PRIVATE");
        /// <summary>
        /// V1 IP of a migrated instance. We want the user to decommission this IP as soon as the migration is complete. Note: V1 instances with V1 ip addresses will be counted as PRIMARY.
        /// </summary>
        public static IpMappingType Migrated1stGen { get; } = new IpMappingType("MIGRATED_1ST_GEN");

        public static bool operator ==(IpMappingType left, IpMappingType right) => left.Equals(right);
        public static bool operator !=(IpMappingType left, IpMappingType right) => !left.Equals(right);

        public static explicit operator string(IpMappingType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpMappingType other && Equals(other);
        public bool Equals(IpMappingType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Maintenance timing setting: `canary` (Earlier) or `stable` (Later). [Learn more](https://cloud.google.com/sql/docs/mysql/instance-settings#maintenance-timing-2ndgen).
    /// </summary>
    [EnumType]
    public readonly struct MaintenanceWindowUpdateTrack : IEquatable<MaintenanceWindowUpdateTrack>
    {
        private readonly string _value;

        private MaintenanceWindowUpdateTrack(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is an unknown maintenance timing preference.
        /// </summary>
        public static MaintenanceWindowUpdateTrack SqlUpdateTrackUnspecified { get; } = new MaintenanceWindowUpdateTrack("SQL_UPDATE_TRACK_UNSPECIFIED");
        /// <summary>
        /// For instance update that requires a restart, this update track indicates your instance prefer to restart for new version early in maintenance window.
        /// </summary>
        public static MaintenanceWindowUpdateTrack Canary { get; } = new MaintenanceWindowUpdateTrack("canary");
        /// <summary>
        /// For instance update that requires a restart, this update track indicates your instance prefer to let Cloud SQL choose the timing of restart (within its Maintenance window, if applicable).
        /// </summary>
        public static MaintenanceWindowUpdateTrack Stable { get; } = new MaintenanceWindowUpdateTrack("stable");

        public static bool operator ==(MaintenanceWindowUpdateTrack left, MaintenanceWindowUpdateTrack right) => left.Equals(right);
        public static bool operator !=(MaintenanceWindowUpdateTrack left, MaintenanceWindowUpdateTrack right) => !left.Equals(right);

        public static explicit operator string(MaintenanceWindowUpdateTrack value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MaintenanceWindowUpdateTrack other && Equals(other);
        public bool Equals(MaintenanceWindowUpdateTrack other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The complexity of the password.
    /// </summary>
    [EnumType]
    public readonly struct PasswordValidationPolicyComplexity : IEquatable<PasswordValidationPolicyComplexity>
    {
        private readonly string _value;

        private PasswordValidationPolicyComplexity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Complexity check is not specified.
        /// </summary>
        public static PasswordValidationPolicyComplexity ComplexityUnspecified { get; } = new PasswordValidationPolicyComplexity("COMPLEXITY_UNSPECIFIED");
        /// <summary>
        /// A combination of lowercase, uppercase, numeric, and non-alphanumeric characters.
        /// </summary>
        public static PasswordValidationPolicyComplexity ComplexityDefault { get; } = new PasswordValidationPolicyComplexity("COMPLEXITY_DEFAULT");

        public static bool operator ==(PasswordValidationPolicyComplexity left, PasswordValidationPolicyComplexity right) => left.Equals(right);
        public static bool operator !=(PasswordValidationPolicyComplexity left, PasswordValidationPolicyComplexity right) => !left.Equals(right);

        public static explicit operator string(PasswordValidationPolicyComplexity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PasswordValidationPolicyComplexity other && Equals(other);
        public bool Equals(PasswordValidationPolicyComplexity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The activation policy specifies when the instance is activated; it is applicable only when the instance state is RUNNABLE. Valid values: * `ALWAYS`: The instance is on, and remains so even in the absence of connection requests. * `NEVER`: The instance is off; it is not activated, even if a connection request arrives.
    /// </summary>
    [EnumType]
    public readonly struct SettingsActivationPolicy : IEquatable<SettingsActivationPolicy>
    {
        private readonly string _value;

        private SettingsActivationPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown activation plan.
        /// </summary>
        public static SettingsActivationPolicy SqlActivationPolicyUnspecified { get; } = new SettingsActivationPolicy("SQL_ACTIVATION_POLICY_UNSPECIFIED");
        /// <summary>
        /// The instance is always up and running.
        /// </summary>
        public static SettingsActivationPolicy Always { get; } = new SettingsActivationPolicy("ALWAYS");
        /// <summary>
        /// The instance never starts.
        /// </summary>
        public static SettingsActivationPolicy Never { get; } = new SettingsActivationPolicy("NEVER");
        /// <summary>
        /// The instance starts upon receiving requests.
        /// </summary>
        public static SettingsActivationPolicy OnDemand { get; } = new SettingsActivationPolicy("ON_DEMAND");

        public static bool operator ==(SettingsActivationPolicy left, SettingsActivationPolicy right) => left.Equals(right);
        public static bool operator !=(SettingsActivationPolicy left, SettingsActivationPolicy right) => !left.Equals(right);

        public static explicit operator string(SettingsActivationPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SettingsActivationPolicy other && Equals(other);
        public bool Equals(SettingsActivationPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Availability type. Potential values: * `ZONAL`: The instance serves data from only one zone. Outages in that zone affect data accessibility. * `REGIONAL`: The instance can serve data from more than one zone in a region (it is highly available)./ For more information, see [Overview of the High Availability Configuration](https://cloud.google.com/sql/docs/mysql/high-availability).
    /// </summary>
    [EnumType]
    public readonly struct SettingsAvailabilityType : IEquatable<SettingsAvailabilityType>
    {
        private readonly string _value;

        private SettingsAvailabilityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is an unknown Availability type.
        /// </summary>
        public static SettingsAvailabilityType SqlAvailabilityTypeUnspecified { get; } = new SettingsAvailabilityType("SQL_AVAILABILITY_TYPE_UNSPECIFIED");
        /// <summary>
        /// Zonal available instance.
        /// </summary>
        public static SettingsAvailabilityType Zonal { get; } = new SettingsAvailabilityType("ZONAL");
        /// <summary>
        /// Regional available instance.
        /// </summary>
        public static SettingsAvailabilityType Regional { get; } = new SettingsAvailabilityType("REGIONAL");

        public static bool operator ==(SettingsAvailabilityType left, SettingsAvailabilityType right) => left.Equals(right);
        public static bool operator !=(SettingsAvailabilityType left, SettingsAvailabilityType right) => !left.Equals(right);

        public static explicit operator string(SettingsAvailabilityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SettingsAvailabilityType other && Equals(other);
        public bool Equals(SettingsAvailabilityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of data disk: `PD_SSD` (default) or `PD_HDD`. Not used for First Generation instances.
    /// </summary>
    [EnumType]
    public readonly struct SettingsDataDiskType : IEquatable<SettingsDataDiskType>
    {
        private readonly string _value;

        private SettingsDataDiskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is an unknown data disk type.
        /// </summary>
        public static SettingsDataDiskType SqlDataDiskTypeUnspecified { get; } = new SettingsDataDiskType("SQL_DATA_DISK_TYPE_UNSPECIFIED");
        /// <summary>
        /// An SSD data disk.
        /// </summary>
        public static SettingsDataDiskType PdSsd { get; } = new SettingsDataDiskType("PD_SSD");
        /// <summary>
        /// An HDD data disk.
        /// </summary>
        public static SettingsDataDiskType PdHdd { get; } = new SettingsDataDiskType("PD_HDD");
        /// <summary>
        /// This field is deprecated and will be removed from a future version of the API.
        /// </summary>
        public static SettingsDataDiskType ObsoleteLocalSsd { get; } = new SettingsDataDiskType("OBSOLETE_LOCAL_SSD");

        public static bool operator ==(SettingsDataDiskType left, SettingsDataDiskType right) => left.Equals(right);
        public static bool operator !=(SettingsDataDiskType left, SettingsDataDiskType right) => !left.Equals(right);

        public static explicit operator string(SettingsDataDiskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SettingsDataDiskType other && Equals(other);
        public bool Equals(SettingsDataDiskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The pricing plan for this instance. This can be either `PER_USE` or `PACKAGE`. Only `PER_USE` is supported for Second Generation instances.
    /// </summary>
    [EnumType]
    public readonly struct SettingsPricingPlan : IEquatable<SettingsPricingPlan>
    {
        private readonly string _value;

        private SettingsPricingPlan(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is an unknown pricing plan for this instance.
        /// </summary>
        public static SettingsPricingPlan SqlPricingPlanUnspecified { get; } = new SettingsPricingPlan("SQL_PRICING_PLAN_UNSPECIFIED");
        /// <summary>
        /// The instance is billed at a monthly flat rate.
        /// </summary>
        public static SettingsPricingPlan Package { get; } = new SettingsPricingPlan("PACKAGE");
        /// <summary>
        /// The instance is billed per usage.
        /// </summary>
        public static SettingsPricingPlan PerUse { get; } = new SettingsPricingPlan("PER_USE");

        public static bool operator ==(SettingsPricingPlan left, SettingsPricingPlan right) => left.Equals(right);
        public static bool operator !=(SettingsPricingPlan left, SettingsPricingPlan right) => !left.Equals(right);

        public static explicit operator string(SettingsPricingPlan value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SettingsPricingPlan other && Equals(other);
        public bool Equals(SettingsPricingPlan other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of replication this instance uses. This can be either `ASYNCHRONOUS` or `SYNCHRONOUS`. (Deprecated) This property was only applicable to First Generation instances.
    /// </summary>
    [EnumType]
    public readonly struct SettingsReplicationType : IEquatable<SettingsReplicationType>
    {
        private readonly string _value;

        private SettingsReplicationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is an unknown replication type for a Cloud SQL instance.
        /// </summary>
        public static SettingsReplicationType SqlReplicationTypeUnspecified { get; } = new SettingsReplicationType("SQL_REPLICATION_TYPE_UNSPECIFIED");
        /// <summary>
        /// The synchronous replication mode for First Generation instances. It is the default value.
        /// </summary>
        public static SettingsReplicationType Synchronous { get; } = new SettingsReplicationType("SYNCHRONOUS");
        /// <summary>
        /// The asynchronous replication mode for First Generation instances. It provides a slight performance gain, but if an outage occurs while this option is set to asynchronous, you can lose up to a few seconds of updates to your data.
        /// </summary>
        public static SettingsReplicationType Asynchronous { get; } = new SettingsReplicationType("ASYNCHRONOUS");

        public static bool operator ==(SettingsReplicationType left, SettingsReplicationType right) => left.Equals(right);
        public static bool operator !=(SettingsReplicationType left, SettingsReplicationType right) => !left.Equals(right);

        public static explicit operator string(SettingsReplicationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SettingsReplicationType other && Equals(other);
        public bool Equals(SettingsReplicationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This field represents the state generated by the proactive database wellness job for OutOfDisk issues. * Writers: * the proactive database wellness job for OOD. * Readers: * the proactive database wellness job
    /// </summary>
    [EnumType]
    public readonly struct SqlOutOfDiskReportSqlOutOfDiskState : IEquatable<SqlOutOfDiskReportSqlOutOfDiskState>
    {
        private readonly string _value;

        private SqlOutOfDiskReportSqlOutOfDiskState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified state
        /// </summary>
        public static SqlOutOfDiskReportSqlOutOfDiskState SqlOutOfDiskStateUnspecified { get; } = new SqlOutOfDiskReportSqlOutOfDiskState("SQL_OUT_OF_DISK_STATE_UNSPECIFIED");
        /// <summary>
        /// The instance has plenty space on data disk
        /// </summary>
        public static SqlOutOfDiskReportSqlOutOfDiskState Normal { get; } = new SqlOutOfDiskReportSqlOutOfDiskState("NORMAL");
        /// <summary>
        /// Data disk is almost used up. It is shutdown to prevent data corruption.
        /// </summary>
        public static SqlOutOfDiskReportSqlOutOfDiskState SoftShutdown { get; } = new SqlOutOfDiskReportSqlOutOfDiskState("SOFT_SHUTDOWN");

        public static bool operator ==(SqlOutOfDiskReportSqlOutOfDiskState left, SqlOutOfDiskReportSqlOutOfDiskState right) => left.Equals(right);
        public static bool operator !=(SqlOutOfDiskReportSqlOutOfDiskState left, SqlOutOfDiskReportSqlOutOfDiskState right) => !left.Equals(right);

        public static explicit operator string(SqlOutOfDiskReportSqlOutOfDiskState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SqlOutOfDiskReportSqlOutOfDiskState other && Equals(other);
        public bool Equals(SqlOutOfDiskReportSqlOutOfDiskState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Dual password status for the user.
    /// </summary>
    [EnumType]
    public readonly struct UserDualPasswordType : IEquatable<UserDualPasswordType>
    {
        private readonly string _value;

        private UserDualPasswordType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default value.
        /// </summary>
        public static UserDualPasswordType DualPasswordTypeUnspecified { get; } = new UserDualPasswordType("DUAL_PASSWORD_TYPE_UNSPECIFIED");
        /// <summary>
        /// Do not update the user's dual password status.
        /// </summary>
        public static UserDualPasswordType NoModifyDualPassword { get; } = new UserDualPasswordType("NO_MODIFY_DUAL_PASSWORD");
        /// <summary>
        /// No dual password usable for connecting using this user.
        /// </summary>
        public static UserDualPasswordType NoDualPassword { get; } = new UserDualPasswordType("NO_DUAL_PASSWORD");
        /// <summary>
        /// Dual password usable for connecting using this user.
        /// </summary>
        public static UserDualPasswordType DualPassword { get; } = new UserDualPasswordType("DUAL_PASSWORD");

        public static bool operator ==(UserDualPasswordType left, UserDualPasswordType right) => left.Equals(right);
        public static bool operator !=(UserDualPasswordType left, UserDualPasswordType right) => !left.Equals(right);

        public static explicit operator string(UserDualPasswordType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UserDualPasswordType other && Equals(other);
        public bool Equals(UserDualPasswordType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The user type. It determines the method to authenticate the user during login. The default is the database's built-in user type.
    /// </summary>
    [EnumType]
    public readonly struct UserType : IEquatable<UserType>
    {
        private readonly string _value;

        private UserType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The database's built-in user type.
        /// </summary>
        public static UserType BuiltIn { get; } = new UserType("BUILT_IN");
        /// <summary>
        /// Cloud IAM user.
        /// </summary>
        public static UserType CloudIamUser { get; } = new UserType("CLOUD_IAM_USER");
        /// <summary>
        /// Cloud IAM service account.
        /// </summary>
        public static UserType CloudIamServiceAccount { get; } = new UserType("CLOUD_IAM_SERVICE_ACCOUNT");

        public static bool operator ==(UserType left, UserType right) => left.Equals(right);
        public static bool operator !=(UserType left, UserType right) => !left.Equals(right);

        public static explicit operator string(UserType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UserType other && Equals(other);
        public bool Equals(UserType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}

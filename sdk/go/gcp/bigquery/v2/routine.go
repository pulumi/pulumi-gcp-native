// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v2

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates a new routine in the dataset.
type Routine struct {
	pulumi.CustomResourceState

	// Optional.
	Arguments ArgumentResponseArrayOutput `pulumi:"arguments"`
	// The time when this routine was created, in milliseconds since the epoch.
	CreationTime pulumi.StringOutput `pulumi:"creationTime"`
	// Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, "\n", y))` The definition_body is `concat(x, "\n", y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'` The definition_body is `return "\n";\n` Note that both \n are replaced with linebreaks.
	DefinitionBody pulumi.StringOutput `pulumi:"definitionBody"`
	// Optional. [Experimental] The description of the routine if defined.
	Description pulumi.StringOutput `pulumi:"description"`
	// Optional. [Experimental] The determinism level of the JavaScript UDF if defined.
	DeterminismLevel pulumi.StringOutput `pulumi:"determinismLevel"`
	// A hash of this resource.
	Etag pulumi.StringOutput `pulumi:"etag"`
	// Optional. If language = "JAVASCRIPT", this field stores the path of the imported JAVASCRIPT libraries.
	ImportedLibraries pulumi.StringArrayOutput `pulumi:"importedLibraries"`
	// Optional. Defaults to "SQL".
	Language pulumi.StringOutput `pulumi:"language"`
	// The time when this routine was last modified, in milliseconds since the epoch.
	LastModifiedTime pulumi.StringOutput `pulumi:"lastModifiedTime"`
	// Optional. Set only if Routine is a "TABLE_VALUED_FUNCTION".
	ReturnTableType StandardSqlTableTypeResponseOutput `pulumi:"returnTableType"`
	// Optional if language = "SQL"; required otherwise. If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: "FLOAT64"}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
	ReturnType StandardSqlDataTypeResponseOutput `pulumi:"returnType"`
	// Required. Reference describing the ID of this routine.
	RoutineReference RoutineReferenceResponseOutput `pulumi:"routineReference"`
	// Required. The type of routine.
	RoutineType pulumi.StringOutput `pulumi:"routineType"`
}

// NewRoutine registers a new resource with the given unique name, arguments, and options.
func NewRoutine(ctx *pulumi.Context,
	name string, args *RoutineArgs, opts ...pulumi.ResourceOption) (*Routine, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DatasetsId == nil {
		return nil, errors.New("invalid value for required argument 'DatasetsId'")
	}
	if args.ProjectsId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectsId'")
	}
	if args.RoutinesId == nil {
		return nil, errors.New("invalid value for required argument 'RoutinesId'")
	}
	var resource Routine
	err := ctx.RegisterResource("gcp-native:bigquery/v2:Routine", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRoutine gets an existing Routine resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRoutine(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RoutineState, opts ...pulumi.ResourceOption) (*Routine, error) {
	var resource Routine
	err := ctx.ReadResource("gcp-native:bigquery/v2:Routine", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Routine resources.
type routineState struct {
	// Optional.
	Arguments []ArgumentResponse `pulumi:"arguments"`
	// The time when this routine was created, in milliseconds since the epoch.
	CreationTime *string `pulumi:"creationTime"`
	// Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, "\n", y))` The definition_body is `concat(x, "\n", y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'` The definition_body is `return "\n";\n` Note that both \n are replaced with linebreaks.
	DefinitionBody *string `pulumi:"definitionBody"`
	// Optional. [Experimental] The description of the routine if defined.
	Description *string `pulumi:"description"`
	// Optional. [Experimental] The determinism level of the JavaScript UDF if defined.
	DeterminismLevel *string `pulumi:"determinismLevel"`
	// A hash of this resource.
	Etag *string `pulumi:"etag"`
	// Optional. If language = "JAVASCRIPT", this field stores the path of the imported JAVASCRIPT libraries.
	ImportedLibraries []string `pulumi:"importedLibraries"`
	// Optional. Defaults to "SQL".
	Language *string `pulumi:"language"`
	// The time when this routine was last modified, in milliseconds since the epoch.
	LastModifiedTime *string `pulumi:"lastModifiedTime"`
	// Optional. Set only if Routine is a "TABLE_VALUED_FUNCTION".
	ReturnTableType *StandardSqlTableTypeResponse `pulumi:"returnTableType"`
	// Optional if language = "SQL"; required otherwise. If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: "FLOAT64"}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
	ReturnType *StandardSqlDataTypeResponse `pulumi:"returnType"`
	// Required. Reference describing the ID of this routine.
	RoutineReference *RoutineReferenceResponse `pulumi:"routineReference"`
	// Required. The type of routine.
	RoutineType *string `pulumi:"routineType"`
}

type RoutineState struct {
	// Optional.
	Arguments ArgumentResponseArrayInput
	// The time when this routine was created, in milliseconds since the epoch.
	CreationTime pulumi.StringPtrInput
	// Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, "\n", y))` The definition_body is `concat(x, "\n", y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'` The definition_body is `return "\n";\n` Note that both \n are replaced with linebreaks.
	DefinitionBody pulumi.StringPtrInput
	// Optional. [Experimental] The description of the routine if defined.
	Description pulumi.StringPtrInput
	// Optional. [Experimental] The determinism level of the JavaScript UDF if defined.
	DeterminismLevel pulumi.StringPtrInput
	// A hash of this resource.
	Etag pulumi.StringPtrInput
	// Optional. If language = "JAVASCRIPT", this field stores the path of the imported JAVASCRIPT libraries.
	ImportedLibraries pulumi.StringArrayInput
	// Optional. Defaults to "SQL".
	Language pulumi.StringPtrInput
	// The time when this routine was last modified, in milliseconds since the epoch.
	LastModifiedTime pulumi.StringPtrInput
	// Optional. Set only if Routine is a "TABLE_VALUED_FUNCTION".
	ReturnTableType StandardSqlTableTypeResponsePtrInput
	// Optional if language = "SQL"; required otherwise. If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: "FLOAT64"}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
	ReturnType StandardSqlDataTypeResponsePtrInput
	// Required. Reference describing the ID of this routine.
	RoutineReference RoutineReferenceResponsePtrInput
	// Required. The type of routine.
	RoutineType pulumi.StringPtrInput
}

func (RoutineState) ElementType() reflect.Type {
	return reflect.TypeOf((*routineState)(nil)).Elem()
}

type routineArgs struct {
	// Optional.
	Arguments  []Argument `pulumi:"arguments"`
	DatasetsId string     `pulumi:"datasetsId"`
	// Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, "\n", y))` The definition_body is `concat(x, "\n", y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'` The definition_body is `return "\n";\n` Note that both \n are replaced with linebreaks.
	DefinitionBody *string `pulumi:"definitionBody"`
	// Optional. [Experimental] The description of the routine if defined.
	Description *string `pulumi:"description"`
	// Optional. [Experimental] The determinism level of the JavaScript UDF if defined.
	DeterminismLevel *string `pulumi:"determinismLevel"`
	// Optional. If language = "JAVASCRIPT", this field stores the path of the imported JAVASCRIPT libraries.
	ImportedLibraries []string `pulumi:"importedLibraries"`
	// Optional. Defaults to "SQL".
	Language   *string `pulumi:"language"`
	ProjectsId string  `pulumi:"projectsId"`
	// Optional. Set only if Routine is a "TABLE_VALUED_FUNCTION".
	ReturnTableType *StandardSqlTableType `pulumi:"returnTableType"`
	// Optional if language = "SQL"; required otherwise. If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: "FLOAT64"}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
	ReturnType *StandardSqlDataType `pulumi:"returnType"`
	// Required. Reference describing the ID of this routine.
	RoutineReference *RoutineReference `pulumi:"routineReference"`
	// Required. The type of routine.
	RoutineType *string `pulumi:"routineType"`
	RoutinesId  string  `pulumi:"routinesId"`
}

// The set of arguments for constructing a Routine resource.
type RoutineArgs struct {
	// Optional.
	Arguments  ArgumentArrayInput
	DatasetsId pulumi.StringInput
	// Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, "\n", y))` The definition_body is `concat(x, "\n", y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'` The definition_body is `return "\n";\n` Note that both \n are replaced with linebreaks.
	DefinitionBody pulumi.StringPtrInput
	// Optional. [Experimental] The description of the routine if defined.
	Description pulumi.StringPtrInput
	// Optional. [Experimental] The determinism level of the JavaScript UDF if defined.
	DeterminismLevel pulumi.StringPtrInput
	// Optional. If language = "JAVASCRIPT", this field stores the path of the imported JAVASCRIPT libraries.
	ImportedLibraries pulumi.StringArrayInput
	// Optional. Defaults to "SQL".
	Language   pulumi.StringPtrInput
	ProjectsId pulumi.StringInput
	// Optional. Set only if Routine is a "TABLE_VALUED_FUNCTION".
	ReturnTableType StandardSqlTableTypePtrInput
	// Optional if language = "SQL"; required otherwise. If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: "FLOAT64"}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
	ReturnType StandardSqlDataTypePtrInput
	// Required. Reference describing the ID of this routine.
	RoutineReference RoutineReferencePtrInput
	// Required. The type of routine.
	RoutineType pulumi.StringPtrInput
	RoutinesId  pulumi.StringInput
}

func (RoutineArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*routineArgs)(nil)).Elem()
}

type RoutineInput interface {
	pulumi.Input

	ToRoutineOutput() RoutineOutput
	ToRoutineOutputWithContext(ctx context.Context) RoutineOutput
}

func (*Routine) ElementType() reflect.Type {
	return reflect.TypeOf((*Routine)(nil))
}

func (i *Routine) ToRoutineOutput() RoutineOutput {
	return i.ToRoutineOutputWithContext(context.Background())
}

func (i *Routine) ToRoutineOutputWithContext(ctx context.Context) RoutineOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RoutineOutput)
}

type RoutineOutput struct {
	*pulumi.OutputState
}

func (RoutineOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Routine)(nil))
}

func (o RoutineOutput) ToRoutineOutput() RoutineOutput {
	return o
}

func (o RoutineOutput) ToRoutineOutputWithContext(ctx context.Context) RoutineOutput {
	return o
}

func init() {
	pulumi.RegisterOutputType(RoutineOutput{})
}

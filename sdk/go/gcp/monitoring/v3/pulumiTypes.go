// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v3

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type Aggregation struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
	AlignmentPeriod *string `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer *string `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields []string `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner *string `pulumi:"perSeriesAligner"`
}

// AggregationInput is an input type that accepts AggregationArgs and AggregationOutput values.
// You can construct a concrete instance of `AggregationInput` via:
//
//          AggregationArgs{...}
type AggregationInput interface {
	pulumi.Input

	ToAggregationOutput() AggregationOutput
	ToAggregationOutputWithContext(context.Context) AggregationOutput
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationArgs struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
	AlignmentPeriod pulumi.StringPtrInput `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer pulumi.StringPtrInput `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields pulumi.StringArrayInput `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner pulumi.StringPtrInput `pulumi:"perSeriesAligner"`
}

func (AggregationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Aggregation)(nil)).Elem()
}

func (i AggregationArgs) ToAggregationOutput() AggregationOutput {
	return i.ToAggregationOutputWithContext(context.Background())
}

func (i AggregationArgs) ToAggregationOutputWithContext(ctx context.Context) AggregationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationOutput)
}

// AggregationArrayInput is an input type that accepts AggregationArray and AggregationArrayOutput values.
// You can construct a concrete instance of `AggregationArrayInput` via:
//
//          AggregationArray{ AggregationArgs{...} }
type AggregationArrayInput interface {
	pulumi.Input

	ToAggregationArrayOutput() AggregationArrayOutput
	ToAggregationArrayOutputWithContext(context.Context) AggregationArrayOutput
}

type AggregationArray []AggregationInput

func (AggregationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Aggregation)(nil)).Elem()
}

func (i AggregationArray) ToAggregationArrayOutput() AggregationArrayOutput {
	return i.ToAggregationArrayOutputWithContext(context.Background())
}

func (i AggregationArray) ToAggregationArrayOutputWithContext(ctx context.Context) AggregationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationArrayOutput)
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationOutput struct{ *pulumi.OutputState }

func (AggregationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Aggregation)(nil)).Elem()
}

func (o AggregationOutput) ToAggregationOutput() AggregationOutput {
	return o
}

func (o AggregationOutput) ToAggregationOutputWithContext(ctx context.Context) AggregationOutput {
	return o
}

// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
func (o AggregationOutput) AlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Aggregation) *string { return v.AlignmentPeriod }).(pulumi.StringPtrOutput)
}

// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
func (o AggregationOutput) CrossSeriesReducer() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Aggregation) *string { return v.CrossSeriesReducer }).(pulumi.StringPtrOutput)
}

// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
func (o AggregationOutput) GroupByFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Aggregation) []string { return v.GroupByFields }).(pulumi.StringArrayOutput)
}

// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
func (o AggregationOutput) PerSeriesAligner() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Aggregation) *string { return v.PerSeriesAligner }).(pulumi.StringPtrOutput)
}

type AggregationArrayOutput struct{ *pulumi.OutputState }

func (AggregationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Aggregation)(nil)).Elem()
}

func (o AggregationArrayOutput) ToAggregationArrayOutput() AggregationArrayOutput {
	return o
}

func (o AggregationArrayOutput) ToAggregationArrayOutputWithContext(ctx context.Context) AggregationArrayOutput {
	return o
}

func (o AggregationArrayOutput) Index(i pulumi.IntInput) AggregationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Aggregation {
		return vs[0].([]Aggregation)[vs[1].(int)]
	}).(AggregationOutput)
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationResponse struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
	AlignmentPeriod string `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer string `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields []string `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner string `pulumi:"perSeriesAligner"`
}

// AggregationResponseInput is an input type that accepts AggregationResponseArgs and AggregationResponseOutput values.
// You can construct a concrete instance of `AggregationResponseInput` via:
//
//          AggregationResponseArgs{...}
type AggregationResponseInput interface {
	pulumi.Input

	ToAggregationResponseOutput() AggregationResponseOutput
	ToAggregationResponseOutputWithContext(context.Context) AggregationResponseOutput
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationResponseArgs struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
	AlignmentPeriod pulumi.StringInput `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer pulumi.StringInput `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields pulumi.StringArrayInput `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner pulumi.StringInput `pulumi:"perSeriesAligner"`
}

func (AggregationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AggregationResponse)(nil)).Elem()
}

func (i AggregationResponseArgs) ToAggregationResponseOutput() AggregationResponseOutput {
	return i.ToAggregationResponseOutputWithContext(context.Background())
}

func (i AggregationResponseArgs) ToAggregationResponseOutputWithContext(ctx context.Context) AggregationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationResponseOutput)
}

// AggregationResponseArrayInput is an input type that accepts AggregationResponseArray and AggregationResponseArrayOutput values.
// You can construct a concrete instance of `AggregationResponseArrayInput` via:
//
//          AggregationResponseArray{ AggregationResponseArgs{...} }
type AggregationResponseArrayInput interface {
	pulumi.Input

	ToAggregationResponseArrayOutput() AggregationResponseArrayOutput
	ToAggregationResponseArrayOutputWithContext(context.Context) AggregationResponseArrayOutput
}

type AggregationResponseArray []AggregationResponseInput

func (AggregationResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AggregationResponse)(nil)).Elem()
}

func (i AggregationResponseArray) ToAggregationResponseArrayOutput() AggregationResponseArrayOutput {
	return i.ToAggregationResponseArrayOutputWithContext(context.Background())
}

func (i AggregationResponseArray) ToAggregationResponseArrayOutputWithContext(ctx context.Context) AggregationResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationResponseArrayOutput)
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationResponseOutput struct{ *pulumi.OutputState }

func (AggregationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AggregationResponse)(nil)).Elem()
}

func (o AggregationResponseOutput) ToAggregationResponseOutput() AggregationResponseOutput {
	return o
}

func (o AggregationResponseOutput) ToAggregationResponseOutputWithContext(ctx context.Context) AggregationResponseOutput {
	return o
}

// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
func (o AggregationResponseOutput) AlignmentPeriod() pulumi.StringOutput {
	return o.ApplyT(func(v AggregationResponse) string { return v.AlignmentPeriod }).(pulumi.StringOutput)
}

// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
func (o AggregationResponseOutput) CrossSeriesReducer() pulumi.StringOutput {
	return o.ApplyT(func(v AggregationResponse) string { return v.CrossSeriesReducer }).(pulumi.StringOutput)
}

// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
func (o AggregationResponseOutput) GroupByFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AggregationResponse) []string { return v.GroupByFields }).(pulumi.StringArrayOutput)
}

// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
func (o AggregationResponseOutput) PerSeriesAligner() pulumi.StringOutput {
	return o.ApplyT(func(v AggregationResponse) string { return v.PerSeriesAligner }).(pulumi.StringOutput)
}

type AggregationResponseArrayOutput struct{ *pulumi.OutputState }

func (AggregationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AggregationResponse)(nil)).Elem()
}

func (o AggregationResponseArrayOutput) ToAggregationResponseArrayOutput() AggregationResponseArrayOutput {
	return o
}

func (o AggregationResponseArrayOutput) ToAggregationResponseArrayOutputWithContext(ctx context.Context) AggregationResponseArrayOutput {
	return o
}

func (o AggregationResponseArrayOutput) Index(i pulumi.IntInput) AggregationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AggregationResponse {
		return vs[0].([]AggregationResponse)[vs[1].(int)]
	}).(AggregationResponseOutput)
}

// App Engine service. Learn more at https://cloud.google.com/appengine.
type AppEngine struct {
	// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource: https://cloud.google.com/monitoring/api/resources#tag_gae_app
	ModuleId *string `pulumi:"moduleId"`
}

// AppEngineInput is an input type that accepts AppEngineArgs and AppEngineOutput values.
// You can construct a concrete instance of `AppEngineInput` via:
//
//          AppEngineArgs{...}
type AppEngineInput interface {
	pulumi.Input

	ToAppEngineOutput() AppEngineOutput
	ToAppEngineOutputWithContext(context.Context) AppEngineOutput
}

// App Engine service. Learn more at https://cloud.google.com/appengine.
type AppEngineArgs struct {
	// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource: https://cloud.google.com/monitoring/api/resources#tag_gae_app
	ModuleId pulumi.StringPtrInput `pulumi:"moduleId"`
}

func (AppEngineArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AppEngine)(nil)).Elem()
}

func (i AppEngineArgs) ToAppEngineOutput() AppEngineOutput {
	return i.ToAppEngineOutputWithContext(context.Background())
}

func (i AppEngineArgs) ToAppEngineOutputWithContext(ctx context.Context) AppEngineOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppEngineOutput)
}

func (i AppEngineArgs) ToAppEnginePtrOutput() AppEnginePtrOutput {
	return i.ToAppEnginePtrOutputWithContext(context.Background())
}

func (i AppEngineArgs) ToAppEnginePtrOutputWithContext(ctx context.Context) AppEnginePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppEngineOutput).ToAppEnginePtrOutputWithContext(ctx)
}

// AppEnginePtrInput is an input type that accepts AppEngineArgs, AppEnginePtr and AppEnginePtrOutput values.
// You can construct a concrete instance of `AppEnginePtrInput` via:
//
//          AppEngineArgs{...}
//
//  or:
//
//          nil
type AppEnginePtrInput interface {
	pulumi.Input

	ToAppEnginePtrOutput() AppEnginePtrOutput
	ToAppEnginePtrOutputWithContext(context.Context) AppEnginePtrOutput
}

type appEnginePtrType AppEngineArgs

func AppEnginePtr(v *AppEngineArgs) AppEnginePtrInput {
	return (*appEnginePtrType)(v)
}

func (*appEnginePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AppEngine)(nil)).Elem()
}

func (i *appEnginePtrType) ToAppEnginePtrOutput() AppEnginePtrOutput {
	return i.ToAppEnginePtrOutputWithContext(context.Background())
}

func (i *appEnginePtrType) ToAppEnginePtrOutputWithContext(ctx context.Context) AppEnginePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppEnginePtrOutput)
}

// App Engine service. Learn more at https://cloud.google.com/appengine.
type AppEngineOutput struct{ *pulumi.OutputState }

func (AppEngineOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AppEngine)(nil)).Elem()
}

func (o AppEngineOutput) ToAppEngineOutput() AppEngineOutput {
	return o
}

func (o AppEngineOutput) ToAppEngineOutputWithContext(ctx context.Context) AppEngineOutput {
	return o
}

func (o AppEngineOutput) ToAppEnginePtrOutput() AppEnginePtrOutput {
	return o.ToAppEnginePtrOutputWithContext(context.Background())
}

func (o AppEngineOutput) ToAppEnginePtrOutputWithContext(ctx context.Context) AppEnginePtrOutput {
	return o.ApplyT(func(v AppEngine) *AppEngine {
		return &v
	}).(AppEnginePtrOutput)
}

// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource: https://cloud.google.com/monitoring/api/resources#tag_gae_app
func (o AppEngineOutput) ModuleId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AppEngine) *string { return v.ModuleId }).(pulumi.StringPtrOutput)
}

type AppEnginePtrOutput struct{ *pulumi.OutputState }

func (AppEnginePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AppEngine)(nil)).Elem()
}

func (o AppEnginePtrOutput) ToAppEnginePtrOutput() AppEnginePtrOutput {
	return o
}

func (o AppEnginePtrOutput) ToAppEnginePtrOutputWithContext(ctx context.Context) AppEnginePtrOutput {
	return o
}

func (o AppEnginePtrOutput) Elem() AppEngineOutput {
	return o.ApplyT(func(v *AppEngine) AppEngine { return *v }).(AppEngineOutput)
}

// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource: https://cloud.google.com/monitoring/api/resources#tag_gae_app
func (o AppEnginePtrOutput) ModuleId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AppEngine) *string {
		if v == nil {
			return nil
		}
		return v.ModuleId
	}).(pulumi.StringPtrOutput)
}

// App Engine service. Learn more at https://cloud.google.com/appengine.
type AppEngineResponse struct {
	// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource: https://cloud.google.com/monitoring/api/resources#tag_gae_app
	ModuleId string `pulumi:"moduleId"`
}

// AppEngineResponseInput is an input type that accepts AppEngineResponseArgs and AppEngineResponseOutput values.
// You can construct a concrete instance of `AppEngineResponseInput` via:
//
//          AppEngineResponseArgs{...}
type AppEngineResponseInput interface {
	pulumi.Input

	ToAppEngineResponseOutput() AppEngineResponseOutput
	ToAppEngineResponseOutputWithContext(context.Context) AppEngineResponseOutput
}

// App Engine service. Learn more at https://cloud.google.com/appengine.
type AppEngineResponseArgs struct {
	// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource: https://cloud.google.com/monitoring/api/resources#tag_gae_app
	ModuleId pulumi.StringInput `pulumi:"moduleId"`
}

func (AppEngineResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AppEngineResponse)(nil)).Elem()
}

func (i AppEngineResponseArgs) ToAppEngineResponseOutput() AppEngineResponseOutput {
	return i.ToAppEngineResponseOutputWithContext(context.Background())
}

func (i AppEngineResponseArgs) ToAppEngineResponseOutputWithContext(ctx context.Context) AppEngineResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppEngineResponseOutput)
}

func (i AppEngineResponseArgs) ToAppEngineResponsePtrOutput() AppEngineResponsePtrOutput {
	return i.ToAppEngineResponsePtrOutputWithContext(context.Background())
}

func (i AppEngineResponseArgs) ToAppEngineResponsePtrOutputWithContext(ctx context.Context) AppEngineResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppEngineResponseOutput).ToAppEngineResponsePtrOutputWithContext(ctx)
}

// AppEngineResponsePtrInput is an input type that accepts AppEngineResponseArgs, AppEngineResponsePtr and AppEngineResponsePtrOutput values.
// You can construct a concrete instance of `AppEngineResponsePtrInput` via:
//
//          AppEngineResponseArgs{...}
//
//  or:
//
//          nil
type AppEngineResponsePtrInput interface {
	pulumi.Input

	ToAppEngineResponsePtrOutput() AppEngineResponsePtrOutput
	ToAppEngineResponsePtrOutputWithContext(context.Context) AppEngineResponsePtrOutput
}

type appEngineResponsePtrType AppEngineResponseArgs

func AppEngineResponsePtr(v *AppEngineResponseArgs) AppEngineResponsePtrInput {
	return (*appEngineResponsePtrType)(v)
}

func (*appEngineResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AppEngineResponse)(nil)).Elem()
}

func (i *appEngineResponsePtrType) ToAppEngineResponsePtrOutput() AppEngineResponsePtrOutput {
	return i.ToAppEngineResponsePtrOutputWithContext(context.Background())
}

func (i *appEngineResponsePtrType) ToAppEngineResponsePtrOutputWithContext(ctx context.Context) AppEngineResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppEngineResponsePtrOutput)
}

// App Engine service. Learn more at https://cloud.google.com/appengine.
type AppEngineResponseOutput struct{ *pulumi.OutputState }

func (AppEngineResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AppEngineResponse)(nil)).Elem()
}

func (o AppEngineResponseOutput) ToAppEngineResponseOutput() AppEngineResponseOutput {
	return o
}

func (o AppEngineResponseOutput) ToAppEngineResponseOutputWithContext(ctx context.Context) AppEngineResponseOutput {
	return o
}

func (o AppEngineResponseOutput) ToAppEngineResponsePtrOutput() AppEngineResponsePtrOutput {
	return o.ToAppEngineResponsePtrOutputWithContext(context.Background())
}

func (o AppEngineResponseOutput) ToAppEngineResponsePtrOutputWithContext(ctx context.Context) AppEngineResponsePtrOutput {
	return o.ApplyT(func(v AppEngineResponse) *AppEngineResponse {
		return &v
	}).(AppEngineResponsePtrOutput)
}

// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource: https://cloud.google.com/monitoring/api/resources#tag_gae_app
func (o AppEngineResponseOutput) ModuleId() pulumi.StringOutput {
	return o.ApplyT(func(v AppEngineResponse) string { return v.ModuleId }).(pulumi.StringOutput)
}

type AppEngineResponsePtrOutput struct{ *pulumi.OutputState }

func (AppEngineResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AppEngineResponse)(nil)).Elem()
}

func (o AppEngineResponsePtrOutput) ToAppEngineResponsePtrOutput() AppEngineResponsePtrOutput {
	return o
}

func (o AppEngineResponsePtrOutput) ToAppEngineResponsePtrOutputWithContext(ctx context.Context) AppEngineResponsePtrOutput {
	return o
}

func (o AppEngineResponsePtrOutput) Elem() AppEngineResponseOutput {
	return o.ApplyT(func(v *AppEngineResponse) AppEngineResponse { return *v }).(AppEngineResponseOutput)
}

// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource: https://cloud.google.com/monitoring/api/resources#tag_gae_app
func (o AppEngineResponsePtrOutput) ModuleId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AppEngineResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ModuleId
	}).(pulumi.StringPtrOutput)
}

// Future parameters for the availability SLI.
type AvailabilityCriteria struct {
}

// AvailabilityCriteriaInput is an input type that accepts AvailabilityCriteriaArgs and AvailabilityCriteriaOutput values.
// You can construct a concrete instance of `AvailabilityCriteriaInput` via:
//
//          AvailabilityCriteriaArgs{...}
type AvailabilityCriteriaInput interface {
	pulumi.Input

	ToAvailabilityCriteriaOutput() AvailabilityCriteriaOutput
	ToAvailabilityCriteriaOutputWithContext(context.Context) AvailabilityCriteriaOutput
}

// Future parameters for the availability SLI.
type AvailabilityCriteriaArgs struct {
}

func (AvailabilityCriteriaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AvailabilityCriteria)(nil)).Elem()
}

func (i AvailabilityCriteriaArgs) ToAvailabilityCriteriaOutput() AvailabilityCriteriaOutput {
	return i.ToAvailabilityCriteriaOutputWithContext(context.Background())
}

func (i AvailabilityCriteriaArgs) ToAvailabilityCriteriaOutputWithContext(ctx context.Context) AvailabilityCriteriaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailabilityCriteriaOutput)
}

func (i AvailabilityCriteriaArgs) ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput {
	return i.ToAvailabilityCriteriaPtrOutputWithContext(context.Background())
}

func (i AvailabilityCriteriaArgs) ToAvailabilityCriteriaPtrOutputWithContext(ctx context.Context) AvailabilityCriteriaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailabilityCriteriaOutput).ToAvailabilityCriteriaPtrOutputWithContext(ctx)
}

// AvailabilityCriteriaPtrInput is an input type that accepts AvailabilityCriteriaArgs, AvailabilityCriteriaPtr and AvailabilityCriteriaPtrOutput values.
// You can construct a concrete instance of `AvailabilityCriteriaPtrInput` via:
//
//          AvailabilityCriteriaArgs{...}
//
//  or:
//
//          nil
type AvailabilityCriteriaPtrInput interface {
	pulumi.Input

	ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput
	ToAvailabilityCriteriaPtrOutputWithContext(context.Context) AvailabilityCriteriaPtrOutput
}

type availabilityCriteriaPtrType AvailabilityCriteriaArgs

func AvailabilityCriteriaPtr(v *AvailabilityCriteriaArgs) AvailabilityCriteriaPtrInput {
	return (*availabilityCriteriaPtrType)(v)
}

func (*availabilityCriteriaPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AvailabilityCriteria)(nil)).Elem()
}

func (i *availabilityCriteriaPtrType) ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput {
	return i.ToAvailabilityCriteriaPtrOutputWithContext(context.Background())
}

func (i *availabilityCriteriaPtrType) ToAvailabilityCriteriaPtrOutputWithContext(ctx context.Context) AvailabilityCriteriaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailabilityCriteriaPtrOutput)
}

// Future parameters for the availability SLI.
type AvailabilityCriteriaOutput struct{ *pulumi.OutputState }

func (AvailabilityCriteriaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AvailabilityCriteria)(nil)).Elem()
}

func (o AvailabilityCriteriaOutput) ToAvailabilityCriteriaOutput() AvailabilityCriteriaOutput {
	return o
}

func (o AvailabilityCriteriaOutput) ToAvailabilityCriteriaOutputWithContext(ctx context.Context) AvailabilityCriteriaOutput {
	return o
}

func (o AvailabilityCriteriaOutput) ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput {
	return o.ToAvailabilityCriteriaPtrOutputWithContext(context.Background())
}

func (o AvailabilityCriteriaOutput) ToAvailabilityCriteriaPtrOutputWithContext(ctx context.Context) AvailabilityCriteriaPtrOutput {
	return o.ApplyT(func(v AvailabilityCriteria) *AvailabilityCriteria {
		return &v
	}).(AvailabilityCriteriaPtrOutput)
}

type AvailabilityCriteriaPtrOutput struct{ *pulumi.OutputState }

func (AvailabilityCriteriaPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AvailabilityCriteria)(nil)).Elem()
}

func (o AvailabilityCriteriaPtrOutput) ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput {
	return o
}

func (o AvailabilityCriteriaPtrOutput) ToAvailabilityCriteriaPtrOutputWithContext(ctx context.Context) AvailabilityCriteriaPtrOutput {
	return o
}

func (o AvailabilityCriteriaPtrOutput) Elem() AvailabilityCriteriaOutput {
	return o.ApplyT(func(v *AvailabilityCriteria) AvailabilityCriteria { return *v }).(AvailabilityCriteriaOutput)
}

// Future parameters for the availability SLI.
type AvailabilityCriteriaResponse struct {
}

// AvailabilityCriteriaResponseInput is an input type that accepts AvailabilityCriteriaResponseArgs and AvailabilityCriteriaResponseOutput values.
// You can construct a concrete instance of `AvailabilityCriteriaResponseInput` via:
//
//          AvailabilityCriteriaResponseArgs{...}
type AvailabilityCriteriaResponseInput interface {
	pulumi.Input

	ToAvailabilityCriteriaResponseOutput() AvailabilityCriteriaResponseOutput
	ToAvailabilityCriteriaResponseOutputWithContext(context.Context) AvailabilityCriteriaResponseOutput
}

// Future parameters for the availability SLI.
type AvailabilityCriteriaResponseArgs struct {
}

func (AvailabilityCriteriaResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AvailabilityCriteriaResponse)(nil)).Elem()
}

func (i AvailabilityCriteriaResponseArgs) ToAvailabilityCriteriaResponseOutput() AvailabilityCriteriaResponseOutput {
	return i.ToAvailabilityCriteriaResponseOutputWithContext(context.Background())
}

func (i AvailabilityCriteriaResponseArgs) ToAvailabilityCriteriaResponseOutputWithContext(ctx context.Context) AvailabilityCriteriaResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailabilityCriteriaResponseOutput)
}

func (i AvailabilityCriteriaResponseArgs) ToAvailabilityCriteriaResponsePtrOutput() AvailabilityCriteriaResponsePtrOutput {
	return i.ToAvailabilityCriteriaResponsePtrOutputWithContext(context.Background())
}

func (i AvailabilityCriteriaResponseArgs) ToAvailabilityCriteriaResponsePtrOutputWithContext(ctx context.Context) AvailabilityCriteriaResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailabilityCriteriaResponseOutput).ToAvailabilityCriteriaResponsePtrOutputWithContext(ctx)
}

// AvailabilityCriteriaResponsePtrInput is an input type that accepts AvailabilityCriteriaResponseArgs, AvailabilityCriteriaResponsePtr and AvailabilityCriteriaResponsePtrOutput values.
// You can construct a concrete instance of `AvailabilityCriteriaResponsePtrInput` via:
//
//          AvailabilityCriteriaResponseArgs{...}
//
//  or:
//
//          nil
type AvailabilityCriteriaResponsePtrInput interface {
	pulumi.Input

	ToAvailabilityCriteriaResponsePtrOutput() AvailabilityCriteriaResponsePtrOutput
	ToAvailabilityCriteriaResponsePtrOutputWithContext(context.Context) AvailabilityCriteriaResponsePtrOutput
}

type availabilityCriteriaResponsePtrType AvailabilityCriteriaResponseArgs

func AvailabilityCriteriaResponsePtr(v *AvailabilityCriteriaResponseArgs) AvailabilityCriteriaResponsePtrInput {
	return (*availabilityCriteriaResponsePtrType)(v)
}

func (*availabilityCriteriaResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AvailabilityCriteriaResponse)(nil)).Elem()
}

func (i *availabilityCriteriaResponsePtrType) ToAvailabilityCriteriaResponsePtrOutput() AvailabilityCriteriaResponsePtrOutput {
	return i.ToAvailabilityCriteriaResponsePtrOutputWithContext(context.Background())
}

func (i *availabilityCriteriaResponsePtrType) ToAvailabilityCriteriaResponsePtrOutputWithContext(ctx context.Context) AvailabilityCriteriaResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailabilityCriteriaResponsePtrOutput)
}

// Future parameters for the availability SLI.
type AvailabilityCriteriaResponseOutput struct{ *pulumi.OutputState }

func (AvailabilityCriteriaResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AvailabilityCriteriaResponse)(nil)).Elem()
}

func (o AvailabilityCriteriaResponseOutput) ToAvailabilityCriteriaResponseOutput() AvailabilityCriteriaResponseOutput {
	return o
}

func (o AvailabilityCriteriaResponseOutput) ToAvailabilityCriteriaResponseOutputWithContext(ctx context.Context) AvailabilityCriteriaResponseOutput {
	return o
}

func (o AvailabilityCriteriaResponseOutput) ToAvailabilityCriteriaResponsePtrOutput() AvailabilityCriteriaResponsePtrOutput {
	return o.ToAvailabilityCriteriaResponsePtrOutputWithContext(context.Background())
}

func (o AvailabilityCriteriaResponseOutput) ToAvailabilityCriteriaResponsePtrOutputWithContext(ctx context.Context) AvailabilityCriteriaResponsePtrOutput {
	return o.ApplyT(func(v AvailabilityCriteriaResponse) *AvailabilityCriteriaResponse {
		return &v
	}).(AvailabilityCriteriaResponsePtrOutput)
}

type AvailabilityCriteriaResponsePtrOutput struct{ *pulumi.OutputState }

func (AvailabilityCriteriaResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AvailabilityCriteriaResponse)(nil)).Elem()
}

func (o AvailabilityCriteriaResponsePtrOutput) ToAvailabilityCriteriaResponsePtrOutput() AvailabilityCriteriaResponsePtrOutput {
	return o
}

func (o AvailabilityCriteriaResponsePtrOutput) ToAvailabilityCriteriaResponsePtrOutputWithContext(ctx context.Context) AvailabilityCriteriaResponsePtrOutput {
	return o
}

func (o AvailabilityCriteriaResponsePtrOutput) Elem() AvailabilityCriteriaResponseOutput {
	return o.ApplyT(func(v *AvailabilityCriteriaResponse) AvailabilityCriteriaResponse { return *v }).(AvailabilityCriteriaResponseOutput)
}

// The authentication parameters to provide to the specified resource or URL that requires a username and password. Currently, only Basic HTTP authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime checks.
type BasicAuthentication struct {
	// The password to use when authenticating with the HTTP server.
	Password *string `pulumi:"password"`
	// The username to use when authenticating with the HTTP server.
	Username *string `pulumi:"username"`
}

// BasicAuthenticationInput is an input type that accepts BasicAuthenticationArgs and BasicAuthenticationOutput values.
// You can construct a concrete instance of `BasicAuthenticationInput` via:
//
//          BasicAuthenticationArgs{...}
type BasicAuthenticationInput interface {
	pulumi.Input

	ToBasicAuthenticationOutput() BasicAuthenticationOutput
	ToBasicAuthenticationOutputWithContext(context.Context) BasicAuthenticationOutput
}

// The authentication parameters to provide to the specified resource or URL that requires a username and password. Currently, only Basic HTTP authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime checks.
type BasicAuthenticationArgs struct {
	// The password to use when authenticating with the HTTP server.
	Password pulumi.StringPtrInput `pulumi:"password"`
	// The username to use when authenticating with the HTTP server.
	Username pulumi.StringPtrInput `pulumi:"username"`
}

func (BasicAuthenticationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicAuthentication)(nil)).Elem()
}

func (i BasicAuthenticationArgs) ToBasicAuthenticationOutput() BasicAuthenticationOutput {
	return i.ToBasicAuthenticationOutputWithContext(context.Background())
}

func (i BasicAuthenticationArgs) ToBasicAuthenticationOutputWithContext(ctx context.Context) BasicAuthenticationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicAuthenticationOutput)
}

func (i BasicAuthenticationArgs) ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput {
	return i.ToBasicAuthenticationPtrOutputWithContext(context.Background())
}

func (i BasicAuthenticationArgs) ToBasicAuthenticationPtrOutputWithContext(ctx context.Context) BasicAuthenticationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicAuthenticationOutput).ToBasicAuthenticationPtrOutputWithContext(ctx)
}

// BasicAuthenticationPtrInput is an input type that accepts BasicAuthenticationArgs, BasicAuthenticationPtr and BasicAuthenticationPtrOutput values.
// You can construct a concrete instance of `BasicAuthenticationPtrInput` via:
//
//          BasicAuthenticationArgs{...}
//
//  or:
//
//          nil
type BasicAuthenticationPtrInput interface {
	pulumi.Input

	ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput
	ToBasicAuthenticationPtrOutputWithContext(context.Context) BasicAuthenticationPtrOutput
}

type basicAuthenticationPtrType BasicAuthenticationArgs

func BasicAuthenticationPtr(v *BasicAuthenticationArgs) BasicAuthenticationPtrInput {
	return (*basicAuthenticationPtrType)(v)
}

func (*basicAuthenticationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicAuthentication)(nil)).Elem()
}

func (i *basicAuthenticationPtrType) ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput {
	return i.ToBasicAuthenticationPtrOutputWithContext(context.Background())
}

func (i *basicAuthenticationPtrType) ToBasicAuthenticationPtrOutputWithContext(ctx context.Context) BasicAuthenticationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicAuthenticationPtrOutput)
}

// The authentication parameters to provide to the specified resource or URL that requires a username and password. Currently, only Basic HTTP authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime checks.
type BasicAuthenticationOutput struct{ *pulumi.OutputState }

func (BasicAuthenticationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicAuthentication)(nil)).Elem()
}

func (o BasicAuthenticationOutput) ToBasicAuthenticationOutput() BasicAuthenticationOutput {
	return o
}

func (o BasicAuthenticationOutput) ToBasicAuthenticationOutputWithContext(ctx context.Context) BasicAuthenticationOutput {
	return o
}

func (o BasicAuthenticationOutput) ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput {
	return o.ToBasicAuthenticationPtrOutputWithContext(context.Background())
}

func (o BasicAuthenticationOutput) ToBasicAuthenticationPtrOutputWithContext(ctx context.Context) BasicAuthenticationPtrOutput {
	return o.ApplyT(func(v BasicAuthentication) *BasicAuthentication {
		return &v
	}).(BasicAuthenticationPtrOutput)
}

// The password to use when authenticating with the HTTP server.
func (o BasicAuthenticationOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BasicAuthentication) *string { return v.Password }).(pulumi.StringPtrOutput)
}

// The username to use when authenticating with the HTTP server.
func (o BasicAuthenticationOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BasicAuthentication) *string { return v.Username }).(pulumi.StringPtrOutput)
}

type BasicAuthenticationPtrOutput struct{ *pulumi.OutputState }

func (BasicAuthenticationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicAuthentication)(nil)).Elem()
}

func (o BasicAuthenticationPtrOutput) ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput {
	return o
}

func (o BasicAuthenticationPtrOutput) ToBasicAuthenticationPtrOutputWithContext(ctx context.Context) BasicAuthenticationPtrOutput {
	return o
}

func (o BasicAuthenticationPtrOutput) Elem() BasicAuthenticationOutput {
	return o.ApplyT(func(v *BasicAuthentication) BasicAuthentication { return *v }).(BasicAuthenticationOutput)
}

// The password to use when authenticating with the HTTP server.
func (o BasicAuthenticationPtrOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BasicAuthentication) *string {
		if v == nil {
			return nil
		}
		return v.Password
	}).(pulumi.StringPtrOutput)
}

// The username to use when authenticating with the HTTP server.
func (o BasicAuthenticationPtrOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BasicAuthentication) *string {
		if v == nil {
			return nil
		}
		return v.Username
	}).(pulumi.StringPtrOutput)
}

// The authentication parameters to provide to the specified resource or URL that requires a username and password. Currently, only Basic HTTP authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime checks.
type BasicAuthenticationResponse struct {
	// The password to use when authenticating with the HTTP server.
	Password string `pulumi:"password"`
	// The username to use when authenticating with the HTTP server.
	Username string `pulumi:"username"`
}

// BasicAuthenticationResponseInput is an input type that accepts BasicAuthenticationResponseArgs and BasicAuthenticationResponseOutput values.
// You can construct a concrete instance of `BasicAuthenticationResponseInput` via:
//
//          BasicAuthenticationResponseArgs{...}
type BasicAuthenticationResponseInput interface {
	pulumi.Input

	ToBasicAuthenticationResponseOutput() BasicAuthenticationResponseOutput
	ToBasicAuthenticationResponseOutputWithContext(context.Context) BasicAuthenticationResponseOutput
}

// The authentication parameters to provide to the specified resource or URL that requires a username and password. Currently, only Basic HTTP authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime checks.
type BasicAuthenticationResponseArgs struct {
	// The password to use when authenticating with the HTTP server.
	Password pulumi.StringInput `pulumi:"password"`
	// The username to use when authenticating with the HTTP server.
	Username pulumi.StringInput `pulumi:"username"`
}

func (BasicAuthenticationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicAuthenticationResponse)(nil)).Elem()
}

func (i BasicAuthenticationResponseArgs) ToBasicAuthenticationResponseOutput() BasicAuthenticationResponseOutput {
	return i.ToBasicAuthenticationResponseOutputWithContext(context.Background())
}

func (i BasicAuthenticationResponseArgs) ToBasicAuthenticationResponseOutputWithContext(ctx context.Context) BasicAuthenticationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicAuthenticationResponseOutput)
}

func (i BasicAuthenticationResponseArgs) ToBasicAuthenticationResponsePtrOutput() BasicAuthenticationResponsePtrOutput {
	return i.ToBasicAuthenticationResponsePtrOutputWithContext(context.Background())
}

func (i BasicAuthenticationResponseArgs) ToBasicAuthenticationResponsePtrOutputWithContext(ctx context.Context) BasicAuthenticationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicAuthenticationResponseOutput).ToBasicAuthenticationResponsePtrOutputWithContext(ctx)
}

// BasicAuthenticationResponsePtrInput is an input type that accepts BasicAuthenticationResponseArgs, BasicAuthenticationResponsePtr and BasicAuthenticationResponsePtrOutput values.
// You can construct a concrete instance of `BasicAuthenticationResponsePtrInput` via:
//
//          BasicAuthenticationResponseArgs{...}
//
//  or:
//
//          nil
type BasicAuthenticationResponsePtrInput interface {
	pulumi.Input

	ToBasicAuthenticationResponsePtrOutput() BasicAuthenticationResponsePtrOutput
	ToBasicAuthenticationResponsePtrOutputWithContext(context.Context) BasicAuthenticationResponsePtrOutput
}

type basicAuthenticationResponsePtrType BasicAuthenticationResponseArgs

func BasicAuthenticationResponsePtr(v *BasicAuthenticationResponseArgs) BasicAuthenticationResponsePtrInput {
	return (*basicAuthenticationResponsePtrType)(v)
}

func (*basicAuthenticationResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicAuthenticationResponse)(nil)).Elem()
}

func (i *basicAuthenticationResponsePtrType) ToBasicAuthenticationResponsePtrOutput() BasicAuthenticationResponsePtrOutput {
	return i.ToBasicAuthenticationResponsePtrOutputWithContext(context.Background())
}

func (i *basicAuthenticationResponsePtrType) ToBasicAuthenticationResponsePtrOutputWithContext(ctx context.Context) BasicAuthenticationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicAuthenticationResponsePtrOutput)
}

// The authentication parameters to provide to the specified resource or URL that requires a username and password. Currently, only Basic HTTP authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime checks.
type BasicAuthenticationResponseOutput struct{ *pulumi.OutputState }

func (BasicAuthenticationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicAuthenticationResponse)(nil)).Elem()
}

func (o BasicAuthenticationResponseOutput) ToBasicAuthenticationResponseOutput() BasicAuthenticationResponseOutput {
	return o
}

func (o BasicAuthenticationResponseOutput) ToBasicAuthenticationResponseOutputWithContext(ctx context.Context) BasicAuthenticationResponseOutput {
	return o
}

func (o BasicAuthenticationResponseOutput) ToBasicAuthenticationResponsePtrOutput() BasicAuthenticationResponsePtrOutput {
	return o.ToBasicAuthenticationResponsePtrOutputWithContext(context.Background())
}

func (o BasicAuthenticationResponseOutput) ToBasicAuthenticationResponsePtrOutputWithContext(ctx context.Context) BasicAuthenticationResponsePtrOutput {
	return o.ApplyT(func(v BasicAuthenticationResponse) *BasicAuthenticationResponse {
		return &v
	}).(BasicAuthenticationResponsePtrOutput)
}

// The password to use when authenticating with the HTTP server.
func (o BasicAuthenticationResponseOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v BasicAuthenticationResponse) string { return v.Password }).(pulumi.StringOutput)
}

// The username to use when authenticating with the HTTP server.
func (o BasicAuthenticationResponseOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v BasicAuthenticationResponse) string { return v.Username }).(pulumi.StringOutput)
}

type BasicAuthenticationResponsePtrOutput struct{ *pulumi.OutputState }

func (BasicAuthenticationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicAuthenticationResponse)(nil)).Elem()
}

func (o BasicAuthenticationResponsePtrOutput) ToBasicAuthenticationResponsePtrOutput() BasicAuthenticationResponsePtrOutput {
	return o
}

func (o BasicAuthenticationResponsePtrOutput) ToBasicAuthenticationResponsePtrOutputWithContext(ctx context.Context) BasicAuthenticationResponsePtrOutput {
	return o
}

func (o BasicAuthenticationResponsePtrOutput) Elem() BasicAuthenticationResponseOutput {
	return o.ApplyT(func(v *BasicAuthenticationResponse) BasicAuthenticationResponse { return *v }).(BasicAuthenticationResponseOutput)
}

// The password to use when authenticating with the HTTP server.
func (o BasicAuthenticationResponsePtrOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BasicAuthenticationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Password
	}).(pulumi.StringPtrOutput)
}

// The username to use when authenticating with the HTTP server.
func (o BasicAuthenticationResponsePtrOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BasicAuthenticationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Username
	}).(pulumi.StringPtrOutput)
}

// An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.
type BasicSli struct {
	// Good service is defined to be the count of requests made to this service that return successfully.
	Availability *AvailabilityCriteria `pulumi:"availability"`
	// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
	Latency *LatencyCriteria `pulumi:"latency"`
	// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
	Location []string `pulumi:"location"`
	// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
	Method []string `pulumi:"method"`
	// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
	Version []string `pulumi:"version"`
}

// BasicSliInput is an input type that accepts BasicSliArgs and BasicSliOutput values.
// You can construct a concrete instance of `BasicSliInput` via:
//
//          BasicSliArgs{...}
type BasicSliInput interface {
	pulumi.Input

	ToBasicSliOutput() BasicSliOutput
	ToBasicSliOutputWithContext(context.Context) BasicSliOutput
}

// An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.
type BasicSliArgs struct {
	// Good service is defined to be the count of requests made to this service that return successfully.
	Availability AvailabilityCriteriaPtrInput `pulumi:"availability"`
	// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
	Latency LatencyCriteriaPtrInput `pulumi:"latency"`
	// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
	Location pulumi.StringArrayInput `pulumi:"location"`
	// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
	Method pulumi.StringArrayInput `pulumi:"method"`
	// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
	Version pulumi.StringArrayInput `pulumi:"version"`
}

func (BasicSliArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicSli)(nil)).Elem()
}

func (i BasicSliArgs) ToBasicSliOutput() BasicSliOutput {
	return i.ToBasicSliOutputWithContext(context.Background())
}

func (i BasicSliArgs) ToBasicSliOutputWithContext(ctx context.Context) BasicSliOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicSliOutput)
}

func (i BasicSliArgs) ToBasicSliPtrOutput() BasicSliPtrOutput {
	return i.ToBasicSliPtrOutputWithContext(context.Background())
}

func (i BasicSliArgs) ToBasicSliPtrOutputWithContext(ctx context.Context) BasicSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicSliOutput).ToBasicSliPtrOutputWithContext(ctx)
}

// BasicSliPtrInput is an input type that accepts BasicSliArgs, BasicSliPtr and BasicSliPtrOutput values.
// You can construct a concrete instance of `BasicSliPtrInput` via:
//
//          BasicSliArgs{...}
//
//  or:
//
//          nil
type BasicSliPtrInput interface {
	pulumi.Input

	ToBasicSliPtrOutput() BasicSliPtrOutput
	ToBasicSliPtrOutputWithContext(context.Context) BasicSliPtrOutput
}

type basicSliPtrType BasicSliArgs

func BasicSliPtr(v *BasicSliArgs) BasicSliPtrInput {
	return (*basicSliPtrType)(v)
}

func (*basicSliPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicSli)(nil)).Elem()
}

func (i *basicSliPtrType) ToBasicSliPtrOutput() BasicSliPtrOutput {
	return i.ToBasicSliPtrOutputWithContext(context.Background())
}

func (i *basicSliPtrType) ToBasicSliPtrOutputWithContext(ctx context.Context) BasicSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicSliPtrOutput)
}

// An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.
type BasicSliOutput struct{ *pulumi.OutputState }

func (BasicSliOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicSli)(nil)).Elem()
}

func (o BasicSliOutput) ToBasicSliOutput() BasicSliOutput {
	return o
}

func (o BasicSliOutput) ToBasicSliOutputWithContext(ctx context.Context) BasicSliOutput {
	return o
}

func (o BasicSliOutput) ToBasicSliPtrOutput() BasicSliPtrOutput {
	return o.ToBasicSliPtrOutputWithContext(context.Background())
}

func (o BasicSliOutput) ToBasicSliPtrOutputWithContext(ctx context.Context) BasicSliPtrOutput {
	return o.ApplyT(func(v BasicSli) *BasicSli {
		return &v
	}).(BasicSliPtrOutput)
}

// Good service is defined to be the count of requests made to this service that return successfully.
func (o BasicSliOutput) Availability() AvailabilityCriteriaPtrOutput {
	return o.ApplyT(func(v BasicSli) *AvailabilityCriteria { return v.Availability }).(AvailabilityCriteriaPtrOutput)
}

// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
func (o BasicSliOutput) Latency() LatencyCriteriaPtrOutput {
	return o.ApplyT(func(v BasicSli) *LatencyCriteria { return v.Latency }).(LatencyCriteriaPtrOutput)
}

// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
func (o BasicSliOutput) Location() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSli) []string { return v.Location }).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
func (o BasicSliOutput) Method() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSli) []string { return v.Method }).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
func (o BasicSliOutput) Version() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSli) []string { return v.Version }).(pulumi.StringArrayOutput)
}

type BasicSliPtrOutput struct{ *pulumi.OutputState }

func (BasicSliPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicSli)(nil)).Elem()
}

func (o BasicSliPtrOutput) ToBasicSliPtrOutput() BasicSliPtrOutput {
	return o
}

func (o BasicSliPtrOutput) ToBasicSliPtrOutputWithContext(ctx context.Context) BasicSliPtrOutput {
	return o
}

func (o BasicSliPtrOutput) Elem() BasicSliOutput {
	return o.ApplyT(func(v *BasicSli) BasicSli { return *v }).(BasicSliOutput)
}

// Good service is defined to be the count of requests made to this service that return successfully.
func (o BasicSliPtrOutput) Availability() AvailabilityCriteriaPtrOutput {
	return o.ApplyT(func(v *BasicSli) *AvailabilityCriteria {
		if v == nil {
			return nil
		}
		return v.Availability
	}).(AvailabilityCriteriaPtrOutput)
}

// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
func (o BasicSliPtrOutput) Latency() LatencyCriteriaPtrOutput {
	return o.ApplyT(func(v *BasicSli) *LatencyCriteria {
		if v == nil {
			return nil
		}
		return v.Latency
	}).(LatencyCriteriaPtrOutput)
}

// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
func (o BasicSliPtrOutput) Location() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *BasicSli) []string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
func (o BasicSliPtrOutput) Method() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *BasicSli) []string {
		if v == nil {
			return nil
		}
		return v.Method
	}).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
func (o BasicSliPtrOutput) Version() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *BasicSli) []string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringArrayOutput)
}

// An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.
type BasicSliResponse struct {
	// Good service is defined to be the count of requests made to this service that return successfully.
	Availability AvailabilityCriteriaResponse `pulumi:"availability"`
	// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
	Latency LatencyCriteriaResponse `pulumi:"latency"`
	// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
	Location []string `pulumi:"location"`
	// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
	Method []string `pulumi:"method"`
	// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
	Version []string `pulumi:"version"`
}

// BasicSliResponseInput is an input type that accepts BasicSliResponseArgs and BasicSliResponseOutput values.
// You can construct a concrete instance of `BasicSliResponseInput` via:
//
//          BasicSliResponseArgs{...}
type BasicSliResponseInput interface {
	pulumi.Input

	ToBasicSliResponseOutput() BasicSliResponseOutput
	ToBasicSliResponseOutputWithContext(context.Context) BasicSliResponseOutput
}

// An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.
type BasicSliResponseArgs struct {
	// Good service is defined to be the count of requests made to this service that return successfully.
	Availability AvailabilityCriteriaResponseInput `pulumi:"availability"`
	// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
	Latency LatencyCriteriaResponseInput `pulumi:"latency"`
	// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
	Location pulumi.StringArrayInput `pulumi:"location"`
	// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
	Method pulumi.StringArrayInput `pulumi:"method"`
	// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
	Version pulumi.StringArrayInput `pulumi:"version"`
}

func (BasicSliResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicSliResponse)(nil)).Elem()
}

func (i BasicSliResponseArgs) ToBasicSliResponseOutput() BasicSliResponseOutput {
	return i.ToBasicSliResponseOutputWithContext(context.Background())
}

func (i BasicSliResponseArgs) ToBasicSliResponseOutputWithContext(ctx context.Context) BasicSliResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicSliResponseOutput)
}

func (i BasicSliResponseArgs) ToBasicSliResponsePtrOutput() BasicSliResponsePtrOutput {
	return i.ToBasicSliResponsePtrOutputWithContext(context.Background())
}

func (i BasicSliResponseArgs) ToBasicSliResponsePtrOutputWithContext(ctx context.Context) BasicSliResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicSliResponseOutput).ToBasicSliResponsePtrOutputWithContext(ctx)
}

// BasicSliResponsePtrInput is an input type that accepts BasicSliResponseArgs, BasicSliResponsePtr and BasicSliResponsePtrOutput values.
// You can construct a concrete instance of `BasicSliResponsePtrInput` via:
//
//          BasicSliResponseArgs{...}
//
//  or:
//
//          nil
type BasicSliResponsePtrInput interface {
	pulumi.Input

	ToBasicSliResponsePtrOutput() BasicSliResponsePtrOutput
	ToBasicSliResponsePtrOutputWithContext(context.Context) BasicSliResponsePtrOutput
}

type basicSliResponsePtrType BasicSliResponseArgs

func BasicSliResponsePtr(v *BasicSliResponseArgs) BasicSliResponsePtrInput {
	return (*basicSliResponsePtrType)(v)
}

func (*basicSliResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicSliResponse)(nil)).Elem()
}

func (i *basicSliResponsePtrType) ToBasicSliResponsePtrOutput() BasicSliResponsePtrOutput {
	return i.ToBasicSliResponsePtrOutputWithContext(context.Background())
}

func (i *basicSliResponsePtrType) ToBasicSliResponsePtrOutputWithContext(ctx context.Context) BasicSliResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicSliResponsePtrOutput)
}

// An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.
type BasicSliResponseOutput struct{ *pulumi.OutputState }

func (BasicSliResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicSliResponse)(nil)).Elem()
}

func (o BasicSliResponseOutput) ToBasicSliResponseOutput() BasicSliResponseOutput {
	return o
}

func (o BasicSliResponseOutput) ToBasicSliResponseOutputWithContext(ctx context.Context) BasicSliResponseOutput {
	return o
}

func (o BasicSliResponseOutput) ToBasicSliResponsePtrOutput() BasicSliResponsePtrOutput {
	return o.ToBasicSliResponsePtrOutputWithContext(context.Background())
}

func (o BasicSliResponseOutput) ToBasicSliResponsePtrOutputWithContext(ctx context.Context) BasicSliResponsePtrOutput {
	return o.ApplyT(func(v BasicSliResponse) *BasicSliResponse {
		return &v
	}).(BasicSliResponsePtrOutput)
}

// Good service is defined to be the count of requests made to this service that return successfully.
func (o BasicSliResponseOutput) Availability() AvailabilityCriteriaResponseOutput {
	return o.ApplyT(func(v BasicSliResponse) AvailabilityCriteriaResponse { return v.Availability }).(AvailabilityCriteriaResponseOutput)
}

// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
func (o BasicSliResponseOutput) Latency() LatencyCriteriaResponseOutput {
	return o.ApplyT(func(v BasicSliResponse) LatencyCriteriaResponse { return v.Latency }).(LatencyCriteriaResponseOutput)
}

// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
func (o BasicSliResponseOutput) Location() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSliResponse) []string { return v.Location }).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
func (o BasicSliResponseOutput) Method() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSliResponse) []string { return v.Method }).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
func (o BasicSliResponseOutput) Version() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSliResponse) []string { return v.Version }).(pulumi.StringArrayOutput)
}

type BasicSliResponsePtrOutput struct{ *pulumi.OutputState }

func (BasicSliResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicSliResponse)(nil)).Elem()
}

func (o BasicSliResponsePtrOutput) ToBasicSliResponsePtrOutput() BasicSliResponsePtrOutput {
	return o
}

func (o BasicSliResponsePtrOutput) ToBasicSliResponsePtrOutputWithContext(ctx context.Context) BasicSliResponsePtrOutput {
	return o
}

func (o BasicSliResponsePtrOutput) Elem() BasicSliResponseOutput {
	return o.ApplyT(func(v *BasicSliResponse) BasicSliResponse { return *v }).(BasicSliResponseOutput)
}

// Good service is defined to be the count of requests made to this service that return successfully.
func (o BasicSliResponsePtrOutput) Availability() AvailabilityCriteriaResponsePtrOutput {
	return o.ApplyT(func(v *BasicSliResponse) *AvailabilityCriteriaResponse {
		if v == nil {
			return nil
		}
		return &v.Availability
	}).(AvailabilityCriteriaResponsePtrOutput)
}

// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
func (o BasicSliResponsePtrOutput) Latency() LatencyCriteriaResponsePtrOutput {
	return o.ApplyT(func(v *BasicSliResponse) *LatencyCriteriaResponse {
		if v == nil {
			return nil
		}
		return &v.Latency
	}).(LatencyCriteriaResponsePtrOutput)
}

// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
func (o BasicSliResponsePtrOutput) Location() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *BasicSliResponse) []string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
func (o BasicSliResponsePtrOutput) Method() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *BasicSliResponse) []string {
		if v == nil {
			return nil
		}
		return v.Method
	}).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
func (o BasicSliResponsePtrOutput) Version() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *BasicSliResponse) []string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringArrayOutput)
}

// BucketOptions describes the bucket boundaries used to create a histogram for the distribution. The buckets can be in a linear sequence, an exponential sequence, or each bucket can be specified explicitly. BucketOptions does not include the number of values in each bucket.A bucket has an inclusive lower bound and exclusive upper bound for the values that are counted for that bucket. The upper bound of a bucket must be strictly greater than the lower bound. The sequence of N buckets for a distribution consists of an underflow bucket (number 0), zero or more finite buckets (number 1 through N - 2) and an overflow bucket (number N - 1). The buckets are contiguous: the lower bound of bucket i (i > 0) is the same as the upper bound of bucket i - 1. The buckets span the whole range of finite values: lower bound of the underflow bucket is -infinity and the upper bound of the overflow bucket is +infinity. The finite buckets are so-called because both bounds are finite.
type BucketOptions struct {
	// The explicit buckets.
	ExplicitBuckets *Explicit `pulumi:"explicitBuckets"`
	// The exponential buckets.
	ExponentialBuckets *Exponential `pulumi:"exponentialBuckets"`
	// The linear bucket.
	LinearBuckets *Linear `pulumi:"linearBuckets"`
}

// BucketOptionsInput is an input type that accepts BucketOptionsArgs and BucketOptionsOutput values.
// You can construct a concrete instance of `BucketOptionsInput` via:
//
//          BucketOptionsArgs{...}
type BucketOptionsInput interface {
	pulumi.Input

	ToBucketOptionsOutput() BucketOptionsOutput
	ToBucketOptionsOutputWithContext(context.Context) BucketOptionsOutput
}

// BucketOptions describes the bucket boundaries used to create a histogram for the distribution. The buckets can be in a linear sequence, an exponential sequence, or each bucket can be specified explicitly. BucketOptions does not include the number of values in each bucket.A bucket has an inclusive lower bound and exclusive upper bound for the values that are counted for that bucket. The upper bound of a bucket must be strictly greater than the lower bound. The sequence of N buckets for a distribution consists of an underflow bucket (number 0), zero or more finite buckets (number 1 through N - 2) and an overflow bucket (number N - 1). The buckets are contiguous: the lower bound of bucket i (i > 0) is the same as the upper bound of bucket i - 1. The buckets span the whole range of finite values: lower bound of the underflow bucket is -infinity and the upper bound of the overflow bucket is +infinity. The finite buckets are so-called because both bounds are finite.
type BucketOptionsArgs struct {
	// The explicit buckets.
	ExplicitBuckets ExplicitPtrInput `pulumi:"explicitBuckets"`
	// The exponential buckets.
	ExponentialBuckets ExponentialPtrInput `pulumi:"exponentialBuckets"`
	// The linear bucket.
	LinearBuckets LinearPtrInput `pulumi:"linearBuckets"`
}

func (BucketOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BucketOptions)(nil)).Elem()
}

func (i BucketOptionsArgs) ToBucketOptionsOutput() BucketOptionsOutput {
	return i.ToBucketOptionsOutputWithContext(context.Background())
}

func (i BucketOptionsArgs) ToBucketOptionsOutputWithContext(ctx context.Context) BucketOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BucketOptionsOutput)
}

func (i BucketOptionsArgs) ToBucketOptionsPtrOutput() BucketOptionsPtrOutput {
	return i.ToBucketOptionsPtrOutputWithContext(context.Background())
}

func (i BucketOptionsArgs) ToBucketOptionsPtrOutputWithContext(ctx context.Context) BucketOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BucketOptionsOutput).ToBucketOptionsPtrOutputWithContext(ctx)
}

// BucketOptionsPtrInput is an input type that accepts BucketOptionsArgs, BucketOptionsPtr and BucketOptionsPtrOutput values.
// You can construct a concrete instance of `BucketOptionsPtrInput` via:
//
//          BucketOptionsArgs{...}
//
//  or:
//
//          nil
type BucketOptionsPtrInput interface {
	pulumi.Input

	ToBucketOptionsPtrOutput() BucketOptionsPtrOutput
	ToBucketOptionsPtrOutputWithContext(context.Context) BucketOptionsPtrOutput
}

type bucketOptionsPtrType BucketOptionsArgs

func BucketOptionsPtr(v *BucketOptionsArgs) BucketOptionsPtrInput {
	return (*bucketOptionsPtrType)(v)
}

func (*bucketOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BucketOptions)(nil)).Elem()
}

func (i *bucketOptionsPtrType) ToBucketOptionsPtrOutput() BucketOptionsPtrOutput {
	return i.ToBucketOptionsPtrOutputWithContext(context.Background())
}

func (i *bucketOptionsPtrType) ToBucketOptionsPtrOutputWithContext(ctx context.Context) BucketOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BucketOptionsPtrOutput)
}

// BucketOptions describes the bucket boundaries used to create a histogram for the distribution. The buckets can be in a linear sequence, an exponential sequence, or each bucket can be specified explicitly. BucketOptions does not include the number of values in each bucket.A bucket has an inclusive lower bound and exclusive upper bound for the values that are counted for that bucket. The upper bound of a bucket must be strictly greater than the lower bound. The sequence of N buckets for a distribution consists of an underflow bucket (number 0), zero or more finite buckets (number 1 through N - 2) and an overflow bucket (number N - 1). The buckets are contiguous: the lower bound of bucket i (i > 0) is the same as the upper bound of bucket i - 1. The buckets span the whole range of finite values: lower bound of the underflow bucket is -infinity and the upper bound of the overflow bucket is +infinity. The finite buckets are so-called because both bounds are finite.
type BucketOptionsOutput struct{ *pulumi.OutputState }

func (BucketOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BucketOptions)(nil)).Elem()
}

func (o BucketOptionsOutput) ToBucketOptionsOutput() BucketOptionsOutput {
	return o
}

func (o BucketOptionsOutput) ToBucketOptionsOutputWithContext(ctx context.Context) BucketOptionsOutput {
	return o
}

func (o BucketOptionsOutput) ToBucketOptionsPtrOutput() BucketOptionsPtrOutput {
	return o.ToBucketOptionsPtrOutputWithContext(context.Background())
}

func (o BucketOptionsOutput) ToBucketOptionsPtrOutputWithContext(ctx context.Context) BucketOptionsPtrOutput {
	return o.ApplyT(func(v BucketOptions) *BucketOptions {
		return &v
	}).(BucketOptionsPtrOutput)
}

// The explicit buckets.
func (o BucketOptionsOutput) ExplicitBuckets() ExplicitPtrOutput {
	return o.ApplyT(func(v BucketOptions) *Explicit { return v.ExplicitBuckets }).(ExplicitPtrOutput)
}

// The exponential buckets.
func (o BucketOptionsOutput) ExponentialBuckets() ExponentialPtrOutput {
	return o.ApplyT(func(v BucketOptions) *Exponential { return v.ExponentialBuckets }).(ExponentialPtrOutput)
}

// The linear bucket.
func (o BucketOptionsOutput) LinearBuckets() LinearPtrOutput {
	return o.ApplyT(func(v BucketOptions) *Linear { return v.LinearBuckets }).(LinearPtrOutput)
}

type BucketOptionsPtrOutput struct{ *pulumi.OutputState }

func (BucketOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BucketOptions)(nil)).Elem()
}

func (o BucketOptionsPtrOutput) ToBucketOptionsPtrOutput() BucketOptionsPtrOutput {
	return o
}

func (o BucketOptionsPtrOutput) ToBucketOptionsPtrOutputWithContext(ctx context.Context) BucketOptionsPtrOutput {
	return o
}

func (o BucketOptionsPtrOutput) Elem() BucketOptionsOutput {
	return o.ApplyT(func(v *BucketOptions) BucketOptions { return *v }).(BucketOptionsOutput)
}

// The explicit buckets.
func (o BucketOptionsPtrOutput) ExplicitBuckets() ExplicitPtrOutput {
	return o.ApplyT(func(v *BucketOptions) *Explicit {
		if v == nil {
			return nil
		}
		return v.ExplicitBuckets
	}).(ExplicitPtrOutput)
}

// The exponential buckets.
func (o BucketOptionsPtrOutput) ExponentialBuckets() ExponentialPtrOutput {
	return o.ApplyT(func(v *BucketOptions) *Exponential {
		if v == nil {
			return nil
		}
		return v.ExponentialBuckets
	}).(ExponentialPtrOutput)
}

// The linear bucket.
func (o BucketOptionsPtrOutput) LinearBuckets() LinearPtrOutput {
	return o.ApplyT(func(v *BucketOptions) *Linear {
		if v == nil {
			return nil
		}
		return v.LinearBuckets
	}).(LinearPtrOutput)
}

// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
type CloudEndpoints struct {
	// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource: https://cloud.google.com/monitoring/api/resources#tag_api
	Service *string `pulumi:"service"`
}

// CloudEndpointsInput is an input type that accepts CloudEndpointsArgs and CloudEndpointsOutput values.
// You can construct a concrete instance of `CloudEndpointsInput` via:
//
//          CloudEndpointsArgs{...}
type CloudEndpointsInput interface {
	pulumi.Input

	ToCloudEndpointsOutput() CloudEndpointsOutput
	ToCloudEndpointsOutputWithContext(context.Context) CloudEndpointsOutput
}

// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
type CloudEndpointsArgs struct {
	// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource: https://cloud.google.com/monitoring/api/resources#tag_api
	Service pulumi.StringPtrInput `pulumi:"service"`
}

func (CloudEndpointsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudEndpoints)(nil)).Elem()
}

func (i CloudEndpointsArgs) ToCloudEndpointsOutput() CloudEndpointsOutput {
	return i.ToCloudEndpointsOutputWithContext(context.Background())
}

func (i CloudEndpointsArgs) ToCloudEndpointsOutputWithContext(ctx context.Context) CloudEndpointsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudEndpointsOutput)
}

func (i CloudEndpointsArgs) ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput {
	return i.ToCloudEndpointsPtrOutputWithContext(context.Background())
}

func (i CloudEndpointsArgs) ToCloudEndpointsPtrOutputWithContext(ctx context.Context) CloudEndpointsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudEndpointsOutput).ToCloudEndpointsPtrOutputWithContext(ctx)
}

// CloudEndpointsPtrInput is an input type that accepts CloudEndpointsArgs, CloudEndpointsPtr and CloudEndpointsPtrOutput values.
// You can construct a concrete instance of `CloudEndpointsPtrInput` via:
//
//          CloudEndpointsArgs{...}
//
//  or:
//
//          nil
type CloudEndpointsPtrInput interface {
	pulumi.Input

	ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput
	ToCloudEndpointsPtrOutputWithContext(context.Context) CloudEndpointsPtrOutput
}

type cloudEndpointsPtrType CloudEndpointsArgs

func CloudEndpointsPtr(v *CloudEndpointsArgs) CloudEndpointsPtrInput {
	return (*cloudEndpointsPtrType)(v)
}

func (*cloudEndpointsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudEndpoints)(nil)).Elem()
}

func (i *cloudEndpointsPtrType) ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput {
	return i.ToCloudEndpointsPtrOutputWithContext(context.Background())
}

func (i *cloudEndpointsPtrType) ToCloudEndpointsPtrOutputWithContext(ctx context.Context) CloudEndpointsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudEndpointsPtrOutput)
}

// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
type CloudEndpointsOutput struct{ *pulumi.OutputState }

func (CloudEndpointsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudEndpoints)(nil)).Elem()
}

func (o CloudEndpointsOutput) ToCloudEndpointsOutput() CloudEndpointsOutput {
	return o
}

func (o CloudEndpointsOutput) ToCloudEndpointsOutputWithContext(ctx context.Context) CloudEndpointsOutput {
	return o
}

func (o CloudEndpointsOutput) ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput {
	return o.ToCloudEndpointsPtrOutputWithContext(context.Background())
}

func (o CloudEndpointsOutput) ToCloudEndpointsPtrOutputWithContext(ctx context.Context) CloudEndpointsPtrOutput {
	return o.ApplyT(func(v CloudEndpoints) *CloudEndpoints {
		return &v
	}).(CloudEndpointsPtrOutput)
}

// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource: https://cloud.google.com/monitoring/api/resources#tag_api
func (o CloudEndpointsOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CloudEndpoints) *string { return v.Service }).(pulumi.StringPtrOutput)
}

type CloudEndpointsPtrOutput struct{ *pulumi.OutputState }

func (CloudEndpointsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudEndpoints)(nil)).Elem()
}

func (o CloudEndpointsPtrOutput) ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput {
	return o
}

func (o CloudEndpointsPtrOutput) ToCloudEndpointsPtrOutputWithContext(ctx context.Context) CloudEndpointsPtrOutput {
	return o
}

func (o CloudEndpointsPtrOutput) Elem() CloudEndpointsOutput {
	return o.ApplyT(func(v *CloudEndpoints) CloudEndpoints { return *v }).(CloudEndpointsOutput)
}

// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource: https://cloud.google.com/monitoring/api/resources#tag_api
func (o CloudEndpointsPtrOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CloudEndpoints) *string {
		if v == nil {
			return nil
		}
		return v.Service
	}).(pulumi.StringPtrOutput)
}

// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
type CloudEndpointsResponse struct {
	// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource: https://cloud.google.com/monitoring/api/resources#tag_api
	Service string `pulumi:"service"`
}

// CloudEndpointsResponseInput is an input type that accepts CloudEndpointsResponseArgs and CloudEndpointsResponseOutput values.
// You can construct a concrete instance of `CloudEndpointsResponseInput` via:
//
//          CloudEndpointsResponseArgs{...}
type CloudEndpointsResponseInput interface {
	pulumi.Input

	ToCloudEndpointsResponseOutput() CloudEndpointsResponseOutput
	ToCloudEndpointsResponseOutputWithContext(context.Context) CloudEndpointsResponseOutput
}

// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
type CloudEndpointsResponseArgs struct {
	// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource: https://cloud.google.com/monitoring/api/resources#tag_api
	Service pulumi.StringInput `pulumi:"service"`
}

func (CloudEndpointsResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudEndpointsResponse)(nil)).Elem()
}

func (i CloudEndpointsResponseArgs) ToCloudEndpointsResponseOutput() CloudEndpointsResponseOutput {
	return i.ToCloudEndpointsResponseOutputWithContext(context.Background())
}

func (i CloudEndpointsResponseArgs) ToCloudEndpointsResponseOutputWithContext(ctx context.Context) CloudEndpointsResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudEndpointsResponseOutput)
}

func (i CloudEndpointsResponseArgs) ToCloudEndpointsResponsePtrOutput() CloudEndpointsResponsePtrOutput {
	return i.ToCloudEndpointsResponsePtrOutputWithContext(context.Background())
}

func (i CloudEndpointsResponseArgs) ToCloudEndpointsResponsePtrOutputWithContext(ctx context.Context) CloudEndpointsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudEndpointsResponseOutput).ToCloudEndpointsResponsePtrOutputWithContext(ctx)
}

// CloudEndpointsResponsePtrInput is an input type that accepts CloudEndpointsResponseArgs, CloudEndpointsResponsePtr and CloudEndpointsResponsePtrOutput values.
// You can construct a concrete instance of `CloudEndpointsResponsePtrInput` via:
//
//          CloudEndpointsResponseArgs{...}
//
//  or:
//
//          nil
type CloudEndpointsResponsePtrInput interface {
	pulumi.Input

	ToCloudEndpointsResponsePtrOutput() CloudEndpointsResponsePtrOutput
	ToCloudEndpointsResponsePtrOutputWithContext(context.Context) CloudEndpointsResponsePtrOutput
}

type cloudEndpointsResponsePtrType CloudEndpointsResponseArgs

func CloudEndpointsResponsePtr(v *CloudEndpointsResponseArgs) CloudEndpointsResponsePtrInput {
	return (*cloudEndpointsResponsePtrType)(v)
}

func (*cloudEndpointsResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudEndpointsResponse)(nil)).Elem()
}

func (i *cloudEndpointsResponsePtrType) ToCloudEndpointsResponsePtrOutput() CloudEndpointsResponsePtrOutput {
	return i.ToCloudEndpointsResponsePtrOutputWithContext(context.Background())
}

func (i *cloudEndpointsResponsePtrType) ToCloudEndpointsResponsePtrOutputWithContext(ctx context.Context) CloudEndpointsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudEndpointsResponsePtrOutput)
}

// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
type CloudEndpointsResponseOutput struct{ *pulumi.OutputState }

func (CloudEndpointsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudEndpointsResponse)(nil)).Elem()
}

func (o CloudEndpointsResponseOutput) ToCloudEndpointsResponseOutput() CloudEndpointsResponseOutput {
	return o
}

func (o CloudEndpointsResponseOutput) ToCloudEndpointsResponseOutputWithContext(ctx context.Context) CloudEndpointsResponseOutput {
	return o
}

func (o CloudEndpointsResponseOutput) ToCloudEndpointsResponsePtrOutput() CloudEndpointsResponsePtrOutput {
	return o.ToCloudEndpointsResponsePtrOutputWithContext(context.Background())
}

func (o CloudEndpointsResponseOutput) ToCloudEndpointsResponsePtrOutputWithContext(ctx context.Context) CloudEndpointsResponsePtrOutput {
	return o.ApplyT(func(v CloudEndpointsResponse) *CloudEndpointsResponse {
		return &v
	}).(CloudEndpointsResponsePtrOutput)
}

// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource: https://cloud.google.com/monitoring/api/resources#tag_api
func (o CloudEndpointsResponseOutput) Service() pulumi.StringOutput {
	return o.ApplyT(func(v CloudEndpointsResponse) string { return v.Service }).(pulumi.StringOutput)
}

type CloudEndpointsResponsePtrOutput struct{ *pulumi.OutputState }

func (CloudEndpointsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudEndpointsResponse)(nil)).Elem()
}

func (o CloudEndpointsResponsePtrOutput) ToCloudEndpointsResponsePtrOutput() CloudEndpointsResponsePtrOutput {
	return o
}

func (o CloudEndpointsResponsePtrOutput) ToCloudEndpointsResponsePtrOutputWithContext(ctx context.Context) CloudEndpointsResponsePtrOutput {
	return o
}

func (o CloudEndpointsResponsePtrOutput) Elem() CloudEndpointsResponseOutput {
	return o.ApplyT(func(v *CloudEndpointsResponse) CloudEndpointsResponse { return *v }).(CloudEndpointsResponseOutput)
}

// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource: https://cloud.google.com/monitoring/api/resources#tag_api
func (o CloudEndpointsResponsePtrOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CloudEndpointsResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Service
	}).(pulumi.StringPtrOutput)
}

// Istio service scoped to a single Kubernetes cluster. Learn more at https://istio.io. Clusters running OSS Istio will have their services ingested as this type.
type ClusterIstio struct {
	// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
	ClusterName *string `pulumi:"clusterName"`
	// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
	Location *string `pulumi:"location"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName *string `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace *string `pulumi:"serviceNamespace"`
}

// ClusterIstioInput is an input type that accepts ClusterIstioArgs and ClusterIstioOutput values.
// You can construct a concrete instance of `ClusterIstioInput` via:
//
//          ClusterIstioArgs{...}
type ClusterIstioInput interface {
	pulumi.Input

	ToClusterIstioOutput() ClusterIstioOutput
	ToClusterIstioOutputWithContext(context.Context) ClusterIstioOutput
}

// Istio service scoped to a single Kubernetes cluster. Learn more at https://istio.io. Clusters running OSS Istio will have their services ingested as this type.
type ClusterIstioArgs struct {
	// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
	ClusterName pulumi.StringPtrInput `pulumi:"clusterName"`
	// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace pulumi.StringPtrInput `pulumi:"serviceNamespace"`
}

func (ClusterIstioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterIstio)(nil)).Elem()
}

func (i ClusterIstioArgs) ToClusterIstioOutput() ClusterIstioOutput {
	return i.ToClusterIstioOutputWithContext(context.Background())
}

func (i ClusterIstioArgs) ToClusterIstioOutputWithContext(ctx context.Context) ClusterIstioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterIstioOutput)
}

func (i ClusterIstioArgs) ToClusterIstioPtrOutput() ClusterIstioPtrOutput {
	return i.ToClusterIstioPtrOutputWithContext(context.Background())
}

func (i ClusterIstioArgs) ToClusterIstioPtrOutputWithContext(ctx context.Context) ClusterIstioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterIstioOutput).ToClusterIstioPtrOutputWithContext(ctx)
}

// ClusterIstioPtrInput is an input type that accepts ClusterIstioArgs, ClusterIstioPtr and ClusterIstioPtrOutput values.
// You can construct a concrete instance of `ClusterIstioPtrInput` via:
//
//          ClusterIstioArgs{...}
//
//  or:
//
//          nil
type ClusterIstioPtrInput interface {
	pulumi.Input

	ToClusterIstioPtrOutput() ClusterIstioPtrOutput
	ToClusterIstioPtrOutputWithContext(context.Context) ClusterIstioPtrOutput
}

type clusterIstioPtrType ClusterIstioArgs

func ClusterIstioPtr(v *ClusterIstioArgs) ClusterIstioPtrInput {
	return (*clusterIstioPtrType)(v)
}

func (*clusterIstioPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterIstio)(nil)).Elem()
}

func (i *clusterIstioPtrType) ToClusterIstioPtrOutput() ClusterIstioPtrOutput {
	return i.ToClusterIstioPtrOutputWithContext(context.Background())
}

func (i *clusterIstioPtrType) ToClusterIstioPtrOutputWithContext(ctx context.Context) ClusterIstioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterIstioPtrOutput)
}

// Istio service scoped to a single Kubernetes cluster. Learn more at https://istio.io. Clusters running OSS Istio will have their services ingested as this type.
type ClusterIstioOutput struct{ *pulumi.OutputState }

func (ClusterIstioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterIstio)(nil)).Elem()
}

func (o ClusterIstioOutput) ToClusterIstioOutput() ClusterIstioOutput {
	return o
}

func (o ClusterIstioOutput) ToClusterIstioOutputWithContext(ctx context.Context) ClusterIstioOutput {
	return o
}

func (o ClusterIstioOutput) ToClusterIstioPtrOutput() ClusterIstioPtrOutput {
	return o.ToClusterIstioPtrOutputWithContext(context.Background())
}

func (o ClusterIstioOutput) ToClusterIstioPtrOutputWithContext(ctx context.Context) ClusterIstioPtrOutput {
	return o.ApplyT(func(v ClusterIstio) *ClusterIstio {
		return &v
	}).(ClusterIstioPtrOutput)
}

// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
func (o ClusterIstioOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterIstio) *string { return v.ClusterName }).(pulumi.StringPtrOutput)
}

// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
func (o ClusterIstioOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterIstio) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o ClusterIstioOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterIstio) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o ClusterIstioOutput) ServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterIstio) *string { return v.ServiceNamespace }).(pulumi.StringPtrOutput)
}

type ClusterIstioPtrOutput struct{ *pulumi.OutputState }

func (ClusterIstioPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterIstio)(nil)).Elem()
}

func (o ClusterIstioPtrOutput) ToClusterIstioPtrOutput() ClusterIstioPtrOutput {
	return o
}

func (o ClusterIstioPtrOutput) ToClusterIstioPtrOutputWithContext(ctx context.Context) ClusterIstioPtrOutput {
	return o
}

func (o ClusterIstioPtrOutput) Elem() ClusterIstioOutput {
	return o.ApplyT(func(v *ClusterIstio) ClusterIstio { return *v }).(ClusterIstioOutput)
}

// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
func (o ClusterIstioPtrOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstio) *string {
		if v == nil {
			return nil
		}
		return v.ClusterName
	}).(pulumi.StringPtrOutput)
}

// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
func (o ClusterIstioPtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstio) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o ClusterIstioPtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstio) *string {
		if v == nil {
			return nil
		}
		return v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o ClusterIstioPtrOutput) ServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstio) *string {
		if v == nil {
			return nil
		}
		return v.ServiceNamespace
	}).(pulumi.StringPtrOutput)
}

// Istio service scoped to a single Kubernetes cluster. Learn more at https://istio.io. Clusters running OSS Istio will have their services ingested as this type.
type ClusterIstioResponse struct {
	// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
	ClusterName string `pulumi:"clusterName"`
	// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
	Location string `pulumi:"location"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName string `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace string `pulumi:"serviceNamespace"`
}

// ClusterIstioResponseInput is an input type that accepts ClusterIstioResponseArgs and ClusterIstioResponseOutput values.
// You can construct a concrete instance of `ClusterIstioResponseInput` via:
//
//          ClusterIstioResponseArgs{...}
type ClusterIstioResponseInput interface {
	pulumi.Input

	ToClusterIstioResponseOutput() ClusterIstioResponseOutput
	ToClusterIstioResponseOutputWithContext(context.Context) ClusterIstioResponseOutput
}

// Istio service scoped to a single Kubernetes cluster. Learn more at https://istio.io. Clusters running OSS Istio will have their services ingested as this type.
type ClusterIstioResponseArgs struct {
	// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
	ClusterName pulumi.StringInput `pulumi:"clusterName"`
	// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
	Location pulumi.StringInput `pulumi:"location"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName pulumi.StringInput `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace pulumi.StringInput `pulumi:"serviceNamespace"`
}

func (ClusterIstioResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterIstioResponse)(nil)).Elem()
}

func (i ClusterIstioResponseArgs) ToClusterIstioResponseOutput() ClusterIstioResponseOutput {
	return i.ToClusterIstioResponseOutputWithContext(context.Background())
}

func (i ClusterIstioResponseArgs) ToClusterIstioResponseOutputWithContext(ctx context.Context) ClusterIstioResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterIstioResponseOutput)
}

func (i ClusterIstioResponseArgs) ToClusterIstioResponsePtrOutput() ClusterIstioResponsePtrOutput {
	return i.ToClusterIstioResponsePtrOutputWithContext(context.Background())
}

func (i ClusterIstioResponseArgs) ToClusterIstioResponsePtrOutputWithContext(ctx context.Context) ClusterIstioResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterIstioResponseOutput).ToClusterIstioResponsePtrOutputWithContext(ctx)
}

// ClusterIstioResponsePtrInput is an input type that accepts ClusterIstioResponseArgs, ClusterIstioResponsePtr and ClusterIstioResponsePtrOutput values.
// You can construct a concrete instance of `ClusterIstioResponsePtrInput` via:
//
//          ClusterIstioResponseArgs{...}
//
//  or:
//
//          nil
type ClusterIstioResponsePtrInput interface {
	pulumi.Input

	ToClusterIstioResponsePtrOutput() ClusterIstioResponsePtrOutput
	ToClusterIstioResponsePtrOutputWithContext(context.Context) ClusterIstioResponsePtrOutput
}

type clusterIstioResponsePtrType ClusterIstioResponseArgs

func ClusterIstioResponsePtr(v *ClusterIstioResponseArgs) ClusterIstioResponsePtrInput {
	return (*clusterIstioResponsePtrType)(v)
}

func (*clusterIstioResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterIstioResponse)(nil)).Elem()
}

func (i *clusterIstioResponsePtrType) ToClusterIstioResponsePtrOutput() ClusterIstioResponsePtrOutput {
	return i.ToClusterIstioResponsePtrOutputWithContext(context.Background())
}

func (i *clusterIstioResponsePtrType) ToClusterIstioResponsePtrOutputWithContext(ctx context.Context) ClusterIstioResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterIstioResponsePtrOutput)
}

// Istio service scoped to a single Kubernetes cluster. Learn more at https://istio.io. Clusters running OSS Istio will have their services ingested as this type.
type ClusterIstioResponseOutput struct{ *pulumi.OutputState }

func (ClusterIstioResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterIstioResponse)(nil)).Elem()
}

func (o ClusterIstioResponseOutput) ToClusterIstioResponseOutput() ClusterIstioResponseOutput {
	return o
}

func (o ClusterIstioResponseOutput) ToClusterIstioResponseOutputWithContext(ctx context.Context) ClusterIstioResponseOutput {
	return o
}

func (o ClusterIstioResponseOutput) ToClusterIstioResponsePtrOutput() ClusterIstioResponsePtrOutput {
	return o.ToClusterIstioResponsePtrOutputWithContext(context.Background())
}

func (o ClusterIstioResponseOutput) ToClusterIstioResponsePtrOutputWithContext(ctx context.Context) ClusterIstioResponsePtrOutput {
	return o.ApplyT(func(v ClusterIstioResponse) *ClusterIstioResponse {
		return &v
	}).(ClusterIstioResponsePtrOutput)
}

// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
func (o ClusterIstioResponseOutput) ClusterName() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterIstioResponse) string { return v.ClusterName }).(pulumi.StringOutput)
}

// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
func (o ClusterIstioResponseOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterIstioResponse) string { return v.Location }).(pulumi.StringOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o ClusterIstioResponseOutput) ServiceName() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterIstioResponse) string { return v.ServiceName }).(pulumi.StringOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o ClusterIstioResponseOutput) ServiceNamespace() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterIstioResponse) string { return v.ServiceNamespace }).(pulumi.StringOutput)
}

type ClusterIstioResponsePtrOutput struct{ *pulumi.OutputState }

func (ClusterIstioResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterIstioResponse)(nil)).Elem()
}

func (o ClusterIstioResponsePtrOutput) ToClusterIstioResponsePtrOutput() ClusterIstioResponsePtrOutput {
	return o
}

func (o ClusterIstioResponsePtrOutput) ToClusterIstioResponsePtrOutputWithContext(ctx context.Context) ClusterIstioResponsePtrOutput {
	return o
}

func (o ClusterIstioResponsePtrOutput) Elem() ClusterIstioResponseOutput {
	return o.ApplyT(func(v *ClusterIstioResponse) ClusterIstioResponse { return *v }).(ClusterIstioResponseOutput)
}

// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
func (o ClusterIstioResponsePtrOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstioResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ClusterName
	}).(pulumi.StringPtrOutput)
}

// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
func (o ClusterIstioResponsePtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstioResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Location
	}).(pulumi.StringPtrOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o ClusterIstioResponsePtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstioResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o ClusterIstioResponsePtrOutput) ServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstioResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ServiceNamespace
	}).(pulumi.StringPtrOutput)
}

// A collection of data points sent from a collectd-based plugin. See the collectd documentation for more information.
type CollectdPayload struct {
	// The end time of the interval.
	EndTime *string `pulumi:"endTime"`
	// The measurement metadata. Example: "process_id" -> 12345
	Metadata map[string]string `pulumi:"metadata"`
	// The name of the plugin. Example: "disk".
	Plugin *string `pulumi:"plugin"`
	// The instance name of the plugin Example: "hdcl".
	PluginInstance *string `pulumi:"pluginInstance"`
	// The start time of the interval.
	StartTime *string `pulumi:"startTime"`
	// The measurement type. Example: "memory".
	Type *string `pulumi:"type"`
	// The measurement type instance. Example: "used".
	TypeInstance *string `pulumi:"typeInstance"`
	// The measured values during this time interval. Each value must have a different data_source_name.
	Values []CollectdValue `pulumi:"values"`
}

// CollectdPayloadInput is an input type that accepts CollectdPayloadArgs and CollectdPayloadOutput values.
// You can construct a concrete instance of `CollectdPayloadInput` via:
//
//          CollectdPayloadArgs{...}
type CollectdPayloadInput interface {
	pulumi.Input

	ToCollectdPayloadOutput() CollectdPayloadOutput
	ToCollectdPayloadOutputWithContext(context.Context) CollectdPayloadOutput
}

// A collection of data points sent from a collectd-based plugin. See the collectd documentation for more information.
type CollectdPayloadArgs struct {
	// The end time of the interval.
	EndTime pulumi.StringPtrInput `pulumi:"endTime"`
	// The measurement metadata. Example: "process_id" -> 12345
	Metadata pulumi.StringMapInput `pulumi:"metadata"`
	// The name of the plugin. Example: "disk".
	Plugin pulumi.StringPtrInput `pulumi:"plugin"`
	// The instance name of the plugin Example: "hdcl".
	PluginInstance pulumi.StringPtrInput `pulumi:"pluginInstance"`
	// The start time of the interval.
	StartTime pulumi.StringPtrInput `pulumi:"startTime"`
	// The measurement type. Example: "memory".
	Type pulumi.StringPtrInput `pulumi:"type"`
	// The measurement type instance. Example: "used".
	TypeInstance pulumi.StringPtrInput `pulumi:"typeInstance"`
	// The measured values during this time interval. Each value must have a different data_source_name.
	Values CollectdValueArrayInput `pulumi:"values"`
}

func (CollectdPayloadArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CollectdPayload)(nil)).Elem()
}

func (i CollectdPayloadArgs) ToCollectdPayloadOutput() CollectdPayloadOutput {
	return i.ToCollectdPayloadOutputWithContext(context.Background())
}

func (i CollectdPayloadArgs) ToCollectdPayloadOutputWithContext(ctx context.Context) CollectdPayloadOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollectdPayloadOutput)
}

// CollectdPayloadArrayInput is an input type that accepts CollectdPayloadArray and CollectdPayloadArrayOutput values.
// You can construct a concrete instance of `CollectdPayloadArrayInput` via:
//
//          CollectdPayloadArray{ CollectdPayloadArgs{...} }
type CollectdPayloadArrayInput interface {
	pulumi.Input

	ToCollectdPayloadArrayOutput() CollectdPayloadArrayOutput
	ToCollectdPayloadArrayOutputWithContext(context.Context) CollectdPayloadArrayOutput
}

type CollectdPayloadArray []CollectdPayloadInput

func (CollectdPayloadArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CollectdPayload)(nil)).Elem()
}

func (i CollectdPayloadArray) ToCollectdPayloadArrayOutput() CollectdPayloadArrayOutput {
	return i.ToCollectdPayloadArrayOutputWithContext(context.Background())
}

func (i CollectdPayloadArray) ToCollectdPayloadArrayOutputWithContext(ctx context.Context) CollectdPayloadArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollectdPayloadArrayOutput)
}

// A collection of data points sent from a collectd-based plugin. See the collectd documentation for more information.
type CollectdPayloadOutput struct{ *pulumi.OutputState }

func (CollectdPayloadOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CollectdPayload)(nil)).Elem()
}

func (o CollectdPayloadOutput) ToCollectdPayloadOutput() CollectdPayloadOutput {
	return o
}

func (o CollectdPayloadOutput) ToCollectdPayloadOutputWithContext(ctx context.Context) CollectdPayloadOutput {
	return o
}

// The end time of the interval.
func (o CollectdPayloadOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdPayload) *string { return v.EndTime }).(pulumi.StringPtrOutput)
}

// The measurement metadata. Example: "process_id" -> 12345
func (o CollectdPayloadOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v CollectdPayload) map[string]string { return v.Metadata }).(pulumi.StringMapOutput)
}

// The name of the plugin. Example: "disk".
func (o CollectdPayloadOutput) Plugin() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdPayload) *string { return v.Plugin }).(pulumi.StringPtrOutput)
}

// The instance name of the plugin Example: "hdcl".
func (o CollectdPayloadOutput) PluginInstance() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdPayload) *string { return v.PluginInstance }).(pulumi.StringPtrOutput)
}

// The start time of the interval.
func (o CollectdPayloadOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdPayload) *string { return v.StartTime }).(pulumi.StringPtrOutput)
}

// The measurement type. Example: "memory".
func (o CollectdPayloadOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdPayload) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// The measurement type instance. Example: "used".
func (o CollectdPayloadOutput) TypeInstance() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdPayload) *string { return v.TypeInstance }).(pulumi.StringPtrOutput)
}

// The measured values during this time interval. Each value must have a different data_source_name.
func (o CollectdPayloadOutput) Values() CollectdValueArrayOutput {
	return o.ApplyT(func(v CollectdPayload) []CollectdValue { return v.Values }).(CollectdValueArrayOutput)
}

type CollectdPayloadArrayOutput struct{ *pulumi.OutputState }

func (CollectdPayloadArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CollectdPayload)(nil)).Elem()
}

func (o CollectdPayloadArrayOutput) ToCollectdPayloadArrayOutput() CollectdPayloadArrayOutput {
	return o
}

func (o CollectdPayloadArrayOutput) ToCollectdPayloadArrayOutputWithContext(ctx context.Context) CollectdPayloadArrayOutput {
	return o
}

func (o CollectdPayloadArrayOutput) Index(i pulumi.IntInput) CollectdPayloadOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CollectdPayload {
		return vs[0].([]CollectdPayload)[vs[1].(int)]
	}).(CollectdPayloadOutput)
}

// A single data point from a collectd-based plugin.
type CollectdValue struct {
	// The data source for the collectd value. For example, there are two data sources for network measurements: "rx" and "tx".
	DataSourceName *string `pulumi:"dataSourceName"`
	// The type of measurement.
	DataSourceType *string `pulumi:"dataSourceType"`
	// The measurement value.
	Value *TypedValue `pulumi:"value"`
}

// CollectdValueInput is an input type that accepts CollectdValueArgs and CollectdValueOutput values.
// You can construct a concrete instance of `CollectdValueInput` via:
//
//          CollectdValueArgs{...}
type CollectdValueInput interface {
	pulumi.Input

	ToCollectdValueOutput() CollectdValueOutput
	ToCollectdValueOutputWithContext(context.Context) CollectdValueOutput
}

// A single data point from a collectd-based plugin.
type CollectdValueArgs struct {
	// The data source for the collectd value. For example, there are two data sources for network measurements: "rx" and "tx".
	DataSourceName pulumi.StringPtrInput `pulumi:"dataSourceName"`
	// The type of measurement.
	DataSourceType pulumi.StringPtrInput `pulumi:"dataSourceType"`
	// The measurement value.
	Value TypedValuePtrInput `pulumi:"value"`
}

func (CollectdValueArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CollectdValue)(nil)).Elem()
}

func (i CollectdValueArgs) ToCollectdValueOutput() CollectdValueOutput {
	return i.ToCollectdValueOutputWithContext(context.Background())
}

func (i CollectdValueArgs) ToCollectdValueOutputWithContext(ctx context.Context) CollectdValueOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollectdValueOutput)
}

// CollectdValueArrayInput is an input type that accepts CollectdValueArray and CollectdValueArrayOutput values.
// You can construct a concrete instance of `CollectdValueArrayInput` via:
//
//          CollectdValueArray{ CollectdValueArgs{...} }
type CollectdValueArrayInput interface {
	pulumi.Input

	ToCollectdValueArrayOutput() CollectdValueArrayOutput
	ToCollectdValueArrayOutputWithContext(context.Context) CollectdValueArrayOutput
}

type CollectdValueArray []CollectdValueInput

func (CollectdValueArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CollectdValue)(nil)).Elem()
}

func (i CollectdValueArray) ToCollectdValueArrayOutput() CollectdValueArrayOutput {
	return i.ToCollectdValueArrayOutputWithContext(context.Background())
}

func (i CollectdValueArray) ToCollectdValueArrayOutputWithContext(ctx context.Context) CollectdValueArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollectdValueArrayOutput)
}

// A single data point from a collectd-based plugin.
type CollectdValueOutput struct{ *pulumi.OutputState }

func (CollectdValueOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CollectdValue)(nil)).Elem()
}

func (o CollectdValueOutput) ToCollectdValueOutput() CollectdValueOutput {
	return o
}

func (o CollectdValueOutput) ToCollectdValueOutputWithContext(ctx context.Context) CollectdValueOutput {
	return o
}

// The data source for the collectd value. For example, there are two data sources for network measurements: "rx" and "tx".
func (o CollectdValueOutput) DataSourceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdValue) *string { return v.DataSourceName }).(pulumi.StringPtrOutput)
}

// The type of measurement.
func (o CollectdValueOutput) DataSourceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdValue) *string { return v.DataSourceType }).(pulumi.StringPtrOutput)
}

// The measurement value.
func (o CollectdValueOutput) Value() TypedValuePtrOutput {
	return o.ApplyT(func(v CollectdValue) *TypedValue { return v.Value }).(TypedValuePtrOutput)
}

type CollectdValueArrayOutput struct{ *pulumi.OutputState }

func (CollectdValueArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CollectdValue)(nil)).Elem()
}

func (o CollectdValueArrayOutput) ToCollectdValueArrayOutput() CollectdValueArrayOutput {
	return o
}

func (o CollectdValueArrayOutput) ToCollectdValueArrayOutputWithContext(ctx context.Context) CollectdValueArrayOutput {
	return o
}

func (o CollectdValueArrayOutput) Index(i pulumi.IntInput) CollectdValueOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CollectdValue {
		return vs[0].([]CollectdValue)[vs[1].(int)]
	}).(CollectdValueOutput)
}

// A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
type Condition struct {
	// A condition that checks that a time series continues to receive new data points.
	ConditionAbsent *MetricAbsence `pulumi:"conditionAbsent"`
	// A condition that uses the Monitoring Query Language to define alerts.
	ConditionMonitoringQueryLanguage *MonitoringQueryLanguageCondition `pulumi:"conditionMonitoringQueryLanguage"`
	// A condition that compares a time series against a threshold.
	ConditionThreshold *MetricThreshold `pulumi:"conditionThreshold"`
	// A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
	DisplayName *string `pulumi:"displayName"`
	// Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Stackdriver Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Stackdriver Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
	Name *string `pulumi:"name"`
}

// ConditionInput is an input type that accepts ConditionArgs and ConditionOutput values.
// You can construct a concrete instance of `ConditionInput` via:
//
//          ConditionArgs{...}
type ConditionInput interface {
	pulumi.Input

	ToConditionOutput() ConditionOutput
	ToConditionOutputWithContext(context.Context) ConditionOutput
}

// A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
type ConditionArgs struct {
	// A condition that checks that a time series continues to receive new data points.
	ConditionAbsent MetricAbsencePtrInput `pulumi:"conditionAbsent"`
	// A condition that uses the Monitoring Query Language to define alerts.
	ConditionMonitoringQueryLanguage MonitoringQueryLanguageConditionPtrInput `pulumi:"conditionMonitoringQueryLanguage"`
	// A condition that compares a time series against a threshold.
	ConditionThreshold MetricThresholdPtrInput `pulumi:"conditionThreshold"`
	// A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Stackdriver Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Stackdriver Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Condition)(nil)).Elem()
}

func (i ConditionArgs) ToConditionOutput() ConditionOutput {
	return i.ToConditionOutputWithContext(context.Background())
}

func (i ConditionArgs) ToConditionOutputWithContext(ctx context.Context) ConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionOutput)
}

// ConditionArrayInput is an input type that accepts ConditionArray and ConditionArrayOutput values.
// You can construct a concrete instance of `ConditionArrayInput` via:
//
//          ConditionArray{ ConditionArgs{...} }
type ConditionArrayInput interface {
	pulumi.Input

	ToConditionArrayOutput() ConditionArrayOutput
	ToConditionArrayOutputWithContext(context.Context) ConditionArrayOutput
}

type ConditionArray []ConditionInput

func (ConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Condition)(nil)).Elem()
}

func (i ConditionArray) ToConditionArrayOutput() ConditionArrayOutput {
	return i.ToConditionArrayOutputWithContext(context.Background())
}

func (i ConditionArray) ToConditionArrayOutputWithContext(ctx context.Context) ConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionArrayOutput)
}

// A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
type ConditionOutput struct{ *pulumi.OutputState }

func (ConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Condition)(nil)).Elem()
}

func (o ConditionOutput) ToConditionOutput() ConditionOutput {
	return o
}

func (o ConditionOutput) ToConditionOutputWithContext(ctx context.Context) ConditionOutput {
	return o
}

// A condition that checks that a time series continues to receive new data points.
func (o ConditionOutput) ConditionAbsent() MetricAbsencePtrOutput {
	return o.ApplyT(func(v Condition) *MetricAbsence { return v.ConditionAbsent }).(MetricAbsencePtrOutput)
}

// A condition that uses the Monitoring Query Language to define alerts.
func (o ConditionOutput) ConditionMonitoringQueryLanguage() MonitoringQueryLanguageConditionPtrOutput {
	return o.ApplyT(func(v Condition) *MonitoringQueryLanguageCondition { return v.ConditionMonitoringQueryLanguage }).(MonitoringQueryLanguageConditionPtrOutput)
}

// A condition that compares a time series against a threshold.
func (o ConditionOutput) ConditionThreshold() MetricThresholdPtrOutput {
	return o.ApplyT(func(v Condition) *MetricThreshold { return v.ConditionThreshold }).(MetricThresholdPtrOutput)
}

// A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
func (o ConditionOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Condition) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Stackdriver Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Stackdriver Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
func (o ConditionOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Condition) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ConditionArrayOutput struct{ *pulumi.OutputState }

func (ConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Condition)(nil)).Elem()
}

func (o ConditionArrayOutput) ToConditionArrayOutput() ConditionArrayOutput {
	return o
}

func (o ConditionArrayOutput) ToConditionArrayOutputWithContext(ctx context.Context) ConditionArrayOutput {
	return o
}

func (o ConditionArrayOutput) Index(i pulumi.IntInput) ConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Condition {
		return vs[0].([]Condition)[vs[1].(int)]
	}).(ConditionOutput)
}

// A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
type ConditionResponse struct {
	// A condition that checks that a time series continues to receive new data points.
	ConditionAbsent MetricAbsenceResponse `pulumi:"conditionAbsent"`
	// A condition that uses the Monitoring Query Language to define alerts.
	ConditionMonitoringQueryLanguage MonitoringQueryLanguageConditionResponse `pulumi:"conditionMonitoringQueryLanguage"`
	// A condition that compares a time series against a threshold.
	ConditionThreshold MetricThresholdResponse `pulumi:"conditionThreshold"`
	// A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
	DisplayName string `pulumi:"displayName"`
	// Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Stackdriver Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Stackdriver Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
	Name string `pulumi:"name"`
}

// ConditionResponseInput is an input type that accepts ConditionResponseArgs and ConditionResponseOutput values.
// You can construct a concrete instance of `ConditionResponseInput` via:
//
//          ConditionResponseArgs{...}
type ConditionResponseInput interface {
	pulumi.Input

	ToConditionResponseOutput() ConditionResponseOutput
	ToConditionResponseOutputWithContext(context.Context) ConditionResponseOutput
}

// A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
type ConditionResponseArgs struct {
	// A condition that checks that a time series continues to receive new data points.
	ConditionAbsent MetricAbsenceResponseInput `pulumi:"conditionAbsent"`
	// A condition that uses the Monitoring Query Language to define alerts.
	ConditionMonitoringQueryLanguage MonitoringQueryLanguageConditionResponseInput `pulumi:"conditionMonitoringQueryLanguage"`
	// A condition that compares a time series against a threshold.
	ConditionThreshold MetricThresholdResponseInput `pulumi:"conditionThreshold"`
	// A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
	DisplayName pulumi.StringInput `pulumi:"displayName"`
	// Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Stackdriver Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Stackdriver Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
	Name pulumi.StringInput `pulumi:"name"`
}

func (ConditionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConditionResponse)(nil)).Elem()
}

func (i ConditionResponseArgs) ToConditionResponseOutput() ConditionResponseOutput {
	return i.ToConditionResponseOutputWithContext(context.Background())
}

func (i ConditionResponseArgs) ToConditionResponseOutputWithContext(ctx context.Context) ConditionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionResponseOutput)
}

// ConditionResponseArrayInput is an input type that accepts ConditionResponseArray and ConditionResponseArrayOutput values.
// You can construct a concrete instance of `ConditionResponseArrayInput` via:
//
//          ConditionResponseArray{ ConditionResponseArgs{...} }
type ConditionResponseArrayInput interface {
	pulumi.Input

	ToConditionResponseArrayOutput() ConditionResponseArrayOutput
	ToConditionResponseArrayOutputWithContext(context.Context) ConditionResponseArrayOutput
}

type ConditionResponseArray []ConditionResponseInput

func (ConditionResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ConditionResponse)(nil)).Elem()
}

func (i ConditionResponseArray) ToConditionResponseArrayOutput() ConditionResponseArrayOutput {
	return i.ToConditionResponseArrayOutputWithContext(context.Background())
}

func (i ConditionResponseArray) ToConditionResponseArrayOutputWithContext(ctx context.Context) ConditionResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionResponseArrayOutput)
}

// A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
type ConditionResponseOutput struct{ *pulumi.OutputState }

func (ConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConditionResponse)(nil)).Elem()
}

func (o ConditionResponseOutput) ToConditionResponseOutput() ConditionResponseOutput {
	return o
}

func (o ConditionResponseOutput) ToConditionResponseOutputWithContext(ctx context.Context) ConditionResponseOutput {
	return o
}

// A condition that checks that a time series continues to receive new data points.
func (o ConditionResponseOutput) ConditionAbsent() MetricAbsenceResponseOutput {
	return o.ApplyT(func(v ConditionResponse) MetricAbsenceResponse { return v.ConditionAbsent }).(MetricAbsenceResponseOutput)
}

// A condition that uses the Monitoring Query Language to define alerts.
func (o ConditionResponseOutput) ConditionMonitoringQueryLanguage() MonitoringQueryLanguageConditionResponseOutput {
	return o.ApplyT(func(v ConditionResponse) MonitoringQueryLanguageConditionResponse {
		return v.ConditionMonitoringQueryLanguage
	}).(MonitoringQueryLanguageConditionResponseOutput)
}

// A condition that compares a time series against a threshold.
func (o ConditionResponseOutput) ConditionThreshold() MetricThresholdResponseOutput {
	return o.ApplyT(func(v ConditionResponse) MetricThresholdResponse { return v.ConditionThreshold }).(MetricThresholdResponseOutput)
}

// A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
func (o ConditionResponseOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v ConditionResponse) string { return v.DisplayName }).(pulumi.StringOutput)
}

// Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Stackdriver Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Stackdriver Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
func (o ConditionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ConditionResponse) string { return v.Name }).(pulumi.StringOutput)
}

type ConditionResponseArrayOutput struct{ *pulumi.OutputState }

func (ConditionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ConditionResponse)(nil)).Elem()
}

func (o ConditionResponseArrayOutput) ToConditionResponseArrayOutput() ConditionResponseArrayOutput {
	return o
}

func (o ConditionResponseArrayOutput) ToConditionResponseArrayOutputWithContext(ctx context.Context) ConditionResponseArrayOutput {
	return o
}

func (o ConditionResponseArrayOutput) Index(i pulumi.IntInput) ConditionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ConditionResponse {
		return vs[0].([]ConditionResponse)[vs[1].(int)]
	}).(ConditionResponseOutput)
}

// Optional. Used to perform content matching. This allows matching based on substrings and regular expressions, together with their negations. Only the first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP check's response) are examined for purposes of content matching.
type ContentMatcher struct {
	// String or regex content to match. Maximum 1024 bytes. An empty content string indicates no content matching is to be performed.
	Content *string `pulumi:"content"`
	// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
	Matcher *string `pulumi:"matcher"`
}

// ContentMatcherInput is an input type that accepts ContentMatcherArgs and ContentMatcherOutput values.
// You can construct a concrete instance of `ContentMatcherInput` via:
//
//          ContentMatcherArgs{...}
type ContentMatcherInput interface {
	pulumi.Input

	ToContentMatcherOutput() ContentMatcherOutput
	ToContentMatcherOutputWithContext(context.Context) ContentMatcherOutput
}

// Optional. Used to perform content matching. This allows matching based on substrings and regular expressions, together with their negations. Only the first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP check's response) are examined for purposes of content matching.
type ContentMatcherArgs struct {
	// String or regex content to match. Maximum 1024 bytes. An empty content string indicates no content matching is to be performed.
	Content pulumi.StringPtrInput `pulumi:"content"`
	// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
	Matcher pulumi.StringPtrInput `pulumi:"matcher"`
}

func (ContentMatcherArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentMatcher)(nil)).Elem()
}

func (i ContentMatcherArgs) ToContentMatcherOutput() ContentMatcherOutput {
	return i.ToContentMatcherOutputWithContext(context.Background())
}

func (i ContentMatcherArgs) ToContentMatcherOutputWithContext(ctx context.Context) ContentMatcherOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentMatcherOutput)
}

// ContentMatcherArrayInput is an input type that accepts ContentMatcherArray and ContentMatcherArrayOutput values.
// You can construct a concrete instance of `ContentMatcherArrayInput` via:
//
//          ContentMatcherArray{ ContentMatcherArgs{...} }
type ContentMatcherArrayInput interface {
	pulumi.Input

	ToContentMatcherArrayOutput() ContentMatcherArrayOutput
	ToContentMatcherArrayOutputWithContext(context.Context) ContentMatcherArrayOutput
}

type ContentMatcherArray []ContentMatcherInput

func (ContentMatcherArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentMatcher)(nil)).Elem()
}

func (i ContentMatcherArray) ToContentMatcherArrayOutput() ContentMatcherArrayOutput {
	return i.ToContentMatcherArrayOutputWithContext(context.Background())
}

func (i ContentMatcherArray) ToContentMatcherArrayOutputWithContext(ctx context.Context) ContentMatcherArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentMatcherArrayOutput)
}

// Optional. Used to perform content matching. This allows matching based on substrings and regular expressions, together with their negations. Only the first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP check's response) are examined for purposes of content matching.
type ContentMatcherOutput struct{ *pulumi.OutputState }

func (ContentMatcherOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentMatcher)(nil)).Elem()
}

func (o ContentMatcherOutput) ToContentMatcherOutput() ContentMatcherOutput {
	return o
}

func (o ContentMatcherOutput) ToContentMatcherOutputWithContext(ctx context.Context) ContentMatcherOutput {
	return o
}

// String or regex content to match. Maximum 1024 bytes. An empty content string indicates no content matching is to be performed.
func (o ContentMatcherOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentMatcher) *string { return v.Content }).(pulumi.StringPtrOutput)
}

// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
func (o ContentMatcherOutput) Matcher() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentMatcher) *string { return v.Matcher }).(pulumi.StringPtrOutput)
}

type ContentMatcherArrayOutput struct{ *pulumi.OutputState }

func (ContentMatcherArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentMatcher)(nil)).Elem()
}

func (o ContentMatcherArrayOutput) ToContentMatcherArrayOutput() ContentMatcherArrayOutput {
	return o
}

func (o ContentMatcherArrayOutput) ToContentMatcherArrayOutputWithContext(ctx context.Context) ContentMatcherArrayOutput {
	return o
}

func (o ContentMatcherArrayOutput) Index(i pulumi.IntInput) ContentMatcherOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContentMatcher {
		return vs[0].([]ContentMatcher)[vs[1].(int)]
	}).(ContentMatcherOutput)
}

// Optional. Used to perform content matching. This allows matching based on substrings and regular expressions, together with their negations. Only the first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP check's response) are examined for purposes of content matching.
type ContentMatcherResponse struct {
	// String or regex content to match. Maximum 1024 bytes. An empty content string indicates no content matching is to be performed.
	Content string `pulumi:"content"`
	// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
	Matcher string `pulumi:"matcher"`
}

// ContentMatcherResponseInput is an input type that accepts ContentMatcherResponseArgs and ContentMatcherResponseOutput values.
// You can construct a concrete instance of `ContentMatcherResponseInput` via:
//
//          ContentMatcherResponseArgs{...}
type ContentMatcherResponseInput interface {
	pulumi.Input

	ToContentMatcherResponseOutput() ContentMatcherResponseOutput
	ToContentMatcherResponseOutputWithContext(context.Context) ContentMatcherResponseOutput
}

// Optional. Used to perform content matching. This allows matching based on substrings and regular expressions, together with their negations. Only the first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP check's response) are examined for purposes of content matching.
type ContentMatcherResponseArgs struct {
	// String or regex content to match. Maximum 1024 bytes. An empty content string indicates no content matching is to be performed.
	Content pulumi.StringInput `pulumi:"content"`
	// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
	Matcher pulumi.StringInput `pulumi:"matcher"`
}

func (ContentMatcherResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentMatcherResponse)(nil)).Elem()
}

func (i ContentMatcherResponseArgs) ToContentMatcherResponseOutput() ContentMatcherResponseOutput {
	return i.ToContentMatcherResponseOutputWithContext(context.Background())
}

func (i ContentMatcherResponseArgs) ToContentMatcherResponseOutputWithContext(ctx context.Context) ContentMatcherResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentMatcherResponseOutput)
}

// ContentMatcherResponseArrayInput is an input type that accepts ContentMatcherResponseArray and ContentMatcherResponseArrayOutput values.
// You can construct a concrete instance of `ContentMatcherResponseArrayInput` via:
//
//          ContentMatcherResponseArray{ ContentMatcherResponseArgs{...} }
type ContentMatcherResponseArrayInput interface {
	pulumi.Input

	ToContentMatcherResponseArrayOutput() ContentMatcherResponseArrayOutput
	ToContentMatcherResponseArrayOutputWithContext(context.Context) ContentMatcherResponseArrayOutput
}

type ContentMatcherResponseArray []ContentMatcherResponseInput

func (ContentMatcherResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentMatcherResponse)(nil)).Elem()
}

func (i ContentMatcherResponseArray) ToContentMatcherResponseArrayOutput() ContentMatcherResponseArrayOutput {
	return i.ToContentMatcherResponseArrayOutputWithContext(context.Background())
}

func (i ContentMatcherResponseArray) ToContentMatcherResponseArrayOutputWithContext(ctx context.Context) ContentMatcherResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentMatcherResponseArrayOutput)
}

// Optional. Used to perform content matching. This allows matching based on substrings and regular expressions, together with their negations. Only the first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP check's response) are examined for purposes of content matching.
type ContentMatcherResponseOutput struct{ *pulumi.OutputState }

func (ContentMatcherResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentMatcherResponse)(nil)).Elem()
}

func (o ContentMatcherResponseOutput) ToContentMatcherResponseOutput() ContentMatcherResponseOutput {
	return o
}

func (o ContentMatcherResponseOutput) ToContentMatcherResponseOutputWithContext(ctx context.Context) ContentMatcherResponseOutput {
	return o
}

// String or regex content to match. Maximum 1024 bytes. An empty content string indicates no content matching is to be performed.
func (o ContentMatcherResponseOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v ContentMatcherResponse) string { return v.Content }).(pulumi.StringOutput)
}

// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
func (o ContentMatcherResponseOutput) Matcher() pulumi.StringOutput {
	return o.ApplyT(func(v ContentMatcherResponse) string { return v.Matcher }).(pulumi.StringOutput)
}

type ContentMatcherResponseArrayOutput struct{ *pulumi.OutputState }

func (ContentMatcherResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentMatcherResponse)(nil)).Elem()
}

func (o ContentMatcherResponseArrayOutput) ToContentMatcherResponseArrayOutput() ContentMatcherResponseArrayOutput {
	return o
}

func (o ContentMatcherResponseArrayOutput) ToContentMatcherResponseArrayOutputWithContext(ctx context.Context) ContentMatcherResponseArrayOutput {
	return o
}

func (o ContentMatcherResponseArrayOutput) Index(i pulumi.IntInput) ContentMatcherResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContentMatcherResponse {
		return vs[0].([]ContentMatcherResponse)[vs[1].(int)]
	}).(ContentMatcherResponseOutput)
}

// Custom view of service telemetry. Currently a place-holder pending final design.
type Custom struct {
}

// CustomInput is an input type that accepts CustomArgs and CustomOutput values.
// You can construct a concrete instance of `CustomInput` via:
//
//          CustomArgs{...}
type CustomInput interface {
	pulumi.Input

	ToCustomOutput() CustomOutput
	ToCustomOutputWithContext(context.Context) CustomOutput
}

// Custom view of service telemetry. Currently a place-holder pending final design.
type CustomArgs struct {
}

func (CustomArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Custom)(nil)).Elem()
}

func (i CustomArgs) ToCustomOutput() CustomOutput {
	return i.ToCustomOutputWithContext(context.Background())
}

func (i CustomArgs) ToCustomOutputWithContext(ctx context.Context) CustomOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomOutput)
}

func (i CustomArgs) ToCustomPtrOutput() CustomPtrOutput {
	return i.ToCustomPtrOutputWithContext(context.Background())
}

func (i CustomArgs) ToCustomPtrOutputWithContext(ctx context.Context) CustomPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomOutput).ToCustomPtrOutputWithContext(ctx)
}

// CustomPtrInput is an input type that accepts CustomArgs, CustomPtr and CustomPtrOutput values.
// You can construct a concrete instance of `CustomPtrInput` via:
//
//          CustomArgs{...}
//
//  or:
//
//          nil
type CustomPtrInput interface {
	pulumi.Input

	ToCustomPtrOutput() CustomPtrOutput
	ToCustomPtrOutputWithContext(context.Context) CustomPtrOutput
}

type customPtrType CustomArgs

func CustomPtr(v *CustomArgs) CustomPtrInput {
	return (*customPtrType)(v)
}

func (*customPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Custom)(nil)).Elem()
}

func (i *customPtrType) ToCustomPtrOutput() CustomPtrOutput {
	return i.ToCustomPtrOutputWithContext(context.Background())
}

func (i *customPtrType) ToCustomPtrOutputWithContext(ctx context.Context) CustomPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomPtrOutput)
}

// Custom view of service telemetry. Currently a place-holder pending final design.
type CustomOutput struct{ *pulumi.OutputState }

func (CustomOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Custom)(nil)).Elem()
}

func (o CustomOutput) ToCustomOutput() CustomOutput {
	return o
}

func (o CustomOutput) ToCustomOutputWithContext(ctx context.Context) CustomOutput {
	return o
}

func (o CustomOutput) ToCustomPtrOutput() CustomPtrOutput {
	return o.ToCustomPtrOutputWithContext(context.Background())
}

func (o CustomOutput) ToCustomPtrOutputWithContext(ctx context.Context) CustomPtrOutput {
	return o.ApplyT(func(v Custom) *Custom {
		return &v
	}).(CustomPtrOutput)
}

type CustomPtrOutput struct{ *pulumi.OutputState }

func (CustomPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Custom)(nil)).Elem()
}

func (o CustomPtrOutput) ToCustomPtrOutput() CustomPtrOutput {
	return o
}

func (o CustomPtrOutput) ToCustomPtrOutputWithContext(ctx context.Context) CustomPtrOutput {
	return o
}

func (o CustomPtrOutput) Elem() CustomOutput {
	return o.ApplyT(func(v *Custom) Custom { return *v }).(CustomOutput)
}

// Custom view of service telemetry. Currently a place-holder pending final design.
type CustomResponse struct {
}

// CustomResponseInput is an input type that accepts CustomResponseArgs and CustomResponseOutput values.
// You can construct a concrete instance of `CustomResponseInput` via:
//
//          CustomResponseArgs{...}
type CustomResponseInput interface {
	pulumi.Input

	ToCustomResponseOutput() CustomResponseOutput
	ToCustomResponseOutputWithContext(context.Context) CustomResponseOutput
}

// Custom view of service telemetry. Currently a place-holder pending final design.
type CustomResponseArgs struct {
}

func (CustomResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomResponse)(nil)).Elem()
}

func (i CustomResponseArgs) ToCustomResponseOutput() CustomResponseOutput {
	return i.ToCustomResponseOutputWithContext(context.Background())
}

func (i CustomResponseArgs) ToCustomResponseOutputWithContext(ctx context.Context) CustomResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomResponseOutput)
}

func (i CustomResponseArgs) ToCustomResponsePtrOutput() CustomResponsePtrOutput {
	return i.ToCustomResponsePtrOutputWithContext(context.Background())
}

func (i CustomResponseArgs) ToCustomResponsePtrOutputWithContext(ctx context.Context) CustomResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomResponseOutput).ToCustomResponsePtrOutputWithContext(ctx)
}

// CustomResponsePtrInput is an input type that accepts CustomResponseArgs, CustomResponsePtr and CustomResponsePtrOutput values.
// You can construct a concrete instance of `CustomResponsePtrInput` via:
//
//          CustomResponseArgs{...}
//
//  or:
//
//          nil
type CustomResponsePtrInput interface {
	pulumi.Input

	ToCustomResponsePtrOutput() CustomResponsePtrOutput
	ToCustomResponsePtrOutputWithContext(context.Context) CustomResponsePtrOutput
}

type customResponsePtrType CustomResponseArgs

func CustomResponsePtr(v *CustomResponseArgs) CustomResponsePtrInput {
	return (*customResponsePtrType)(v)
}

func (*customResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CustomResponse)(nil)).Elem()
}

func (i *customResponsePtrType) ToCustomResponsePtrOutput() CustomResponsePtrOutput {
	return i.ToCustomResponsePtrOutputWithContext(context.Background())
}

func (i *customResponsePtrType) ToCustomResponsePtrOutputWithContext(ctx context.Context) CustomResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomResponsePtrOutput)
}

// Custom view of service telemetry. Currently a place-holder pending final design.
type CustomResponseOutput struct{ *pulumi.OutputState }

func (CustomResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomResponse)(nil)).Elem()
}

func (o CustomResponseOutput) ToCustomResponseOutput() CustomResponseOutput {
	return o
}

func (o CustomResponseOutput) ToCustomResponseOutputWithContext(ctx context.Context) CustomResponseOutput {
	return o
}

func (o CustomResponseOutput) ToCustomResponsePtrOutput() CustomResponsePtrOutput {
	return o.ToCustomResponsePtrOutputWithContext(context.Background())
}

func (o CustomResponseOutput) ToCustomResponsePtrOutputWithContext(ctx context.Context) CustomResponsePtrOutput {
	return o.ApplyT(func(v CustomResponse) *CustomResponse {
		return &v
	}).(CustomResponsePtrOutput)
}

type CustomResponsePtrOutput struct{ *pulumi.OutputState }

func (CustomResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CustomResponse)(nil)).Elem()
}

func (o CustomResponsePtrOutput) ToCustomResponsePtrOutput() CustomResponsePtrOutput {
	return o
}

func (o CustomResponsePtrOutput) ToCustomResponsePtrOutputWithContext(ctx context.Context) CustomResponsePtrOutput {
	return o
}

func (o CustomResponsePtrOutput) Elem() CustomResponseOutput {
	return o.ApplyT(func(v *CustomResponse) CustomResponse { return *v }).(CustomResponseOutput)
}

// Distribution contains summary statistics for a population of values. It optionally contains a histogram representing the distribution of those values across a set of buckets.The summary statistics are the count, mean, sum of the squared deviation from the mean, the minimum, and the maximum of the set of population of values. The histogram is based on a sequence of buckets and gives a count of values that fall into each bucket. The boundaries of the buckets are given either explicitly or by formulas for buckets of fixed or exponentially increasing widths.Although it is not forbidden, it is generally a bad idea to include non-finite values (infinities or NaNs) in the population of values, as this will render the mean and sum_of_squared_deviation fields meaningless.
type Distribution struct {
	// Required in the Cloud Monitoring API v3. The values for each bucket specified in bucket_options. The sum of the values in bucketCounts must equal the value in the count field of the Distribution object. The order of the bucket counts follows the numbering schemes described for the three bucket types. The underflow bucket has number 0; the finite buckets, if any, have numbers 1 through N-2; and the overflow bucket has number N-1. The size of bucket_counts must not be greater than N. If the size is less than N, then the remaining buckets are assigned values of zero.
	BucketCounts []string `pulumi:"bucketCounts"`
	// Required in the Cloud Monitoring API v3. Defines the histogram bucket boundaries.
	BucketOptions *BucketOptions `pulumi:"bucketOptions"`
	// The number of values in the population. Must be non-negative. This value must equal the sum of the values in bucket_counts if a histogram is provided.
	Count *string `pulumi:"count"`
	// Must be in increasing order of value field.
	Exemplars []Exemplar `pulumi:"exemplars"`
	// The arithmetic mean of the values in the population. If count is zero then this field must be zero.
	Mean *float64 `pulumi:"mean"`
	// If specified, contains the range of the population values. The field must not be present if the count is zero. This field is presently ignored by the Cloud Monitoring API v3.
	Range *Range `pulumi:"range"`
	// The sum of squared deviations from the mean of the values in the population. For values x_i this is: Sum[i=1..n]((x_i - mean)^2) Knuth, "The Art of Computer Programming", Vol. 2, page 232, 3rd edition describes Welford's method for accumulating this sum in one pass.If count is zero then this field must be zero.
	SumOfSquaredDeviation *float64 `pulumi:"sumOfSquaredDeviation"`
}

// DistributionInput is an input type that accepts DistributionArgs and DistributionOutput values.
// You can construct a concrete instance of `DistributionInput` via:
//
//          DistributionArgs{...}
type DistributionInput interface {
	pulumi.Input

	ToDistributionOutput() DistributionOutput
	ToDistributionOutputWithContext(context.Context) DistributionOutput
}

// Distribution contains summary statistics for a population of values. It optionally contains a histogram representing the distribution of those values across a set of buckets.The summary statistics are the count, mean, sum of the squared deviation from the mean, the minimum, and the maximum of the set of population of values. The histogram is based on a sequence of buckets and gives a count of values that fall into each bucket. The boundaries of the buckets are given either explicitly or by formulas for buckets of fixed or exponentially increasing widths.Although it is not forbidden, it is generally a bad idea to include non-finite values (infinities or NaNs) in the population of values, as this will render the mean and sum_of_squared_deviation fields meaningless.
type DistributionArgs struct {
	// Required in the Cloud Monitoring API v3. The values for each bucket specified in bucket_options. The sum of the values in bucketCounts must equal the value in the count field of the Distribution object. The order of the bucket counts follows the numbering schemes described for the three bucket types. The underflow bucket has number 0; the finite buckets, if any, have numbers 1 through N-2; and the overflow bucket has number N-1. The size of bucket_counts must not be greater than N. If the size is less than N, then the remaining buckets are assigned values of zero.
	BucketCounts pulumi.StringArrayInput `pulumi:"bucketCounts"`
	// Required in the Cloud Monitoring API v3. Defines the histogram bucket boundaries.
	BucketOptions BucketOptionsPtrInput `pulumi:"bucketOptions"`
	// The number of values in the population. Must be non-negative. This value must equal the sum of the values in bucket_counts if a histogram is provided.
	Count pulumi.StringPtrInput `pulumi:"count"`
	// Must be in increasing order of value field.
	Exemplars ExemplarArrayInput `pulumi:"exemplars"`
	// The arithmetic mean of the values in the population. If count is zero then this field must be zero.
	Mean pulumi.Float64PtrInput `pulumi:"mean"`
	// If specified, contains the range of the population values. The field must not be present if the count is zero. This field is presently ignored by the Cloud Monitoring API v3.
	Range RangePtrInput `pulumi:"range"`
	// The sum of squared deviations from the mean of the values in the population. For values x_i this is: Sum[i=1..n]((x_i - mean)^2) Knuth, "The Art of Computer Programming", Vol. 2, page 232, 3rd edition describes Welford's method for accumulating this sum in one pass.If count is zero then this field must be zero.
	SumOfSquaredDeviation pulumi.Float64PtrInput `pulumi:"sumOfSquaredDeviation"`
}

func (DistributionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Distribution)(nil)).Elem()
}

func (i DistributionArgs) ToDistributionOutput() DistributionOutput {
	return i.ToDistributionOutputWithContext(context.Background())
}

func (i DistributionArgs) ToDistributionOutputWithContext(ctx context.Context) DistributionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionOutput)
}

func (i DistributionArgs) ToDistributionPtrOutput() DistributionPtrOutput {
	return i.ToDistributionPtrOutputWithContext(context.Background())
}

func (i DistributionArgs) ToDistributionPtrOutputWithContext(ctx context.Context) DistributionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionOutput).ToDistributionPtrOutputWithContext(ctx)
}

// DistributionPtrInput is an input type that accepts DistributionArgs, DistributionPtr and DistributionPtrOutput values.
// You can construct a concrete instance of `DistributionPtrInput` via:
//
//          DistributionArgs{...}
//
//  or:
//
//          nil
type DistributionPtrInput interface {
	pulumi.Input

	ToDistributionPtrOutput() DistributionPtrOutput
	ToDistributionPtrOutputWithContext(context.Context) DistributionPtrOutput
}

type distributionPtrType DistributionArgs

func DistributionPtr(v *DistributionArgs) DistributionPtrInput {
	return (*distributionPtrType)(v)
}

func (*distributionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Distribution)(nil)).Elem()
}

func (i *distributionPtrType) ToDistributionPtrOutput() DistributionPtrOutput {
	return i.ToDistributionPtrOutputWithContext(context.Background())
}

func (i *distributionPtrType) ToDistributionPtrOutputWithContext(ctx context.Context) DistributionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionPtrOutput)
}

// Distribution contains summary statistics for a population of values. It optionally contains a histogram representing the distribution of those values across a set of buckets.The summary statistics are the count, mean, sum of the squared deviation from the mean, the minimum, and the maximum of the set of population of values. The histogram is based on a sequence of buckets and gives a count of values that fall into each bucket. The boundaries of the buckets are given either explicitly or by formulas for buckets of fixed or exponentially increasing widths.Although it is not forbidden, it is generally a bad idea to include non-finite values (infinities or NaNs) in the population of values, as this will render the mean and sum_of_squared_deviation fields meaningless.
type DistributionOutput struct{ *pulumi.OutputState }

func (DistributionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Distribution)(nil)).Elem()
}

func (o DistributionOutput) ToDistributionOutput() DistributionOutput {
	return o
}

func (o DistributionOutput) ToDistributionOutputWithContext(ctx context.Context) DistributionOutput {
	return o
}

func (o DistributionOutput) ToDistributionPtrOutput() DistributionPtrOutput {
	return o.ToDistributionPtrOutputWithContext(context.Background())
}

func (o DistributionOutput) ToDistributionPtrOutputWithContext(ctx context.Context) DistributionPtrOutput {
	return o.ApplyT(func(v Distribution) *Distribution {
		return &v
	}).(DistributionPtrOutput)
}

// Required in the Cloud Monitoring API v3. The values for each bucket specified in bucket_options. The sum of the values in bucketCounts must equal the value in the count field of the Distribution object. The order of the bucket counts follows the numbering schemes described for the three bucket types. The underflow bucket has number 0; the finite buckets, if any, have numbers 1 through N-2; and the overflow bucket has number N-1. The size of bucket_counts must not be greater than N. If the size is less than N, then the remaining buckets are assigned values of zero.
func (o DistributionOutput) BucketCounts() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Distribution) []string { return v.BucketCounts }).(pulumi.StringArrayOutput)
}

// Required in the Cloud Monitoring API v3. Defines the histogram bucket boundaries.
func (o DistributionOutput) BucketOptions() BucketOptionsPtrOutput {
	return o.ApplyT(func(v Distribution) *BucketOptions { return v.BucketOptions }).(BucketOptionsPtrOutput)
}

// The number of values in the population. Must be non-negative. This value must equal the sum of the values in bucket_counts if a histogram is provided.
func (o DistributionOutput) Count() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Distribution) *string { return v.Count }).(pulumi.StringPtrOutput)
}

// Must be in increasing order of value field.
func (o DistributionOutput) Exemplars() ExemplarArrayOutput {
	return o.ApplyT(func(v Distribution) []Exemplar { return v.Exemplars }).(ExemplarArrayOutput)
}

// The arithmetic mean of the values in the population. If count is zero then this field must be zero.
func (o DistributionOutput) Mean() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Distribution) *float64 { return v.Mean }).(pulumi.Float64PtrOutput)
}

// If specified, contains the range of the population values. The field must not be present if the count is zero. This field is presently ignored by the Cloud Monitoring API v3.
func (o DistributionOutput) Range() RangePtrOutput {
	return o.ApplyT(func(v Distribution) *Range { return v.Range }).(RangePtrOutput)
}

// The sum of squared deviations from the mean of the values in the population. For values x_i this is: Sum[i=1..n]((x_i - mean)^2) Knuth, "The Art of Computer Programming", Vol. 2, page 232, 3rd edition describes Welford's method for accumulating this sum in one pass.If count is zero then this field must be zero.
func (o DistributionOutput) SumOfSquaredDeviation() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Distribution) *float64 { return v.SumOfSquaredDeviation }).(pulumi.Float64PtrOutput)
}

type DistributionPtrOutput struct{ *pulumi.OutputState }

func (DistributionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Distribution)(nil)).Elem()
}

func (o DistributionPtrOutput) ToDistributionPtrOutput() DistributionPtrOutput {
	return o
}

func (o DistributionPtrOutput) ToDistributionPtrOutputWithContext(ctx context.Context) DistributionPtrOutput {
	return o
}

func (o DistributionPtrOutput) Elem() DistributionOutput {
	return o.ApplyT(func(v *Distribution) Distribution { return *v }).(DistributionOutput)
}

// Required in the Cloud Monitoring API v3. The values for each bucket specified in bucket_options. The sum of the values in bucketCounts must equal the value in the count field of the Distribution object. The order of the bucket counts follows the numbering schemes described for the three bucket types. The underflow bucket has number 0; the finite buckets, if any, have numbers 1 through N-2; and the overflow bucket has number N-1. The size of bucket_counts must not be greater than N. If the size is less than N, then the remaining buckets are assigned values of zero.
func (o DistributionPtrOutput) BucketCounts() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Distribution) []string {
		if v == nil {
			return nil
		}
		return v.BucketCounts
	}).(pulumi.StringArrayOutput)
}

// Required in the Cloud Monitoring API v3. Defines the histogram bucket boundaries.
func (o DistributionPtrOutput) BucketOptions() BucketOptionsPtrOutput {
	return o.ApplyT(func(v *Distribution) *BucketOptions {
		if v == nil {
			return nil
		}
		return v.BucketOptions
	}).(BucketOptionsPtrOutput)
}

// The number of values in the population. Must be non-negative. This value must equal the sum of the values in bucket_counts if a histogram is provided.
func (o DistributionPtrOutput) Count() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Distribution) *string {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.StringPtrOutput)
}

// Must be in increasing order of value field.
func (o DistributionPtrOutput) Exemplars() ExemplarArrayOutput {
	return o.ApplyT(func(v *Distribution) []Exemplar {
		if v == nil {
			return nil
		}
		return v.Exemplars
	}).(ExemplarArrayOutput)
}

// The arithmetic mean of the values in the population. If count is zero then this field must be zero.
func (o DistributionPtrOutput) Mean() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Distribution) *float64 {
		if v == nil {
			return nil
		}
		return v.Mean
	}).(pulumi.Float64PtrOutput)
}

// If specified, contains the range of the population values. The field must not be present if the count is zero. This field is presently ignored by the Cloud Monitoring API v3.
func (o DistributionPtrOutput) Range() RangePtrOutput {
	return o.ApplyT(func(v *Distribution) *Range {
		if v == nil {
			return nil
		}
		return v.Range
	}).(RangePtrOutput)
}

// The sum of squared deviations from the mean of the values in the population. For values x_i this is: Sum[i=1..n]((x_i - mean)^2) Knuth, "The Art of Computer Programming", Vol. 2, page 232, 3rd edition describes Welford's method for accumulating this sum in one pass.If count is zero then this field must be zero.
func (o DistributionPtrOutput) SumOfSquaredDeviation() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Distribution) *float64 {
		if v == nil {
			return nil
		}
		return v.SumOfSquaredDeviation
	}).(pulumi.Float64PtrOutput)
}

// A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min <= x < range.max.
type DistributionCut struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter *string `pulumi:"distributionFilter"`
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range *GoogleMonitoringV3Range `pulumi:"range"`
}

// DistributionCutInput is an input type that accepts DistributionCutArgs and DistributionCutOutput values.
// You can construct a concrete instance of `DistributionCutInput` via:
//
//          DistributionCutArgs{...}
type DistributionCutInput interface {
	pulumi.Input

	ToDistributionCutOutput() DistributionCutOutput
	ToDistributionCutOutputWithContext(context.Context) DistributionCutOutput
}

// A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min <= x < range.max.
type DistributionCutArgs struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter pulumi.StringPtrInput `pulumi:"distributionFilter"`
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range GoogleMonitoringV3RangePtrInput `pulumi:"range"`
}

func (DistributionCutArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DistributionCut)(nil)).Elem()
}

func (i DistributionCutArgs) ToDistributionCutOutput() DistributionCutOutput {
	return i.ToDistributionCutOutputWithContext(context.Background())
}

func (i DistributionCutArgs) ToDistributionCutOutputWithContext(ctx context.Context) DistributionCutOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionCutOutput)
}

func (i DistributionCutArgs) ToDistributionCutPtrOutput() DistributionCutPtrOutput {
	return i.ToDistributionCutPtrOutputWithContext(context.Background())
}

func (i DistributionCutArgs) ToDistributionCutPtrOutputWithContext(ctx context.Context) DistributionCutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionCutOutput).ToDistributionCutPtrOutputWithContext(ctx)
}

// DistributionCutPtrInput is an input type that accepts DistributionCutArgs, DistributionCutPtr and DistributionCutPtrOutput values.
// You can construct a concrete instance of `DistributionCutPtrInput` via:
//
//          DistributionCutArgs{...}
//
//  or:
//
//          nil
type DistributionCutPtrInput interface {
	pulumi.Input

	ToDistributionCutPtrOutput() DistributionCutPtrOutput
	ToDistributionCutPtrOutputWithContext(context.Context) DistributionCutPtrOutput
}

type distributionCutPtrType DistributionCutArgs

func DistributionCutPtr(v *DistributionCutArgs) DistributionCutPtrInput {
	return (*distributionCutPtrType)(v)
}

func (*distributionCutPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DistributionCut)(nil)).Elem()
}

func (i *distributionCutPtrType) ToDistributionCutPtrOutput() DistributionCutPtrOutput {
	return i.ToDistributionCutPtrOutputWithContext(context.Background())
}

func (i *distributionCutPtrType) ToDistributionCutPtrOutputWithContext(ctx context.Context) DistributionCutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionCutPtrOutput)
}

// A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min <= x < range.max.
type DistributionCutOutput struct{ *pulumi.OutputState }

func (DistributionCutOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DistributionCut)(nil)).Elem()
}

func (o DistributionCutOutput) ToDistributionCutOutput() DistributionCutOutput {
	return o
}

func (o DistributionCutOutput) ToDistributionCutOutputWithContext(ctx context.Context) DistributionCutOutput {
	return o
}

func (o DistributionCutOutput) ToDistributionCutPtrOutput() DistributionCutPtrOutput {
	return o.ToDistributionCutPtrOutputWithContext(context.Background())
}

func (o DistributionCutOutput) ToDistributionCutPtrOutputWithContext(ctx context.Context) DistributionCutPtrOutput {
	return o.ApplyT(func(v DistributionCut) *DistributionCut {
		return &v
	}).(DistributionCutPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o DistributionCutOutput) DistributionFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DistributionCut) *string { return v.DistributionFilter }).(pulumi.StringPtrOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o DistributionCutOutput) Range() GoogleMonitoringV3RangePtrOutput {
	return o.ApplyT(func(v DistributionCut) *GoogleMonitoringV3Range { return v.Range }).(GoogleMonitoringV3RangePtrOutput)
}

type DistributionCutPtrOutput struct{ *pulumi.OutputState }

func (DistributionCutPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DistributionCut)(nil)).Elem()
}

func (o DistributionCutPtrOutput) ToDistributionCutPtrOutput() DistributionCutPtrOutput {
	return o
}

func (o DistributionCutPtrOutput) ToDistributionCutPtrOutputWithContext(ctx context.Context) DistributionCutPtrOutput {
	return o
}

func (o DistributionCutPtrOutput) Elem() DistributionCutOutput {
	return o.ApplyT(func(v *DistributionCut) DistributionCut { return *v }).(DistributionCutOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o DistributionCutPtrOutput) DistributionFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DistributionCut) *string {
		if v == nil {
			return nil
		}
		return v.DistributionFilter
	}).(pulumi.StringPtrOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o DistributionCutPtrOutput) Range() GoogleMonitoringV3RangePtrOutput {
	return o.ApplyT(func(v *DistributionCut) *GoogleMonitoringV3Range {
		if v == nil {
			return nil
		}
		return v.Range
	}).(GoogleMonitoringV3RangePtrOutput)
}

// A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min <= x < range.max.
type DistributionCutResponse struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter string `pulumi:"distributionFilter"`
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range GoogleMonitoringV3RangeResponse `pulumi:"range"`
}

// DistributionCutResponseInput is an input type that accepts DistributionCutResponseArgs and DistributionCutResponseOutput values.
// You can construct a concrete instance of `DistributionCutResponseInput` via:
//
//          DistributionCutResponseArgs{...}
type DistributionCutResponseInput interface {
	pulumi.Input

	ToDistributionCutResponseOutput() DistributionCutResponseOutput
	ToDistributionCutResponseOutputWithContext(context.Context) DistributionCutResponseOutput
}

// A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min <= x < range.max.
type DistributionCutResponseArgs struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter pulumi.StringInput `pulumi:"distributionFilter"`
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range GoogleMonitoringV3RangeResponseInput `pulumi:"range"`
}

func (DistributionCutResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DistributionCutResponse)(nil)).Elem()
}

func (i DistributionCutResponseArgs) ToDistributionCutResponseOutput() DistributionCutResponseOutput {
	return i.ToDistributionCutResponseOutputWithContext(context.Background())
}

func (i DistributionCutResponseArgs) ToDistributionCutResponseOutputWithContext(ctx context.Context) DistributionCutResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionCutResponseOutput)
}

func (i DistributionCutResponseArgs) ToDistributionCutResponsePtrOutput() DistributionCutResponsePtrOutput {
	return i.ToDistributionCutResponsePtrOutputWithContext(context.Background())
}

func (i DistributionCutResponseArgs) ToDistributionCutResponsePtrOutputWithContext(ctx context.Context) DistributionCutResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionCutResponseOutput).ToDistributionCutResponsePtrOutputWithContext(ctx)
}

// DistributionCutResponsePtrInput is an input type that accepts DistributionCutResponseArgs, DistributionCutResponsePtr and DistributionCutResponsePtrOutput values.
// You can construct a concrete instance of `DistributionCutResponsePtrInput` via:
//
//          DistributionCutResponseArgs{...}
//
//  or:
//
//          nil
type DistributionCutResponsePtrInput interface {
	pulumi.Input

	ToDistributionCutResponsePtrOutput() DistributionCutResponsePtrOutput
	ToDistributionCutResponsePtrOutputWithContext(context.Context) DistributionCutResponsePtrOutput
}

type distributionCutResponsePtrType DistributionCutResponseArgs

func DistributionCutResponsePtr(v *DistributionCutResponseArgs) DistributionCutResponsePtrInput {
	return (*distributionCutResponsePtrType)(v)
}

func (*distributionCutResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DistributionCutResponse)(nil)).Elem()
}

func (i *distributionCutResponsePtrType) ToDistributionCutResponsePtrOutput() DistributionCutResponsePtrOutput {
	return i.ToDistributionCutResponsePtrOutputWithContext(context.Background())
}

func (i *distributionCutResponsePtrType) ToDistributionCutResponsePtrOutputWithContext(ctx context.Context) DistributionCutResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionCutResponsePtrOutput)
}

// A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min <= x < range.max.
type DistributionCutResponseOutput struct{ *pulumi.OutputState }

func (DistributionCutResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DistributionCutResponse)(nil)).Elem()
}

func (o DistributionCutResponseOutput) ToDistributionCutResponseOutput() DistributionCutResponseOutput {
	return o
}

func (o DistributionCutResponseOutput) ToDistributionCutResponseOutputWithContext(ctx context.Context) DistributionCutResponseOutput {
	return o
}

func (o DistributionCutResponseOutput) ToDistributionCutResponsePtrOutput() DistributionCutResponsePtrOutput {
	return o.ToDistributionCutResponsePtrOutputWithContext(context.Background())
}

func (o DistributionCutResponseOutput) ToDistributionCutResponsePtrOutputWithContext(ctx context.Context) DistributionCutResponsePtrOutput {
	return o.ApplyT(func(v DistributionCutResponse) *DistributionCutResponse {
		return &v
	}).(DistributionCutResponsePtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o DistributionCutResponseOutput) DistributionFilter() pulumi.StringOutput {
	return o.ApplyT(func(v DistributionCutResponse) string { return v.DistributionFilter }).(pulumi.StringOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o DistributionCutResponseOutput) Range() GoogleMonitoringV3RangeResponseOutput {
	return o.ApplyT(func(v DistributionCutResponse) GoogleMonitoringV3RangeResponse { return v.Range }).(GoogleMonitoringV3RangeResponseOutput)
}

type DistributionCutResponsePtrOutput struct{ *pulumi.OutputState }

func (DistributionCutResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DistributionCutResponse)(nil)).Elem()
}

func (o DistributionCutResponsePtrOutput) ToDistributionCutResponsePtrOutput() DistributionCutResponsePtrOutput {
	return o
}

func (o DistributionCutResponsePtrOutput) ToDistributionCutResponsePtrOutputWithContext(ctx context.Context) DistributionCutResponsePtrOutput {
	return o
}

func (o DistributionCutResponsePtrOutput) Elem() DistributionCutResponseOutput {
	return o.ApplyT(func(v *DistributionCutResponse) DistributionCutResponse { return *v }).(DistributionCutResponseOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o DistributionCutResponsePtrOutput) DistributionFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DistributionCutResponse) *string {
		if v == nil {
			return nil
		}
		return &v.DistributionFilter
	}).(pulumi.StringPtrOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o DistributionCutResponsePtrOutput) Range() GoogleMonitoringV3RangeResponsePtrOutput {
	return o.ApplyT(func(v *DistributionCutResponse) *GoogleMonitoringV3RangeResponse {
		if v == nil {
			return nil
		}
		return &v.Range
	}).(GoogleMonitoringV3RangeResponsePtrOutput)
}

// A content string and a MIME type that describes the content string's format.
type Documentation struct {
	// The text of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller.
	Content *string `pulumi:"content"`
	// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
	MimeType *string `pulumi:"mimeType"`
}

// DocumentationInput is an input type that accepts DocumentationArgs and DocumentationOutput values.
// You can construct a concrete instance of `DocumentationInput` via:
//
//          DocumentationArgs{...}
type DocumentationInput interface {
	pulumi.Input

	ToDocumentationOutput() DocumentationOutput
	ToDocumentationOutputWithContext(context.Context) DocumentationOutput
}

// A content string and a MIME type that describes the content string's format.
type DocumentationArgs struct {
	// The text of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller.
	Content pulumi.StringPtrInput `pulumi:"content"`
	// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
	MimeType pulumi.StringPtrInput `pulumi:"mimeType"`
}

func (DocumentationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Documentation)(nil)).Elem()
}

func (i DocumentationArgs) ToDocumentationOutput() DocumentationOutput {
	return i.ToDocumentationOutputWithContext(context.Background())
}

func (i DocumentationArgs) ToDocumentationOutputWithContext(ctx context.Context) DocumentationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentationOutput)
}

func (i DocumentationArgs) ToDocumentationPtrOutput() DocumentationPtrOutput {
	return i.ToDocumentationPtrOutputWithContext(context.Background())
}

func (i DocumentationArgs) ToDocumentationPtrOutputWithContext(ctx context.Context) DocumentationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentationOutput).ToDocumentationPtrOutputWithContext(ctx)
}

// DocumentationPtrInput is an input type that accepts DocumentationArgs, DocumentationPtr and DocumentationPtrOutput values.
// You can construct a concrete instance of `DocumentationPtrInput` via:
//
//          DocumentationArgs{...}
//
//  or:
//
//          nil
type DocumentationPtrInput interface {
	pulumi.Input

	ToDocumentationPtrOutput() DocumentationPtrOutput
	ToDocumentationPtrOutputWithContext(context.Context) DocumentationPtrOutput
}

type documentationPtrType DocumentationArgs

func DocumentationPtr(v *DocumentationArgs) DocumentationPtrInput {
	return (*documentationPtrType)(v)
}

func (*documentationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Documentation)(nil)).Elem()
}

func (i *documentationPtrType) ToDocumentationPtrOutput() DocumentationPtrOutput {
	return i.ToDocumentationPtrOutputWithContext(context.Background())
}

func (i *documentationPtrType) ToDocumentationPtrOutputWithContext(ctx context.Context) DocumentationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentationPtrOutput)
}

// A content string and a MIME type that describes the content string's format.
type DocumentationOutput struct{ *pulumi.OutputState }

func (DocumentationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Documentation)(nil)).Elem()
}

func (o DocumentationOutput) ToDocumentationOutput() DocumentationOutput {
	return o
}

func (o DocumentationOutput) ToDocumentationOutputWithContext(ctx context.Context) DocumentationOutput {
	return o
}

func (o DocumentationOutput) ToDocumentationPtrOutput() DocumentationPtrOutput {
	return o.ToDocumentationPtrOutputWithContext(context.Background())
}

func (o DocumentationOutput) ToDocumentationPtrOutputWithContext(ctx context.Context) DocumentationPtrOutput {
	return o.ApplyT(func(v Documentation) *Documentation {
		return &v
	}).(DocumentationPtrOutput)
}

// The text of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller.
func (o DocumentationOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Documentation) *string { return v.Content }).(pulumi.StringPtrOutput)
}

// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
func (o DocumentationOutput) MimeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Documentation) *string { return v.MimeType }).(pulumi.StringPtrOutput)
}

type DocumentationPtrOutput struct{ *pulumi.OutputState }

func (DocumentationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Documentation)(nil)).Elem()
}

func (o DocumentationPtrOutput) ToDocumentationPtrOutput() DocumentationPtrOutput {
	return o
}

func (o DocumentationPtrOutput) ToDocumentationPtrOutputWithContext(ctx context.Context) DocumentationPtrOutput {
	return o
}

func (o DocumentationPtrOutput) Elem() DocumentationOutput {
	return o.ApplyT(func(v *Documentation) Documentation { return *v }).(DocumentationOutput)
}

// The text of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller.
func (o DocumentationPtrOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Documentation) *string {
		if v == nil {
			return nil
		}
		return v.Content
	}).(pulumi.StringPtrOutput)
}

// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
func (o DocumentationPtrOutput) MimeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Documentation) *string {
		if v == nil {
			return nil
		}
		return v.MimeType
	}).(pulumi.StringPtrOutput)
}

// A content string and a MIME type that describes the content string's format.
type DocumentationResponse struct {
	// The text of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller.
	Content string `pulumi:"content"`
	// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
	MimeType string `pulumi:"mimeType"`
}

// DocumentationResponseInput is an input type that accepts DocumentationResponseArgs and DocumentationResponseOutput values.
// You can construct a concrete instance of `DocumentationResponseInput` via:
//
//          DocumentationResponseArgs{...}
type DocumentationResponseInput interface {
	pulumi.Input

	ToDocumentationResponseOutput() DocumentationResponseOutput
	ToDocumentationResponseOutputWithContext(context.Context) DocumentationResponseOutput
}

// A content string and a MIME type that describes the content string's format.
type DocumentationResponseArgs struct {
	// The text of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller.
	Content pulumi.StringInput `pulumi:"content"`
	// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
	MimeType pulumi.StringInput `pulumi:"mimeType"`
}

func (DocumentationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DocumentationResponse)(nil)).Elem()
}

func (i DocumentationResponseArgs) ToDocumentationResponseOutput() DocumentationResponseOutput {
	return i.ToDocumentationResponseOutputWithContext(context.Background())
}

func (i DocumentationResponseArgs) ToDocumentationResponseOutputWithContext(ctx context.Context) DocumentationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentationResponseOutput)
}

func (i DocumentationResponseArgs) ToDocumentationResponsePtrOutput() DocumentationResponsePtrOutput {
	return i.ToDocumentationResponsePtrOutputWithContext(context.Background())
}

func (i DocumentationResponseArgs) ToDocumentationResponsePtrOutputWithContext(ctx context.Context) DocumentationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentationResponseOutput).ToDocumentationResponsePtrOutputWithContext(ctx)
}

// DocumentationResponsePtrInput is an input type that accepts DocumentationResponseArgs, DocumentationResponsePtr and DocumentationResponsePtrOutput values.
// You can construct a concrete instance of `DocumentationResponsePtrInput` via:
//
//          DocumentationResponseArgs{...}
//
//  or:
//
//          nil
type DocumentationResponsePtrInput interface {
	pulumi.Input

	ToDocumentationResponsePtrOutput() DocumentationResponsePtrOutput
	ToDocumentationResponsePtrOutputWithContext(context.Context) DocumentationResponsePtrOutput
}

type documentationResponsePtrType DocumentationResponseArgs

func DocumentationResponsePtr(v *DocumentationResponseArgs) DocumentationResponsePtrInput {
	return (*documentationResponsePtrType)(v)
}

func (*documentationResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DocumentationResponse)(nil)).Elem()
}

func (i *documentationResponsePtrType) ToDocumentationResponsePtrOutput() DocumentationResponsePtrOutput {
	return i.ToDocumentationResponsePtrOutputWithContext(context.Background())
}

func (i *documentationResponsePtrType) ToDocumentationResponsePtrOutputWithContext(ctx context.Context) DocumentationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentationResponsePtrOutput)
}

// A content string and a MIME type that describes the content string's format.
type DocumentationResponseOutput struct{ *pulumi.OutputState }

func (DocumentationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DocumentationResponse)(nil)).Elem()
}

func (o DocumentationResponseOutput) ToDocumentationResponseOutput() DocumentationResponseOutput {
	return o
}

func (o DocumentationResponseOutput) ToDocumentationResponseOutputWithContext(ctx context.Context) DocumentationResponseOutput {
	return o
}

func (o DocumentationResponseOutput) ToDocumentationResponsePtrOutput() DocumentationResponsePtrOutput {
	return o.ToDocumentationResponsePtrOutputWithContext(context.Background())
}

func (o DocumentationResponseOutput) ToDocumentationResponsePtrOutputWithContext(ctx context.Context) DocumentationResponsePtrOutput {
	return o.ApplyT(func(v DocumentationResponse) *DocumentationResponse {
		return &v
	}).(DocumentationResponsePtrOutput)
}

// The text of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller.
func (o DocumentationResponseOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v DocumentationResponse) string { return v.Content }).(pulumi.StringOutput)
}

// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
func (o DocumentationResponseOutput) MimeType() pulumi.StringOutput {
	return o.ApplyT(func(v DocumentationResponse) string { return v.MimeType }).(pulumi.StringOutput)
}

type DocumentationResponsePtrOutput struct{ *pulumi.OutputState }

func (DocumentationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DocumentationResponse)(nil)).Elem()
}

func (o DocumentationResponsePtrOutput) ToDocumentationResponsePtrOutput() DocumentationResponsePtrOutput {
	return o
}

func (o DocumentationResponsePtrOutput) ToDocumentationResponsePtrOutputWithContext(ctx context.Context) DocumentationResponsePtrOutput {
	return o
}

func (o DocumentationResponsePtrOutput) Elem() DocumentationResponseOutput {
	return o.ApplyT(func(v *DocumentationResponse) DocumentationResponse { return *v }).(DocumentationResponseOutput)
}

// The text of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller.
func (o DocumentationResponsePtrOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Content
	}).(pulumi.StringPtrOutput)
}

// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
func (o DocumentationResponsePtrOutput) MimeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.MimeType
	}).(pulumi.StringPtrOutput)
}

// Exemplars are example points that may be used to annotate aggregated distribution values. They are metadata that gives information about a particular value added to a Distribution bucket, such as a trace ID that was active when a value was added. They may contain further information, such as a example values and timestamps, origin, etc.
type Exemplar struct {
	// Contextual information about the example value. Examples are:Trace: type.googleapis.com/google.monitoring.v3.SpanContextLiteral string: type.googleapis.com/google.protobuf.StringValueLabels dropped during aggregation: type.googleapis.com/google.monitoring.v3.DroppedLabelsThere may be only a single attachment of any given message type in a single exemplar, and this is enforced by the system.
	Attachments []map[string]string `pulumi:"attachments"`
	// The observation (sampling) time of the above value.
	Timestamp *string `pulumi:"timestamp"`
	// Value of the exemplar point. This value determines to which bucket the exemplar belongs.
	Value *float64 `pulumi:"value"`
}

// ExemplarInput is an input type that accepts ExemplarArgs and ExemplarOutput values.
// You can construct a concrete instance of `ExemplarInput` via:
//
//          ExemplarArgs{...}
type ExemplarInput interface {
	pulumi.Input

	ToExemplarOutput() ExemplarOutput
	ToExemplarOutputWithContext(context.Context) ExemplarOutput
}

// Exemplars are example points that may be used to annotate aggregated distribution values. They are metadata that gives information about a particular value added to a Distribution bucket, such as a trace ID that was active when a value was added. They may contain further information, such as a example values and timestamps, origin, etc.
type ExemplarArgs struct {
	// Contextual information about the example value. Examples are:Trace: type.googleapis.com/google.monitoring.v3.SpanContextLiteral string: type.googleapis.com/google.protobuf.StringValueLabels dropped during aggregation: type.googleapis.com/google.monitoring.v3.DroppedLabelsThere may be only a single attachment of any given message type in a single exemplar, and this is enforced by the system.
	Attachments pulumi.StringMapArrayInput `pulumi:"attachments"`
	// The observation (sampling) time of the above value.
	Timestamp pulumi.StringPtrInput `pulumi:"timestamp"`
	// Value of the exemplar point. This value determines to which bucket the exemplar belongs.
	Value pulumi.Float64PtrInput `pulumi:"value"`
}

func (ExemplarArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Exemplar)(nil)).Elem()
}

func (i ExemplarArgs) ToExemplarOutput() ExemplarOutput {
	return i.ToExemplarOutputWithContext(context.Background())
}

func (i ExemplarArgs) ToExemplarOutputWithContext(ctx context.Context) ExemplarOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExemplarOutput)
}

// ExemplarArrayInput is an input type that accepts ExemplarArray and ExemplarArrayOutput values.
// You can construct a concrete instance of `ExemplarArrayInput` via:
//
//          ExemplarArray{ ExemplarArgs{...} }
type ExemplarArrayInput interface {
	pulumi.Input

	ToExemplarArrayOutput() ExemplarArrayOutput
	ToExemplarArrayOutputWithContext(context.Context) ExemplarArrayOutput
}

type ExemplarArray []ExemplarInput

func (ExemplarArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Exemplar)(nil)).Elem()
}

func (i ExemplarArray) ToExemplarArrayOutput() ExemplarArrayOutput {
	return i.ToExemplarArrayOutputWithContext(context.Background())
}

func (i ExemplarArray) ToExemplarArrayOutputWithContext(ctx context.Context) ExemplarArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExemplarArrayOutput)
}

// Exemplars are example points that may be used to annotate aggregated distribution values. They are metadata that gives information about a particular value added to a Distribution bucket, such as a trace ID that was active when a value was added. They may contain further information, such as a example values and timestamps, origin, etc.
type ExemplarOutput struct{ *pulumi.OutputState }

func (ExemplarOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Exemplar)(nil)).Elem()
}

func (o ExemplarOutput) ToExemplarOutput() ExemplarOutput {
	return o
}

func (o ExemplarOutput) ToExemplarOutputWithContext(ctx context.Context) ExemplarOutput {
	return o
}

// Contextual information about the example value. Examples are:Trace: type.googleapis.com/google.monitoring.v3.SpanContextLiteral string: type.googleapis.com/google.protobuf.StringValueLabels dropped during aggregation: type.googleapis.com/google.monitoring.v3.DroppedLabelsThere may be only a single attachment of any given message type in a single exemplar, and this is enforced by the system.
func (o ExemplarOutput) Attachments() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v Exemplar) []map[string]string { return v.Attachments }).(pulumi.StringMapArrayOutput)
}

// The observation (sampling) time of the above value.
func (o ExemplarOutput) Timestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Exemplar) *string { return v.Timestamp }).(pulumi.StringPtrOutput)
}

// Value of the exemplar point. This value determines to which bucket the exemplar belongs.
func (o ExemplarOutput) Value() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Exemplar) *float64 { return v.Value }).(pulumi.Float64PtrOutput)
}

type ExemplarArrayOutput struct{ *pulumi.OutputState }

func (ExemplarArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Exemplar)(nil)).Elem()
}

func (o ExemplarArrayOutput) ToExemplarArrayOutput() ExemplarArrayOutput {
	return o
}

func (o ExemplarArrayOutput) ToExemplarArrayOutputWithContext(ctx context.Context) ExemplarArrayOutput {
	return o
}

func (o ExemplarArrayOutput) Index(i pulumi.IntInput) ExemplarOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Exemplar {
		return vs[0].([]Exemplar)[vs[1].(int)]
	}).(ExemplarOutput)
}

// Specifies a set of buckets with arbitrary widths.There are size(bounds) + 1 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): boundsi Lower bound (1 <= i < N); boundsi - 1The bounds field must contain at least one element. If bounds has only one element, then there are no finite buckets, and that single element is the common boundary of the overflow and underflow buckets.
type Explicit struct {
	// The values must be monotonically increasing.
	Bounds []float64 `pulumi:"bounds"`
}

// ExplicitInput is an input type that accepts ExplicitArgs and ExplicitOutput values.
// You can construct a concrete instance of `ExplicitInput` via:
//
//          ExplicitArgs{...}
type ExplicitInput interface {
	pulumi.Input

	ToExplicitOutput() ExplicitOutput
	ToExplicitOutputWithContext(context.Context) ExplicitOutput
}

// Specifies a set of buckets with arbitrary widths.There are size(bounds) + 1 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): boundsi Lower bound (1 <= i < N); boundsi - 1The bounds field must contain at least one element. If bounds has only one element, then there are no finite buckets, and that single element is the common boundary of the overflow and underflow buckets.
type ExplicitArgs struct {
	// The values must be monotonically increasing.
	Bounds pulumi.Float64ArrayInput `pulumi:"bounds"`
}

func (ExplicitArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Explicit)(nil)).Elem()
}

func (i ExplicitArgs) ToExplicitOutput() ExplicitOutput {
	return i.ToExplicitOutputWithContext(context.Background())
}

func (i ExplicitArgs) ToExplicitOutputWithContext(ctx context.Context) ExplicitOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExplicitOutput)
}

func (i ExplicitArgs) ToExplicitPtrOutput() ExplicitPtrOutput {
	return i.ToExplicitPtrOutputWithContext(context.Background())
}

func (i ExplicitArgs) ToExplicitPtrOutputWithContext(ctx context.Context) ExplicitPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExplicitOutput).ToExplicitPtrOutputWithContext(ctx)
}

// ExplicitPtrInput is an input type that accepts ExplicitArgs, ExplicitPtr and ExplicitPtrOutput values.
// You can construct a concrete instance of `ExplicitPtrInput` via:
//
//          ExplicitArgs{...}
//
//  or:
//
//          nil
type ExplicitPtrInput interface {
	pulumi.Input

	ToExplicitPtrOutput() ExplicitPtrOutput
	ToExplicitPtrOutputWithContext(context.Context) ExplicitPtrOutput
}

type explicitPtrType ExplicitArgs

func ExplicitPtr(v *ExplicitArgs) ExplicitPtrInput {
	return (*explicitPtrType)(v)
}

func (*explicitPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Explicit)(nil)).Elem()
}

func (i *explicitPtrType) ToExplicitPtrOutput() ExplicitPtrOutput {
	return i.ToExplicitPtrOutputWithContext(context.Background())
}

func (i *explicitPtrType) ToExplicitPtrOutputWithContext(ctx context.Context) ExplicitPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExplicitPtrOutput)
}

// Specifies a set of buckets with arbitrary widths.There are size(bounds) + 1 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): boundsi Lower bound (1 <= i < N); boundsi - 1The bounds field must contain at least one element. If bounds has only one element, then there are no finite buckets, and that single element is the common boundary of the overflow and underflow buckets.
type ExplicitOutput struct{ *pulumi.OutputState }

func (ExplicitOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Explicit)(nil)).Elem()
}

func (o ExplicitOutput) ToExplicitOutput() ExplicitOutput {
	return o
}

func (o ExplicitOutput) ToExplicitOutputWithContext(ctx context.Context) ExplicitOutput {
	return o
}

func (o ExplicitOutput) ToExplicitPtrOutput() ExplicitPtrOutput {
	return o.ToExplicitPtrOutputWithContext(context.Background())
}

func (o ExplicitOutput) ToExplicitPtrOutputWithContext(ctx context.Context) ExplicitPtrOutput {
	return o.ApplyT(func(v Explicit) *Explicit {
		return &v
	}).(ExplicitPtrOutput)
}

// The values must be monotonically increasing.
func (o ExplicitOutput) Bounds() pulumi.Float64ArrayOutput {
	return o.ApplyT(func(v Explicit) []float64 { return v.Bounds }).(pulumi.Float64ArrayOutput)
}

type ExplicitPtrOutput struct{ *pulumi.OutputState }

func (ExplicitPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Explicit)(nil)).Elem()
}

func (o ExplicitPtrOutput) ToExplicitPtrOutput() ExplicitPtrOutput {
	return o
}

func (o ExplicitPtrOutput) ToExplicitPtrOutputWithContext(ctx context.Context) ExplicitPtrOutput {
	return o
}

func (o ExplicitPtrOutput) Elem() ExplicitOutput {
	return o.ApplyT(func(v *Explicit) Explicit { return *v }).(ExplicitOutput)
}

// The values must be monotonically increasing.
func (o ExplicitPtrOutput) Bounds() pulumi.Float64ArrayOutput {
	return o.ApplyT(func(v *Explicit) []float64 {
		if v == nil {
			return nil
		}
		return v.Bounds
	}).(pulumi.Float64ArrayOutput)
}

// Specifies an exponential sequence of buckets that have a width that is proportional to the value of the lower bound. Each bucket represents a constant relative uncertainty on a specific value in the bucket.There are num_finite_buckets + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): scale * (growth_factor ^ i). Lower bound (1 <= i < N): scale * (growth_factor ^ (i - 1)).
type Exponential struct {
	// Must be greater than 1.
	GrowthFactor *float64 `pulumi:"growthFactor"`
	// Must be greater than 0.
	NumFiniteBuckets *int `pulumi:"numFiniteBuckets"`
	// Must be greater than 0.
	Scale *float64 `pulumi:"scale"`
}

// ExponentialInput is an input type that accepts ExponentialArgs and ExponentialOutput values.
// You can construct a concrete instance of `ExponentialInput` via:
//
//          ExponentialArgs{...}
type ExponentialInput interface {
	pulumi.Input

	ToExponentialOutput() ExponentialOutput
	ToExponentialOutputWithContext(context.Context) ExponentialOutput
}

// Specifies an exponential sequence of buckets that have a width that is proportional to the value of the lower bound. Each bucket represents a constant relative uncertainty on a specific value in the bucket.There are num_finite_buckets + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): scale * (growth_factor ^ i). Lower bound (1 <= i < N): scale * (growth_factor ^ (i - 1)).
type ExponentialArgs struct {
	// Must be greater than 1.
	GrowthFactor pulumi.Float64PtrInput `pulumi:"growthFactor"`
	// Must be greater than 0.
	NumFiniteBuckets pulumi.IntPtrInput `pulumi:"numFiniteBuckets"`
	// Must be greater than 0.
	Scale pulumi.Float64PtrInput `pulumi:"scale"`
}

func (ExponentialArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Exponential)(nil)).Elem()
}

func (i ExponentialArgs) ToExponentialOutput() ExponentialOutput {
	return i.ToExponentialOutputWithContext(context.Background())
}

func (i ExponentialArgs) ToExponentialOutputWithContext(ctx context.Context) ExponentialOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExponentialOutput)
}

func (i ExponentialArgs) ToExponentialPtrOutput() ExponentialPtrOutput {
	return i.ToExponentialPtrOutputWithContext(context.Background())
}

func (i ExponentialArgs) ToExponentialPtrOutputWithContext(ctx context.Context) ExponentialPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExponentialOutput).ToExponentialPtrOutputWithContext(ctx)
}

// ExponentialPtrInput is an input type that accepts ExponentialArgs, ExponentialPtr and ExponentialPtrOutput values.
// You can construct a concrete instance of `ExponentialPtrInput` via:
//
//          ExponentialArgs{...}
//
//  or:
//
//          nil
type ExponentialPtrInput interface {
	pulumi.Input

	ToExponentialPtrOutput() ExponentialPtrOutput
	ToExponentialPtrOutputWithContext(context.Context) ExponentialPtrOutput
}

type exponentialPtrType ExponentialArgs

func ExponentialPtr(v *ExponentialArgs) ExponentialPtrInput {
	return (*exponentialPtrType)(v)
}

func (*exponentialPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Exponential)(nil)).Elem()
}

func (i *exponentialPtrType) ToExponentialPtrOutput() ExponentialPtrOutput {
	return i.ToExponentialPtrOutputWithContext(context.Background())
}

func (i *exponentialPtrType) ToExponentialPtrOutputWithContext(ctx context.Context) ExponentialPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExponentialPtrOutput)
}

// Specifies an exponential sequence of buckets that have a width that is proportional to the value of the lower bound. Each bucket represents a constant relative uncertainty on a specific value in the bucket.There are num_finite_buckets + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): scale * (growth_factor ^ i). Lower bound (1 <= i < N): scale * (growth_factor ^ (i - 1)).
type ExponentialOutput struct{ *pulumi.OutputState }

func (ExponentialOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Exponential)(nil)).Elem()
}

func (o ExponentialOutput) ToExponentialOutput() ExponentialOutput {
	return o
}

func (o ExponentialOutput) ToExponentialOutputWithContext(ctx context.Context) ExponentialOutput {
	return o
}

func (o ExponentialOutput) ToExponentialPtrOutput() ExponentialPtrOutput {
	return o.ToExponentialPtrOutputWithContext(context.Background())
}

func (o ExponentialOutput) ToExponentialPtrOutputWithContext(ctx context.Context) ExponentialPtrOutput {
	return o.ApplyT(func(v Exponential) *Exponential {
		return &v
	}).(ExponentialPtrOutput)
}

// Must be greater than 1.
func (o ExponentialOutput) GrowthFactor() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Exponential) *float64 { return v.GrowthFactor }).(pulumi.Float64PtrOutput)
}

// Must be greater than 0.
func (o ExponentialOutput) NumFiniteBuckets() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Exponential) *int { return v.NumFiniteBuckets }).(pulumi.IntPtrOutput)
}

// Must be greater than 0.
func (o ExponentialOutput) Scale() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Exponential) *float64 { return v.Scale }).(pulumi.Float64PtrOutput)
}

type ExponentialPtrOutput struct{ *pulumi.OutputState }

func (ExponentialPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Exponential)(nil)).Elem()
}

func (o ExponentialPtrOutput) ToExponentialPtrOutput() ExponentialPtrOutput {
	return o
}

func (o ExponentialPtrOutput) ToExponentialPtrOutputWithContext(ctx context.Context) ExponentialPtrOutput {
	return o
}

func (o ExponentialPtrOutput) Elem() ExponentialOutput {
	return o.ApplyT(func(v *Exponential) Exponential { return *v }).(ExponentialOutput)
}

// Must be greater than 1.
func (o ExponentialPtrOutput) GrowthFactor() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Exponential) *float64 {
		if v == nil {
			return nil
		}
		return v.GrowthFactor
	}).(pulumi.Float64PtrOutput)
}

// Must be greater than 0.
func (o ExponentialPtrOutput) NumFiniteBuckets() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Exponential) *int {
		if v == nil {
			return nil
		}
		return v.NumFiniteBuckets
	}).(pulumi.IntPtrOutput)
}

// Must be greater than 0.
func (o ExponentialPtrOutput) Scale() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Exponential) *float64 {
		if v == nil {
			return nil
		}
		return v.Scale
	}).(pulumi.Float64PtrOutput)
}

// Range of numerical values, inclusive of min and exclusive of max. If the open range "< range.max" is desired, set range.min = -infinity. If the open range ">= range.min" is desired, set range.max = infinity.
type GoogleMonitoringV3Range struct {
	// Range maximum.
	Max *float64 `pulumi:"max"`
	// Range minimum.
	Min *float64 `pulumi:"min"`
}

// GoogleMonitoringV3RangeInput is an input type that accepts GoogleMonitoringV3RangeArgs and GoogleMonitoringV3RangeOutput values.
// You can construct a concrete instance of `GoogleMonitoringV3RangeInput` via:
//
//          GoogleMonitoringV3RangeArgs{...}
type GoogleMonitoringV3RangeInput interface {
	pulumi.Input

	ToGoogleMonitoringV3RangeOutput() GoogleMonitoringV3RangeOutput
	ToGoogleMonitoringV3RangeOutputWithContext(context.Context) GoogleMonitoringV3RangeOutput
}

// Range of numerical values, inclusive of min and exclusive of max. If the open range "< range.max" is desired, set range.min = -infinity. If the open range ">= range.min" is desired, set range.max = infinity.
type GoogleMonitoringV3RangeArgs struct {
	// Range maximum.
	Max pulumi.Float64PtrInput `pulumi:"max"`
	// Range minimum.
	Min pulumi.Float64PtrInput `pulumi:"min"`
}

func (GoogleMonitoringV3RangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleMonitoringV3Range)(nil)).Elem()
}

func (i GoogleMonitoringV3RangeArgs) ToGoogleMonitoringV3RangeOutput() GoogleMonitoringV3RangeOutput {
	return i.ToGoogleMonitoringV3RangeOutputWithContext(context.Background())
}

func (i GoogleMonitoringV3RangeArgs) ToGoogleMonitoringV3RangeOutputWithContext(ctx context.Context) GoogleMonitoringV3RangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleMonitoringV3RangeOutput)
}

func (i GoogleMonitoringV3RangeArgs) ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput {
	return i.ToGoogleMonitoringV3RangePtrOutputWithContext(context.Background())
}

func (i GoogleMonitoringV3RangeArgs) ToGoogleMonitoringV3RangePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleMonitoringV3RangeOutput).ToGoogleMonitoringV3RangePtrOutputWithContext(ctx)
}

// GoogleMonitoringV3RangePtrInput is an input type that accepts GoogleMonitoringV3RangeArgs, GoogleMonitoringV3RangePtr and GoogleMonitoringV3RangePtrOutput values.
// You can construct a concrete instance of `GoogleMonitoringV3RangePtrInput` via:
//
//          GoogleMonitoringV3RangeArgs{...}
//
//  or:
//
//          nil
type GoogleMonitoringV3RangePtrInput interface {
	pulumi.Input

	ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput
	ToGoogleMonitoringV3RangePtrOutputWithContext(context.Context) GoogleMonitoringV3RangePtrOutput
}

type googleMonitoringV3RangePtrType GoogleMonitoringV3RangeArgs

func GoogleMonitoringV3RangePtr(v *GoogleMonitoringV3RangeArgs) GoogleMonitoringV3RangePtrInput {
	return (*googleMonitoringV3RangePtrType)(v)
}

func (*googleMonitoringV3RangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleMonitoringV3Range)(nil)).Elem()
}

func (i *googleMonitoringV3RangePtrType) ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput {
	return i.ToGoogleMonitoringV3RangePtrOutputWithContext(context.Background())
}

func (i *googleMonitoringV3RangePtrType) ToGoogleMonitoringV3RangePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleMonitoringV3RangePtrOutput)
}

// Range of numerical values, inclusive of min and exclusive of max. If the open range "< range.max" is desired, set range.min = -infinity. If the open range ">= range.min" is desired, set range.max = infinity.
type GoogleMonitoringV3RangeOutput struct{ *pulumi.OutputState }

func (GoogleMonitoringV3RangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleMonitoringV3Range)(nil)).Elem()
}

func (o GoogleMonitoringV3RangeOutput) ToGoogleMonitoringV3RangeOutput() GoogleMonitoringV3RangeOutput {
	return o
}

func (o GoogleMonitoringV3RangeOutput) ToGoogleMonitoringV3RangeOutputWithContext(ctx context.Context) GoogleMonitoringV3RangeOutput {
	return o
}

func (o GoogleMonitoringV3RangeOutput) ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput {
	return o.ToGoogleMonitoringV3RangePtrOutputWithContext(context.Background())
}

func (o GoogleMonitoringV3RangeOutput) ToGoogleMonitoringV3RangePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangePtrOutput {
	return o.ApplyT(func(v GoogleMonitoringV3Range) *GoogleMonitoringV3Range {
		return &v
	}).(GoogleMonitoringV3RangePtrOutput)
}

// Range maximum.
func (o GoogleMonitoringV3RangeOutput) Max() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v GoogleMonitoringV3Range) *float64 { return v.Max }).(pulumi.Float64PtrOutput)
}

// Range minimum.
func (o GoogleMonitoringV3RangeOutput) Min() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v GoogleMonitoringV3Range) *float64 { return v.Min }).(pulumi.Float64PtrOutput)
}

type GoogleMonitoringV3RangePtrOutput struct{ *pulumi.OutputState }

func (GoogleMonitoringV3RangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleMonitoringV3Range)(nil)).Elem()
}

func (o GoogleMonitoringV3RangePtrOutput) ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput {
	return o
}

func (o GoogleMonitoringV3RangePtrOutput) ToGoogleMonitoringV3RangePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangePtrOutput {
	return o
}

func (o GoogleMonitoringV3RangePtrOutput) Elem() GoogleMonitoringV3RangeOutput {
	return o.ApplyT(func(v *GoogleMonitoringV3Range) GoogleMonitoringV3Range { return *v }).(GoogleMonitoringV3RangeOutput)
}

// Range maximum.
func (o GoogleMonitoringV3RangePtrOutput) Max() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GoogleMonitoringV3Range) *float64 {
		if v == nil {
			return nil
		}
		return v.Max
	}).(pulumi.Float64PtrOutput)
}

// Range minimum.
func (o GoogleMonitoringV3RangePtrOutput) Min() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GoogleMonitoringV3Range) *float64 {
		if v == nil {
			return nil
		}
		return v.Min
	}).(pulumi.Float64PtrOutput)
}

// Range of numerical values, inclusive of min and exclusive of max. If the open range "< range.max" is desired, set range.min = -infinity. If the open range ">= range.min" is desired, set range.max = infinity.
type GoogleMonitoringV3RangeResponse struct {
	// Range maximum.
	Max float64 `pulumi:"max"`
	// Range minimum.
	Min float64 `pulumi:"min"`
}

// GoogleMonitoringV3RangeResponseInput is an input type that accepts GoogleMonitoringV3RangeResponseArgs and GoogleMonitoringV3RangeResponseOutput values.
// You can construct a concrete instance of `GoogleMonitoringV3RangeResponseInput` via:
//
//          GoogleMonitoringV3RangeResponseArgs{...}
type GoogleMonitoringV3RangeResponseInput interface {
	pulumi.Input

	ToGoogleMonitoringV3RangeResponseOutput() GoogleMonitoringV3RangeResponseOutput
	ToGoogleMonitoringV3RangeResponseOutputWithContext(context.Context) GoogleMonitoringV3RangeResponseOutput
}

// Range of numerical values, inclusive of min and exclusive of max. If the open range "< range.max" is desired, set range.min = -infinity. If the open range ">= range.min" is desired, set range.max = infinity.
type GoogleMonitoringV3RangeResponseArgs struct {
	// Range maximum.
	Max pulumi.Float64Input `pulumi:"max"`
	// Range minimum.
	Min pulumi.Float64Input `pulumi:"min"`
}

func (GoogleMonitoringV3RangeResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleMonitoringV3RangeResponse)(nil)).Elem()
}

func (i GoogleMonitoringV3RangeResponseArgs) ToGoogleMonitoringV3RangeResponseOutput() GoogleMonitoringV3RangeResponseOutput {
	return i.ToGoogleMonitoringV3RangeResponseOutputWithContext(context.Background())
}

func (i GoogleMonitoringV3RangeResponseArgs) ToGoogleMonitoringV3RangeResponseOutputWithContext(ctx context.Context) GoogleMonitoringV3RangeResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleMonitoringV3RangeResponseOutput)
}

func (i GoogleMonitoringV3RangeResponseArgs) ToGoogleMonitoringV3RangeResponsePtrOutput() GoogleMonitoringV3RangeResponsePtrOutput {
	return i.ToGoogleMonitoringV3RangeResponsePtrOutputWithContext(context.Background())
}

func (i GoogleMonitoringV3RangeResponseArgs) ToGoogleMonitoringV3RangeResponsePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangeResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleMonitoringV3RangeResponseOutput).ToGoogleMonitoringV3RangeResponsePtrOutputWithContext(ctx)
}

// GoogleMonitoringV3RangeResponsePtrInput is an input type that accepts GoogleMonitoringV3RangeResponseArgs, GoogleMonitoringV3RangeResponsePtr and GoogleMonitoringV3RangeResponsePtrOutput values.
// You can construct a concrete instance of `GoogleMonitoringV3RangeResponsePtrInput` via:
//
//          GoogleMonitoringV3RangeResponseArgs{...}
//
//  or:
//
//          nil
type GoogleMonitoringV3RangeResponsePtrInput interface {
	pulumi.Input

	ToGoogleMonitoringV3RangeResponsePtrOutput() GoogleMonitoringV3RangeResponsePtrOutput
	ToGoogleMonitoringV3RangeResponsePtrOutputWithContext(context.Context) GoogleMonitoringV3RangeResponsePtrOutput
}

type googleMonitoringV3RangeResponsePtrType GoogleMonitoringV3RangeResponseArgs

func GoogleMonitoringV3RangeResponsePtr(v *GoogleMonitoringV3RangeResponseArgs) GoogleMonitoringV3RangeResponsePtrInput {
	return (*googleMonitoringV3RangeResponsePtrType)(v)
}

func (*googleMonitoringV3RangeResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleMonitoringV3RangeResponse)(nil)).Elem()
}

func (i *googleMonitoringV3RangeResponsePtrType) ToGoogleMonitoringV3RangeResponsePtrOutput() GoogleMonitoringV3RangeResponsePtrOutput {
	return i.ToGoogleMonitoringV3RangeResponsePtrOutputWithContext(context.Background())
}

func (i *googleMonitoringV3RangeResponsePtrType) ToGoogleMonitoringV3RangeResponsePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangeResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleMonitoringV3RangeResponsePtrOutput)
}

// Range of numerical values, inclusive of min and exclusive of max. If the open range "< range.max" is desired, set range.min = -infinity. If the open range ">= range.min" is desired, set range.max = infinity.
type GoogleMonitoringV3RangeResponseOutput struct{ *pulumi.OutputState }

func (GoogleMonitoringV3RangeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleMonitoringV3RangeResponse)(nil)).Elem()
}

func (o GoogleMonitoringV3RangeResponseOutput) ToGoogleMonitoringV3RangeResponseOutput() GoogleMonitoringV3RangeResponseOutput {
	return o
}

func (o GoogleMonitoringV3RangeResponseOutput) ToGoogleMonitoringV3RangeResponseOutputWithContext(ctx context.Context) GoogleMonitoringV3RangeResponseOutput {
	return o
}

func (o GoogleMonitoringV3RangeResponseOutput) ToGoogleMonitoringV3RangeResponsePtrOutput() GoogleMonitoringV3RangeResponsePtrOutput {
	return o.ToGoogleMonitoringV3RangeResponsePtrOutputWithContext(context.Background())
}

func (o GoogleMonitoringV3RangeResponseOutput) ToGoogleMonitoringV3RangeResponsePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangeResponsePtrOutput {
	return o.ApplyT(func(v GoogleMonitoringV3RangeResponse) *GoogleMonitoringV3RangeResponse {
		return &v
	}).(GoogleMonitoringV3RangeResponsePtrOutput)
}

// Range maximum.
func (o GoogleMonitoringV3RangeResponseOutput) Max() pulumi.Float64Output {
	return o.ApplyT(func(v GoogleMonitoringV3RangeResponse) float64 { return v.Max }).(pulumi.Float64Output)
}

// Range minimum.
func (o GoogleMonitoringV3RangeResponseOutput) Min() pulumi.Float64Output {
	return o.ApplyT(func(v GoogleMonitoringV3RangeResponse) float64 { return v.Min }).(pulumi.Float64Output)
}

type GoogleMonitoringV3RangeResponsePtrOutput struct{ *pulumi.OutputState }

func (GoogleMonitoringV3RangeResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleMonitoringV3RangeResponse)(nil)).Elem()
}

func (o GoogleMonitoringV3RangeResponsePtrOutput) ToGoogleMonitoringV3RangeResponsePtrOutput() GoogleMonitoringV3RangeResponsePtrOutput {
	return o
}

func (o GoogleMonitoringV3RangeResponsePtrOutput) ToGoogleMonitoringV3RangeResponsePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangeResponsePtrOutput {
	return o
}

func (o GoogleMonitoringV3RangeResponsePtrOutput) Elem() GoogleMonitoringV3RangeResponseOutput {
	return o.ApplyT(func(v *GoogleMonitoringV3RangeResponse) GoogleMonitoringV3RangeResponse { return *v }).(GoogleMonitoringV3RangeResponseOutput)
}

// Range maximum.
func (o GoogleMonitoringV3RangeResponsePtrOutput) Max() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GoogleMonitoringV3RangeResponse) *float64 {
		if v == nil {
			return nil
		}
		return &v.Max
	}).(pulumi.Float64PtrOutput)
}

// Range minimum.
func (o GoogleMonitoringV3RangeResponsePtrOutput) Min() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GoogleMonitoringV3RangeResponse) *float64 {
		if v == nil {
			return nil
		}
		return &v.Min
	}).(pulumi.Float64PtrOutput)
}

// Information involved in an HTTP/HTTPS Uptime check request.
type HttpCheck struct {
	// The authentication information. Optional when creating an HTTP check; defaults to empty.
	AuthInfo *BasicAuthentication `pulumi:"authInfo"`
	// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note: As with all bytes fields, JSON representations are base64 encoded. e.g.: "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
	Body *string `pulumi:"body"`
	// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
	ContentType *string `pulumi:"contentType"`
	// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
	Headers map[string]string `pulumi:"headers"`
	// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
	MaskHeaders *bool `pulumi:"maskHeaders"`
	// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
	Path *string `pulumi:"path"`
	// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
	Port *int `pulumi:"port"`
	// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
	RequestMethod *string `pulumi:"requestMethod"`
	// If true, use HTTPS instead of HTTP to run the check.
	UseSsl *bool `pulumi:"useSsl"`
	// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
	ValidateSsl *bool `pulumi:"validateSsl"`
}

// HttpCheckInput is an input type that accepts HttpCheckArgs and HttpCheckOutput values.
// You can construct a concrete instance of `HttpCheckInput` via:
//
//          HttpCheckArgs{...}
type HttpCheckInput interface {
	pulumi.Input

	ToHttpCheckOutput() HttpCheckOutput
	ToHttpCheckOutputWithContext(context.Context) HttpCheckOutput
}

// Information involved in an HTTP/HTTPS Uptime check request.
type HttpCheckArgs struct {
	// The authentication information. Optional when creating an HTTP check; defaults to empty.
	AuthInfo BasicAuthenticationPtrInput `pulumi:"authInfo"`
	// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note: As with all bytes fields, JSON representations are base64 encoded. e.g.: "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
	Body pulumi.StringPtrInput `pulumi:"body"`
	// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
	ContentType pulumi.StringPtrInput `pulumi:"contentType"`
	// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
	Headers pulumi.StringMapInput `pulumi:"headers"`
	// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
	MaskHeaders pulumi.BoolPtrInput `pulumi:"maskHeaders"`
	// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
	Path pulumi.StringPtrInput `pulumi:"path"`
	// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
	RequestMethod pulumi.StringPtrInput `pulumi:"requestMethod"`
	// If true, use HTTPS instead of HTTP to run the check.
	UseSsl pulumi.BoolPtrInput `pulumi:"useSsl"`
	// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
	ValidateSsl pulumi.BoolPtrInput `pulumi:"validateSsl"`
}

func (HttpCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HttpCheck)(nil)).Elem()
}

func (i HttpCheckArgs) ToHttpCheckOutput() HttpCheckOutput {
	return i.ToHttpCheckOutputWithContext(context.Background())
}

func (i HttpCheckArgs) ToHttpCheckOutputWithContext(ctx context.Context) HttpCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpCheckOutput)
}

func (i HttpCheckArgs) ToHttpCheckPtrOutput() HttpCheckPtrOutput {
	return i.ToHttpCheckPtrOutputWithContext(context.Background())
}

func (i HttpCheckArgs) ToHttpCheckPtrOutputWithContext(ctx context.Context) HttpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpCheckOutput).ToHttpCheckPtrOutputWithContext(ctx)
}

// HttpCheckPtrInput is an input type that accepts HttpCheckArgs, HttpCheckPtr and HttpCheckPtrOutput values.
// You can construct a concrete instance of `HttpCheckPtrInput` via:
//
//          HttpCheckArgs{...}
//
//  or:
//
//          nil
type HttpCheckPtrInput interface {
	pulumi.Input

	ToHttpCheckPtrOutput() HttpCheckPtrOutput
	ToHttpCheckPtrOutputWithContext(context.Context) HttpCheckPtrOutput
}

type httpCheckPtrType HttpCheckArgs

func HttpCheckPtr(v *HttpCheckArgs) HttpCheckPtrInput {
	return (*httpCheckPtrType)(v)
}

func (*httpCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HttpCheck)(nil)).Elem()
}

func (i *httpCheckPtrType) ToHttpCheckPtrOutput() HttpCheckPtrOutput {
	return i.ToHttpCheckPtrOutputWithContext(context.Background())
}

func (i *httpCheckPtrType) ToHttpCheckPtrOutputWithContext(ctx context.Context) HttpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpCheckPtrOutput)
}

// Information involved in an HTTP/HTTPS Uptime check request.
type HttpCheckOutput struct{ *pulumi.OutputState }

func (HttpCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HttpCheck)(nil)).Elem()
}

func (o HttpCheckOutput) ToHttpCheckOutput() HttpCheckOutput {
	return o
}

func (o HttpCheckOutput) ToHttpCheckOutputWithContext(ctx context.Context) HttpCheckOutput {
	return o
}

func (o HttpCheckOutput) ToHttpCheckPtrOutput() HttpCheckPtrOutput {
	return o.ToHttpCheckPtrOutputWithContext(context.Background())
}

func (o HttpCheckOutput) ToHttpCheckPtrOutputWithContext(ctx context.Context) HttpCheckPtrOutput {
	return o.ApplyT(func(v HttpCheck) *HttpCheck {
		return &v
	}).(HttpCheckPtrOutput)
}

// The authentication information. Optional when creating an HTTP check; defaults to empty.
func (o HttpCheckOutput) AuthInfo() BasicAuthenticationPtrOutput {
	return o.ApplyT(func(v HttpCheck) *BasicAuthentication { return v.AuthInfo }).(BasicAuthenticationPtrOutput)
}

// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note: As with all bytes fields, JSON representations are base64 encoded. e.g.: "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
func (o HttpCheckOutput) Body() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HttpCheck) *string { return v.Body }).(pulumi.StringPtrOutput)
}

// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
func (o HttpCheckOutput) ContentType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HttpCheck) *string { return v.ContentType }).(pulumi.StringPtrOutput)
}

// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
func (o HttpCheckOutput) Headers() pulumi.StringMapOutput {
	return o.ApplyT(func(v HttpCheck) map[string]string { return v.Headers }).(pulumi.StringMapOutput)
}

// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
func (o HttpCheckOutput) MaskHeaders() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HttpCheck) *bool { return v.MaskHeaders }).(pulumi.BoolPtrOutput)
}

// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
func (o HttpCheckOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HttpCheck) *string { return v.Path }).(pulumi.StringPtrOutput)
}

// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
func (o HttpCheckOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HttpCheck) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
func (o HttpCheckOutput) RequestMethod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HttpCheck) *string { return v.RequestMethod }).(pulumi.StringPtrOutput)
}

// If true, use HTTPS instead of HTTP to run the check.
func (o HttpCheckOutput) UseSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HttpCheck) *bool { return v.UseSsl }).(pulumi.BoolPtrOutput)
}

// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
func (o HttpCheckOutput) ValidateSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HttpCheck) *bool { return v.ValidateSsl }).(pulumi.BoolPtrOutput)
}

type HttpCheckPtrOutput struct{ *pulumi.OutputState }

func (HttpCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HttpCheck)(nil)).Elem()
}

func (o HttpCheckPtrOutput) ToHttpCheckPtrOutput() HttpCheckPtrOutput {
	return o
}

func (o HttpCheckPtrOutput) ToHttpCheckPtrOutputWithContext(ctx context.Context) HttpCheckPtrOutput {
	return o
}

func (o HttpCheckPtrOutput) Elem() HttpCheckOutput {
	return o.ApplyT(func(v *HttpCheck) HttpCheck { return *v }).(HttpCheckOutput)
}

// The authentication information. Optional when creating an HTTP check; defaults to empty.
func (o HttpCheckPtrOutput) AuthInfo() BasicAuthenticationPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *BasicAuthentication {
		if v == nil {
			return nil
		}
		return v.AuthInfo
	}).(BasicAuthenticationPtrOutput)
}

// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note: As with all bytes fields, JSON representations are base64 encoded. e.g.: "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
func (o HttpCheckPtrOutput) Body() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *string {
		if v == nil {
			return nil
		}
		return v.Body
	}).(pulumi.StringPtrOutput)
}

// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
func (o HttpCheckPtrOutput) ContentType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *string {
		if v == nil {
			return nil
		}
		return v.ContentType
	}).(pulumi.StringPtrOutput)
}

// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
func (o HttpCheckPtrOutput) Headers() pulumi.StringMapOutput {
	return o.ApplyT(func(v *HttpCheck) map[string]string {
		if v == nil {
			return nil
		}
		return v.Headers
	}).(pulumi.StringMapOutput)
}

// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
func (o HttpCheckPtrOutput) MaskHeaders() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *bool {
		if v == nil {
			return nil
		}
		return v.MaskHeaders
	}).(pulumi.BoolPtrOutput)
}

// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
func (o HttpCheckPtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *string {
		if v == nil {
			return nil
		}
		return v.Path
	}).(pulumi.StringPtrOutput)
}

// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
func (o HttpCheckPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
func (o HttpCheckPtrOutput) RequestMethod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *string {
		if v == nil {
			return nil
		}
		return v.RequestMethod
	}).(pulumi.StringPtrOutput)
}

// If true, use HTTPS instead of HTTP to run the check.
func (o HttpCheckPtrOutput) UseSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *bool {
		if v == nil {
			return nil
		}
		return v.UseSsl
	}).(pulumi.BoolPtrOutput)
}

// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
func (o HttpCheckPtrOutput) ValidateSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *bool {
		if v == nil {
			return nil
		}
		return v.ValidateSsl
	}).(pulumi.BoolPtrOutput)
}

// Information involved in an HTTP/HTTPS Uptime check request.
type HttpCheckResponse struct {
	// The authentication information. Optional when creating an HTTP check; defaults to empty.
	AuthInfo BasicAuthenticationResponse `pulumi:"authInfo"`
	// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note: As with all bytes fields, JSON representations are base64 encoded. e.g.: "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
	Body string `pulumi:"body"`
	// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
	ContentType string `pulumi:"contentType"`
	// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
	Headers map[string]string `pulumi:"headers"`
	// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
	MaskHeaders bool `pulumi:"maskHeaders"`
	// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
	Path string `pulumi:"path"`
	// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
	Port int `pulumi:"port"`
	// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
	RequestMethod string `pulumi:"requestMethod"`
	// If true, use HTTPS instead of HTTP to run the check.
	UseSsl bool `pulumi:"useSsl"`
	// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
	ValidateSsl bool `pulumi:"validateSsl"`
}

// HttpCheckResponseInput is an input type that accepts HttpCheckResponseArgs and HttpCheckResponseOutput values.
// You can construct a concrete instance of `HttpCheckResponseInput` via:
//
//          HttpCheckResponseArgs{...}
type HttpCheckResponseInput interface {
	pulumi.Input

	ToHttpCheckResponseOutput() HttpCheckResponseOutput
	ToHttpCheckResponseOutputWithContext(context.Context) HttpCheckResponseOutput
}

// Information involved in an HTTP/HTTPS Uptime check request.
type HttpCheckResponseArgs struct {
	// The authentication information. Optional when creating an HTTP check; defaults to empty.
	AuthInfo BasicAuthenticationResponseInput `pulumi:"authInfo"`
	// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note: As with all bytes fields, JSON representations are base64 encoded. e.g.: "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
	Body pulumi.StringInput `pulumi:"body"`
	// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
	ContentType pulumi.StringInput `pulumi:"contentType"`
	// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
	Headers pulumi.StringMapInput `pulumi:"headers"`
	// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
	MaskHeaders pulumi.BoolInput `pulumi:"maskHeaders"`
	// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
	Path pulumi.StringInput `pulumi:"path"`
	// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
	Port pulumi.IntInput `pulumi:"port"`
	// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
	RequestMethod pulumi.StringInput `pulumi:"requestMethod"`
	// If true, use HTTPS instead of HTTP to run the check.
	UseSsl pulumi.BoolInput `pulumi:"useSsl"`
	// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
	ValidateSsl pulumi.BoolInput `pulumi:"validateSsl"`
}

func (HttpCheckResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HttpCheckResponse)(nil)).Elem()
}

func (i HttpCheckResponseArgs) ToHttpCheckResponseOutput() HttpCheckResponseOutput {
	return i.ToHttpCheckResponseOutputWithContext(context.Background())
}

func (i HttpCheckResponseArgs) ToHttpCheckResponseOutputWithContext(ctx context.Context) HttpCheckResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpCheckResponseOutput)
}

func (i HttpCheckResponseArgs) ToHttpCheckResponsePtrOutput() HttpCheckResponsePtrOutput {
	return i.ToHttpCheckResponsePtrOutputWithContext(context.Background())
}

func (i HttpCheckResponseArgs) ToHttpCheckResponsePtrOutputWithContext(ctx context.Context) HttpCheckResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpCheckResponseOutput).ToHttpCheckResponsePtrOutputWithContext(ctx)
}

// HttpCheckResponsePtrInput is an input type that accepts HttpCheckResponseArgs, HttpCheckResponsePtr and HttpCheckResponsePtrOutput values.
// You can construct a concrete instance of `HttpCheckResponsePtrInput` via:
//
//          HttpCheckResponseArgs{...}
//
//  or:
//
//          nil
type HttpCheckResponsePtrInput interface {
	pulumi.Input

	ToHttpCheckResponsePtrOutput() HttpCheckResponsePtrOutput
	ToHttpCheckResponsePtrOutputWithContext(context.Context) HttpCheckResponsePtrOutput
}

type httpCheckResponsePtrType HttpCheckResponseArgs

func HttpCheckResponsePtr(v *HttpCheckResponseArgs) HttpCheckResponsePtrInput {
	return (*httpCheckResponsePtrType)(v)
}

func (*httpCheckResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HttpCheckResponse)(nil)).Elem()
}

func (i *httpCheckResponsePtrType) ToHttpCheckResponsePtrOutput() HttpCheckResponsePtrOutput {
	return i.ToHttpCheckResponsePtrOutputWithContext(context.Background())
}

func (i *httpCheckResponsePtrType) ToHttpCheckResponsePtrOutputWithContext(ctx context.Context) HttpCheckResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpCheckResponsePtrOutput)
}

// Information involved in an HTTP/HTTPS Uptime check request.
type HttpCheckResponseOutput struct{ *pulumi.OutputState }

func (HttpCheckResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HttpCheckResponse)(nil)).Elem()
}

func (o HttpCheckResponseOutput) ToHttpCheckResponseOutput() HttpCheckResponseOutput {
	return o
}

func (o HttpCheckResponseOutput) ToHttpCheckResponseOutputWithContext(ctx context.Context) HttpCheckResponseOutput {
	return o
}

func (o HttpCheckResponseOutput) ToHttpCheckResponsePtrOutput() HttpCheckResponsePtrOutput {
	return o.ToHttpCheckResponsePtrOutputWithContext(context.Background())
}

func (o HttpCheckResponseOutput) ToHttpCheckResponsePtrOutputWithContext(ctx context.Context) HttpCheckResponsePtrOutput {
	return o.ApplyT(func(v HttpCheckResponse) *HttpCheckResponse {
		return &v
	}).(HttpCheckResponsePtrOutput)
}

// The authentication information. Optional when creating an HTTP check; defaults to empty.
func (o HttpCheckResponseOutput) AuthInfo() BasicAuthenticationResponseOutput {
	return o.ApplyT(func(v HttpCheckResponse) BasicAuthenticationResponse { return v.AuthInfo }).(BasicAuthenticationResponseOutput)
}

// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note: As with all bytes fields, JSON representations are base64 encoded. e.g.: "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
func (o HttpCheckResponseOutput) Body() pulumi.StringOutput {
	return o.ApplyT(func(v HttpCheckResponse) string { return v.Body }).(pulumi.StringOutput)
}

// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
func (o HttpCheckResponseOutput) ContentType() pulumi.StringOutput {
	return o.ApplyT(func(v HttpCheckResponse) string { return v.ContentType }).(pulumi.StringOutput)
}

// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
func (o HttpCheckResponseOutput) Headers() pulumi.StringMapOutput {
	return o.ApplyT(func(v HttpCheckResponse) map[string]string { return v.Headers }).(pulumi.StringMapOutput)
}

// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
func (o HttpCheckResponseOutput) MaskHeaders() pulumi.BoolOutput {
	return o.ApplyT(func(v HttpCheckResponse) bool { return v.MaskHeaders }).(pulumi.BoolOutput)
}

// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
func (o HttpCheckResponseOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v HttpCheckResponse) string { return v.Path }).(pulumi.StringOutput)
}

// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
func (o HttpCheckResponseOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v HttpCheckResponse) int { return v.Port }).(pulumi.IntOutput)
}

// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
func (o HttpCheckResponseOutput) RequestMethod() pulumi.StringOutput {
	return o.ApplyT(func(v HttpCheckResponse) string { return v.RequestMethod }).(pulumi.StringOutput)
}

// If true, use HTTPS instead of HTTP to run the check.
func (o HttpCheckResponseOutput) UseSsl() pulumi.BoolOutput {
	return o.ApplyT(func(v HttpCheckResponse) bool { return v.UseSsl }).(pulumi.BoolOutput)
}

// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
func (o HttpCheckResponseOutput) ValidateSsl() pulumi.BoolOutput {
	return o.ApplyT(func(v HttpCheckResponse) bool { return v.ValidateSsl }).(pulumi.BoolOutput)
}

type HttpCheckResponsePtrOutput struct{ *pulumi.OutputState }

func (HttpCheckResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HttpCheckResponse)(nil)).Elem()
}

func (o HttpCheckResponsePtrOutput) ToHttpCheckResponsePtrOutput() HttpCheckResponsePtrOutput {
	return o
}

func (o HttpCheckResponsePtrOutput) ToHttpCheckResponsePtrOutputWithContext(ctx context.Context) HttpCheckResponsePtrOutput {
	return o
}

func (o HttpCheckResponsePtrOutput) Elem() HttpCheckResponseOutput {
	return o.ApplyT(func(v *HttpCheckResponse) HttpCheckResponse { return *v }).(HttpCheckResponseOutput)
}

// The authentication information. Optional when creating an HTTP check; defaults to empty.
func (o HttpCheckResponsePtrOutput) AuthInfo() BasicAuthenticationResponsePtrOutput {
	return o.ApplyT(func(v *HttpCheckResponse) *BasicAuthenticationResponse {
		if v == nil {
			return nil
		}
		return &v.AuthInfo
	}).(BasicAuthenticationResponsePtrOutput)
}

// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note: As with all bytes fields, JSON representations are base64 encoded. e.g.: "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
func (o HttpCheckResponsePtrOutput) Body() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheckResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Body
	}).(pulumi.StringPtrOutput)
}

// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
func (o HttpCheckResponsePtrOutput) ContentType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheckResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ContentType
	}).(pulumi.StringPtrOutput)
}

// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
func (o HttpCheckResponsePtrOutput) Headers() pulumi.StringMapOutput {
	return o.ApplyT(func(v *HttpCheckResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.Headers
	}).(pulumi.StringMapOutput)
}

// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
func (o HttpCheckResponsePtrOutput) MaskHeaders() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HttpCheckResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.MaskHeaders
	}).(pulumi.BoolPtrOutput)
}

// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
func (o HttpCheckResponsePtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheckResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Path
	}).(pulumi.StringPtrOutput)
}

// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
func (o HttpCheckResponsePtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HttpCheckResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Port
	}).(pulumi.IntPtrOutput)
}

// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
func (o HttpCheckResponsePtrOutput) RequestMethod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheckResponse) *string {
		if v == nil {
			return nil
		}
		return &v.RequestMethod
	}).(pulumi.StringPtrOutput)
}

// If true, use HTTPS instead of HTTP to run the check.
func (o HttpCheckResponsePtrOutput) UseSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HttpCheckResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.UseSsl
	}).(pulumi.BoolPtrOutput)
}

// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
func (o HttpCheckResponsePtrOutput) ValidateSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HttpCheckResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.ValidateSsl
	}).(pulumi.BoolPtrOutput)
}

// An internal checker allows Uptime checks to run on private/internal GCP resources.
type InternalChecker struct {
	// The checker's human-readable name. The display name should be unique within a Stackdriver Workspace in order to make it easier to identify; however, uniqueness is not enforced.
	DisplayName *string `pulumi:"displayName"`
	// The GCP zone the Uptime check should egress from. Only respected for internal Uptime checks, where internal_network is specified.
	GcpZone *string `pulumi:"gcpZone"`
	// A unique resource name for this InternalChecker. The format is: projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID] [PROJECT_ID_OR_NUMBER] is the Stackdriver Workspace project for the Uptime check config associated with the internal checker.
	Name *string `pulumi:"name"`
	// The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the internal resource lives (ex: "default").
	Network *string `pulumi:"network"`
	// The GCP project ID where the internal checker lives. Not necessary the same as the Workspace project.
	PeerProjectId *string `pulumi:"peerProjectId"`
	// The current operational state of the internal checker.
	State *string `pulumi:"state"`
}

// InternalCheckerInput is an input type that accepts InternalCheckerArgs and InternalCheckerOutput values.
// You can construct a concrete instance of `InternalCheckerInput` via:
//
//          InternalCheckerArgs{...}
type InternalCheckerInput interface {
	pulumi.Input

	ToInternalCheckerOutput() InternalCheckerOutput
	ToInternalCheckerOutputWithContext(context.Context) InternalCheckerOutput
}

// An internal checker allows Uptime checks to run on private/internal GCP resources.
type InternalCheckerArgs struct {
	// The checker's human-readable name. The display name should be unique within a Stackdriver Workspace in order to make it easier to identify; however, uniqueness is not enforced.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// The GCP zone the Uptime check should egress from. Only respected for internal Uptime checks, where internal_network is specified.
	GcpZone pulumi.StringPtrInput `pulumi:"gcpZone"`
	// A unique resource name for this InternalChecker. The format is: projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID] [PROJECT_ID_OR_NUMBER] is the Stackdriver Workspace project for the Uptime check config associated with the internal checker.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the internal resource lives (ex: "default").
	Network pulumi.StringPtrInput `pulumi:"network"`
	// The GCP project ID where the internal checker lives. Not necessary the same as the Workspace project.
	PeerProjectId pulumi.StringPtrInput `pulumi:"peerProjectId"`
	// The current operational state of the internal checker.
	State pulumi.StringPtrInput `pulumi:"state"`
}

func (InternalCheckerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InternalChecker)(nil)).Elem()
}

func (i InternalCheckerArgs) ToInternalCheckerOutput() InternalCheckerOutput {
	return i.ToInternalCheckerOutputWithContext(context.Background())
}

func (i InternalCheckerArgs) ToInternalCheckerOutputWithContext(ctx context.Context) InternalCheckerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InternalCheckerOutput)
}

// InternalCheckerArrayInput is an input type that accepts InternalCheckerArray and InternalCheckerArrayOutput values.
// You can construct a concrete instance of `InternalCheckerArrayInput` via:
//
//          InternalCheckerArray{ InternalCheckerArgs{...} }
type InternalCheckerArrayInput interface {
	pulumi.Input

	ToInternalCheckerArrayOutput() InternalCheckerArrayOutput
	ToInternalCheckerArrayOutputWithContext(context.Context) InternalCheckerArrayOutput
}

type InternalCheckerArray []InternalCheckerInput

func (InternalCheckerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InternalChecker)(nil)).Elem()
}

func (i InternalCheckerArray) ToInternalCheckerArrayOutput() InternalCheckerArrayOutput {
	return i.ToInternalCheckerArrayOutputWithContext(context.Background())
}

func (i InternalCheckerArray) ToInternalCheckerArrayOutputWithContext(ctx context.Context) InternalCheckerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InternalCheckerArrayOutput)
}

// An internal checker allows Uptime checks to run on private/internal GCP resources.
type InternalCheckerOutput struct{ *pulumi.OutputState }

func (InternalCheckerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InternalChecker)(nil)).Elem()
}

func (o InternalCheckerOutput) ToInternalCheckerOutput() InternalCheckerOutput {
	return o
}

func (o InternalCheckerOutput) ToInternalCheckerOutputWithContext(ctx context.Context) InternalCheckerOutput {
	return o
}

// The checker's human-readable name. The display name should be unique within a Stackdriver Workspace in order to make it easier to identify; however, uniqueness is not enforced.
func (o InternalCheckerOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// The GCP zone the Uptime check should egress from. Only respected for internal Uptime checks, where internal_network is specified.
func (o InternalCheckerOutput) GcpZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.GcpZone }).(pulumi.StringPtrOutput)
}

// A unique resource name for this InternalChecker. The format is: projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID] [PROJECT_ID_OR_NUMBER] is the Stackdriver Workspace project for the Uptime check config associated with the internal checker.
func (o InternalCheckerOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the internal resource lives (ex: "default").
func (o InternalCheckerOutput) Network() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.Network }).(pulumi.StringPtrOutput)
}

// The GCP project ID where the internal checker lives. Not necessary the same as the Workspace project.
func (o InternalCheckerOutput) PeerProjectId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.PeerProjectId }).(pulumi.StringPtrOutput)
}

// The current operational state of the internal checker.
func (o InternalCheckerOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.State }).(pulumi.StringPtrOutput)
}

type InternalCheckerArrayOutput struct{ *pulumi.OutputState }

func (InternalCheckerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InternalChecker)(nil)).Elem()
}

func (o InternalCheckerArrayOutput) ToInternalCheckerArrayOutput() InternalCheckerArrayOutput {
	return o
}

func (o InternalCheckerArrayOutput) ToInternalCheckerArrayOutputWithContext(ctx context.Context) InternalCheckerArrayOutput {
	return o
}

func (o InternalCheckerArrayOutput) Index(i pulumi.IntInput) InternalCheckerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InternalChecker {
		return vs[0].([]InternalChecker)[vs[1].(int)]
	}).(InternalCheckerOutput)
}

// An internal checker allows Uptime checks to run on private/internal GCP resources.
type InternalCheckerResponse struct {
	// The checker's human-readable name. The display name should be unique within a Stackdriver Workspace in order to make it easier to identify; however, uniqueness is not enforced.
	DisplayName string `pulumi:"displayName"`
	// The GCP zone the Uptime check should egress from. Only respected for internal Uptime checks, where internal_network is specified.
	GcpZone string `pulumi:"gcpZone"`
	// A unique resource name for this InternalChecker. The format is: projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID] [PROJECT_ID_OR_NUMBER] is the Stackdriver Workspace project for the Uptime check config associated with the internal checker.
	Name string `pulumi:"name"`
	// The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the internal resource lives (ex: "default").
	Network string `pulumi:"network"`
	// The GCP project ID where the internal checker lives. Not necessary the same as the Workspace project.
	PeerProjectId string `pulumi:"peerProjectId"`
	// The current operational state of the internal checker.
	State string `pulumi:"state"`
}

// InternalCheckerResponseInput is an input type that accepts InternalCheckerResponseArgs and InternalCheckerResponseOutput values.
// You can construct a concrete instance of `InternalCheckerResponseInput` via:
//
//          InternalCheckerResponseArgs{...}
type InternalCheckerResponseInput interface {
	pulumi.Input

	ToInternalCheckerResponseOutput() InternalCheckerResponseOutput
	ToInternalCheckerResponseOutputWithContext(context.Context) InternalCheckerResponseOutput
}

// An internal checker allows Uptime checks to run on private/internal GCP resources.
type InternalCheckerResponseArgs struct {
	// The checker's human-readable name. The display name should be unique within a Stackdriver Workspace in order to make it easier to identify; however, uniqueness is not enforced.
	DisplayName pulumi.StringInput `pulumi:"displayName"`
	// The GCP zone the Uptime check should egress from. Only respected for internal Uptime checks, where internal_network is specified.
	GcpZone pulumi.StringInput `pulumi:"gcpZone"`
	// A unique resource name for this InternalChecker. The format is: projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID] [PROJECT_ID_OR_NUMBER] is the Stackdriver Workspace project for the Uptime check config associated with the internal checker.
	Name pulumi.StringInput `pulumi:"name"`
	// The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the internal resource lives (ex: "default").
	Network pulumi.StringInput `pulumi:"network"`
	// The GCP project ID where the internal checker lives. Not necessary the same as the Workspace project.
	PeerProjectId pulumi.StringInput `pulumi:"peerProjectId"`
	// The current operational state of the internal checker.
	State pulumi.StringInput `pulumi:"state"`
}

func (InternalCheckerResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InternalCheckerResponse)(nil)).Elem()
}

func (i InternalCheckerResponseArgs) ToInternalCheckerResponseOutput() InternalCheckerResponseOutput {
	return i.ToInternalCheckerResponseOutputWithContext(context.Background())
}

func (i InternalCheckerResponseArgs) ToInternalCheckerResponseOutputWithContext(ctx context.Context) InternalCheckerResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InternalCheckerResponseOutput)
}

// InternalCheckerResponseArrayInput is an input type that accepts InternalCheckerResponseArray and InternalCheckerResponseArrayOutput values.
// You can construct a concrete instance of `InternalCheckerResponseArrayInput` via:
//
//          InternalCheckerResponseArray{ InternalCheckerResponseArgs{...} }
type InternalCheckerResponseArrayInput interface {
	pulumi.Input

	ToInternalCheckerResponseArrayOutput() InternalCheckerResponseArrayOutput
	ToInternalCheckerResponseArrayOutputWithContext(context.Context) InternalCheckerResponseArrayOutput
}

type InternalCheckerResponseArray []InternalCheckerResponseInput

func (InternalCheckerResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InternalCheckerResponse)(nil)).Elem()
}

func (i InternalCheckerResponseArray) ToInternalCheckerResponseArrayOutput() InternalCheckerResponseArrayOutput {
	return i.ToInternalCheckerResponseArrayOutputWithContext(context.Background())
}

func (i InternalCheckerResponseArray) ToInternalCheckerResponseArrayOutputWithContext(ctx context.Context) InternalCheckerResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InternalCheckerResponseArrayOutput)
}

// An internal checker allows Uptime checks to run on private/internal GCP resources.
type InternalCheckerResponseOutput struct{ *pulumi.OutputState }

func (InternalCheckerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InternalCheckerResponse)(nil)).Elem()
}

func (o InternalCheckerResponseOutput) ToInternalCheckerResponseOutput() InternalCheckerResponseOutput {
	return o
}

func (o InternalCheckerResponseOutput) ToInternalCheckerResponseOutputWithContext(ctx context.Context) InternalCheckerResponseOutput {
	return o
}

// The checker's human-readable name. The display name should be unique within a Stackdriver Workspace in order to make it easier to identify; however, uniqueness is not enforced.
func (o InternalCheckerResponseOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v InternalCheckerResponse) string { return v.DisplayName }).(pulumi.StringOutput)
}

// The GCP zone the Uptime check should egress from. Only respected for internal Uptime checks, where internal_network is specified.
func (o InternalCheckerResponseOutput) GcpZone() pulumi.StringOutput {
	return o.ApplyT(func(v InternalCheckerResponse) string { return v.GcpZone }).(pulumi.StringOutput)
}

// A unique resource name for this InternalChecker. The format is: projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID] [PROJECT_ID_OR_NUMBER] is the Stackdriver Workspace project for the Uptime check config associated with the internal checker.
func (o InternalCheckerResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v InternalCheckerResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the internal resource lives (ex: "default").
func (o InternalCheckerResponseOutput) Network() pulumi.StringOutput {
	return o.ApplyT(func(v InternalCheckerResponse) string { return v.Network }).(pulumi.StringOutput)
}

// The GCP project ID where the internal checker lives. Not necessary the same as the Workspace project.
func (o InternalCheckerResponseOutput) PeerProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v InternalCheckerResponse) string { return v.PeerProjectId }).(pulumi.StringOutput)
}

// The current operational state of the internal checker.
func (o InternalCheckerResponseOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v InternalCheckerResponse) string { return v.State }).(pulumi.StringOutput)
}

type InternalCheckerResponseArrayOutput struct{ *pulumi.OutputState }

func (InternalCheckerResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InternalCheckerResponse)(nil)).Elem()
}

func (o InternalCheckerResponseArrayOutput) ToInternalCheckerResponseArrayOutput() InternalCheckerResponseArrayOutput {
	return o
}

func (o InternalCheckerResponseArrayOutput) ToInternalCheckerResponseArrayOutputWithContext(ctx context.Context) InternalCheckerResponseArrayOutput {
	return o
}

func (o InternalCheckerResponseArrayOutput) Index(i pulumi.IntInput) InternalCheckerResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InternalCheckerResponse {
		return vs[0].([]InternalCheckerResponse)[vs[1].(int)]
	}).(InternalCheckerResponseOutput)
}

// Canonical service scoped to an Istio mesh. Anthos clusters running ASM >= 1.6.8 will have their services ingested as this type.
type IstioCanonicalService struct {
	// The name of the canonical service underlying this service. Corresponds to the destination_canonical_service_name metric label in label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	CanonicalService *string `pulumi:"canonicalService"`
	// The namespace of the canonical service underlying this service. Corresponds to the destination_canonical_service_namespace metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	CanonicalServiceNamespace *string `pulumi:"canonicalServiceNamespace"`
	// Identifier for the Istio mesh in which this canonical service is defined. Corresponds to the mesh_uid metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	MeshUid *string `pulumi:"meshUid"`
}

// IstioCanonicalServiceInput is an input type that accepts IstioCanonicalServiceArgs and IstioCanonicalServiceOutput values.
// You can construct a concrete instance of `IstioCanonicalServiceInput` via:
//
//          IstioCanonicalServiceArgs{...}
type IstioCanonicalServiceInput interface {
	pulumi.Input

	ToIstioCanonicalServiceOutput() IstioCanonicalServiceOutput
	ToIstioCanonicalServiceOutputWithContext(context.Context) IstioCanonicalServiceOutput
}

// Canonical service scoped to an Istio mesh. Anthos clusters running ASM >= 1.6.8 will have their services ingested as this type.
type IstioCanonicalServiceArgs struct {
	// The name of the canonical service underlying this service. Corresponds to the destination_canonical_service_name metric label in label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	CanonicalService pulumi.StringPtrInput `pulumi:"canonicalService"`
	// The namespace of the canonical service underlying this service. Corresponds to the destination_canonical_service_namespace metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	CanonicalServiceNamespace pulumi.StringPtrInput `pulumi:"canonicalServiceNamespace"`
	// Identifier for the Istio mesh in which this canonical service is defined. Corresponds to the mesh_uid metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	MeshUid pulumi.StringPtrInput `pulumi:"meshUid"`
}

func (IstioCanonicalServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IstioCanonicalService)(nil)).Elem()
}

func (i IstioCanonicalServiceArgs) ToIstioCanonicalServiceOutput() IstioCanonicalServiceOutput {
	return i.ToIstioCanonicalServiceOutputWithContext(context.Background())
}

func (i IstioCanonicalServiceArgs) ToIstioCanonicalServiceOutputWithContext(ctx context.Context) IstioCanonicalServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IstioCanonicalServiceOutput)
}

func (i IstioCanonicalServiceArgs) ToIstioCanonicalServicePtrOutput() IstioCanonicalServicePtrOutput {
	return i.ToIstioCanonicalServicePtrOutputWithContext(context.Background())
}

func (i IstioCanonicalServiceArgs) ToIstioCanonicalServicePtrOutputWithContext(ctx context.Context) IstioCanonicalServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IstioCanonicalServiceOutput).ToIstioCanonicalServicePtrOutputWithContext(ctx)
}

// IstioCanonicalServicePtrInput is an input type that accepts IstioCanonicalServiceArgs, IstioCanonicalServicePtr and IstioCanonicalServicePtrOutput values.
// You can construct a concrete instance of `IstioCanonicalServicePtrInput` via:
//
//          IstioCanonicalServiceArgs{...}
//
//  or:
//
//          nil
type IstioCanonicalServicePtrInput interface {
	pulumi.Input

	ToIstioCanonicalServicePtrOutput() IstioCanonicalServicePtrOutput
	ToIstioCanonicalServicePtrOutputWithContext(context.Context) IstioCanonicalServicePtrOutput
}

type istioCanonicalServicePtrType IstioCanonicalServiceArgs

func IstioCanonicalServicePtr(v *IstioCanonicalServiceArgs) IstioCanonicalServicePtrInput {
	return (*istioCanonicalServicePtrType)(v)
}

func (*istioCanonicalServicePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IstioCanonicalService)(nil)).Elem()
}

func (i *istioCanonicalServicePtrType) ToIstioCanonicalServicePtrOutput() IstioCanonicalServicePtrOutput {
	return i.ToIstioCanonicalServicePtrOutputWithContext(context.Background())
}

func (i *istioCanonicalServicePtrType) ToIstioCanonicalServicePtrOutputWithContext(ctx context.Context) IstioCanonicalServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IstioCanonicalServicePtrOutput)
}

// Canonical service scoped to an Istio mesh. Anthos clusters running ASM >= 1.6.8 will have their services ingested as this type.
type IstioCanonicalServiceOutput struct{ *pulumi.OutputState }

func (IstioCanonicalServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IstioCanonicalService)(nil)).Elem()
}

func (o IstioCanonicalServiceOutput) ToIstioCanonicalServiceOutput() IstioCanonicalServiceOutput {
	return o
}

func (o IstioCanonicalServiceOutput) ToIstioCanonicalServiceOutputWithContext(ctx context.Context) IstioCanonicalServiceOutput {
	return o
}

func (o IstioCanonicalServiceOutput) ToIstioCanonicalServicePtrOutput() IstioCanonicalServicePtrOutput {
	return o.ToIstioCanonicalServicePtrOutputWithContext(context.Background())
}

func (o IstioCanonicalServiceOutput) ToIstioCanonicalServicePtrOutputWithContext(ctx context.Context) IstioCanonicalServicePtrOutput {
	return o.ApplyT(func(v IstioCanonicalService) *IstioCanonicalService {
		return &v
	}).(IstioCanonicalServicePtrOutput)
}

// The name of the canonical service underlying this service. Corresponds to the destination_canonical_service_name metric label in label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceOutput) CanonicalService() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IstioCanonicalService) *string { return v.CanonicalService }).(pulumi.StringPtrOutput)
}

// The namespace of the canonical service underlying this service. Corresponds to the destination_canonical_service_namespace metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceOutput) CanonicalServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IstioCanonicalService) *string { return v.CanonicalServiceNamespace }).(pulumi.StringPtrOutput)
}

// Identifier for the Istio mesh in which this canonical service is defined. Corresponds to the mesh_uid metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceOutput) MeshUid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IstioCanonicalService) *string { return v.MeshUid }).(pulumi.StringPtrOutput)
}

type IstioCanonicalServicePtrOutput struct{ *pulumi.OutputState }

func (IstioCanonicalServicePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IstioCanonicalService)(nil)).Elem()
}

func (o IstioCanonicalServicePtrOutput) ToIstioCanonicalServicePtrOutput() IstioCanonicalServicePtrOutput {
	return o
}

func (o IstioCanonicalServicePtrOutput) ToIstioCanonicalServicePtrOutputWithContext(ctx context.Context) IstioCanonicalServicePtrOutput {
	return o
}

func (o IstioCanonicalServicePtrOutput) Elem() IstioCanonicalServiceOutput {
	return o.ApplyT(func(v *IstioCanonicalService) IstioCanonicalService { return *v }).(IstioCanonicalServiceOutput)
}

// The name of the canonical service underlying this service. Corresponds to the destination_canonical_service_name metric label in label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServicePtrOutput) CanonicalService() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IstioCanonicalService) *string {
		if v == nil {
			return nil
		}
		return v.CanonicalService
	}).(pulumi.StringPtrOutput)
}

// The namespace of the canonical service underlying this service. Corresponds to the destination_canonical_service_namespace metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServicePtrOutput) CanonicalServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IstioCanonicalService) *string {
		if v == nil {
			return nil
		}
		return v.CanonicalServiceNamespace
	}).(pulumi.StringPtrOutput)
}

// Identifier for the Istio mesh in which this canonical service is defined. Corresponds to the mesh_uid metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServicePtrOutput) MeshUid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IstioCanonicalService) *string {
		if v == nil {
			return nil
		}
		return v.MeshUid
	}).(pulumi.StringPtrOutput)
}

// Canonical service scoped to an Istio mesh. Anthos clusters running ASM >= 1.6.8 will have their services ingested as this type.
type IstioCanonicalServiceResponse struct {
	// The name of the canonical service underlying this service. Corresponds to the destination_canonical_service_name metric label in label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	CanonicalService string `pulumi:"canonicalService"`
	// The namespace of the canonical service underlying this service. Corresponds to the destination_canonical_service_namespace metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	CanonicalServiceNamespace string `pulumi:"canonicalServiceNamespace"`
	// Identifier for the Istio mesh in which this canonical service is defined. Corresponds to the mesh_uid metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	MeshUid string `pulumi:"meshUid"`
}

// IstioCanonicalServiceResponseInput is an input type that accepts IstioCanonicalServiceResponseArgs and IstioCanonicalServiceResponseOutput values.
// You can construct a concrete instance of `IstioCanonicalServiceResponseInput` via:
//
//          IstioCanonicalServiceResponseArgs{...}
type IstioCanonicalServiceResponseInput interface {
	pulumi.Input

	ToIstioCanonicalServiceResponseOutput() IstioCanonicalServiceResponseOutput
	ToIstioCanonicalServiceResponseOutputWithContext(context.Context) IstioCanonicalServiceResponseOutput
}

// Canonical service scoped to an Istio mesh. Anthos clusters running ASM >= 1.6.8 will have their services ingested as this type.
type IstioCanonicalServiceResponseArgs struct {
	// The name of the canonical service underlying this service. Corresponds to the destination_canonical_service_name metric label in label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	CanonicalService pulumi.StringInput `pulumi:"canonicalService"`
	// The namespace of the canonical service underlying this service. Corresponds to the destination_canonical_service_namespace metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	CanonicalServiceNamespace pulumi.StringInput `pulumi:"canonicalServiceNamespace"`
	// Identifier for the Istio mesh in which this canonical service is defined. Corresponds to the mesh_uid metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	MeshUid pulumi.StringInput `pulumi:"meshUid"`
}

func (IstioCanonicalServiceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IstioCanonicalServiceResponse)(nil)).Elem()
}

func (i IstioCanonicalServiceResponseArgs) ToIstioCanonicalServiceResponseOutput() IstioCanonicalServiceResponseOutput {
	return i.ToIstioCanonicalServiceResponseOutputWithContext(context.Background())
}

func (i IstioCanonicalServiceResponseArgs) ToIstioCanonicalServiceResponseOutputWithContext(ctx context.Context) IstioCanonicalServiceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IstioCanonicalServiceResponseOutput)
}

func (i IstioCanonicalServiceResponseArgs) ToIstioCanonicalServiceResponsePtrOutput() IstioCanonicalServiceResponsePtrOutput {
	return i.ToIstioCanonicalServiceResponsePtrOutputWithContext(context.Background())
}

func (i IstioCanonicalServiceResponseArgs) ToIstioCanonicalServiceResponsePtrOutputWithContext(ctx context.Context) IstioCanonicalServiceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IstioCanonicalServiceResponseOutput).ToIstioCanonicalServiceResponsePtrOutputWithContext(ctx)
}

// IstioCanonicalServiceResponsePtrInput is an input type that accepts IstioCanonicalServiceResponseArgs, IstioCanonicalServiceResponsePtr and IstioCanonicalServiceResponsePtrOutput values.
// You can construct a concrete instance of `IstioCanonicalServiceResponsePtrInput` via:
//
//          IstioCanonicalServiceResponseArgs{...}
//
//  or:
//
//          nil
type IstioCanonicalServiceResponsePtrInput interface {
	pulumi.Input

	ToIstioCanonicalServiceResponsePtrOutput() IstioCanonicalServiceResponsePtrOutput
	ToIstioCanonicalServiceResponsePtrOutputWithContext(context.Context) IstioCanonicalServiceResponsePtrOutput
}

type istioCanonicalServiceResponsePtrType IstioCanonicalServiceResponseArgs

func IstioCanonicalServiceResponsePtr(v *IstioCanonicalServiceResponseArgs) IstioCanonicalServiceResponsePtrInput {
	return (*istioCanonicalServiceResponsePtrType)(v)
}

func (*istioCanonicalServiceResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IstioCanonicalServiceResponse)(nil)).Elem()
}

func (i *istioCanonicalServiceResponsePtrType) ToIstioCanonicalServiceResponsePtrOutput() IstioCanonicalServiceResponsePtrOutput {
	return i.ToIstioCanonicalServiceResponsePtrOutputWithContext(context.Background())
}

func (i *istioCanonicalServiceResponsePtrType) ToIstioCanonicalServiceResponsePtrOutputWithContext(ctx context.Context) IstioCanonicalServiceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IstioCanonicalServiceResponsePtrOutput)
}

// Canonical service scoped to an Istio mesh. Anthos clusters running ASM >= 1.6.8 will have their services ingested as this type.
type IstioCanonicalServiceResponseOutput struct{ *pulumi.OutputState }

func (IstioCanonicalServiceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IstioCanonicalServiceResponse)(nil)).Elem()
}

func (o IstioCanonicalServiceResponseOutput) ToIstioCanonicalServiceResponseOutput() IstioCanonicalServiceResponseOutput {
	return o
}

func (o IstioCanonicalServiceResponseOutput) ToIstioCanonicalServiceResponseOutputWithContext(ctx context.Context) IstioCanonicalServiceResponseOutput {
	return o
}

func (o IstioCanonicalServiceResponseOutput) ToIstioCanonicalServiceResponsePtrOutput() IstioCanonicalServiceResponsePtrOutput {
	return o.ToIstioCanonicalServiceResponsePtrOutputWithContext(context.Background())
}

func (o IstioCanonicalServiceResponseOutput) ToIstioCanonicalServiceResponsePtrOutputWithContext(ctx context.Context) IstioCanonicalServiceResponsePtrOutput {
	return o.ApplyT(func(v IstioCanonicalServiceResponse) *IstioCanonicalServiceResponse {
		return &v
	}).(IstioCanonicalServiceResponsePtrOutput)
}

// The name of the canonical service underlying this service. Corresponds to the destination_canonical_service_name metric label in label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceResponseOutput) CanonicalService() pulumi.StringOutput {
	return o.ApplyT(func(v IstioCanonicalServiceResponse) string { return v.CanonicalService }).(pulumi.StringOutput)
}

// The namespace of the canonical service underlying this service. Corresponds to the destination_canonical_service_namespace metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceResponseOutput) CanonicalServiceNamespace() pulumi.StringOutput {
	return o.ApplyT(func(v IstioCanonicalServiceResponse) string { return v.CanonicalServiceNamespace }).(pulumi.StringOutput)
}

// Identifier for the Istio mesh in which this canonical service is defined. Corresponds to the mesh_uid metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceResponseOutput) MeshUid() pulumi.StringOutput {
	return o.ApplyT(func(v IstioCanonicalServiceResponse) string { return v.MeshUid }).(pulumi.StringOutput)
}

type IstioCanonicalServiceResponsePtrOutput struct{ *pulumi.OutputState }

func (IstioCanonicalServiceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IstioCanonicalServiceResponse)(nil)).Elem()
}

func (o IstioCanonicalServiceResponsePtrOutput) ToIstioCanonicalServiceResponsePtrOutput() IstioCanonicalServiceResponsePtrOutput {
	return o
}

func (o IstioCanonicalServiceResponsePtrOutput) ToIstioCanonicalServiceResponsePtrOutputWithContext(ctx context.Context) IstioCanonicalServiceResponsePtrOutput {
	return o
}

func (o IstioCanonicalServiceResponsePtrOutput) Elem() IstioCanonicalServiceResponseOutput {
	return o.ApplyT(func(v *IstioCanonicalServiceResponse) IstioCanonicalServiceResponse { return *v }).(IstioCanonicalServiceResponseOutput)
}

// The name of the canonical service underlying this service. Corresponds to the destination_canonical_service_name metric label in label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceResponsePtrOutput) CanonicalService() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IstioCanonicalServiceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.CanonicalService
	}).(pulumi.StringPtrOutput)
}

// The namespace of the canonical service underlying this service. Corresponds to the destination_canonical_service_namespace metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceResponsePtrOutput) CanonicalServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IstioCanonicalServiceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.CanonicalServiceNamespace
	}).(pulumi.StringPtrOutput)
}

// Identifier for the Istio mesh in which this canonical service is defined. Corresponds to the mesh_uid metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceResponsePtrOutput) MeshUid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IstioCanonicalServiceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.MeshUid
	}).(pulumi.StringPtrOutput)
}

// A description of a label.
type LabelDescriptor struct {
	// A human-readable description for the label.
	Description *string `pulumi:"description"`
	// The key for this label. The key must meet the following criteria: Does not exceed 100 characters. Matches the following regular expression: [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case letter. The remaining characters must be letters, digits, or underscores.
	Key *string `pulumi:"key"`
	// The type of data that can be assigned to the label.
	ValueType *string `pulumi:"valueType"`
}

// LabelDescriptorInput is an input type that accepts LabelDescriptorArgs and LabelDescriptorOutput values.
// You can construct a concrete instance of `LabelDescriptorInput` via:
//
//          LabelDescriptorArgs{...}
type LabelDescriptorInput interface {
	pulumi.Input

	ToLabelDescriptorOutput() LabelDescriptorOutput
	ToLabelDescriptorOutputWithContext(context.Context) LabelDescriptorOutput
}

// A description of a label.
type LabelDescriptorArgs struct {
	// A human-readable description for the label.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// The key for this label. The key must meet the following criteria: Does not exceed 100 characters. Matches the following regular expression: [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case letter. The remaining characters must be letters, digits, or underscores.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// The type of data that can be assigned to the label.
	ValueType pulumi.StringPtrInput `pulumi:"valueType"`
}

func (LabelDescriptorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelDescriptor)(nil)).Elem()
}

func (i LabelDescriptorArgs) ToLabelDescriptorOutput() LabelDescriptorOutput {
	return i.ToLabelDescriptorOutputWithContext(context.Background())
}

func (i LabelDescriptorArgs) ToLabelDescriptorOutputWithContext(ctx context.Context) LabelDescriptorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelDescriptorOutput)
}

// LabelDescriptorArrayInput is an input type that accepts LabelDescriptorArray and LabelDescriptorArrayOutput values.
// You can construct a concrete instance of `LabelDescriptorArrayInput` via:
//
//          LabelDescriptorArray{ LabelDescriptorArgs{...} }
type LabelDescriptorArrayInput interface {
	pulumi.Input

	ToLabelDescriptorArrayOutput() LabelDescriptorArrayOutput
	ToLabelDescriptorArrayOutputWithContext(context.Context) LabelDescriptorArrayOutput
}

type LabelDescriptorArray []LabelDescriptorInput

func (LabelDescriptorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LabelDescriptor)(nil)).Elem()
}

func (i LabelDescriptorArray) ToLabelDescriptorArrayOutput() LabelDescriptorArrayOutput {
	return i.ToLabelDescriptorArrayOutputWithContext(context.Background())
}

func (i LabelDescriptorArray) ToLabelDescriptorArrayOutputWithContext(ctx context.Context) LabelDescriptorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelDescriptorArrayOutput)
}

// A description of a label.
type LabelDescriptorOutput struct{ *pulumi.OutputState }

func (LabelDescriptorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelDescriptor)(nil)).Elem()
}

func (o LabelDescriptorOutput) ToLabelDescriptorOutput() LabelDescriptorOutput {
	return o
}

func (o LabelDescriptorOutput) ToLabelDescriptorOutputWithContext(ctx context.Context) LabelDescriptorOutput {
	return o
}

// A human-readable description for the label.
func (o LabelDescriptorOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelDescriptor) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The key for this label. The key must meet the following criteria: Does not exceed 100 characters. Matches the following regular expression: [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case letter. The remaining characters must be letters, digits, or underscores.
func (o LabelDescriptorOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelDescriptor) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// The type of data that can be assigned to the label.
func (o LabelDescriptorOutput) ValueType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelDescriptor) *string { return v.ValueType }).(pulumi.StringPtrOutput)
}

type LabelDescriptorArrayOutput struct{ *pulumi.OutputState }

func (LabelDescriptorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LabelDescriptor)(nil)).Elem()
}

func (o LabelDescriptorArrayOutput) ToLabelDescriptorArrayOutput() LabelDescriptorArrayOutput {
	return o
}

func (o LabelDescriptorArrayOutput) ToLabelDescriptorArrayOutputWithContext(ctx context.Context) LabelDescriptorArrayOutput {
	return o
}

func (o LabelDescriptorArrayOutput) Index(i pulumi.IntInput) LabelDescriptorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LabelDescriptor {
		return vs[0].([]LabelDescriptor)[vs[1].(int)]
	}).(LabelDescriptorOutput)
}

// A description of a label.
type LabelDescriptorResponse struct {
	// A human-readable description for the label.
	Description string `pulumi:"description"`
	// The key for this label. The key must meet the following criteria: Does not exceed 100 characters. Matches the following regular expression: [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case letter. The remaining characters must be letters, digits, or underscores.
	Key string `pulumi:"key"`
	// The type of data that can be assigned to the label.
	ValueType string `pulumi:"valueType"`
}

// LabelDescriptorResponseInput is an input type that accepts LabelDescriptorResponseArgs and LabelDescriptorResponseOutput values.
// You can construct a concrete instance of `LabelDescriptorResponseInput` via:
//
//          LabelDescriptorResponseArgs{...}
type LabelDescriptorResponseInput interface {
	pulumi.Input

	ToLabelDescriptorResponseOutput() LabelDescriptorResponseOutput
	ToLabelDescriptorResponseOutputWithContext(context.Context) LabelDescriptorResponseOutput
}

// A description of a label.
type LabelDescriptorResponseArgs struct {
	// A human-readable description for the label.
	Description pulumi.StringInput `pulumi:"description"`
	// The key for this label. The key must meet the following criteria: Does not exceed 100 characters. Matches the following regular expression: [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case letter. The remaining characters must be letters, digits, or underscores.
	Key pulumi.StringInput `pulumi:"key"`
	// The type of data that can be assigned to the label.
	ValueType pulumi.StringInput `pulumi:"valueType"`
}

func (LabelDescriptorResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelDescriptorResponse)(nil)).Elem()
}

func (i LabelDescriptorResponseArgs) ToLabelDescriptorResponseOutput() LabelDescriptorResponseOutput {
	return i.ToLabelDescriptorResponseOutputWithContext(context.Background())
}

func (i LabelDescriptorResponseArgs) ToLabelDescriptorResponseOutputWithContext(ctx context.Context) LabelDescriptorResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelDescriptorResponseOutput)
}

// LabelDescriptorResponseArrayInput is an input type that accepts LabelDescriptorResponseArray and LabelDescriptorResponseArrayOutput values.
// You can construct a concrete instance of `LabelDescriptorResponseArrayInput` via:
//
//          LabelDescriptorResponseArray{ LabelDescriptorResponseArgs{...} }
type LabelDescriptorResponseArrayInput interface {
	pulumi.Input

	ToLabelDescriptorResponseArrayOutput() LabelDescriptorResponseArrayOutput
	ToLabelDescriptorResponseArrayOutputWithContext(context.Context) LabelDescriptorResponseArrayOutput
}

type LabelDescriptorResponseArray []LabelDescriptorResponseInput

func (LabelDescriptorResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LabelDescriptorResponse)(nil)).Elem()
}

func (i LabelDescriptorResponseArray) ToLabelDescriptorResponseArrayOutput() LabelDescriptorResponseArrayOutput {
	return i.ToLabelDescriptorResponseArrayOutputWithContext(context.Background())
}

func (i LabelDescriptorResponseArray) ToLabelDescriptorResponseArrayOutputWithContext(ctx context.Context) LabelDescriptorResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelDescriptorResponseArrayOutput)
}

// A description of a label.
type LabelDescriptorResponseOutput struct{ *pulumi.OutputState }

func (LabelDescriptorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelDescriptorResponse)(nil)).Elem()
}

func (o LabelDescriptorResponseOutput) ToLabelDescriptorResponseOutput() LabelDescriptorResponseOutput {
	return o
}

func (o LabelDescriptorResponseOutput) ToLabelDescriptorResponseOutputWithContext(ctx context.Context) LabelDescriptorResponseOutput {
	return o
}

// A human-readable description for the label.
func (o LabelDescriptorResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v LabelDescriptorResponse) string { return v.Description }).(pulumi.StringOutput)
}

// The key for this label. The key must meet the following criteria: Does not exceed 100 characters. Matches the following regular expression: [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case letter. The remaining characters must be letters, digits, or underscores.
func (o LabelDescriptorResponseOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v LabelDescriptorResponse) string { return v.Key }).(pulumi.StringOutput)
}

// The type of data that can be assigned to the label.
func (o LabelDescriptorResponseOutput) ValueType() pulumi.StringOutput {
	return o.ApplyT(func(v LabelDescriptorResponse) string { return v.ValueType }).(pulumi.StringOutput)
}

type LabelDescriptorResponseArrayOutput struct{ *pulumi.OutputState }

func (LabelDescriptorResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LabelDescriptorResponse)(nil)).Elem()
}

func (o LabelDescriptorResponseArrayOutput) ToLabelDescriptorResponseArrayOutput() LabelDescriptorResponseArrayOutput {
	return o
}

func (o LabelDescriptorResponseArrayOutput) ToLabelDescriptorResponseArrayOutputWithContext(ctx context.Context) LabelDescriptorResponseArrayOutput {
	return o
}

func (o LabelDescriptorResponseArrayOutput) Index(i pulumi.IntInput) LabelDescriptorResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LabelDescriptorResponse {
		return vs[0].([]LabelDescriptorResponse)[vs[1].(int)]
	}).(LabelDescriptorResponseOutput)
}

// Parameters for a latency threshold SLI.
type LatencyCriteria struct {
	// Good service is defined to be the count of requests made to this service that return in no more than threshold.
	Threshold *string `pulumi:"threshold"`
}

// LatencyCriteriaInput is an input type that accepts LatencyCriteriaArgs and LatencyCriteriaOutput values.
// You can construct a concrete instance of `LatencyCriteriaInput` via:
//
//          LatencyCriteriaArgs{...}
type LatencyCriteriaInput interface {
	pulumi.Input

	ToLatencyCriteriaOutput() LatencyCriteriaOutput
	ToLatencyCriteriaOutputWithContext(context.Context) LatencyCriteriaOutput
}

// Parameters for a latency threshold SLI.
type LatencyCriteriaArgs struct {
	// Good service is defined to be the count of requests made to this service that return in no more than threshold.
	Threshold pulumi.StringPtrInput `pulumi:"threshold"`
}

func (LatencyCriteriaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LatencyCriteria)(nil)).Elem()
}

func (i LatencyCriteriaArgs) ToLatencyCriteriaOutput() LatencyCriteriaOutput {
	return i.ToLatencyCriteriaOutputWithContext(context.Background())
}

func (i LatencyCriteriaArgs) ToLatencyCriteriaOutputWithContext(ctx context.Context) LatencyCriteriaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatencyCriteriaOutput)
}

func (i LatencyCriteriaArgs) ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput {
	return i.ToLatencyCriteriaPtrOutputWithContext(context.Background())
}

func (i LatencyCriteriaArgs) ToLatencyCriteriaPtrOutputWithContext(ctx context.Context) LatencyCriteriaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatencyCriteriaOutput).ToLatencyCriteriaPtrOutputWithContext(ctx)
}

// LatencyCriteriaPtrInput is an input type that accepts LatencyCriteriaArgs, LatencyCriteriaPtr and LatencyCriteriaPtrOutput values.
// You can construct a concrete instance of `LatencyCriteriaPtrInput` via:
//
//          LatencyCriteriaArgs{...}
//
//  or:
//
//          nil
type LatencyCriteriaPtrInput interface {
	pulumi.Input

	ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput
	ToLatencyCriteriaPtrOutputWithContext(context.Context) LatencyCriteriaPtrOutput
}

type latencyCriteriaPtrType LatencyCriteriaArgs

func LatencyCriteriaPtr(v *LatencyCriteriaArgs) LatencyCriteriaPtrInput {
	return (*latencyCriteriaPtrType)(v)
}

func (*latencyCriteriaPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LatencyCriteria)(nil)).Elem()
}

func (i *latencyCriteriaPtrType) ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput {
	return i.ToLatencyCriteriaPtrOutputWithContext(context.Background())
}

func (i *latencyCriteriaPtrType) ToLatencyCriteriaPtrOutputWithContext(ctx context.Context) LatencyCriteriaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatencyCriteriaPtrOutput)
}

// Parameters for a latency threshold SLI.
type LatencyCriteriaOutput struct{ *pulumi.OutputState }

func (LatencyCriteriaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LatencyCriteria)(nil)).Elem()
}

func (o LatencyCriteriaOutput) ToLatencyCriteriaOutput() LatencyCriteriaOutput {
	return o
}

func (o LatencyCriteriaOutput) ToLatencyCriteriaOutputWithContext(ctx context.Context) LatencyCriteriaOutput {
	return o
}

func (o LatencyCriteriaOutput) ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput {
	return o.ToLatencyCriteriaPtrOutputWithContext(context.Background())
}

func (o LatencyCriteriaOutput) ToLatencyCriteriaPtrOutputWithContext(ctx context.Context) LatencyCriteriaPtrOutput {
	return o.ApplyT(func(v LatencyCriteria) *LatencyCriteria {
		return &v
	}).(LatencyCriteriaPtrOutput)
}

// Good service is defined to be the count of requests made to this service that return in no more than threshold.
func (o LatencyCriteriaOutput) Threshold() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LatencyCriteria) *string { return v.Threshold }).(pulumi.StringPtrOutput)
}

type LatencyCriteriaPtrOutput struct{ *pulumi.OutputState }

func (LatencyCriteriaPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LatencyCriteria)(nil)).Elem()
}

func (o LatencyCriteriaPtrOutput) ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput {
	return o
}

func (o LatencyCriteriaPtrOutput) ToLatencyCriteriaPtrOutputWithContext(ctx context.Context) LatencyCriteriaPtrOutput {
	return o
}

func (o LatencyCriteriaPtrOutput) Elem() LatencyCriteriaOutput {
	return o.ApplyT(func(v *LatencyCriteria) LatencyCriteria { return *v }).(LatencyCriteriaOutput)
}

// Good service is defined to be the count of requests made to this service that return in no more than threshold.
func (o LatencyCriteriaPtrOutput) Threshold() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LatencyCriteria) *string {
		if v == nil {
			return nil
		}
		return v.Threshold
	}).(pulumi.StringPtrOutput)
}

// Parameters for a latency threshold SLI.
type LatencyCriteriaResponse struct {
	// Good service is defined to be the count of requests made to this service that return in no more than threshold.
	Threshold string `pulumi:"threshold"`
}

// LatencyCriteriaResponseInput is an input type that accepts LatencyCriteriaResponseArgs and LatencyCriteriaResponseOutput values.
// You can construct a concrete instance of `LatencyCriteriaResponseInput` via:
//
//          LatencyCriteriaResponseArgs{...}
type LatencyCriteriaResponseInput interface {
	pulumi.Input

	ToLatencyCriteriaResponseOutput() LatencyCriteriaResponseOutput
	ToLatencyCriteriaResponseOutputWithContext(context.Context) LatencyCriteriaResponseOutput
}

// Parameters for a latency threshold SLI.
type LatencyCriteriaResponseArgs struct {
	// Good service is defined to be the count of requests made to this service that return in no more than threshold.
	Threshold pulumi.StringInput `pulumi:"threshold"`
}

func (LatencyCriteriaResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LatencyCriteriaResponse)(nil)).Elem()
}

func (i LatencyCriteriaResponseArgs) ToLatencyCriteriaResponseOutput() LatencyCriteriaResponseOutput {
	return i.ToLatencyCriteriaResponseOutputWithContext(context.Background())
}

func (i LatencyCriteriaResponseArgs) ToLatencyCriteriaResponseOutputWithContext(ctx context.Context) LatencyCriteriaResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatencyCriteriaResponseOutput)
}

func (i LatencyCriteriaResponseArgs) ToLatencyCriteriaResponsePtrOutput() LatencyCriteriaResponsePtrOutput {
	return i.ToLatencyCriteriaResponsePtrOutputWithContext(context.Background())
}

func (i LatencyCriteriaResponseArgs) ToLatencyCriteriaResponsePtrOutputWithContext(ctx context.Context) LatencyCriteriaResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatencyCriteriaResponseOutput).ToLatencyCriteriaResponsePtrOutputWithContext(ctx)
}

// LatencyCriteriaResponsePtrInput is an input type that accepts LatencyCriteriaResponseArgs, LatencyCriteriaResponsePtr and LatencyCriteriaResponsePtrOutput values.
// You can construct a concrete instance of `LatencyCriteriaResponsePtrInput` via:
//
//          LatencyCriteriaResponseArgs{...}
//
//  or:
//
//          nil
type LatencyCriteriaResponsePtrInput interface {
	pulumi.Input

	ToLatencyCriteriaResponsePtrOutput() LatencyCriteriaResponsePtrOutput
	ToLatencyCriteriaResponsePtrOutputWithContext(context.Context) LatencyCriteriaResponsePtrOutput
}

type latencyCriteriaResponsePtrType LatencyCriteriaResponseArgs

func LatencyCriteriaResponsePtr(v *LatencyCriteriaResponseArgs) LatencyCriteriaResponsePtrInput {
	return (*latencyCriteriaResponsePtrType)(v)
}

func (*latencyCriteriaResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LatencyCriteriaResponse)(nil)).Elem()
}

func (i *latencyCriteriaResponsePtrType) ToLatencyCriteriaResponsePtrOutput() LatencyCriteriaResponsePtrOutput {
	return i.ToLatencyCriteriaResponsePtrOutputWithContext(context.Background())
}

func (i *latencyCriteriaResponsePtrType) ToLatencyCriteriaResponsePtrOutputWithContext(ctx context.Context) LatencyCriteriaResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatencyCriteriaResponsePtrOutput)
}

// Parameters for a latency threshold SLI.
type LatencyCriteriaResponseOutput struct{ *pulumi.OutputState }

func (LatencyCriteriaResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LatencyCriteriaResponse)(nil)).Elem()
}

func (o LatencyCriteriaResponseOutput) ToLatencyCriteriaResponseOutput() LatencyCriteriaResponseOutput {
	return o
}

func (o LatencyCriteriaResponseOutput) ToLatencyCriteriaResponseOutputWithContext(ctx context.Context) LatencyCriteriaResponseOutput {
	return o
}

func (o LatencyCriteriaResponseOutput) ToLatencyCriteriaResponsePtrOutput() LatencyCriteriaResponsePtrOutput {
	return o.ToLatencyCriteriaResponsePtrOutputWithContext(context.Background())
}

func (o LatencyCriteriaResponseOutput) ToLatencyCriteriaResponsePtrOutputWithContext(ctx context.Context) LatencyCriteriaResponsePtrOutput {
	return o.ApplyT(func(v LatencyCriteriaResponse) *LatencyCriteriaResponse {
		return &v
	}).(LatencyCriteriaResponsePtrOutput)
}

// Good service is defined to be the count of requests made to this service that return in no more than threshold.
func (o LatencyCriteriaResponseOutput) Threshold() pulumi.StringOutput {
	return o.ApplyT(func(v LatencyCriteriaResponse) string { return v.Threshold }).(pulumi.StringOutput)
}

type LatencyCriteriaResponsePtrOutput struct{ *pulumi.OutputState }

func (LatencyCriteriaResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LatencyCriteriaResponse)(nil)).Elem()
}

func (o LatencyCriteriaResponsePtrOutput) ToLatencyCriteriaResponsePtrOutput() LatencyCriteriaResponsePtrOutput {
	return o
}

func (o LatencyCriteriaResponsePtrOutput) ToLatencyCriteriaResponsePtrOutputWithContext(ctx context.Context) LatencyCriteriaResponsePtrOutput {
	return o
}

func (o LatencyCriteriaResponsePtrOutput) Elem() LatencyCriteriaResponseOutput {
	return o.ApplyT(func(v *LatencyCriteriaResponse) LatencyCriteriaResponse { return *v }).(LatencyCriteriaResponseOutput)
}

// Good service is defined to be the count of requests made to this service that return in no more than threshold.
func (o LatencyCriteriaResponsePtrOutput) Threshold() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LatencyCriteriaResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Threshold
	}).(pulumi.StringPtrOutput)
}

// Specifies a linear sequence of buckets that all have the same width (except overflow and underflow). Each bucket represents a constant absolute uncertainty on the specific value in the bucket.There are num_finite_buckets + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): offset + (width * i). Lower bound (1 <= i < N): offset + (width * (i - 1)).
type Linear struct {
	// Must be greater than 0.
	NumFiniteBuckets *int `pulumi:"numFiniteBuckets"`
	// Lower bound of the first bucket.
	Offset *float64 `pulumi:"offset"`
	// Must be greater than 0.
	Width *float64 `pulumi:"width"`
}

// LinearInput is an input type that accepts LinearArgs and LinearOutput values.
// You can construct a concrete instance of `LinearInput` via:
//
//          LinearArgs{...}
type LinearInput interface {
	pulumi.Input

	ToLinearOutput() LinearOutput
	ToLinearOutputWithContext(context.Context) LinearOutput
}

// Specifies a linear sequence of buckets that all have the same width (except overflow and underflow). Each bucket represents a constant absolute uncertainty on the specific value in the bucket.There are num_finite_buckets + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): offset + (width * i). Lower bound (1 <= i < N): offset + (width * (i - 1)).
type LinearArgs struct {
	// Must be greater than 0.
	NumFiniteBuckets pulumi.IntPtrInput `pulumi:"numFiniteBuckets"`
	// Lower bound of the first bucket.
	Offset pulumi.Float64PtrInput `pulumi:"offset"`
	// Must be greater than 0.
	Width pulumi.Float64PtrInput `pulumi:"width"`
}

func (LinearArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Linear)(nil)).Elem()
}

func (i LinearArgs) ToLinearOutput() LinearOutput {
	return i.ToLinearOutputWithContext(context.Background())
}

func (i LinearArgs) ToLinearOutputWithContext(ctx context.Context) LinearOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LinearOutput)
}

func (i LinearArgs) ToLinearPtrOutput() LinearPtrOutput {
	return i.ToLinearPtrOutputWithContext(context.Background())
}

func (i LinearArgs) ToLinearPtrOutputWithContext(ctx context.Context) LinearPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LinearOutput).ToLinearPtrOutputWithContext(ctx)
}

// LinearPtrInput is an input type that accepts LinearArgs, LinearPtr and LinearPtrOutput values.
// You can construct a concrete instance of `LinearPtrInput` via:
//
//          LinearArgs{...}
//
//  or:
//
//          nil
type LinearPtrInput interface {
	pulumi.Input

	ToLinearPtrOutput() LinearPtrOutput
	ToLinearPtrOutputWithContext(context.Context) LinearPtrOutput
}

type linearPtrType LinearArgs

func LinearPtr(v *LinearArgs) LinearPtrInput {
	return (*linearPtrType)(v)
}

func (*linearPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Linear)(nil)).Elem()
}

func (i *linearPtrType) ToLinearPtrOutput() LinearPtrOutput {
	return i.ToLinearPtrOutputWithContext(context.Background())
}

func (i *linearPtrType) ToLinearPtrOutputWithContext(ctx context.Context) LinearPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LinearPtrOutput)
}

// Specifies a linear sequence of buckets that all have the same width (except overflow and underflow). Each bucket represents a constant absolute uncertainty on the specific value in the bucket.There are num_finite_buckets + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): offset + (width * i). Lower bound (1 <= i < N): offset + (width * (i - 1)).
type LinearOutput struct{ *pulumi.OutputState }

func (LinearOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Linear)(nil)).Elem()
}

func (o LinearOutput) ToLinearOutput() LinearOutput {
	return o
}

func (o LinearOutput) ToLinearOutputWithContext(ctx context.Context) LinearOutput {
	return o
}

func (o LinearOutput) ToLinearPtrOutput() LinearPtrOutput {
	return o.ToLinearPtrOutputWithContext(context.Background())
}

func (o LinearOutput) ToLinearPtrOutputWithContext(ctx context.Context) LinearPtrOutput {
	return o.ApplyT(func(v Linear) *Linear {
		return &v
	}).(LinearPtrOutput)
}

// Must be greater than 0.
func (o LinearOutput) NumFiniteBuckets() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Linear) *int { return v.NumFiniteBuckets }).(pulumi.IntPtrOutput)
}

// Lower bound of the first bucket.
func (o LinearOutput) Offset() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Linear) *float64 { return v.Offset }).(pulumi.Float64PtrOutput)
}

// Must be greater than 0.
func (o LinearOutput) Width() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Linear) *float64 { return v.Width }).(pulumi.Float64PtrOutput)
}

type LinearPtrOutput struct{ *pulumi.OutputState }

func (LinearPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Linear)(nil)).Elem()
}

func (o LinearPtrOutput) ToLinearPtrOutput() LinearPtrOutput {
	return o
}

func (o LinearPtrOutput) ToLinearPtrOutputWithContext(ctx context.Context) LinearPtrOutput {
	return o
}

func (o LinearPtrOutput) Elem() LinearOutput {
	return o.ApplyT(func(v *Linear) Linear { return *v }).(LinearOutput)
}

// Must be greater than 0.
func (o LinearPtrOutput) NumFiniteBuckets() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Linear) *int {
		if v == nil {
			return nil
		}
		return v.NumFiniteBuckets
	}).(pulumi.IntPtrOutput)
}

// Lower bound of the first bucket.
func (o LinearPtrOutput) Offset() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Linear) *float64 {
		if v == nil {
			return nil
		}
		return v.Offset
	}).(pulumi.Float64PtrOutput)
}

// Must be greater than 0.
func (o LinearPtrOutput) Width() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Linear) *float64 {
		if v == nil {
			return nil
		}
		return v.Width
	}).(pulumi.Float64PtrOutput)
}

// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8 will have their services ingested as this type.
type MeshIstio struct {
	// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
	MeshUid *string `pulumi:"meshUid"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName *string `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace *string `pulumi:"serviceNamespace"`
}

// MeshIstioInput is an input type that accepts MeshIstioArgs and MeshIstioOutput values.
// You can construct a concrete instance of `MeshIstioInput` via:
//
//          MeshIstioArgs{...}
type MeshIstioInput interface {
	pulumi.Input

	ToMeshIstioOutput() MeshIstioOutput
	ToMeshIstioOutputWithContext(context.Context) MeshIstioOutput
}

// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8 will have their services ingested as this type.
type MeshIstioArgs struct {
	// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
	MeshUid pulumi.StringPtrInput `pulumi:"meshUid"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace pulumi.StringPtrInput `pulumi:"serviceNamespace"`
}

func (MeshIstioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MeshIstio)(nil)).Elem()
}

func (i MeshIstioArgs) ToMeshIstioOutput() MeshIstioOutput {
	return i.ToMeshIstioOutputWithContext(context.Background())
}

func (i MeshIstioArgs) ToMeshIstioOutputWithContext(ctx context.Context) MeshIstioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeshIstioOutput)
}

func (i MeshIstioArgs) ToMeshIstioPtrOutput() MeshIstioPtrOutput {
	return i.ToMeshIstioPtrOutputWithContext(context.Background())
}

func (i MeshIstioArgs) ToMeshIstioPtrOutputWithContext(ctx context.Context) MeshIstioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeshIstioOutput).ToMeshIstioPtrOutputWithContext(ctx)
}

// MeshIstioPtrInput is an input type that accepts MeshIstioArgs, MeshIstioPtr and MeshIstioPtrOutput values.
// You can construct a concrete instance of `MeshIstioPtrInput` via:
//
//          MeshIstioArgs{...}
//
//  or:
//
//          nil
type MeshIstioPtrInput interface {
	pulumi.Input

	ToMeshIstioPtrOutput() MeshIstioPtrOutput
	ToMeshIstioPtrOutputWithContext(context.Context) MeshIstioPtrOutput
}

type meshIstioPtrType MeshIstioArgs

func MeshIstioPtr(v *MeshIstioArgs) MeshIstioPtrInput {
	return (*meshIstioPtrType)(v)
}

func (*meshIstioPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MeshIstio)(nil)).Elem()
}

func (i *meshIstioPtrType) ToMeshIstioPtrOutput() MeshIstioPtrOutput {
	return i.ToMeshIstioPtrOutputWithContext(context.Background())
}

func (i *meshIstioPtrType) ToMeshIstioPtrOutputWithContext(ctx context.Context) MeshIstioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeshIstioPtrOutput)
}

// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8 will have their services ingested as this type.
type MeshIstioOutput struct{ *pulumi.OutputState }

func (MeshIstioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MeshIstio)(nil)).Elem()
}

func (o MeshIstioOutput) ToMeshIstioOutput() MeshIstioOutput {
	return o
}

func (o MeshIstioOutput) ToMeshIstioOutputWithContext(ctx context.Context) MeshIstioOutput {
	return o
}

func (o MeshIstioOutput) ToMeshIstioPtrOutput() MeshIstioPtrOutput {
	return o.ToMeshIstioPtrOutputWithContext(context.Background())
}

func (o MeshIstioOutput) ToMeshIstioPtrOutputWithContext(ctx context.Context) MeshIstioPtrOutput {
	return o.ApplyT(func(v MeshIstio) *MeshIstio {
		return &v
	}).(MeshIstioPtrOutput)
}

// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
func (o MeshIstioOutput) MeshUid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MeshIstio) *string { return v.MeshUid }).(pulumi.StringPtrOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o MeshIstioOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MeshIstio) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o MeshIstioOutput) ServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MeshIstio) *string { return v.ServiceNamespace }).(pulumi.StringPtrOutput)
}

type MeshIstioPtrOutput struct{ *pulumi.OutputState }

func (MeshIstioPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MeshIstio)(nil)).Elem()
}

func (o MeshIstioPtrOutput) ToMeshIstioPtrOutput() MeshIstioPtrOutput {
	return o
}

func (o MeshIstioPtrOutput) ToMeshIstioPtrOutputWithContext(ctx context.Context) MeshIstioPtrOutput {
	return o
}

func (o MeshIstioPtrOutput) Elem() MeshIstioOutput {
	return o.ApplyT(func(v *MeshIstio) MeshIstio { return *v }).(MeshIstioOutput)
}

// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
func (o MeshIstioPtrOutput) MeshUid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MeshIstio) *string {
		if v == nil {
			return nil
		}
		return v.MeshUid
	}).(pulumi.StringPtrOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o MeshIstioPtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MeshIstio) *string {
		if v == nil {
			return nil
		}
		return v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o MeshIstioPtrOutput) ServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MeshIstio) *string {
		if v == nil {
			return nil
		}
		return v.ServiceNamespace
	}).(pulumi.StringPtrOutput)
}

// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8 will have their services ingested as this type.
type MeshIstioResponse struct {
	// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
	MeshUid string `pulumi:"meshUid"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName string `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace string `pulumi:"serviceNamespace"`
}

// MeshIstioResponseInput is an input type that accepts MeshIstioResponseArgs and MeshIstioResponseOutput values.
// You can construct a concrete instance of `MeshIstioResponseInput` via:
//
//          MeshIstioResponseArgs{...}
type MeshIstioResponseInput interface {
	pulumi.Input

	ToMeshIstioResponseOutput() MeshIstioResponseOutput
	ToMeshIstioResponseOutputWithContext(context.Context) MeshIstioResponseOutput
}

// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8 will have their services ingested as this type.
type MeshIstioResponseArgs struct {
	// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
	MeshUid pulumi.StringInput `pulumi:"meshUid"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName pulumi.StringInput `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace pulumi.StringInput `pulumi:"serviceNamespace"`
}

func (MeshIstioResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MeshIstioResponse)(nil)).Elem()
}

func (i MeshIstioResponseArgs) ToMeshIstioResponseOutput() MeshIstioResponseOutput {
	return i.ToMeshIstioResponseOutputWithContext(context.Background())
}

func (i MeshIstioResponseArgs) ToMeshIstioResponseOutputWithContext(ctx context.Context) MeshIstioResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeshIstioResponseOutput)
}

func (i MeshIstioResponseArgs) ToMeshIstioResponsePtrOutput() MeshIstioResponsePtrOutput {
	return i.ToMeshIstioResponsePtrOutputWithContext(context.Background())
}

func (i MeshIstioResponseArgs) ToMeshIstioResponsePtrOutputWithContext(ctx context.Context) MeshIstioResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeshIstioResponseOutput).ToMeshIstioResponsePtrOutputWithContext(ctx)
}

// MeshIstioResponsePtrInput is an input type that accepts MeshIstioResponseArgs, MeshIstioResponsePtr and MeshIstioResponsePtrOutput values.
// You can construct a concrete instance of `MeshIstioResponsePtrInput` via:
//
//          MeshIstioResponseArgs{...}
//
//  or:
//
//          nil
type MeshIstioResponsePtrInput interface {
	pulumi.Input

	ToMeshIstioResponsePtrOutput() MeshIstioResponsePtrOutput
	ToMeshIstioResponsePtrOutputWithContext(context.Context) MeshIstioResponsePtrOutput
}

type meshIstioResponsePtrType MeshIstioResponseArgs

func MeshIstioResponsePtr(v *MeshIstioResponseArgs) MeshIstioResponsePtrInput {
	return (*meshIstioResponsePtrType)(v)
}

func (*meshIstioResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MeshIstioResponse)(nil)).Elem()
}

func (i *meshIstioResponsePtrType) ToMeshIstioResponsePtrOutput() MeshIstioResponsePtrOutput {
	return i.ToMeshIstioResponsePtrOutputWithContext(context.Background())
}

func (i *meshIstioResponsePtrType) ToMeshIstioResponsePtrOutputWithContext(ctx context.Context) MeshIstioResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeshIstioResponsePtrOutput)
}

// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8 will have their services ingested as this type.
type MeshIstioResponseOutput struct{ *pulumi.OutputState }

func (MeshIstioResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MeshIstioResponse)(nil)).Elem()
}

func (o MeshIstioResponseOutput) ToMeshIstioResponseOutput() MeshIstioResponseOutput {
	return o
}

func (o MeshIstioResponseOutput) ToMeshIstioResponseOutputWithContext(ctx context.Context) MeshIstioResponseOutput {
	return o
}

func (o MeshIstioResponseOutput) ToMeshIstioResponsePtrOutput() MeshIstioResponsePtrOutput {
	return o.ToMeshIstioResponsePtrOutputWithContext(context.Background())
}

func (o MeshIstioResponseOutput) ToMeshIstioResponsePtrOutputWithContext(ctx context.Context) MeshIstioResponsePtrOutput {
	return o.ApplyT(func(v MeshIstioResponse) *MeshIstioResponse {
		return &v
	}).(MeshIstioResponsePtrOutput)
}

// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
func (o MeshIstioResponseOutput) MeshUid() pulumi.StringOutput {
	return o.ApplyT(func(v MeshIstioResponse) string { return v.MeshUid }).(pulumi.StringOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o MeshIstioResponseOutput) ServiceName() pulumi.StringOutput {
	return o.ApplyT(func(v MeshIstioResponse) string { return v.ServiceName }).(pulumi.StringOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o MeshIstioResponseOutput) ServiceNamespace() pulumi.StringOutput {
	return o.ApplyT(func(v MeshIstioResponse) string { return v.ServiceNamespace }).(pulumi.StringOutput)
}

type MeshIstioResponsePtrOutput struct{ *pulumi.OutputState }

func (MeshIstioResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MeshIstioResponse)(nil)).Elem()
}

func (o MeshIstioResponsePtrOutput) ToMeshIstioResponsePtrOutput() MeshIstioResponsePtrOutput {
	return o
}

func (o MeshIstioResponsePtrOutput) ToMeshIstioResponsePtrOutputWithContext(ctx context.Context) MeshIstioResponsePtrOutput {
	return o
}

func (o MeshIstioResponsePtrOutput) Elem() MeshIstioResponseOutput {
	return o.ApplyT(func(v *MeshIstioResponse) MeshIstioResponse { return *v }).(MeshIstioResponseOutput)
}

// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
func (o MeshIstioResponsePtrOutput) MeshUid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MeshIstioResponse) *string {
		if v == nil {
			return nil
		}
		return &v.MeshUid
	}).(pulumi.StringPtrOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o MeshIstioResponsePtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MeshIstioResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o MeshIstioResponsePtrOutput) ServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MeshIstioResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ServiceNamespace
	}).(pulumi.StringPtrOutput)
}

// A specific metric, identified by specifying values for all of the labels of a MetricDescriptor.
type Metric struct {
	// The set of label values that uniquely identify this metric. All labels listed in the MetricDescriptor must be assigned values.
	Labels map[string]string `pulumi:"labels"`
	// An existing metric type, see google.api.MetricDescriptor. For example, custom.googleapis.com/invoice/paid/amount.
	Type *string `pulumi:"type"`
}

// MetricInput is an input type that accepts MetricArgs and MetricOutput values.
// You can construct a concrete instance of `MetricInput` via:
//
//          MetricArgs{...}
type MetricInput interface {
	pulumi.Input

	ToMetricOutput() MetricOutput
	ToMetricOutputWithContext(context.Context) MetricOutput
}

// A specific metric, identified by specifying values for all of the labels of a MetricDescriptor.
type MetricArgs struct {
	// The set of label values that uniquely identify this metric. All labels listed in the MetricDescriptor must be assigned values.
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// An existing metric type, see google.api.MetricDescriptor. For example, custom.googleapis.com/invoice/paid/amount.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (MetricArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Metric)(nil)).Elem()
}

func (i MetricArgs) ToMetricOutput() MetricOutput {
	return i.ToMetricOutputWithContext(context.Background())
}

func (i MetricArgs) ToMetricOutputWithContext(ctx context.Context) MetricOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricOutput)
}

func (i MetricArgs) ToMetricPtrOutput() MetricPtrOutput {
	return i.ToMetricPtrOutputWithContext(context.Background())
}

func (i MetricArgs) ToMetricPtrOutputWithContext(ctx context.Context) MetricPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricOutput).ToMetricPtrOutputWithContext(ctx)
}

// MetricPtrInput is an input type that accepts MetricArgs, MetricPtr and MetricPtrOutput values.
// You can construct a concrete instance of `MetricPtrInput` via:
//
//          MetricArgs{...}
//
//  or:
//
//          nil
type MetricPtrInput interface {
	pulumi.Input

	ToMetricPtrOutput() MetricPtrOutput
	ToMetricPtrOutputWithContext(context.Context) MetricPtrOutput
}

type metricPtrType MetricArgs

func MetricPtr(v *MetricArgs) MetricPtrInput {
	return (*metricPtrType)(v)
}

func (*metricPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Metric)(nil)).Elem()
}

func (i *metricPtrType) ToMetricPtrOutput() MetricPtrOutput {
	return i.ToMetricPtrOutputWithContext(context.Background())
}

func (i *metricPtrType) ToMetricPtrOutputWithContext(ctx context.Context) MetricPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricPtrOutput)
}

// A specific metric, identified by specifying values for all of the labels of a MetricDescriptor.
type MetricOutput struct{ *pulumi.OutputState }

func (MetricOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Metric)(nil)).Elem()
}

func (o MetricOutput) ToMetricOutput() MetricOutput {
	return o
}

func (o MetricOutput) ToMetricOutputWithContext(ctx context.Context) MetricOutput {
	return o
}

func (o MetricOutput) ToMetricPtrOutput() MetricPtrOutput {
	return o.ToMetricPtrOutputWithContext(context.Background())
}

func (o MetricOutput) ToMetricPtrOutputWithContext(ctx context.Context) MetricPtrOutput {
	return o.ApplyT(func(v Metric) *Metric {
		return &v
	}).(MetricPtrOutput)
}

// The set of label values that uniquely identify this metric. All labels listed in the MetricDescriptor must be assigned values.
func (o MetricOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v Metric) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// An existing metric type, see google.api.MetricDescriptor. For example, custom.googleapis.com/invoice/paid/amount.
func (o MetricOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Metric) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type MetricPtrOutput struct{ *pulumi.OutputState }

func (MetricPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Metric)(nil)).Elem()
}

func (o MetricPtrOutput) ToMetricPtrOutput() MetricPtrOutput {
	return o
}

func (o MetricPtrOutput) ToMetricPtrOutputWithContext(ctx context.Context) MetricPtrOutput {
	return o
}

func (o MetricPtrOutput) Elem() MetricOutput {
	return o.ApplyT(func(v *Metric) Metric { return *v }).(MetricOutput)
}

// The set of label values that uniquely identify this metric. All labels listed in the MetricDescriptor must be assigned values.
func (o MetricPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Metric) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// An existing metric type, see google.api.MetricDescriptor. For example, custom.googleapis.com/invoice/paid/amount.
func (o MetricPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Metric) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// A condition type that checks that monitored resources are reporting data. The configuration defines a metric and a set of monitored resources. The predicate is considered in violation when a time series for the specified metric of a monitored resource does not include any data in the specified duration.
type MetricAbsence struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations []Aggregation `pulumi:"aggregations"`
	// The amount of time that a time series must fail to report new data to be considered failing. The minimum value of this field is 120 seconds. Larger values that are a multiple of a minute--for example, 240 or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
	Duration *string `pulumi:"duration"`
	// Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter *string `pulumi:"filter"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
	Trigger *Trigger `pulumi:"trigger"`
}

// MetricAbsenceInput is an input type that accepts MetricAbsenceArgs and MetricAbsenceOutput values.
// You can construct a concrete instance of `MetricAbsenceInput` via:
//
//          MetricAbsenceArgs{...}
type MetricAbsenceInput interface {
	pulumi.Input

	ToMetricAbsenceOutput() MetricAbsenceOutput
	ToMetricAbsenceOutputWithContext(context.Context) MetricAbsenceOutput
}

// A condition type that checks that monitored resources are reporting data. The configuration defines a metric and a set of monitored resources. The predicate is considered in violation when a time series for the specified metric of a monitored resource does not include any data in the specified duration.
type MetricAbsenceArgs struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations AggregationArrayInput `pulumi:"aggregations"`
	// The amount of time that a time series must fail to report new data to be considered failing. The minimum value of this field is 120 seconds. Larger values that are a multiple of a minute--for example, 240 or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
	Duration pulumi.StringPtrInput `pulumi:"duration"`
	// Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter pulumi.StringPtrInput `pulumi:"filter"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
	Trigger TriggerPtrInput `pulumi:"trigger"`
}

func (MetricAbsenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricAbsence)(nil)).Elem()
}

func (i MetricAbsenceArgs) ToMetricAbsenceOutput() MetricAbsenceOutput {
	return i.ToMetricAbsenceOutputWithContext(context.Background())
}

func (i MetricAbsenceArgs) ToMetricAbsenceOutputWithContext(ctx context.Context) MetricAbsenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricAbsenceOutput)
}

func (i MetricAbsenceArgs) ToMetricAbsencePtrOutput() MetricAbsencePtrOutput {
	return i.ToMetricAbsencePtrOutputWithContext(context.Background())
}

func (i MetricAbsenceArgs) ToMetricAbsencePtrOutputWithContext(ctx context.Context) MetricAbsencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricAbsenceOutput).ToMetricAbsencePtrOutputWithContext(ctx)
}

// MetricAbsencePtrInput is an input type that accepts MetricAbsenceArgs, MetricAbsencePtr and MetricAbsencePtrOutput values.
// You can construct a concrete instance of `MetricAbsencePtrInput` via:
//
//          MetricAbsenceArgs{...}
//
//  or:
//
//          nil
type MetricAbsencePtrInput interface {
	pulumi.Input

	ToMetricAbsencePtrOutput() MetricAbsencePtrOutput
	ToMetricAbsencePtrOutputWithContext(context.Context) MetricAbsencePtrOutput
}

type metricAbsencePtrType MetricAbsenceArgs

func MetricAbsencePtr(v *MetricAbsenceArgs) MetricAbsencePtrInput {
	return (*metricAbsencePtrType)(v)
}

func (*metricAbsencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricAbsence)(nil)).Elem()
}

func (i *metricAbsencePtrType) ToMetricAbsencePtrOutput() MetricAbsencePtrOutput {
	return i.ToMetricAbsencePtrOutputWithContext(context.Background())
}

func (i *metricAbsencePtrType) ToMetricAbsencePtrOutputWithContext(ctx context.Context) MetricAbsencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricAbsencePtrOutput)
}

// A condition type that checks that monitored resources are reporting data. The configuration defines a metric and a set of monitored resources. The predicate is considered in violation when a time series for the specified metric of a monitored resource does not include any data in the specified duration.
type MetricAbsenceOutput struct{ *pulumi.OutputState }

func (MetricAbsenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricAbsence)(nil)).Elem()
}

func (o MetricAbsenceOutput) ToMetricAbsenceOutput() MetricAbsenceOutput {
	return o
}

func (o MetricAbsenceOutput) ToMetricAbsenceOutputWithContext(ctx context.Context) MetricAbsenceOutput {
	return o
}

func (o MetricAbsenceOutput) ToMetricAbsencePtrOutput() MetricAbsencePtrOutput {
	return o.ToMetricAbsencePtrOutputWithContext(context.Background())
}

func (o MetricAbsenceOutput) ToMetricAbsencePtrOutputWithContext(ctx context.Context) MetricAbsencePtrOutput {
	return o.ApplyT(func(v MetricAbsence) *MetricAbsence {
		return &v
	}).(MetricAbsencePtrOutput)
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricAbsenceOutput) Aggregations() AggregationArrayOutput {
	return o.ApplyT(func(v MetricAbsence) []Aggregation { return v.Aggregations }).(AggregationArrayOutput)
}

// The amount of time that a time series must fail to report new data to be considered failing. The minimum value of this field is 120 seconds. Larger values that are a multiple of a minute--for example, 240 or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
func (o MetricAbsenceOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricAbsence) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricAbsenceOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricAbsence) *string { return v.Filter }).(pulumi.StringPtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
func (o MetricAbsenceOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v MetricAbsence) *Trigger { return v.Trigger }).(TriggerPtrOutput)
}

type MetricAbsencePtrOutput struct{ *pulumi.OutputState }

func (MetricAbsencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricAbsence)(nil)).Elem()
}

func (o MetricAbsencePtrOutput) ToMetricAbsencePtrOutput() MetricAbsencePtrOutput {
	return o
}

func (o MetricAbsencePtrOutput) ToMetricAbsencePtrOutputWithContext(ctx context.Context) MetricAbsencePtrOutput {
	return o
}

func (o MetricAbsencePtrOutput) Elem() MetricAbsenceOutput {
	return o.ApplyT(func(v *MetricAbsence) MetricAbsence { return *v }).(MetricAbsenceOutput)
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricAbsencePtrOutput) Aggregations() AggregationArrayOutput {
	return o.ApplyT(func(v *MetricAbsence) []Aggregation {
		if v == nil {
			return nil
		}
		return v.Aggregations
	}).(AggregationArrayOutput)
}

// The amount of time that a time series must fail to report new data to be considered failing. The minimum value of this field is 120 seconds. Larger values that are a multiple of a minute--for example, 240 or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
func (o MetricAbsencePtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricAbsence) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricAbsencePtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricAbsence) *string {
		if v == nil {
			return nil
		}
		return v.Filter
	}).(pulumi.StringPtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
func (o MetricAbsencePtrOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v *MetricAbsence) *Trigger {
		if v == nil {
			return nil
		}
		return v.Trigger
	}).(TriggerPtrOutput)
}

// A condition type that checks that monitored resources are reporting data. The configuration defines a metric and a set of monitored resources. The predicate is considered in violation when a time series for the specified metric of a monitored resource does not include any data in the specified duration.
type MetricAbsenceResponse struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations []AggregationResponse `pulumi:"aggregations"`
	// The amount of time that a time series must fail to report new data to be considered failing. The minimum value of this field is 120 seconds. Larger values that are a multiple of a minute--for example, 240 or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
	Duration string `pulumi:"duration"`
	// Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter string `pulumi:"filter"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
	Trigger TriggerResponse `pulumi:"trigger"`
}

// MetricAbsenceResponseInput is an input type that accepts MetricAbsenceResponseArgs and MetricAbsenceResponseOutput values.
// You can construct a concrete instance of `MetricAbsenceResponseInput` via:
//
//          MetricAbsenceResponseArgs{...}
type MetricAbsenceResponseInput interface {
	pulumi.Input

	ToMetricAbsenceResponseOutput() MetricAbsenceResponseOutput
	ToMetricAbsenceResponseOutputWithContext(context.Context) MetricAbsenceResponseOutput
}

// A condition type that checks that monitored resources are reporting data. The configuration defines a metric and a set of monitored resources. The predicate is considered in violation when a time series for the specified metric of a monitored resource does not include any data in the specified duration.
type MetricAbsenceResponseArgs struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations AggregationResponseArrayInput `pulumi:"aggregations"`
	// The amount of time that a time series must fail to report new data to be considered failing. The minimum value of this field is 120 seconds. Larger values that are a multiple of a minute--for example, 240 or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
	Duration pulumi.StringInput `pulumi:"duration"`
	// Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter pulumi.StringInput `pulumi:"filter"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
	Trigger TriggerResponseInput `pulumi:"trigger"`
}

func (MetricAbsenceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricAbsenceResponse)(nil)).Elem()
}

func (i MetricAbsenceResponseArgs) ToMetricAbsenceResponseOutput() MetricAbsenceResponseOutput {
	return i.ToMetricAbsenceResponseOutputWithContext(context.Background())
}

func (i MetricAbsenceResponseArgs) ToMetricAbsenceResponseOutputWithContext(ctx context.Context) MetricAbsenceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricAbsenceResponseOutput)
}

// A condition type that checks that monitored resources are reporting data. The configuration defines a metric and a set of monitored resources. The predicate is considered in violation when a time series for the specified metric of a monitored resource does not include any data in the specified duration.
type MetricAbsenceResponseOutput struct{ *pulumi.OutputState }

func (MetricAbsenceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricAbsenceResponse)(nil)).Elem()
}

func (o MetricAbsenceResponseOutput) ToMetricAbsenceResponseOutput() MetricAbsenceResponseOutput {
	return o
}

func (o MetricAbsenceResponseOutput) ToMetricAbsenceResponseOutputWithContext(ctx context.Context) MetricAbsenceResponseOutput {
	return o
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricAbsenceResponseOutput) Aggregations() AggregationResponseArrayOutput {
	return o.ApplyT(func(v MetricAbsenceResponse) []AggregationResponse { return v.Aggregations }).(AggregationResponseArrayOutput)
}

// The amount of time that a time series must fail to report new data to be considered failing. The minimum value of this field is 120 seconds. Larger values that are a multiple of a minute--for example, 240 or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
func (o MetricAbsenceResponseOutput) Duration() pulumi.StringOutput {
	return o.ApplyT(func(v MetricAbsenceResponse) string { return v.Duration }).(pulumi.StringOutput)
}

// Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricAbsenceResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v MetricAbsenceResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
func (o MetricAbsenceResponseOutput) Trigger() TriggerResponseOutput {
	return o.ApplyT(func(v MetricAbsenceResponse) TriggerResponse { return v.Trigger }).(TriggerResponseOutput)
}

// Additional annotations that can be used to guide the usage of a metric.
type MetricDescriptorMetadata struct {
	// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
	IngestDelay *string `pulumi:"ingestDelay"`
	// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
	SamplePeriod *string `pulumi:"samplePeriod"`
}

// MetricDescriptorMetadataInput is an input type that accepts MetricDescriptorMetadataArgs and MetricDescriptorMetadataOutput values.
// You can construct a concrete instance of `MetricDescriptorMetadataInput` via:
//
//          MetricDescriptorMetadataArgs{...}
type MetricDescriptorMetadataInput interface {
	pulumi.Input

	ToMetricDescriptorMetadataOutput() MetricDescriptorMetadataOutput
	ToMetricDescriptorMetadataOutputWithContext(context.Context) MetricDescriptorMetadataOutput
}

// Additional annotations that can be used to guide the usage of a metric.
type MetricDescriptorMetadataArgs struct {
	// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
	IngestDelay pulumi.StringPtrInput `pulumi:"ingestDelay"`
	// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
	SamplePeriod pulumi.StringPtrInput `pulumi:"samplePeriod"`
}

func (MetricDescriptorMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricDescriptorMetadata)(nil)).Elem()
}

func (i MetricDescriptorMetadataArgs) ToMetricDescriptorMetadataOutput() MetricDescriptorMetadataOutput {
	return i.ToMetricDescriptorMetadataOutputWithContext(context.Background())
}

func (i MetricDescriptorMetadataArgs) ToMetricDescriptorMetadataOutputWithContext(ctx context.Context) MetricDescriptorMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricDescriptorMetadataOutput)
}

func (i MetricDescriptorMetadataArgs) ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput {
	return i.ToMetricDescriptorMetadataPtrOutputWithContext(context.Background())
}

func (i MetricDescriptorMetadataArgs) ToMetricDescriptorMetadataPtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricDescriptorMetadataOutput).ToMetricDescriptorMetadataPtrOutputWithContext(ctx)
}

// MetricDescriptorMetadataPtrInput is an input type that accepts MetricDescriptorMetadataArgs, MetricDescriptorMetadataPtr and MetricDescriptorMetadataPtrOutput values.
// You can construct a concrete instance of `MetricDescriptorMetadataPtrInput` via:
//
//          MetricDescriptorMetadataArgs{...}
//
//  or:
//
//          nil
type MetricDescriptorMetadataPtrInput interface {
	pulumi.Input

	ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput
	ToMetricDescriptorMetadataPtrOutputWithContext(context.Context) MetricDescriptorMetadataPtrOutput
}

type metricDescriptorMetadataPtrType MetricDescriptorMetadataArgs

func MetricDescriptorMetadataPtr(v *MetricDescriptorMetadataArgs) MetricDescriptorMetadataPtrInput {
	return (*metricDescriptorMetadataPtrType)(v)
}

func (*metricDescriptorMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricDescriptorMetadata)(nil)).Elem()
}

func (i *metricDescriptorMetadataPtrType) ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput {
	return i.ToMetricDescriptorMetadataPtrOutputWithContext(context.Background())
}

func (i *metricDescriptorMetadataPtrType) ToMetricDescriptorMetadataPtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricDescriptorMetadataPtrOutput)
}

// Additional annotations that can be used to guide the usage of a metric.
type MetricDescriptorMetadataOutput struct{ *pulumi.OutputState }

func (MetricDescriptorMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricDescriptorMetadata)(nil)).Elem()
}

func (o MetricDescriptorMetadataOutput) ToMetricDescriptorMetadataOutput() MetricDescriptorMetadataOutput {
	return o
}

func (o MetricDescriptorMetadataOutput) ToMetricDescriptorMetadataOutputWithContext(ctx context.Context) MetricDescriptorMetadataOutput {
	return o
}

func (o MetricDescriptorMetadataOutput) ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput {
	return o.ToMetricDescriptorMetadataPtrOutputWithContext(context.Background())
}

func (o MetricDescriptorMetadataOutput) ToMetricDescriptorMetadataPtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataPtrOutput {
	return o.ApplyT(func(v MetricDescriptorMetadata) *MetricDescriptorMetadata {
		return &v
	}).(MetricDescriptorMetadataPtrOutput)
}

// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
func (o MetricDescriptorMetadataOutput) IngestDelay() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricDescriptorMetadata) *string { return v.IngestDelay }).(pulumi.StringPtrOutput)
}

// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
func (o MetricDescriptorMetadataOutput) SamplePeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricDescriptorMetadata) *string { return v.SamplePeriod }).(pulumi.StringPtrOutput)
}

type MetricDescriptorMetadataPtrOutput struct{ *pulumi.OutputState }

func (MetricDescriptorMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricDescriptorMetadata)(nil)).Elem()
}

func (o MetricDescriptorMetadataPtrOutput) ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput {
	return o
}

func (o MetricDescriptorMetadataPtrOutput) ToMetricDescriptorMetadataPtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataPtrOutput {
	return o
}

func (o MetricDescriptorMetadataPtrOutput) Elem() MetricDescriptorMetadataOutput {
	return o.ApplyT(func(v *MetricDescriptorMetadata) MetricDescriptorMetadata { return *v }).(MetricDescriptorMetadataOutput)
}

// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
func (o MetricDescriptorMetadataPtrOutput) IngestDelay() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricDescriptorMetadata) *string {
		if v == nil {
			return nil
		}
		return v.IngestDelay
	}).(pulumi.StringPtrOutput)
}

// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
func (o MetricDescriptorMetadataPtrOutput) SamplePeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricDescriptorMetadata) *string {
		if v == nil {
			return nil
		}
		return v.SamplePeriod
	}).(pulumi.StringPtrOutput)
}

// Additional annotations that can be used to guide the usage of a metric.
type MetricDescriptorMetadataResponse struct {
	// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
	IngestDelay string `pulumi:"ingestDelay"`
	// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
	SamplePeriod string `pulumi:"samplePeriod"`
}

// MetricDescriptorMetadataResponseInput is an input type that accepts MetricDescriptorMetadataResponseArgs and MetricDescriptorMetadataResponseOutput values.
// You can construct a concrete instance of `MetricDescriptorMetadataResponseInput` via:
//
//          MetricDescriptorMetadataResponseArgs{...}
type MetricDescriptorMetadataResponseInput interface {
	pulumi.Input

	ToMetricDescriptorMetadataResponseOutput() MetricDescriptorMetadataResponseOutput
	ToMetricDescriptorMetadataResponseOutputWithContext(context.Context) MetricDescriptorMetadataResponseOutput
}

// Additional annotations that can be used to guide the usage of a metric.
type MetricDescriptorMetadataResponseArgs struct {
	// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
	IngestDelay pulumi.StringInput `pulumi:"ingestDelay"`
	// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
	SamplePeriod pulumi.StringInput `pulumi:"samplePeriod"`
}

func (MetricDescriptorMetadataResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricDescriptorMetadataResponse)(nil)).Elem()
}

func (i MetricDescriptorMetadataResponseArgs) ToMetricDescriptorMetadataResponseOutput() MetricDescriptorMetadataResponseOutput {
	return i.ToMetricDescriptorMetadataResponseOutputWithContext(context.Background())
}

func (i MetricDescriptorMetadataResponseArgs) ToMetricDescriptorMetadataResponseOutputWithContext(ctx context.Context) MetricDescriptorMetadataResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricDescriptorMetadataResponseOutput)
}

func (i MetricDescriptorMetadataResponseArgs) ToMetricDescriptorMetadataResponsePtrOutput() MetricDescriptorMetadataResponsePtrOutput {
	return i.ToMetricDescriptorMetadataResponsePtrOutputWithContext(context.Background())
}

func (i MetricDescriptorMetadataResponseArgs) ToMetricDescriptorMetadataResponsePtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricDescriptorMetadataResponseOutput).ToMetricDescriptorMetadataResponsePtrOutputWithContext(ctx)
}

// MetricDescriptorMetadataResponsePtrInput is an input type that accepts MetricDescriptorMetadataResponseArgs, MetricDescriptorMetadataResponsePtr and MetricDescriptorMetadataResponsePtrOutput values.
// You can construct a concrete instance of `MetricDescriptorMetadataResponsePtrInput` via:
//
//          MetricDescriptorMetadataResponseArgs{...}
//
//  or:
//
//          nil
type MetricDescriptorMetadataResponsePtrInput interface {
	pulumi.Input

	ToMetricDescriptorMetadataResponsePtrOutput() MetricDescriptorMetadataResponsePtrOutput
	ToMetricDescriptorMetadataResponsePtrOutputWithContext(context.Context) MetricDescriptorMetadataResponsePtrOutput
}

type metricDescriptorMetadataResponsePtrType MetricDescriptorMetadataResponseArgs

func MetricDescriptorMetadataResponsePtr(v *MetricDescriptorMetadataResponseArgs) MetricDescriptorMetadataResponsePtrInput {
	return (*metricDescriptorMetadataResponsePtrType)(v)
}

func (*metricDescriptorMetadataResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricDescriptorMetadataResponse)(nil)).Elem()
}

func (i *metricDescriptorMetadataResponsePtrType) ToMetricDescriptorMetadataResponsePtrOutput() MetricDescriptorMetadataResponsePtrOutput {
	return i.ToMetricDescriptorMetadataResponsePtrOutputWithContext(context.Background())
}

func (i *metricDescriptorMetadataResponsePtrType) ToMetricDescriptorMetadataResponsePtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricDescriptorMetadataResponsePtrOutput)
}

// Additional annotations that can be used to guide the usage of a metric.
type MetricDescriptorMetadataResponseOutput struct{ *pulumi.OutputState }

func (MetricDescriptorMetadataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricDescriptorMetadataResponse)(nil)).Elem()
}

func (o MetricDescriptorMetadataResponseOutput) ToMetricDescriptorMetadataResponseOutput() MetricDescriptorMetadataResponseOutput {
	return o
}

func (o MetricDescriptorMetadataResponseOutput) ToMetricDescriptorMetadataResponseOutputWithContext(ctx context.Context) MetricDescriptorMetadataResponseOutput {
	return o
}

func (o MetricDescriptorMetadataResponseOutput) ToMetricDescriptorMetadataResponsePtrOutput() MetricDescriptorMetadataResponsePtrOutput {
	return o.ToMetricDescriptorMetadataResponsePtrOutputWithContext(context.Background())
}

func (o MetricDescriptorMetadataResponseOutput) ToMetricDescriptorMetadataResponsePtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataResponsePtrOutput {
	return o.ApplyT(func(v MetricDescriptorMetadataResponse) *MetricDescriptorMetadataResponse {
		return &v
	}).(MetricDescriptorMetadataResponsePtrOutput)
}

// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
func (o MetricDescriptorMetadataResponseOutput) IngestDelay() pulumi.StringOutput {
	return o.ApplyT(func(v MetricDescriptorMetadataResponse) string { return v.IngestDelay }).(pulumi.StringOutput)
}

// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
func (o MetricDescriptorMetadataResponseOutput) SamplePeriod() pulumi.StringOutput {
	return o.ApplyT(func(v MetricDescriptorMetadataResponse) string { return v.SamplePeriod }).(pulumi.StringOutput)
}

type MetricDescriptorMetadataResponsePtrOutput struct{ *pulumi.OutputState }

func (MetricDescriptorMetadataResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricDescriptorMetadataResponse)(nil)).Elem()
}

func (o MetricDescriptorMetadataResponsePtrOutput) ToMetricDescriptorMetadataResponsePtrOutput() MetricDescriptorMetadataResponsePtrOutput {
	return o
}

func (o MetricDescriptorMetadataResponsePtrOutput) ToMetricDescriptorMetadataResponsePtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataResponsePtrOutput {
	return o
}

func (o MetricDescriptorMetadataResponsePtrOutput) Elem() MetricDescriptorMetadataResponseOutput {
	return o.ApplyT(func(v *MetricDescriptorMetadataResponse) MetricDescriptorMetadataResponse { return *v }).(MetricDescriptorMetadataResponseOutput)
}

// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
func (o MetricDescriptorMetadataResponsePtrOutput) IngestDelay() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricDescriptorMetadataResponse) *string {
		if v == nil {
			return nil
		}
		return &v.IngestDelay
	}).(pulumi.StringPtrOutput)
}

// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
func (o MetricDescriptorMetadataResponsePtrOutput) SamplePeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricDescriptorMetadataResponse) *string {
		if v == nil {
			return nil
		}
		return &v.SamplePeriod
	}).(pulumi.StringPtrOutput)
}

// A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x < range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
type MetricRange struct {
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range *GoogleMonitoringV3Range `pulumi:"range"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
	TimeSeries *string `pulumi:"timeSeries"`
}

// MetricRangeInput is an input type that accepts MetricRangeArgs and MetricRangeOutput values.
// You can construct a concrete instance of `MetricRangeInput` via:
//
//          MetricRangeArgs{...}
type MetricRangeInput interface {
	pulumi.Input

	ToMetricRangeOutput() MetricRangeOutput
	ToMetricRangeOutputWithContext(context.Context) MetricRangeOutput
}

// A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x < range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
type MetricRangeArgs struct {
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range GoogleMonitoringV3RangePtrInput `pulumi:"range"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
	TimeSeries pulumi.StringPtrInput `pulumi:"timeSeries"`
}

func (MetricRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricRange)(nil)).Elem()
}

func (i MetricRangeArgs) ToMetricRangeOutput() MetricRangeOutput {
	return i.ToMetricRangeOutputWithContext(context.Background())
}

func (i MetricRangeArgs) ToMetricRangeOutputWithContext(ctx context.Context) MetricRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricRangeOutput)
}

func (i MetricRangeArgs) ToMetricRangePtrOutput() MetricRangePtrOutput {
	return i.ToMetricRangePtrOutputWithContext(context.Background())
}

func (i MetricRangeArgs) ToMetricRangePtrOutputWithContext(ctx context.Context) MetricRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricRangeOutput).ToMetricRangePtrOutputWithContext(ctx)
}

// MetricRangePtrInput is an input type that accepts MetricRangeArgs, MetricRangePtr and MetricRangePtrOutput values.
// You can construct a concrete instance of `MetricRangePtrInput` via:
//
//          MetricRangeArgs{...}
//
//  or:
//
//          nil
type MetricRangePtrInput interface {
	pulumi.Input

	ToMetricRangePtrOutput() MetricRangePtrOutput
	ToMetricRangePtrOutputWithContext(context.Context) MetricRangePtrOutput
}

type metricRangePtrType MetricRangeArgs

func MetricRangePtr(v *MetricRangeArgs) MetricRangePtrInput {
	return (*metricRangePtrType)(v)
}

func (*metricRangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricRange)(nil)).Elem()
}

func (i *metricRangePtrType) ToMetricRangePtrOutput() MetricRangePtrOutput {
	return i.ToMetricRangePtrOutputWithContext(context.Background())
}

func (i *metricRangePtrType) ToMetricRangePtrOutputWithContext(ctx context.Context) MetricRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricRangePtrOutput)
}

// A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x < range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
type MetricRangeOutput struct{ *pulumi.OutputState }

func (MetricRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricRange)(nil)).Elem()
}

func (o MetricRangeOutput) ToMetricRangeOutput() MetricRangeOutput {
	return o
}

func (o MetricRangeOutput) ToMetricRangeOutputWithContext(ctx context.Context) MetricRangeOutput {
	return o
}

func (o MetricRangeOutput) ToMetricRangePtrOutput() MetricRangePtrOutput {
	return o.ToMetricRangePtrOutputWithContext(context.Background())
}

func (o MetricRangeOutput) ToMetricRangePtrOutputWithContext(ctx context.Context) MetricRangePtrOutput {
	return o.ApplyT(func(v MetricRange) *MetricRange {
		return &v
	}).(MetricRangePtrOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o MetricRangeOutput) Range() GoogleMonitoringV3RangePtrOutput {
	return o.ApplyT(func(v MetricRange) *GoogleMonitoringV3Range { return v.Range }).(GoogleMonitoringV3RangePtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
func (o MetricRangeOutput) TimeSeries() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricRange) *string { return v.TimeSeries }).(pulumi.StringPtrOutput)
}

type MetricRangePtrOutput struct{ *pulumi.OutputState }

func (MetricRangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricRange)(nil)).Elem()
}

func (o MetricRangePtrOutput) ToMetricRangePtrOutput() MetricRangePtrOutput {
	return o
}

func (o MetricRangePtrOutput) ToMetricRangePtrOutputWithContext(ctx context.Context) MetricRangePtrOutput {
	return o
}

func (o MetricRangePtrOutput) Elem() MetricRangeOutput {
	return o.ApplyT(func(v *MetricRange) MetricRange { return *v }).(MetricRangeOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o MetricRangePtrOutput) Range() GoogleMonitoringV3RangePtrOutput {
	return o.ApplyT(func(v *MetricRange) *GoogleMonitoringV3Range {
		if v == nil {
			return nil
		}
		return v.Range
	}).(GoogleMonitoringV3RangePtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
func (o MetricRangePtrOutput) TimeSeries() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricRange) *string {
		if v == nil {
			return nil
		}
		return v.TimeSeries
	}).(pulumi.StringPtrOutput)
}

// A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x < range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
type MetricRangeResponse struct {
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range GoogleMonitoringV3RangeResponse `pulumi:"range"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
	TimeSeries string `pulumi:"timeSeries"`
}

// MetricRangeResponseInput is an input type that accepts MetricRangeResponseArgs and MetricRangeResponseOutput values.
// You can construct a concrete instance of `MetricRangeResponseInput` via:
//
//          MetricRangeResponseArgs{...}
type MetricRangeResponseInput interface {
	pulumi.Input

	ToMetricRangeResponseOutput() MetricRangeResponseOutput
	ToMetricRangeResponseOutputWithContext(context.Context) MetricRangeResponseOutput
}

// A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x < range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
type MetricRangeResponseArgs struct {
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range GoogleMonitoringV3RangeResponseInput `pulumi:"range"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
	TimeSeries pulumi.StringInput `pulumi:"timeSeries"`
}

func (MetricRangeResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricRangeResponse)(nil)).Elem()
}

func (i MetricRangeResponseArgs) ToMetricRangeResponseOutput() MetricRangeResponseOutput {
	return i.ToMetricRangeResponseOutputWithContext(context.Background())
}

func (i MetricRangeResponseArgs) ToMetricRangeResponseOutputWithContext(ctx context.Context) MetricRangeResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricRangeResponseOutput)
}

func (i MetricRangeResponseArgs) ToMetricRangeResponsePtrOutput() MetricRangeResponsePtrOutput {
	return i.ToMetricRangeResponsePtrOutputWithContext(context.Background())
}

func (i MetricRangeResponseArgs) ToMetricRangeResponsePtrOutputWithContext(ctx context.Context) MetricRangeResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricRangeResponseOutput).ToMetricRangeResponsePtrOutputWithContext(ctx)
}

// MetricRangeResponsePtrInput is an input type that accepts MetricRangeResponseArgs, MetricRangeResponsePtr and MetricRangeResponsePtrOutput values.
// You can construct a concrete instance of `MetricRangeResponsePtrInput` via:
//
//          MetricRangeResponseArgs{...}
//
//  or:
//
//          nil
type MetricRangeResponsePtrInput interface {
	pulumi.Input

	ToMetricRangeResponsePtrOutput() MetricRangeResponsePtrOutput
	ToMetricRangeResponsePtrOutputWithContext(context.Context) MetricRangeResponsePtrOutput
}

type metricRangeResponsePtrType MetricRangeResponseArgs

func MetricRangeResponsePtr(v *MetricRangeResponseArgs) MetricRangeResponsePtrInput {
	return (*metricRangeResponsePtrType)(v)
}

func (*metricRangeResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricRangeResponse)(nil)).Elem()
}

func (i *metricRangeResponsePtrType) ToMetricRangeResponsePtrOutput() MetricRangeResponsePtrOutput {
	return i.ToMetricRangeResponsePtrOutputWithContext(context.Background())
}

func (i *metricRangeResponsePtrType) ToMetricRangeResponsePtrOutputWithContext(ctx context.Context) MetricRangeResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricRangeResponsePtrOutput)
}

// A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x < range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
type MetricRangeResponseOutput struct{ *pulumi.OutputState }

func (MetricRangeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricRangeResponse)(nil)).Elem()
}

func (o MetricRangeResponseOutput) ToMetricRangeResponseOutput() MetricRangeResponseOutput {
	return o
}

func (o MetricRangeResponseOutput) ToMetricRangeResponseOutputWithContext(ctx context.Context) MetricRangeResponseOutput {
	return o
}

func (o MetricRangeResponseOutput) ToMetricRangeResponsePtrOutput() MetricRangeResponsePtrOutput {
	return o.ToMetricRangeResponsePtrOutputWithContext(context.Background())
}

func (o MetricRangeResponseOutput) ToMetricRangeResponsePtrOutputWithContext(ctx context.Context) MetricRangeResponsePtrOutput {
	return o.ApplyT(func(v MetricRangeResponse) *MetricRangeResponse {
		return &v
	}).(MetricRangeResponsePtrOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o MetricRangeResponseOutput) Range() GoogleMonitoringV3RangeResponseOutput {
	return o.ApplyT(func(v MetricRangeResponse) GoogleMonitoringV3RangeResponse { return v.Range }).(GoogleMonitoringV3RangeResponseOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
func (o MetricRangeResponseOutput) TimeSeries() pulumi.StringOutput {
	return o.ApplyT(func(v MetricRangeResponse) string { return v.TimeSeries }).(pulumi.StringOutput)
}

type MetricRangeResponsePtrOutput struct{ *pulumi.OutputState }

func (MetricRangeResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricRangeResponse)(nil)).Elem()
}

func (o MetricRangeResponsePtrOutput) ToMetricRangeResponsePtrOutput() MetricRangeResponsePtrOutput {
	return o
}

func (o MetricRangeResponsePtrOutput) ToMetricRangeResponsePtrOutputWithContext(ctx context.Context) MetricRangeResponsePtrOutput {
	return o
}

func (o MetricRangeResponsePtrOutput) Elem() MetricRangeResponseOutput {
	return o.ApplyT(func(v *MetricRangeResponse) MetricRangeResponse { return *v }).(MetricRangeResponseOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o MetricRangeResponsePtrOutput) Range() GoogleMonitoringV3RangeResponsePtrOutput {
	return o.ApplyT(func(v *MetricRangeResponse) *GoogleMonitoringV3RangeResponse {
		if v == nil {
			return nil
		}
		return &v.Range
	}).(GoogleMonitoringV3RangeResponsePtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
func (o MetricRangeResponsePtrOutput) TimeSeries() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricRangeResponse) *string {
		if v == nil {
			return nil
		}
		return &v.TimeSeries
	}).(pulumi.StringPtrOutput)
}

// A condition type that compares a collection of time series against a threshold.
type MetricThreshold struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations []Aggregation `pulumi:"aggregations"`
	// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
	Comparison *string `pulumi:"comparison"`
	// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
	DenominatorAggregations []Aggregation `pulumi:"denominatorAggregations"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
	DenominatorFilter *string `pulumi:"denominatorFilter"`
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration *string `pulumi:"duration"`
	// Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter *string `pulumi:"filter"`
	// A value against which to compare the time series.
	ThresholdValue *float64 `pulumi:"thresholdValue"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger *Trigger `pulumi:"trigger"`
}

// MetricThresholdInput is an input type that accepts MetricThresholdArgs and MetricThresholdOutput values.
// You can construct a concrete instance of `MetricThresholdInput` via:
//
//          MetricThresholdArgs{...}
type MetricThresholdInput interface {
	pulumi.Input

	ToMetricThresholdOutput() MetricThresholdOutput
	ToMetricThresholdOutputWithContext(context.Context) MetricThresholdOutput
}

// A condition type that compares a collection of time series against a threshold.
type MetricThresholdArgs struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations AggregationArrayInput `pulumi:"aggregations"`
	// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
	Comparison pulumi.StringPtrInput `pulumi:"comparison"`
	// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
	DenominatorAggregations AggregationArrayInput `pulumi:"denominatorAggregations"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
	DenominatorFilter pulumi.StringPtrInput `pulumi:"denominatorFilter"`
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration pulumi.StringPtrInput `pulumi:"duration"`
	// Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter pulumi.StringPtrInput `pulumi:"filter"`
	// A value against which to compare the time series.
	ThresholdValue pulumi.Float64PtrInput `pulumi:"thresholdValue"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger TriggerPtrInput `pulumi:"trigger"`
}

func (MetricThresholdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricThreshold)(nil)).Elem()
}

func (i MetricThresholdArgs) ToMetricThresholdOutput() MetricThresholdOutput {
	return i.ToMetricThresholdOutputWithContext(context.Background())
}

func (i MetricThresholdArgs) ToMetricThresholdOutputWithContext(ctx context.Context) MetricThresholdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricThresholdOutput)
}

func (i MetricThresholdArgs) ToMetricThresholdPtrOutput() MetricThresholdPtrOutput {
	return i.ToMetricThresholdPtrOutputWithContext(context.Background())
}

func (i MetricThresholdArgs) ToMetricThresholdPtrOutputWithContext(ctx context.Context) MetricThresholdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricThresholdOutput).ToMetricThresholdPtrOutputWithContext(ctx)
}

// MetricThresholdPtrInput is an input type that accepts MetricThresholdArgs, MetricThresholdPtr and MetricThresholdPtrOutput values.
// You can construct a concrete instance of `MetricThresholdPtrInput` via:
//
//          MetricThresholdArgs{...}
//
//  or:
//
//          nil
type MetricThresholdPtrInput interface {
	pulumi.Input

	ToMetricThresholdPtrOutput() MetricThresholdPtrOutput
	ToMetricThresholdPtrOutputWithContext(context.Context) MetricThresholdPtrOutput
}

type metricThresholdPtrType MetricThresholdArgs

func MetricThresholdPtr(v *MetricThresholdArgs) MetricThresholdPtrInput {
	return (*metricThresholdPtrType)(v)
}

func (*metricThresholdPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricThreshold)(nil)).Elem()
}

func (i *metricThresholdPtrType) ToMetricThresholdPtrOutput() MetricThresholdPtrOutput {
	return i.ToMetricThresholdPtrOutputWithContext(context.Background())
}

func (i *metricThresholdPtrType) ToMetricThresholdPtrOutputWithContext(ctx context.Context) MetricThresholdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricThresholdPtrOutput)
}

// A condition type that compares a collection of time series against a threshold.
type MetricThresholdOutput struct{ *pulumi.OutputState }

func (MetricThresholdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricThreshold)(nil)).Elem()
}

func (o MetricThresholdOutput) ToMetricThresholdOutput() MetricThresholdOutput {
	return o
}

func (o MetricThresholdOutput) ToMetricThresholdOutputWithContext(ctx context.Context) MetricThresholdOutput {
	return o
}

func (o MetricThresholdOutput) ToMetricThresholdPtrOutput() MetricThresholdPtrOutput {
	return o.ToMetricThresholdPtrOutputWithContext(context.Background())
}

func (o MetricThresholdOutput) ToMetricThresholdPtrOutputWithContext(ctx context.Context) MetricThresholdPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *MetricThreshold {
		return &v
	}).(MetricThresholdPtrOutput)
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricThresholdOutput) Aggregations() AggregationArrayOutput {
	return o.ApplyT(func(v MetricThreshold) []Aggregation { return v.Aggregations }).(AggregationArrayOutput)
}

// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
func (o MetricThresholdOutput) Comparison() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *string { return v.Comparison }).(pulumi.StringPtrOutput)
}

// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
func (o MetricThresholdOutput) DenominatorAggregations() AggregationArrayOutput {
	return o.ApplyT(func(v MetricThreshold) []Aggregation { return v.DenominatorAggregations }).(AggregationArrayOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
func (o MetricThresholdOutput) DenominatorFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *string { return v.DenominatorFilter }).(pulumi.StringPtrOutput)
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MetricThresholdOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricThresholdOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *string { return v.Filter }).(pulumi.StringPtrOutput)
}

// A value against which to compare the time series.
func (o MetricThresholdOutput) ThresholdValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v MetricThreshold) *float64 { return v.ThresholdValue }).(pulumi.Float64PtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MetricThresholdOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *Trigger { return v.Trigger }).(TriggerPtrOutput)
}

type MetricThresholdPtrOutput struct{ *pulumi.OutputState }

func (MetricThresholdPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricThreshold)(nil)).Elem()
}

func (o MetricThresholdPtrOutput) ToMetricThresholdPtrOutput() MetricThresholdPtrOutput {
	return o
}

func (o MetricThresholdPtrOutput) ToMetricThresholdPtrOutputWithContext(ctx context.Context) MetricThresholdPtrOutput {
	return o
}

func (o MetricThresholdPtrOutput) Elem() MetricThresholdOutput {
	return o.ApplyT(func(v *MetricThreshold) MetricThreshold { return *v }).(MetricThresholdOutput)
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricThresholdPtrOutput) Aggregations() AggregationArrayOutput {
	return o.ApplyT(func(v *MetricThreshold) []Aggregation {
		if v == nil {
			return nil
		}
		return v.Aggregations
	}).(AggregationArrayOutput)
}

// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
func (o MetricThresholdPtrOutput) Comparison() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *string {
		if v == nil {
			return nil
		}
		return v.Comparison
	}).(pulumi.StringPtrOutput)
}

// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
func (o MetricThresholdPtrOutput) DenominatorAggregations() AggregationArrayOutput {
	return o.ApplyT(func(v *MetricThreshold) []Aggregation {
		if v == nil {
			return nil
		}
		return v.DenominatorAggregations
	}).(AggregationArrayOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
func (o MetricThresholdPtrOutput) DenominatorFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *string {
		if v == nil {
			return nil
		}
		return v.DenominatorFilter
	}).(pulumi.StringPtrOutput)
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MetricThresholdPtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricThresholdPtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *string {
		if v == nil {
			return nil
		}
		return v.Filter
	}).(pulumi.StringPtrOutput)
}

// A value against which to compare the time series.
func (o MetricThresholdPtrOutput) ThresholdValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *float64 {
		if v == nil {
			return nil
		}
		return v.ThresholdValue
	}).(pulumi.Float64PtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MetricThresholdPtrOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *Trigger {
		if v == nil {
			return nil
		}
		return v.Trigger
	}).(TriggerPtrOutput)
}

// A condition type that compares a collection of time series against a threshold.
type MetricThresholdResponse struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations []AggregationResponse `pulumi:"aggregations"`
	// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
	Comparison string `pulumi:"comparison"`
	// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
	DenominatorAggregations []AggregationResponse `pulumi:"denominatorAggregations"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
	DenominatorFilter string `pulumi:"denominatorFilter"`
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration string `pulumi:"duration"`
	// Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter string `pulumi:"filter"`
	// A value against which to compare the time series.
	ThresholdValue float64 `pulumi:"thresholdValue"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger TriggerResponse `pulumi:"trigger"`
}

// MetricThresholdResponseInput is an input type that accepts MetricThresholdResponseArgs and MetricThresholdResponseOutput values.
// You can construct a concrete instance of `MetricThresholdResponseInput` via:
//
//          MetricThresholdResponseArgs{...}
type MetricThresholdResponseInput interface {
	pulumi.Input

	ToMetricThresholdResponseOutput() MetricThresholdResponseOutput
	ToMetricThresholdResponseOutputWithContext(context.Context) MetricThresholdResponseOutput
}

// A condition type that compares a collection of time series against a threshold.
type MetricThresholdResponseArgs struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations AggregationResponseArrayInput `pulumi:"aggregations"`
	// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
	Comparison pulumi.StringInput `pulumi:"comparison"`
	// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
	DenominatorAggregations AggregationResponseArrayInput `pulumi:"denominatorAggregations"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
	DenominatorFilter pulumi.StringInput `pulumi:"denominatorFilter"`
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration pulumi.StringInput `pulumi:"duration"`
	// Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter pulumi.StringInput `pulumi:"filter"`
	// A value against which to compare the time series.
	ThresholdValue pulumi.Float64Input `pulumi:"thresholdValue"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger TriggerResponseInput `pulumi:"trigger"`
}

func (MetricThresholdResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricThresholdResponse)(nil)).Elem()
}

func (i MetricThresholdResponseArgs) ToMetricThresholdResponseOutput() MetricThresholdResponseOutput {
	return i.ToMetricThresholdResponseOutputWithContext(context.Background())
}

func (i MetricThresholdResponseArgs) ToMetricThresholdResponseOutputWithContext(ctx context.Context) MetricThresholdResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricThresholdResponseOutput)
}

// A condition type that compares a collection of time series against a threshold.
type MetricThresholdResponseOutput struct{ *pulumi.OutputState }

func (MetricThresholdResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricThresholdResponse)(nil)).Elem()
}

func (o MetricThresholdResponseOutput) ToMetricThresholdResponseOutput() MetricThresholdResponseOutput {
	return o
}

func (o MetricThresholdResponseOutput) ToMetricThresholdResponseOutputWithContext(ctx context.Context) MetricThresholdResponseOutput {
	return o
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricThresholdResponseOutput) Aggregations() AggregationResponseArrayOutput {
	return o.ApplyT(func(v MetricThresholdResponse) []AggregationResponse { return v.Aggregations }).(AggregationResponseArrayOutput)
}

// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
func (o MetricThresholdResponseOutput) Comparison() pulumi.StringOutput {
	return o.ApplyT(func(v MetricThresholdResponse) string { return v.Comparison }).(pulumi.StringOutput)
}

// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
func (o MetricThresholdResponseOutput) DenominatorAggregations() AggregationResponseArrayOutput {
	return o.ApplyT(func(v MetricThresholdResponse) []AggregationResponse { return v.DenominatorAggregations }).(AggregationResponseArrayOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
func (o MetricThresholdResponseOutput) DenominatorFilter() pulumi.StringOutput {
	return o.ApplyT(func(v MetricThresholdResponse) string { return v.DenominatorFilter }).(pulumi.StringOutput)
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MetricThresholdResponseOutput) Duration() pulumi.StringOutput {
	return o.ApplyT(func(v MetricThresholdResponse) string { return v.Duration }).(pulumi.StringOutput)
}

// Required. A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricThresholdResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v MetricThresholdResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// A value against which to compare the time series.
func (o MetricThresholdResponseOutput) ThresholdValue() pulumi.Float64Output {
	return o.ApplyT(func(v MetricThresholdResponse) float64 { return v.ThresholdValue }).(pulumi.Float64Output)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MetricThresholdResponseOutput) Trigger() TriggerResponseOutput {
	return o.ApplyT(func(v MetricThresholdResponse) TriggerResponse { return v.Trigger }).(TriggerResponseOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "instance_id" and "zone": { "type": "gce_instance", "labels": { "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResource struct {
	// Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels map[string]string `pulumi:"labels"`
	// Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types and Logging resource types.
	Type *string `pulumi:"type"`
}

// MonitoredResourceInput is an input type that accepts MonitoredResourceArgs and MonitoredResourceOutput values.
// You can construct a concrete instance of `MonitoredResourceInput` via:
//
//          MonitoredResourceArgs{...}
type MonitoredResourceInput interface {
	pulumi.Input

	ToMonitoredResourceOutput() MonitoredResourceOutput
	ToMonitoredResourceOutputWithContext(context.Context) MonitoredResourceOutput
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "instance_id" and "zone": { "type": "gce_instance", "labels": { "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceArgs struct {
	// Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types and Logging resource types.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (MonitoredResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResource)(nil)).Elem()
}

func (i MonitoredResourceArgs) ToMonitoredResourceOutput() MonitoredResourceOutput {
	return i.ToMonitoredResourceOutputWithContext(context.Background())
}

func (i MonitoredResourceArgs) ToMonitoredResourceOutputWithContext(ctx context.Context) MonitoredResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceOutput)
}

func (i MonitoredResourceArgs) ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput {
	return i.ToMonitoredResourcePtrOutputWithContext(context.Background())
}

func (i MonitoredResourceArgs) ToMonitoredResourcePtrOutputWithContext(ctx context.Context) MonitoredResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceOutput).ToMonitoredResourcePtrOutputWithContext(ctx)
}

// MonitoredResourcePtrInput is an input type that accepts MonitoredResourceArgs, MonitoredResourcePtr and MonitoredResourcePtrOutput values.
// You can construct a concrete instance of `MonitoredResourcePtrInput` via:
//
//          MonitoredResourceArgs{...}
//
//  or:
//
//          nil
type MonitoredResourcePtrInput interface {
	pulumi.Input

	ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput
	ToMonitoredResourcePtrOutputWithContext(context.Context) MonitoredResourcePtrOutput
}

type monitoredResourcePtrType MonitoredResourceArgs

func MonitoredResourcePtr(v *MonitoredResourceArgs) MonitoredResourcePtrInput {
	return (*monitoredResourcePtrType)(v)
}

func (*monitoredResourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoredResource)(nil)).Elem()
}

func (i *monitoredResourcePtrType) ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput {
	return i.ToMonitoredResourcePtrOutputWithContext(context.Background())
}

func (i *monitoredResourcePtrType) ToMonitoredResourcePtrOutputWithContext(ctx context.Context) MonitoredResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourcePtrOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "instance_id" and "zone": { "type": "gce_instance", "labels": { "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceOutput struct{ *pulumi.OutputState }

func (MonitoredResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResource)(nil)).Elem()
}

func (o MonitoredResourceOutput) ToMonitoredResourceOutput() MonitoredResourceOutput {
	return o
}

func (o MonitoredResourceOutput) ToMonitoredResourceOutputWithContext(ctx context.Context) MonitoredResourceOutput {
	return o
}

func (o MonitoredResourceOutput) ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput {
	return o.ToMonitoredResourcePtrOutputWithContext(context.Background())
}

func (o MonitoredResourceOutput) ToMonitoredResourcePtrOutputWithContext(ctx context.Context) MonitoredResourcePtrOutput {
	return o.ApplyT(func(v MonitoredResource) *MonitoredResource {
		return &v
	}).(MonitoredResourcePtrOutput)
}

// Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
func (o MonitoredResourceOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v MonitoredResource) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types and Logging resource types.
func (o MonitoredResourceOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MonitoredResource) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type MonitoredResourcePtrOutput struct{ *pulumi.OutputState }

func (MonitoredResourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoredResource)(nil)).Elem()
}

func (o MonitoredResourcePtrOutput) ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput {
	return o
}

func (o MonitoredResourcePtrOutput) ToMonitoredResourcePtrOutputWithContext(ctx context.Context) MonitoredResourcePtrOutput {
	return o
}

func (o MonitoredResourcePtrOutput) Elem() MonitoredResourceOutput {
	return o.ApplyT(func(v *MonitoredResource) MonitoredResource { return *v }).(MonitoredResourceOutput)
}

// Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
func (o MonitoredResourcePtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *MonitoredResource) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types and Logging resource types.
func (o MonitoredResourcePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MonitoredResource) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Auxiliary metadata for a MonitoredResource object. MonitoredResource objects contain the minimum set of information to uniquely identify a monitored resource instance. There is some other useful auxiliary metadata. Monitoring and Logging use an ingestion pipeline to extract metadata for cloud resources of all types, and store the metadata in this message.
type MonitoredResourceMetadata struct {
	// Values for predefined system metadata labels. System labels are a kind of metadata extracted by Google, including "machine_image", "vpc", "subnet_id", "security_group", "name", etc. System label values can be only strings, Boolean values, or a list of strings. For example: { "name": "my-test-instance", "security_group": ["a", "b", "c"], "spot_instance": false }
	SystemLabels map[string]string `pulumi:"systemLabels"`
	// A map of user-defined metadata labels.
	UserLabels map[string]string `pulumi:"userLabels"`
}

// MonitoredResourceMetadataInput is an input type that accepts MonitoredResourceMetadataArgs and MonitoredResourceMetadataOutput values.
// You can construct a concrete instance of `MonitoredResourceMetadataInput` via:
//
//          MonitoredResourceMetadataArgs{...}
type MonitoredResourceMetadataInput interface {
	pulumi.Input

	ToMonitoredResourceMetadataOutput() MonitoredResourceMetadataOutput
	ToMonitoredResourceMetadataOutputWithContext(context.Context) MonitoredResourceMetadataOutput
}

// Auxiliary metadata for a MonitoredResource object. MonitoredResource objects contain the minimum set of information to uniquely identify a monitored resource instance. There is some other useful auxiliary metadata. Monitoring and Logging use an ingestion pipeline to extract metadata for cloud resources of all types, and store the metadata in this message.
type MonitoredResourceMetadataArgs struct {
	// Values for predefined system metadata labels. System labels are a kind of metadata extracted by Google, including "machine_image", "vpc", "subnet_id", "security_group", "name", etc. System label values can be only strings, Boolean values, or a list of strings. For example: { "name": "my-test-instance", "security_group": ["a", "b", "c"], "spot_instance": false }
	SystemLabels pulumi.StringMapInput `pulumi:"systemLabels"`
	// A map of user-defined metadata labels.
	UserLabels pulumi.StringMapInput `pulumi:"userLabels"`
}

func (MonitoredResourceMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResourceMetadata)(nil)).Elem()
}

func (i MonitoredResourceMetadataArgs) ToMonitoredResourceMetadataOutput() MonitoredResourceMetadataOutput {
	return i.ToMonitoredResourceMetadataOutputWithContext(context.Background())
}

func (i MonitoredResourceMetadataArgs) ToMonitoredResourceMetadataOutputWithContext(ctx context.Context) MonitoredResourceMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceMetadataOutput)
}

func (i MonitoredResourceMetadataArgs) ToMonitoredResourceMetadataPtrOutput() MonitoredResourceMetadataPtrOutput {
	return i.ToMonitoredResourceMetadataPtrOutputWithContext(context.Background())
}

func (i MonitoredResourceMetadataArgs) ToMonitoredResourceMetadataPtrOutputWithContext(ctx context.Context) MonitoredResourceMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceMetadataOutput).ToMonitoredResourceMetadataPtrOutputWithContext(ctx)
}

// MonitoredResourceMetadataPtrInput is an input type that accepts MonitoredResourceMetadataArgs, MonitoredResourceMetadataPtr and MonitoredResourceMetadataPtrOutput values.
// You can construct a concrete instance of `MonitoredResourceMetadataPtrInput` via:
//
//          MonitoredResourceMetadataArgs{...}
//
//  or:
//
//          nil
type MonitoredResourceMetadataPtrInput interface {
	pulumi.Input

	ToMonitoredResourceMetadataPtrOutput() MonitoredResourceMetadataPtrOutput
	ToMonitoredResourceMetadataPtrOutputWithContext(context.Context) MonitoredResourceMetadataPtrOutput
}

type monitoredResourceMetadataPtrType MonitoredResourceMetadataArgs

func MonitoredResourceMetadataPtr(v *MonitoredResourceMetadataArgs) MonitoredResourceMetadataPtrInput {
	return (*monitoredResourceMetadataPtrType)(v)
}

func (*monitoredResourceMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoredResourceMetadata)(nil)).Elem()
}

func (i *monitoredResourceMetadataPtrType) ToMonitoredResourceMetadataPtrOutput() MonitoredResourceMetadataPtrOutput {
	return i.ToMonitoredResourceMetadataPtrOutputWithContext(context.Background())
}

func (i *monitoredResourceMetadataPtrType) ToMonitoredResourceMetadataPtrOutputWithContext(ctx context.Context) MonitoredResourceMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceMetadataPtrOutput)
}

// Auxiliary metadata for a MonitoredResource object. MonitoredResource objects contain the minimum set of information to uniquely identify a monitored resource instance. There is some other useful auxiliary metadata. Monitoring and Logging use an ingestion pipeline to extract metadata for cloud resources of all types, and store the metadata in this message.
type MonitoredResourceMetadataOutput struct{ *pulumi.OutputState }

func (MonitoredResourceMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResourceMetadata)(nil)).Elem()
}

func (o MonitoredResourceMetadataOutput) ToMonitoredResourceMetadataOutput() MonitoredResourceMetadataOutput {
	return o
}

func (o MonitoredResourceMetadataOutput) ToMonitoredResourceMetadataOutputWithContext(ctx context.Context) MonitoredResourceMetadataOutput {
	return o
}

func (o MonitoredResourceMetadataOutput) ToMonitoredResourceMetadataPtrOutput() MonitoredResourceMetadataPtrOutput {
	return o.ToMonitoredResourceMetadataPtrOutputWithContext(context.Background())
}

func (o MonitoredResourceMetadataOutput) ToMonitoredResourceMetadataPtrOutputWithContext(ctx context.Context) MonitoredResourceMetadataPtrOutput {
	return o.ApplyT(func(v MonitoredResourceMetadata) *MonitoredResourceMetadata {
		return &v
	}).(MonitoredResourceMetadataPtrOutput)
}

// Values for predefined system metadata labels. System labels are a kind of metadata extracted by Google, including "machine_image", "vpc", "subnet_id", "security_group", "name", etc. System label values can be only strings, Boolean values, or a list of strings. For example: { "name": "my-test-instance", "security_group": ["a", "b", "c"], "spot_instance": false }
func (o MonitoredResourceMetadataOutput) SystemLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v MonitoredResourceMetadata) map[string]string { return v.SystemLabels }).(pulumi.StringMapOutput)
}

// A map of user-defined metadata labels.
func (o MonitoredResourceMetadataOutput) UserLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v MonitoredResourceMetadata) map[string]string { return v.UserLabels }).(pulumi.StringMapOutput)
}

type MonitoredResourceMetadataPtrOutput struct{ *pulumi.OutputState }

func (MonitoredResourceMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoredResourceMetadata)(nil)).Elem()
}

func (o MonitoredResourceMetadataPtrOutput) ToMonitoredResourceMetadataPtrOutput() MonitoredResourceMetadataPtrOutput {
	return o
}

func (o MonitoredResourceMetadataPtrOutput) ToMonitoredResourceMetadataPtrOutputWithContext(ctx context.Context) MonitoredResourceMetadataPtrOutput {
	return o
}

func (o MonitoredResourceMetadataPtrOutput) Elem() MonitoredResourceMetadataOutput {
	return o.ApplyT(func(v *MonitoredResourceMetadata) MonitoredResourceMetadata { return *v }).(MonitoredResourceMetadataOutput)
}

// Values for predefined system metadata labels. System labels are a kind of metadata extracted by Google, including "machine_image", "vpc", "subnet_id", "security_group", "name", etc. System label values can be only strings, Boolean values, or a list of strings. For example: { "name": "my-test-instance", "security_group": ["a", "b", "c"], "spot_instance": false }
func (o MonitoredResourceMetadataPtrOutput) SystemLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *MonitoredResourceMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.SystemLabels
	}).(pulumi.StringMapOutput)
}

// A map of user-defined metadata labels.
func (o MonitoredResourceMetadataPtrOutput) UserLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *MonitoredResourceMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.UserLabels
	}).(pulumi.StringMapOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "instance_id" and "zone": { "type": "gce_instance", "labels": { "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceResponse struct {
	// Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels map[string]string `pulumi:"labels"`
	// Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types and Logging resource types.
	Type string `pulumi:"type"`
}

// MonitoredResourceResponseInput is an input type that accepts MonitoredResourceResponseArgs and MonitoredResourceResponseOutput values.
// You can construct a concrete instance of `MonitoredResourceResponseInput` via:
//
//          MonitoredResourceResponseArgs{...}
type MonitoredResourceResponseInput interface {
	pulumi.Input

	ToMonitoredResourceResponseOutput() MonitoredResourceResponseOutput
	ToMonitoredResourceResponseOutputWithContext(context.Context) MonitoredResourceResponseOutput
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "instance_id" and "zone": { "type": "gce_instance", "labels": { "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceResponseArgs struct {
	// Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types and Logging resource types.
	Type pulumi.StringInput `pulumi:"type"`
}

func (MonitoredResourceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResourceResponse)(nil)).Elem()
}

func (i MonitoredResourceResponseArgs) ToMonitoredResourceResponseOutput() MonitoredResourceResponseOutput {
	return i.ToMonitoredResourceResponseOutputWithContext(context.Background())
}

func (i MonitoredResourceResponseArgs) ToMonitoredResourceResponseOutputWithContext(ctx context.Context) MonitoredResourceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceResponseOutput)
}

func (i MonitoredResourceResponseArgs) ToMonitoredResourceResponsePtrOutput() MonitoredResourceResponsePtrOutput {
	return i.ToMonitoredResourceResponsePtrOutputWithContext(context.Background())
}

func (i MonitoredResourceResponseArgs) ToMonitoredResourceResponsePtrOutputWithContext(ctx context.Context) MonitoredResourceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceResponseOutput).ToMonitoredResourceResponsePtrOutputWithContext(ctx)
}

// MonitoredResourceResponsePtrInput is an input type that accepts MonitoredResourceResponseArgs, MonitoredResourceResponsePtr and MonitoredResourceResponsePtrOutput values.
// You can construct a concrete instance of `MonitoredResourceResponsePtrInput` via:
//
//          MonitoredResourceResponseArgs{...}
//
//  or:
//
//          nil
type MonitoredResourceResponsePtrInput interface {
	pulumi.Input

	ToMonitoredResourceResponsePtrOutput() MonitoredResourceResponsePtrOutput
	ToMonitoredResourceResponsePtrOutputWithContext(context.Context) MonitoredResourceResponsePtrOutput
}

type monitoredResourceResponsePtrType MonitoredResourceResponseArgs

func MonitoredResourceResponsePtr(v *MonitoredResourceResponseArgs) MonitoredResourceResponsePtrInput {
	return (*monitoredResourceResponsePtrType)(v)
}

func (*monitoredResourceResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoredResourceResponse)(nil)).Elem()
}

func (i *monitoredResourceResponsePtrType) ToMonitoredResourceResponsePtrOutput() MonitoredResourceResponsePtrOutput {
	return i.ToMonitoredResourceResponsePtrOutputWithContext(context.Background())
}

func (i *monitoredResourceResponsePtrType) ToMonitoredResourceResponsePtrOutputWithContext(ctx context.Context) MonitoredResourceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceResponsePtrOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "instance_id" and "zone": { "type": "gce_instance", "labels": { "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceResponseOutput struct{ *pulumi.OutputState }

func (MonitoredResourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResourceResponse)(nil)).Elem()
}

func (o MonitoredResourceResponseOutput) ToMonitoredResourceResponseOutput() MonitoredResourceResponseOutput {
	return o
}

func (o MonitoredResourceResponseOutput) ToMonitoredResourceResponseOutputWithContext(ctx context.Context) MonitoredResourceResponseOutput {
	return o
}

func (o MonitoredResourceResponseOutput) ToMonitoredResourceResponsePtrOutput() MonitoredResourceResponsePtrOutput {
	return o.ToMonitoredResourceResponsePtrOutputWithContext(context.Background())
}

func (o MonitoredResourceResponseOutput) ToMonitoredResourceResponsePtrOutputWithContext(ctx context.Context) MonitoredResourceResponsePtrOutput {
	return o.ApplyT(func(v MonitoredResourceResponse) *MonitoredResourceResponse {
		return &v
	}).(MonitoredResourceResponsePtrOutput)
}

// Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
func (o MonitoredResourceResponseOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v MonitoredResourceResponse) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types and Logging resource types.
func (o MonitoredResourceResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v MonitoredResourceResponse) string { return v.Type }).(pulumi.StringOutput)
}

type MonitoredResourceResponsePtrOutput struct{ *pulumi.OutputState }

func (MonitoredResourceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoredResourceResponse)(nil)).Elem()
}

func (o MonitoredResourceResponsePtrOutput) ToMonitoredResourceResponsePtrOutput() MonitoredResourceResponsePtrOutput {
	return o
}

func (o MonitoredResourceResponsePtrOutput) ToMonitoredResourceResponsePtrOutputWithContext(ctx context.Context) MonitoredResourceResponsePtrOutput {
	return o
}

func (o MonitoredResourceResponsePtrOutput) Elem() MonitoredResourceResponseOutput {
	return o.ApplyT(func(v *MonitoredResourceResponse) MonitoredResourceResponse { return *v }).(MonitoredResourceResponseOutput)
}

// Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
func (o MonitoredResourceResponsePtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *MonitoredResourceResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types and Logging resource types.
func (o MonitoredResourceResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MonitoredResourceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// A condition type that allows alert policies to be defined using Monitoring Query Language (https://cloud.google.com/monitoring/mql).
type MonitoringQueryLanguageCondition struct {
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration *string `pulumi:"duration"`
	// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
	Query *string `pulumi:"query"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger *Trigger `pulumi:"trigger"`
}

// MonitoringQueryLanguageConditionInput is an input type that accepts MonitoringQueryLanguageConditionArgs and MonitoringQueryLanguageConditionOutput values.
// You can construct a concrete instance of `MonitoringQueryLanguageConditionInput` via:
//
//          MonitoringQueryLanguageConditionArgs{...}
type MonitoringQueryLanguageConditionInput interface {
	pulumi.Input

	ToMonitoringQueryLanguageConditionOutput() MonitoringQueryLanguageConditionOutput
	ToMonitoringQueryLanguageConditionOutputWithContext(context.Context) MonitoringQueryLanguageConditionOutput
}

// A condition type that allows alert policies to be defined using Monitoring Query Language (https://cloud.google.com/monitoring/mql).
type MonitoringQueryLanguageConditionArgs struct {
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration pulumi.StringPtrInput `pulumi:"duration"`
	// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
	Query pulumi.StringPtrInput `pulumi:"query"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger TriggerPtrInput `pulumi:"trigger"`
}

func (MonitoringQueryLanguageConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoringQueryLanguageCondition)(nil)).Elem()
}

func (i MonitoringQueryLanguageConditionArgs) ToMonitoringQueryLanguageConditionOutput() MonitoringQueryLanguageConditionOutput {
	return i.ToMonitoringQueryLanguageConditionOutputWithContext(context.Background())
}

func (i MonitoringQueryLanguageConditionArgs) ToMonitoringQueryLanguageConditionOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoringQueryLanguageConditionOutput)
}

func (i MonitoringQueryLanguageConditionArgs) ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput {
	return i.ToMonitoringQueryLanguageConditionPtrOutputWithContext(context.Background())
}

func (i MonitoringQueryLanguageConditionArgs) ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoringQueryLanguageConditionOutput).ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx)
}

// MonitoringQueryLanguageConditionPtrInput is an input type that accepts MonitoringQueryLanguageConditionArgs, MonitoringQueryLanguageConditionPtr and MonitoringQueryLanguageConditionPtrOutput values.
// You can construct a concrete instance of `MonitoringQueryLanguageConditionPtrInput` via:
//
//          MonitoringQueryLanguageConditionArgs{...}
//
//  or:
//
//          nil
type MonitoringQueryLanguageConditionPtrInput interface {
	pulumi.Input

	ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput
	ToMonitoringQueryLanguageConditionPtrOutputWithContext(context.Context) MonitoringQueryLanguageConditionPtrOutput
}

type monitoringQueryLanguageConditionPtrType MonitoringQueryLanguageConditionArgs

func MonitoringQueryLanguageConditionPtr(v *MonitoringQueryLanguageConditionArgs) MonitoringQueryLanguageConditionPtrInput {
	return (*monitoringQueryLanguageConditionPtrType)(v)
}

func (*monitoringQueryLanguageConditionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoringQueryLanguageCondition)(nil)).Elem()
}

func (i *monitoringQueryLanguageConditionPtrType) ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput {
	return i.ToMonitoringQueryLanguageConditionPtrOutputWithContext(context.Background())
}

func (i *monitoringQueryLanguageConditionPtrType) ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoringQueryLanguageConditionPtrOutput)
}

// A condition type that allows alert policies to be defined using Monitoring Query Language (https://cloud.google.com/monitoring/mql).
type MonitoringQueryLanguageConditionOutput struct{ *pulumi.OutputState }

func (MonitoringQueryLanguageConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoringQueryLanguageCondition)(nil)).Elem()
}

func (o MonitoringQueryLanguageConditionOutput) ToMonitoringQueryLanguageConditionOutput() MonitoringQueryLanguageConditionOutput {
	return o
}

func (o MonitoringQueryLanguageConditionOutput) ToMonitoringQueryLanguageConditionOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionOutput {
	return o
}

func (o MonitoringQueryLanguageConditionOutput) ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput {
	return o.ToMonitoringQueryLanguageConditionPtrOutputWithContext(context.Background())
}

func (o MonitoringQueryLanguageConditionOutput) ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionPtrOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageCondition) *MonitoringQueryLanguageCondition {
		return &v
	}).(MonitoringQueryLanguageConditionPtrOutput)
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MonitoringQueryLanguageConditionOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageCondition) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
func (o MonitoringQueryLanguageConditionOutput) Query() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageCondition) *string { return v.Query }).(pulumi.StringPtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MonitoringQueryLanguageConditionOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageCondition) *Trigger { return v.Trigger }).(TriggerPtrOutput)
}

type MonitoringQueryLanguageConditionPtrOutput struct{ *pulumi.OutputState }

func (MonitoringQueryLanguageConditionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoringQueryLanguageCondition)(nil)).Elem()
}

func (o MonitoringQueryLanguageConditionPtrOutput) ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput {
	return o
}

func (o MonitoringQueryLanguageConditionPtrOutput) ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionPtrOutput {
	return o
}

func (o MonitoringQueryLanguageConditionPtrOutput) Elem() MonitoringQueryLanguageConditionOutput {
	return o.ApplyT(func(v *MonitoringQueryLanguageCondition) MonitoringQueryLanguageCondition { return *v }).(MonitoringQueryLanguageConditionOutput)
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MonitoringQueryLanguageConditionPtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MonitoringQueryLanguageCondition) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
func (o MonitoringQueryLanguageConditionPtrOutput) Query() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MonitoringQueryLanguageCondition) *string {
		if v == nil {
			return nil
		}
		return v.Query
	}).(pulumi.StringPtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MonitoringQueryLanguageConditionPtrOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v *MonitoringQueryLanguageCondition) *Trigger {
		if v == nil {
			return nil
		}
		return v.Trigger
	}).(TriggerPtrOutput)
}

// A condition type that allows alert policies to be defined using Monitoring Query Language (https://cloud.google.com/monitoring/mql).
type MonitoringQueryLanguageConditionResponse struct {
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration string `pulumi:"duration"`
	// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
	Query string `pulumi:"query"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger TriggerResponse `pulumi:"trigger"`
}

// MonitoringQueryLanguageConditionResponseInput is an input type that accepts MonitoringQueryLanguageConditionResponseArgs and MonitoringQueryLanguageConditionResponseOutput values.
// You can construct a concrete instance of `MonitoringQueryLanguageConditionResponseInput` via:
//
//          MonitoringQueryLanguageConditionResponseArgs{...}
type MonitoringQueryLanguageConditionResponseInput interface {
	pulumi.Input

	ToMonitoringQueryLanguageConditionResponseOutput() MonitoringQueryLanguageConditionResponseOutput
	ToMonitoringQueryLanguageConditionResponseOutputWithContext(context.Context) MonitoringQueryLanguageConditionResponseOutput
}

// A condition type that allows alert policies to be defined using Monitoring Query Language (https://cloud.google.com/monitoring/mql).
type MonitoringQueryLanguageConditionResponseArgs struct {
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration pulumi.StringInput `pulumi:"duration"`
	// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
	Query pulumi.StringInput `pulumi:"query"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger TriggerResponseInput `pulumi:"trigger"`
}

func (MonitoringQueryLanguageConditionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoringQueryLanguageConditionResponse)(nil)).Elem()
}

func (i MonitoringQueryLanguageConditionResponseArgs) ToMonitoringQueryLanguageConditionResponseOutput() MonitoringQueryLanguageConditionResponseOutput {
	return i.ToMonitoringQueryLanguageConditionResponseOutputWithContext(context.Background())
}

func (i MonitoringQueryLanguageConditionResponseArgs) ToMonitoringQueryLanguageConditionResponseOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoringQueryLanguageConditionResponseOutput)
}

// A condition type that allows alert policies to be defined using Monitoring Query Language (https://cloud.google.com/monitoring/mql).
type MonitoringQueryLanguageConditionResponseOutput struct{ *pulumi.OutputState }

func (MonitoringQueryLanguageConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoringQueryLanguageConditionResponse)(nil)).Elem()
}

func (o MonitoringQueryLanguageConditionResponseOutput) ToMonitoringQueryLanguageConditionResponseOutput() MonitoringQueryLanguageConditionResponseOutput {
	return o
}

func (o MonitoringQueryLanguageConditionResponseOutput) ToMonitoringQueryLanguageConditionResponseOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionResponseOutput {
	return o
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MonitoringQueryLanguageConditionResponseOutput) Duration() pulumi.StringOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageConditionResponse) string { return v.Duration }).(pulumi.StringOutput)
}

// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
func (o MonitoringQueryLanguageConditionResponseOutput) Query() pulumi.StringOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageConditionResponse) string { return v.Query }).(pulumi.StringOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MonitoringQueryLanguageConditionResponseOutput) Trigger() TriggerResponseOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageConditionResponse) TriggerResponse { return v.Trigger }).(TriggerResponseOutput)
}

// Describes a change made to a configuration.
type MutationRecord struct {
	// When the change occurred.
	MutateTime *string `pulumi:"mutateTime"`
	// The email address of the user making the change.
	MutatedBy *string `pulumi:"mutatedBy"`
}

// MutationRecordInput is an input type that accepts MutationRecordArgs and MutationRecordOutput values.
// You can construct a concrete instance of `MutationRecordInput` via:
//
//          MutationRecordArgs{...}
type MutationRecordInput interface {
	pulumi.Input

	ToMutationRecordOutput() MutationRecordOutput
	ToMutationRecordOutputWithContext(context.Context) MutationRecordOutput
}

// Describes a change made to a configuration.
type MutationRecordArgs struct {
	// When the change occurred.
	MutateTime pulumi.StringPtrInput `pulumi:"mutateTime"`
	// The email address of the user making the change.
	MutatedBy pulumi.StringPtrInput `pulumi:"mutatedBy"`
}

func (MutationRecordArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MutationRecord)(nil)).Elem()
}

func (i MutationRecordArgs) ToMutationRecordOutput() MutationRecordOutput {
	return i.ToMutationRecordOutputWithContext(context.Background())
}

func (i MutationRecordArgs) ToMutationRecordOutputWithContext(ctx context.Context) MutationRecordOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordOutput)
}

func (i MutationRecordArgs) ToMutationRecordPtrOutput() MutationRecordPtrOutput {
	return i.ToMutationRecordPtrOutputWithContext(context.Background())
}

func (i MutationRecordArgs) ToMutationRecordPtrOutputWithContext(ctx context.Context) MutationRecordPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordOutput).ToMutationRecordPtrOutputWithContext(ctx)
}

// MutationRecordPtrInput is an input type that accepts MutationRecordArgs, MutationRecordPtr and MutationRecordPtrOutput values.
// You can construct a concrete instance of `MutationRecordPtrInput` via:
//
//          MutationRecordArgs{...}
//
//  or:
//
//          nil
type MutationRecordPtrInput interface {
	pulumi.Input

	ToMutationRecordPtrOutput() MutationRecordPtrOutput
	ToMutationRecordPtrOutputWithContext(context.Context) MutationRecordPtrOutput
}

type mutationRecordPtrType MutationRecordArgs

func MutationRecordPtr(v *MutationRecordArgs) MutationRecordPtrInput {
	return (*mutationRecordPtrType)(v)
}

func (*mutationRecordPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MutationRecord)(nil)).Elem()
}

func (i *mutationRecordPtrType) ToMutationRecordPtrOutput() MutationRecordPtrOutput {
	return i.ToMutationRecordPtrOutputWithContext(context.Background())
}

func (i *mutationRecordPtrType) ToMutationRecordPtrOutputWithContext(ctx context.Context) MutationRecordPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordPtrOutput)
}

// MutationRecordArrayInput is an input type that accepts MutationRecordArray and MutationRecordArrayOutput values.
// You can construct a concrete instance of `MutationRecordArrayInput` via:
//
//          MutationRecordArray{ MutationRecordArgs{...} }
type MutationRecordArrayInput interface {
	pulumi.Input

	ToMutationRecordArrayOutput() MutationRecordArrayOutput
	ToMutationRecordArrayOutputWithContext(context.Context) MutationRecordArrayOutput
}

type MutationRecordArray []MutationRecordInput

func (MutationRecordArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MutationRecord)(nil)).Elem()
}

func (i MutationRecordArray) ToMutationRecordArrayOutput() MutationRecordArrayOutput {
	return i.ToMutationRecordArrayOutputWithContext(context.Background())
}

func (i MutationRecordArray) ToMutationRecordArrayOutputWithContext(ctx context.Context) MutationRecordArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordArrayOutput)
}

// Describes a change made to a configuration.
type MutationRecordOutput struct{ *pulumi.OutputState }

func (MutationRecordOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MutationRecord)(nil)).Elem()
}

func (o MutationRecordOutput) ToMutationRecordOutput() MutationRecordOutput {
	return o
}

func (o MutationRecordOutput) ToMutationRecordOutputWithContext(ctx context.Context) MutationRecordOutput {
	return o
}

func (o MutationRecordOutput) ToMutationRecordPtrOutput() MutationRecordPtrOutput {
	return o.ToMutationRecordPtrOutputWithContext(context.Background())
}

func (o MutationRecordOutput) ToMutationRecordPtrOutputWithContext(ctx context.Context) MutationRecordPtrOutput {
	return o.ApplyT(func(v MutationRecord) *MutationRecord {
		return &v
	}).(MutationRecordPtrOutput)
}

// When the change occurred.
func (o MutationRecordOutput) MutateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MutationRecord) *string { return v.MutateTime }).(pulumi.StringPtrOutput)
}

// The email address of the user making the change.
func (o MutationRecordOutput) MutatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MutationRecord) *string { return v.MutatedBy }).(pulumi.StringPtrOutput)
}

type MutationRecordPtrOutput struct{ *pulumi.OutputState }

func (MutationRecordPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MutationRecord)(nil)).Elem()
}

func (o MutationRecordPtrOutput) ToMutationRecordPtrOutput() MutationRecordPtrOutput {
	return o
}

func (o MutationRecordPtrOutput) ToMutationRecordPtrOutputWithContext(ctx context.Context) MutationRecordPtrOutput {
	return o
}

func (o MutationRecordPtrOutput) Elem() MutationRecordOutput {
	return o.ApplyT(func(v *MutationRecord) MutationRecord { return *v }).(MutationRecordOutput)
}

// When the change occurred.
func (o MutationRecordPtrOutput) MutateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MutationRecord) *string {
		if v == nil {
			return nil
		}
		return v.MutateTime
	}).(pulumi.StringPtrOutput)
}

// The email address of the user making the change.
func (o MutationRecordPtrOutput) MutatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MutationRecord) *string {
		if v == nil {
			return nil
		}
		return v.MutatedBy
	}).(pulumi.StringPtrOutput)
}

type MutationRecordArrayOutput struct{ *pulumi.OutputState }

func (MutationRecordArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MutationRecord)(nil)).Elem()
}

func (o MutationRecordArrayOutput) ToMutationRecordArrayOutput() MutationRecordArrayOutput {
	return o
}

func (o MutationRecordArrayOutput) ToMutationRecordArrayOutputWithContext(ctx context.Context) MutationRecordArrayOutput {
	return o
}

func (o MutationRecordArrayOutput) Index(i pulumi.IntInput) MutationRecordOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MutationRecord {
		return vs[0].([]MutationRecord)[vs[1].(int)]
	}).(MutationRecordOutput)
}

// Describes a change made to a configuration.
type MutationRecordResponse struct {
	// When the change occurred.
	MutateTime string `pulumi:"mutateTime"`
	// The email address of the user making the change.
	MutatedBy string `pulumi:"mutatedBy"`
}

// MutationRecordResponseInput is an input type that accepts MutationRecordResponseArgs and MutationRecordResponseOutput values.
// You can construct a concrete instance of `MutationRecordResponseInput` via:
//
//          MutationRecordResponseArgs{...}
type MutationRecordResponseInput interface {
	pulumi.Input

	ToMutationRecordResponseOutput() MutationRecordResponseOutput
	ToMutationRecordResponseOutputWithContext(context.Context) MutationRecordResponseOutput
}

// Describes a change made to a configuration.
type MutationRecordResponseArgs struct {
	// When the change occurred.
	MutateTime pulumi.StringInput `pulumi:"mutateTime"`
	// The email address of the user making the change.
	MutatedBy pulumi.StringInput `pulumi:"mutatedBy"`
}

func (MutationRecordResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MutationRecordResponse)(nil)).Elem()
}

func (i MutationRecordResponseArgs) ToMutationRecordResponseOutput() MutationRecordResponseOutput {
	return i.ToMutationRecordResponseOutputWithContext(context.Background())
}

func (i MutationRecordResponseArgs) ToMutationRecordResponseOutputWithContext(ctx context.Context) MutationRecordResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordResponseOutput)
}

func (i MutationRecordResponseArgs) ToMutationRecordResponsePtrOutput() MutationRecordResponsePtrOutput {
	return i.ToMutationRecordResponsePtrOutputWithContext(context.Background())
}

func (i MutationRecordResponseArgs) ToMutationRecordResponsePtrOutputWithContext(ctx context.Context) MutationRecordResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordResponseOutput).ToMutationRecordResponsePtrOutputWithContext(ctx)
}

// MutationRecordResponsePtrInput is an input type that accepts MutationRecordResponseArgs, MutationRecordResponsePtr and MutationRecordResponsePtrOutput values.
// You can construct a concrete instance of `MutationRecordResponsePtrInput` via:
//
//          MutationRecordResponseArgs{...}
//
//  or:
//
//          nil
type MutationRecordResponsePtrInput interface {
	pulumi.Input

	ToMutationRecordResponsePtrOutput() MutationRecordResponsePtrOutput
	ToMutationRecordResponsePtrOutputWithContext(context.Context) MutationRecordResponsePtrOutput
}

type mutationRecordResponsePtrType MutationRecordResponseArgs

func MutationRecordResponsePtr(v *MutationRecordResponseArgs) MutationRecordResponsePtrInput {
	return (*mutationRecordResponsePtrType)(v)
}

func (*mutationRecordResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MutationRecordResponse)(nil)).Elem()
}

func (i *mutationRecordResponsePtrType) ToMutationRecordResponsePtrOutput() MutationRecordResponsePtrOutput {
	return i.ToMutationRecordResponsePtrOutputWithContext(context.Background())
}

func (i *mutationRecordResponsePtrType) ToMutationRecordResponsePtrOutputWithContext(ctx context.Context) MutationRecordResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordResponsePtrOutput)
}

// MutationRecordResponseArrayInput is an input type that accepts MutationRecordResponseArray and MutationRecordResponseArrayOutput values.
// You can construct a concrete instance of `MutationRecordResponseArrayInput` via:
//
//          MutationRecordResponseArray{ MutationRecordResponseArgs{...} }
type MutationRecordResponseArrayInput interface {
	pulumi.Input

	ToMutationRecordResponseArrayOutput() MutationRecordResponseArrayOutput
	ToMutationRecordResponseArrayOutputWithContext(context.Context) MutationRecordResponseArrayOutput
}

type MutationRecordResponseArray []MutationRecordResponseInput

func (MutationRecordResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MutationRecordResponse)(nil)).Elem()
}

func (i MutationRecordResponseArray) ToMutationRecordResponseArrayOutput() MutationRecordResponseArrayOutput {
	return i.ToMutationRecordResponseArrayOutputWithContext(context.Background())
}

func (i MutationRecordResponseArray) ToMutationRecordResponseArrayOutputWithContext(ctx context.Context) MutationRecordResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordResponseArrayOutput)
}

// Describes a change made to a configuration.
type MutationRecordResponseOutput struct{ *pulumi.OutputState }

func (MutationRecordResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MutationRecordResponse)(nil)).Elem()
}

func (o MutationRecordResponseOutput) ToMutationRecordResponseOutput() MutationRecordResponseOutput {
	return o
}

func (o MutationRecordResponseOutput) ToMutationRecordResponseOutputWithContext(ctx context.Context) MutationRecordResponseOutput {
	return o
}

func (o MutationRecordResponseOutput) ToMutationRecordResponsePtrOutput() MutationRecordResponsePtrOutput {
	return o.ToMutationRecordResponsePtrOutputWithContext(context.Background())
}

func (o MutationRecordResponseOutput) ToMutationRecordResponsePtrOutputWithContext(ctx context.Context) MutationRecordResponsePtrOutput {
	return o.ApplyT(func(v MutationRecordResponse) *MutationRecordResponse {
		return &v
	}).(MutationRecordResponsePtrOutput)
}

// When the change occurred.
func (o MutationRecordResponseOutput) MutateTime() pulumi.StringOutput {
	return o.ApplyT(func(v MutationRecordResponse) string { return v.MutateTime }).(pulumi.StringOutput)
}

// The email address of the user making the change.
func (o MutationRecordResponseOutput) MutatedBy() pulumi.StringOutput {
	return o.ApplyT(func(v MutationRecordResponse) string { return v.MutatedBy }).(pulumi.StringOutput)
}

type MutationRecordResponsePtrOutput struct{ *pulumi.OutputState }

func (MutationRecordResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MutationRecordResponse)(nil)).Elem()
}

func (o MutationRecordResponsePtrOutput) ToMutationRecordResponsePtrOutput() MutationRecordResponsePtrOutput {
	return o
}

func (o MutationRecordResponsePtrOutput) ToMutationRecordResponsePtrOutputWithContext(ctx context.Context) MutationRecordResponsePtrOutput {
	return o
}

func (o MutationRecordResponsePtrOutput) Elem() MutationRecordResponseOutput {
	return o.ApplyT(func(v *MutationRecordResponse) MutationRecordResponse { return *v }).(MutationRecordResponseOutput)
}

// When the change occurred.
func (o MutationRecordResponsePtrOutput) MutateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MutationRecordResponse) *string {
		if v == nil {
			return nil
		}
		return &v.MutateTime
	}).(pulumi.StringPtrOutput)
}

// The email address of the user making the change.
func (o MutationRecordResponsePtrOutput) MutatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MutationRecordResponse) *string {
		if v == nil {
			return nil
		}
		return &v.MutatedBy
	}).(pulumi.StringPtrOutput)
}

type MutationRecordResponseArrayOutput struct{ *pulumi.OutputState }

func (MutationRecordResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MutationRecordResponse)(nil)).Elem()
}

func (o MutationRecordResponseArrayOutput) ToMutationRecordResponseArrayOutput() MutationRecordResponseArrayOutput {
	return o
}

func (o MutationRecordResponseArrayOutput) ToMutationRecordResponseArrayOutputWithContext(ctx context.Context) MutationRecordResponseArrayOutput {
	return o
}

func (o MutationRecordResponseArrayOutput) Index(i pulumi.IntInput) MutationRecordResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MutationRecordResponse {
		return vs[0].([]MutationRecordResponse)[vs[1].(int)]
	}).(MutationRecordResponseOutput)
}

// A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.
type PerformanceThreshold struct {
	// BasicSli to evaluate to judge window quality.
	BasicSliPerformance *BasicSli `pulumi:"basicSliPerformance"`
	// RequestBasedSli to evaluate to judge window quality.
	Performance *RequestBasedSli `pulumi:"performance"`
	// If window performance >= threshold, the window is counted as good.
	Threshold *float64 `pulumi:"threshold"`
}

// PerformanceThresholdInput is an input type that accepts PerformanceThresholdArgs and PerformanceThresholdOutput values.
// You can construct a concrete instance of `PerformanceThresholdInput` via:
//
//          PerformanceThresholdArgs{...}
type PerformanceThresholdInput interface {
	pulumi.Input

	ToPerformanceThresholdOutput() PerformanceThresholdOutput
	ToPerformanceThresholdOutputWithContext(context.Context) PerformanceThresholdOutput
}

// A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.
type PerformanceThresholdArgs struct {
	// BasicSli to evaluate to judge window quality.
	BasicSliPerformance BasicSliPtrInput `pulumi:"basicSliPerformance"`
	// RequestBasedSli to evaluate to judge window quality.
	Performance RequestBasedSliPtrInput `pulumi:"performance"`
	// If window performance >= threshold, the window is counted as good.
	Threshold pulumi.Float64PtrInput `pulumi:"threshold"`
}

func (PerformanceThresholdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PerformanceThreshold)(nil)).Elem()
}

func (i PerformanceThresholdArgs) ToPerformanceThresholdOutput() PerformanceThresholdOutput {
	return i.ToPerformanceThresholdOutputWithContext(context.Background())
}

func (i PerformanceThresholdArgs) ToPerformanceThresholdOutputWithContext(ctx context.Context) PerformanceThresholdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PerformanceThresholdOutput)
}

func (i PerformanceThresholdArgs) ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput {
	return i.ToPerformanceThresholdPtrOutputWithContext(context.Background())
}

func (i PerformanceThresholdArgs) ToPerformanceThresholdPtrOutputWithContext(ctx context.Context) PerformanceThresholdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PerformanceThresholdOutput).ToPerformanceThresholdPtrOutputWithContext(ctx)
}

// PerformanceThresholdPtrInput is an input type that accepts PerformanceThresholdArgs, PerformanceThresholdPtr and PerformanceThresholdPtrOutput values.
// You can construct a concrete instance of `PerformanceThresholdPtrInput` via:
//
//          PerformanceThresholdArgs{...}
//
//  or:
//
//          nil
type PerformanceThresholdPtrInput interface {
	pulumi.Input

	ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput
	ToPerformanceThresholdPtrOutputWithContext(context.Context) PerformanceThresholdPtrOutput
}

type performanceThresholdPtrType PerformanceThresholdArgs

func PerformanceThresholdPtr(v *PerformanceThresholdArgs) PerformanceThresholdPtrInput {
	return (*performanceThresholdPtrType)(v)
}

func (*performanceThresholdPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PerformanceThreshold)(nil)).Elem()
}

func (i *performanceThresholdPtrType) ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput {
	return i.ToPerformanceThresholdPtrOutputWithContext(context.Background())
}

func (i *performanceThresholdPtrType) ToPerformanceThresholdPtrOutputWithContext(ctx context.Context) PerformanceThresholdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PerformanceThresholdPtrOutput)
}

// A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.
type PerformanceThresholdOutput struct{ *pulumi.OutputState }

func (PerformanceThresholdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PerformanceThreshold)(nil)).Elem()
}

func (o PerformanceThresholdOutput) ToPerformanceThresholdOutput() PerformanceThresholdOutput {
	return o
}

func (o PerformanceThresholdOutput) ToPerformanceThresholdOutputWithContext(ctx context.Context) PerformanceThresholdOutput {
	return o
}

func (o PerformanceThresholdOutput) ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput {
	return o.ToPerformanceThresholdPtrOutputWithContext(context.Background())
}

func (o PerformanceThresholdOutput) ToPerformanceThresholdPtrOutputWithContext(ctx context.Context) PerformanceThresholdPtrOutput {
	return o.ApplyT(func(v PerformanceThreshold) *PerformanceThreshold {
		return &v
	}).(PerformanceThresholdPtrOutput)
}

// BasicSli to evaluate to judge window quality.
func (o PerformanceThresholdOutput) BasicSliPerformance() BasicSliPtrOutput {
	return o.ApplyT(func(v PerformanceThreshold) *BasicSli { return v.BasicSliPerformance }).(BasicSliPtrOutput)
}

// RequestBasedSli to evaluate to judge window quality.
func (o PerformanceThresholdOutput) Performance() RequestBasedSliPtrOutput {
	return o.ApplyT(func(v PerformanceThreshold) *RequestBasedSli { return v.Performance }).(RequestBasedSliPtrOutput)
}

// If window performance >= threshold, the window is counted as good.
func (o PerformanceThresholdOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PerformanceThreshold) *float64 { return v.Threshold }).(pulumi.Float64PtrOutput)
}

type PerformanceThresholdPtrOutput struct{ *pulumi.OutputState }

func (PerformanceThresholdPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PerformanceThreshold)(nil)).Elem()
}

func (o PerformanceThresholdPtrOutput) ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput {
	return o
}

func (o PerformanceThresholdPtrOutput) ToPerformanceThresholdPtrOutputWithContext(ctx context.Context) PerformanceThresholdPtrOutput {
	return o
}

func (o PerformanceThresholdPtrOutput) Elem() PerformanceThresholdOutput {
	return o.ApplyT(func(v *PerformanceThreshold) PerformanceThreshold { return *v }).(PerformanceThresholdOutput)
}

// BasicSli to evaluate to judge window quality.
func (o PerformanceThresholdPtrOutput) BasicSliPerformance() BasicSliPtrOutput {
	return o.ApplyT(func(v *PerformanceThreshold) *BasicSli {
		if v == nil {
			return nil
		}
		return v.BasicSliPerformance
	}).(BasicSliPtrOutput)
}

// RequestBasedSli to evaluate to judge window quality.
func (o PerformanceThresholdPtrOutput) Performance() RequestBasedSliPtrOutput {
	return o.ApplyT(func(v *PerformanceThreshold) *RequestBasedSli {
		if v == nil {
			return nil
		}
		return v.Performance
	}).(RequestBasedSliPtrOutput)
}

// If window performance >= threshold, the window is counted as good.
func (o PerformanceThresholdPtrOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PerformanceThreshold) *float64 {
		if v == nil {
			return nil
		}
		return v.Threshold
	}).(pulumi.Float64PtrOutput)
}

// A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.
type PerformanceThresholdResponse struct {
	// BasicSli to evaluate to judge window quality.
	BasicSliPerformance BasicSliResponse `pulumi:"basicSliPerformance"`
	// RequestBasedSli to evaluate to judge window quality.
	Performance RequestBasedSliResponse `pulumi:"performance"`
	// If window performance >= threshold, the window is counted as good.
	Threshold float64 `pulumi:"threshold"`
}

// PerformanceThresholdResponseInput is an input type that accepts PerformanceThresholdResponseArgs and PerformanceThresholdResponseOutput values.
// You can construct a concrete instance of `PerformanceThresholdResponseInput` via:
//
//          PerformanceThresholdResponseArgs{...}
type PerformanceThresholdResponseInput interface {
	pulumi.Input

	ToPerformanceThresholdResponseOutput() PerformanceThresholdResponseOutput
	ToPerformanceThresholdResponseOutputWithContext(context.Context) PerformanceThresholdResponseOutput
}

// A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.
type PerformanceThresholdResponseArgs struct {
	// BasicSli to evaluate to judge window quality.
	BasicSliPerformance BasicSliResponseInput `pulumi:"basicSliPerformance"`
	// RequestBasedSli to evaluate to judge window quality.
	Performance RequestBasedSliResponseInput `pulumi:"performance"`
	// If window performance >= threshold, the window is counted as good.
	Threshold pulumi.Float64Input `pulumi:"threshold"`
}

func (PerformanceThresholdResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PerformanceThresholdResponse)(nil)).Elem()
}

func (i PerformanceThresholdResponseArgs) ToPerformanceThresholdResponseOutput() PerformanceThresholdResponseOutput {
	return i.ToPerformanceThresholdResponseOutputWithContext(context.Background())
}

func (i PerformanceThresholdResponseArgs) ToPerformanceThresholdResponseOutputWithContext(ctx context.Context) PerformanceThresholdResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PerformanceThresholdResponseOutput)
}

func (i PerformanceThresholdResponseArgs) ToPerformanceThresholdResponsePtrOutput() PerformanceThresholdResponsePtrOutput {
	return i.ToPerformanceThresholdResponsePtrOutputWithContext(context.Background())
}

func (i PerformanceThresholdResponseArgs) ToPerformanceThresholdResponsePtrOutputWithContext(ctx context.Context) PerformanceThresholdResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PerformanceThresholdResponseOutput).ToPerformanceThresholdResponsePtrOutputWithContext(ctx)
}

// PerformanceThresholdResponsePtrInput is an input type that accepts PerformanceThresholdResponseArgs, PerformanceThresholdResponsePtr and PerformanceThresholdResponsePtrOutput values.
// You can construct a concrete instance of `PerformanceThresholdResponsePtrInput` via:
//
//          PerformanceThresholdResponseArgs{...}
//
//  or:
//
//          nil
type PerformanceThresholdResponsePtrInput interface {
	pulumi.Input

	ToPerformanceThresholdResponsePtrOutput() PerformanceThresholdResponsePtrOutput
	ToPerformanceThresholdResponsePtrOutputWithContext(context.Context) PerformanceThresholdResponsePtrOutput
}

type performanceThresholdResponsePtrType PerformanceThresholdResponseArgs

func PerformanceThresholdResponsePtr(v *PerformanceThresholdResponseArgs) PerformanceThresholdResponsePtrInput {
	return (*performanceThresholdResponsePtrType)(v)
}

func (*performanceThresholdResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PerformanceThresholdResponse)(nil)).Elem()
}

func (i *performanceThresholdResponsePtrType) ToPerformanceThresholdResponsePtrOutput() PerformanceThresholdResponsePtrOutput {
	return i.ToPerformanceThresholdResponsePtrOutputWithContext(context.Background())
}

func (i *performanceThresholdResponsePtrType) ToPerformanceThresholdResponsePtrOutputWithContext(ctx context.Context) PerformanceThresholdResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PerformanceThresholdResponsePtrOutput)
}

// A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.
type PerformanceThresholdResponseOutput struct{ *pulumi.OutputState }

func (PerformanceThresholdResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PerformanceThresholdResponse)(nil)).Elem()
}

func (o PerformanceThresholdResponseOutput) ToPerformanceThresholdResponseOutput() PerformanceThresholdResponseOutput {
	return o
}

func (o PerformanceThresholdResponseOutput) ToPerformanceThresholdResponseOutputWithContext(ctx context.Context) PerformanceThresholdResponseOutput {
	return o
}

func (o PerformanceThresholdResponseOutput) ToPerformanceThresholdResponsePtrOutput() PerformanceThresholdResponsePtrOutput {
	return o.ToPerformanceThresholdResponsePtrOutputWithContext(context.Background())
}

func (o PerformanceThresholdResponseOutput) ToPerformanceThresholdResponsePtrOutputWithContext(ctx context.Context) PerformanceThresholdResponsePtrOutput {
	return o.ApplyT(func(v PerformanceThresholdResponse) *PerformanceThresholdResponse {
		return &v
	}).(PerformanceThresholdResponsePtrOutput)
}

// BasicSli to evaluate to judge window quality.
func (o PerformanceThresholdResponseOutput) BasicSliPerformance() BasicSliResponseOutput {
	return o.ApplyT(func(v PerformanceThresholdResponse) BasicSliResponse { return v.BasicSliPerformance }).(BasicSliResponseOutput)
}

// RequestBasedSli to evaluate to judge window quality.
func (o PerformanceThresholdResponseOutput) Performance() RequestBasedSliResponseOutput {
	return o.ApplyT(func(v PerformanceThresholdResponse) RequestBasedSliResponse { return v.Performance }).(RequestBasedSliResponseOutput)
}

// If window performance >= threshold, the window is counted as good.
func (o PerformanceThresholdResponseOutput) Threshold() pulumi.Float64Output {
	return o.ApplyT(func(v PerformanceThresholdResponse) float64 { return v.Threshold }).(pulumi.Float64Output)
}

type PerformanceThresholdResponsePtrOutput struct{ *pulumi.OutputState }

func (PerformanceThresholdResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PerformanceThresholdResponse)(nil)).Elem()
}

func (o PerformanceThresholdResponsePtrOutput) ToPerformanceThresholdResponsePtrOutput() PerformanceThresholdResponsePtrOutput {
	return o
}

func (o PerformanceThresholdResponsePtrOutput) ToPerformanceThresholdResponsePtrOutputWithContext(ctx context.Context) PerformanceThresholdResponsePtrOutput {
	return o
}

func (o PerformanceThresholdResponsePtrOutput) Elem() PerformanceThresholdResponseOutput {
	return o.ApplyT(func(v *PerformanceThresholdResponse) PerformanceThresholdResponse { return *v }).(PerformanceThresholdResponseOutput)
}

// BasicSli to evaluate to judge window quality.
func (o PerformanceThresholdResponsePtrOutput) BasicSliPerformance() BasicSliResponsePtrOutput {
	return o.ApplyT(func(v *PerformanceThresholdResponse) *BasicSliResponse {
		if v == nil {
			return nil
		}
		return &v.BasicSliPerformance
	}).(BasicSliResponsePtrOutput)
}

// RequestBasedSli to evaluate to judge window quality.
func (o PerformanceThresholdResponsePtrOutput) Performance() RequestBasedSliResponsePtrOutput {
	return o.ApplyT(func(v *PerformanceThresholdResponse) *RequestBasedSliResponse {
		if v == nil {
			return nil
		}
		return &v.Performance
	}).(RequestBasedSliResponsePtrOutput)
}

// If window performance >= threshold, the window is counted as good.
func (o PerformanceThresholdResponsePtrOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PerformanceThresholdResponse) *float64 {
		if v == nil {
			return nil
		}
		return &v.Threshold
	}).(pulumi.Float64PtrOutput)
}

// A single data point in a time series.
type Point struct {
	// The time interval to which the data point applies. For GAUGE metrics, the start time is optional, but if it is supplied, it must equal the end time. For DELTA metrics, the start and end time should specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For CUMULATIVE metrics, the start and end time should specify a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points.
	Interval *TimeInterval `pulumi:"interval"`
	// The value of the data point.
	Value *TypedValue `pulumi:"value"`
}

// PointInput is an input type that accepts PointArgs and PointOutput values.
// You can construct a concrete instance of `PointInput` via:
//
//          PointArgs{...}
type PointInput interface {
	pulumi.Input

	ToPointOutput() PointOutput
	ToPointOutputWithContext(context.Context) PointOutput
}

// A single data point in a time series.
type PointArgs struct {
	// The time interval to which the data point applies. For GAUGE metrics, the start time is optional, but if it is supplied, it must equal the end time. For DELTA metrics, the start and end time should specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For CUMULATIVE metrics, the start and end time should specify a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points.
	Interval TimeIntervalPtrInput `pulumi:"interval"`
	// The value of the data point.
	Value TypedValuePtrInput `pulumi:"value"`
}

func (PointArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Point)(nil)).Elem()
}

func (i PointArgs) ToPointOutput() PointOutput {
	return i.ToPointOutputWithContext(context.Background())
}

func (i PointArgs) ToPointOutputWithContext(ctx context.Context) PointOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PointOutput)
}

// PointArrayInput is an input type that accepts PointArray and PointArrayOutput values.
// You can construct a concrete instance of `PointArrayInput` via:
//
//          PointArray{ PointArgs{...} }
type PointArrayInput interface {
	pulumi.Input

	ToPointArrayOutput() PointArrayOutput
	ToPointArrayOutputWithContext(context.Context) PointArrayOutput
}

type PointArray []PointInput

func (PointArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Point)(nil)).Elem()
}

func (i PointArray) ToPointArrayOutput() PointArrayOutput {
	return i.ToPointArrayOutputWithContext(context.Background())
}

func (i PointArray) ToPointArrayOutputWithContext(ctx context.Context) PointArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PointArrayOutput)
}

// A single data point in a time series.
type PointOutput struct{ *pulumi.OutputState }

func (PointOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Point)(nil)).Elem()
}

func (o PointOutput) ToPointOutput() PointOutput {
	return o
}

func (o PointOutput) ToPointOutputWithContext(ctx context.Context) PointOutput {
	return o
}

// The time interval to which the data point applies. For GAUGE metrics, the start time is optional, but if it is supplied, it must equal the end time. For DELTA metrics, the start and end time should specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For CUMULATIVE metrics, the start and end time should specify a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points.
func (o PointOutput) Interval() TimeIntervalPtrOutput {
	return o.ApplyT(func(v Point) *TimeInterval { return v.Interval }).(TimeIntervalPtrOutput)
}

// The value of the data point.
func (o PointOutput) Value() TypedValuePtrOutput {
	return o.ApplyT(func(v Point) *TypedValue { return v.Value }).(TypedValuePtrOutput)
}

type PointArrayOutput struct{ *pulumi.OutputState }

func (PointArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Point)(nil)).Elem()
}

func (o PointArrayOutput) ToPointArrayOutput() PointArrayOutput {
	return o
}

func (o PointArrayOutput) ToPointArrayOutputWithContext(ctx context.Context) PointArrayOutput {
	return o
}

func (o PointArrayOutput) Index(i pulumi.IntInput) PointOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Point {
		return vs[0].([]Point)[vs[1].(int)]
	}).(PointOutput)
}

// The range of the population values.
type Range struct {
	// The maximum of the population values.
	Max *float64 `pulumi:"max"`
	// The minimum of the population values.
	Min *float64 `pulumi:"min"`
}

// RangeInput is an input type that accepts RangeArgs and RangeOutput values.
// You can construct a concrete instance of `RangeInput` via:
//
//          RangeArgs{...}
type RangeInput interface {
	pulumi.Input

	ToRangeOutput() RangeOutput
	ToRangeOutputWithContext(context.Context) RangeOutput
}

// The range of the population values.
type RangeArgs struct {
	// The maximum of the population values.
	Max pulumi.Float64PtrInput `pulumi:"max"`
	// The minimum of the population values.
	Min pulumi.Float64PtrInput `pulumi:"min"`
}

func (RangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Range)(nil)).Elem()
}

func (i RangeArgs) ToRangeOutput() RangeOutput {
	return i.ToRangeOutputWithContext(context.Background())
}

func (i RangeArgs) ToRangeOutputWithContext(ctx context.Context) RangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RangeOutput)
}

func (i RangeArgs) ToRangePtrOutput() RangePtrOutput {
	return i.ToRangePtrOutputWithContext(context.Background())
}

func (i RangeArgs) ToRangePtrOutputWithContext(ctx context.Context) RangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RangeOutput).ToRangePtrOutputWithContext(ctx)
}

// RangePtrInput is an input type that accepts RangeArgs, RangePtr and RangePtrOutput values.
// You can construct a concrete instance of `RangePtrInput` via:
//
//          RangeArgs{...}
//
//  or:
//
//          nil
type RangePtrInput interface {
	pulumi.Input

	ToRangePtrOutput() RangePtrOutput
	ToRangePtrOutputWithContext(context.Context) RangePtrOutput
}

type rangePtrType RangeArgs

func RangePtr(v *RangeArgs) RangePtrInput {
	return (*rangePtrType)(v)
}

func (*rangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Range)(nil)).Elem()
}

func (i *rangePtrType) ToRangePtrOutput() RangePtrOutput {
	return i.ToRangePtrOutputWithContext(context.Background())
}

func (i *rangePtrType) ToRangePtrOutputWithContext(ctx context.Context) RangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RangePtrOutput)
}

// The range of the population values.
type RangeOutput struct{ *pulumi.OutputState }

func (RangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Range)(nil)).Elem()
}

func (o RangeOutput) ToRangeOutput() RangeOutput {
	return o
}

func (o RangeOutput) ToRangeOutputWithContext(ctx context.Context) RangeOutput {
	return o
}

func (o RangeOutput) ToRangePtrOutput() RangePtrOutput {
	return o.ToRangePtrOutputWithContext(context.Background())
}

func (o RangeOutput) ToRangePtrOutputWithContext(ctx context.Context) RangePtrOutput {
	return o.ApplyT(func(v Range) *Range {
		return &v
	}).(RangePtrOutput)
}

// The maximum of the population values.
func (o RangeOutput) Max() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Range) *float64 { return v.Max }).(pulumi.Float64PtrOutput)
}

// The minimum of the population values.
func (o RangeOutput) Min() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Range) *float64 { return v.Min }).(pulumi.Float64PtrOutput)
}

type RangePtrOutput struct{ *pulumi.OutputState }

func (RangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Range)(nil)).Elem()
}

func (o RangePtrOutput) ToRangePtrOutput() RangePtrOutput {
	return o
}

func (o RangePtrOutput) ToRangePtrOutputWithContext(ctx context.Context) RangePtrOutput {
	return o
}

func (o RangePtrOutput) Elem() RangeOutput {
	return o.ApplyT(func(v *Range) Range { return *v }).(RangeOutput)
}

// The maximum of the population values.
func (o RangePtrOutput) Max() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Range) *float64 {
		if v == nil {
			return nil
		}
		return v.Max
	}).(pulumi.Float64PtrOutput)
}

// The minimum of the population values.
func (o RangePtrOutput) Min() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Range) *float64 {
		if v == nil {
			return nil
		}
		return v.Min
	}).(pulumi.Float64PtrOutput)
}

// Service Level Indicators for which atomic units of service are counted directly.
type RequestBasedSli struct {
	// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
	DistributionCut *DistributionCut `pulumi:"distributionCut"`
	// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
	GoodTotalRatio *TimeSeriesRatio `pulumi:"goodTotalRatio"`
}

// RequestBasedSliInput is an input type that accepts RequestBasedSliArgs and RequestBasedSliOutput values.
// You can construct a concrete instance of `RequestBasedSliInput` via:
//
//          RequestBasedSliArgs{...}
type RequestBasedSliInput interface {
	pulumi.Input

	ToRequestBasedSliOutput() RequestBasedSliOutput
	ToRequestBasedSliOutputWithContext(context.Context) RequestBasedSliOutput
}

// Service Level Indicators for which atomic units of service are counted directly.
type RequestBasedSliArgs struct {
	// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
	DistributionCut DistributionCutPtrInput `pulumi:"distributionCut"`
	// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
	GoodTotalRatio TimeSeriesRatioPtrInput `pulumi:"goodTotalRatio"`
}

func (RequestBasedSliArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RequestBasedSli)(nil)).Elem()
}

func (i RequestBasedSliArgs) ToRequestBasedSliOutput() RequestBasedSliOutput {
	return i.ToRequestBasedSliOutputWithContext(context.Background())
}

func (i RequestBasedSliArgs) ToRequestBasedSliOutputWithContext(ctx context.Context) RequestBasedSliOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequestBasedSliOutput)
}

func (i RequestBasedSliArgs) ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput {
	return i.ToRequestBasedSliPtrOutputWithContext(context.Background())
}

func (i RequestBasedSliArgs) ToRequestBasedSliPtrOutputWithContext(ctx context.Context) RequestBasedSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequestBasedSliOutput).ToRequestBasedSliPtrOutputWithContext(ctx)
}

// RequestBasedSliPtrInput is an input type that accepts RequestBasedSliArgs, RequestBasedSliPtr and RequestBasedSliPtrOutput values.
// You can construct a concrete instance of `RequestBasedSliPtrInput` via:
//
//          RequestBasedSliArgs{...}
//
//  or:
//
//          nil
type RequestBasedSliPtrInput interface {
	pulumi.Input

	ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput
	ToRequestBasedSliPtrOutputWithContext(context.Context) RequestBasedSliPtrOutput
}

type requestBasedSliPtrType RequestBasedSliArgs

func RequestBasedSliPtr(v *RequestBasedSliArgs) RequestBasedSliPtrInput {
	return (*requestBasedSliPtrType)(v)
}

func (*requestBasedSliPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RequestBasedSli)(nil)).Elem()
}

func (i *requestBasedSliPtrType) ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput {
	return i.ToRequestBasedSliPtrOutputWithContext(context.Background())
}

func (i *requestBasedSliPtrType) ToRequestBasedSliPtrOutputWithContext(ctx context.Context) RequestBasedSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequestBasedSliPtrOutput)
}

// Service Level Indicators for which atomic units of service are counted directly.
type RequestBasedSliOutput struct{ *pulumi.OutputState }

func (RequestBasedSliOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RequestBasedSli)(nil)).Elem()
}

func (o RequestBasedSliOutput) ToRequestBasedSliOutput() RequestBasedSliOutput {
	return o
}

func (o RequestBasedSliOutput) ToRequestBasedSliOutputWithContext(ctx context.Context) RequestBasedSliOutput {
	return o
}

func (o RequestBasedSliOutput) ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput {
	return o.ToRequestBasedSliPtrOutputWithContext(context.Background())
}

func (o RequestBasedSliOutput) ToRequestBasedSliPtrOutputWithContext(ctx context.Context) RequestBasedSliPtrOutput {
	return o.ApplyT(func(v RequestBasedSli) *RequestBasedSli {
		return &v
	}).(RequestBasedSliPtrOutput)
}

// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
func (o RequestBasedSliOutput) DistributionCut() DistributionCutPtrOutput {
	return o.ApplyT(func(v RequestBasedSli) *DistributionCut { return v.DistributionCut }).(DistributionCutPtrOutput)
}

// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
func (o RequestBasedSliOutput) GoodTotalRatio() TimeSeriesRatioPtrOutput {
	return o.ApplyT(func(v RequestBasedSli) *TimeSeriesRatio { return v.GoodTotalRatio }).(TimeSeriesRatioPtrOutput)
}

type RequestBasedSliPtrOutput struct{ *pulumi.OutputState }

func (RequestBasedSliPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RequestBasedSli)(nil)).Elem()
}

func (o RequestBasedSliPtrOutput) ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput {
	return o
}

func (o RequestBasedSliPtrOutput) ToRequestBasedSliPtrOutputWithContext(ctx context.Context) RequestBasedSliPtrOutput {
	return o
}

func (o RequestBasedSliPtrOutput) Elem() RequestBasedSliOutput {
	return o.ApplyT(func(v *RequestBasedSli) RequestBasedSli { return *v }).(RequestBasedSliOutput)
}

// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
func (o RequestBasedSliPtrOutput) DistributionCut() DistributionCutPtrOutput {
	return o.ApplyT(func(v *RequestBasedSli) *DistributionCut {
		if v == nil {
			return nil
		}
		return v.DistributionCut
	}).(DistributionCutPtrOutput)
}

// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
func (o RequestBasedSliPtrOutput) GoodTotalRatio() TimeSeriesRatioPtrOutput {
	return o.ApplyT(func(v *RequestBasedSli) *TimeSeriesRatio {
		if v == nil {
			return nil
		}
		return v.GoodTotalRatio
	}).(TimeSeriesRatioPtrOutput)
}

// Service Level Indicators for which atomic units of service are counted directly.
type RequestBasedSliResponse struct {
	// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
	DistributionCut DistributionCutResponse `pulumi:"distributionCut"`
	// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
	GoodTotalRatio TimeSeriesRatioResponse `pulumi:"goodTotalRatio"`
}

// RequestBasedSliResponseInput is an input type that accepts RequestBasedSliResponseArgs and RequestBasedSliResponseOutput values.
// You can construct a concrete instance of `RequestBasedSliResponseInput` via:
//
//          RequestBasedSliResponseArgs{...}
type RequestBasedSliResponseInput interface {
	pulumi.Input

	ToRequestBasedSliResponseOutput() RequestBasedSliResponseOutput
	ToRequestBasedSliResponseOutputWithContext(context.Context) RequestBasedSliResponseOutput
}

// Service Level Indicators for which atomic units of service are counted directly.
type RequestBasedSliResponseArgs struct {
	// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
	DistributionCut DistributionCutResponseInput `pulumi:"distributionCut"`
	// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
	GoodTotalRatio TimeSeriesRatioResponseInput `pulumi:"goodTotalRatio"`
}

func (RequestBasedSliResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RequestBasedSliResponse)(nil)).Elem()
}

func (i RequestBasedSliResponseArgs) ToRequestBasedSliResponseOutput() RequestBasedSliResponseOutput {
	return i.ToRequestBasedSliResponseOutputWithContext(context.Background())
}

func (i RequestBasedSliResponseArgs) ToRequestBasedSliResponseOutputWithContext(ctx context.Context) RequestBasedSliResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequestBasedSliResponseOutput)
}

func (i RequestBasedSliResponseArgs) ToRequestBasedSliResponsePtrOutput() RequestBasedSliResponsePtrOutput {
	return i.ToRequestBasedSliResponsePtrOutputWithContext(context.Background())
}

func (i RequestBasedSliResponseArgs) ToRequestBasedSliResponsePtrOutputWithContext(ctx context.Context) RequestBasedSliResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequestBasedSliResponseOutput).ToRequestBasedSliResponsePtrOutputWithContext(ctx)
}

// RequestBasedSliResponsePtrInput is an input type that accepts RequestBasedSliResponseArgs, RequestBasedSliResponsePtr and RequestBasedSliResponsePtrOutput values.
// You can construct a concrete instance of `RequestBasedSliResponsePtrInput` via:
//
//          RequestBasedSliResponseArgs{...}
//
//  or:
//
//          nil
type RequestBasedSliResponsePtrInput interface {
	pulumi.Input

	ToRequestBasedSliResponsePtrOutput() RequestBasedSliResponsePtrOutput
	ToRequestBasedSliResponsePtrOutputWithContext(context.Context) RequestBasedSliResponsePtrOutput
}

type requestBasedSliResponsePtrType RequestBasedSliResponseArgs

func RequestBasedSliResponsePtr(v *RequestBasedSliResponseArgs) RequestBasedSliResponsePtrInput {
	return (*requestBasedSliResponsePtrType)(v)
}

func (*requestBasedSliResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RequestBasedSliResponse)(nil)).Elem()
}

func (i *requestBasedSliResponsePtrType) ToRequestBasedSliResponsePtrOutput() RequestBasedSliResponsePtrOutput {
	return i.ToRequestBasedSliResponsePtrOutputWithContext(context.Background())
}

func (i *requestBasedSliResponsePtrType) ToRequestBasedSliResponsePtrOutputWithContext(ctx context.Context) RequestBasedSliResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequestBasedSliResponsePtrOutput)
}

// Service Level Indicators for which atomic units of service are counted directly.
type RequestBasedSliResponseOutput struct{ *pulumi.OutputState }

func (RequestBasedSliResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RequestBasedSliResponse)(nil)).Elem()
}

func (o RequestBasedSliResponseOutput) ToRequestBasedSliResponseOutput() RequestBasedSliResponseOutput {
	return o
}

func (o RequestBasedSliResponseOutput) ToRequestBasedSliResponseOutputWithContext(ctx context.Context) RequestBasedSliResponseOutput {
	return o
}

func (o RequestBasedSliResponseOutput) ToRequestBasedSliResponsePtrOutput() RequestBasedSliResponsePtrOutput {
	return o.ToRequestBasedSliResponsePtrOutputWithContext(context.Background())
}

func (o RequestBasedSliResponseOutput) ToRequestBasedSliResponsePtrOutputWithContext(ctx context.Context) RequestBasedSliResponsePtrOutput {
	return o.ApplyT(func(v RequestBasedSliResponse) *RequestBasedSliResponse {
		return &v
	}).(RequestBasedSliResponsePtrOutput)
}

// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
func (o RequestBasedSliResponseOutput) DistributionCut() DistributionCutResponseOutput {
	return o.ApplyT(func(v RequestBasedSliResponse) DistributionCutResponse { return v.DistributionCut }).(DistributionCutResponseOutput)
}

// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
func (o RequestBasedSliResponseOutput) GoodTotalRatio() TimeSeriesRatioResponseOutput {
	return o.ApplyT(func(v RequestBasedSliResponse) TimeSeriesRatioResponse { return v.GoodTotalRatio }).(TimeSeriesRatioResponseOutput)
}

type RequestBasedSliResponsePtrOutput struct{ *pulumi.OutputState }

func (RequestBasedSliResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RequestBasedSliResponse)(nil)).Elem()
}

func (o RequestBasedSliResponsePtrOutput) ToRequestBasedSliResponsePtrOutput() RequestBasedSliResponsePtrOutput {
	return o
}

func (o RequestBasedSliResponsePtrOutput) ToRequestBasedSliResponsePtrOutputWithContext(ctx context.Context) RequestBasedSliResponsePtrOutput {
	return o
}

func (o RequestBasedSliResponsePtrOutput) Elem() RequestBasedSliResponseOutput {
	return o.ApplyT(func(v *RequestBasedSliResponse) RequestBasedSliResponse { return *v }).(RequestBasedSliResponseOutput)
}

// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
func (o RequestBasedSliResponsePtrOutput) DistributionCut() DistributionCutResponsePtrOutput {
	return o.ApplyT(func(v *RequestBasedSliResponse) *DistributionCutResponse {
		if v == nil {
			return nil
		}
		return &v.DistributionCut
	}).(DistributionCutResponsePtrOutput)
}

// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
func (o RequestBasedSliResponsePtrOutput) GoodTotalRatio() TimeSeriesRatioResponsePtrOutput {
	return o.ApplyT(func(v *RequestBasedSliResponse) *TimeSeriesRatioResponse {
		if v == nil {
			return nil
		}
		return &v.GoodTotalRatio
	}).(TimeSeriesRatioResponsePtrOutput)
}

// The resource submessage for group checks. It can be used instead of a monitored resource, when multiple resources are being monitored.
type ResourceGroup struct {
	// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
	GroupId *string `pulumi:"groupId"`
	// The resource type of the group members.
	ResourceType *string `pulumi:"resourceType"`
}

// ResourceGroupInput is an input type that accepts ResourceGroupArgs and ResourceGroupOutput values.
// You can construct a concrete instance of `ResourceGroupInput` via:
//
//          ResourceGroupArgs{...}
type ResourceGroupInput interface {
	pulumi.Input

	ToResourceGroupOutput() ResourceGroupOutput
	ToResourceGroupOutputWithContext(context.Context) ResourceGroupOutput
}

// The resource submessage for group checks. It can be used instead of a monitored resource, when multiple resources are being monitored.
type ResourceGroupArgs struct {
	// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
	GroupId pulumi.StringPtrInput `pulumi:"groupId"`
	// The resource type of the group members.
	ResourceType pulumi.StringPtrInput `pulumi:"resourceType"`
}

func (ResourceGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceGroup)(nil)).Elem()
}

func (i ResourceGroupArgs) ToResourceGroupOutput() ResourceGroupOutput {
	return i.ToResourceGroupOutputWithContext(context.Background())
}

func (i ResourceGroupArgs) ToResourceGroupOutputWithContext(ctx context.Context) ResourceGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceGroupOutput)
}

func (i ResourceGroupArgs) ToResourceGroupPtrOutput() ResourceGroupPtrOutput {
	return i.ToResourceGroupPtrOutputWithContext(context.Background())
}

func (i ResourceGroupArgs) ToResourceGroupPtrOutputWithContext(ctx context.Context) ResourceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceGroupOutput).ToResourceGroupPtrOutputWithContext(ctx)
}

// ResourceGroupPtrInput is an input type that accepts ResourceGroupArgs, ResourceGroupPtr and ResourceGroupPtrOutput values.
// You can construct a concrete instance of `ResourceGroupPtrInput` via:
//
//          ResourceGroupArgs{...}
//
//  or:
//
//          nil
type ResourceGroupPtrInput interface {
	pulumi.Input

	ToResourceGroupPtrOutput() ResourceGroupPtrOutput
	ToResourceGroupPtrOutputWithContext(context.Context) ResourceGroupPtrOutput
}

type resourceGroupPtrType ResourceGroupArgs

func ResourceGroupPtr(v *ResourceGroupArgs) ResourceGroupPtrInput {
	return (*resourceGroupPtrType)(v)
}

func (*resourceGroupPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceGroup)(nil)).Elem()
}

func (i *resourceGroupPtrType) ToResourceGroupPtrOutput() ResourceGroupPtrOutput {
	return i.ToResourceGroupPtrOutputWithContext(context.Background())
}

func (i *resourceGroupPtrType) ToResourceGroupPtrOutputWithContext(ctx context.Context) ResourceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceGroupPtrOutput)
}

// The resource submessage for group checks. It can be used instead of a monitored resource, when multiple resources are being monitored.
type ResourceGroupOutput struct{ *pulumi.OutputState }

func (ResourceGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceGroup)(nil)).Elem()
}

func (o ResourceGroupOutput) ToResourceGroupOutput() ResourceGroupOutput {
	return o
}

func (o ResourceGroupOutput) ToResourceGroupOutputWithContext(ctx context.Context) ResourceGroupOutput {
	return o
}

func (o ResourceGroupOutput) ToResourceGroupPtrOutput() ResourceGroupPtrOutput {
	return o.ToResourceGroupPtrOutputWithContext(context.Background())
}

func (o ResourceGroupOutput) ToResourceGroupPtrOutputWithContext(ctx context.Context) ResourceGroupPtrOutput {
	return o.ApplyT(func(v ResourceGroup) *ResourceGroup {
		return &v
	}).(ResourceGroupPtrOutput)
}

// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
func (o ResourceGroupOutput) GroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceGroup) *string { return v.GroupId }).(pulumi.StringPtrOutput)
}

// The resource type of the group members.
func (o ResourceGroupOutput) ResourceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceGroup) *string { return v.ResourceType }).(pulumi.StringPtrOutput)
}

type ResourceGroupPtrOutput struct{ *pulumi.OutputState }

func (ResourceGroupPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceGroup)(nil)).Elem()
}

func (o ResourceGroupPtrOutput) ToResourceGroupPtrOutput() ResourceGroupPtrOutput {
	return o
}

func (o ResourceGroupPtrOutput) ToResourceGroupPtrOutputWithContext(ctx context.Context) ResourceGroupPtrOutput {
	return o
}

func (o ResourceGroupPtrOutput) Elem() ResourceGroupOutput {
	return o.ApplyT(func(v *ResourceGroup) ResourceGroup { return *v }).(ResourceGroupOutput)
}

// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
func (o ResourceGroupPtrOutput) GroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceGroup) *string {
		if v == nil {
			return nil
		}
		return v.GroupId
	}).(pulumi.StringPtrOutput)
}

// The resource type of the group members.
func (o ResourceGroupPtrOutput) ResourceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceGroup) *string {
		if v == nil {
			return nil
		}
		return v.ResourceType
	}).(pulumi.StringPtrOutput)
}

// The resource submessage for group checks. It can be used instead of a monitored resource, when multiple resources are being monitored.
type ResourceGroupResponse struct {
	// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
	GroupId string `pulumi:"groupId"`
	// The resource type of the group members.
	ResourceType string `pulumi:"resourceType"`
}

// ResourceGroupResponseInput is an input type that accepts ResourceGroupResponseArgs and ResourceGroupResponseOutput values.
// You can construct a concrete instance of `ResourceGroupResponseInput` via:
//
//          ResourceGroupResponseArgs{...}
type ResourceGroupResponseInput interface {
	pulumi.Input

	ToResourceGroupResponseOutput() ResourceGroupResponseOutput
	ToResourceGroupResponseOutputWithContext(context.Context) ResourceGroupResponseOutput
}

// The resource submessage for group checks. It can be used instead of a monitored resource, when multiple resources are being monitored.
type ResourceGroupResponseArgs struct {
	// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
	GroupId pulumi.StringInput `pulumi:"groupId"`
	// The resource type of the group members.
	ResourceType pulumi.StringInput `pulumi:"resourceType"`
}

func (ResourceGroupResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceGroupResponse)(nil)).Elem()
}

func (i ResourceGroupResponseArgs) ToResourceGroupResponseOutput() ResourceGroupResponseOutput {
	return i.ToResourceGroupResponseOutputWithContext(context.Background())
}

func (i ResourceGroupResponseArgs) ToResourceGroupResponseOutputWithContext(ctx context.Context) ResourceGroupResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceGroupResponseOutput)
}

func (i ResourceGroupResponseArgs) ToResourceGroupResponsePtrOutput() ResourceGroupResponsePtrOutput {
	return i.ToResourceGroupResponsePtrOutputWithContext(context.Background())
}

func (i ResourceGroupResponseArgs) ToResourceGroupResponsePtrOutputWithContext(ctx context.Context) ResourceGroupResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceGroupResponseOutput).ToResourceGroupResponsePtrOutputWithContext(ctx)
}

// ResourceGroupResponsePtrInput is an input type that accepts ResourceGroupResponseArgs, ResourceGroupResponsePtr and ResourceGroupResponsePtrOutput values.
// You can construct a concrete instance of `ResourceGroupResponsePtrInput` via:
//
//          ResourceGroupResponseArgs{...}
//
//  or:
//
//          nil
type ResourceGroupResponsePtrInput interface {
	pulumi.Input

	ToResourceGroupResponsePtrOutput() ResourceGroupResponsePtrOutput
	ToResourceGroupResponsePtrOutputWithContext(context.Context) ResourceGroupResponsePtrOutput
}

type resourceGroupResponsePtrType ResourceGroupResponseArgs

func ResourceGroupResponsePtr(v *ResourceGroupResponseArgs) ResourceGroupResponsePtrInput {
	return (*resourceGroupResponsePtrType)(v)
}

func (*resourceGroupResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceGroupResponse)(nil)).Elem()
}

func (i *resourceGroupResponsePtrType) ToResourceGroupResponsePtrOutput() ResourceGroupResponsePtrOutput {
	return i.ToResourceGroupResponsePtrOutputWithContext(context.Background())
}

func (i *resourceGroupResponsePtrType) ToResourceGroupResponsePtrOutputWithContext(ctx context.Context) ResourceGroupResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceGroupResponsePtrOutput)
}

// The resource submessage for group checks. It can be used instead of a monitored resource, when multiple resources are being monitored.
type ResourceGroupResponseOutput struct{ *pulumi.OutputState }

func (ResourceGroupResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceGroupResponse)(nil)).Elem()
}

func (o ResourceGroupResponseOutput) ToResourceGroupResponseOutput() ResourceGroupResponseOutput {
	return o
}

func (o ResourceGroupResponseOutput) ToResourceGroupResponseOutputWithContext(ctx context.Context) ResourceGroupResponseOutput {
	return o
}

func (o ResourceGroupResponseOutput) ToResourceGroupResponsePtrOutput() ResourceGroupResponsePtrOutput {
	return o.ToResourceGroupResponsePtrOutputWithContext(context.Background())
}

func (o ResourceGroupResponseOutput) ToResourceGroupResponsePtrOutputWithContext(ctx context.Context) ResourceGroupResponsePtrOutput {
	return o.ApplyT(func(v ResourceGroupResponse) *ResourceGroupResponse {
		return &v
	}).(ResourceGroupResponsePtrOutput)
}

// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
func (o ResourceGroupResponseOutput) GroupId() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceGroupResponse) string { return v.GroupId }).(pulumi.StringOutput)
}

// The resource type of the group members.
func (o ResourceGroupResponseOutput) ResourceType() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceGroupResponse) string { return v.ResourceType }).(pulumi.StringOutput)
}

type ResourceGroupResponsePtrOutput struct{ *pulumi.OutputState }

func (ResourceGroupResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceGroupResponse)(nil)).Elem()
}

func (o ResourceGroupResponsePtrOutput) ToResourceGroupResponsePtrOutput() ResourceGroupResponsePtrOutput {
	return o
}

func (o ResourceGroupResponsePtrOutput) ToResourceGroupResponsePtrOutputWithContext(ctx context.Context) ResourceGroupResponsePtrOutput {
	return o
}

func (o ResourceGroupResponsePtrOutput) Elem() ResourceGroupResponseOutput {
	return o.ApplyT(func(v *ResourceGroupResponse) ResourceGroupResponse { return *v }).(ResourceGroupResponseOutput)
}

// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
func (o ResourceGroupResponsePtrOutput) GroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceGroupResponse) *string {
		if v == nil {
			return nil
		}
		return &v.GroupId
	}).(pulumi.StringPtrOutput)
}

// The resource type of the group members.
func (o ResourceGroupResponsePtrOutput) ResourceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceGroupResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ResourceType
	}).(pulumi.StringPtrOutput)
}

// A Service-Level Indicator (SLI) describes the "performance" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a "custom" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.
type ServiceLevelIndicator struct {
	// Basic SLI on a well-known service type.
	BasicSli *BasicSli `pulumi:"basicSli"`
	// Request-based SLIs
	RequestBased *RequestBasedSli `pulumi:"requestBased"`
	// Windows-based SLIs
	WindowsBased *WindowsBasedSli `pulumi:"windowsBased"`
}

// ServiceLevelIndicatorInput is an input type that accepts ServiceLevelIndicatorArgs and ServiceLevelIndicatorOutput values.
// You can construct a concrete instance of `ServiceLevelIndicatorInput` via:
//
//          ServiceLevelIndicatorArgs{...}
type ServiceLevelIndicatorInput interface {
	pulumi.Input

	ToServiceLevelIndicatorOutput() ServiceLevelIndicatorOutput
	ToServiceLevelIndicatorOutputWithContext(context.Context) ServiceLevelIndicatorOutput
}

// A Service-Level Indicator (SLI) describes the "performance" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a "custom" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.
type ServiceLevelIndicatorArgs struct {
	// Basic SLI on a well-known service type.
	BasicSli BasicSliPtrInput `pulumi:"basicSli"`
	// Request-based SLIs
	RequestBased RequestBasedSliPtrInput `pulumi:"requestBased"`
	// Windows-based SLIs
	WindowsBased WindowsBasedSliPtrInput `pulumi:"windowsBased"`
}

func (ServiceLevelIndicatorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLevelIndicator)(nil)).Elem()
}

func (i ServiceLevelIndicatorArgs) ToServiceLevelIndicatorOutput() ServiceLevelIndicatorOutput {
	return i.ToServiceLevelIndicatorOutputWithContext(context.Background())
}

func (i ServiceLevelIndicatorArgs) ToServiceLevelIndicatorOutputWithContext(ctx context.Context) ServiceLevelIndicatorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLevelIndicatorOutput)
}

func (i ServiceLevelIndicatorArgs) ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput {
	return i.ToServiceLevelIndicatorPtrOutputWithContext(context.Background())
}

func (i ServiceLevelIndicatorArgs) ToServiceLevelIndicatorPtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLevelIndicatorOutput).ToServiceLevelIndicatorPtrOutputWithContext(ctx)
}

// ServiceLevelIndicatorPtrInput is an input type that accepts ServiceLevelIndicatorArgs, ServiceLevelIndicatorPtr and ServiceLevelIndicatorPtrOutput values.
// You can construct a concrete instance of `ServiceLevelIndicatorPtrInput` via:
//
//          ServiceLevelIndicatorArgs{...}
//
//  or:
//
//          nil
type ServiceLevelIndicatorPtrInput interface {
	pulumi.Input

	ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput
	ToServiceLevelIndicatorPtrOutputWithContext(context.Context) ServiceLevelIndicatorPtrOutput
}

type serviceLevelIndicatorPtrType ServiceLevelIndicatorArgs

func ServiceLevelIndicatorPtr(v *ServiceLevelIndicatorArgs) ServiceLevelIndicatorPtrInput {
	return (*serviceLevelIndicatorPtrType)(v)
}

func (*serviceLevelIndicatorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceLevelIndicator)(nil)).Elem()
}

func (i *serviceLevelIndicatorPtrType) ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput {
	return i.ToServiceLevelIndicatorPtrOutputWithContext(context.Background())
}

func (i *serviceLevelIndicatorPtrType) ToServiceLevelIndicatorPtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLevelIndicatorPtrOutput)
}

// A Service-Level Indicator (SLI) describes the "performance" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a "custom" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.
type ServiceLevelIndicatorOutput struct{ *pulumi.OutputState }

func (ServiceLevelIndicatorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLevelIndicator)(nil)).Elem()
}

func (o ServiceLevelIndicatorOutput) ToServiceLevelIndicatorOutput() ServiceLevelIndicatorOutput {
	return o
}

func (o ServiceLevelIndicatorOutput) ToServiceLevelIndicatorOutputWithContext(ctx context.Context) ServiceLevelIndicatorOutput {
	return o
}

func (o ServiceLevelIndicatorOutput) ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput {
	return o.ToServiceLevelIndicatorPtrOutputWithContext(context.Background())
}

func (o ServiceLevelIndicatorOutput) ToServiceLevelIndicatorPtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorPtrOutput {
	return o.ApplyT(func(v ServiceLevelIndicator) *ServiceLevelIndicator {
		return &v
	}).(ServiceLevelIndicatorPtrOutput)
}

// Basic SLI on a well-known service type.
func (o ServiceLevelIndicatorOutput) BasicSli() BasicSliPtrOutput {
	return o.ApplyT(func(v ServiceLevelIndicator) *BasicSli { return v.BasicSli }).(BasicSliPtrOutput)
}

// Request-based SLIs
func (o ServiceLevelIndicatorOutput) RequestBased() RequestBasedSliPtrOutput {
	return o.ApplyT(func(v ServiceLevelIndicator) *RequestBasedSli { return v.RequestBased }).(RequestBasedSliPtrOutput)
}

// Windows-based SLIs
func (o ServiceLevelIndicatorOutput) WindowsBased() WindowsBasedSliPtrOutput {
	return o.ApplyT(func(v ServiceLevelIndicator) *WindowsBasedSli { return v.WindowsBased }).(WindowsBasedSliPtrOutput)
}

type ServiceLevelIndicatorPtrOutput struct{ *pulumi.OutputState }

func (ServiceLevelIndicatorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceLevelIndicator)(nil)).Elem()
}

func (o ServiceLevelIndicatorPtrOutput) ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput {
	return o
}

func (o ServiceLevelIndicatorPtrOutput) ToServiceLevelIndicatorPtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorPtrOutput {
	return o
}

func (o ServiceLevelIndicatorPtrOutput) Elem() ServiceLevelIndicatorOutput {
	return o.ApplyT(func(v *ServiceLevelIndicator) ServiceLevelIndicator { return *v }).(ServiceLevelIndicatorOutput)
}

// Basic SLI on a well-known service type.
func (o ServiceLevelIndicatorPtrOutput) BasicSli() BasicSliPtrOutput {
	return o.ApplyT(func(v *ServiceLevelIndicator) *BasicSli {
		if v == nil {
			return nil
		}
		return v.BasicSli
	}).(BasicSliPtrOutput)
}

// Request-based SLIs
func (o ServiceLevelIndicatorPtrOutput) RequestBased() RequestBasedSliPtrOutput {
	return o.ApplyT(func(v *ServiceLevelIndicator) *RequestBasedSli {
		if v == nil {
			return nil
		}
		return v.RequestBased
	}).(RequestBasedSliPtrOutput)
}

// Windows-based SLIs
func (o ServiceLevelIndicatorPtrOutput) WindowsBased() WindowsBasedSliPtrOutput {
	return o.ApplyT(func(v *ServiceLevelIndicator) *WindowsBasedSli {
		if v == nil {
			return nil
		}
		return v.WindowsBased
	}).(WindowsBasedSliPtrOutput)
}

// A Service-Level Indicator (SLI) describes the "performance" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a "custom" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.
type ServiceLevelIndicatorResponse struct {
	// Basic SLI on a well-known service type.
	BasicSli BasicSliResponse `pulumi:"basicSli"`
	// Request-based SLIs
	RequestBased RequestBasedSliResponse `pulumi:"requestBased"`
	// Windows-based SLIs
	WindowsBased WindowsBasedSliResponse `pulumi:"windowsBased"`
}

// ServiceLevelIndicatorResponseInput is an input type that accepts ServiceLevelIndicatorResponseArgs and ServiceLevelIndicatorResponseOutput values.
// You can construct a concrete instance of `ServiceLevelIndicatorResponseInput` via:
//
//          ServiceLevelIndicatorResponseArgs{...}
type ServiceLevelIndicatorResponseInput interface {
	pulumi.Input

	ToServiceLevelIndicatorResponseOutput() ServiceLevelIndicatorResponseOutput
	ToServiceLevelIndicatorResponseOutputWithContext(context.Context) ServiceLevelIndicatorResponseOutput
}

// A Service-Level Indicator (SLI) describes the "performance" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a "custom" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.
type ServiceLevelIndicatorResponseArgs struct {
	// Basic SLI on a well-known service type.
	BasicSli BasicSliResponseInput `pulumi:"basicSli"`
	// Request-based SLIs
	RequestBased RequestBasedSliResponseInput `pulumi:"requestBased"`
	// Windows-based SLIs
	WindowsBased WindowsBasedSliResponseInput `pulumi:"windowsBased"`
}

func (ServiceLevelIndicatorResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLevelIndicatorResponse)(nil)).Elem()
}

func (i ServiceLevelIndicatorResponseArgs) ToServiceLevelIndicatorResponseOutput() ServiceLevelIndicatorResponseOutput {
	return i.ToServiceLevelIndicatorResponseOutputWithContext(context.Background())
}

func (i ServiceLevelIndicatorResponseArgs) ToServiceLevelIndicatorResponseOutputWithContext(ctx context.Context) ServiceLevelIndicatorResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLevelIndicatorResponseOutput)
}

func (i ServiceLevelIndicatorResponseArgs) ToServiceLevelIndicatorResponsePtrOutput() ServiceLevelIndicatorResponsePtrOutput {
	return i.ToServiceLevelIndicatorResponsePtrOutputWithContext(context.Background())
}

func (i ServiceLevelIndicatorResponseArgs) ToServiceLevelIndicatorResponsePtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLevelIndicatorResponseOutput).ToServiceLevelIndicatorResponsePtrOutputWithContext(ctx)
}

// ServiceLevelIndicatorResponsePtrInput is an input type that accepts ServiceLevelIndicatorResponseArgs, ServiceLevelIndicatorResponsePtr and ServiceLevelIndicatorResponsePtrOutput values.
// You can construct a concrete instance of `ServiceLevelIndicatorResponsePtrInput` via:
//
//          ServiceLevelIndicatorResponseArgs{...}
//
//  or:
//
//          nil
type ServiceLevelIndicatorResponsePtrInput interface {
	pulumi.Input

	ToServiceLevelIndicatorResponsePtrOutput() ServiceLevelIndicatorResponsePtrOutput
	ToServiceLevelIndicatorResponsePtrOutputWithContext(context.Context) ServiceLevelIndicatorResponsePtrOutput
}

type serviceLevelIndicatorResponsePtrType ServiceLevelIndicatorResponseArgs

func ServiceLevelIndicatorResponsePtr(v *ServiceLevelIndicatorResponseArgs) ServiceLevelIndicatorResponsePtrInput {
	return (*serviceLevelIndicatorResponsePtrType)(v)
}

func (*serviceLevelIndicatorResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceLevelIndicatorResponse)(nil)).Elem()
}

func (i *serviceLevelIndicatorResponsePtrType) ToServiceLevelIndicatorResponsePtrOutput() ServiceLevelIndicatorResponsePtrOutput {
	return i.ToServiceLevelIndicatorResponsePtrOutputWithContext(context.Background())
}

func (i *serviceLevelIndicatorResponsePtrType) ToServiceLevelIndicatorResponsePtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLevelIndicatorResponsePtrOutput)
}

// A Service-Level Indicator (SLI) describes the "performance" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a "custom" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.
type ServiceLevelIndicatorResponseOutput struct{ *pulumi.OutputState }

func (ServiceLevelIndicatorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLevelIndicatorResponse)(nil)).Elem()
}

func (o ServiceLevelIndicatorResponseOutput) ToServiceLevelIndicatorResponseOutput() ServiceLevelIndicatorResponseOutput {
	return o
}

func (o ServiceLevelIndicatorResponseOutput) ToServiceLevelIndicatorResponseOutputWithContext(ctx context.Context) ServiceLevelIndicatorResponseOutput {
	return o
}

func (o ServiceLevelIndicatorResponseOutput) ToServiceLevelIndicatorResponsePtrOutput() ServiceLevelIndicatorResponsePtrOutput {
	return o.ToServiceLevelIndicatorResponsePtrOutputWithContext(context.Background())
}

func (o ServiceLevelIndicatorResponseOutput) ToServiceLevelIndicatorResponsePtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorResponsePtrOutput {
	return o.ApplyT(func(v ServiceLevelIndicatorResponse) *ServiceLevelIndicatorResponse {
		return &v
	}).(ServiceLevelIndicatorResponsePtrOutput)
}

// Basic SLI on a well-known service type.
func (o ServiceLevelIndicatorResponseOutput) BasicSli() BasicSliResponseOutput {
	return o.ApplyT(func(v ServiceLevelIndicatorResponse) BasicSliResponse { return v.BasicSli }).(BasicSliResponseOutput)
}

// Request-based SLIs
func (o ServiceLevelIndicatorResponseOutput) RequestBased() RequestBasedSliResponseOutput {
	return o.ApplyT(func(v ServiceLevelIndicatorResponse) RequestBasedSliResponse { return v.RequestBased }).(RequestBasedSliResponseOutput)
}

// Windows-based SLIs
func (o ServiceLevelIndicatorResponseOutput) WindowsBased() WindowsBasedSliResponseOutput {
	return o.ApplyT(func(v ServiceLevelIndicatorResponse) WindowsBasedSliResponse { return v.WindowsBased }).(WindowsBasedSliResponseOutput)
}

type ServiceLevelIndicatorResponsePtrOutput struct{ *pulumi.OutputState }

func (ServiceLevelIndicatorResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceLevelIndicatorResponse)(nil)).Elem()
}

func (o ServiceLevelIndicatorResponsePtrOutput) ToServiceLevelIndicatorResponsePtrOutput() ServiceLevelIndicatorResponsePtrOutput {
	return o
}

func (o ServiceLevelIndicatorResponsePtrOutput) ToServiceLevelIndicatorResponsePtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorResponsePtrOutput {
	return o
}

func (o ServiceLevelIndicatorResponsePtrOutput) Elem() ServiceLevelIndicatorResponseOutput {
	return o.ApplyT(func(v *ServiceLevelIndicatorResponse) ServiceLevelIndicatorResponse { return *v }).(ServiceLevelIndicatorResponseOutput)
}

// Basic SLI on a well-known service type.
func (o ServiceLevelIndicatorResponsePtrOutput) BasicSli() BasicSliResponsePtrOutput {
	return o.ApplyT(func(v *ServiceLevelIndicatorResponse) *BasicSliResponse {
		if v == nil {
			return nil
		}
		return &v.BasicSli
	}).(BasicSliResponsePtrOutput)
}

// Request-based SLIs
func (o ServiceLevelIndicatorResponsePtrOutput) RequestBased() RequestBasedSliResponsePtrOutput {
	return o.ApplyT(func(v *ServiceLevelIndicatorResponse) *RequestBasedSliResponse {
		if v == nil {
			return nil
		}
		return &v.RequestBased
	}).(RequestBasedSliResponsePtrOutput)
}

// Windows-based SLIs
func (o ServiceLevelIndicatorResponsePtrOutput) WindowsBased() WindowsBasedSliResponsePtrOutput {
	return o.ApplyT(func(v *ServiceLevelIndicatorResponse) *WindowsBasedSliResponse {
		if v == nil {
			return nil
		}
		return &v.WindowsBased
	}).(WindowsBasedSliResponsePtrOutput)
}

// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
type Status struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code *int `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details []map[string]string `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message *string `pulumi:"message"`
}

// StatusInput is an input type that accepts StatusArgs and StatusOutput values.
// You can construct a concrete instance of `StatusInput` via:
//
//          StatusArgs{...}
type StatusInput interface {
	pulumi.Input

	ToStatusOutput() StatusOutput
	ToStatusOutputWithContext(context.Context) StatusOutput
}

// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
type StatusArgs struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code pulumi.IntPtrInput `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details pulumi.StringMapArrayInput `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message pulumi.StringPtrInput `pulumi:"message"`
}

func (StatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Status)(nil)).Elem()
}

func (i StatusArgs) ToStatusOutput() StatusOutput {
	return i.ToStatusOutputWithContext(context.Background())
}

func (i StatusArgs) ToStatusOutputWithContext(ctx context.Context) StatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusOutput)
}

func (i StatusArgs) ToStatusPtrOutput() StatusPtrOutput {
	return i.ToStatusPtrOutputWithContext(context.Background())
}

func (i StatusArgs) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusOutput).ToStatusPtrOutputWithContext(ctx)
}

// StatusPtrInput is an input type that accepts StatusArgs, StatusPtr and StatusPtrOutput values.
// You can construct a concrete instance of `StatusPtrInput` via:
//
//          StatusArgs{...}
//
//  or:
//
//          nil
type StatusPtrInput interface {
	pulumi.Input

	ToStatusPtrOutput() StatusPtrOutput
	ToStatusPtrOutputWithContext(context.Context) StatusPtrOutput
}

type statusPtrType StatusArgs

func StatusPtr(v *StatusArgs) StatusPtrInput {
	return (*statusPtrType)(v)
}

func (*statusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Status)(nil)).Elem()
}

func (i *statusPtrType) ToStatusPtrOutput() StatusPtrOutput {
	return i.ToStatusPtrOutputWithContext(context.Background())
}

func (i *statusPtrType) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusPtrOutput)
}

// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
type StatusOutput struct{ *pulumi.OutputState }

func (StatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Status)(nil)).Elem()
}

func (o StatusOutput) ToStatusOutput() StatusOutput {
	return o
}

func (o StatusOutput) ToStatusOutputWithContext(ctx context.Context) StatusOutput {
	return o
}

func (o StatusOutput) ToStatusPtrOutput() StatusPtrOutput {
	return o.ToStatusPtrOutputWithContext(context.Background())
}

func (o StatusOutput) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return o.ApplyT(func(v Status) *Status {
		return &v
	}).(StatusPtrOutput)
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusOutput) Code() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Status) *int { return v.Code }).(pulumi.IntPtrOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusOutput) Details() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v Status) []map[string]string { return v.Details }).(pulumi.StringMapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Status) *string { return v.Message }).(pulumi.StringPtrOutput)
}

type StatusPtrOutput struct{ *pulumi.OutputState }

func (StatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Status)(nil)).Elem()
}

func (o StatusPtrOutput) ToStatusPtrOutput() StatusPtrOutput {
	return o
}

func (o StatusPtrOutput) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return o
}

func (o StatusPtrOutput) Elem() StatusOutput {
	return o.ApplyT(func(v *Status) Status { return *v }).(StatusOutput)
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusPtrOutput) Code() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Status) *int {
		if v == nil {
			return nil
		}
		return v.Code
	}).(pulumi.IntPtrOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusPtrOutput) Details() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v *Status) []map[string]string {
		if v == nil {
			return nil
		}
		return v.Details
	}).(pulumi.StringMapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusPtrOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Status) *string {
		if v == nil {
			return nil
		}
		return v.Message
	}).(pulumi.StringPtrOutput)
}

// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
type StatusResponse struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code int `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details []map[string]string `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message string `pulumi:"message"`
}

// StatusResponseInput is an input type that accepts StatusResponseArgs and StatusResponseOutput values.
// You can construct a concrete instance of `StatusResponseInput` via:
//
//          StatusResponseArgs{...}
type StatusResponseInput interface {
	pulumi.Input

	ToStatusResponseOutput() StatusResponseOutput
	ToStatusResponseOutputWithContext(context.Context) StatusResponseOutput
}

// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
type StatusResponseArgs struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code pulumi.IntInput `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details pulumi.StringMapArrayInput `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message pulumi.StringInput `pulumi:"message"`
}

func (StatusResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatusResponse)(nil)).Elem()
}

func (i StatusResponseArgs) ToStatusResponseOutput() StatusResponseOutput {
	return i.ToStatusResponseOutputWithContext(context.Background())
}

func (i StatusResponseArgs) ToStatusResponseOutputWithContext(ctx context.Context) StatusResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusResponseOutput)
}

func (i StatusResponseArgs) ToStatusResponsePtrOutput() StatusResponsePtrOutput {
	return i.ToStatusResponsePtrOutputWithContext(context.Background())
}

func (i StatusResponseArgs) ToStatusResponsePtrOutputWithContext(ctx context.Context) StatusResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusResponseOutput).ToStatusResponsePtrOutputWithContext(ctx)
}

// StatusResponsePtrInput is an input type that accepts StatusResponseArgs, StatusResponsePtr and StatusResponsePtrOutput values.
// You can construct a concrete instance of `StatusResponsePtrInput` via:
//
//          StatusResponseArgs{...}
//
//  or:
//
//          nil
type StatusResponsePtrInput interface {
	pulumi.Input

	ToStatusResponsePtrOutput() StatusResponsePtrOutput
	ToStatusResponsePtrOutputWithContext(context.Context) StatusResponsePtrOutput
}

type statusResponsePtrType StatusResponseArgs

func StatusResponsePtr(v *StatusResponseArgs) StatusResponsePtrInput {
	return (*statusResponsePtrType)(v)
}

func (*statusResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StatusResponse)(nil)).Elem()
}

func (i *statusResponsePtrType) ToStatusResponsePtrOutput() StatusResponsePtrOutput {
	return i.ToStatusResponsePtrOutputWithContext(context.Background())
}

func (i *statusResponsePtrType) ToStatusResponsePtrOutputWithContext(ctx context.Context) StatusResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusResponsePtrOutput)
}

// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
type StatusResponseOutput struct{ *pulumi.OutputState }

func (StatusResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatusResponse)(nil)).Elem()
}

func (o StatusResponseOutput) ToStatusResponseOutput() StatusResponseOutput {
	return o
}

func (o StatusResponseOutput) ToStatusResponseOutputWithContext(ctx context.Context) StatusResponseOutput {
	return o
}

func (o StatusResponseOutput) ToStatusResponsePtrOutput() StatusResponsePtrOutput {
	return o.ToStatusResponsePtrOutputWithContext(context.Background())
}

func (o StatusResponseOutput) ToStatusResponsePtrOutputWithContext(ctx context.Context) StatusResponsePtrOutput {
	return o.ApplyT(func(v StatusResponse) *StatusResponse {
		return &v
	}).(StatusResponsePtrOutput)
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusResponseOutput) Code() pulumi.IntOutput {
	return o.ApplyT(func(v StatusResponse) int { return v.Code }).(pulumi.IntOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusResponseOutput) Details() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v StatusResponse) []map[string]string { return v.Details }).(pulumi.StringMapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusResponseOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v StatusResponse) string { return v.Message }).(pulumi.StringOutput)
}

type StatusResponsePtrOutput struct{ *pulumi.OutputState }

func (StatusResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StatusResponse)(nil)).Elem()
}

func (o StatusResponsePtrOutput) ToStatusResponsePtrOutput() StatusResponsePtrOutput {
	return o
}

func (o StatusResponsePtrOutput) ToStatusResponsePtrOutputWithContext(ctx context.Context) StatusResponsePtrOutput {
	return o
}

func (o StatusResponsePtrOutput) Elem() StatusResponseOutput {
	return o.ApplyT(func(v *StatusResponse) StatusResponse { return *v }).(StatusResponseOutput)
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusResponsePtrOutput) Code() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatusResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Code
	}).(pulumi.IntPtrOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusResponsePtrOutput) Details() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v *StatusResponse) []map[string]string {
		if v == nil {
			return nil
		}
		return v.Details
	}).(pulumi.StringMapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusResponsePtrOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatusResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Message
	}).(pulumi.StringPtrOutput)
}

// Information required for a TCP Uptime check request.
type TcpCheck struct {
	// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
	Port *int `pulumi:"port"`
}

// TcpCheckInput is an input type that accepts TcpCheckArgs and TcpCheckOutput values.
// You can construct a concrete instance of `TcpCheckInput` via:
//
//          TcpCheckArgs{...}
type TcpCheckInput interface {
	pulumi.Input

	ToTcpCheckOutput() TcpCheckOutput
	ToTcpCheckOutputWithContext(context.Context) TcpCheckOutput
}

// Information required for a TCP Uptime check request.
type TcpCheckArgs struct {
	// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (TcpCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TcpCheck)(nil)).Elem()
}

func (i TcpCheckArgs) ToTcpCheckOutput() TcpCheckOutput {
	return i.ToTcpCheckOutputWithContext(context.Background())
}

func (i TcpCheckArgs) ToTcpCheckOutputWithContext(ctx context.Context) TcpCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TcpCheckOutput)
}

func (i TcpCheckArgs) ToTcpCheckPtrOutput() TcpCheckPtrOutput {
	return i.ToTcpCheckPtrOutputWithContext(context.Background())
}

func (i TcpCheckArgs) ToTcpCheckPtrOutputWithContext(ctx context.Context) TcpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TcpCheckOutput).ToTcpCheckPtrOutputWithContext(ctx)
}

// TcpCheckPtrInput is an input type that accepts TcpCheckArgs, TcpCheckPtr and TcpCheckPtrOutput values.
// You can construct a concrete instance of `TcpCheckPtrInput` via:
//
//          TcpCheckArgs{...}
//
//  or:
//
//          nil
type TcpCheckPtrInput interface {
	pulumi.Input

	ToTcpCheckPtrOutput() TcpCheckPtrOutput
	ToTcpCheckPtrOutputWithContext(context.Context) TcpCheckPtrOutput
}

type tcpCheckPtrType TcpCheckArgs

func TcpCheckPtr(v *TcpCheckArgs) TcpCheckPtrInput {
	return (*tcpCheckPtrType)(v)
}

func (*tcpCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TcpCheck)(nil)).Elem()
}

func (i *tcpCheckPtrType) ToTcpCheckPtrOutput() TcpCheckPtrOutput {
	return i.ToTcpCheckPtrOutputWithContext(context.Background())
}

func (i *tcpCheckPtrType) ToTcpCheckPtrOutputWithContext(ctx context.Context) TcpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TcpCheckPtrOutput)
}

// Information required for a TCP Uptime check request.
type TcpCheckOutput struct{ *pulumi.OutputState }

func (TcpCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TcpCheck)(nil)).Elem()
}

func (o TcpCheckOutput) ToTcpCheckOutput() TcpCheckOutput {
	return o
}

func (o TcpCheckOutput) ToTcpCheckOutputWithContext(ctx context.Context) TcpCheckOutput {
	return o
}

func (o TcpCheckOutput) ToTcpCheckPtrOutput() TcpCheckPtrOutput {
	return o.ToTcpCheckPtrOutputWithContext(context.Background())
}

func (o TcpCheckOutput) ToTcpCheckPtrOutputWithContext(ctx context.Context) TcpCheckPtrOutput {
	return o.ApplyT(func(v TcpCheck) *TcpCheck {
		return &v
	}).(TcpCheckPtrOutput)
}

// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
func (o TcpCheckOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TcpCheck) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type TcpCheckPtrOutput struct{ *pulumi.OutputState }

func (TcpCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TcpCheck)(nil)).Elem()
}

func (o TcpCheckPtrOutput) ToTcpCheckPtrOutput() TcpCheckPtrOutput {
	return o
}

func (o TcpCheckPtrOutput) ToTcpCheckPtrOutputWithContext(ctx context.Context) TcpCheckPtrOutput {
	return o
}

func (o TcpCheckPtrOutput) Elem() TcpCheckOutput {
	return o.ApplyT(func(v *TcpCheck) TcpCheck { return *v }).(TcpCheckOutput)
}

// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
func (o TcpCheckPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TcpCheck) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// Information required for a TCP Uptime check request.
type TcpCheckResponse struct {
	// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
	Port int `pulumi:"port"`
}

// TcpCheckResponseInput is an input type that accepts TcpCheckResponseArgs and TcpCheckResponseOutput values.
// You can construct a concrete instance of `TcpCheckResponseInput` via:
//
//          TcpCheckResponseArgs{...}
type TcpCheckResponseInput interface {
	pulumi.Input

	ToTcpCheckResponseOutput() TcpCheckResponseOutput
	ToTcpCheckResponseOutputWithContext(context.Context) TcpCheckResponseOutput
}

// Information required for a TCP Uptime check request.
type TcpCheckResponseArgs struct {
	// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
	Port pulumi.IntInput `pulumi:"port"`
}

func (TcpCheckResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TcpCheckResponse)(nil)).Elem()
}

func (i TcpCheckResponseArgs) ToTcpCheckResponseOutput() TcpCheckResponseOutput {
	return i.ToTcpCheckResponseOutputWithContext(context.Background())
}

func (i TcpCheckResponseArgs) ToTcpCheckResponseOutputWithContext(ctx context.Context) TcpCheckResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TcpCheckResponseOutput)
}

func (i TcpCheckResponseArgs) ToTcpCheckResponsePtrOutput() TcpCheckResponsePtrOutput {
	return i.ToTcpCheckResponsePtrOutputWithContext(context.Background())
}

func (i TcpCheckResponseArgs) ToTcpCheckResponsePtrOutputWithContext(ctx context.Context) TcpCheckResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TcpCheckResponseOutput).ToTcpCheckResponsePtrOutputWithContext(ctx)
}

// TcpCheckResponsePtrInput is an input type that accepts TcpCheckResponseArgs, TcpCheckResponsePtr and TcpCheckResponsePtrOutput values.
// You can construct a concrete instance of `TcpCheckResponsePtrInput` via:
//
//          TcpCheckResponseArgs{...}
//
//  or:
//
//          nil
type TcpCheckResponsePtrInput interface {
	pulumi.Input

	ToTcpCheckResponsePtrOutput() TcpCheckResponsePtrOutput
	ToTcpCheckResponsePtrOutputWithContext(context.Context) TcpCheckResponsePtrOutput
}

type tcpCheckResponsePtrType TcpCheckResponseArgs

func TcpCheckResponsePtr(v *TcpCheckResponseArgs) TcpCheckResponsePtrInput {
	return (*tcpCheckResponsePtrType)(v)
}

func (*tcpCheckResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TcpCheckResponse)(nil)).Elem()
}

func (i *tcpCheckResponsePtrType) ToTcpCheckResponsePtrOutput() TcpCheckResponsePtrOutput {
	return i.ToTcpCheckResponsePtrOutputWithContext(context.Background())
}

func (i *tcpCheckResponsePtrType) ToTcpCheckResponsePtrOutputWithContext(ctx context.Context) TcpCheckResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TcpCheckResponsePtrOutput)
}

// Information required for a TCP Uptime check request.
type TcpCheckResponseOutput struct{ *pulumi.OutputState }

func (TcpCheckResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TcpCheckResponse)(nil)).Elem()
}

func (o TcpCheckResponseOutput) ToTcpCheckResponseOutput() TcpCheckResponseOutput {
	return o
}

func (o TcpCheckResponseOutput) ToTcpCheckResponseOutputWithContext(ctx context.Context) TcpCheckResponseOutput {
	return o
}

func (o TcpCheckResponseOutput) ToTcpCheckResponsePtrOutput() TcpCheckResponsePtrOutput {
	return o.ToTcpCheckResponsePtrOutputWithContext(context.Background())
}

func (o TcpCheckResponseOutput) ToTcpCheckResponsePtrOutputWithContext(ctx context.Context) TcpCheckResponsePtrOutput {
	return o.ApplyT(func(v TcpCheckResponse) *TcpCheckResponse {
		return &v
	}).(TcpCheckResponsePtrOutput)
}

// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
func (o TcpCheckResponseOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v TcpCheckResponse) int { return v.Port }).(pulumi.IntOutput)
}

type TcpCheckResponsePtrOutput struct{ *pulumi.OutputState }

func (TcpCheckResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TcpCheckResponse)(nil)).Elem()
}

func (o TcpCheckResponsePtrOutput) ToTcpCheckResponsePtrOutput() TcpCheckResponsePtrOutput {
	return o
}

func (o TcpCheckResponsePtrOutput) ToTcpCheckResponsePtrOutputWithContext(ctx context.Context) TcpCheckResponsePtrOutput {
	return o
}

func (o TcpCheckResponsePtrOutput) Elem() TcpCheckResponseOutput {
	return o.ApplyT(func(v *TcpCheckResponse) TcpCheckResponse { return *v }).(TcpCheckResponseOutput)
}

// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
func (o TcpCheckResponsePtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TcpCheckResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Port
	}).(pulumi.IntPtrOutput)
}

// Configuration for how to query telemetry on a Service.
type Telemetry struct {
	// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
	ResourceName *string `pulumi:"resourceName"`
}

// TelemetryInput is an input type that accepts TelemetryArgs and TelemetryOutput values.
// You can construct a concrete instance of `TelemetryInput` via:
//
//          TelemetryArgs{...}
type TelemetryInput interface {
	pulumi.Input

	ToTelemetryOutput() TelemetryOutput
	ToTelemetryOutputWithContext(context.Context) TelemetryOutput
}

// Configuration for how to query telemetry on a Service.
type TelemetryArgs struct {
	// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
	ResourceName pulumi.StringPtrInput `pulumi:"resourceName"`
}

func (TelemetryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Telemetry)(nil)).Elem()
}

func (i TelemetryArgs) ToTelemetryOutput() TelemetryOutput {
	return i.ToTelemetryOutputWithContext(context.Background())
}

func (i TelemetryArgs) ToTelemetryOutputWithContext(ctx context.Context) TelemetryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TelemetryOutput)
}

func (i TelemetryArgs) ToTelemetryPtrOutput() TelemetryPtrOutput {
	return i.ToTelemetryPtrOutputWithContext(context.Background())
}

func (i TelemetryArgs) ToTelemetryPtrOutputWithContext(ctx context.Context) TelemetryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TelemetryOutput).ToTelemetryPtrOutputWithContext(ctx)
}

// TelemetryPtrInput is an input type that accepts TelemetryArgs, TelemetryPtr and TelemetryPtrOutput values.
// You can construct a concrete instance of `TelemetryPtrInput` via:
//
//          TelemetryArgs{...}
//
//  or:
//
//          nil
type TelemetryPtrInput interface {
	pulumi.Input

	ToTelemetryPtrOutput() TelemetryPtrOutput
	ToTelemetryPtrOutputWithContext(context.Context) TelemetryPtrOutput
}

type telemetryPtrType TelemetryArgs

func TelemetryPtr(v *TelemetryArgs) TelemetryPtrInput {
	return (*telemetryPtrType)(v)
}

func (*telemetryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Telemetry)(nil)).Elem()
}

func (i *telemetryPtrType) ToTelemetryPtrOutput() TelemetryPtrOutput {
	return i.ToTelemetryPtrOutputWithContext(context.Background())
}

func (i *telemetryPtrType) ToTelemetryPtrOutputWithContext(ctx context.Context) TelemetryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TelemetryPtrOutput)
}

// Configuration for how to query telemetry on a Service.
type TelemetryOutput struct{ *pulumi.OutputState }

func (TelemetryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Telemetry)(nil)).Elem()
}

func (o TelemetryOutput) ToTelemetryOutput() TelemetryOutput {
	return o
}

func (o TelemetryOutput) ToTelemetryOutputWithContext(ctx context.Context) TelemetryOutput {
	return o
}

func (o TelemetryOutput) ToTelemetryPtrOutput() TelemetryPtrOutput {
	return o.ToTelemetryPtrOutputWithContext(context.Background())
}

func (o TelemetryOutput) ToTelemetryPtrOutputWithContext(ctx context.Context) TelemetryPtrOutput {
	return o.ApplyT(func(v Telemetry) *Telemetry {
		return &v
	}).(TelemetryPtrOutput)
}

// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
func (o TelemetryOutput) ResourceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Telemetry) *string { return v.ResourceName }).(pulumi.StringPtrOutput)
}

type TelemetryPtrOutput struct{ *pulumi.OutputState }

func (TelemetryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Telemetry)(nil)).Elem()
}

func (o TelemetryPtrOutput) ToTelemetryPtrOutput() TelemetryPtrOutput {
	return o
}

func (o TelemetryPtrOutput) ToTelemetryPtrOutputWithContext(ctx context.Context) TelemetryPtrOutput {
	return o
}

func (o TelemetryPtrOutput) Elem() TelemetryOutput {
	return o.ApplyT(func(v *Telemetry) Telemetry { return *v }).(TelemetryOutput)
}

// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
func (o TelemetryPtrOutput) ResourceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Telemetry) *string {
		if v == nil {
			return nil
		}
		return v.ResourceName
	}).(pulumi.StringPtrOutput)
}

// Configuration for how to query telemetry on a Service.
type TelemetryResponse struct {
	// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
	ResourceName string `pulumi:"resourceName"`
}

// TelemetryResponseInput is an input type that accepts TelemetryResponseArgs and TelemetryResponseOutput values.
// You can construct a concrete instance of `TelemetryResponseInput` via:
//
//          TelemetryResponseArgs{...}
type TelemetryResponseInput interface {
	pulumi.Input

	ToTelemetryResponseOutput() TelemetryResponseOutput
	ToTelemetryResponseOutputWithContext(context.Context) TelemetryResponseOutput
}

// Configuration for how to query telemetry on a Service.
type TelemetryResponseArgs struct {
	// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
	ResourceName pulumi.StringInput `pulumi:"resourceName"`
}

func (TelemetryResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TelemetryResponse)(nil)).Elem()
}

func (i TelemetryResponseArgs) ToTelemetryResponseOutput() TelemetryResponseOutput {
	return i.ToTelemetryResponseOutputWithContext(context.Background())
}

func (i TelemetryResponseArgs) ToTelemetryResponseOutputWithContext(ctx context.Context) TelemetryResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TelemetryResponseOutput)
}

func (i TelemetryResponseArgs) ToTelemetryResponsePtrOutput() TelemetryResponsePtrOutput {
	return i.ToTelemetryResponsePtrOutputWithContext(context.Background())
}

func (i TelemetryResponseArgs) ToTelemetryResponsePtrOutputWithContext(ctx context.Context) TelemetryResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TelemetryResponseOutput).ToTelemetryResponsePtrOutputWithContext(ctx)
}

// TelemetryResponsePtrInput is an input type that accepts TelemetryResponseArgs, TelemetryResponsePtr and TelemetryResponsePtrOutput values.
// You can construct a concrete instance of `TelemetryResponsePtrInput` via:
//
//          TelemetryResponseArgs{...}
//
//  or:
//
//          nil
type TelemetryResponsePtrInput interface {
	pulumi.Input

	ToTelemetryResponsePtrOutput() TelemetryResponsePtrOutput
	ToTelemetryResponsePtrOutputWithContext(context.Context) TelemetryResponsePtrOutput
}

type telemetryResponsePtrType TelemetryResponseArgs

func TelemetryResponsePtr(v *TelemetryResponseArgs) TelemetryResponsePtrInput {
	return (*telemetryResponsePtrType)(v)
}

func (*telemetryResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TelemetryResponse)(nil)).Elem()
}

func (i *telemetryResponsePtrType) ToTelemetryResponsePtrOutput() TelemetryResponsePtrOutput {
	return i.ToTelemetryResponsePtrOutputWithContext(context.Background())
}

func (i *telemetryResponsePtrType) ToTelemetryResponsePtrOutputWithContext(ctx context.Context) TelemetryResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TelemetryResponsePtrOutput)
}

// Configuration for how to query telemetry on a Service.
type TelemetryResponseOutput struct{ *pulumi.OutputState }

func (TelemetryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TelemetryResponse)(nil)).Elem()
}

func (o TelemetryResponseOutput) ToTelemetryResponseOutput() TelemetryResponseOutput {
	return o
}

func (o TelemetryResponseOutput) ToTelemetryResponseOutputWithContext(ctx context.Context) TelemetryResponseOutput {
	return o
}

func (o TelemetryResponseOutput) ToTelemetryResponsePtrOutput() TelemetryResponsePtrOutput {
	return o.ToTelemetryResponsePtrOutputWithContext(context.Background())
}

func (o TelemetryResponseOutput) ToTelemetryResponsePtrOutputWithContext(ctx context.Context) TelemetryResponsePtrOutput {
	return o.ApplyT(func(v TelemetryResponse) *TelemetryResponse {
		return &v
	}).(TelemetryResponsePtrOutput)
}

// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
func (o TelemetryResponseOutput) ResourceName() pulumi.StringOutput {
	return o.ApplyT(func(v TelemetryResponse) string { return v.ResourceName }).(pulumi.StringOutput)
}

type TelemetryResponsePtrOutput struct{ *pulumi.OutputState }

func (TelemetryResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TelemetryResponse)(nil)).Elem()
}

func (o TelemetryResponsePtrOutput) ToTelemetryResponsePtrOutput() TelemetryResponsePtrOutput {
	return o
}

func (o TelemetryResponsePtrOutput) ToTelemetryResponsePtrOutputWithContext(ctx context.Context) TelemetryResponsePtrOutput {
	return o
}

func (o TelemetryResponsePtrOutput) Elem() TelemetryResponseOutput {
	return o.ApplyT(func(v *TelemetryResponse) TelemetryResponse { return *v }).(TelemetryResponseOutput)
}

// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
func (o TelemetryResponsePtrOutput) ResourceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TelemetryResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ResourceName
	}).(pulumi.StringPtrOutput)
}

// A closed time interval. It extends from the start time to the end time, and includes both: [startTime, endTime]. Valid time intervals depend on the MetricKind of the metric value. The end time must not be earlier than the start time. When writing data points, the start time must not be more than 25 hours in the past and the end time must not be more than five minutes in the future. For GAUGE metrics, the startTime value is technically optional; if no value is specified, the start time defaults to the value of the end time, and the interval represents a single point in time. If both start and end times are specified, they must be identical. Such an interval is valid only for GAUGE metrics, which are point-in-time measurements. The end time of a new interval must be at least a millisecond after the end time of the previous interval. For DELTA metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For DELTA metrics, the start time of the next interval must be at least a millisecond after the end time of the previous interval. For CUMULATIVE metrics, the start time and end time must specify a a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points. The new start time must be at least a millisecond after the end time of the previous interval. The start time of a new interval must be at least a millisecond after the end time of the previous interval because intervals are closed. If the start time of a new interval is the same as the end time of the previous interval, then data written at the new start time could overwrite data written at the previous end time.
type TimeInterval struct {
	// Required. The end of the time interval.
	EndTime *string `pulumi:"endTime"`
	// Optional. The beginning of the time interval. The default value for the start time is the end time. The start time must not be later than the end time.
	StartTime *string `pulumi:"startTime"`
}

// TimeIntervalInput is an input type that accepts TimeIntervalArgs and TimeIntervalOutput values.
// You can construct a concrete instance of `TimeIntervalInput` via:
//
//          TimeIntervalArgs{...}
type TimeIntervalInput interface {
	pulumi.Input

	ToTimeIntervalOutput() TimeIntervalOutput
	ToTimeIntervalOutputWithContext(context.Context) TimeIntervalOutput
}

// A closed time interval. It extends from the start time to the end time, and includes both: [startTime, endTime]. Valid time intervals depend on the MetricKind of the metric value. The end time must not be earlier than the start time. When writing data points, the start time must not be more than 25 hours in the past and the end time must not be more than five minutes in the future. For GAUGE metrics, the startTime value is technically optional; if no value is specified, the start time defaults to the value of the end time, and the interval represents a single point in time. If both start and end times are specified, they must be identical. Such an interval is valid only for GAUGE metrics, which are point-in-time measurements. The end time of a new interval must be at least a millisecond after the end time of the previous interval. For DELTA metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For DELTA metrics, the start time of the next interval must be at least a millisecond after the end time of the previous interval. For CUMULATIVE metrics, the start time and end time must specify a a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points. The new start time must be at least a millisecond after the end time of the previous interval. The start time of a new interval must be at least a millisecond after the end time of the previous interval because intervals are closed. If the start time of a new interval is the same as the end time of the previous interval, then data written at the new start time could overwrite data written at the previous end time.
type TimeIntervalArgs struct {
	// Required. The end of the time interval.
	EndTime pulumi.StringPtrInput `pulumi:"endTime"`
	// Optional. The beginning of the time interval. The default value for the start time is the end time. The start time must not be later than the end time.
	StartTime pulumi.StringPtrInput `pulumi:"startTime"`
}

func (TimeIntervalArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeInterval)(nil)).Elem()
}

func (i TimeIntervalArgs) ToTimeIntervalOutput() TimeIntervalOutput {
	return i.ToTimeIntervalOutputWithContext(context.Background())
}

func (i TimeIntervalArgs) ToTimeIntervalOutputWithContext(ctx context.Context) TimeIntervalOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeIntervalOutput)
}

func (i TimeIntervalArgs) ToTimeIntervalPtrOutput() TimeIntervalPtrOutput {
	return i.ToTimeIntervalPtrOutputWithContext(context.Background())
}

func (i TimeIntervalArgs) ToTimeIntervalPtrOutputWithContext(ctx context.Context) TimeIntervalPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeIntervalOutput).ToTimeIntervalPtrOutputWithContext(ctx)
}

// TimeIntervalPtrInput is an input type that accepts TimeIntervalArgs, TimeIntervalPtr and TimeIntervalPtrOutput values.
// You can construct a concrete instance of `TimeIntervalPtrInput` via:
//
//          TimeIntervalArgs{...}
//
//  or:
//
//          nil
type TimeIntervalPtrInput interface {
	pulumi.Input

	ToTimeIntervalPtrOutput() TimeIntervalPtrOutput
	ToTimeIntervalPtrOutputWithContext(context.Context) TimeIntervalPtrOutput
}

type timeIntervalPtrType TimeIntervalArgs

func TimeIntervalPtr(v *TimeIntervalArgs) TimeIntervalPtrInput {
	return (*timeIntervalPtrType)(v)
}

func (*timeIntervalPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeInterval)(nil)).Elem()
}

func (i *timeIntervalPtrType) ToTimeIntervalPtrOutput() TimeIntervalPtrOutput {
	return i.ToTimeIntervalPtrOutputWithContext(context.Background())
}

func (i *timeIntervalPtrType) ToTimeIntervalPtrOutputWithContext(ctx context.Context) TimeIntervalPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeIntervalPtrOutput)
}

// A closed time interval. It extends from the start time to the end time, and includes both: [startTime, endTime]. Valid time intervals depend on the MetricKind of the metric value. The end time must not be earlier than the start time. When writing data points, the start time must not be more than 25 hours in the past and the end time must not be more than five minutes in the future. For GAUGE metrics, the startTime value is technically optional; if no value is specified, the start time defaults to the value of the end time, and the interval represents a single point in time. If both start and end times are specified, they must be identical. Such an interval is valid only for GAUGE metrics, which are point-in-time measurements. The end time of a new interval must be at least a millisecond after the end time of the previous interval. For DELTA metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For DELTA metrics, the start time of the next interval must be at least a millisecond after the end time of the previous interval. For CUMULATIVE metrics, the start time and end time must specify a a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points. The new start time must be at least a millisecond after the end time of the previous interval. The start time of a new interval must be at least a millisecond after the end time of the previous interval because intervals are closed. If the start time of a new interval is the same as the end time of the previous interval, then data written at the new start time could overwrite data written at the previous end time.
type TimeIntervalOutput struct{ *pulumi.OutputState }

func (TimeIntervalOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeInterval)(nil)).Elem()
}

func (o TimeIntervalOutput) ToTimeIntervalOutput() TimeIntervalOutput {
	return o
}

func (o TimeIntervalOutput) ToTimeIntervalOutputWithContext(ctx context.Context) TimeIntervalOutput {
	return o
}

func (o TimeIntervalOutput) ToTimeIntervalPtrOutput() TimeIntervalPtrOutput {
	return o.ToTimeIntervalPtrOutputWithContext(context.Background())
}

func (o TimeIntervalOutput) ToTimeIntervalPtrOutputWithContext(ctx context.Context) TimeIntervalPtrOutput {
	return o.ApplyT(func(v TimeInterval) *TimeInterval {
		return &v
	}).(TimeIntervalPtrOutput)
}

// Required. The end of the time interval.
func (o TimeIntervalOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeInterval) *string { return v.EndTime }).(pulumi.StringPtrOutput)
}

// Optional. The beginning of the time interval. The default value for the start time is the end time. The start time must not be later than the end time.
func (o TimeIntervalOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeInterval) *string { return v.StartTime }).(pulumi.StringPtrOutput)
}

type TimeIntervalPtrOutput struct{ *pulumi.OutputState }

func (TimeIntervalPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeInterval)(nil)).Elem()
}

func (o TimeIntervalPtrOutput) ToTimeIntervalPtrOutput() TimeIntervalPtrOutput {
	return o
}

func (o TimeIntervalPtrOutput) ToTimeIntervalPtrOutputWithContext(ctx context.Context) TimeIntervalPtrOutput {
	return o
}

func (o TimeIntervalPtrOutput) Elem() TimeIntervalOutput {
	return o.ApplyT(func(v *TimeInterval) TimeInterval { return *v }).(TimeIntervalOutput)
}

// Required. The end of the time interval.
func (o TimeIntervalPtrOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeInterval) *string {
		if v == nil {
			return nil
		}
		return v.EndTime
	}).(pulumi.StringPtrOutput)
}

// Optional. The beginning of the time interval. The default value for the start time is the end time. The start time must not be later than the end time.
func (o TimeIntervalPtrOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeInterval) *string {
		if v == nil {
			return nil
		}
		return v.StartTime
	}).(pulumi.StringPtrOutput)
}

// A collection of data points that describes the time-varying values of a metric. A time series is identified by a combination of a fully-specified monitored resource and a fully-specified metric. This type is used for both listing and creating time series.
type TimeSeriesType struct {
	// The associated monitored resource metadata. When reading a time series, this field will include metadata labels that are explicitly named in the reduction. When creating a time series, this field is ignored.
	Metadata *MonitoredResourceMetadata `pulumi:"metadata"`
	// The associated metric. A fully-specified metric used to identify the time series.
	Metric *Metric `pulumi:"metric"`
	// The metric kind of the time series. When listing time series, this metric kind might be different from the metric kind of the associated metric if this time series is an alignment or reduction of other time series.When creating a time series, this field is optional. If present, it must be the same as the metric kind of the associated metric. If the associated metric's descriptor must be auto-created, then this field specifies the metric kind of the new descriptor and must be either GAUGE (the default) or CUMULATIVE.
	MetricKind *string `pulumi:"metricKind"`
	// The data points of this time series. When listing time series, points are returned in reverse time order.When creating a time series, this field must contain exactly one point and the point's type must be the same as the value type of the associated metric. If the associated metric's descriptor must be auto-created, then the value type of the descriptor is determined by the point's type, which must be BOOL, INT64, DOUBLE, or DISTRIBUTION.
	Points []Point `pulumi:"points"`
	// The associated monitored resource. Custom metrics can use only certain monitored resource types in their time series data. For more information, see Monitored resources for custom metrics (https://cloud.google.com/monitoring/custom-metrics/creating-metrics#custom-metric-resources).
	Resource *MonitoredResource `pulumi:"resource"`
	// The units in which the metric value is reported. It is only applicable if the value_type is INT64, DOUBLE, or DISTRIBUTION. The unit defines the representation of the stored metric values.
	Unit *string `pulumi:"unit"`
	// The value type of the time series. When listing time series, this value type might be different from the value type of the associated metric if this time series is an alignment or reduction of other time series.When creating a time series, this field is optional. If present, it must be the same as the type of the data in the points field.
	ValueType *string `pulumi:"valueType"`
}

// TimeSeriesTypeInput is an input type that accepts TimeSeriesTypeArgs and TimeSeriesTypeOutput values.
// You can construct a concrete instance of `TimeSeriesTypeInput` via:
//
//          TimeSeriesTypeArgs{...}
type TimeSeriesTypeInput interface {
	pulumi.Input

	ToTimeSeriesTypeOutput() TimeSeriesTypeOutput
	ToTimeSeriesTypeOutputWithContext(context.Context) TimeSeriesTypeOutput
}

// A collection of data points that describes the time-varying values of a metric. A time series is identified by a combination of a fully-specified monitored resource and a fully-specified metric. This type is used for both listing and creating time series.
type TimeSeriesTypeArgs struct {
	// The associated monitored resource metadata. When reading a time series, this field will include metadata labels that are explicitly named in the reduction. When creating a time series, this field is ignored.
	Metadata MonitoredResourceMetadataPtrInput `pulumi:"metadata"`
	// The associated metric. A fully-specified metric used to identify the time series.
	Metric MetricPtrInput `pulumi:"metric"`
	// The metric kind of the time series. When listing time series, this metric kind might be different from the metric kind of the associated metric if this time series is an alignment or reduction of other time series.When creating a time series, this field is optional. If present, it must be the same as the metric kind of the associated metric. If the associated metric's descriptor must be auto-created, then this field specifies the metric kind of the new descriptor and must be either GAUGE (the default) or CUMULATIVE.
	MetricKind pulumi.StringPtrInput `pulumi:"metricKind"`
	// The data points of this time series. When listing time series, points are returned in reverse time order.When creating a time series, this field must contain exactly one point and the point's type must be the same as the value type of the associated metric. If the associated metric's descriptor must be auto-created, then the value type of the descriptor is determined by the point's type, which must be BOOL, INT64, DOUBLE, or DISTRIBUTION.
	Points PointArrayInput `pulumi:"points"`
	// The associated monitored resource. Custom metrics can use only certain monitored resource types in their time series data. For more information, see Monitored resources for custom metrics (https://cloud.google.com/monitoring/custom-metrics/creating-metrics#custom-metric-resources).
	Resource MonitoredResourcePtrInput `pulumi:"resource"`
	// The units in which the metric value is reported. It is only applicable if the value_type is INT64, DOUBLE, or DISTRIBUTION. The unit defines the representation of the stored metric values.
	Unit pulumi.StringPtrInput `pulumi:"unit"`
	// The value type of the time series. When listing time series, this value type might be different from the value type of the associated metric if this time series is an alignment or reduction of other time series.When creating a time series, this field is optional. If present, it must be the same as the type of the data in the points field.
	ValueType pulumi.StringPtrInput `pulumi:"valueType"`
}

func (TimeSeriesTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesType)(nil)).Elem()
}

func (i TimeSeriesTypeArgs) ToTimeSeriesTypeOutput() TimeSeriesTypeOutput {
	return i.ToTimeSeriesTypeOutputWithContext(context.Background())
}

func (i TimeSeriesTypeArgs) ToTimeSeriesTypeOutputWithContext(ctx context.Context) TimeSeriesTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesTypeOutput)
}

// TimeSeriesTypeArrayInput is an input type that accepts TimeSeriesTypeArray and TimeSeriesTypeArrayOutput values.
// You can construct a concrete instance of `TimeSeriesTypeArrayInput` via:
//
//          TimeSeriesTypeArray{ TimeSeriesTypeArgs{...} }
type TimeSeriesTypeArrayInput interface {
	pulumi.Input

	ToTimeSeriesTypeArrayOutput() TimeSeriesTypeArrayOutput
	ToTimeSeriesTypeArrayOutputWithContext(context.Context) TimeSeriesTypeArrayOutput
}

type TimeSeriesTypeArray []TimeSeriesTypeInput

func (TimeSeriesTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TimeSeriesType)(nil)).Elem()
}

func (i TimeSeriesTypeArray) ToTimeSeriesTypeArrayOutput() TimeSeriesTypeArrayOutput {
	return i.ToTimeSeriesTypeArrayOutputWithContext(context.Background())
}

func (i TimeSeriesTypeArray) ToTimeSeriesTypeArrayOutputWithContext(ctx context.Context) TimeSeriesTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesTypeArrayOutput)
}

// A collection of data points that describes the time-varying values of a metric. A time series is identified by a combination of a fully-specified monitored resource and a fully-specified metric. This type is used for both listing and creating time series.
type TimeSeriesTypeOutput struct{ *pulumi.OutputState }

func (TimeSeriesTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesType)(nil)).Elem()
}

func (o TimeSeriesTypeOutput) ToTimeSeriesTypeOutput() TimeSeriesTypeOutput {
	return o
}

func (o TimeSeriesTypeOutput) ToTimeSeriesTypeOutputWithContext(ctx context.Context) TimeSeriesTypeOutput {
	return o
}

// The associated monitored resource metadata. When reading a time series, this field will include metadata labels that are explicitly named in the reduction. When creating a time series, this field is ignored.
func (o TimeSeriesTypeOutput) Metadata() MonitoredResourceMetadataPtrOutput {
	return o.ApplyT(func(v TimeSeriesType) *MonitoredResourceMetadata { return v.Metadata }).(MonitoredResourceMetadataPtrOutput)
}

// The associated metric. A fully-specified metric used to identify the time series.
func (o TimeSeriesTypeOutput) Metric() MetricPtrOutput {
	return o.ApplyT(func(v TimeSeriesType) *Metric { return v.Metric }).(MetricPtrOutput)
}

// The metric kind of the time series. When listing time series, this metric kind might be different from the metric kind of the associated metric if this time series is an alignment or reduction of other time series.When creating a time series, this field is optional. If present, it must be the same as the metric kind of the associated metric. If the associated metric's descriptor must be auto-created, then this field specifies the metric kind of the new descriptor and must be either GAUGE (the default) or CUMULATIVE.
func (o TimeSeriesTypeOutput) MetricKind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesType) *string { return v.MetricKind }).(pulumi.StringPtrOutput)
}

// The data points of this time series. When listing time series, points are returned in reverse time order.When creating a time series, this field must contain exactly one point and the point's type must be the same as the value type of the associated metric. If the associated metric's descriptor must be auto-created, then the value type of the descriptor is determined by the point's type, which must be BOOL, INT64, DOUBLE, or DISTRIBUTION.
func (o TimeSeriesTypeOutput) Points() PointArrayOutput {
	return o.ApplyT(func(v TimeSeriesType) []Point { return v.Points }).(PointArrayOutput)
}

// The associated monitored resource. Custom metrics can use only certain monitored resource types in their time series data. For more information, see Monitored resources for custom metrics (https://cloud.google.com/monitoring/custom-metrics/creating-metrics#custom-metric-resources).
func (o TimeSeriesTypeOutput) Resource() MonitoredResourcePtrOutput {
	return o.ApplyT(func(v TimeSeriesType) *MonitoredResource { return v.Resource }).(MonitoredResourcePtrOutput)
}

// The units in which the metric value is reported. It is only applicable if the value_type is INT64, DOUBLE, or DISTRIBUTION. The unit defines the representation of the stored metric values.
func (o TimeSeriesTypeOutput) Unit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesType) *string { return v.Unit }).(pulumi.StringPtrOutput)
}

// The value type of the time series. When listing time series, this value type might be different from the value type of the associated metric if this time series is an alignment or reduction of other time series.When creating a time series, this field is optional. If present, it must be the same as the type of the data in the points field.
func (o TimeSeriesTypeOutput) ValueType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesType) *string { return v.ValueType }).(pulumi.StringPtrOutput)
}

type TimeSeriesTypeArrayOutput struct{ *pulumi.OutputState }

func (TimeSeriesTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TimeSeriesType)(nil)).Elem()
}

func (o TimeSeriesTypeArrayOutput) ToTimeSeriesTypeArrayOutput() TimeSeriesTypeArrayOutput {
	return o
}

func (o TimeSeriesTypeArrayOutput) ToTimeSeriesTypeArrayOutputWithContext(ctx context.Context) TimeSeriesTypeArrayOutput {
	return o
}

func (o TimeSeriesTypeArrayOutput) Index(i pulumi.IntInput) TimeSeriesTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TimeSeriesType {
		return vs[0].([]TimeSeriesType)[vs[1].(int)]
	}).(TimeSeriesTypeOutput)
}

// A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.
type TimeSeriesRatio struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	BadServiceFilter *string `pulumi:"badServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	GoodServiceFilter *string `pulumi:"goodServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	TotalServiceFilter *string `pulumi:"totalServiceFilter"`
}

// TimeSeriesRatioInput is an input type that accepts TimeSeriesRatioArgs and TimeSeriesRatioOutput values.
// You can construct a concrete instance of `TimeSeriesRatioInput` via:
//
//          TimeSeriesRatioArgs{...}
type TimeSeriesRatioInput interface {
	pulumi.Input

	ToTimeSeriesRatioOutput() TimeSeriesRatioOutput
	ToTimeSeriesRatioOutputWithContext(context.Context) TimeSeriesRatioOutput
}

// A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.
type TimeSeriesRatioArgs struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	BadServiceFilter pulumi.StringPtrInput `pulumi:"badServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	GoodServiceFilter pulumi.StringPtrInput `pulumi:"goodServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	TotalServiceFilter pulumi.StringPtrInput `pulumi:"totalServiceFilter"`
}

func (TimeSeriesRatioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesRatio)(nil)).Elem()
}

func (i TimeSeriesRatioArgs) ToTimeSeriesRatioOutput() TimeSeriesRatioOutput {
	return i.ToTimeSeriesRatioOutputWithContext(context.Background())
}

func (i TimeSeriesRatioArgs) ToTimeSeriesRatioOutputWithContext(ctx context.Context) TimeSeriesRatioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesRatioOutput)
}

func (i TimeSeriesRatioArgs) ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput {
	return i.ToTimeSeriesRatioPtrOutputWithContext(context.Background())
}

func (i TimeSeriesRatioArgs) ToTimeSeriesRatioPtrOutputWithContext(ctx context.Context) TimeSeriesRatioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesRatioOutput).ToTimeSeriesRatioPtrOutputWithContext(ctx)
}

// TimeSeriesRatioPtrInput is an input type that accepts TimeSeriesRatioArgs, TimeSeriesRatioPtr and TimeSeriesRatioPtrOutput values.
// You can construct a concrete instance of `TimeSeriesRatioPtrInput` via:
//
//          TimeSeriesRatioArgs{...}
//
//  or:
//
//          nil
type TimeSeriesRatioPtrInput interface {
	pulumi.Input

	ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput
	ToTimeSeriesRatioPtrOutputWithContext(context.Context) TimeSeriesRatioPtrOutput
}

type timeSeriesRatioPtrType TimeSeriesRatioArgs

func TimeSeriesRatioPtr(v *TimeSeriesRatioArgs) TimeSeriesRatioPtrInput {
	return (*timeSeriesRatioPtrType)(v)
}

func (*timeSeriesRatioPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesRatio)(nil)).Elem()
}

func (i *timeSeriesRatioPtrType) ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput {
	return i.ToTimeSeriesRatioPtrOutputWithContext(context.Background())
}

func (i *timeSeriesRatioPtrType) ToTimeSeriesRatioPtrOutputWithContext(ctx context.Context) TimeSeriesRatioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesRatioPtrOutput)
}

// A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.
type TimeSeriesRatioOutput struct{ *pulumi.OutputState }

func (TimeSeriesRatioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesRatio)(nil)).Elem()
}

func (o TimeSeriesRatioOutput) ToTimeSeriesRatioOutput() TimeSeriesRatioOutput {
	return o
}

func (o TimeSeriesRatioOutput) ToTimeSeriesRatioOutputWithContext(ctx context.Context) TimeSeriesRatioOutput {
	return o
}

func (o TimeSeriesRatioOutput) ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput {
	return o.ToTimeSeriesRatioPtrOutputWithContext(context.Background())
}

func (o TimeSeriesRatioOutput) ToTimeSeriesRatioPtrOutputWithContext(ctx context.Context) TimeSeriesRatioPtrOutput {
	return o.ApplyT(func(v TimeSeriesRatio) *TimeSeriesRatio {
		return &v
	}).(TimeSeriesRatioPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioOutput) BadServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesRatio) *string { return v.BadServiceFilter }).(pulumi.StringPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioOutput) GoodServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesRatio) *string { return v.GoodServiceFilter }).(pulumi.StringPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioOutput) TotalServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesRatio) *string { return v.TotalServiceFilter }).(pulumi.StringPtrOutput)
}

type TimeSeriesRatioPtrOutput struct{ *pulumi.OutputState }

func (TimeSeriesRatioPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesRatio)(nil)).Elem()
}

func (o TimeSeriesRatioPtrOutput) ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput {
	return o
}

func (o TimeSeriesRatioPtrOutput) ToTimeSeriesRatioPtrOutputWithContext(ctx context.Context) TimeSeriesRatioPtrOutput {
	return o
}

func (o TimeSeriesRatioPtrOutput) Elem() TimeSeriesRatioOutput {
	return o.ApplyT(func(v *TimeSeriesRatio) TimeSeriesRatio { return *v }).(TimeSeriesRatioOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioPtrOutput) BadServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesRatio) *string {
		if v == nil {
			return nil
		}
		return v.BadServiceFilter
	}).(pulumi.StringPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioPtrOutput) GoodServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesRatio) *string {
		if v == nil {
			return nil
		}
		return v.GoodServiceFilter
	}).(pulumi.StringPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioPtrOutput) TotalServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesRatio) *string {
		if v == nil {
			return nil
		}
		return v.TotalServiceFilter
	}).(pulumi.StringPtrOutput)
}

// A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.
type TimeSeriesRatioResponse struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	BadServiceFilter string `pulumi:"badServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	GoodServiceFilter string `pulumi:"goodServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	TotalServiceFilter string `pulumi:"totalServiceFilter"`
}

// TimeSeriesRatioResponseInput is an input type that accepts TimeSeriesRatioResponseArgs and TimeSeriesRatioResponseOutput values.
// You can construct a concrete instance of `TimeSeriesRatioResponseInput` via:
//
//          TimeSeriesRatioResponseArgs{...}
type TimeSeriesRatioResponseInput interface {
	pulumi.Input

	ToTimeSeriesRatioResponseOutput() TimeSeriesRatioResponseOutput
	ToTimeSeriesRatioResponseOutputWithContext(context.Context) TimeSeriesRatioResponseOutput
}

// A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.
type TimeSeriesRatioResponseArgs struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	BadServiceFilter pulumi.StringInput `pulumi:"badServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	GoodServiceFilter pulumi.StringInput `pulumi:"goodServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	TotalServiceFilter pulumi.StringInput `pulumi:"totalServiceFilter"`
}

func (TimeSeriesRatioResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesRatioResponse)(nil)).Elem()
}

func (i TimeSeriesRatioResponseArgs) ToTimeSeriesRatioResponseOutput() TimeSeriesRatioResponseOutput {
	return i.ToTimeSeriesRatioResponseOutputWithContext(context.Background())
}

func (i TimeSeriesRatioResponseArgs) ToTimeSeriesRatioResponseOutputWithContext(ctx context.Context) TimeSeriesRatioResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesRatioResponseOutput)
}

func (i TimeSeriesRatioResponseArgs) ToTimeSeriesRatioResponsePtrOutput() TimeSeriesRatioResponsePtrOutput {
	return i.ToTimeSeriesRatioResponsePtrOutputWithContext(context.Background())
}

func (i TimeSeriesRatioResponseArgs) ToTimeSeriesRatioResponsePtrOutputWithContext(ctx context.Context) TimeSeriesRatioResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesRatioResponseOutput).ToTimeSeriesRatioResponsePtrOutputWithContext(ctx)
}

// TimeSeriesRatioResponsePtrInput is an input type that accepts TimeSeriesRatioResponseArgs, TimeSeriesRatioResponsePtr and TimeSeriesRatioResponsePtrOutput values.
// You can construct a concrete instance of `TimeSeriesRatioResponsePtrInput` via:
//
//          TimeSeriesRatioResponseArgs{...}
//
//  or:
//
//          nil
type TimeSeriesRatioResponsePtrInput interface {
	pulumi.Input

	ToTimeSeriesRatioResponsePtrOutput() TimeSeriesRatioResponsePtrOutput
	ToTimeSeriesRatioResponsePtrOutputWithContext(context.Context) TimeSeriesRatioResponsePtrOutput
}

type timeSeriesRatioResponsePtrType TimeSeriesRatioResponseArgs

func TimeSeriesRatioResponsePtr(v *TimeSeriesRatioResponseArgs) TimeSeriesRatioResponsePtrInput {
	return (*timeSeriesRatioResponsePtrType)(v)
}

func (*timeSeriesRatioResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesRatioResponse)(nil)).Elem()
}

func (i *timeSeriesRatioResponsePtrType) ToTimeSeriesRatioResponsePtrOutput() TimeSeriesRatioResponsePtrOutput {
	return i.ToTimeSeriesRatioResponsePtrOutputWithContext(context.Background())
}

func (i *timeSeriesRatioResponsePtrType) ToTimeSeriesRatioResponsePtrOutputWithContext(ctx context.Context) TimeSeriesRatioResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesRatioResponsePtrOutput)
}

// A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.
type TimeSeriesRatioResponseOutput struct{ *pulumi.OutputState }

func (TimeSeriesRatioResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesRatioResponse)(nil)).Elem()
}

func (o TimeSeriesRatioResponseOutput) ToTimeSeriesRatioResponseOutput() TimeSeriesRatioResponseOutput {
	return o
}

func (o TimeSeriesRatioResponseOutput) ToTimeSeriesRatioResponseOutputWithContext(ctx context.Context) TimeSeriesRatioResponseOutput {
	return o
}

func (o TimeSeriesRatioResponseOutput) ToTimeSeriesRatioResponsePtrOutput() TimeSeriesRatioResponsePtrOutput {
	return o.ToTimeSeriesRatioResponsePtrOutputWithContext(context.Background())
}

func (o TimeSeriesRatioResponseOutput) ToTimeSeriesRatioResponsePtrOutputWithContext(ctx context.Context) TimeSeriesRatioResponsePtrOutput {
	return o.ApplyT(func(v TimeSeriesRatioResponse) *TimeSeriesRatioResponse {
		return &v
	}).(TimeSeriesRatioResponsePtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioResponseOutput) BadServiceFilter() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesRatioResponse) string { return v.BadServiceFilter }).(pulumi.StringOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioResponseOutput) GoodServiceFilter() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesRatioResponse) string { return v.GoodServiceFilter }).(pulumi.StringOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioResponseOutput) TotalServiceFilter() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesRatioResponse) string { return v.TotalServiceFilter }).(pulumi.StringOutput)
}

type TimeSeriesRatioResponsePtrOutput struct{ *pulumi.OutputState }

func (TimeSeriesRatioResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesRatioResponse)(nil)).Elem()
}

func (o TimeSeriesRatioResponsePtrOutput) ToTimeSeriesRatioResponsePtrOutput() TimeSeriesRatioResponsePtrOutput {
	return o
}

func (o TimeSeriesRatioResponsePtrOutput) ToTimeSeriesRatioResponsePtrOutputWithContext(ctx context.Context) TimeSeriesRatioResponsePtrOutput {
	return o
}

func (o TimeSeriesRatioResponsePtrOutput) Elem() TimeSeriesRatioResponseOutput {
	return o.ApplyT(func(v *TimeSeriesRatioResponse) TimeSeriesRatioResponse { return *v }).(TimeSeriesRatioResponseOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioResponsePtrOutput) BadServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesRatioResponse) *string {
		if v == nil {
			return nil
		}
		return &v.BadServiceFilter
	}).(pulumi.StringPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioResponsePtrOutput) GoodServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesRatioResponse) *string {
		if v == nil {
			return nil
		}
		return &v.GoodServiceFilter
	}).(pulumi.StringPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioResponsePtrOutput) TotalServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesRatioResponse) *string {
		if v == nil {
			return nil
		}
		return &v.TotalServiceFilter
	}).(pulumi.StringPtrOutput)
}

// Specifies how many time series must fail a predicate to trigger a condition. If not specified, then a {count: 1} trigger is used.
type Trigger struct {
	// The absolute number of time series that must fail the predicate for the condition to be triggered.
	Count *int `pulumi:"count"`
	// The percentage of time series that must fail the predicate for the condition to be triggered.
	Percent *float64 `pulumi:"percent"`
}

// TriggerInput is an input type that accepts TriggerArgs and TriggerOutput values.
// You can construct a concrete instance of `TriggerInput` via:
//
//          TriggerArgs{...}
type TriggerInput interface {
	pulumi.Input

	ToTriggerOutput() TriggerOutput
	ToTriggerOutputWithContext(context.Context) TriggerOutput
}

// Specifies how many time series must fail a predicate to trigger a condition. If not specified, then a {count: 1} trigger is used.
type TriggerArgs struct {
	// The absolute number of time series that must fail the predicate for the condition to be triggered.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// The percentage of time series that must fail the predicate for the condition to be triggered.
	Percent pulumi.Float64PtrInput `pulumi:"percent"`
}

func (TriggerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Trigger)(nil)).Elem()
}

func (i TriggerArgs) ToTriggerOutput() TriggerOutput {
	return i.ToTriggerOutputWithContext(context.Background())
}

func (i TriggerArgs) ToTriggerOutputWithContext(ctx context.Context) TriggerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TriggerOutput)
}

func (i TriggerArgs) ToTriggerPtrOutput() TriggerPtrOutput {
	return i.ToTriggerPtrOutputWithContext(context.Background())
}

func (i TriggerArgs) ToTriggerPtrOutputWithContext(ctx context.Context) TriggerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TriggerOutput).ToTriggerPtrOutputWithContext(ctx)
}

// TriggerPtrInput is an input type that accepts TriggerArgs, TriggerPtr and TriggerPtrOutput values.
// You can construct a concrete instance of `TriggerPtrInput` via:
//
//          TriggerArgs{...}
//
//  or:
//
//          nil
type TriggerPtrInput interface {
	pulumi.Input

	ToTriggerPtrOutput() TriggerPtrOutput
	ToTriggerPtrOutputWithContext(context.Context) TriggerPtrOutput
}

type triggerPtrType TriggerArgs

func TriggerPtr(v *TriggerArgs) TriggerPtrInput {
	return (*triggerPtrType)(v)
}

func (*triggerPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Trigger)(nil)).Elem()
}

func (i *triggerPtrType) ToTriggerPtrOutput() TriggerPtrOutput {
	return i.ToTriggerPtrOutputWithContext(context.Background())
}

func (i *triggerPtrType) ToTriggerPtrOutputWithContext(ctx context.Context) TriggerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TriggerPtrOutput)
}

// Specifies how many time series must fail a predicate to trigger a condition. If not specified, then a {count: 1} trigger is used.
type TriggerOutput struct{ *pulumi.OutputState }

func (TriggerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Trigger)(nil)).Elem()
}

func (o TriggerOutput) ToTriggerOutput() TriggerOutput {
	return o
}

func (o TriggerOutput) ToTriggerOutputWithContext(ctx context.Context) TriggerOutput {
	return o
}

func (o TriggerOutput) ToTriggerPtrOutput() TriggerPtrOutput {
	return o.ToTriggerPtrOutputWithContext(context.Background())
}

func (o TriggerOutput) ToTriggerPtrOutputWithContext(ctx context.Context) TriggerPtrOutput {
	return o.ApplyT(func(v Trigger) *Trigger {
		return &v
	}).(TriggerPtrOutput)
}

// The absolute number of time series that must fail the predicate for the condition to be triggered.
func (o TriggerOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Trigger) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// The percentage of time series that must fail the predicate for the condition to be triggered.
func (o TriggerOutput) Percent() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Trigger) *float64 { return v.Percent }).(pulumi.Float64PtrOutput)
}

type TriggerPtrOutput struct{ *pulumi.OutputState }

func (TriggerPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Trigger)(nil)).Elem()
}

func (o TriggerPtrOutput) ToTriggerPtrOutput() TriggerPtrOutput {
	return o
}

func (o TriggerPtrOutput) ToTriggerPtrOutputWithContext(ctx context.Context) TriggerPtrOutput {
	return o
}

func (o TriggerPtrOutput) Elem() TriggerOutput {
	return o.ApplyT(func(v *Trigger) Trigger { return *v }).(TriggerOutput)
}

// The absolute number of time series that must fail the predicate for the condition to be triggered.
func (o TriggerPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Trigger) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

// The percentage of time series that must fail the predicate for the condition to be triggered.
func (o TriggerPtrOutput) Percent() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Trigger) *float64 {
		if v == nil {
			return nil
		}
		return v.Percent
	}).(pulumi.Float64PtrOutput)
}

// Specifies how many time series must fail a predicate to trigger a condition. If not specified, then a {count: 1} trigger is used.
type TriggerResponse struct {
	// The absolute number of time series that must fail the predicate for the condition to be triggered.
	Count int `pulumi:"count"`
	// The percentage of time series that must fail the predicate for the condition to be triggered.
	Percent float64 `pulumi:"percent"`
}

// TriggerResponseInput is an input type that accepts TriggerResponseArgs and TriggerResponseOutput values.
// You can construct a concrete instance of `TriggerResponseInput` via:
//
//          TriggerResponseArgs{...}
type TriggerResponseInput interface {
	pulumi.Input

	ToTriggerResponseOutput() TriggerResponseOutput
	ToTriggerResponseOutputWithContext(context.Context) TriggerResponseOutput
}

// Specifies how many time series must fail a predicate to trigger a condition. If not specified, then a {count: 1} trigger is used.
type TriggerResponseArgs struct {
	// The absolute number of time series that must fail the predicate for the condition to be triggered.
	Count pulumi.IntInput `pulumi:"count"`
	// The percentage of time series that must fail the predicate for the condition to be triggered.
	Percent pulumi.Float64Input `pulumi:"percent"`
}

func (TriggerResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TriggerResponse)(nil)).Elem()
}

func (i TriggerResponseArgs) ToTriggerResponseOutput() TriggerResponseOutput {
	return i.ToTriggerResponseOutputWithContext(context.Background())
}

func (i TriggerResponseArgs) ToTriggerResponseOutputWithContext(ctx context.Context) TriggerResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TriggerResponseOutput)
}

// Specifies how many time series must fail a predicate to trigger a condition. If not specified, then a {count: 1} trigger is used.
type TriggerResponseOutput struct{ *pulumi.OutputState }

func (TriggerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TriggerResponse)(nil)).Elem()
}

func (o TriggerResponseOutput) ToTriggerResponseOutput() TriggerResponseOutput {
	return o
}

func (o TriggerResponseOutput) ToTriggerResponseOutputWithContext(ctx context.Context) TriggerResponseOutput {
	return o
}

// The absolute number of time series that must fail the predicate for the condition to be triggered.
func (o TriggerResponseOutput) Count() pulumi.IntOutput {
	return o.ApplyT(func(v TriggerResponse) int { return v.Count }).(pulumi.IntOutput)
}

// The percentage of time series that must fail the predicate for the condition to be triggered.
func (o TriggerResponseOutput) Percent() pulumi.Float64Output {
	return o.ApplyT(func(v TriggerResponse) float64 { return v.Percent }).(pulumi.Float64Output)
}

// A single strongly-typed value.
type TypedValue struct {
	// A Boolean value: true or false.
	BoolValue *bool `pulumi:"boolValue"`
	// A distribution value.
	DistributionValue *Distribution `pulumi:"distributionValue"`
	// A 64-bit double-precision floating-point number. Its magnitude is approximately ±10±300 and it has 16 significant digits of precision.
	DoubleValue *float64 `pulumi:"doubleValue"`
	// A 64-bit integer. Its range is approximately ±9.2x1018.
	Int64Value *string `pulumi:"int64Value"`
	// A variable-length string value.
	StringValue *string `pulumi:"stringValue"`
}

// TypedValueInput is an input type that accepts TypedValueArgs and TypedValueOutput values.
// You can construct a concrete instance of `TypedValueInput` via:
//
//          TypedValueArgs{...}
type TypedValueInput interface {
	pulumi.Input

	ToTypedValueOutput() TypedValueOutput
	ToTypedValueOutputWithContext(context.Context) TypedValueOutput
}

// A single strongly-typed value.
type TypedValueArgs struct {
	// A Boolean value: true or false.
	BoolValue pulumi.BoolPtrInput `pulumi:"boolValue"`
	// A distribution value.
	DistributionValue DistributionPtrInput `pulumi:"distributionValue"`
	// A 64-bit double-precision floating-point number. Its magnitude is approximately ±10±300 and it has 16 significant digits of precision.
	DoubleValue pulumi.Float64PtrInput `pulumi:"doubleValue"`
	// A 64-bit integer. Its range is approximately ±9.2x1018.
	Int64Value pulumi.StringPtrInput `pulumi:"int64Value"`
	// A variable-length string value.
	StringValue pulumi.StringPtrInput `pulumi:"stringValue"`
}

func (TypedValueArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TypedValue)(nil)).Elem()
}

func (i TypedValueArgs) ToTypedValueOutput() TypedValueOutput {
	return i.ToTypedValueOutputWithContext(context.Background())
}

func (i TypedValueArgs) ToTypedValueOutputWithContext(ctx context.Context) TypedValueOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TypedValueOutput)
}

func (i TypedValueArgs) ToTypedValuePtrOutput() TypedValuePtrOutput {
	return i.ToTypedValuePtrOutputWithContext(context.Background())
}

func (i TypedValueArgs) ToTypedValuePtrOutputWithContext(ctx context.Context) TypedValuePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TypedValueOutput).ToTypedValuePtrOutputWithContext(ctx)
}

// TypedValuePtrInput is an input type that accepts TypedValueArgs, TypedValuePtr and TypedValuePtrOutput values.
// You can construct a concrete instance of `TypedValuePtrInput` via:
//
//          TypedValueArgs{...}
//
//  or:
//
//          nil
type TypedValuePtrInput interface {
	pulumi.Input

	ToTypedValuePtrOutput() TypedValuePtrOutput
	ToTypedValuePtrOutputWithContext(context.Context) TypedValuePtrOutput
}

type typedValuePtrType TypedValueArgs

func TypedValuePtr(v *TypedValueArgs) TypedValuePtrInput {
	return (*typedValuePtrType)(v)
}

func (*typedValuePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TypedValue)(nil)).Elem()
}

func (i *typedValuePtrType) ToTypedValuePtrOutput() TypedValuePtrOutput {
	return i.ToTypedValuePtrOutputWithContext(context.Background())
}

func (i *typedValuePtrType) ToTypedValuePtrOutputWithContext(ctx context.Context) TypedValuePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TypedValuePtrOutput)
}

// A single strongly-typed value.
type TypedValueOutput struct{ *pulumi.OutputState }

func (TypedValueOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TypedValue)(nil)).Elem()
}

func (o TypedValueOutput) ToTypedValueOutput() TypedValueOutput {
	return o
}

func (o TypedValueOutput) ToTypedValueOutputWithContext(ctx context.Context) TypedValueOutput {
	return o
}

func (o TypedValueOutput) ToTypedValuePtrOutput() TypedValuePtrOutput {
	return o.ToTypedValuePtrOutputWithContext(context.Background())
}

func (o TypedValueOutput) ToTypedValuePtrOutputWithContext(ctx context.Context) TypedValuePtrOutput {
	return o.ApplyT(func(v TypedValue) *TypedValue {
		return &v
	}).(TypedValuePtrOutput)
}

// A Boolean value: true or false.
func (o TypedValueOutput) BoolValue() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v TypedValue) *bool { return v.BoolValue }).(pulumi.BoolPtrOutput)
}

// A distribution value.
func (o TypedValueOutput) DistributionValue() DistributionPtrOutput {
	return o.ApplyT(func(v TypedValue) *Distribution { return v.DistributionValue }).(DistributionPtrOutput)
}

// A 64-bit double-precision floating-point number. Its magnitude is approximately ±10±300 and it has 16 significant digits of precision.
func (o TypedValueOutput) DoubleValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v TypedValue) *float64 { return v.DoubleValue }).(pulumi.Float64PtrOutput)
}

// A 64-bit integer. Its range is approximately ±9.2x1018.
func (o TypedValueOutput) Int64Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TypedValue) *string { return v.Int64Value }).(pulumi.StringPtrOutput)
}

// A variable-length string value.
func (o TypedValueOutput) StringValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TypedValue) *string { return v.StringValue }).(pulumi.StringPtrOutput)
}

type TypedValuePtrOutput struct{ *pulumi.OutputState }

func (TypedValuePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TypedValue)(nil)).Elem()
}

func (o TypedValuePtrOutput) ToTypedValuePtrOutput() TypedValuePtrOutput {
	return o
}

func (o TypedValuePtrOutput) ToTypedValuePtrOutputWithContext(ctx context.Context) TypedValuePtrOutput {
	return o
}

func (o TypedValuePtrOutput) Elem() TypedValueOutput {
	return o.ApplyT(func(v *TypedValue) TypedValue { return *v }).(TypedValueOutput)
}

// A Boolean value: true or false.
func (o TypedValuePtrOutput) BoolValue() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *TypedValue) *bool {
		if v == nil {
			return nil
		}
		return v.BoolValue
	}).(pulumi.BoolPtrOutput)
}

// A distribution value.
func (o TypedValuePtrOutput) DistributionValue() DistributionPtrOutput {
	return o.ApplyT(func(v *TypedValue) *Distribution {
		if v == nil {
			return nil
		}
		return v.DistributionValue
	}).(DistributionPtrOutput)
}

// A 64-bit double-precision floating-point number. Its magnitude is approximately ±10±300 and it has 16 significant digits of precision.
func (o TypedValuePtrOutput) DoubleValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *TypedValue) *float64 {
		if v == nil {
			return nil
		}
		return v.DoubleValue
	}).(pulumi.Float64PtrOutput)
}

// A 64-bit integer. Its range is approximately ±9.2x1018.
func (o TypedValuePtrOutput) Int64Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TypedValue) *string {
		if v == nil {
			return nil
		}
		return v.Int64Value
	}).(pulumi.StringPtrOutput)
}

// A variable-length string value.
func (o TypedValuePtrOutput) StringValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TypedValue) *string {
		if v == nil {
			return nil
		}
		return v.StringValue
	}).(pulumi.StringPtrOutput)
}

// A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.
type WindowsBasedSli struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
	GoodBadMetricFilter *string `pulumi:"goodBadMetricFilter"`
	// A window is good if its performance is high enough.
	GoodTotalRatioThreshold *PerformanceThreshold `pulumi:"goodTotalRatioThreshold"`
	// A window is good if the metric's value is in a good range, averaged across returned streams.
	MetricMeanInRange *MetricRange `pulumi:"metricMeanInRange"`
	// A window is good if the metric's value is in a good range, summed across returned streams.
	MetricSumInRange *MetricRange `pulumi:"metricSumInRange"`
	// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
	WindowPeriod *string `pulumi:"windowPeriod"`
}

// WindowsBasedSliInput is an input type that accepts WindowsBasedSliArgs and WindowsBasedSliOutput values.
// You can construct a concrete instance of `WindowsBasedSliInput` via:
//
//          WindowsBasedSliArgs{...}
type WindowsBasedSliInput interface {
	pulumi.Input

	ToWindowsBasedSliOutput() WindowsBasedSliOutput
	ToWindowsBasedSliOutputWithContext(context.Context) WindowsBasedSliOutput
}

// A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.
type WindowsBasedSliArgs struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
	GoodBadMetricFilter pulumi.StringPtrInput `pulumi:"goodBadMetricFilter"`
	// A window is good if its performance is high enough.
	GoodTotalRatioThreshold PerformanceThresholdPtrInput `pulumi:"goodTotalRatioThreshold"`
	// A window is good if the metric's value is in a good range, averaged across returned streams.
	MetricMeanInRange MetricRangePtrInput `pulumi:"metricMeanInRange"`
	// A window is good if the metric's value is in a good range, summed across returned streams.
	MetricSumInRange MetricRangePtrInput `pulumi:"metricSumInRange"`
	// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
	WindowPeriod pulumi.StringPtrInput `pulumi:"windowPeriod"`
}

func (WindowsBasedSliArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsBasedSli)(nil)).Elem()
}

func (i WindowsBasedSliArgs) ToWindowsBasedSliOutput() WindowsBasedSliOutput {
	return i.ToWindowsBasedSliOutputWithContext(context.Background())
}

func (i WindowsBasedSliArgs) ToWindowsBasedSliOutputWithContext(ctx context.Context) WindowsBasedSliOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsBasedSliOutput)
}

func (i WindowsBasedSliArgs) ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput {
	return i.ToWindowsBasedSliPtrOutputWithContext(context.Background())
}

func (i WindowsBasedSliArgs) ToWindowsBasedSliPtrOutputWithContext(ctx context.Context) WindowsBasedSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsBasedSliOutput).ToWindowsBasedSliPtrOutputWithContext(ctx)
}

// WindowsBasedSliPtrInput is an input type that accepts WindowsBasedSliArgs, WindowsBasedSliPtr and WindowsBasedSliPtrOutput values.
// You can construct a concrete instance of `WindowsBasedSliPtrInput` via:
//
//          WindowsBasedSliArgs{...}
//
//  or:
//
//          nil
type WindowsBasedSliPtrInput interface {
	pulumi.Input

	ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput
	ToWindowsBasedSliPtrOutputWithContext(context.Context) WindowsBasedSliPtrOutput
}

type windowsBasedSliPtrType WindowsBasedSliArgs

func WindowsBasedSliPtr(v *WindowsBasedSliArgs) WindowsBasedSliPtrInput {
	return (*windowsBasedSliPtrType)(v)
}

func (*windowsBasedSliPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WindowsBasedSli)(nil)).Elem()
}

func (i *windowsBasedSliPtrType) ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput {
	return i.ToWindowsBasedSliPtrOutputWithContext(context.Background())
}

func (i *windowsBasedSliPtrType) ToWindowsBasedSliPtrOutputWithContext(ctx context.Context) WindowsBasedSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsBasedSliPtrOutput)
}

// A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.
type WindowsBasedSliOutput struct{ *pulumi.OutputState }

func (WindowsBasedSliOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsBasedSli)(nil)).Elem()
}

func (o WindowsBasedSliOutput) ToWindowsBasedSliOutput() WindowsBasedSliOutput {
	return o
}

func (o WindowsBasedSliOutput) ToWindowsBasedSliOutputWithContext(ctx context.Context) WindowsBasedSliOutput {
	return o
}

func (o WindowsBasedSliOutput) ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput {
	return o.ToWindowsBasedSliPtrOutputWithContext(context.Background())
}

func (o WindowsBasedSliOutput) ToWindowsBasedSliPtrOutputWithContext(ctx context.Context) WindowsBasedSliPtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *WindowsBasedSli {
		return &v
	}).(WindowsBasedSliPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
func (o WindowsBasedSliOutput) GoodBadMetricFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *string { return v.GoodBadMetricFilter }).(pulumi.StringPtrOutput)
}

// A window is good if its performance is high enough.
func (o WindowsBasedSliOutput) GoodTotalRatioThreshold() PerformanceThresholdPtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *PerformanceThreshold { return v.GoodTotalRatioThreshold }).(PerformanceThresholdPtrOutput)
}

// A window is good if the metric's value is in a good range, averaged across returned streams.
func (o WindowsBasedSliOutput) MetricMeanInRange() MetricRangePtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *MetricRange { return v.MetricMeanInRange }).(MetricRangePtrOutput)
}

// A window is good if the metric's value is in a good range, summed across returned streams.
func (o WindowsBasedSliOutput) MetricSumInRange() MetricRangePtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *MetricRange { return v.MetricSumInRange }).(MetricRangePtrOutput)
}

// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
func (o WindowsBasedSliOutput) WindowPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *string { return v.WindowPeriod }).(pulumi.StringPtrOutput)
}

type WindowsBasedSliPtrOutput struct{ *pulumi.OutputState }

func (WindowsBasedSliPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WindowsBasedSli)(nil)).Elem()
}

func (o WindowsBasedSliPtrOutput) ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput {
	return o
}

func (o WindowsBasedSliPtrOutput) ToWindowsBasedSliPtrOutputWithContext(ctx context.Context) WindowsBasedSliPtrOutput {
	return o
}

func (o WindowsBasedSliPtrOutput) Elem() WindowsBasedSliOutput {
	return o.ApplyT(func(v *WindowsBasedSli) WindowsBasedSli { return *v }).(WindowsBasedSliOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
func (o WindowsBasedSliPtrOutput) GoodBadMetricFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *string {
		if v == nil {
			return nil
		}
		return v.GoodBadMetricFilter
	}).(pulumi.StringPtrOutput)
}

// A window is good if its performance is high enough.
func (o WindowsBasedSliPtrOutput) GoodTotalRatioThreshold() PerformanceThresholdPtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *PerformanceThreshold {
		if v == nil {
			return nil
		}
		return v.GoodTotalRatioThreshold
	}).(PerformanceThresholdPtrOutput)
}

// A window is good if the metric's value is in a good range, averaged across returned streams.
func (o WindowsBasedSliPtrOutput) MetricMeanInRange() MetricRangePtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *MetricRange {
		if v == nil {
			return nil
		}
		return v.MetricMeanInRange
	}).(MetricRangePtrOutput)
}

// A window is good if the metric's value is in a good range, summed across returned streams.
func (o WindowsBasedSliPtrOutput) MetricSumInRange() MetricRangePtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *MetricRange {
		if v == nil {
			return nil
		}
		return v.MetricSumInRange
	}).(MetricRangePtrOutput)
}

// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
func (o WindowsBasedSliPtrOutput) WindowPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *string {
		if v == nil {
			return nil
		}
		return v.WindowPeriod
	}).(pulumi.StringPtrOutput)
}

// A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.
type WindowsBasedSliResponse struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
	GoodBadMetricFilter string `pulumi:"goodBadMetricFilter"`
	// A window is good if its performance is high enough.
	GoodTotalRatioThreshold PerformanceThresholdResponse `pulumi:"goodTotalRatioThreshold"`
	// A window is good if the metric's value is in a good range, averaged across returned streams.
	MetricMeanInRange MetricRangeResponse `pulumi:"metricMeanInRange"`
	// A window is good if the metric's value is in a good range, summed across returned streams.
	MetricSumInRange MetricRangeResponse `pulumi:"metricSumInRange"`
	// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
	WindowPeriod string `pulumi:"windowPeriod"`
}

// WindowsBasedSliResponseInput is an input type that accepts WindowsBasedSliResponseArgs and WindowsBasedSliResponseOutput values.
// You can construct a concrete instance of `WindowsBasedSliResponseInput` via:
//
//          WindowsBasedSliResponseArgs{...}
type WindowsBasedSliResponseInput interface {
	pulumi.Input

	ToWindowsBasedSliResponseOutput() WindowsBasedSliResponseOutput
	ToWindowsBasedSliResponseOutputWithContext(context.Context) WindowsBasedSliResponseOutput
}

// A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.
type WindowsBasedSliResponseArgs struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
	GoodBadMetricFilter pulumi.StringInput `pulumi:"goodBadMetricFilter"`
	// A window is good if its performance is high enough.
	GoodTotalRatioThreshold PerformanceThresholdResponseInput `pulumi:"goodTotalRatioThreshold"`
	// A window is good if the metric's value is in a good range, averaged across returned streams.
	MetricMeanInRange MetricRangeResponseInput `pulumi:"metricMeanInRange"`
	// A window is good if the metric's value is in a good range, summed across returned streams.
	MetricSumInRange MetricRangeResponseInput `pulumi:"metricSumInRange"`
	// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
	WindowPeriod pulumi.StringInput `pulumi:"windowPeriod"`
}

func (WindowsBasedSliResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsBasedSliResponse)(nil)).Elem()
}

func (i WindowsBasedSliResponseArgs) ToWindowsBasedSliResponseOutput() WindowsBasedSliResponseOutput {
	return i.ToWindowsBasedSliResponseOutputWithContext(context.Background())
}

func (i WindowsBasedSliResponseArgs) ToWindowsBasedSliResponseOutputWithContext(ctx context.Context) WindowsBasedSliResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsBasedSliResponseOutput)
}

func (i WindowsBasedSliResponseArgs) ToWindowsBasedSliResponsePtrOutput() WindowsBasedSliResponsePtrOutput {
	return i.ToWindowsBasedSliResponsePtrOutputWithContext(context.Background())
}

func (i WindowsBasedSliResponseArgs) ToWindowsBasedSliResponsePtrOutputWithContext(ctx context.Context) WindowsBasedSliResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsBasedSliResponseOutput).ToWindowsBasedSliResponsePtrOutputWithContext(ctx)
}

// WindowsBasedSliResponsePtrInput is an input type that accepts WindowsBasedSliResponseArgs, WindowsBasedSliResponsePtr and WindowsBasedSliResponsePtrOutput values.
// You can construct a concrete instance of `WindowsBasedSliResponsePtrInput` via:
//
//          WindowsBasedSliResponseArgs{...}
//
//  or:
//
//          nil
type WindowsBasedSliResponsePtrInput interface {
	pulumi.Input

	ToWindowsBasedSliResponsePtrOutput() WindowsBasedSliResponsePtrOutput
	ToWindowsBasedSliResponsePtrOutputWithContext(context.Context) WindowsBasedSliResponsePtrOutput
}

type windowsBasedSliResponsePtrType WindowsBasedSliResponseArgs

func WindowsBasedSliResponsePtr(v *WindowsBasedSliResponseArgs) WindowsBasedSliResponsePtrInput {
	return (*windowsBasedSliResponsePtrType)(v)
}

func (*windowsBasedSliResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WindowsBasedSliResponse)(nil)).Elem()
}

func (i *windowsBasedSliResponsePtrType) ToWindowsBasedSliResponsePtrOutput() WindowsBasedSliResponsePtrOutput {
	return i.ToWindowsBasedSliResponsePtrOutputWithContext(context.Background())
}

func (i *windowsBasedSliResponsePtrType) ToWindowsBasedSliResponsePtrOutputWithContext(ctx context.Context) WindowsBasedSliResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsBasedSliResponsePtrOutput)
}

// A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.
type WindowsBasedSliResponseOutput struct{ *pulumi.OutputState }

func (WindowsBasedSliResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsBasedSliResponse)(nil)).Elem()
}

func (o WindowsBasedSliResponseOutput) ToWindowsBasedSliResponseOutput() WindowsBasedSliResponseOutput {
	return o
}

func (o WindowsBasedSliResponseOutput) ToWindowsBasedSliResponseOutputWithContext(ctx context.Context) WindowsBasedSliResponseOutput {
	return o
}

func (o WindowsBasedSliResponseOutput) ToWindowsBasedSliResponsePtrOutput() WindowsBasedSliResponsePtrOutput {
	return o.ToWindowsBasedSliResponsePtrOutputWithContext(context.Background())
}

func (o WindowsBasedSliResponseOutput) ToWindowsBasedSliResponsePtrOutputWithContext(ctx context.Context) WindowsBasedSliResponsePtrOutput {
	return o.ApplyT(func(v WindowsBasedSliResponse) *WindowsBasedSliResponse {
		return &v
	}).(WindowsBasedSliResponsePtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
func (o WindowsBasedSliResponseOutput) GoodBadMetricFilter() pulumi.StringOutput {
	return o.ApplyT(func(v WindowsBasedSliResponse) string { return v.GoodBadMetricFilter }).(pulumi.StringOutput)
}

// A window is good if its performance is high enough.
func (o WindowsBasedSliResponseOutput) GoodTotalRatioThreshold() PerformanceThresholdResponseOutput {
	return o.ApplyT(func(v WindowsBasedSliResponse) PerformanceThresholdResponse { return v.GoodTotalRatioThreshold }).(PerformanceThresholdResponseOutput)
}

// A window is good if the metric's value is in a good range, averaged across returned streams.
func (o WindowsBasedSliResponseOutput) MetricMeanInRange() MetricRangeResponseOutput {
	return o.ApplyT(func(v WindowsBasedSliResponse) MetricRangeResponse { return v.MetricMeanInRange }).(MetricRangeResponseOutput)
}

// A window is good if the metric's value is in a good range, summed across returned streams.
func (o WindowsBasedSliResponseOutput) MetricSumInRange() MetricRangeResponseOutput {
	return o.ApplyT(func(v WindowsBasedSliResponse) MetricRangeResponse { return v.MetricSumInRange }).(MetricRangeResponseOutput)
}

// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
func (o WindowsBasedSliResponseOutput) WindowPeriod() pulumi.StringOutput {
	return o.ApplyT(func(v WindowsBasedSliResponse) string { return v.WindowPeriod }).(pulumi.StringOutput)
}

type WindowsBasedSliResponsePtrOutput struct{ *pulumi.OutputState }

func (WindowsBasedSliResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WindowsBasedSliResponse)(nil)).Elem()
}

func (o WindowsBasedSliResponsePtrOutput) ToWindowsBasedSliResponsePtrOutput() WindowsBasedSliResponsePtrOutput {
	return o
}

func (o WindowsBasedSliResponsePtrOutput) ToWindowsBasedSliResponsePtrOutputWithContext(ctx context.Context) WindowsBasedSliResponsePtrOutput {
	return o
}

func (o WindowsBasedSliResponsePtrOutput) Elem() WindowsBasedSliResponseOutput {
	return o.ApplyT(func(v *WindowsBasedSliResponse) WindowsBasedSliResponse { return *v }).(WindowsBasedSliResponseOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
func (o WindowsBasedSliResponsePtrOutput) GoodBadMetricFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WindowsBasedSliResponse) *string {
		if v == nil {
			return nil
		}
		return &v.GoodBadMetricFilter
	}).(pulumi.StringPtrOutput)
}

// A window is good if its performance is high enough.
func (o WindowsBasedSliResponsePtrOutput) GoodTotalRatioThreshold() PerformanceThresholdResponsePtrOutput {
	return o.ApplyT(func(v *WindowsBasedSliResponse) *PerformanceThresholdResponse {
		if v == nil {
			return nil
		}
		return &v.GoodTotalRatioThreshold
	}).(PerformanceThresholdResponsePtrOutput)
}

// A window is good if the metric's value is in a good range, averaged across returned streams.
func (o WindowsBasedSliResponsePtrOutput) MetricMeanInRange() MetricRangeResponsePtrOutput {
	return o.ApplyT(func(v *WindowsBasedSliResponse) *MetricRangeResponse {
		if v == nil {
			return nil
		}
		return &v.MetricMeanInRange
	}).(MetricRangeResponsePtrOutput)
}

// A window is good if the metric's value is in a good range, summed across returned streams.
func (o WindowsBasedSliResponsePtrOutput) MetricSumInRange() MetricRangeResponsePtrOutput {
	return o.ApplyT(func(v *WindowsBasedSliResponse) *MetricRangeResponse {
		if v == nil {
			return nil
		}
		return &v.MetricSumInRange
	}).(MetricRangeResponsePtrOutput)
}

// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
func (o WindowsBasedSliResponsePtrOutput) WindowPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WindowsBasedSliResponse) *string {
		if v == nil {
			return nil
		}
		return &v.WindowPeriod
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterOutputType(AggregationOutput{})
	pulumi.RegisterOutputType(AggregationArrayOutput{})
	pulumi.RegisterOutputType(AggregationResponseOutput{})
	pulumi.RegisterOutputType(AggregationResponseArrayOutput{})
	pulumi.RegisterOutputType(AppEngineOutput{})
	pulumi.RegisterOutputType(AppEnginePtrOutput{})
	pulumi.RegisterOutputType(AppEngineResponseOutput{})
	pulumi.RegisterOutputType(AppEngineResponsePtrOutput{})
	pulumi.RegisterOutputType(AvailabilityCriteriaOutput{})
	pulumi.RegisterOutputType(AvailabilityCriteriaPtrOutput{})
	pulumi.RegisterOutputType(AvailabilityCriteriaResponseOutput{})
	pulumi.RegisterOutputType(AvailabilityCriteriaResponsePtrOutput{})
	pulumi.RegisterOutputType(BasicAuthenticationOutput{})
	pulumi.RegisterOutputType(BasicAuthenticationPtrOutput{})
	pulumi.RegisterOutputType(BasicAuthenticationResponseOutput{})
	pulumi.RegisterOutputType(BasicAuthenticationResponsePtrOutput{})
	pulumi.RegisterOutputType(BasicSliOutput{})
	pulumi.RegisterOutputType(BasicSliPtrOutput{})
	pulumi.RegisterOutputType(BasicSliResponseOutput{})
	pulumi.RegisterOutputType(BasicSliResponsePtrOutput{})
	pulumi.RegisterOutputType(BucketOptionsOutput{})
	pulumi.RegisterOutputType(BucketOptionsPtrOutput{})
	pulumi.RegisterOutputType(CloudEndpointsOutput{})
	pulumi.RegisterOutputType(CloudEndpointsPtrOutput{})
	pulumi.RegisterOutputType(CloudEndpointsResponseOutput{})
	pulumi.RegisterOutputType(CloudEndpointsResponsePtrOutput{})
	pulumi.RegisterOutputType(ClusterIstioOutput{})
	pulumi.RegisterOutputType(ClusterIstioPtrOutput{})
	pulumi.RegisterOutputType(ClusterIstioResponseOutput{})
	pulumi.RegisterOutputType(ClusterIstioResponsePtrOutput{})
	pulumi.RegisterOutputType(CollectdPayloadOutput{})
	pulumi.RegisterOutputType(CollectdPayloadArrayOutput{})
	pulumi.RegisterOutputType(CollectdValueOutput{})
	pulumi.RegisterOutputType(CollectdValueArrayOutput{})
	pulumi.RegisterOutputType(ConditionOutput{})
	pulumi.RegisterOutputType(ConditionArrayOutput{})
	pulumi.RegisterOutputType(ConditionResponseOutput{})
	pulumi.RegisterOutputType(ConditionResponseArrayOutput{})
	pulumi.RegisterOutputType(ContentMatcherOutput{})
	pulumi.RegisterOutputType(ContentMatcherArrayOutput{})
	pulumi.RegisterOutputType(ContentMatcherResponseOutput{})
	pulumi.RegisterOutputType(ContentMatcherResponseArrayOutput{})
	pulumi.RegisterOutputType(CustomOutput{})
	pulumi.RegisterOutputType(CustomPtrOutput{})
	pulumi.RegisterOutputType(CustomResponseOutput{})
	pulumi.RegisterOutputType(CustomResponsePtrOutput{})
	pulumi.RegisterOutputType(DistributionOutput{})
	pulumi.RegisterOutputType(DistributionPtrOutput{})
	pulumi.RegisterOutputType(DistributionCutOutput{})
	pulumi.RegisterOutputType(DistributionCutPtrOutput{})
	pulumi.RegisterOutputType(DistributionCutResponseOutput{})
	pulumi.RegisterOutputType(DistributionCutResponsePtrOutput{})
	pulumi.RegisterOutputType(DocumentationOutput{})
	pulumi.RegisterOutputType(DocumentationPtrOutput{})
	pulumi.RegisterOutputType(DocumentationResponseOutput{})
	pulumi.RegisterOutputType(DocumentationResponsePtrOutput{})
	pulumi.RegisterOutputType(ExemplarOutput{})
	pulumi.RegisterOutputType(ExemplarArrayOutput{})
	pulumi.RegisterOutputType(ExplicitOutput{})
	pulumi.RegisterOutputType(ExplicitPtrOutput{})
	pulumi.RegisterOutputType(ExponentialOutput{})
	pulumi.RegisterOutputType(ExponentialPtrOutput{})
	pulumi.RegisterOutputType(GoogleMonitoringV3RangeOutput{})
	pulumi.RegisterOutputType(GoogleMonitoringV3RangePtrOutput{})
	pulumi.RegisterOutputType(GoogleMonitoringV3RangeResponseOutput{})
	pulumi.RegisterOutputType(GoogleMonitoringV3RangeResponsePtrOutput{})
	pulumi.RegisterOutputType(HttpCheckOutput{})
	pulumi.RegisterOutputType(HttpCheckPtrOutput{})
	pulumi.RegisterOutputType(HttpCheckResponseOutput{})
	pulumi.RegisterOutputType(HttpCheckResponsePtrOutput{})
	pulumi.RegisterOutputType(InternalCheckerOutput{})
	pulumi.RegisterOutputType(InternalCheckerArrayOutput{})
	pulumi.RegisterOutputType(InternalCheckerResponseOutput{})
	pulumi.RegisterOutputType(InternalCheckerResponseArrayOutput{})
	pulumi.RegisterOutputType(IstioCanonicalServiceOutput{})
	pulumi.RegisterOutputType(IstioCanonicalServicePtrOutput{})
	pulumi.RegisterOutputType(IstioCanonicalServiceResponseOutput{})
	pulumi.RegisterOutputType(IstioCanonicalServiceResponsePtrOutput{})
	pulumi.RegisterOutputType(LabelDescriptorOutput{})
	pulumi.RegisterOutputType(LabelDescriptorArrayOutput{})
	pulumi.RegisterOutputType(LabelDescriptorResponseOutput{})
	pulumi.RegisterOutputType(LabelDescriptorResponseArrayOutput{})
	pulumi.RegisterOutputType(LatencyCriteriaOutput{})
	pulumi.RegisterOutputType(LatencyCriteriaPtrOutput{})
	pulumi.RegisterOutputType(LatencyCriteriaResponseOutput{})
	pulumi.RegisterOutputType(LatencyCriteriaResponsePtrOutput{})
	pulumi.RegisterOutputType(LinearOutput{})
	pulumi.RegisterOutputType(LinearPtrOutput{})
	pulumi.RegisterOutputType(MeshIstioOutput{})
	pulumi.RegisterOutputType(MeshIstioPtrOutput{})
	pulumi.RegisterOutputType(MeshIstioResponseOutput{})
	pulumi.RegisterOutputType(MeshIstioResponsePtrOutput{})
	pulumi.RegisterOutputType(MetricOutput{})
	pulumi.RegisterOutputType(MetricPtrOutput{})
	pulumi.RegisterOutputType(MetricAbsenceOutput{})
	pulumi.RegisterOutputType(MetricAbsencePtrOutput{})
	pulumi.RegisterOutputType(MetricAbsenceResponseOutput{})
	pulumi.RegisterOutputType(MetricDescriptorMetadataOutput{})
	pulumi.RegisterOutputType(MetricDescriptorMetadataPtrOutput{})
	pulumi.RegisterOutputType(MetricDescriptorMetadataResponseOutput{})
	pulumi.RegisterOutputType(MetricDescriptorMetadataResponsePtrOutput{})
	pulumi.RegisterOutputType(MetricRangeOutput{})
	pulumi.RegisterOutputType(MetricRangePtrOutput{})
	pulumi.RegisterOutputType(MetricRangeResponseOutput{})
	pulumi.RegisterOutputType(MetricRangeResponsePtrOutput{})
	pulumi.RegisterOutputType(MetricThresholdOutput{})
	pulumi.RegisterOutputType(MetricThresholdPtrOutput{})
	pulumi.RegisterOutputType(MetricThresholdResponseOutput{})
	pulumi.RegisterOutputType(MonitoredResourceOutput{})
	pulumi.RegisterOutputType(MonitoredResourcePtrOutput{})
	pulumi.RegisterOutputType(MonitoredResourceMetadataOutput{})
	pulumi.RegisterOutputType(MonitoredResourceMetadataPtrOutput{})
	pulumi.RegisterOutputType(MonitoredResourceResponseOutput{})
	pulumi.RegisterOutputType(MonitoredResourceResponsePtrOutput{})
	pulumi.RegisterOutputType(MonitoringQueryLanguageConditionOutput{})
	pulumi.RegisterOutputType(MonitoringQueryLanguageConditionPtrOutput{})
	pulumi.RegisterOutputType(MonitoringQueryLanguageConditionResponseOutput{})
	pulumi.RegisterOutputType(MutationRecordOutput{})
	pulumi.RegisterOutputType(MutationRecordPtrOutput{})
	pulumi.RegisterOutputType(MutationRecordArrayOutput{})
	pulumi.RegisterOutputType(MutationRecordResponseOutput{})
	pulumi.RegisterOutputType(MutationRecordResponsePtrOutput{})
	pulumi.RegisterOutputType(MutationRecordResponseArrayOutput{})
	pulumi.RegisterOutputType(PerformanceThresholdOutput{})
	pulumi.RegisterOutputType(PerformanceThresholdPtrOutput{})
	pulumi.RegisterOutputType(PerformanceThresholdResponseOutput{})
	pulumi.RegisterOutputType(PerformanceThresholdResponsePtrOutput{})
	pulumi.RegisterOutputType(PointOutput{})
	pulumi.RegisterOutputType(PointArrayOutput{})
	pulumi.RegisterOutputType(RangeOutput{})
	pulumi.RegisterOutputType(RangePtrOutput{})
	pulumi.RegisterOutputType(RequestBasedSliOutput{})
	pulumi.RegisterOutputType(RequestBasedSliPtrOutput{})
	pulumi.RegisterOutputType(RequestBasedSliResponseOutput{})
	pulumi.RegisterOutputType(RequestBasedSliResponsePtrOutput{})
	pulumi.RegisterOutputType(ResourceGroupOutput{})
	pulumi.RegisterOutputType(ResourceGroupPtrOutput{})
	pulumi.RegisterOutputType(ResourceGroupResponseOutput{})
	pulumi.RegisterOutputType(ResourceGroupResponsePtrOutput{})
	pulumi.RegisterOutputType(ServiceLevelIndicatorOutput{})
	pulumi.RegisterOutputType(ServiceLevelIndicatorPtrOutput{})
	pulumi.RegisterOutputType(ServiceLevelIndicatorResponseOutput{})
	pulumi.RegisterOutputType(ServiceLevelIndicatorResponsePtrOutput{})
	pulumi.RegisterOutputType(StatusOutput{})
	pulumi.RegisterOutputType(StatusPtrOutput{})
	pulumi.RegisterOutputType(StatusResponseOutput{})
	pulumi.RegisterOutputType(StatusResponsePtrOutput{})
	pulumi.RegisterOutputType(TcpCheckOutput{})
	pulumi.RegisterOutputType(TcpCheckPtrOutput{})
	pulumi.RegisterOutputType(TcpCheckResponseOutput{})
	pulumi.RegisterOutputType(TcpCheckResponsePtrOutput{})
	pulumi.RegisterOutputType(TelemetryOutput{})
	pulumi.RegisterOutputType(TelemetryPtrOutput{})
	pulumi.RegisterOutputType(TelemetryResponseOutput{})
	pulumi.RegisterOutputType(TelemetryResponsePtrOutput{})
	pulumi.RegisterOutputType(TimeIntervalOutput{})
	pulumi.RegisterOutputType(TimeIntervalPtrOutput{})
	pulumi.RegisterOutputType(TimeSeriesTypeOutput{})
	pulumi.RegisterOutputType(TimeSeriesTypeArrayOutput{})
	pulumi.RegisterOutputType(TimeSeriesRatioOutput{})
	pulumi.RegisterOutputType(TimeSeriesRatioPtrOutput{})
	pulumi.RegisterOutputType(TimeSeriesRatioResponseOutput{})
	pulumi.RegisterOutputType(TimeSeriesRatioResponsePtrOutput{})
	pulumi.RegisterOutputType(TriggerOutput{})
	pulumi.RegisterOutputType(TriggerPtrOutput{})
	pulumi.RegisterOutputType(TriggerResponseOutput{})
	pulumi.RegisterOutputType(TypedValueOutput{})
	pulumi.RegisterOutputType(TypedValuePtrOutput{})
	pulumi.RegisterOutputType(WindowsBasedSliOutput{})
	pulumi.RegisterOutputType(WindowsBasedSliPtrOutput{})
	pulumi.RegisterOutputType(WindowsBasedSliResponseOutput{})
	pulumi.RegisterOutputType(WindowsBasedSliResponsePtrOutput{})
}

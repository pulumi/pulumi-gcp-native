// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

// Accelerator describes Compute Engine accelerators to be attached to the VM.
type Accelerator struct {
	// The number of accelerators of this type.
	Count *string `pulumi:"count"`
	// Optional. The NVIDIA GPU driver version that should be installed for this type. You can define the specific driver version such as "470.103.01", following the driver version requirements in https://cloud.google.com/compute/docs/gpus/install-drivers-gpu#minimum-driver. Batch will install the specific accelerator driver if qualified.
	DriverVersion *string `pulumi:"driverVersion"`
	// Deprecated: please use instances[0].install_gpu_drivers instead.
	//
	// Deprecated: Deprecated: please use instances[0].install_gpu_drivers instead.
	InstallGpuDrivers *bool `pulumi:"installGpuDrivers"`
	// The accelerator type. For example, "nvidia-tesla-t4". See `gcloud compute accelerator-types list`.
	Type *string `pulumi:"type"`
}

// AcceleratorInput is an input type that accepts AcceleratorArgs and AcceleratorOutput values.
// You can construct a concrete instance of `AcceleratorInput` via:
//
//	AcceleratorArgs{...}
type AcceleratorInput interface {
	pulumi.Input

	ToAcceleratorOutput() AcceleratorOutput
	ToAcceleratorOutputWithContext(context.Context) AcceleratorOutput
}

// Accelerator describes Compute Engine accelerators to be attached to the VM.
type AcceleratorArgs struct {
	// The number of accelerators of this type.
	Count pulumi.StringPtrInput `pulumi:"count"`
	// Optional. The NVIDIA GPU driver version that should be installed for this type. You can define the specific driver version such as "470.103.01", following the driver version requirements in https://cloud.google.com/compute/docs/gpus/install-drivers-gpu#minimum-driver. Batch will install the specific accelerator driver if qualified.
	DriverVersion pulumi.StringPtrInput `pulumi:"driverVersion"`
	// Deprecated: please use instances[0].install_gpu_drivers instead.
	//
	// Deprecated: Deprecated: please use instances[0].install_gpu_drivers instead.
	InstallGpuDrivers pulumi.BoolPtrInput `pulumi:"installGpuDrivers"`
	// The accelerator type. For example, "nvidia-tesla-t4". See `gcloud compute accelerator-types list`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (AcceleratorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Accelerator)(nil)).Elem()
}

func (i AcceleratorArgs) ToAcceleratorOutput() AcceleratorOutput {
	return i.ToAcceleratorOutputWithContext(context.Background())
}

func (i AcceleratorArgs) ToAcceleratorOutputWithContext(ctx context.Context) AcceleratorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AcceleratorOutput)
}

// AcceleratorArrayInput is an input type that accepts AcceleratorArray and AcceleratorArrayOutput values.
// You can construct a concrete instance of `AcceleratorArrayInput` via:
//
//	AcceleratorArray{ AcceleratorArgs{...} }
type AcceleratorArrayInput interface {
	pulumi.Input

	ToAcceleratorArrayOutput() AcceleratorArrayOutput
	ToAcceleratorArrayOutputWithContext(context.Context) AcceleratorArrayOutput
}

type AcceleratorArray []AcceleratorInput

func (AcceleratorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Accelerator)(nil)).Elem()
}

func (i AcceleratorArray) ToAcceleratorArrayOutput() AcceleratorArrayOutput {
	return i.ToAcceleratorArrayOutputWithContext(context.Background())
}

func (i AcceleratorArray) ToAcceleratorArrayOutputWithContext(ctx context.Context) AcceleratorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AcceleratorArrayOutput)
}

// Accelerator describes Compute Engine accelerators to be attached to the VM.
type AcceleratorOutput struct{ *pulumi.OutputState }

func (AcceleratorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Accelerator)(nil)).Elem()
}

func (o AcceleratorOutput) ToAcceleratorOutput() AcceleratorOutput {
	return o
}

func (o AcceleratorOutput) ToAcceleratorOutputWithContext(ctx context.Context) AcceleratorOutput {
	return o
}

// The number of accelerators of this type.
func (o AcceleratorOutput) Count() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Accelerator) *string { return v.Count }).(pulumi.StringPtrOutput)
}

// Optional. The NVIDIA GPU driver version that should be installed for this type. You can define the specific driver version such as "470.103.01", following the driver version requirements in https://cloud.google.com/compute/docs/gpus/install-drivers-gpu#minimum-driver. Batch will install the specific accelerator driver if qualified.
func (o AcceleratorOutput) DriverVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Accelerator) *string { return v.DriverVersion }).(pulumi.StringPtrOutput)
}

// Deprecated: please use instances[0].install_gpu_drivers instead.
//
// Deprecated: Deprecated: please use instances[0].install_gpu_drivers instead.
func (o AcceleratorOutput) InstallGpuDrivers() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Accelerator) *bool { return v.InstallGpuDrivers }).(pulumi.BoolPtrOutput)
}

// The accelerator type. For example, "nvidia-tesla-t4". See `gcloud compute accelerator-types list`.
func (o AcceleratorOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Accelerator) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type AcceleratorArrayOutput struct{ *pulumi.OutputState }

func (AcceleratorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Accelerator)(nil)).Elem()
}

func (o AcceleratorArrayOutput) ToAcceleratorArrayOutput() AcceleratorArrayOutput {
	return o
}

func (o AcceleratorArrayOutput) ToAcceleratorArrayOutputWithContext(ctx context.Context) AcceleratorArrayOutput {
	return o
}

func (o AcceleratorArrayOutput) Index(i pulumi.IntInput) AcceleratorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Accelerator {
		return vs[0].([]Accelerator)[vs[1].(int)]
	}).(AcceleratorOutput)
}

// Accelerator describes Compute Engine accelerators to be attached to the VM.
type AcceleratorResponse struct {
	// The number of accelerators of this type.
	Count string `pulumi:"count"`
	// Optional. The NVIDIA GPU driver version that should be installed for this type. You can define the specific driver version such as "470.103.01", following the driver version requirements in https://cloud.google.com/compute/docs/gpus/install-drivers-gpu#minimum-driver. Batch will install the specific accelerator driver if qualified.
	DriverVersion string `pulumi:"driverVersion"`
	// Deprecated: please use instances[0].install_gpu_drivers instead.
	//
	// Deprecated: Deprecated: please use instances[0].install_gpu_drivers instead.
	InstallGpuDrivers bool `pulumi:"installGpuDrivers"`
	// The accelerator type. For example, "nvidia-tesla-t4". See `gcloud compute accelerator-types list`.
	Type string `pulumi:"type"`
}

// Accelerator describes Compute Engine accelerators to be attached to the VM.
type AcceleratorResponseOutput struct{ *pulumi.OutputState }

func (AcceleratorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AcceleratorResponse)(nil)).Elem()
}

func (o AcceleratorResponseOutput) ToAcceleratorResponseOutput() AcceleratorResponseOutput {
	return o
}

func (o AcceleratorResponseOutput) ToAcceleratorResponseOutputWithContext(ctx context.Context) AcceleratorResponseOutput {
	return o
}

// The number of accelerators of this type.
func (o AcceleratorResponseOutput) Count() pulumi.StringOutput {
	return o.ApplyT(func(v AcceleratorResponse) string { return v.Count }).(pulumi.StringOutput)
}

// Optional. The NVIDIA GPU driver version that should be installed for this type. You can define the specific driver version such as "470.103.01", following the driver version requirements in https://cloud.google.com/compute/docs/gpus/install-drivers-gpu#minimum-driver. Batch will install the specific accelerator driver if qualified.
func (o AcceleratorResponseOutput) DriverVersion() pulumi.StringOutput {
	return o.ApplyT(func(v AcceleratorResponse) string { return v.DriverVersion }).(pulumi.StringOutput)
}

// Deprecated: please use instances[0].install_gpu_drivers instead.
//
// Deprecated: Deprecated: please use instances[0].install_gpu_drivers instead.
func (o AcceleratorResponseOutput) InstallGpuDrivers() pulumi.BoolOutput {
	return o.ApplyT(func(v AcceleratorResponse) bool { return v.InstallGpuDrivers }).(pulumi.BoolOutput)
}

// The accelerator type. For example, "nvidia-tesla-t4". See `gcloud compute accelerator-types list`.
func (o AcceleratorResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v AcceleratorResponse) string { return v.Type }).(pulumi.StringOutput)
}

type AcceleratorResponseArrayOutput struct{ *pulumi.OutputState }

func (AcceleratorResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AcceleratorResponse)(nil)).Elem()
}

func (o AcceleratorResponseArrayOutput) ToAcceleratorResponseArrayOutput() AcceleratorResponseArrayOutput {
	return o
}

func (o AcceleratorResponseArrayOutput) ToAcceleratorResponseArrayOutputWithContext(ctx context.Context) AcceleratorResponseArrayOutput {
	return o
}

func (o AcceleratorResponseArrayOutput) Index(i pulumi.IntInput) AcceleratorResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AcceleratorResponse {
		return vs[0].([]AcceleratorResponse)[vs[1].(int)]
	}).(AcceleratorResponseOutput)
}

// Conditions for actions to deal with task failures.
type ActionCondition struct {
	// Exit codes of a task execution. If there are more than 1 exit codes, when task executes with any of the exit code in the list, the condition is met and the action will be executed.
	ExitCodes []int `pulumi:"exitCodes"`
}

// ActionConditionInput is an input type that accepts ActionConditionArgs and ActionConditionOutput values.
// You can construct a concrete instance of `ActionConditionInput` via:
//
//	ActionConditionArgs{...}
type ActionConditionInput interface {
	pulumi.Input

	ToActionConditionOutput() ActionConditionOutput
	ToActionConditionOutputWithContext(context.Context) ActionConditionOutput
}

// Conditions for actions to deal with task failures.
type ActionConditionArgs struct {
	// Exit codes of a task execution. If there are more than 1 exit codes, when task executes with any of the exit code in the list, the condition is met and the action will be executed.
	ExitCodes pulumi.IntArrayInput `pulumi:"exitCodes"`
}

func (ActionConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ActionCondition)(nil)).Elem()
}

func (i ActionConditionArgs) ToActionConditionOutput() ActionConditionOutput {
	return i.ToActionConditionOutputWithContext(context.Background())
}

func (i ActionConditionArgs) ToActionConditionOutputWithContext(ctx context.Context) ActionConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ActionConditionOutput)
}

func (i ActionConditionArgs) ToActionConditionPtrOutput() ActionConditionPtrOutput {
	return i.ToActionConditionPtrOutputWithContext(context.Background())
}

func (i ActionConditionArgs) ToActionConditionPtrOutputWithContext(ctx context.Context) ActionConditionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ActionConditionOutput).ToActionConditionPtrOutputWithContext(ctx)
}

// ActionConditionPtrInput is an input type that accepts ActionConditionArgs, ActionConditionPtr and ActionConditionPtrOutput values.
// You can construct a concrete instance of `ActionConditionPtrInput` via:
//
//	        ActionConditionArgs{...}
//
//	or:
//
//	        nil
type ActionConditionPtrInput interface {
	pulumi.Input

	ToActionConditionPtrOutput() ActionConditionPtrOutput
	ToActionConditionPtrOutputWithContext(context.Context) ActionConditionPtrOutput
}

type actionConditionPtrType ActionConditionArgs

func ActionConditionPtr(v *ActionConditionArgs) ActionConditionPtrInput {
	return (*actionConditionPtrType)(v)
}

func (*actionConditionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ActionCondition)(nil)).Elem()
}

func (i *actionConditionPtrType) ToActionConditionPtrOutput() ActionConditionPtrOutput {
	return i.ToActionConditionPtrOutputWithContext(context.Background())
}

func (i *actionConditionPtrType) ToActionConditionPtrOutputWithContext(ctx context.Context) ActionConditionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ActionConditionPtrOutput)
}

// Conditions for actions to deal with task failures.
type ActionConditionOutput struct{ *pulumi.OutputState }

func (ActionConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ActionCondition)(nil)).Elem()
}

func (o ActionConditionOutput) ToActionConditionOutput() ActionConditionOutput {
	return o
}

func (o ActionConditionOutput) ToActionConditionOutputWithContext(ctx context.Context) ActionConditionOutput {
	return o
}

func (o ActionConditionOutput) ToActionConditionPtrOutput() ActionConditionPtrOutput {
	return o.ToActionConditionPtrOutputWithContext(context.Background())
}

func (o ActionConditionOutput) ToActionConditionPtrOutputWithContext(ctx context.Context) ActionConditionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ActionCondition) *ActionCondition {
		return &v
	}).(ActionConditionPtrOutput)
}

// Exit codes of a task execution. If there are more than 1 exit codes, when task executes with any of the exit code in the list, the condition is met and the action will be executed.
func (o ActionConditionOutput) ExitCodes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v ActionCondition) []int { return v.ExitCodes }).(pulumi.IntArrayOutput)
}

type ActionConditionPtrOutput struct{ *pulumi.OutputState }

func (ActionConditionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ActionCondition)(nil)).Elem()
}

func (o ActionConditionPtrOutput) ToActionConditionPtrOutput() ActionConditionPtrOutput {
	return o
}

func (o ActionConditionPtrOutput) ToActionConditionPtrOutputWithContext(ctx context.Context) ActionConditionPtrOutput {
	return o
}

func (o ActionConditionPtrOutput) Elem() ActionConditionOutput {
	return o.ApplyT(func(v *ActionCondition) ActionCondition {
		if v != nil {
			return *v
		}
		var ret ActionCondition
		return ret
	}).(ActionConditionOutput)
}

// Exit codes of a task execution. If there are more than 1 exit codes, when task executes with any of the exit code in the list, the condition is met and the action will be executed.
func (o ActionConditionPtrOutput) ExitCodes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *ActionCondition) []int {
		if v == nil {
			return nil
		}
		return v.ExitCodes
	}).(pulumi.IntArrayOutput)
}

// Conditions for actions to deal with task failures.
type ActionConditionResponse struct {
	// Exit codes of a task execution. If there are more than 1 exit codes, when task executes with any of the exit code in the list, the condition is met and the action will be executed.
	ExitCodes []int `pulumi:"exitCodes"`
}

// Conditions for actions to deal with task failures.
type ActionConditionResponseOutput struct{ *pulumi.OutputState }

func (ActionConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ActionConditionResponse)(nil)).Elem()
}

func (o ActionConditionResponseOutput) ToActionConditionResponseOutput() ActionConditionResponseOutput {
	return o
}

func (o ActionConditionResponseOutput) ToActionConditionResponseOutputWithContext(ctx context.Context) ActionConditionResponseOutput {
	return o
}

// Exit codes of a task execution. If there are more than 1 exit codes, when task executes with any of the exit code in the list, the condition is met and the action will be executed.
func (o ActionConditionResponseOutput) ExitCodes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v ActionConditionResponse) []int { return v.ExitCodes }).(pulumi.IntArrayOutput)
}

// A Job's resource allocation policy describes when, where, and how compute resources should be allocated for the Job.
type AllocationPolicy struct {
	// Describe instances that can be created by this AllocationPolicy. Only instances[0] is supported now.
	Instances []InstancePolicyOrTemplate `pulumi:"instances"`
	// Labels applied to all VM instances and other resources created by AllocationPolicy. Labels could be user provided or system generated. You can assign up to 64 labels. [Google Compute Engine label restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions) apply. Label names that start with "goog-" or "google-" are reserved.
	Labels map[string]string `pulumi:"labels"`
	// Location where compute resources should be allocated for the Job.
	Location *LocationPolicy `pulumi:"location"`
	// The network policy. If you define an instance template in the InstancePolicyOrTemplate field, Batch will use the network settings in the instance template instead of this field.
	Network *NetworkPolicy `pulumi:"network"`
	// The placement policy.
	Placement *PlacementPolicy `pulumi:"placement"`
	// Service account that VMs will run as.
	ServiceAccount *ServiceAccount `pulumi:"serviceAccount"`
}

// AllocationPolicyInput is an input type that accepts AllocationPolicyArgs and AllocationPolicyOutput values.
// You can construct a concrete instance of `AllocationPolicyInput` via:
//
//	AllocationPolicyArgs{...}
type AllocationPolicyInput interface {
	pulumi.Input

	ToAllocationPolicyOutput() AllocationPolicyOutput
	ToAllocationPolicyOutputWithContext(context.Context) AllocationPolicyOutput
}

// A Job's resource allocation policy describes when, where, and how compute resources should be allocated for the Job.
type AllocationPolicyArgs struct {
	// Describe instances that can be created by this AllocationPolicy. Only instances[0] is supported now.
	Instances InstancePolicyOrTemplateArrayInput `pulumi:"instances"`
	// Labels applied to all VM instances and other resources created by AllocationPolicy. Labels could be user provided or system generated. You can assign up to 64 labels. [Google Compute Engine label restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions) apply. Label names that start with "goog-" or "google-" are reserved.
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// Location where compute resources should be allocated for the Job.
	Location LocationPolicyPtrInput `pulumi:"location"`
	// The network policy. If you define an instance template in the InstancePolicyOrTemplate field, Batch will use the network settings in the instance template instead of this field.
	Network NetworkPolicyPtrInput `pulumi:"network"`
	// The placement policy.
	Placement PlacementPolicyPtrInput `pulumi:"placement"`
	// Service account that VMs will run as.
	ServiceAccount ServiceAccountPtrInput `pulumi:"serviceAccount"`
}

func (AllocationPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocationPolicy)(nil)).Elem()
}

func (i AllocationPolicyArgs) ToAllocationPolicyOutput() AllocationPolicyOutput {
	return i.ToAllocationPolicyOutputWithContext(context.Background())
}

func (i AllocationPolicyArgs) ToAllocationPolicyOutputWithContext(ctx context.Context) AllocationPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationPolicyOutput)
}

func (i AllocationPolicyArgs) ToAllocationPolicyPtrOutput() AllocationPolicyPtrOutput {
	return i.ToAllocationPolicyPtrOutputWithContext(context.Background())
}

func (i AllocationPolicyArgs) ToAllocationPolicyPtrOutputWithContext(ctx context.Context) AllocationPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationPolicyOutput).ToAllocationPolicyPtrOutputWithContext(ctx)
}

// AllocationPolicyPtrInput is an input type that accepts AllocationPolicyArgs, AllocationPolicyPtr and AllocationPolicyPtrOutput values.
// You can construct a concrete instance of `AllocationPolicyPtrInput` via:
//
//	        AllocationPolicyArgs{...}
//
//	or:
//
//	        nil
type AllocationPolicyPtrInput interface {
	pulumi.Input

	ToAllocationPolicyPtrOutput() AllocationPolicyPtrOutput
	ToAllocationPolicyPtrOutputWithContext(context.Context) AllocationPolicyPtrOutput
}

type allocationPolicyPtrType AllocationPolicyArgs

func AllocationPolicyPtr(v *AllocationPolicyArgs) AllocationPolicyPtrInput {
	return (*allocationPolicyPtrType)(v)
}

func (*allocationPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AllocationPolicy)(nil)).Elem()
}

func (i *allocationPolicyPtrType) ToAllocationPolicyPtrOutput() AllocationPolicyPtrOutput {
	return i.ToAllocationPolicyPtrOutputWithContext(context.Background())
}

func (i *allocationPolicyPtrType) ToAllocationPolicyPtrOutputWithContext(ctx context.Context) AllocationPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AllocationPolicyPtrOutput)
}

// A Job's resource allocation policy describes when, where, and how compute resources should be allocated for the Job.
type AllocationPolicyOutput struct{ *pulumi.OutputState }

func (AllocationPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocationPolicy)(nil)).Elem()
}

func (o AllocationPolicyOutput) ToAllocationPolicyOutput() AllocationPolicyOutput {
	return o
}

func (o AllocationPolicyOutput) ToAllocationPolicyOutputWithContext(ctx context.Context) AllocationPolicyOutput {
	return o
}

func (o AllocationPolicyOutput) ToAllocationPolicyPtrOutput() AllocationPolicyPtrOutput {
	return o.ToAllocationPolicyPtrOutputWithContext(context.Background())
}

func (o AllocationPolicyOutput) ToAllocationPolicyPtrOutputWithContext(ctx context.Context) AllocationPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AllocationPolicy) *AllocationPolicy {
		return &v
	}).(AllocationPolicyPtrOutput)
}

// Describe instances that can be created by this AllocationPolicy. Only instances[0] is supported now.
func (o AllocationPolicyOutput) Instances() InstancePolicyOrTemplateArrayOutput {
	return o.ApplyT(func(v AllocationPolicy) []InstancePolicyOrTemplate { return v.Instances }).(InstancePolicyOrTemplateArrayOutput)
}

// Labels applied to all VM instances and other resources created by AllocationPolicy. Labels could be user provided or system generated. You can assign up to 64 labels. [Google Compute Engine label restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions) apply. Label names that start with "goog-" or "google-" are reserved.
func (o AllocationPolicyOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v AllocationPolicy) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// Location where compute resources should be allocated for the Job.
func (o AllocationPolicyOutput) Location() LocationPolicyPtrOutput {
	return o.ApplyT(func(v AllocationPolicy) *LocationPolicy { return v.Location }).(LocationPolicyPtrOutput)
}

// The network policy. If you define an instance template in the InstancePolicyOrTemplate field, Batch will use the network settings in the instance template instead of this field.
func (o AllocationPolicyOutput) Network() NetworkPolicyPtrOutput {
	return o.ApplyT(func(v AllocationPolicy) *NetworkPolicy { return v.Network }).(NetworkPolicyPtrOutput)
}

// The placement policy.
func (o AllocationPolicyOutput) Placement() PlacementPolicyPtrOutput {
	return o.ApplyT(func(v AllocationPolicy) *PlacementPolicy { return v.Placement }).(PlacementPolicyPtrOutput)
}

// Service account that VMs will run as.
func (o AllocationPolicyOutput) ServiceAccount() ServiceAccountPtrOutput {
	return o.ApplyT(func(v AllocationPolicy) *ServiceAccount { return v.ServiceAccount }).(ServiceAccountPtrOutput)
}

type AllocationPolicyPtrOutput struct{ *pulumi.OutputState }

func (AllocationPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AllocationPolicy)(nil)).Elem()
}

func (o AllocationPolicyPtrOutput) ToAllocationPolicyPtrOutput() AllocationPolicyPtrOutput {
	return o
}

func (o AllocationPolicyPtrOutput) ToAllocationPolicyPtrOutputWithContext(ctx context.Context) AllocationPolicyPtrOutput {
	return o
}

func (o AllocationPolicyPtrOutput) Elem() AllocationPolicyOutput {
	return o.ApplyT(func(v *AllocationPolicy) AllocationPolicy {
		if v != nil {
			return *v
		}
		var ret AllocationPolicy
		return ret
	}).(AllocationPolicyOutput)
}

// Describe instances that can be created by this AllocationPolicy. Only instances[0] is supported now.
func (o AllocationPolicyPtrOutput) Instances() InstancePolicyOrTemplateArrayOutput {
	return o.ApplyT(func(v *AllocationPolicy) []InstancePolicyOrTemplate {
		if v == nil {
			return nil
		}
		return v.Instances
	}).(InstancePolicyOrTemplateArrayOutput)
}

// Labels applied to all VM instances and other resources created by AllocationPolicy. Labels could be user provided or system generated. You can assign up to 64 labels. [Google Compute Engine label restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions) apply. Label names that start with "goog-" or "google-" are reserved.
func (o AllocationPolicyPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *AllocationPolicy) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// Location where compute resources should be allocated for the Job.
func (o AllocationPolicyPtrOutput) Location() LocationPolicyPtrOutput {
	return o.ApplyT(func(v *AllocationPolicy) *LocationPolicy {
		if v == nil {
			return nil
		}
		return v.Location
	}).(LocationPolicyPtrOutput)
}

// The network policy. If you define an instance template in the InstancePolicyOrTemplate field, Batch will use the network settings in the instance template instead of this field.
func (o AllocationPolicyPtrOutput) Network() NetworkPolicyPtrOutput {
	return o.ApplyT(func(v *AllocationPolicy) *NetworkPolicy {
		if v == nil {
			return nil
		}
		return v.Network
	}).(NetworkPolicyPtrOutput)
}

// The placement policy.
func (o AllocationPolicyPtrOutput) Placement() PlacementPolicyPtrOutput {
	return o.ApplyT(func(v *AllocationPolicy) *PlacementPolicy {
		if v == nil {
			return nil
		}
		return v.Placement
	}).(PlacementPolicyPtrOutput)
}

// Service account that VMs will run as.
func (o AllocationPolicyPtrOutput) ServiceAccount() ServiceAccountPtrOutput {
	return o.ApplyT(func(v *AllocationPolicy) *ServiceAccount {
		if v == nil {
			return nil
		}
		return v.ServiceAccount
	}).(ServiceAccountPtrOutput)
}

// A Job's resource allocation policy describes when, where, and how compute resources should be allocated for the Job.
type AllocationPolicyResponse struct {
	// Describe instances that can be created by this AllocationPolicy. Only instances[0] is supported now.
	Instances []InstancePolicyOrTemplateResponse `pulumi:"instances"`
	// Labels applied to all VM instances and other resources created by AllocationPolicy. Labels could be user provided or system generated. You can assign up to 64 labels. [Google Compute Engine label restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions) apply. Label names that start with "goog-" or "google-" are reserved.
	Labels map[string]string `pulumi:"labels"`
	// Location where compute resources should be allocated for the Job.
	Location LocationPolicyResponse `pulumi:"location"`
	// The network policy. If you define an instance template in the InstancePolicyOrTemplate field, Batch will use the network settings in the instance template instead of this field.
	Network NetworkPolicyResponse `pulumi:"network"`
	// The placement policy.
	Placement PlacementPolicyResponse `pulumi:"placement"`
	// Service account that VMs will run as.
	ServiceAccount ServiceAccountResponse `pulumi:"serviceAccount"`
}

// A Job's resource allocation policy describes when, where, and how compute resources should be allocated for the Job.
type AllocationPolicyResponseOutput struct{ *pulumi.OutputState }

func (AllocationPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AllocationPolicyResponse)(nil)).Elem()
}

func (o AllocationPolicyResponseOutput) ToAllocationPolicyResponseOutput() AllocationPolicyResponseOutput {
	return o
}

func (o AllocationPolicyResponseOutput) ToAllocationPolicyResponseOutputWithContext(ctx context.Context) AllocationPolicyResponseOutput {
	return o
}

// Describe instances that can be created by this AllocationPolicy. Only instances[0] is supported now.
func (o AllocationPolicyResponseOutput) Instances() InstancePolicyOrTemplateResponseArrayOutput {
	return o.ApplyT(func(v AllocationPolicyResponse) []InstancePolicyOrTemplateResponse { return v.Instances }).(InstancePolicyOrTemplateResponseArrayOutput)
}

// Labels applied to all VM instances and other resources created by AllocationPolicy. Labels could be user provided or system generated. You can assign up to 64 labels. [Google Compute Engine label restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions) apply. Label names that start with "goog-" or "google-" are reserved.
func (o AllocationPolicyResponseOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v AllocationPolicyResponse) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// Location where compute resources should be allocated for the Job.
func (o AllocationPolicyResponseOutput) Location() LocationPolicyResponseOutput {
	return o.ApplyT(func(v AllocationPolicyResponse) LocationPolicyResponse { return v.Location }).(LocationPolicyResponseOutput)
}

// The network policy. If you define an instance template in the InstancePolicyOrTemplate field, Batch will use the network settings in the instance template instead of this field.
func (o AllocationPolicyResponseOutput) Network() NetworkPolicyResponseOutput {
	return o.ApplyT(func(v AllocationPolicyResponse) NetworkPolicyResponse { return v.Network }).(NetworkPolicyResponseOutput)
}

// The placement policy.
func (o AllocationPolicyResponseOutput) Placement() PlacementPolicyResponseOutput {
	return o.ApplyT(func(v AllocationPolicyResponse) PlacementPolicyResponse { return v.Placement }).(PlacementPolicyResponseOutput)
}

// Service account that VMs will run as.
func (o AllocationPolicyResponseOutput) ServiceAccount() ServiceAccountResponseOutput {
	return o.ApplyT(func(v AllocationPolicyResponse) ServiceAccountResponse { return v.ServiceAccount }).(ServiceAccountResponseOutput)
}

// A new or an existing persistent disk (PD) or a local ssd attached to a VM instance.
type AttachedDisk struct {
	// Device name that the guest operating system will see. It is used by Runnable.volumes field to mount disks. So please specify the device_name if you want Batch to help mount the disk, and it should match the device_name field in volumes.
	DeviceName *string `pulumi:"deviceName"`
	// Name of an existing PD.
	ExistingDisk *string `pulumi:"existingDisk"`
	NewDisk      *Disk   `pulumi:"newDisk"`
}

// AttachedDiskInput is an input type that accepts AttachedDiskArgs and AttachedDiskOutput values.
// You can construct a concrete instance of `AttachedDiskInput` via:
//
//	AttachedDiskArgs{...}
type AttachedDiskInput interface {
	pulumi.Input

	ToAttachedDiskOutput() AttachedDiskOutput
	ToAttachedDiskOutputWithContext(context.Context) AttachedDiskOutput
}

// A new or an existing persistent disk (PD) or a local ssd attached to a VM instance.
type AttachedDiskArgs struct {
	// Device name that the guest operating system will see. It is used by Runnable.volumes field to mount disks. So please specify the device_name if you want Batch to help mount the disk, and it should match the device_name field in volumes.
	DeviceName pulumi.StringPtrInput `pulumi:"deviceName"`
	// Name of an existing PD.
	ExistingDisk pulumi.StringPtrInput `pulumi:"existingDisk"`
	NewDisk      DiskPtrInput          `pulumi:"newDisk"`
}

func (AttachedDiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AttachedDisk)(nil)).Elem()
}

func (i AttachedDiskArgs) ToAttachedDiskOutput() AttachedDiskOutput {
	return i.ToAttachedDiskOutputWithContext(context.Background())
}

func (i AttachedDiskArgs) ToAttachedDiskOutputWithContext(ctx context.Context) AttachedDiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttachedDiskOutput)
}

// AttachedDiskArrayInput is an input type that accepts AttachedDiskArray and AttachedDiskArrayOutput values.
// You can construct a concrete instance of `AttachedDiskArrayInput` via:
//
//	AttachedDiskArray{ AttachedDiskArgs{...} }
type AttachedDiskArrayInput interface {
	pulumi.Input

	ToAttachedDiskArrayOutput() AttachedDiskArrayOutput
	ToAttachedDiskArrayOutputWithContext(context.Context) AttachedDiskArrayOutput
}

type AttachedDiskArray []AttachedDiskInput

func (AttachedDiskArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AttachedDisk)(nil)).Elem()
}

func (i AttachedDiskArray) ToAttachedDiskArrayOutput() AttachedDiskArrayOutput {
	return i.ToAttachedDiskArrayOutputWithContext(context.Background())
}

func (i AttachedDiskArray) ToAttachedDiskArrayOutputWithContext(ctx context.Context) AttachedDiskArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttachedDiskArrayOutput)
}

// A new or an existing persistent disk (PD) or a local ssd attached to a VM instance.
type AttachedDiskOutput struct{ *pulumi.OutputState }

func (AttachedDiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AttachedDisk)(nil)).Elem()
}

func (o AttachedDiskOutput) ToAttachedDiskOutput() AttachedDiskOutput {
	return o
}

func (o AttachedDiskOutput) ToAttachedDiskOutputWithContext(ctx context.Context) AttachedDiskOutput {
	return o
}

// Device name that the guest operating system will see. It is used by Runnable.volumes field to mount disks. So please specify the device_name if you want Batch to help mount the disk, and it should match the device_name field in volumes.
func (o AttachedDiskOutput) DeviceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AttachedDisk) *string { return v.DeviceName }).(pulumi.StringPtrOutput)
}

// Name of an existing PD.
func (o AttachedDiskOutput) ExistingDisk() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AttachedDisk) *string { return v.ExistingDisk }).(pulumi.StringPtrOutput)
}

func (o AttachedDiskOutput) NewDisk() DiskPtrOutput {
	return o.ApplyT(func(v AttachedDisk) *Disk { return v.NewDisk }).(DiskPtrOutput)
}

type AttachedDiskArrayOutput struct{ *pulumi.OutputState }

func (AttachedDiskArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AttachedDisk)(nil)).Elem()
}

func (o AttachedDiskArrayOutput) ToAttachedDiskArrayOutput() AttachedDiskArrayOutput {
	return o
}

func (o AttachedDiskArrayOutput) ToAttachedDiskArrayOutputWithContext(ctx context.Context) AttachedDiskArrayOutput {
	return o
}

func (o AttachedDiskArrayOutput) Index(i pulumi.IntInput) AttachedDiskOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AttachedDisk {
		return vs[0].([]AttachedDisk)[vs[1].(int)]
	}).(AttachedDiskOutput)
}

// A new or an existing persistent disk (PD) or a local ssd attached to a VM instance.
type AttachedDiskResponse struct {
	// Device name that the guest operating system will see. It is used by Runnable.volumes field to mount disks. So please specify the device_name if you want Batch to help mount the disk, and it should match the device_name field in volumes.
	DeviceName string `pulumi:"deviceName"`
	// Name of an existing PD.
	ExistingDisk string       `pulumi:"existingDisk"`
	NewDisk      DiskResponse `pulumi:"newDisk"`
}

// A new or an existing persistent disk (PD) or a local ssd attached to a VM instance.
type AttachedDiskResponseOutput struct{ *pulumi.OutputState }

func (AttachedDiskResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AttachedDiskResponse)(nil)).Elem()
}

func (o AttachedDiskResponseOutput) ToAttachedDiskResponseOutput() AttachedDiskResponseOutput {
	return o
}

func (o AttachedDiskResponseOutput) ToAttachedDiskResponseOutputWithContext(ctx context.Context) AttachedDiskResponseOutput {
	return o
}

// Device name that the guest operating system will see. It is used by Runnable.volumes field to mount disks. So please specify the device_name if you want Batch to help mount the disk, and it should match the device_name field in volumes.
func (o AttachedDiskResponseOutput) DeviceName() pulumi.StringOutput {
	return o.ApplyT(func(v AttachedDiskResponse) string { return v.DeviceName }).(pulumi.StringOutput)
}

// Name of an existing PD.
func (o AttachedDiskResponseOutput) ExistingDisk() pulumi.StringOutput {
	return o.ApplyT(func(v AttachedDiskResponse) string { return v.ExistingDisk }).(pulumi.StringOutput)
}

func (o AttachedDiskResponseOutput) NewDisk() DiskResponseOutput {
	return o.ApplyT(func(v AttachedDiskResponse) DiskResponse { return v.NewDisk }).(DiskResponseOutput)
}

type AttachedDiskResponseArrayOutput struct{ *pulumi.OutputState }

func (AttachedDiskResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AttachedDiskResponse)(nil)).Elem()
}

func (o AttachedDiskResponseArrayOutput) ToAttachedDiskResponseArrayOutput() AttachedDiskResponseArrayOutput {
	return o
}

func (o AttachedDiskResponseArrayOutput) ToAttachedDiskResponseArrayOutputWithContext(ctx context.Context) AttachedDiskResponseArrayOutput {
	return o
}

func (o AttachedDiskResponseArrayOutput) Index(i pulumi.IntInput) AttachedDiskResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AttachedDiskResponse {
		return vs[0].([]AttachedDiskResponse)[vs[1].(int)]
	}).(AttachedDiskResponseOutput)
}

// Barrier runnable blocks until all tasks in a taskgroup reach it.
type Barrier struct {
	// Barriers are identified by their index in runnable list. Names are not required, but if present should be an identifier.
	Name *string `pulumi:"name"`
}

// BarrierInput is an input type that accepts BarrierArgs and BarrierOutput values.
// You can construct a concrete instance of `BarrierInput` via:
//
//	BarrierArgs{...}
type BarrierInput interface {
	pulumi.Input

	ToBarrierOutput() BarrierOutput
	ToBarrierOutputWithContext(context.Context) BarrierOutput
}

// Barrier runnable blocks until all tasks in a taskgroup reach it.
type BarrierArgs struct {
	// Barriers are identified by their index in runnable list. Names are not required, but if present should be an identifier.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (BarrierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Barrier)(nil)).Elem()
}

func (i BarrierArgs) ToBarrierOutput() BarrierOutput {
	return i.ToBarrierOutputWithContext(context.Background())
}

func (i BarrierArgs) ToBarrierOutputWithContext(ctx context.Context) BarrierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BarrierOutput)
}

func (i BarrierArgs) ToBarrierPtrOutput() BarrierPtrOutput {
	return i.ToBarrierPtrOutputWithContext(context.Background())
}

func (i BarrierArgs) ToBarrierPtrOutputWithContext(ctx context.Context) BarrierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BarrierOutput).ToBarrierPtrOutputWithContext(ctx)
}

// BarrierPtrInput is an input type that accepts BarrierArgs, BarrierPtr and BarrierPtrOutput values.
// You can construct a concrete instance of `BarrierPtrInput` via:
//
//	        BarrierArgs{...}
//
//	or:
//
//	        nil
type BarrierPtrInput interface {
	pulumi.Input

	ToBarrierPtrOutput() BarrierPtrOutput
	ToBarrierPtrOutputWithContext(context.Context) BarrierPtrOutput
}

type barrierPtrType BarrierArgs

func BarrierPtr(v *BarrierArgs) BarrierPtrInput {
	return (*barrierPtrType)(v)
}

func (*barrierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Barrier)(nil)).Elem()
}

func (i *barrierPtrType) ToBarrierPtrOutput() BarrierPtrOutput {
	return i.ToBarrierPtrOutputWithContext(context.Background())
}

func (i *barrierPtrType) ToBarrierPtrOutputWithContext(ctx context.Context) BarrierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BarrierPtrOutput)
}

// Barrier runnable blocks until all tasks in a taskgroup reach it.
type BarrierOutput struct{ *pulumi.OutputState }

func (BarrierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Barrier)(nil)).Elem()
}

func (o BarrierOutput) ToBarrierOutput() BarrierOutput {
	return o
}

func (o BarrierOutput) ToBarrierOutputWithContext(ctx context.Context) BarrierOutput {
	return o
}

func (o BarrierOutput) ToBarrierPtrOutput() BarrierPtrOutput {
	return o.ToBarrierPtrOutputWithContext(context.Background())
}

func (o BarrierOutput) ToBarrierPtrOutputWithContext(ctx context.Context) BarrierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Barrier) *Barrier {
		return &v
	}).(BarrierPtrOutput)
}

// Barriers are identified by their index in runnable list. Names are not required, but if present should be an identifier.
func (o BarrierOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Barrier) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type BarrierPtrOutput struct{ *pulumi.OutputState }

func (BarrierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Barrier)(nil)).Elem()
}

func (o BarrierPtrOutput) ToBarrierPtrOutput() BarrierPtrOutput {
	return o
}

func (o BarrierPtrOutput) ToBarrierPtrOutputWithContext(ctx context.Context) BarrierPtrOutput {
	return o
}

func (o BarrierPtrOutput) Elem() BarrierOutput {
	return o.ApplyT(func(v *Barrier) Barrier {
		if v != nil {
			return *v
		}
		var ret Barrier
		return ret
	}).(BarrierOutput)
}

// Barriers are identified by their index in runnable list. Names are not required, but if present should be an identifier.
func (o BarrierPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Barrier) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Barrier runnable blocks until all tasks in a taskgroup reach it.
type BarrierResponse struct {
	// Barriers are identified by their index in runnable list. Names are not required, but if present should be an identifier.
	Name string `pulumi:"name"`
}

// Barrier runnable blocks until all tasks in a taskgroup reach it.
type BarrierResponseOutput struct{ *pulumi.OutputState }

func (BarrierResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BarrierResponse)(nil)).Elem()
}

func (o BarrierResponseOutput) ToBarrierResponseOutput() BarrierResponseOutput {
	return o
}

func (o BarrierResponseOutput) ToBarrierResponseOutputWithContext(ctx context.Context) BarrierResponseOutput {
	return o
}

// Barriers are identified by their index in runnable list. Names are not required, but if present should be an identifier.
func (o BarrierResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v BarrierResponse) string { return v.Name }).(pulumi.StringOutput)
}

// CloudLoggingOption contains additional settings for cloud logging generated by Batch job.
type CloudLoggingOption struct {
}

// CloudLoggingOptionInput is an input type that accepts CloudLoggingOptionArgs and CloudLoggingOptionOutput values.
// You can construct a concrete instance of `CloudLoggingOptionInput` via:
//
//	CloudLoggingOptionArgs{...}
type CloudLoggingOptionInput interface {
	pulumi.Input

	ToCloudLoggingOptionOutput() CloudLoggingOptionOutput
	ToCloudLoggingOptionOutputWithContext(context.Context) CloudLoggingOptionOutput
}

// CloudLoggingOption contains additional settings for cloud logging generated by Batch job.
type CloudLoggingOptionArgs struct {
}

func (CloudLoggingOptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudLoggingOption)(nil)).Elem()
}

func (i CloudLoggingOptionArgs) ToCloudLoggingOptionOutput() CloudLoggingOptionOutput {
	return i.ToCloudLoggingOptionOutputWithContext(context.Background())
}

func (i CloudLoggingOptionArgs) ToCloudLoggingOptionOutputWithContext(ctx context.Context) CloudLoggingOptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudLoggingOptionOutput)
}

func (i CloudLoggingOptionArgs) ToCloudLoggingOptionPtrOutput() CloudLoggingOptionPtrOutput {
	return i.ToCloudLoggingOptionPtrOutputWithContext(context.Background())
}

func (i CloudLoggingOptionArgs) ToCloudLoggingOptionPtrOutputWithContext(ctx context.Context) CloudLoggingOptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudLoggingOptionOutput).ToCloudLoggingOptionPtrOutputWithContext(ctx)
}

// CloudLoggingOptionPtrInput is an input type that accepts CloudLoggingOptionArgs, CloudLoggingOptionPtr and CloudLoggingOptionPtrOutput values.
// You can construct a concrete instance of `CloudLoggingOptionPtrInput` via:
//
//	        CloudLoggingOptionArgs{...}
//
//	or:
//
//	        nil
type CloudLoggingOptionPtrInput interface {
	pulumi.Input

	ToCloudLoggingOptionPtrOutput() CloudLoggingOptionPtrOutput
	ToCloudLoggingOptionPtrOutputWithContext(context.Context) CloudLoggingOptionPtrOutput
}

type cloudLoggingOptionPtrType CloudLoggingOptionArgs

func CloudLoggingOptionPtr(v *CloudLoggingOptionArgs) CloudLoggingOptionPtrInput {
	return (*cloudLoggingOptionPtrType)(v)
}

func (*cloudLoggingOptionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudLoggingOption)(nil)).Elem()
}

func (i *cloudLoggingOptionPtrType) ToCloudLoggingOptionPtrOutput() CloudLoggingOptionPtrOutput {
	return i.ToCloudLoggingOptionPtrOutputWithContext(context.Background())
}

func (i *cloudLoggingOptionPtrType) ToCloudLoggingOptionPtrOutputWithContext(ctx context.Context) CloudLoggingOptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudLoggingOptionPtrOutput)
}

// CloudLoggingOption contains additional settings for cloud logging generated by Batch job.
type CloudLoggingOptionOutput struct{ *pulumi.OutputState }

func (CloudLoggingOptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudLoggingOption)(nil)).Elem()
}

func (o CloudLoggingOptionOutput) ToCloudLoggingOptionOutput() CloudLoggingOptionOutput {
	return o
}

func (o CloudLoggingOptionOutput) ToCloudLoggingOptionOutputWithContext(ctx context.Context) CloudLoggingOptionOutput {
	return o
}

func (o CloudLoggingOptionOutput) ToCloudLoggingOptionPtrOutput() CloudLoggingOptionPtrOutput {
	return o.ToCloudLoggingOptionPtrOutputWithContext(context.Background())
}

func (o CloudLoggingOptionOutput) ToCloudLoggingOptionPtrOutputWithContext(ctx context.Context) CloudLoggingOptionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CloudLoggingOption) *CloudLoggingOption {
		return &v
	}).(CloudLoggingOptionPtrOutput)
}

type CloudLoggingOptionPtrOutput struct{ *pulumi.OutputState }

func (CloudLoggingOptionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudLoggingOption)(nil)).Elem()
}

func (o CloudLoggingOptionPtrOutput) ToCloudLoggingOptionPtrOutput() CloudLoggingOptionPtrOutput {
	return o
}

func (o CloudLoggingOptionPtrOutput) ToCloudLoggingOptionPtrOutputWithContext(ctx context.Context) CloudLoggingOptionPtrOutput {
	return o
}

func (o CloudLoggingOptionPtrOutput) Elem() CloudLoggingOptionOutput {
	return o.ApplyT(func(v *CloudLoggingOption) CloudLoggingOption {
		if v != nil {
			return *v
		}
		var ret CloudLoggingOption
		return ret
	}).(CloudLoggingOptionOutput)
}

// CloudLoggingOption contains additional settings for cloud logging generated by Batch job.
type CloudLoggingOptionResponse struct {
}

// CloudLoggingOption contains additional settings for cloud logging generated by Batch job.
type CloudLoggingOptionResponseOutput struct{ *pulumi.OutputState }

func (CloudLoggingOptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudLoggingOptionResponse)(nil)).Elem()
}

func (o CloudLoggingOptionResponseOutput) ToCloudLoggingOptionResponseOutput() CloudLoggingOptionResponseOutput {
	return o
}

func (o CloudLoggingOptionResponseOutput) ToCloudLoggingOptionResponseOutputWithContext(ctx context.Context) CloudLoggingOptionResponseOutput {
	return o
}

// Compute resource requirements. ComputeResource defines the amount of resources required for each task. Make sure your tasks have enough resources to successfully run. If you also define the types of resources for a job to use with the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure both fields are compatible with each other.
type ComputeResource struct {
	// Extra boot disk size in MiB for each task.
	BootDiskMib *string `pulumi:"bootDiskMib"`
	// The milliCPU count. `cpuMilli` defines the amount of CPU resources per task in milliCPU units. For example, `1000` corresponds to 1 vCPU per task. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the CPU resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 2 vCPUs each, you are recommended to set `cpuMilli` no more than `2000`, or you are recommended to run two tasks on the same VM if you set `cpuMilli` to `1000` or less.
	CpuMilli *string `pulumi:"cpuMilli"`
	// Memory in MiB. `memoryMib` defines the amount of memory per task in MiB units. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the memory resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 8 GiB each, you are recommended to set `memoryMib` to no more than `8192`, or you are recommended to run two tasks on the same VM if you set `memoryMib` to `4096` or less.
	MemoryMib *string `pulumi:"memoryMib"`
}

// ComputeResourceInput is an input type that accepts ComputeResourceArgs and ComputeResourceOutput values.
// You can construct a concrete instance of `ComputeResourceInput` via:
//
//	ComputeResourceArgs{...}
type ComputeResourceInput interface {
	pulumi.Input

	ToComputeResourceOutput() ComputeResourceOutput
	ToComputeResourceOutputWithContext(context.Context) ComputeResourceOutput
}

// Compute resource requirements. ComputeResource defines the amount of resources required for each task. Make sure your tasks have enough resources to successfully run. If you also define the types of resources for a job to use with the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure both fields are compatible with each other.
type ComputeResourceArgs struct {
	// Extra boot disk size in MiB for each task.
	BootDiskMib pulumi.StringPtrInput `pulumi:"bootDiskMib"`
	// The milliCPU count. `cpuMilli` defines the amount of CPU resources per task in milliCPU units. For example, `1000` corresponds to 1 vCPU per task. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the CPU resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 2 vCPUs each, you are recommended to set `cpuMilli` no more than `2000`, or you are recommended to run two tasks on the same VM if you set `cpuMilli` to `1000` or less.
	CpuMilli pulumi.StringPtrInput `pulumi:"cpuMilli"`
	// Memory in MiB. `memoryMib` defines the amount of memory per task in MiB units. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the memory resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 8 GiB each, you are recommended to set `memoryMib` to no more than `8192`, or you are recommended to run two tasks on the same VM if you set `memoryMib` to `4096` or less.
	MemoryMib pulumi.StringPtrInput `pulumi:"memoryMib"`
}

func (ComputeResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ComputeResource)(nil)).Elem()
}

func (i ComputeResourceArgs) ToComputeResourceOutput() ComputeResourceOutput {
	return i.ToComputeResourceOutputWithContext(context.Background())
}

func (i ComputeResourceArgs) ToComputeResourceOutputWithContext(ctx context.Context) ComputeResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeResourceOutput)
}

func (i ComputeResourceArgs) ToComputeResourcePtrOutput() ComputeResourcePtrOutput {
	return i.ToComputeResourcePtrOutputWithContext(context.Background())
}

func (i ComputeResourceArgs) ToComputeResourcePtrOutputWithContext(ctx context.Context) ComputeResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeResourceOutput).ToComputeResourcePtrOutputWithContext(ctx)
}

// ComputeResourcePtrInput is an input type that accepts ComputeResourceArgs, ComputeResourcePtr and ComputeResourcePtrOutput values.
// You can construct a concrete instance of `ComputeResourcePtrInput` via:
//
//	        ComputeResourceArgs{...}
//
//	or:
//
//	        nil
type ComputeResourcePtrInput interface {
	pulumi.Input

	ToComputeResourcePtrOutput() ComputeResourcePtrOutput
	ToComputeResourcePtrOutputWithContext(context.Context) ComputeResourcePtrOutput
}

type computeResourcePtrType ComputeResourceArgs

func ComputeResourcePtr(v *ComputeResourceArgs) ComputeResourcePtrInput {
	return (*computeResourcePtrType)(v)
}

func (*computeResourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ComputeResource)(nil)).Elem()
}

func (i *computeResourcePtrType) ToComputeResourcePtrOutput() ComputeResourcePtrOutput {
	return i.ToComputeResourcePtrOutputWithContext(context.Background())
}

func (i *computeResourcePtrType) ToComputeResourcePtrOutputWithContext(ctx context.Context) ComputeResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeResourcePtrOutput)
}

// Compute resource requirements. ComputeResource defines the amount of resources required for each task. Make sure your tasks have enough resources to successfully run. If you also define the types of resources for a job to use with the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure both fields are compatible with each other.
type ComputeResourceOutput struct{ *pulumi.OutputState }

func (ComputeResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ComputeResource)(nil)).Elem()
}

func (o ComputeResourceOutput) ToComputeResourceOutput() ComputeResourceOutput {
	return o
}

func (o ComputeResourceOutput) ToComputeResourceOutputWithContext(ctx context.Context) ComputeResourceOutput {
	return o
}

func (o ComputeResourceOutput) ToComputeResourcePtrOutput() ComputeResourcePtrOutput {
	return o.ToComputeResourcePtrOutputWithContext(context.Background())
}

func (o ComputeResourceOutput) ToComputeResourcePtrOutputWithContext(ctx context.Context) ComputeResourcePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ComputeResource) *ComputeResource {
		return &v
	}).(ComputeResourcePtrOutput)
}

// Extra boot disk size in MiB for each task.
func (o ComputeResourceOutput) BootDiskMib() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComputeResource) *string { return v.BootDiskMib }).(pulumi.StringPtrOutput)
}

// The milliCPU count. `cpuMilli` defines the amount of CPU resources per task in milliCPU units. For example, `1000` corresponds to 1 vCPU per task. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the CPU resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 2 vCPUs each, you are recommended to set `cpuMilli` no more than `2000`, or you are recommended to run two tasks on the same VM if you set `cpuMilli` to `1000` or less.
func (o ComputeResourceOutput) CpuMilli() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComputeResource) *string { return v.CpuMilli }).(pulumi.StringPtrOutput)
}

// Memory in MiB. `memoryMib` defines the amount of memory per task in MiB units. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the memory resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 8 GiB each, you are recommended to set `memoryMib` to no more than `8192`, or you are recommended to run two tasks on the same VM if you set `memoryMib` to `4096` or less.
func (o ComputeResourceOutput) MemoryMib() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ComputeResource) *string { return v.MemoryMib }).(pulumi.StringPtrOutput)
}

type ComputeResourcePtrOutput struct{ *pulumi.OutputState }

func (ComputeResourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ComputeResource)(nil)).Elem()
}

func (o ComputeResourcePtrOutput) ToComputeResourcePtrOutput() ComputeResourcePtrOutput {
	return o
}

func (o ComputeResourcePtrOutput) ToComputeResourcePtrOutputWithContext(ctx context.Context) ComputeResourcePtrOutput {
	return o
}

func (o ComputeResourcePtrOutput) Elem() ComputeResourceOutput {
	return o.ApplyT(func(v *ComputeResource) ComputeResource {
		if v != nil {
			return *v
		}
		var ret ComputeResource
		return ret
	}).(ComputeResourceOutput)
}

// Extra boot disk size in MiB for each task.
func (o ComputeResourcePtrOutput) BootDiskMib() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ComputeResource) *string {
		if v == nil {
			return nil
		}
		return v.BootDiskMib
	}).(pulumi.StringPtrOutput)
}

// The milliCPU count. `cpuMilli` defines the amount of CPU resources per task in milliCPU units. For example, `1000` corresponds to 1 vCPU per task. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the CPU resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 2 vCPUs each, you are recommended to set `cpuMilli` no more than `2000`, or you are recommended to run two tasks on the same VM if you set `cpuMilli` to `1000` or less.
func (o ComputeResourcePtrOutput) CpuMilli() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ComputeResource) *string {
		if v == nil {
			return nil
		}
		return v.CpuMilli
	}).(pulumi.StringPtrOutput)
}

// Memory in MiB. `memoryMib` defines the amount of memory per task in MiB units. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the memory resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 8 GiB each, you are recommended to set `memoryMib` to no more than `8192`, or you are recommended to run two tasks on the same VM if you set `memoryMib` to `4096` or less.
func (o ComputeResourcePtrOutput) MemoryMib() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ComputeResource) *string {
		if v == nil {
			return nil
		}
		return v.MemoryMib
	}).(pulumi.StringPtrOutput)
}

// Compute resource requirements. ComputeResource defines the amount of resources required for each task. Make sure your tasks have enough resources to successfully run. If you also define the types of resources for a job to use with the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure both fields are compatible with each other.
type ComputeResourceResponse struct {
	// Extra boot disk size in MiB for each task.
	BootDiskMib string `pulumi:"bootDiskMib"`
	// The milliCPU count. `cpuMilli` defines the amount of CPU resources per task in milliCPU units. For example, `1000` corresponds to 1 vCPU per task. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the CPU resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 2 vCPUs each, you are recommended to set `cpuMilli` no more than `2000`, or you are recommended to run two tasks on the same VM if you set `cpuMilli` to `1000` or less.
	CpuMilli string `pulumi:"cpuMilli"`
	// Memory in MiB. `memoryMib` defines the amount of memory per task in MiB units. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the memory resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 8 GiB each, you are recommended to set `memoryMib` to no more than `8192`, or you are recommended to run two tasks on the same VM if you set `memoryMib` to `4096` or less.
	MemoryMib string `pulumi:"memoryMib"`
}

// Compute resource requirements. ComputeResource defines the amount of resources required for each task. Make sure your tasks have enough resources to successfully run. If you also define the types of resources for a job to use with the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure both fields are compatible with each other.
type ComputeResourceResponseOutput struct{ *pulumi.OutputState }

func (ComputeResourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ComputeResourceResponse)(nil)).Elem()
}

func (o ComputeResourceResponseOutput) ToComputeResourceResponseOutput() ComputeResourceResponseOutput {
	return o
}

func (o ComputeResourceResponseOutput) ToComputeResourceResponseOutputWithContext(ctx context.Context) ComputeResourceResponseOutput {
	return o
}

// Extra boot disk size in MiB for each task.
func (o ComputeResourceResponseOutput) BootDiskMib() pulumi.StringOutput {
	return o.ApplyT(func(v ComputeResourceResponse) string { return v.BootDiskMib }).(pulumi.StringOutput)
}

// The milliCPU count. `cpuMilli` defines the amount of CPU resources per task in milliCPU units. For example, `1000` corresponds to 1 vCPU per task. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the CPU resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 2 vCPUs each, you are recommended to set `cpuMilli` no more than `2000`, or you are recommended to run two tasks on the same VM if you set `cpuMilli` to `1000` or less.
func (o ComputeResourceResponseOutput) CpuMilli() pulumi.StringOutput {
	return o.ApplyT(func(v ComputeResourceResponse) string { return v.CpuMilli }).(pulumi.StringOutput)
}

// Memory in MiB. `memoryMib` defines the amount of memory per task in MiB units. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the memory resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 8 GiB each, you are recommended to set `memoryMib` to no more than `8192`, or you are recommended to run two tasks on the same VM if you set `memoryMib` to `4096` or less.
func (o ComputeResourceResponseOutput) MemoryMib() pulumi.StringOutput {
	return o.ApplyT(func(v ComputeResourceResponse) string { return v.MemoryMib }).(pulumi.StringOutput)
}

// Container runnable.
type Container struct {
	// If set to true, external network access to and from container will be blocked, containers that are with block_external_network as true can still communicate with each other, network cannot be specified in the `container.options` field.
	BlockExternalNetwork *bool `pulumi:"blockExternalNetwork"`
	// Overrides the `CMD` specified in the container. If there is an ENTRYPOINT (either in the container image or with the entrypoint field below) then commands are appended as arguments to the ENTRYPOINT.
	Commands []string `pulumi:"commands"`
	// Overrides the `ENTRYPOINT` specified in the container.
	Entrypoint *string `pulumi:"entrypoint"`
	// The URI to pull the container image from.
	ImageUri *string `pulumi:"imageUri"`
	// Arbitrary additional options to include in the "docker run" command when running this container, e.g. "--network host".
	Options *string `pulumi:"options"`
	// Optional password for logging in to a docker registry. If password matches `projects/*/secrets/*/versions/*` then Batch will read the password from the Secret Manager;
	Password *string `pulumi:"password"`
	// Optional username for logging in to a docker registry. If username matches `projects/*/secrets/*/versions/*` then Batch will read the username from the Secret Manager.
	Username *string `pulumi:"username"`
	// Volumes to mount (bind mount) from the host machine files or directories into the container, formatted to match docker run's --volume option, e.g. /foo:/bar, or /foo:/bar:ro If the `TaskSpec.Volumes` field is specified but this field is not, Batch will mount each volume from the host machine to the container with the same mount path by default. In this case, the default mount option for containers will be read-only (ro) for existing persistent disks and read-write (rw) for other volume types, regardless of the original mount options specified in `TaskSpec.Volumes`. If you need different mount settings, you can explicitly configure them in this field.
	Volumes []string `pulumi:"volumes"`
}

// ContainerInput is an input type that accepts ContainerArgs and ContainerOutput values.
// You can construct a concrete instance of `ContainerInput` via:
//
//	ContainerArgs{...}
type ContainerInput interface {
	pulumi.Input

	ToContainerOutput() ContainerOutput
	ToContainerOutputWithContext(context.Context) ContainerOutput
}

// Container runnable.
type ContainerArgs struct {
	// If set to true, external network access to and from container will be blocked, containers that are with block_external_network as true can still communicate with each other, network cannot be specified in the `container.options` field.
	BlockExternalNetwork pulumi.BoolPtrInput `pulumi:"blockExternalNetwork"`
	// Overrides the `CMD` specified in the container. If there is an ENTRYPOINT (either in the container image or with the entrypoint field below) then commands are appended as arguments to the ENTRYPOINT.
	Commands pulumi.StringArrayInput `pulumi:"commands"`
	// Overrides the `ENTRYPOINT` specified in the container.
	Entrypoint pulumi.StringPtrInput `pulumi:"entrypoint"`
	// The URI to pull the container image from.
	ImageUri pulumi.StringPtrInput `pulumi:"imageUri"`
	// Arbitrary additional options to include in the "docker run" command when running this container, e.g. "--network host".
	Options pulumi.StringPtrInput `pulumi:"options"`
	// Optional password for logging in to a docker registry. If password matches `projects/*/secrets/*/versions/*` then Batch will read the password from the Secret Manager;
	Password pulumi.StringPtrInput `pulumi:"password"`
	// Optional username for logging in to a docker registry. If username matches `projects/*/secrets/*/versions/*` then Batch will read the username from the Secret Manager.
	Username pulumi.StringPtrInput `pulumi:"username"`
	// Volumes to mount (bind mount) from the host machine files or directories into the container, formatted to match docker run's --volume option, e.g. /foo:/bar, or /foo:/bar:ro If the `TaskSpec.Volumes` field is specified but this field is not, Batch will mount each volume from the host machine to the container with the same mount path by default. In this case, the default mount option for containers will be read-only (ro) for existing persistent disks and read-write (rw) for other volume types, regardless of the original mount options specified in `TaskSpec.Volumes`. If you need different mount settings, you can explicitly configure them in this field.
	Volumes pulumi.StringArrayInput `pulumi:"volumes"`
}

func (ContainerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Container)(nil)).Elem()
}

func (i ContainerArgs) ToContainerOutput() ContainerOutput {
	return i.ToContainerOutputWithContext(context.Background())
}

func (i ContainerArgs) ToContainerOutputWithContext(ctx context.Context) ContainerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerOutput)
}

func (i ContainerArgs) ToContainerPtrOutput() ContainerPtrOutput {
	return i.ToContainerPtrOutputWithContext(context.Background())
}

func (i ContainerArgs) ToContainerPtrOutputWithContext(ctx context.Context) ContainerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerOutput).ToContainerPtrOutputWithContext(ctx)
}

// ContainerPtrInput is an input type that accepts ContainerArgs, ContainerPtr and ContainerPtrOutput values.
// You can construct a concrete instance of `ContainerPtrInput` via:
//
//	        ContainerArgs{...}
//
//	or:
//
//	        nil
type ContainerPtrInput interface {
	pulumi.Input

	ToContainerPtrOutput() ContainerPtrOutput
	ToContainerPtrOutputWithContext(context.Context) ContainerPtrOutput
}

type containerPtrType ContainerArgs

func ContainerPtr(v *ContainerArgs) ContainerPtrInput {
	return (*containerPtrType)(v)
}

func (*containerPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Container)(nil)).Elem()
}

func (i *containerPtrType) ToContainerPtrOutput() ContainerPtrOutput {
	return i.ToContainerPtrOutputWithContext(context.Background())
}

func (i *containerPtrType) ToContainerPtrOutputWithContext(ctx context.Context) ContainerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerPtrOutput)
}

// Container runnable.
type ContainerOutput struct{ *pulumi.OutputState }

func (ContainerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Container)(nil)).Elem()
}

func (o ContainerOutput) ToContainerOutput() ContainerOutput {
	return o
}

func (o ContainerOutput) ToContainerOutputWithContext(ctx context.Context) ContainerOutput {
	return o
}

func (o ContainerOutput) ToContainerPtrOutput() ContainerPtrOutput {
	return o.ToContainerPtrOutputWithContext(context.Background())
}

func (o ContainerOutput) ToContainerPtrOutputWithContext(ctx context.Context) ContainerPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Container) *Container {
		return &v
	}).(ContainerPtrOutput)
}

// If set to true, external network access to and from container will be blocked, containers that are with block_external_network as true can still communicate with each other, network cannot be specified in the `container.options` field.
func (o ContainerOutput) BlockExternalNetwork() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Container) *bool { return v.BlockExternalNetwork }).(pulumi.BoolPtrOutput)
}

// Overrides the `CMD` specified in the container. If there is an ENTRYPOINT (either in the container image or with the entrypoint field below) then commands are appended as arguments to the ENTRYPOINT.
func (o ContainerOutput) Commands() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Container) []string { return v.Commands }).(pulumi.StringArrayOutput)
}

// Overrides the `ENTRYPOINT` specified in the container.
func (o ContainerOutput) Entrypoint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Container) *string { return v.Entrypoint }).(pulumi.StringPtrOutput)
}

// The URI to pull the container image from.
func (o ContainerOutput) ImageUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Container) *string { return v.ImageUri }).(pulumi.StringPtrOutput)
}

// Arbitrary additional options to include in the "docker run" command when running this container, e.g. "--network host".
func (o ContainerOutput) Options() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Container) *string { return v.Options }).(pulumi.StringPtrOutput)
}

// Optional password for logging in to a docker registry. If password matches `projects/*/secrets/*/versions/*` then Batch will read the password from the Secret Manager;
func (o ContainerOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Container) *string { return v.Password }).(pulumi.StringPtrOutput)
}

// Optional username for logging in to a docker registry. If username matches `projects/*/secrets/*/versions/*` then Batch will read the username from the Secret Manager.
func (o ContainerOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Container) *string { return v.Username }).(pulumi.StringPtrOutput)
}

// Volumes to mount (bind mount) from the host machine files or directories into the container, formatted to match docker run's --volume option, e.g. /foo:/bar, or /foo:/bar:ro If the `TaskSpec.Volumes` field is specified but this field is not, Batch will mount each volume from the host machine to the container with the same mount path by default. In this case, the default mount option for containers will be read-only (ro) for existing persistent disks and read-write (rw) for other volume types, regardless of the original mount options specified in `TaskSpec.Volumes`. If you need different mount settings, you can explicitly configure them in this field.
func (o ContainerOutput) Volumes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Container) []string { return v.Volumes }).(pulumi.StringArrayOutput)
}

type ContainerPtrOutput struct{ *pulumi.OutputState }

func (ContainerPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Container)(nil)).Elem()
}

func (o ContainerPtrOutput) ToContainerPtrOutput() ContainerPtrOutput {
	return o
}

func (o ContainerPtrOutput) ToContainerPtrOutputWithContext(ctx context.Context) ContainerPtrOutput {
	return o
}

func (o ContainerPtrOutput) Elem() ContainerOutput {
	return o.ApplyT(func(v *Container) Container {
		if v != nil {
			return *v
		}
		var ret Container
		return ret
	}).(ContainerOutput)
}

// If set to true, external network access to and from container will be blocked, containers that are with block_external_network as true can still communicate with each other, network cannot be specified in the `container.options` field.
func (o ContainerPtrOutput) BlockExternalNetwork() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Container) *bool {
		if v == nil {
			return nil
		}
		return v.BlockExternalNetwork
	}).(pulumi.BoolPtrOutput)
}

// Overrides the `CMD` specified in the container. If there is an ENTRYPOINT (either in the container image or with the entrypoint field below) then commands are appended as arguments to the ENTRYPOINT.
func (o ContainerPtrOutput) Commands() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Container) []string {
		if v == nil {
			return nil
		}
		return v.Commands
	}).(pulumi.StringArrayOutput)
}

// Overrides the `ENTRYPOINT` specified in the container.
func (o ContainerPtrOutput) Entrypoint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Container) *string {
		if v == nil {
			return nil
		}
		return v.Entrypoint
	}).(pulumi.StringPtrOutput)
}

// The URI to pull the container image from.
func (o ContainerPtrOutput) ImageUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Container) *string {
		if v == nil {
			return nil
		}
		return v.ImageUri
	}).(pulumi.StringPtrOutput)
}

// Arbitrary additional options to include in the "docker run" command when running this container, e.g. "--network host".
func (o ContainerPtrOutput) Options() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Container) *string {
		if v == nil {
			return nil
		}
		return v.Options
	}).(pulumi.StringPtrOutput)
}

// Optional password for logging in to a docker registry. If password matches `projects/*/secrets/*/versions/*` then Batch will read the password from the Secret Manager;
func (o ContainerPtrOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Container) *string {
		if v == nil {
			return nil
		}
		return v.Password
	}).(pulumi.StringPtrOutput)
}

// Optional username for logging in to a docker registry. If username matches `projects/*/secrets/*/versions/*` then Batch will read the username from the Secret Manager.
func (o ContainerPtrOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Container) *string {
		if v == nil {
			return nil
		}
		return v.Username
	}).(pulumi.StringPtrOutput)
}

// Volumes to mount (bind mount) from the host machine files or directories into the container, formatted to match docker run's --volume option, e.g. /foo:/bar, or /foo:/bar:ro If the `TaskSpec.Volumes` field is specified but this field is not, Batch will mount each volume from the host machine to the container with the same mount path by default. In this case, the default mount option for containers will be read-only (ro) for existing persistent disks and read-write (rw) for other volume types, regardless of the original mount options specified in `TaskSpec.Volumes`. If you need different mount settings, you can explicitly configure them in this field.
func (o ContainerPtrOutput) Volumes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Container) []string {
		if v == nil {
			return nil
		}
		return v.Volumes
	}).(pulumi.StringArrayOutput)
}

// Container runnable.
type ContainerResponse struct {
	// If set to true, external network access to and from container will be blocked, containers that are with block_external_network as true can still communicate with each other, network cannot be specified in the `container.options` field.
	BlockExternalNetwork bool `pulumi:"blockExternalNetwork"`
	// Overrides the `CMD` specified in the container. If there is an ENTRYPOINT (either in the container image or with the entrypoint field below) then commands are appended as arguments to the ENTRYPOINT.
	Commands []string `pulumi:"commands"`
	// Overrides the `ENTRYPOINT` specified in the container.
	Entrypoint string `pulumi:"entrypoint"`
	// The URI to pull the container image from.
	ImageUri string `pulumi:"imageUri"`
	// Arbitrary additional options to include in the "docker run" command when running this container, e.g. "--network host".
	Options string `pulumi:"options"`
	// Optional password for logging in to a docker registry. If password matches `projects/*/secrets/*/versions/*` then Batch will read the password from the Secret Manager;
	Password string `pulumi:"password"`
	// Optional username for logging in to a docker registry. If username matches `projects/*/secrets/*/versions/*` then Batch will read the username from the Secret Manager.
	Username string `pulumi:"username"`
	// Volumes to mount (bind mount) from the host machine files or directories into the container, formatted to match docker run's --volume option, e.g. /foo:/bar, or /foo:/bar:ro If the `TaskSpec.Volumes` field is specified but this field is not, Batch will mount each volume from the host machine to the container with the same mount path by default. In this case, the default mount option for containers will be read-only (ro) for existing persistent disks and read-write (rw) for other volume types, regardless of the original mount options specified in `TaskSpec.Volumes`. If you need different mount settings, you can explicitly configure them in this field.
	Volumes []string `pulumi:"volumes"`
}

// Container runnable.
type ContainerResponseOutput struct{ *pulumi.OutputState }

func (ContainerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerResponse)(nil)).Elem()
}

func (o ContainerResponseOutput) ToContainerResponseOutput() ContainerResponseOutput {
	return o
}

func (o ContainerResponseOutput) ToContainerResponseOutputWithContext(ctx context.Context) ContainerResponseOutput {
	return o
}

// If set to true, external network access to and from container will be blocked, containers that are with block_external_network as true can still communicate with each other, network cannot be specified in the `container.options` field.
func (o ContainerResponseOutput) BlockExternalNetwork() pulumi.BoolOutput {
	return o.ApplyT(func(v ContainerResponse) bool { return v.BlockExternalNetwork }).(pulumi.BoolOutput)
}

// Overrides the `CMD` specified in the container. If there is an ENTRYPOINT (either in the container image or with the entrypoint field below) then commands are appended as arguments to the ENTRYPOINT.
func (o ContainerResponseOutput) Commands() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ContainerResponse) []string { return v.Commands }).(pulumi.StringArrayOutput)
}

// Overrides the `ENTRYPOINT` specified in the container.
func (o ContainerResponseOutput) Entrypoint() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerResponse) string { return v.Entrypoint }).(pulumi.StringOutput)
}

// The URI to pull the container image from.
func (o ContainerResponseOutput) ImageUri() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerResponse) string { return v.ImageUri }).(pulumi.StringOutput)
}

// Arbitrary additional options to include in the "docker run" command when running this container, e.g. "--network host".
func (o ContainerResponseOutput) Options() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerResponse) string { return v.Options }).(pulumi.StringOutput)
}

// Optional password for logging in to a docker registry. If password matches `projects/*/secrets/*/versions/*` then Batch will read the password from the Secret Manager;
func (o ContainerResponseOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerResponse) string { return v.Password }).(pulumi.StringOutput)
}

// Optional username for logging in to a docker registry. If username matches `projects/*/secrets/*/versions/*` then Batch will read the username from the Secret Manager.
func (o ContainerResponseOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerResponse) string { return v.Username }).(pulumi.StringOutput)
}

// Volumes to mount (bind mount) from the host machine files or directories into the container, formatted to match docker run's --volume option, e.g. /foo:/bar, or /foo:/bar:ro If the `TaskSpec.Volumes` field is specified but this field is not, Batch will mount each volume from the host machine to the container with the same mount path by default. In this case, the default mount option for containers will be read-only (ro) for existing persistent disks and read-write (rw) for other volume types, regardless of the original mount options specified in `TaskSpec.Volumes`. If you need different mount settings, you can explicitly configure them in this field.
func (o ContainerResponseOutput) Volumes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ContainerResponse) []string { return v.Volumes }).(pulumi.StringArrayOutput)
}

// A new persistent disk or a local ssd. A VM can only have one local SSD setting but multiple local SSD partitions. See https://cloud.google.com/compute/docs/disks#pdspecs and https://cloud.google.com/compute/docs/disks#localssds.
type Disk struct {
	// Local SSDs are available through both "SCSI" and "NVMe" interfaces. If not indicated, "NVMe" will be the default one for local ssds. This field is ignored for persistent disks as the interface is chosen automatically. See https://cloud.google.com/compute/docs/disks/persistent-disks#choose_an_interface.
	DiskInterface *string `pulumi:"diskInterface"`
	// URL for a VM image to use as the data source for this disk. For example, the following are all valid URLs: * Specify the image by its family name: projects/{project}/global/images/family/{image_family} * Specify the image version: projects/{project}/global/images/{image_version} You can also use Batch customized image in short names. The following image values are supported for a boot disk: * `batch-debian`: use Batch Debian images. * `batch-centos`: use Batch CentOS images. * `batch-cos`: use Batch Container-Optimized images. * `batch-hpc-centos`: use Batch HPC CentOS images. * `batch-hpc-rocky`: use Batch HPC Rocky Linux images.
	Image *string `pulumi:"image"`
	// Disk size in GB. **Non-Boot Disk**: If the `type` specifies a persistent disk, this field is ignored if `data_source` is set as `image` or `snapshot`. If the `type` specifies a local SSD, this field should be a multiple of 375 GB, otherwise, the final size will be the next greater multiple of 375 GB. **Boot Disk**: Batch will calculate the boot disk size based on source image and task requirements if you do not speicify the size. If both this field and the `boot_disk_mib` field in task spec's `compute_resource` are defined, Batch will only honor this field. Also, this field should be no smaller than the source disk's size when the `data_source` is set as `snapshot` or `image`. For example, if you set an image as the `data_source` field and the image's default disk size 30 GB, you can only use this field to make the disk larger or equal to 30 GB.
	SizeGb *string `pulumi:"sizeGb"`
	// Name of a snapshot used as the data source. Snapshot is not supported as boot disk now.
	Snapshot *string `pulumi:"snapshot"`
	// Disk type as shown in `gcloud compute disk-types list`. For example, local SSD uses type "local-ssd". Persistent disks and boot disks use "pd-balanced", "pd-extreme", "pd-ssd" or "pd-standard".
	Type *string `pulumi:"type"`
}

// DiskInput is an input type that accepts DiskArgs and DiskOutput values.
// You can construct a concrete instance of `DiskInput` via:
//
//	DiskArgs{...}
type DiskInput interface {
	pulumi.Input

	ToDiskOutput() DiskOutput
	ToDiskOutputWithContext(context.Context) DiskOutput
}

// A new persistent disk or a local ssd. A VM can only have one local SSD setting but multiple local SSD partitions. See https://cloud.google.com/compute/docs/disks#pdspecs and https://cloud.google.com/compute/docs/disks#localssds.
type DiskArgs struct {
	// Local SSDs are available through both "SCSI" and "NVMe" interfaces. If not indicated, "NVMe" will be the default one for local ssds. This field is ignored for persistent disks as the interface is chosen automatically. See https://cloud.google.com/compute/docs/disks/persistent-disks#choose_an_interface.
	DiskInterface pulumi.StringPtrInput `pulumi:"diskInterface"`
	// URL for a VM image to use as the data source for this disk. For example, the following are all valid URLs: * Specify the image by its family name: projects/{project}/global/images/family/{image_family} * Specify the image version: projects/{project}/global/images/{image_version} You can also use Batch customized image in short names. The following image values are supported for a boot disk: * `batch-debian`: use Batch Debian images. * `batch-centos`: use Batch CentOS images. * `batch-cos`: use Batch Container-Optimized images. * `batch-hpc-centos`: use Batch HPC CentOS images. * `batch-hpc-rocky`: use Batch HPC Rocky Linux images.
	Image pulumi.StringPtrInput `pulumi:"image"`
	// Disk size in GB. **Non-Boot Disk**: If the `type` specifies a persistent disk, this field is ignored if `data_source` is set as `image` or `snapshot`. If the `type` specifies a local SSD, this field should be a multiple of 375 GB, otherwise, the final size will be the next greater multiple of 375 GB. **Boot Disk**: Batch will calculate the boot disk size based on source image and task requirements if you do not speicify the size. If both this field and the `boot_disk_mib` field in task spec's `compute_resource` are defined, Batch will only honor this field. Also, this field should be no smaller than the source disk's size when the `data_source` is set as `snapshot` or `image`. For example, if you set an image as the `data_source` field and the image's default disk size 30 GB, you can only use this field to make the disk larger or equal to 30 GB.
	SizeGb pulumi.StringPtrInput `pulumi:"sizeGb"`
	// Name of a snapshot used as the data source. Snapshot is not supported as boot disk now.
	Snapshot pulumi.StringPtrInput `pulumi:"snapshot"`
	// Disk type as shown in `gcloud compute disk-types list`. For example, local SSD uses type "local-ssd". Persistent disks and boot disks use "pd-balanced", "pd-extreme", "pd-ssd" or "pd-standard".
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (DiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Disk)(nil)).Elem()
}

func (i DiskArgs) ToDiskOutput() DiskOutput {
	return i.ToDiskOutputWithContext(context.Background())
}

func (i DiskArgs) ToDiskOutputWithContext(ctx context.Context) DiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiskOutput)
}

func (i DiskArgs) ToDiskPtrOutput() DiskPtrOutput {
	return i.ToDiskPtrOutputWithContext(context.Background())
}

func (i DiskArgs) ToDiskPtrOutputWithContext(ctx context.Context) DiskPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiskOutput).ToDiskPtrOutputWithContext(ctx)
}

// DiskPtrInput is an input type that accepts DiskArgs, DiskPtr and DiskPtrOutput values.
// You can construct a concrete instance of `DiskPtrInput` via:
//
//	        DiskArgs{...}
//
//	or:
//
//	        nil
type DiskPtrInput interface {
	pulumi.Input

	ToDiskPtrOutput() DiskPtrOutput
	ToDiskPtrOutputWithContext(context.Context) DiskPtrOutput
}

type diskPtrType DiskArgs

func DiskPtr(v *DiskArgs) DiskPtrInput {
	return (*diskPtrType)(v)
}

func (*diskPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Disk)(nil)).Elem()
}

func (i *diskPtrType) ToDiskPtrOutput() DiskPtrOutput {
	return i.ToDiskPtrOutputWithContext(context.Background())
}

func (i *diskPtrType) ToDiskPtrOutputWithContext(ctx context.Context) DiskPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiskPtrOutput)
}

// A new persistent disk or a local ssd. A VM can only have one local SSD setting but multiple local SSD partitions. See https://cloud.google.com/compute/docs/disks#pdspecs and https://cloud.google.com/compute/docs/disks#localssds.
type DiskOutput struct{ *pulumi.OutputState }

func (DiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Disk)(nil)).Elem()
}

func (o DiskOutput) ToDiskOutput() DiskOutput {
	return o
}

func (o DiskOutput) ToDiskOutputWithContext(ctx context.Context) DiskOutput {
	return o
}

func (o DiskOutput) ToDiskPtrOutput() DiskPtrOutput {
	return o.ToDiskPtrOutputWithContext(context.Background())
}

func (o DiskOutput) ToDiskPtrOutputWithContext(ctx context.Context) DiskPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Disk) *Disk {
		return &v
	}).(DiskPtrOutput)
}

// Local SSDs are available through both "SCSI" and "NVMe" interfaces. If not indicated, "NVMe" will be the default one for local ssds. This field is ignored for persistent disks as the interface is chosen automatically. See https://cloud.google.com/compute/docs/disks/persistent-disks#choose_an_interface.
func (o DiskOutput) DiskInterface() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Disk) *string { return v.DiskInterface }).(pulumi.StringPtrOutput)
}

// URL for a VM image to use as the data source for this disk. For example, the following are all valid URLs: * Specify the image by its family name: projects/{project}/global/images/family/{image_family} * Specify the image version: projects/{project}/global/images/{image_version} You can also use Batch customized image in short names. The following image values are supported for a boot disk: * `batch-debian`: use Batch Debian images. * `batch-centos`: use Batch CentOS images. * `batch-cos`: use Batch Container-Optimized images. * `batch-hpc-centos`: use Batch HPC CentOS images. * `batch-hpc-rocky`: use Batch HPC Rocky Linux images.
func (o DiskOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Disk) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// Disk size in GB. **Non-Boot Disk**: If the `type` specifies a persistent disk, this field is ignored if `data_source` is set as `image` or `snapshot`. If the `type` specifies a local SSD, this field should be a multiple of 375 GB, otherwise, the final size will be the next greater multiple of 375 GB. **Boot Disk**: Batch will calculate the boot disk size based on source image and task requirements if you do not speicify the size. If both this field and the `boot_disk_mib` field in task spec's `compute_resource` are defined, Batch will only honor this field. Also, this field should be no smaller than the source disk's size when the `data_source` is set as `snapshot` or `image`. For example, if you set an image as the `data_source` field and the image's default disk size 30 GB, you can only use this field to make the disk larger or equal to 30 GB.
func (o DiskOutput) SizeGb() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Disk) *string { return v.SizeGb }).(pulumi.StringPtrOutput)
}

// Name of a snapshot used as the data source. Snapshot is not supported as boot disk now.
func (o DiskOutput) Snapshot() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Disk) *string { return v.Snapshot }).(pulumi.StringPtrOutput)
}

// Disk type as shown in `gcloud compute disk-types list`. For example, local SSD uses type "local-ssd". Persistent disks and boot disks use "pd-balanced", "pd-extreme", "pd-ssd" or "pd-standard".
func (o DiskOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Disk) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type DiskPtrOutput struct{ *pulumi.OutputState }

func (DiskPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Disk)(nil)).Elem()
}

func (o DiskPtrOutput) ToDiskPtrOutput() DiskPtrOutput {
	return o
}

func (o DiskPtrOutput) ToDiskPtrOutputWithContext(ctx context.Context) DiskPtrOutput {
	return o
}

func (o DiskPtrOutput) Elem() DiskOutput {
	return o.ApplyT(func(v *Disk) Disk {
		if v != nil {
			return *v
		}
		var ret Disk
		return ret
	}).(DiskOutput)
}

// Local SSDs are available through both "SCSI" and "NVMe" interfaces. If not indicated, "NVMe" will be the default one for local ssds. This field is ignored for persistent disks as the interface is chosen automatically. See https://cloud.google.com/compute/docs/disks/persistent-disks#choose_an_interface.
func (o DiskPtrOutput) DiskInterface() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Disk) *string {
		if v == nil {
			return nil
		}
		return v.DiskInterface
	}).(pulumi.StringPtrOutput)
}

// URL for a VM image to use as the data source for this disk. For example, the following are all valid URLs: * Specify the image by its family name: projects/{project}/global/images/family/{image_family} * Specify the image version: projects/{project}/global/images/{image_version} You can also use Batch customized image in short names. The following image values are supported for a boot disk: * `batch-debian`: use Batch Debian images. * `batch-centos`: use Batch CentOS images. * `batch-cos`: use Batch Container-Optimized images. * `batch-hpc-centos`: use Batch HPC CentOS images. * `batch-hpc-rocky`: use Batch HPC Rocky Linux images.
func (o DiskPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Disk) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// Disk size in GB. **Non-Boot Disk**: If the `type` specifies a persistent disk, this field is ignored if `data_source` is set as `image` or `snapshot`. If the `type` specifies a local SSD, this field should be a multiple of 375 GB, otherwise, the final size will be the next greater multiple of 375 GB. **Boot Disk**: Batch will calculate the boot disk size based on source image and task requirements if you do not speicify the size. If both this field and the `boot_disk_mib` field in task spec's `compute_resource` are defined, Batch will only honor this field. Also, this field should be no smaller than the source disk's size when the `data_source` is set as `snapshot` or `image`. For example, if you set an image as the `data_source` field and the image's default disk size 30 GB, you can only use this field to make the disk larger or equal to 30 GB.
func (o DiskPtrOutput) SizeGb() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Disk) *string {
		if v == nil {
			return nil
		}
		return v.SizeGb
	}).(pulumi.StringPtrOutput)
}

// Name of a snapshot used as the data source. Snapshot is not supported as boot disk now.
func (o DiskPtrOutput) Snapshot() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Disk) *string {
		if v == nil {
			return nil
		}
		return v.Snapshot
	}).(pulumi.StringPtrOutput)
}

// Disk type as shown in `gcloud compute disk-types list`. For example, local SSD uses type "local-ssd". Persistent disks and boot disks use "pd-balanced", "pd-extreme", "pd-ssd" or "pd-standard".
func (o DiskPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Disk) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// A new persistent disk or a local ssd. A VM can only have one local SSD setting but multiple local SSD partitions. See https://cloud.google.com/compute/docs/disks#pdspecs and https://cloud.google.com/compute/docs/disks#localssds.
type DiskResponse struct {
	// Local SSDs are available through both "SCSI" and "NVMe" interfaces. If not indicated, "NVMe" will be the default one for local ssds. This field is ignored for persistent disks as the interface is chosen automatically. See https://cloud.google.com/compute/docs/disks/persistent-disks#choose_an_interface.
	DiskInterface string `pulumi:"diskInterface"`
	// URL for a VM image to use as the data source for this disk. For example, the following are all valid URLs: * Specify the image by its family name: projects/{project}/global/images/family/{image_family} * Specify the image version: projects/{project}/global/images/{image_version} You can also use Batch customized image in short names. The following image values are supported for a boot disk: * `batch-debian`: use Batch Debian images. * `batch-centos`: use Batch CentOS images. * `batch-cos`: use Batch Container-Optimized images. * `batch-hpc-centos`: use Batch HPC CentOS images. * `batch-hpc-rocky`: use Batch HPC Rocky Linux images.
	Image string `pulumi:"image"`
	// Disk size in GB. **Non-Boot Disk**: If the `type` specifies a persistent disk, this field is ignored if `data_source` is set as `image` or `snapshot`. If the `type` specifies a local SSD, this field should be a multiple of 375 GB, otherwise, the final size will be the next greater multiple of 375 GB. **Boot Disk**: Batch will calculate the boot disk size based on source image and task requirements if you do not speicify the size. If both this field and the `boot_disk_mib` field in task spec's `compute_resource` are defined, Batch will only honor this field. Also, this field should be no smaller than the source disk's size when the `data_source` is set as `snapshot` or `image`. For example, if you set an image as the `data_source` field and the image's default disk size 30 GB, you can only use this field to make the disk larger or equal to 30 GB.
	SizeGb string `pulumi:"sizeGb"`
	// Name of a snapshot used as the data source. Snapshot is not supported as boot disk now.
	Snapshot string `pulumi:"snapshot"`
	// Disk type as shown in `gcloud compute disk-types list`. For example, local SSD uses type "local-ssd". Persistent disks and boot disks use "pd-balanced", "pd-extreme", "pd-ssd" or "pd-standard".
	Type string `pulumi:"type"`
}

// A new persistent disk or a local ssd. A VM can only have one local SSD setting but multiple local SSD partitions. See https://cloud.google.com/compute/docs/disks#pdspecs and https://cloud.google.com/compute/docs/disks#localssds.
type DiskResponseOutput struct{ *pulumi.OutputState }

func (DiskResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DiskResponse)(nil)).Elem()
}

func (o DiskResponseOutput) ToDiskResponseOutput() DiskResponseOutput {
	return o
}

func (o DiskResponseOutput) ToDiskResponseOutputWithContext(ctx context.Context) DiskResponseOutput {
	return o
}

// Local SSDs are available through both "SCSI" and "NVMe" interfaces. If not indicated, "NVMe" will be the default one for local ssds. This field is ignored for persistent disks as the interface is chosen automatically. See https://cloud.google.com/compute/docs/disks/persistent-disks#choose_an_interface.
func (o DiskResponseOutput) DiskInterface() pulumi.StringOutput {
	return o.ApplyT(func(v DiskResponse) string { return v.DiskInterface }).(pulumi.StringOutput)
}

// URL for a VM image to use as the data source for this disk. For example, the following are all valid URLs: * Specify the image by its family name: projects/{project}/global/images/family/{image_family} * Specify the image version: projects/{project}/global/images/{image_version} You can also use Batch customized image in short names. The following image values are supported for a boot disk: * `batch-debian`: use Batch Debian images. * `batch-centos`: use Batch CentOS images. * `batch-cos`: use Batch Container-Optimized images. * `batch-hpc-centos`: use Batch HPC CentOS images. * `batch-hpc-rocky`: use Batch HPC Rocky Linux images.
func (o DiskResponseOutput) Image() pulumi.StringOutput {
	return o.ApplyT(func(v DiskResponse) string { return v.Image }).(pulumi.StringOutput)
}

// Disk size in GB. **Non-Boot Disk**: If the `type` specifies a persistent disk, this field is ignored if `data_source` is set as `image` or `snapshot`. If the `type` specifies a local SSD, this field should be a multiple of 375 GB, otherwise, the final size will be the next greater multiple of 375 GB. **Boot Disk**: Batch will calculate the boot disk size based on source image and task requirements if you do not speicify the size. If both this field and the `boot_disk_mib` field in task spec's `compute_resource` are defined, Batch will only honor this field. Also, this field should be no smaller than the source disk's size when the `data_source` is set as `snapshot` or `image`. For example, if you set an image as the `data_source` field and the image's default disk size 30 GB, you can only use this field to make the disk larger or equal to 30 GB.
func (o DiskResponseOutput) SizeGb() pulumi.StringOutput {
	return o.ApplyT(func(v DiskResponse) string { return v.SizeGb }).(pulumi.StringOutput)
}

// Name of a snapshot used as the data source. Snapshot is not supported as boot disk now.
func (o DiskResponseOutput) Snapshot() pulumi.StringOutput {
	return o.ApplyT(func(v DiskResponse) string { return v.Snapshot }).(pulumi.StringOutput)
}

// Disk type as shown in `gcloud compute disk-types list`. For example, local SSD uses type "local-ssd". Persistent disks and boot disks use "pd-balanced", "pd-extreme", "pd-ssd" or "pd-standard".
func (o DiskResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v DiskResponse) string { return v.Type }).(pulumi.StringOutput)
}

// An Environment describes a collection of environment variables to set when executing Tasks.
type Environment struct {
	// An encrypted JSON dictionary where the key/value pairs correspond to environment variable names and their values.
	EncryptedVariables *KMSEnvMap `pulumi:"encryptedVariables"`
	// A map of environment variable names to Secret Manager secret names. The VM will access the named secrets to set the value of each environment variable.
	SecretVariables map[string]string `pulumi:"secretVariables"`
	// A map of environment variable names to values.
	Variables map[string]string `pulumi:"variables"`
}

// EnvironmentInput is an input type that accepts EnvironmentArgs and EnvironmentOutput values.
// You can construct a concrete instance of `EnvironmentInput` via:
//
//	EnvironmentArgs{...}
type EnvironmentInput interface {
	pulumi.Input

	ToEnvironmentOutput() EnvironmentOutput
	ToEnvironmentOutputWithContext(context.Context) EnvironmentOutput
}

// An Environment describes a collection of environment variables to set when executing Tasks.
type EnvironmentArgs struct {
	// An encrypted JSON dictionary where the key/value pairs correspond to environment variable names and their values.
	EncryptedVariables KMSEnvMapPtrInput `pulumi:"encryptedVariables"`
	// A map of environment variable names to Secret Manager secret names. The VM will access the named secrets to set the value of each environment variable.
	SecretVariables pulumi.StringMapInput `pulumi:"secretVariables"`
	// A map of environment variable names to values.
	Variables pulumi.StringMapInput `pulumi:"variables"`
}

func (EnvironmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Environment)(nil)).Elem()
}

func (i EnvironmentArgs) ToEnvironmentOutput() EnvironmentOutput {
	return i.ToEnvironmentOutputWithContext(context.Background())
}

func (i EnvironmentArgs) ToEnvironmentOutputWithContext(ctx context.Context) EnvironmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentOutput)
}

func (i EnvironmentArgs) ToEnvironmentPtrOutput() EnvironmentPtrOutput {
	return i.ToEnvironmentPtrOutputWithContext(context.Background())
}

func (i EnvironmentArgs) ToEnvironmentPtrOutputWithContext(ctx context.Context) EnvironmentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentOutput).ToEnvironmentPtrOutputWithContext(ctx)
}

// EnvironmentPtrInput is an input type that accepts EnvironmentArgs, EnvironmentPtr and EnvironmentPtrOutput values.
// You can construct a concrete instance of `EnvironmentPtrInput` via:
//
//	        EnvironmentArgs{...}
//
//	or:
//
//	        nil
type EnvironmentPtrInput interface {
	pulumi.Input

	ToEnvironmentPtrOutput() EnvironmentPtrOutput
	ToEnvironmentPtrOutputWithContext(context.Context) EnvironmentPtrOutput
}

type environmentPtrType EnvironmentArgs

func EnvironmentPtr(v *EnvironmentArgs) EnvironmentPtrInput {
	return (*environmentPtrType)(v)
}

func (*environmentPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Environment)(nil)).Elem()
}

func (i *environmentPtrType) ToEnvironmentPtrOutput() EnvironmentPtrOutput {
	return i.ToEnvironmentPtrOutputWithContext(context.Background())
}

func (i *environmentPtrType) ToEnvironmentPtrOutputWithContext(ctx context.Context) EnvironmentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentPtrOutput)
}

// EnvironmentArrayInput is an input type that accepts EnvironmentArray and EnvironmentArrayOutput values.
// You can construct a concrete instance of `EnvironmentArrayInput` via:
//
//	EnvironmentArray{ EnvironmentArgs{...} }
type EnvironmentArrayInput interface {
	pulumi.Input

	ToEnvironmentArrayOutput() EnvironmentArrayOutput
	ToEnvironmentArrayOutputWithContext(context.Context) EnvironmentArrayOutput
}

type EnvironmentArray []EnvironmentInput

func (EnvironmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Environment)(nil)).Elem()
}

func (i EnvironmentArray) ToEnvironmentArrayOutput() EnvironmentArrayOutput {
	return i.ToEnvironmentArrayOutputWithContext(context.Background())
}

func (i EnvironmentArray) ToEnvironmentArrayOutputWithContext(ctx context.Context) EnvironmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentArrayOutput)
}

// An Environment describes a collection of environment variables to set when executing Tasks.
type EnvironmentOutput struct{ *pulumi.OutputState }

func (EnvironmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Environment)(nil)).Elem()
}

func (o EnvironmentOutput) ToEnvironmentOutput() EnvironmentOutput {
	return o
}

func (o EnvironmentOutput) ToEnvironmentOutputWithContext(ctx context.Context) EnvironmentOutput {
	return o
}

func (o EnvironmentOutput) ToEnvironmentPtrOutput() EnvironmentPtrOutput {
	return o.ToEnvironmentPtrOutputWithContext(context.Background())
}

func (o EnvironmentOutput) ToEnvironmentPtrOutputWithContext(ctx context.Context) EnvironmentPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Environment) *Environment {
		return &v
	}).(EnvironmentPtrOutput)
}

// An encrypted JSON dictionary where the key/value pairs correspond to environment variable names and their values.
func (o EnvironmentOutput) EncryptedVariables() KMSEnvMapPtrOutput {
	return o.ApplyT(func(v Environment) *KMSEnvMap { return v.EncryptedVariables }).(KMSEnvMapPtrOutput)
}

// A map of environment variable names to Secret Manager secret names. The VM will access the named secrets to set the value of each environment variable.
func (o EnvironmentOutput) SecretVariables() pulumi.StringMapOutput {
	return o.ApplyT(func(v Environment) map[string]string { return v.SecretVariables }).(pulumi.StringMapOutput)
}

// A map of environment variable names to values.
func (o EnvironmentOutput) Variables() pulumi.StringMapOutput {
	return o.ApplyT(func(v Environment) map[string]string { return v.Variables }).(pulumi.StringMapOutput)
}

type EnvironmentPtrOutput struct{ *pulumi.OutputState }

func (EnvironmentPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Environment)(nil)).Elem()
}

func (o EnvironmentPtrOutput) ToEnvironmentPtrOutput() EnvironmentPtrOutput {
	return o
}

func (o EnvironmentPtrOutput) ToEnvironmentPtrOutputWithContext(ctx context.Context) EnvironmentPtrOutput {
	return o
}

func (o EnvironmentPtrOutput) Elem() EnvironmentOutput {
	return o.ApplyT(func(v *Environment) Environment {
		if v != nil {
			return *v
		}
		var ret Environment
		return ret
	}).(EnvironmentOutput)
}

// An encrypted JSON dictionary where the key/value pairs correspond to environment variable names and their values.
func (o EnvironmentPtrOutput) EncryptedVariables() KMSEnvMapPtrOutput {
	return o.ApplyT(func(v *Environment) *KMSEnvMap {
		if v == nil {
			return nil
		}
		return v.EncryptedVariables
	}).(KMSEnvMapPtrOutput)
}

// A map of environment variable names to Secret Manager secret names. The VM will access the named secrets to set the value of each environment variable.
func (o EnvironmentPtrOutput) SecretVariables() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Environment) map[string]string {
		if v == nil {
			return nil
		}
		return v.SecretVariables
	}).(pulumi.StringMapOutput)
}

// A map of environment variable names to values.
func (o EnvironmentPtrOutput) Variables() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Environment) map[string]string {
		if v == nil {
			return nil
		}
		return v.Variables
	}).(pulumi.StringMapOutput)
}

type EnvironmentArrayOutput struct{ *pulumi.OutputState }

func (EnvironmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Environment)(nil)).Elem()
}

func (o EnvironmentArrayOutput) ToEnvironmentArrayOutput() EnvironmentArrayOutput {
	return o
}

func (o EnvironmentArrayOutput) ToEnvironmentArrayOutputWithContext(ctx context.Context) EnvironmentArrayOutput {
	return o
}

func (o EnvironmentArrayOutput) Index(i pulumi.IntInput) EnvironmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Environment {
		return vs[0].([]Environment)[vs[1].(int)]
	}).(EnvironmentOutput)
}

// An Environment describes a collection of environment variables to set when executing Tasks.
type EnvironmentResponse struct {
	// An encrypted JSON dictionary where the key/value pairs correspond to environment variable names and their values.
	EncryptedVariables KMSEnvMapResponse `pulumi:"encryptedVariables"`
	// A map of environment variable names to Secret Manager secret names. The VM will access the named secrets to set the value of each environment variable.
	SecretVariables map[string]string `pulumi:"secretVariables"`
	// A map of environment variable names to values.
	Variables map[string]string `pulumi:"variables"`
}

// An Environment describes a collection of environment variables to set when executing Tasks.
type EnvironmentResponseOutput struct{ *pulumi.OutputState }

func (EnvironmentResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentResponse)(nil)).Elem()
}

func (o EnvironmentResponseOutput) ToEnvironmentResponseOutput() EnvironmentResponseOutput {
	return o
}

func (o EnvironmentResponseOutput) ToEnvironmentResponseOutputWithContext(ctx context.Context) EnvironmentResponseOutput {
	return o
}

// An encrypted JSON dictionary where the key/value pairs correspond to environment variable names and their values.
func (o EnvironmentResponseOutput) EncryptedVariables() KMSEnvMapResponseOutput {
	return o.ApplyT(func(v EnvironmentResponse) KMSEnvMapResponse { return v.EncryptedVariables }).(KMSEnvMapResponseOutput)
}

// A map of environment variable names to Secret Manager secret names. The VM will access the named secrets to set the value of each environment variable.
func (o EnvironmentResponseOutput) SecretVariables() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentResponse) map[string]string { return v.SecretVariables }).(pulumi.StringMapOutput)
}

// A map of environment variable names to values.
func (o EnvironmentResponseOutput) Variables() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentResponse) map[string]string { return v.Variables }).(pulumi.StringMapOutput)
}

type EnvironmentResponseArrayOutput struct{ *pulumi.OutputState }

func (EnvironmentResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EnvironmentResponse)(nil)).Elem()
}

func (o EnvironmentResponseArrayOutput) ToEnvironmentResponseArrayOutput() EnvironmentResponseArrayOutput {
	return o
}

func (o EnvironmentResponseArrayOutput) ToEnvironmentResponseArrayOutputWithContext(ctx context.Context) EnvironmentResponseArrayOutput {
	return o
}

func (o EnvironmentResponseArrayOutput) Index(i pulumi.IntInput) EnvironmentResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) EnvironmentResponse {
		return vs[0].([]EnvironmentResponse)[vs[1].(int)]
	}).(EnvironmentResponseOutput)
}

// Represents a Google Cloud Storage volume.
type GCS struct {
	// Remote path, either a bucket name or a subdirectory of a bucket, e.g.: bucket_name, bucket_name/subdirectory/
	RemotePath *string `pulumi:"remotePath"`
}

// GCSInput is an input type that accepts GCSArgs and GCSOutput values.
// You can construct a concrete instance of `GCSInput` via:
//
//	GCSArgs{...}
type GCSInput interface {
	pulumi.Input

	ToGCSOutput() GCSOutput
	ToGCSOutputWithContext(context.Context) GCSOutput
}

// Represents a Google Cloud Storage volume.
type GCSArgs struct {
	// Remote path, either a bucket name or a subdirectory of a bucket, e.g.: bucket_name, bucket_name/subdirectory/
	RemotePath pulumi.StringPtrInput `pulumi:"remotePath"`
}

func (GCSArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GCS)(nil)).Elem()
}

func (i GCSArgs) ToGCSOutput() GCSOutput {
	return i.ToGCSOutputWithContext(context.Background())
}

func (i GCSArgs) ToGCSOutputWithContext(ctx context.Context) GCSOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GCSOutput)
}

func (i GCSArgs) ToGCSPtrOutput() GCSPtrOutput {
	return i.ToGCSPtrOutputWithContext(context.Background())
}

func (i GCSArgs) ToGCSPtrOutputWithContext(ctx context.Context) GCSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GCSOutput).ToGCSPtrOutputWithContext(ctx)
}

// GCSPtrInput is an input type that accepts GCSArgs, GCSPtr and GCSPtrOutput values.
// You can construct a concrete instance of `GCSPtrInput` via:
//
//	        GCSArgs{...}
//
//	or:
//
//	        nil
type GCSPtrInput interface {
	pulumi.Input

	ToGCSPtrOutput() GCSPtrOutput
	ToGCSPtrOutputWithContext(context.Context) GCSPtrOutput
}

type gcsPtrType GCSArgs

func GCSPtr(v *GCSArgs) GCSPtrInput {
	return (*gcsPtrType)(v)
}

func (*gcsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GCS)(nil)).Elem()
}

func (i *gcsPtrType) ToGCSPtrOutput() GCSPtrOutput {
	return i.ToGCSPtrOutputWithContext(context.Background())
}

func (i *gcsPtrType) ToGCSPtrOutputWithContext(ctx context.Context) GCSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GCSPtrOutput)
}

// Represents a Google Cloud Storage volume.
type GCSOutput struct{ *pulumi.OutputState }

func (GCSOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GCS)(nil)).Elem()
}

func (o GCSOutput) ToGCSOutput() GCSOutput {
	return o
}

func (o GCSOutput) ToGCSOutputWithContext(ctx context.Context) GCSOutput {
	return o
}

func (o GCSOutput) ToGCSPtrOutput() GCSPtrOutput {
	return o.ToGCSPtrOutputWithContext(context.Background())
}

func (o GCSOutput) ToGCSPtrOutputWithContext(ctx context.Context) GCSPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GCS) *GCS {
		return &v
	}).(GCSPtrOutput)
}

// Remote path, either a bucket name or a subdirectory of a bucket, e.g.: bucket_name, bucket_name/subdirectory/
func (o GCSOutput) RemotePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GCS) *string { return v.RemotePath }).(pulumi.StringPtrOutput)
}

type GCSPtrOutput struct{ *pulumi.OutputState }

func (GCSPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GCS)(nil)).Elem()
}

func (o GCSPtrOutput) ToGCSPtrOutput() GCSPtrOutput {
	return o
}

func (o GCSPtrOutput) ToGCSPtrOutputWithContext(ctx context.Context) GCSPtrOutput {
	return o
}

func (o GCSPtrOutput) Elem() GCSOutput {
	return o.ApplyT(func(v *GCS) GCS {
		if v != nil {
			return *v
		}
		var ret GCS
		return ret
	}).(GCSOutput)
}

// Remote path, either a bucket name or a subdirectory of a bucket, e.g.: bucket_name, bucket_name/subdirectory/
func (o GCSPtrOutput) RemotePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GCS) *string {
		if v == nil {
			return nil
		}
		return v.RemotePath
	}).(pulumi.StringPtrOutput)
}

// Represents a Google Cloud Storage volume.
type GCSResponse struct {
	// Remote path, either a bucket name or a subdirectory of a bucket, e.g.: bucket_name, bucket_name/subdirectory/
	RemotePath string `pulumi:"remotePath"`
}

// Represents a Google Cloud Storage volume.
type GCSResponseOutput struct{ *pulumi.OutputState }

func (GCSResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GCSResponse)(nil)).Elem()
}

func (o GCSResponseOutput) ToGCSResponseOutput() GCSResponseOutput {
	return o
}

func (o GCSResponseOutput) ToGCSResponseOutputWithContext(ctx context.Context) GCSResponseOutput {
	return o
}

// Remote path, either a bucket name or a subdirectory of a bucket, e.g.: bucket_name, bucket_name/subdirectory/
func (o GCSResponseOutput) RemotePath() pulumi.StringOutput {
	return o.ApplyT(func(v GCSResponse) string { return v.RemotePath }).(pulumi.StringOutput)
}

// InstancePolicy describes an instance type and resources attached to each VM created by this InstancePolicy.
type InstancePolicy struct {
	// The accelerators attached to each VM instance.
	Accelerators []Accelerator `pulumi:"accelerators"`
	// Boot disk to be created and attached to each VM by this InstancePolicy. Boot disk will be deleted when the VM is deleted. Batch API now only supports booting from image.
	BootDisk *Disk `pulumi:"bootDisk"`
	// Non-boot disks to be attached for each VM created by this InstancePolicy. New disks will be deleted when the VM is deleted. A non-boot disk is a disk that can be of a device with a file system or a raw storage drive that is not ready for data storage and accessing.
	Disks []AttachedDisk `pulumi:"disks"`
	// The Compute Engine machine type.
	MachineType *string `pulumi:"machineType"`
	// The minimum CPU platform. See https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.
	MinCpuPlatform *string `pulumi:"minCpuPlatform"`
	// The provisioning model.
	ProvisioningModel *InstancePolicyProvisioningModel `pulumi:"provisioningModel"`
	// Optional. If specified, VMs will consume only the specified reservation. If not specified (default), VMs will consume any applicable reservation.
	Reservation *string `pulumi:"reservation"`
}

// InstancePolicyInput is an input type that accepts InstancePolicyArgs and InstancePolicyOutput values.
// You can construct a concrete instance of `InstancePolicyInput` via:
//
//	InstancePolicyArgs{...}
type InstancePolicyInput interface {
	pulumi.Input

	ToInstancePolicyOutput() InstancePolicyOutput
	ToInstancePolicyOutputWithContext(context.Context) InstancePolicyOutput
}

// InstancePolicy describes an instance type and resources attached to each VM created by this InstancePolicy.
type InstancePolicyArgs struct {
	// The accelerators attached to each VM instance.
	Accelerators AcceleratorArrayInput `pulumi:"accelerators"`
	// Boot disk to be created and attached to each VM by this InstancePolicy. Boot disk will be deleted when the VM is deleted. Batch API now only supports booting from image.
	BootDisk DiskPtrInput `pulumi:"bootDisk"`
	// Non-boot disks to be attached for each VM created by this InstancePolicy. New disks will be deleted when the VM is deleted. A non-boot disk is a disk that can be of a device with a file system or a raw storage drive that is not ready for data storage and accessing.
	Disks AttachedDiskArrayInput `pulumi:"disks"`
	// The Compute Engine machine type.
	MachineType pulumi.StringPtrInput `pulumi:"machineType"`
	// The minimum CPU platform. See https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.
	MinCpuPlatform pulumi.StringPtrInput `pulumi:"minCpuPlatform"`
	// The provisioning model.
	ProvisioningModel InstancePolicyProvisioningModelPtrInput `pulumi:"provisioningModel"`
	// Optional. If specified, VMs will consume only the specified reservation. If not specified (default), VMs will consume any applicable reservation.
	Reservation pulumi.StringPtrInput `pulumi:"reservation"`
}

func (InstancePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstancePolicy)(nil)).Elem()
}

func (i InstancePolicyArgs) ToInstancePolicyOutput() InstancePolicyOutput {
	return i.ToInstancePolicyOutputWithContext(context.Background())
}

func (i InstancePolicyArgs) ToInstancePolicyOutputWithContext(ctx context.Context) InstancePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstancePolicyOutput)
}

func (i InstancePolicyArgs) ToInstancePolicyPtrOutput() InstancePolicyPtrOutput {
	return i.ToInstancePolicyPtrOutputWithContext(context.Background())
}

func (i InstancePolicyArgs) ToInstancePolicyPtrOutputWithContext(ctx context.Context) InstancePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstancePolicyOutput).ToInstancePolicyPtrOutputWithContext(ctx)
}

// InstancePolicyPtrInput is an input type that accepts InstancePolicyArgs, InstancePolicyPtr and InstancePolicyPtrOutput values.
// You can construct a concrete instance of `InstancePolicyPtrInput` via:
//
//	        InstancePolicyArgs{...}
//
//	or:
//
//	        nil
type InstancePolicyPtrInput interface {
	pulumi.Input

	ToInstancePolicyPtrOutput() InstancePolicyPtrOutput
	ToInstancePolicyPtrOutputWithContext(context.Context) InstancePolicyPtrOutput
}

type instancePolicyPtrType InstancePolicyArgs

func InstancePolicyPtr(v *InstancePolicyArgs) InstancePolicyPtrInput {
	return (*instancePolicyPtrType)(v)
}

func (*instancePolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InstancePolicy)(nil)).Elem()
}

func (i *instancePolicyPtrType) ToInstancePolicyPtrOutput() InstancePolicyPtrOutput {
	return i.ToInstancePolicyPtrOutputWithContext(context.Background())
}

func (i *instancePolicyPtrType) ToInstancePolicyPtrOutputWithContext(ctx context.Context) InstancePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstancePolicyPtrOutput)
}

// InstancePolicy describes an instance type and resources attached to each VM created by this InstancePolicy.
type InstancePolicyOutput struct{ *pulumi.OutputState }

func (InstancePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstancePolicy)(nil)).Elem()
}

func (o InstancePolicyOutput) ToInstancePolicyOutput() InstancePolicyOutput {
	return o
}

func (o InstancePolicyOutput) ToInstancePolicyOutputWithContext(ctx context.Context) InstancePolicyOutput {
	return o
}

func (o InstancePolicyOutput) ToInstancePolicyPtrOutput() InstancePolicyPtrOutput {
	return o.ToInstancePolicyPtrOutputWithContext(context.Background())
}

func (o InstancePolicyOutput) ToInstancePolicyPtrOutputWithContext(ctx context.Context) InstancePolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v InstancePolicy) *InstancePolicy {
		return &v
	}).(InstancePolicyPtrOutput)
}

// The accelerators attached to each VM instance.
func (o InstancePolicyOutput) Accelerators() AcceleratorArrayOutput {
	return o.ApplyT(func(v InstancePolicy) []Accelerator { return v.Accelerators }).(AcceleratorArrayOutput)
}

// Boot disk to be created and attached to each VM by this InstancePolicy. Boot disk will be deleted when the VM is deleted. Batch API now only supports booting from image.
func (o InstancePolicyOutput) BootDisk() DiskPtrOutput {
	return o.ApplyT(func(v InstancePolicy) *Disk { return v.BootDisk }).(DiskPtrOutput)
}

// Non-boot disks to be attached for each VM created by this InstancePolicy. New disks will be deleted when the VM is deleted. A non-boot disk is a disk that can be of a device with a file system or a raw storage drive that is not ready for data storage and accessing.
func (o InstancePolicyOutput) Disks() AttachedDiskArrayOutput {
	return o.ApplyT(func(v InstancePolicy) []AttachedDisk { return v.Disks }).(AttachedDiskArrayOutput)
}

// The Compute Engine machine type.
func (o InstancePolicyOutput) MachineType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstancePolicy) *string { return v.MachineType }).(pulumi.StringPtrOutput)
}

// The minimum CPU platform. See https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.
func (o InstancePolicyOutput) MinCpuPlatform() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstancePolicy) *string { return v.MinCpuPlatform }).(pulumi.StringPtrOutput)
}

// The provisioning model.
func (o InstancePolicyOutput) ProvisioningModel() InstancePolicyProvisioningModelPtrOutput {
	return o.ApplyT(func(v InstancePolicy) *InstancePolicyProvisioningModel { return v.ProvisioningModel }).(InstancePolicyProvisioningModelPtrOutput)
}

// Optional. If specified, VMs will consume only the specified reservation. If not specified (default), VMs will consume any applicable reservation.
func (o InstancePolicyOutput) Reservation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstancePolicy) *string { return v.Reservation }).(pulumi.StringPtrOutput)
}

type InstancePolicyPtrOutput struct{ *pulumi.OutputState }

func (InstancePolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InstancePolicy)(nil)).Elem()
}

func (o InstancePolicyPtrOutput) ToInstancePolicyPtrOutput() InstancePolicyPtrOutput {
	return o
}

func (o InstancePolicyPtrOutput) ToInstancePolicyPtrOutputWithContext(ctx context.Context) InstancePolicyPtrOutput {
	return o
}

func (o InstancePolicyPtrOutput) Elem() InstancePolicyOutput {
	return o.ApplyT(func(v *InstancePolicy) InstancePolicy {
		if v != nil {
			return *v
		}
		var ret InstancePolicy
		return ret
	}).(InstancePolicyOutput)
}

// The accelerators attached to each VM instance.
func (o InstancePolicyPtrOutput) Accelerators() AcceleratorArrayOutput {
	return o.ApplyT(func(v *InstancePolicy) []Accelerator {
		if v == nil {
			return nil
		}
		return v.Accelerators
	}).(AcceleratorArrayOutput)
}

// Boot disk to be created and attached to each VM by this InstancePolicy. Boot disk will be deleted when the VM is deleted. Batch API now only supports booting from image.
func (o InstancePolicyPtrOutput) BootDisk() DiskPtrOutput {
	return o.ApplyT(func(v *InstancePolicy) *Disk {
		if v == nil {
			return nil
		}
		return v.BootDisk
	}).(DiskPtrOutput)
}

// Non-boot disks to be attached for each VM created by this InstancePolicy. New disks will be deleted when the VM is deleted. A non-boot disk is a disk that can be of a device with a file system or a raw storage drive that is not ready for data storage and accessing.
func (o InstancePolicyPtrOutput) Disks() AttachedDiskArrayOutput {
	return o.ApplyT(func(v *InstancePolicy) []AttachedDisk {
		if v == nil {
			return nil
		}
		return v.Disks
	}).(AttachedDiskArrayOutput)
}

// The Compute Engine machine type.
func (o InstancePolicyPtrOutput) MachineType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstancePolicy) *string {
		if v == nil {
			return nil
		}
		return v.MachineType
	}).(pulumi.StringPtrOutput)
}

// The minimum CPU platform. See https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.
func (o InstancePolicyPtrOutput) MinCpuPlatform() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstancePolicy) *string {
		if v == nil {
			return nil
		}
		return v.MinCpuPlatform
	}).(pulumi.StringPtrOutput)
}

// The provisioning model.
func (o InstancePolicyPtrOutput) ProvisioningModel() InstancePolicyProvisioningModelPtrOutput {
	return o.ApplyT(func(v *InstancePolicy) *InstancePolicyProvisioningModel {
		if v == nil {
			return nil
		}
		return v.ProvisioningModel
	}).(InstancePolicyProvisioningModelPtrOutput)
}

// Optional. If specified, VMs will consume only the specified reservation. If not specified (default), VMs will consume any applicable reservation.
func (o InstancePolicyPtrOutput) Reservation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstancePolicy) *string {
		if v == nil {
			return nil
		}
		return v.Reservation
	}).(pulumi.StringPtrOutput)
}

// InstancePolicyOrTemplate lets you define the type of resources to use for this job either with an InstancePolicy or an instance template. If undefined, Batch picks the type of VM to use and doesn't include optional VM resources such as GPUs and extra disks.
type InstancePolicyOrTemplate struct {
	// Set this field true if users want Batch to help fetch drivers from a third party location and install them for GPUs specified in policy.accelerators or instance_template on their behalf. Default is false. For Container-Optimized Image cases, Batch will install the accelerator driver following milestones of https://cloud.google.com/container-optimized-os/docs/release-notes. For non Container-Optimized Image cases, following https://github.com/GoogleCloudPlatform/compute-gpu-installation/blob/main/linux/install_gpu_driver.py.
	InstallGpuDrivers *bool `pulumi:"installGpuDrivers"`
	// Name of an instance template used to create VMs. Named the field as 'instance_template' instead of 'template' to avoid c++ keyword conflict.
	InstanceTemplate *string `pulumi:"instanceTemplate"`
	// InstancePolicy.
	Policy *InstancePolicy `pulumi:"policy"`
}

// InstancePolicyOrTemplateInput is an input type that accepts InstancePolicyOrTemplateArgs and InstancePolicyOrTemplateOutput values.
// You can construct a concrete instance of `InstancePolicyOrTemplateInput` via:
//
//	InstancePolicyOrTemplateArgs{...}
type InstancePolicyOrTemplateInput interface {
	pulumi.Input

	ToInstancePolicyOrTemplateOutput() InstancePolicyOrTemplateOutput
	ToInstancePolicyOrTemplateOutputWithContext(context.Context) InstancePolicyOrTemplateOutput
}

// InstancePolicyOrTemplate lets you define the type of resources to use for this job either with an InstancePolicy or an instance template. If undefined, Batch picks the type of VM to use and doesn't include optional VM resources such as GPUs and extra disks.
type InstancePolicyOrTemplateArgs struct {
	// Set this field true if users want Batch to help fetch drivers from a third party location and install them for GPUs specified in policy.accelerators or instance_template on their behalf. Default is false. For Container-Optimized Image cases, Batch will install the accelerator driver following milestones of https://cloud.google.com/container-optimized-os/docs/release-notes. For non Container-Optimized Image cases, following https://github.com/GoogleCloudPlatform/compute-gpu-installation/blob/main/linux/install_gpu_driver.py.
	InstallGpuDrivers pulumi.BoolPtrInput `pulumi:"installGpuDrivers"`
	// Name of an instance template used to create VMs. Named the field as 'instance_template' instead of 'template' to avoid c++ keyword conflict.
	InstanceTemplate pulumi.StringPtrInput `pulumi:"instanceTemplate"`
	// InstancePolicy.
	Policy InstancePolicyPtrInput `pulumi:"policy"`
}

func (InstancePolicyOrTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstancePolicyOrTemplate)(nil)).Elem()
}

func (i InstancePolicyOrTemplateArgs) ToInstancePolicyOrTemplateOutput() InstancePolicyOrTemplateOutput {
	return i.ToInstancePolicyOrTemplateOutputWithContext(context.Background())
}

func (i InstancePolicyOrTemplateArgs) ToInstancePolicyOrTemplateOutputWithContext(ctx context.Context) InstancePolicyOrTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstancePolicyOrTemplateOutput)
}

// InstancePolicyOrTemplateArrayInput is an input type that accepts InstancePolicyOrTemplateArray and InstancePolicyOrTemplateArrayOutput values.
// You can construct a concrete instance of `InstancePolicyOrTemplateArrayInput` via:
//
//	InstancePolicyOrTemplateArray{ InstancePolicyOrTemplateArgs{...} }
type InstancePolicyOrTemplateArrayInput interface {
	pulumi.Input

	ToInstancePolicyOrTemplateArrayOutput() InstancePolicyOrTemplateArrayOutput
	ToInstancePolicyOrTemplateArrayOutputWithContext(context.Context) InstancePolicyOrTemplateArrayOutput
}

type InstancePolicyOrTemplateArray []InstancePolicyOrTemplateInput

func (InstancePolicyOrTemplateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstancePolicyOrTemplate)(nil)).Elem()
}

func (i InstancePolicyOrTemplateArray) ToInstancePolicyOrTemplateArrayOutput() InstancePolicyOrTemplateArrayOutput {
	return i.ToInstancePolicyOrTemplateArrayOutputWithContext(context.Background())
}

func (i InstancePolicyOrTemplateArray) ToInstancePolicyOrTemplateArrayOutputWithContext(ctx context.Context) InstancePolicyOrTemplateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstancePolicyOrTemplateArrayOutput)
}

// InstancePolicyOrTemplate lets you define the type of resources to use for this job either with an InstancePolicy or an instance template. If undefined, Batch picks the type of VM to use and doesn't include optional VM resources such as GPUs and extra disks.
type InstancePolicyOrTemplateOutput struct{ *pulumi.OutputState }

func (InstancePolicyOrTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstancePolicyOrTemplate)(nil)).Elem()
}

func (o InstancePolicyOrTemplateOutput) ToInstancePolicyOrTemplateOutput() InstancePolicyOrTemplateOutput {
	return o
}

func (o InstancePolicyOrTemplateOutput) ToInstancePolicyOrTemplateOutputWithContext(ctx context.Context) InstancePolicyOrTemplateOutput {
	return o
}

// Set this field true if users want Batch to help fetch drivers from a third party location and install them for GPUs specified in policy.accelerators or instance_template on their behalf. Default is false. For Container-Optimized Image cases, Batch will install the accelerator driver following milestones of https://cloud.google.com/container-optimized-os/docs/release-notes. For non Container-Optimized Image cases, following https://github.com/GoogleCloudPlatform/compute-gpu-installation/blob/main/linux/install_gpu_driver.py.
func (o InstancePolicyOrTemplateOutput) InstallGpuDrivers() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v InstancePolicyOrTemplate) *bool { return v.InstallGpuDrivers }).(pulumi.BoolPtrOutput)
}

// Name of an instance template used to create VMs. Named the field as 'instance_template' instead of 'template' to avoid c++ keyword conflict.
func (o InstancePolicyOrTemplateOutput) InstanceTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstancePolicyOrTemplate) *string { return v.InstanceTemplate }).(pulumi.StringPtrOutput)
}

// InstancePolicy.
func (o InstancePolicyOrTemplateOutput) Policy() InstancePolicyPtrOutput {
	return o.ApplyT(func(v InstancePolicyOrTemplate) *InstancePolicy { return v.Policy }).(InstancePolicyPtrOutput)
}

type InstancePolicyOrTemplateArrayOutput struct{ *pulumi.OutputState }

func (InstancePolicyOrTemplateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstancePolicyOrTemplate)(nil)).Elem()
}

func (o InstancePolicyOrTemplateArrayOutput) ToInstancePolicyOrTemplateArrayOutput() InstancePolicyOrTemplateArrayOutput {
	return o
}

func (o InstancePolicyOrTemplateArrayOutput) ToInstancePolicyOrTemplateArrayOutputWithContext(ctx context.Context) InstancePolicyOrTemplateArrayOutput {
	return o
}

func (o InstancePolicyOrTemplateArrayOutput) Index(i pulumi.IntInput) InstancePolicyOrTemplateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstancePolicyOrTemplate {
		return vs[0].([]InstancePolicyOrTemplate)[vs[1].(int)]
	}).(InstancePolicyOrTemplateOutput)
}

// InstancePolicyOrTemplate lets you define the type of resources to use for this job either with an InstancePolicy or an instance template. If undefined, Batch picks the type of VM to use and doesn't include optional VM resources such as GPUs and extra disks.
type InstancePolicyOrTemplateResponse struct {
	// Set this field true if users want Batch to help fetch drivers from a third party location and install them for GPUs specified in policy.accelerators or instance_template on their behalf. Default is false. For Container-Optimized Image cases, Batch will install the accelerator driver following milestones of https://cloud.google.com/container-optimized-os/docs/release-notes. For non Container-Optimized Image cases, following https://github.com/GoogleCloudPlatform/compute-gpu-installation/blob/main/linux/install_gpu_driver.py.
	InstallGpuDrivers bool `pulumi:"installGpuDrivers"`
	// Name of an instance template used to create VMs. Named the field as 'instance_template' instead of 'template' to avoid c++ keyword conflict.
	InstanceTemplate string `pulumi:"instanceTemplate"`
	// InstancePolicy.
	Policy InstancePolicyResponse `pulumi:"policy"`
}

// InstancePolicyOrTemplate lets you define the type of resources to use for this job either with an InstancePolicy or an instance template. If undefined, Batch picks the type of VM to use and doesn't include optional VM resources such as GPUs and extra disks.
type InstancePolicyOrTemplateResponseOutput struct{ *pulumi.OutputState }

func (InstancePolicyOrTemplateResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstancePolicyOrTemplateResponse)(nil)).Elem()
}

func (o InstancePolicyOrTemplateResponseOutput) ToInstancePolicyOrTemplateResponseOutput() InstancePolicyOrTemplateResponseOutput {
	return o
}

func (o InstancePolicyOrTemplateResponseOutput) ToInstancePolicyOrTemplateResponseOutputWithContext(ctx context.Context) InstancePolicyOrTemplateResponseOutput {
	return o
}

// Set this field true if users want Batch to help fetch drivers from a third party location and install them for GPUs specified in policy.accelerators or instance_template on their behalf. Default is false. For Container-Optimized Image cases, Batch will install the accelerator driver following milestones of https://cloud.google.com/container-optimized-os/docs/release-notes. For non Container-Optimized Image cases, following https://github.com/GoogleCloudPlatform/compute-gpu-installation/blob/main/linux/install_gpu_driver.py.
func (o InstancePolicyOrTemplateResponseOutput) InstallGpuDrivers() pulumi.BoolOutput {
	return o.ApplyT(func(v InstancePolicyOrTemplateResponse) bool { return v.InstallGpuDrivers }).(pulumi.BoolOutput)
}

// Name of an instance template used to create VMs. Named the field as 'instance_template' instead of 'template' to avoid c++ keyword conflict.
func (o InstancePolicyOrTemplateResponseOutput) InstanceTemplate() pulumi.StringOutput {
	return o.ApplyT(func(v InstancePolicyOrTemplateResponse) string { return v.InstanceTemplate }).(pulumi.StringOutput)
}

// InstancePolicy.
func (o InstancePolicyOrTemplateResponseOutput) Policy() InstancePolicyResponseOutput {
	return o.ApplyT(func(v InstancePolicyOrTemplateResponse) InstancePolicyResponse { return v.Policy }).(InstancePolicyResponseOutput)
}

type InstancePolicyOrTemplateResponseArrayOutput struct{ *pulumi.OutputState }

func (InstancePolicyOrTemplateResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstancePolicyOrTemplateResponse)(nil)).Elem()
}

func (o InstancePolicyOrTemplateResponseArrayOutput) ToInstancePolicyOrTemplateResponseArrayOutput() InstancePolicyOrTemplateResponseArrayOutput {
	return o
}

func (o InstancePolicyOrTemplateResponseArrayOutput) ToInstancePolicyOrTemplateResponseArrayOutputWithContext(ctx context.Context) InstancePolicyOrTemplateResponseArrayOutput {
	return o
}

func (o InstancePolicyOrTemplateResponseArrayOutput) Index(i pulumi.IntInput) InstancePolicyOrTemplateResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstancePolicyOrTemplateResponse {
		return vs[0].([]InstancePolicyOrTemplateResponse)[vs[1].(int)]
	}).(InstancePolicyOrTemplateResponseOutput)
}

// InstancePolicy describes an instance type and resources attached to each VM created by this InstancePolicy.
type InstancePolicyResponse struct {
	// The accelerators attached to each VM instance.
	Accelerators []AcceleratorResponse `pulumi:"accelerators"`
	// Boot disk to be created and attached to each VM by this InstancePolicy. Boot disk will be deleted when the VM is deleted. Batch API now only supports booting from image.
	BootDisk DiskResponse `pulumi:"bootDisk"`
	// Non-boot disks to be attached for each VM created by this InstancePolicy. New disks will be deleted when the VM is deleted. A non-boot disk is a disk that can be of a device with a file system or a raw storage drive that is not ready for data storage and accessing.
	Disks []AttachedDiskResponse `pulumi:"disks"`
	// The Compute Engine machine type.
	MachineType string `pulumi:"machineType"`
	// The minimum CPU platform. See https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.
	MinCpuPlatform string `pulumi:"minCpuPlatform"`
	// The provisioning model.
	ProvisioningModel string `pulumi:"provisioningModel"`
	// Optional. If specified, VMs will consume only the specified reservation. If not specified (default), VMs will consume any applicable reservation.
	Reservation string `pulumi:"reservation"`
}

// InstancePolicy describes an instance type and resources attached to each VM created by this InstancePolicy.
type InstancePolicyResponseOutput struct{ *pulumi.OutputState }

func (InstancePolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstancePolicyResponse)(nil)).Elem()
}

func (o InstancePolicyResponseOutput) ToInstancePolicyResponseOutput() InstancePolicyResponseOutput {
	return o
}

func (o InstancePolicyResponseOutput) ToInstancePolicyResponseOutputWithContext(ctx context.Context) InstancePolicyResponseOutput {
	return o
}

// The accelerators attached to each VM instance.
func (o InstancePolicyResponseOutput) Accelerators() AcceleratorResponseArrayOutput {
	return o.ApplyT(func(v InstancePolicyResponse) []AcceleratorResponse { return v.Accelerators }).(AcceleratorResponseArrayOutput)
}

// Boot disk to be created and attached to each VM by this InstancePolicy. Boot disk will be deleted when the VM is deleted. Batch API now only supports booting from image.
func (o InstancePolicyResponseOutput) BootDisk() DiskResponseOutput {
	return o.ApplyT(func(v InstancePolicyResponse) DiskResponse { return v.BootDisk }).(DiskResponseOutput)
}

// Non-boot disks to be attached for each VM created by this InstancePolicy. New disks will be deleted when the VM is deleted. A non-boot disk is a disk that can be of a device with a file system or a raw storage drive that is not ready for data storage and accessing.
func (o InstancePolicyResponseOutput) Disks() AttachedDiskResponseArrayOutput {
	return o.ApplyT(func(v InstancePolicyResponse) []AttachedDiskResponse { return v.Disks }).(AttachedDiskResponseArrayOutput)
}

// The Compute Engine machine type.
func (o InstancePolicyResponseOutput) MachineType() pulumi.StringOutput {
	return o.ApplyT(func(v InstancePolicyResponse) string { return v.MachineType }).(pulumi.StringOutput)
}

// The minimum CPU platform. See https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.
func (o InstancePolicyResponseOutput) MinCpuPlatform() pulumi.StringOutput {
	return o.ApplyT(func(v InstancePolicyResponse) string { return v.MinCpuPlatform }).(pulumi.StringOutput)
}

// The provisioning model.
func (o InstancePolicyResponseOutput) ProvisioningModel() pulumi.StringOutput {
	return o.ApplyT(func(v InstancePolicyResponse) string { return v.ProvisioningModel }).(pulumi.StringOutput)
}

// Optional. If specified, VMs will consume only the specified reservation. If not specified (default), VMs will consume any applicable reservation.
func (o InstancePolicyResponseOutput) Reservation() pulumi.StringOutput {
	return o.ApplyT(func(v InstancePolicyResponse) string { return v.Reservation }).(pulumi.StringOutput)
}

// VM instance status.
type InstanceStatusResponse struct {
	// The VM boot disk.
	BootDisk DiskResponse `pulumi:"bootDisk"`
	// The Compute Engine machine type.
	MachineType string `pulumi:"machineType"`
	// The VM instance provisioning model.
	ProvisioningModel string `pulumi:"provisioningModel"`
	// The max number of tasks can be assigned to this instance type.
	TaskPack string `pulumi:"taskPack"`
}

// VM instance status.
type InstanceStatusResponseOutput struct{ *pulumi.OutputState }

func (InstanceStatusResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceStatusResponse)(nil)).Elem()
}

func (o InstanceStatusResponseOutput) ToInstanceStatusResponseOutput() InstanceStatusResponseOutput {
	return o
}

func (o InstanceStatusResponseOutput) ToInstanceStatusResponseOutputWithContext(ctx context.Context) InstanceStatusResponseOutput {
	return o
}

// The VM boot disk.
func (o InstanceStatusResponseOutput) BootDisk() DiskResponseOutput {
	return o.ApplyT(func(v InstanceStatusResponse) DiskResponse { return v.BootDisk }).(DiskResponseOutput)
}

// The Compute Engine machine type.
func (o InstanceStatusResponseOutput) MachineType() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceStatusResponse) string { return v.MachineType }).(pulumi.StringOutput)
}

// The VM instance provisioning model.
func (o InstanceStatusResponseOutput) ProvisioningModel() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceStatusResponse) string { return v.ProvisioningModel }).(pulumi.StringOutput)
}

// The max number of tasks can be assigned to this instance type.
func (o InstanceStatusResponseOutput) TaskPack() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceStatusResponse) string { return v.TaskPack }).(pulumi.StringOutput)
}

type InstanceStatusResponseArrayOutput struct{ *pulumi.OutputState }

func (InstanceStatusResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceStatusResponse)(nil)).Elem()
}

func (o InstanceStatusResponseArrayOutput) ToInstanceStatusResponseArrayOutput() InstanceStatusResponseArrayOutput {
	return o
}

func (o InstanceStatusResponseArrayOutput) ToInstanceStatusResponseArrayOutputWithContext(ctx context.Context) InstanceStatusResponseArrayOutput {
	return o
}

func (o InstanceStatusResponseArrayOutput) Index(i pulumi.IntInput) InstanceStatusResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstanceStatusResponse {
		return vs[0].([]InstanceStatusResponse)[vs[1].(int)]
	}).(InstanceStatusResponseOutput)
}

// Notification configurations.
type JobNotification struct {
	// The attribute requirements of messages to be sent to this Pub/Sub topic. Without this field, no message will be sent.
	Message *Message `pulumi:"message"`
	// The Pub/Sub topic where notifications like the job state changes will be published. The topic must exist in the same project as the job and billings will be charged to this project. If not specified, no Pub/Sub messages will be sent. Topic format: `projects/{project}/topics/{topic}`.
	PubsubTopic *string `pulumi:"pubsubTopic"`
}

// JobNotificationInput is an input type that accepts JobNotificationArgs and JobNotificationOutput values.
// You can construct a concrete instance of `JobNotificationInput` via:
//
//	JobNotificationArgs{...}
type JobNotificationInput interface {
	pulumi.Input

	ToJobNotificationOutput() JobNotificationOutput
	ToJobNotificationOutputWithContext(context.Context) JobNotificationOutput
}

// Notification configurations.
type JobNotificationArgs struct {
	// The attribute requirements of messages to be sent to this Pub/Sub topic. Without this field, no message will be sent.
	Message MessagePtrInput `pulumi:"message"`
	// The Pub/Sub topic where notifications like the job state changes will be published. The topic must exist in the same project as the job and billings will be charged to this project. If not specified, no Pub/Sub messages will be sent. Topic format: `projects/{project}/topics/{topic}`.
	PubsubTopic pulumi.StringPtrInput `pulumi:"pubsubTopic"`
}

func (JobNotificationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobNotification)(nil)).Elem()
}

func (i JobNotificationArgs) ToJobNotificationOutput() JobNotificationOutput {
	return i.ToJobNotificationOutputWithContext(context.Background())
}

func (i JobNotificationArgs) ToJobNotificationOutputWithContext(ctx context.Context) JobNotificationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobNotificationOutput)
}

// JobNotificationArrayInput is an input type that accepts JobNotificationArray and JobNotificationArrayOutput values.
// You can construct a concrete instance of `JobNotificationArrayInput` via:
//
//	JobNotificationArray{ JobNotificationArgs{...} }
type JobNotificationArrayInput interface {
	pulumi.Input

	ToJobNotificationArrayOutput() JobNotificationArrayOutput
	ToJobNotificationArrayOutputWithContext(context.Context) JobNotificationArrayOutput
}

type JobNotificationArray []JobNotificationInput

func (JobNotificationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobNotification)(nil)).Elem()
}

func (i JobNotificationArray) ToJobNotificationArrayOutput() JobNotificationArrayOutput {
	return i.ToJobNotificationArrayOutputWithContext(context.Background())
}

func (i JobNotificationArray) ToJobNotificationArrayOutputWithContext(ctx context.Context) JobNotificationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobNotificationArrayOutput)
}

// Notification configurations.
type JobNotificationOutput struct{ *pulumi.OutputState }

func (JobNotificationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobNotification)(nil)).Elem()
}

func (o JobNotificationOutput) ToJobNotificationOutput() JobNotificationOutput {
	return o
}

func (o JobNotificationOutput) ToJobNotificationOutputWithContext(ctx context.Context) JobNotificationOutput {
	return o
}

// The attribute requirements of messages to be sent to this Pub/Sub topic. Without this field, no message will be sent.
func (o JobNotificationOutput) Message() MessagePtrOutput {
	return o.ApplyT(func(v JobNotification) *Message { return v.Message }).(MessagePtrOutput)
}

// The Pub/Sub topic where notifications like the job state changes will be published. The topic must exist in the same project as the job and billings will be charged to this project. If not specified, no Pub/Sub messages will be sent. Topic format: `projects/{project}/topics/{topic}`.
func (o JobNotificationOutput) PubsubTopic() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobNotification) *string { return v.PubsubTopic }).(pulumi.StringPtrOutput)
}

type JobNotificationArrayOutput struct{ *pulumi.OutputState }

func (JobNotificationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobNotification)(nil)).Elem()
}

func (o JobNotificationArrayOutput) ToJobNotificationArrayOutput() JobNotificationArrayOutput {
	return o
}

func (o JobNotificationArrayOutput) ToJobNotificationArrayOutputWithContext(ctx context.Context) JobNotificationArrayOutput {
	return o
}

func (o JobNotificationArrayOutput) Index(i pulumi.IntInput) JobNotificationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) JobNotification {
		return vs[0].([]JobNotification)[vs[1].(int)]
	}).(JobNotificationOutput)
}

// Notification configurations.
type JobNotificationResponse struct {
	// The attribute requirements of messages to be sent to this Pub/Sub topic. Without this field, no message will be sent.
	Message MessageResponse `pulumi:"message"`
	// The Pub/Sub topic where notifications like the job state changes will be published. The topic must exist in the same project as the job and billings will be charged to this project. If not specified, no Pub/Sub messages will be sent. Topic format: `projects/{project}/topics/{topic}`.
	PubsubTopic string `pulumi:"pubsubTopic"`
}

// Notification configurations.
type JobNotificationResponseOutput struct{ *pulumi.OutputState }

func (JobNotificationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobNotificationResponse)(nil)).Elem()
}

func (o JobNotificationResponseOutput) ToJobNotificationResponseOutput() JobNotificationResponseOutput {
	return o
}

func (o JobNotificationResponseOutput) ToJobNotificationResponseOutputWithContext(ctx context.Context) JobNotificationResponseOutput {
	return o
}

// The attribute requirements of messages to be sent to this Pub/Sub topic. Without this field, no message will be sent.
func (o JobNotificationResponseOutput) Message() MessageResponseOutput {
	return o.ApplyT(func(v JobNotificationResponse) MessageResponse { return v.Message }).(MessageResponseOutput)
}

// The Pub/Sub topic where notifications like the job state changes will be published. The topic must exist in the same project as the job and billings will be charged to this project. If not specified, no Pub/Sub messages will be sent. Topic format: `projects/{project}/topics/{topic}`.
func (o JobNotificationResponseOutput) PubsubTopic() pulumi.StringOutput {
	return o.ApplyT(func(v JobNotificationResponse) string { return v.PubsubTopic }).(pulumi.StringOutput)
}

type JobNotificationResponseArrayOutput struct{ *pulumi.OutputState }

func (JobNotificationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobNotificationResponse)(nil)).Elem()
}

func (o JobNotificationResponseArrayOutput) ToJobNotificationResponseArrayOutput() JobNotificationResponseArrayOutput {
	return o
}

func (o JobNotificationResponseArrayOutput) ToJobNotificationResponseArrayOutputWithContext(ctx context.Context) JobNotificationResponseArrayOutput {
	return o
}

func (o JobNotificationResponseArrayOutput) Index(i pulumi.IntInput) JobNotificationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) JobNotificationResponse {
		return vs[0].([]JobNotificationResponse)[vs[1].(int)]
	}).(JobNotificationResponseOutput)
}

// Job status.
type JobStatusResponse struct {
	// The duration of time that the Job spent in status RUNNING.
	RunDuration string `pulumi:"runDuration"`
	// Job state
	State string `pulumi:"state"`
	// Job status events
	StatusEvents []StatusEventResponse `pulumi:"statusEvents"`
	// Aggregated task status for each TaskGroup in the Job. The map key is TaskGroup ID.
	TaskGroups map[string]TaskGroupStatusResponse `pulumi:"taskGroups"`
}

// Job status.
type JobStatusResponseOutput struct{ *pulumi.OutputState }

func (JobStatusResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobStatusResponse)(nil)).Elem()
}

func (o JobStatusResponseOutput) ToJobStatusResponseOutput() JobStatusResponseOutput {
	return o
}

func (o JobStatusResponseOutput) ToJobStatusResponseOutputWithContext(ctx context.Context) JobStatusResponseOutput {
	return o
}

// The duration of time that the Job spent in status RUNNING.
func (o JobStatusResponseOutput) RunDuration() pulumi.StringOutput {
	return o.ApplyT(func(v JobStatusResponse) string { return v.RunDuration }).(pulumi.StringOutput)
}

// Job state
func (o JobStatusResponseOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v JobStatusResponse) string { return v.State }).(pulumi.StringOutput)
}

// Job status events
func (o JobStatusResponseOutput) StatusEvents() StatusEventResponseArrayOutput {
	return o.ApplyT(func(v JobStatusResponse) []StatusEventResponse { return v.StatusEvents }).(StatusEventResponseArrayOutput)
}

// Aggregated task status for each TaskGroup in the Job. The map key is TaskGroup ID.
func (o JobStatusResponseOutput) TaskGroups() TaskGroupStatusResponseMapOutput {
	return o.ApplyT(func(v JobStatusResponse) map[string]TaskGroupStatusResponse { return v.TaskGroups }).(TaskGroupStatusResponseMapOutput)
}

type KMSEnvMap struct {
	// The value of the cipherText response from the `encrypt` method.
	CipherText *string `pulumi:"cipherText"`
	// The name of the KMS key that will be used to decrypt the cipher text.
	KeyName *string `pulumi:"keyName"`
}

// KMSEnvMapInput is an input type that accepts KMSEnvMap and KMSEnvMapOutput values.
// You can construct a concrete instance of `KMSEnvMapInput` via:
//
//	KMSEnvMap{ "key": KMSEnvArgs{...} }
type KMSEnvMapInput interface {
	pulumi.Input

	ToKMSEnvMapOutput() KMSEnvMapOutput
	ToKMSEnvMapOutputWithContext(context.Context) KMSEnvMapOutput
}

type KMSEnvMapArgs struct {
	// The value of the cipherText response from the `encrypt` method.
	CipherText pulumi.StringPtrInput `pulumi:"cipherText"`
	// The name of the KMS key that will be used to decrypt the cipher text.
	KeyName pulumi.StringPtrInput `pulumi:"keyName"`
}

func (KMSEnvMapArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KMSEnvMap)(nil)).Elem()
}

func (i KMSEnvMapArgs) ToKMSEnvMapOutput() KMSEnvMapOutput {
	return i.ToKMSEnvMapOutputWithContext(context.Background())
}

func (i KMSEnvMapArgs) ToKMSEnvMapOutputWithContext(ctx context.Context) KMSEnvMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KMSEnvMapOutput)
}

func (i KMSEnvMapArgs) ToKMSEnvMapPtrOutput() KMSEnvMapPtrOutput {
	return i.ToKMSEnvMapPtrOutputWithContext(context.Background())
}

func (i KMSEnvMapArgs) ToKMSEnvMapPtrOutputWithContext(ctx context.Context) KMSEnvMapPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KMSEnvMapOutput).ToKMSEnvMapPtrOutputWithContext(ctx)
}

// KMSEnvMapPtrInput is an input type that accepts KMSEnvMapArgs, KMSEnvMapPtr and KMSEnvMapPtrOutput values.
// You can construct a concrete instance of `KMSEnvMapPtrInput` via:
//
//	        KMSEnvMapArgs{...}
//
//	or:
//
//	        nil
type KMSEnvMapPtrInput interface {
	pulumi.Input

	ToKMSEnvMapPtrOutput() KMSEnvMapPtrOutput
	ToKMSEnvMapPtrOutputWithContext(context.Context) KMSEnvMapPtrOutput
}

type kmsenvMapPtrType KMSEnvMapArgs

func KMSEnvMapPtr(v *KMSEnvMapArgs) KMSEnvMapPtrInput {
	return (*kmsenvMapPtrType)(v)
}

func (*kmsenvMapPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KMSEnvMap)(nil)).Elem()
}

func (i *kmsenvMapPtrType) ToKMSEnvMapPtrOutput() KMSEnvMapPtrOutput {
	return i.ToKMSEnvMapPtrOutputWithContext(context.Background())
}

func (i *kmsenvMapPtrType) ToKMSEnvMapPtrOutputWithContext(ctx context.Context) KMSEnvMapPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KMSEnvMapPtrOutput)
}

type KMSEnvMapOutput struct{ *pulumi.OutputState }

func (KMSEnvMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KMSEnvMap)(nil)).Elem()
}

func (o KMSEnvMapOutput) ToKMSEnvMapOutput() KMSEnvMapOutput {
	return o
}

func (o KMSEnvMapOutput) ToKMSEnvMapOutputWithContext(ctx context.Context) KMSEnvMapOutput {
	return o
}

func (o KMSEnvMapOutput) ToKMSEnvMapPtrOutput() KMSEnvMapPtrOutput {
	return o.ToKMSEnvMapPtrOutputWithContext(context.Background())
}

func (o KMSEnvMapOutput) ToKMSEnvMapPtrOutputWithContext(ctx context.Context) KMSEnvMapPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KMSEnvMap) *KMSEnvMap {
		return &v
	}).(KMSEnvMapPtrOutput)
}

// The value of the cipherText response from the `encrypt` method.
func (o KMSEnvMapOutput) CipherText() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KMSEnvMap) *string { return v.CipherText }).(pulumi.StringPtrOutput)
}

// The name of the KMS key that will be used to decrypt the cipher text.
func (o KMSEnvMapOutput) KeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KMSEnvMap) *string { return v.KeyName }).(pulumi.StringPtrOutput)
}

type KMSEnvMapPtrOutput struct{ *pulumi.OutputState }

func (KMSEnvMapPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KMSEnvMap)(nil)).Elem()
}

func (o KMSEnvMapPtrOutput) ToKMSEnvMapPtrOutput() KMSEnvMapPtrOutput {
	return o
}

func (o KMSEnvMapPtrOutput) ToKMSEnvMapPtrOutputWithContext(ctx context.Context) KMSEnvMapPtrOutput {
	return o
}

func (o KMSEnvMapPtrOutput) Elem() KMSEnvMapOutput {
	return o.ApplyT(func(v *KMSEnvMap) KMSEnvMap {
		if v != nil {
			return *v
		}
		var ret KMSEnvMap
		return ret
	}).(KMSEnvMapOutput)
}

// The value of the cipherText response from the `encrypt` method.
func (o KMSEnvMapPtrOutput) CipherText() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KMSEnvMap) *string {
		if v == nil {
			return nil
		}
		return v.CipherText
	}).(pulumi.StringPtrOutput)
}

// The name of the KMS key that will be used to decrypt the cipher text.
func (o KMSEnvMapPtrOutput) KeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KMSEnvMap) *string {
		if v == nil {
			return nil
		}
		return v.KeyName
	}).(pulumi.StringPtrOutput)
}

type KMSEnvMapResponse struct {
	// The value of the cipherText response from the `encrypt` method.
	CipherText string `pulumi:"cipherText"`
	// The name of the KMS key that will be used to decrypt the cipher text.
	KeyName string `pulumi:"keyName"`
}

type KMSEnvMapResponseOutput struct{ *pulumi.OutputState }

func (KMSEnvMapResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KMSEnvMapResponse)(nil)).Elem()
}

func (o KMSEnvMapResponseOutput) ToKMSEnvMapResponseOutput() KMSEnvMapResponseOutput {
	return o
}

func (o KMSEnvMapResponseOutput) ToKMSEnvMapResponseOutputWithContext(ctx context.Context) KMSEnvMapResponseOutput {
	return o
}

// The value of the cipherText response from the `encrypt` method.
func (o KMSEnvMapResponseOutput) CipherText() pulumi.StringOutput {
	return o.ApplyT(func(v KMSEnvMapResponse) string { return v.CipherText }).(pulumi.StringOutput)
}

// The name of the KMS key that will be used to decrypt the cipher text.
func (o KMSEnvMapResponseOutput) KeyName() pulumi.StringOutput {
	return o.ApplyT(func(v KMSEnvMapResponse) string { return v.KeyName }).(pulumi.StringOutput)
}

// LifecyclePolicy describes how to deal with task failures based on different conditions.
type LifecyclePolicy struct {
	// Action to execute when ActionCondition is true. When RETRY_TASK is specified, we will retry failed tasks if we notice any exit code match and fail tasks if no match is found. Likewise, when FAIL_TASK is specified, we will fail tasks if we notice any exit code match and retry tasks if no match is found.
	Action *LifecyclePolicyAction `pulumi:"action"`
	// Conditions that decide why a task failure is dealt with a specific action.
	ActionCondition *ActionCondition `pulumi:"actionCondition"`
}

// LifecyclePolicyInput is an input type that accepts LifecyclePolicyArgs and LifecyclePolicyOutput values.
// You can construct a concrete instance of `LifecyclePolicyInput` via:
//
//	LifecyclePolicyArgs{...}
type LifecyclePolicyInput interface {
	pulumi.Input

	ToLifecyclePolicyOutput() LifecyclePolicyOutput
	ToLifecyclePolicyOutputWithContext(context.Context) LifecyclePolicyOutput
}

// LifecyclePolicy describes how to deal with task failures based on different conditions.
type LifecyclePolicyArgs struct {
	// Action to execute when ActionCondition is true. When RETRY_TASK is specified, we will retry failed tasks if we notice any exit code match and fail tasks if no match is found. Likewise, when FAIL_TASK is specified, we will fail tasks if we notice any exit code match and retry tasks if no match is found.
	Action LifecyclePolicyActionPtrInput `pulumi:"action"`
	// Conditions that decide why a task failure is dealt with a specific action.
	ActionCondition ActionConditionPtrInput `pulumi:"actionCondition"`
}

func (LifecyclePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LifecyclePolicy)(nil)).Elem()
}

func (i LifecyclePolicyArgs) ToLifecyclePolicyOutput() LifecyclePolicyOutput {
	return i.ToLifecyclePolicyOutputWithContext(context.Background())
}

func (i LifecyclePolicyArgs) ToLifecyclePolicyOutputWithContext(ctx context.Context) LifecyclePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LifecyclePolicyOutput)
}

// LifecyclePolicyArrayInput is an input type that accepts LifecyclePolicyArray and LifecyclePolicyArrayOutput values.
// You can construct a concrete instance of `LifecyclePolicyArrayInput` via:
//
//	LifecyclePolicyArray{ LifecyclePolicyArgs{...} }
type LifecyclePolicyArrayInput interface {
	pulumi.Input

	ToLifecyclePolicyArrayOutput() LifecyclePolicyArrayOutput
	ToLifecyclePolicyArrayOutputWithContext(context.Context) LifecyclePolicyArrayOutput
}

type LifecyclePolicyArray []LifecyclePolicyInput

func (LifecyclePolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LifecyclePolicy)(nil)).Elem()
}

func (i LifecyclePolicyArray) ToLifecyclePolicyArrayOutput() LifecyclePolicyArrayOutput {
	return i.ToLifecyclePolicyArrayOutputWithContext(context.Background())
}

func (i LifecyclePolicyArray) ToLifecyclePolicyArrayOutputWithContext(ctx context.Context) LifecyclePolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LifecyclePolicyArrayOutput)
}

// LifecyclePolicy describes how to deal with task failures based on different conditions.
type LifecyclePolicyOutput struct{ *pulumi.OutputState }

func (LifecyclePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LifecyclePolicy)(nil)).Elem()
}

func (o LifecyclePolicyOutput) ToLifecyclePolicyOutput() LifecyclePolicyOutput {
	return o
}

func (o LifecyclePolicyOutput) ToLifecyclePolicyOutputWithContext(ctx context.Context) LifecyclePolicyOutput {
	return o
}

// Action to execute when ActionCondition is true. When RETRY_TASK is specified, we will retry failed tasks if we notice any exit code match and fail tasks if no match is found. Likewise, when FAIL_TASK is specified, we will fail tasks if we notice any exit code match and retry tasks if no match is found.
func (o LifecyclePolicyOutput) Action() LifecyclePolicyActionPtrOutput {
	return o.ApplyT(func(v LifecyclePolicy) *LifecyclePolicyAction { return v.Action }).(LifecyclePolicyActionPtrOutput)
}

// Conditions that decide why a task failure is dealt with a specific action.
func (o LifecyclePolicyOutput) ActionCondition() ActionConditionPtrOutput {
	return o.ApplyT(func(v LifecyclePolicy) *ActionCondition { return v.ActionCondition }).(ActionConditionPtrOutput)
}

type LifecyclePolicyArrayOutput struct{ *pulumi.OutputState }

func (LifecyclePolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LifecyclePolicy)(nil)).Elem()
}

func (o LifecyclePolicyArrayOutput) ToLifecyclePolicyArrayOutput() LifecyclePolicyArrayOutput {
	return o
}

func (o LifecyclePolicyArrayOutput) ToLifecyclePolicyArrayOutputWithContext(ctx context.Context) LifecyclePolicyArrayOutput {
	return o
}

func (o LifecyclePolicyArrayOutput) Index(i pulumi.IntInput) LifecyclePolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LifecyclePolicy {
		return vs[0].([]LifecyclePolicy)[vs[1].(int)]
	}).(LifecyclePolicyOutput)
}

// LifecyclePolicy describes how to deal with task failures based on different conditions.
type LifecyclePolicyResponse struct {
	// Action to execute when ActionCondition is true. When RETRY_TASK is specified, we will retry failed tasks if we notice any exit code match and fail tasks if no match is found. Likewise, when FAIL_TASK is specified, we will fail tasks if we notice any exit code match and retry tasks if no match is found.
	Action string `pulumi:"action"`
	// Conditions that decide why a task failure is dealt with a specific action.
	ActionCondition ActionConditionResponse `pulumi:"actionCondition"`
}

// LifecyclePolicy describes how to deal with task failures based on different conditions.
type LifecyclePolicyResponseOutput struct{ *pulumi.OutputState }

func (LifecyclePolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LifecyclePolicyResponse)(nil)).Elem()
}

func (o LifecyclePolicyResponseOutput) ToLifecyclePolicyResponseOutput() LifecyclePolicyResponseOutput {
	return o
}

func (o LifecyclePolicyResponseOutput) ToLifecyclePolicyResponseOutputWithContext(ctx context.Context) LifecyclePolicyResponseOutput {
	return o
}

// Action to execute when ActionCondition is true. When RETRY_TASK is specified, we will retry failed tasks if we notice any exit code match and fail tasks if no match is found. Likewise, when FAIL_TASK is specified, we will fail tasks if we notice any exit code match and retry tasks if no match is found.
func (o LifecyclePolicyResponseOutput) Action() pulumi.StringOutput {
	return o.ApplyT(func(v LifecyclePolicyResponse) string { return v.Action }).(pulumi.StringOutput)
}

// Conditions that decide why a task failure is dealt with a specific action.
func (o LifecyclePolicyResponseOutput) ActionCondition() ActionConditionResponseOutput {
	return o.ApplyT(func(v LifecyclePolicyResponse) ActionConditionResponse { return v.ActionCondition }).(ActionConditionResponseOutput)
}

type LifecyclePolicyResponseArrayOutput struct{ *pulumi.OutputState }

func (LifecyclePolicyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LifecyclePolicyResponse)(nil)).Elem()
}

func (o LifecyclePolicyResponseArrayOutput) ToLifecyclePolicyResponseArrayOutput() LifecyclePolicyResponseArrayOutput {
	return o
}

func (o LifecyclePolicyResponseArrayOutput) ToLifecyclePolicyResponseArrayOutputWithContext(ctx context.Context) LifecyclePolicyResponseArrayOutput {
	return o
}

func (o LifecyclePolicyResponseArrayOutput) Index(i pulumi.IntInput) LifecyclePolicyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LifecyclePolicyResponse {
		return vs[0].([]LifecyclePolicyResponse)[vs[1].(int)]
	}).(LifecyclePolicyResponseOutput)
}

type LocationPolicy struct {
	// A list of allowed location names represented by internal URLs. Each location can be a region or a zone. Only one region or multiple zones in one region is supported now. For example, ["regions/us-central1"] allow VMs in any zones in region us-central1. ["zones/us-central1-a", "zones/us-central1-c"] only allow VMs in zones us-central1-a and us-central1-c. All locations end up in different regions would cause errors. For example, ["regions/us-central1", "zones/us-central1-a", "zones/us-central1-b", "zones/us-west1-a"] contains 2 regions "us-central1" and "us-west1". An error is expected in this case.
	AllowedLocations []string `pulumi:"allowedLocations"`
}

// LocationPolicyInput is an input type that accepts LocationPolicyArgs and LocationPolicyOutput values.
// You can construct a concrete instance of `LocationPolicyInput` via:
//
//	LocationPolicyArgs{...}
type LocationPolicyInput interface {
	pulumi.Input

	ToLocationPolicyOutput() LocationPolicyOutput
	ToLocationPolicyOutputWithContext(context.Context) LocationPolicyOutput
}

type LocationPolicyArgs struct {
	// A list of allowed location names represented by internal URLs. Each location can be a region or a zone. Only one region or multiple zones in one region is supported now. For example, ["regions/us-central1"] allow VMs in any zones in region us-central1. ["zones/us-central1-a", "zones/us-central1-c"] only allow VMs in zones us-central1-a and us-central1-c. All locations end up in different regions would cause errors. For example, ["regions/us-central1", "zones/us-central1-a", "zones/us-central1-b", "zones/us-west1-a"] contains 2 regions "us-central1" and "us-west1". An error is expected in this case.
	AllowedLocations pulumi.StringArrayInput `pulumi:"allowedLocations"`
}

func (LocationPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationPolicy)(nil)).Elem()
}

func (i LocationPolicyArgs) ToLocationPolicyOutput() LocationPolicyOutput {
	return i.ToLocationPolicyOutputWithContext(context.Background())
}

func (i LocationPolicyArgs) ToLocationPolicyOutputWithContext(ctx context.Context) LocationPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationPolicyOutput)
}

func (i LocationPolicyArgs) ToLocationPolicyPtrOutput() LocationPolicyPtrOutput {
	return i.ToLocationPolicyPtrOutputWithContext(context.Background())
}

func (i LocationPolicyArgs) ToLocationPolicyPtrOutputWithContext(ctx context.Context) LocationPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationPolicyOutput).ToLocationPolicyPtrOutputWithContext(ctx)
}

// LocationPolicyPtrInput is an input type that accepts LocationPolicyArgs, LocationPolicyPtr and LocationPolicyPtrOutput values.
// You can construct a concrete instance of `LocationPolicyPtrInput` via:
//
//	        LocationPolicyArgs{...}
//
//	or:
//
//	        nil
type LocationPolicyPtrInput interface {
	pulumi.Input

	ToLocationPolicyPtrOutput() LocationPolicyPtrOutput
	ToLocationPolicyPtrOutputWithContext(context.Context) LocationPolicyPtrOutput
}

type locationPolicyPtrType LocationPolicyArgs

func LocationPolicyPtr(v *LocationPolicyArgs) LocationPolicyPtrInput {
	return (*locationPolicyPtrType)(v)
}

func (*locationPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LocationPolicy)(nil)).Elem()
}

func (i *locationPolicyPtrType) ToLocationPolicyPtrOutput() LocationPolicyPtrOutput {
	return i.ToLocationPolicyPtrOutputWithContext(context.Background())
}

func (i *locationPolicyPtrType) ToLocationPolicyPtrOutputWithContext(ctx context.Context) LocationPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationPolicyPtrOutput)
}

type LocationPolicyOutput struct{ *pulumi.OutputState }

func (LocationPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationPolicy)(nil)).Elem()
}

func (o LocationPolicyOutput) ToLocationPolicyOutput() LocationPolicyOutput {
	return o
}

func (o LocationPolicyOutput) ToLocationPolicyOutputWithContext(ctx context.Context) LocationPolicyOutput {
	return o
}

func (o LocationPolicyOutput) ToLocationPolicyPtrOutput() LocationPolicyPtrOutput {
	return o.ToLocationPolicyPtrOutputWithContext(context.Background())
}

func (o LocationPolicyOutput) ToLocationPolicyPtrOutputWithContext(ctx context.Context) LocationPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LocationPolicy) *LocationPolicy {
		return &v
	}).(LocationPolicyPtrOutput)
}

// A list of allowed location names represented by internal URLs. Each location can be a region or a zone. Only one region or multiple zones in one region is supported now. For example, ["regions/us-central1"] allow VMs in any zones in region us-central1. ["zones/us-central1-a", "zones/us-central1-c"] only allow VMs in zones us-central1-a and us-central1-c. All locations end up in different regions would cause errors. For example, ["regions/us-central1", "zones/us-central1-a", "zones/us-central1-b", "zones/us-west1-a"] contains 2 regions "us-central1" and "us-west1". An error is expected in this case.
func (o LocationPolicyOutput) AllowedLocations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LocationPolicy) []string { return v.AllowedLocations }).(pulumi.StringArrayOutput)
}

type LocationPolicyPtrOutput struct{ *pulumi.OutputState }

func (LocationPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LocationPolicy)(nil)).Elem()
}

func (o LocationPolicyPtrOutput) ToLocationPolicyPtrOutput() LocationPolicyPtrOutput {
	return o
}

func (o LocationPolicyPtrOutput) ToLocationPolicyPtrOutputWithContext(ctx context.Context) LocationPolicyPtrOutput {
	return o
}

func (o LocationPolicyPtrOutput) Elem() LocationPolicyOutput {
	return o.ApplyT(func(v *LocationPolicy) LocationPolicy {
		if v != nil {
			return *v
		}
		var ret LocationPolicy
		return ret
	}).(LocationPolicyOutput)
}

// A list of allowed location names represented by internal URLs. Each location can be a region or a zone. Only one region or multiple zones in one region is supported now. For example, ["regions/us-central1"] allow VMs in any zones in region us-central1. ["zones/us-central1-a", "zones/us-central1-c"] only allow VMs in zones us-central1-a and us-central1-c. All locations end up in different regions would cause errors. For example, ["regions/us-central1", "zones/us-central1-a", "zones/us-central1-b", "zones/us-west1-a"] contains 2 regions "us-central1" and "us-west1". An error is expected in this case.
func (o LocationPolicyPtrOutput) AllowedLocations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LocationPolicy) []string {
		if v == nil {
			return nil
		}
		return v.AllowedLocations
	}).(pulumi.StringArrayOutput)
}

type LocationPolicyResponse struct {
	// A list of allowed location names represented by internal URLs. Each location can be a region or a zone. Only one region or multiple zones in one region is supported now. For example, ["regions/us-central1"] allow VMs in any zones in region us-central1. ["zones/us-central1-a", "zones/us-central1-c"] only allow VMs in zones us-central1-a and us-central1-c. All locations end up in different regions would cause errors. For example, ["regions/us-central1", "zones/us-central1-a", "zones/us-central1-b", "zones/us-west1-a"] contains 2 regions "us-central1" and "us-west1". An error is expected in this case.
	AllowedLocations []string `pulumi:"allowedLocations"`
}

type LocationPolicyResponseOutput struct{ *pulumi.OutputState }

func (LocationPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationPolicyResponse)(nil)).Elem()
}

func (o LocationPolicyResponseOutput) ToLocationPolicyResponseOutput() LocationPolicyResponseOutput {
	return o
}

func (o LocationPolicyResponseOutput) ToLocationPolicyResponseOutputWithContext(ctx context.Context) LocationPolicyResponseOutput {
	return o
}

// A list of allowed location names represented by internal URLs. Each location can be a region or a zone. Only one region or multiple zones in one region is supported now. For example, ["regions/us-central1"] allow VMs in any zones in region us-central1. ["zones/us-central1-a", "zones/us-central1-c"] only allow VMs in zones us-central1-a and us-central1-c. All locations end up in different regions would cause errors. For example, ["regions/us-central1", "zones/us-central1-a", "zones/us-central1-b", "zones/us-west1-a"] contains 2 regions "us-central1" and "us-west1". An error is expected in this case.
func (o LocationPolicyResponseOutput) AllowedLocations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LocationPolicyResponse) []string { return v.AllowedLocations }).(pulumi.StringArrayOutput)
}

// LogsPolicy describes how outputs from a Job's Tasks (stdout/stderr) will be preserved.
type LogsPolicy struct {
	// Optional. Additional settings for Cloud Logging. It will only take effect when the destination of LogsPolicy is set to CLOUD_LOGGING.
	CloudLoggingOption *CloudLoggingOption `pulumi:"cloudLoggingOption"`
	// Where logs should be saved.
	Destination *LogsPolicyDestination `pulumi:"destination"`
	// The path to which logs are saved when the destination = PATH. This can be a local file path on the VM, or under the mount point of a Persistent Disk or Filestore, or a Cloud Storage path.
	LogsPath *string `pulumi:"logsPath"`
}

// LogsPolicyInput is an input type that accepts LogsPolicyArgs and LogsPolicyOutput values.
// You can construct a concrete instance of `LogsPolicyInput` via:
//
//	LogsPolicyArgs{...}
type LogsPolicyInput interface {
	pulumi.Input

	ToLogsPolicyOutput() LogsPolicyOutput
	ToLogsPolicyOutputWithContext(context.Context) LogsPolicyOutput
}

// LogsPolicy describes how outputs from a Job's Tasks (stdout/stderr) will be preserved.
type LogsPolicyArgs struct {
	// Optional. Additional settings for Cloud Logging. It will only take effect when the destination of LogsPolicy is set to CLOUD_LOGGING.
	CloudLoggingOption CloudLoggingOptionPtrInput `pulumi:"cloudLoggingOption"`
	// Where logs should be saved.
	Destination LogsPolicyDestinationPtrInput `pulumi:"destination"`
	// The path to which logs are saved when the destination = PATH. This can be a local file path on the VM, or under the mount point of a Persistent Disk or Filestore, or a Cloud Storage path.
	LogsPath pulumi.StringPtrInput `pulumi:"logsPath"`
}

func (LogsPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogsPolicy)(nil)).Elem()
}

func (i LogsPolicyArgs) ToLogsPolicyOutput() LogsPolicyOutput {
	return i.ToLogsPolicyOutputWithContext(context.Background())
}

func (i LogsPolicyArgs) ToLogsPolicyOutputWithContext(ctx context.Context) LogsPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsPolicyOutput)
}

func (i LogsPolicyArgs) ToLogsPolicyPtrOutput() LogsPolicyPtrOutput {
	return i.ToLogsPolicyPtrOutputWithContext(context.Background())
}

func (i LogsPolicyArgs) ToLogsPolicyPtrOutputWithContext(ctx context.Context) LogsPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsPolicyOutput).ToLogsPolicyPtrOutputWithContext(ctx)
}

// LogsPolicyPtrInput is an input type that accepts LogsPolicyArgs, LogsPolicyPtr and LogsPolicyPtrOutput values.
// You can construct a concrete instance of `LogsPolicyPtrInput` via:
//
//	        LogsPolicyArgs{...}
//
//	or:
//
//	        nil
type LogsPolicyPtrInput interface {
	pulumi.Input

	ToLogsPolicyPtrOutput() LogsPolicyPtrOutput
	ToLogsPolicyPtrOutputWithContext(context.Context) LogsPolicyPtrOutput
}

type logsPolicyPtrType LogsPolicyArgs

func LogsPolicyPtr(v *LogsPolicyArgs) LogsPolicyPtrInput {
	return (*logsPolicyPtrType)(v)
}

func (*logsPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogsPolicy)(nil)).Elem()
}

func (i *logsPolicyPtrType) ToLogsPolicyPtrOutput() LogsPolicyPtrOutput {
	return i.ToLogsPolicyPtrOutputWithContext(context.Background())
}

func (i *logsPolicyPtrType) ToLogsPolicyPtrOutputWithContext(ctx context.Context) LogsPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsPolicyPtrOutput)
}

// LogsPolicy describes how outputs from a Job's Tasks (stdout/stderr) will be preserved.
type LogsPolicyOutput struct{ *pulumi.OutputState }

func (LogsPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogsPolicy)(nil)).Elem()
}

func (o LogsPolicyOutput) ToLogsPolicyOutput() LogsPolicyOutput {
	return o
}

func (o LogsPolicyOutput) ToLogsPolicyOutputWithContext(ctx context.Context) LogsPolicyOutput {
	return o
}

func (o LogsPolicyOutput) ToLogsPolicyPtrOutput() LogsPolicyPtrOutput {
	return o.ToLogsPolicyPtrOutputWithContext(context.Background())
}

func (o LogsPolicyOutput) ToLogsPolicyPtrOutputWithContext(ctx context.Context) LogsPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogsPolicy) *LogsPolicy {
		return &v
	}).(LogsPolicyPtrOutput)
}

// Optional. Additional settings for Cloud Logging. It will only take effect when the destination of LogsPolicy is set to CLOUD_LOGGING.
func (o LogsPolicyOutput) CloudLoggingOption() CloudLoggingOptionPtrOutput {
	return o.ApplyT(func(v LogsPolicy) *CloudLoggingOption { return v.CloudLoggingOption }).(CloudLoggingOptionPtrOutput)
}

// Where logs should be saved.
func (o LogsPolicyOutput) Destination() LogsPolicyDestinationPtrOutput {
	return o.ApplyT(func(v LogsPolicy) *LogsPolicyDestination { return v.Destination }).(LogsPolicyDestinationPtrOutput)
}

// The path to which logs are saved when the destination = PATH. This can be a local file path on the VM, or under the mount point of a Persistent Disk or Filestore, or a Cloud Storage path.
func (o LogsPolicyOutput) LogsPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogsPolicy) *string { return v.LogsPath }).(pulumi.StringPtrOutput)
}

type LogsPolicyPtrOutput struct{ *pulumi.OutputState }

func (LogsPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogsPolicy)(nil)).Elem()
}

func (o LogsPolicyPtrOutput) ToLogsPolicyPtrOutput() LogsPolicyPtrOutput {
	return o
}

func (o LogsPolicyPtrOutput) ToLogsPolicyPtrOutputWithContext(ctx context.Context) LogsPolicyPtrOutput {
	return o
}

func (o LogsPolicyPtrOutput) Elem() LogsPolicyOutput {
	return o.ApplyT(func(v *LogsPolicy) LogsPolicy {
		if v != nil {
			return *v
		}
		var ret LogsPolicy
		return ret
	}).(LogsPolicyOutput)
}

// Optional. Additional settings for Cloud Logging. It will only take effect when the destination of LogsPolicy is set to CLOUD_LOGGING.
func (o LogsPolicyPtrOutput) CloudLoggingOption() CloudLoggingOptionPtrOutput {
	return o.ApplyT(func(v *LogsPolicy) *CloudLoggingOption {
		if v == nil {
			return nil
		}
		return v.CloudLoggingOption
	}).(CloudLoggingOptionPtrOutput)
}

// Where logs should be saved.
func (o LogsPolicyPtrOutput) Destination() LogsPolicyDestinationPtrOutput {
	return o.ApplyT(func(v *LogsPolicy) *LogsPolicyDestination {
		if v == nil {
			return nil
		}
		return v.Destination
	}).(LogsPolicyDestinationPtrOutput)
}

// The path to which logs are saved when the destination = PATH. This can be a local file path on the VM, or under the mount point of a Persistent Disk or Filestore, or a Cloud Storage path.
func (o LogsPolicyPtrOutput) LogsPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogsPolicy) *string {
		if v == nil {
			return nil
		}
		return v.LogsPath
	}).(pulumi.StringPtrOutput)
}

// LogsPolicy describes how outputs from a Job's Tasks (stdout/stderr) will be preserved.
type LogsPolicyResponse struct {
	// Optional. Additional settings for Cloud Logging. It will only take effect when the destination of LogsPolicy is set to CLOUD_LOGGING.
	CloudLoggingOption CloudLoggingOptionResponse `pulumi:"cloudLoggingOption"`
	// Where logs should be saved.
	Destination string `pulumi:"destination"`
	// The path to which logs are saved when the destination = PATH. This can be a local file path on the VM, or under the mount point of a Persistent Disk or Filestore, or a Cloud Storage path.
	LogsPath string `pulumi:"logsPath"`
}

// LogsPolicy describes how outputs from a Job's Tasks (stdout/stderr) will be preserved.
type LogsPolicyResponseOutput struct{ *pulumi.OutputState }

func (LogsPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogsPolicyResponse)(nil)).Elem()
}

func (o LogsPolicyResponseOutput) ToLogsPolicyResponseOutput() LogsPolicyResponseOutput {
	return o
}

func (o LogsPolicyResponseOutput) ToLogsPolicyResponseOutputWithContext(ctx context.Context) LogsPolicyResponseOutput {
	return o
}

// Optional. Additional settings for Cloud Logging. It will only take effect when the destination of LogsPolicy is set to CLOUD_LOGGING.
func (o LogsPolicyResponseOutput) CloudLoggingOption() CloudLoggingOptionResponseOutput {
	return o.ApplyT(func(v LogsPolicyResponse) CloudLoggingOptionResponse { return v.CloudLoggingOption }).(CloudLoggingOptionResponseOutput)
}

// Where logs should be saved.
func (o LogsPolicyResponseOutput) Destination() pulumi.StringOutput {
	return o.ApplyT(func(v LogsPolicyResponse) string { return v.Destination }).(pulumi.StringOutput)
}

// The path to which logs are saved when the destination = PATH. This can be a local file path on the VM, or under the mount point of a Persistent Disk or Filestore, or a Cloud Storage path.
func (o LogsPolicyResponseOutput) LogsPath() pulumi.StringOutput {
	return o.ApplyT(func(v LogsPolicyResponse) string { return v.LogsPath }).(pulumi.StringOutput)
}

// Message details. Describe the conditions under which messages will be sent. If no attribute is defined, no message will be sent by default. One message should specify either the job or the task level attributes, but not both. For example, job level: JOB_STATE_CHANGED and/or a specified new_job_state; task level: TASK_STATE_CHANGED and/or a specified new_task_state.
type Message struct {
	// The new job state.
	NewJobState *MessageNewJobState `pulumi:"newJobState"`
	// The new task state.
	NewTaskState *MessageNewTaskState `pulumi:"newTaskState"`
	// The message type.
	Type *MessageType `pulumi:"type"`
}

// MessageInput is an input type that accepts MessageArgs and MessageOutput values.
// You can construct a concrete instance of `MessageInput` via:
//
//	MessageArgs{...}
type MessageInput interface {
	pulumi.Input

	ToMessageOutput() MessageOutput
	ToMessageOutputWithContext(context.Context) MessageOutput
}

// Message details. Describe the conditions under which messages will be sent. If no attribute is defined, no message will be sent by default. One message should specify either the job or the task level attributes, but not both. For example, job level: JOB_STATE_CHANGED and/or a specified new_job_state; task level: TASK_STATE_CHANGED and/or a specified new_task_state.
type MessageArgs struct {
	// The new job state.
	NewJobState MessageNewJobStatePtrInput `pulumi:"newJobState"`
	// The new task state.
	NewTaskState MessageNewTaskStatePtrInput `pulumi:"newTaskState"`
	// The message type.
	Type MessageTypePtrInput `pulumi:"type"`
}

func (MessageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Message)(nil)).Elem()
}

func (i MessageArgs) ToMessageOutput() MessageOutput {
	return i.ToMessageOutputWithContext(context.Background())
}

func (i MessageArgs) ToMessageOutputWithContext(ctx context.Context) MessageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MessageOutput)
}

func (i MessageArgs) ToMessagePtrOutput() MessagePtrOutput {
	return i.ToMessagePtrOutputWithContext(context.Background())
}

func (i MessageArgs) ToMessagePtrOutputWithContext(ctx context.Context) MessagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MessageOutput).ToMessagePtrOutputWithContext(ctx)
}

// MessagePtrInput is an input type that accepts MessageArgs, MessagePtr and MessagePtrOutput values.
// You can construct a concrete instance of `MessagePtrInput` via:
//
//	        MessageArgs{...}
//
//	or:
//
//	        nil
type MessagePtrInput interface {
	pulumi.Input

	ToMessagePtrOutput() MessagePtrOutput
	ToMessagePtrOutputWithContext(context.Context) MessagePtrOutput
}

type messagePtrType MessageArgs

func MessagePtr(v *MessageArgs) MessagePtrInput {
	return (*messagePtrType)(v)
}

func (*messagePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Message)(nil)).Elem()
}

func (i *messagePtrType) ToMessagePtrOutput() MessagePtrOutput {
	return i.ToMessagePtrOutputWithContext(context.Background())
}

func (i *messagePtrType) ToMessagePtrOutputWithContext(ctx context.Context) MessagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MessagePtrOutput)
}

// Message details. Describe the conditions under which messages will be sent. If no attribute is defined, no message will be sent by default. One message should specify either the job or the task level attributes, but not both. For example, job level: JOB_STATE_CHANGED and/or a specified new_job_state; task level: TASK_STATE_CHANGED and/or a specified new_task_state.
type MessageOutput struct{ *pulumi.OutputState }

func (MessageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Message)(nil)).Elem()
}

func (o MessageOutput) ToMessageOutput() MessageOutput {
	return o
}

func (o MessageOutput) ToMessageOutputWithContext(ctx context.Context) MessageOutput {
	return o
}

func (o MessageOutput) ToMessagePtrOutput() MessagePtrOutput {
	return o.ToMessagePtrOutputWithContext(context.Background())
}

func (o MessageOutput) ToMessagePtrOutputWithContext(ctx context.Context) MessagePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Message) *Message {
		return &v
	}).(MessagePtrOutput)
}

// The new job state.
func (o MessageOutput) NewJobState() MessageNewJobStatePtrOutput {
	return o.ApplyT(func(v Message) *MessageNewJobState { return v.NewJobState }).(MessageNewJobStatePtrOutput)
}

// The new task state.
func (o MessageOutput) NewTaskState() MessageNewTaskStatePtrOutput {
	return o.ApplyT(func(v Message) *MessageNewTaskState { return v.NewTaskState }).(MessageNewTaskStatePtrOutput)
}

// The message type.
func (o MessageOutput) Type() MessageTypePtrOutput {
	return o.ApplyT(func(v Message) *MessageType { return v.Type }).(MessageTypePtrOutput)
}

type MessagePtrOutput struct{ *pulumi.OutputState }

func (MessagePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Message)(nil)).Elem()
}

func (o MessagePtrOutput) ToMessagePtrOutput() MessagePtrOutput {
	return o
}

func (o MessagePtrOutput) ToMessagePtrOutputWithContext(ctx context.Context) MessagePtrOutput {
	return o
}

func (o MessagePtrOutput) Elem() MessageOutput {
	return o.ApplyT(func(v *Message) Message {
		if v != nil {
			return *v
		}
		var ret Message
		return ret
	}).(MessageOutput)
}

// The new job state.
func (o MessagePtrOutput) NewJobState() MessageNewJobStatePtrOutput {
	return o.ApplyT(func(v *Message) *MessageNewJobState {
		if v == nil {
			return nil
		}
		return v.NewJobState
	}).(MessageNewJobStatePtrOutput)
}

// The new task state.
func (o MessagePtrOutput) NewTaskState() MessageNewTaskStatePtrOutput {
	return o.ApplyT(func(v *Message) *MessageNewTaskState {
		if v == nil {
			return nil
		}
		return v.NewTaskState
	}).(MessageNewTaskStatePtrOutput)
}

// The message type.
func (o MessagePtrOutput) Type() MessageTypePtrOutput {
	return o.ApplyT(func(v *Message) *MessageType {
		if v == nil {
			return nil
		}
		return v.Type
	}).(MessageTypePtrOutput)
}

// Message details. Describe the conditions under which messages will be sent. If no attribute is defined, no message will be sent by default. One message should specify either the job or the task level attributes, but not both. For example, job level: JOB_STATE_CHANGED and/or a specified new_job_state; task level: TASK_STATE_CHANGED and/or a specified new_task_state.
type MessageResponse struct {
	// The new job state.
	NewJobState string `pulumi:"newJobState"`
	// The new task state.
	NewTaskState string `pulumi:"newTaskState"`
	// The message type.
	Type string `pulumi:"type"`
}

// Message details. Describe the conditions under which messages will be sent. If no attribute is defined, no message will be sent by default. One message should specify either the job or the task level attributes, but not both. For example, job level: JOB_STATE_CHANGED and/or a specified new_job_state; task level: TASK_STATE_CHANGED and/or a specified new_task_state.
type MessageResponseOutput struct{ *pulumi.OutputState }

func (MessageResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MessageResponse)(nil)).Elem()
}

func (o MessageResponseOutput) ToMessageResponseOutput() MessageResponseOutput {
	return o
}

func (o MessageResponseOutput) ToMessageResponseOutputWithContext(ctx context.Context) MessageResponseOutput {
	return o
}

// The new job state.
func (o MessageResponseOutput) NewJobState() pulumi.StringOutput {
	return o.ApplyT(func(v MessageResponse) string { return v.NewJobState }).(pulumi.StringOutput)
}

// The new task state.
func (o MessageResponseOutput) NewTaskState() pulumi.StringOutput {
	return o.ApplyT(func(v MessageResponse) string { return v.NewTaskState }).(pulumi.StringOutput)
}

// The message type.
func (o MessageResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v MessageResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Represents an NFS volume.
type NFS struct {
	// Remote source path exported from the NFS, e.g., "/share".
	RemotePath *string `pulumi:"remotePath"`
	// The IP address of the NFS.
	Server *string `pulumi:"server"`
}

// NFSInput is an input type that accepts NFSArgs and NFSOutput values.
// You can construct a concrete instance of `NFSInput` via:
//
//	NFSArgs{...}
type NFSInput interface {
	pulumi.Input

	ToNFSOutput() NFSOutput
	ToNFSOutputWithContext(context.Context) NFSOutput
}

// Represents an NFS volume.
type NFSArgs struct {
	// Remote source path exported from the NFS, e.g., "/share".
	RemotePath pulumi.StringPtrInput `pulumi:"remotePath"`
	// The IP address of the NFS.
	Server pulumi.StringPtrInput `pulumi:"server"`
}

func (NFSArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NFS)(nil)).Elem()
}

func (i NFSArgs) ToNFSOutput() NFSOutput {
	return i.ToNFSOutputWithContext(context.Background())
}

func (i NFSArgs) ToNFSOutputWithContext(ctx context.Context) NFSOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NFSOutput)
}

func (i NFSArgs) ToNFSPtrOutput() NFSPtrOutput {
	return i.ToNFSPtrOutputWithContext(context.Background())
}

func (i NFSArgs) ToNFSPtrOutputWithContext(ctx context.Context) NFSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NFSOutput).ToNFSPtrOutputWithContext(ctx)
}

// NFSPtrInput is an input type that accepts NFSArgs, NFSPtr and NFSPtrOutput values.
// You can construct a concrete instance of `NFSPtrInput` via:
//
//	        NFSArgs{...}
//
//	or:
//
//	        nil
type NFSPtrInput interface {
	pulumi.Input

	ToNFSPtrOutput() NFSPtrOutput
	ToNFSPtrOutputWithContext(context.Context) NFSPtrOutput
}

type nfsPtrType NFSArgs

func NFSPtr(v *NFSArgs) NFSPtrInput {
	return (*nfsPtrType)(v)
}

func (*nfsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NFS)(nil)).Elem()
}

func (i *nfsPtrType) ToNFSPtrOutput() NFSPtrOutput {
	return i.ToNFSPtrOutputWithContext(context.Background())
}

func (i *nfsPtrType) ToNFSPtrOutputWithContext(ctx context.Context) NFSPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NFSPtrOutput)
}

// Represents an NFS volume.
type NFSOutput struct{ *pulumi.OutputState }

func (NFSOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NFS)(nil)).Elem()
}

func (o NFSOutput) ToNFSOutput() NFSOutput {
	return o
}

func (o NFSOutput) ToNFSOutputWithContext(ctx context.Context) NFSOutput {
	return o
}

func (o NFSOutput) ToNFSPtrOutput() NFSPtrOutput {
	return o.ToNFSPtrOutputWithContext(context.Background())
}

func (o NFSOutput) ToNFSPtrOutputWithContext(ctx context.Context) NFSPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NFS) *NFS {
		return &v
	}).(NFSPtrOutput)
}

// Remote source path exported from the NFS, e.g., "/share".
func (o NFSOutput) RemotePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NFS) *string { return v.RemotePath }).(pulumi.StringPtrOutput)
}

// The IP address of the NFS.
func (o NFSOutput) Server() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NFS) *string { return v.Server }).(pulumi.StringPtrOutput)
}

type NFSPtrOutput struct{ *pulumi.OutputState }

func (NFSPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NFS)(nil)).Elem()
}

func (o NFSPtrOutput) ToNFSPtrOutput() NFSPtrOutput {
	return o
}

func (o NFSPtrOutput) ToNFSPtrOutputWithContext(ctx context.Context) NFSPtrOutput {
	return o
}

func (o NFSPtrOutput) Elem() NFSOutput {
	return o.ApplyT(func(v *NFS) NFS {
		if v != nil {
			return *v
		}
		var ret NFS
		return ret
	}).(NFSOutput)
}

// Remote source path exported from the NFS, e.g., "/share".
func (o NFSPtrOutput) RemotePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NFS) *string {
		if v == nil {
			return nil
		}
		return v.RemotePath
	}).(pulumi.StringPtrOutput)
}

// The IP address of the NFS.
func (o NFSPtrOutput) Server() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NFS) *string {
		if v == nil {
			return nil
		}
		return v.Server
	}).(pulumi.StringPtrOutput)
}

// Represents an NFS volume.
type NFSResponse struct {
	// Remote source path exported from the NFS, e.g., "/share".
	RemotePath string `pulumi:"remotePath"`
	// The IP address of the NFS.
	Server string `pulumi:"server"`
}

// Represents an NFS volume.
type NFSResponseOutput struct{ *pulumi.OutputState }

func (NFSResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NFSResponse)(nil)).Elem()
}

func (o NFSResponseOutput) ToNFSResponseOutput() NFSResponseOutput {
	return o
}

func (o NFSResponseOutput) ToNFSResponseOutputWithContext(ctx context.Context) NFSResponseOutput {
	return o
}

// Remote source path exported from the NFS, e.g., "/share".
func (o NFSResponseOutput) RemotePath() pulumi.StringOutput {
	return o.ApplyT(func(v NFSResponse) string { return v.RemotePath }).(pulumi.StringOutput)
}

// The IP address of the NFS.
func (o NFSResponseOutput) Server() pulumi.StringOutput {
	return o.ApplyT(func(v NFSResponse) string { return v.Server }).(pulumi.StringOutput)
}

// A network interface.
type NetworkInterface struct {
	// The URL of an existing network resource. You can specify the network as a full or partial URL. For example, the following are all valid URLs: * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network} * projects/{project}/global/networks/{network} * global/networks/{network}
	Network *string `pulumi:"network"`
	// Default is false (with an external IP address). Required if no external public IP address is attached to the VM. If no external public IP address, additional configuration is required to allow the VM to access Google Services. See https://cloud.google.com/vpc/docs/configure-private-google-access and https://cloud.google.com/nat/docs/gce-example#create-nat for more information.
	NoExternalIpAddress *bool `pulumi:"noExternalIpAddress"`
	// The URL of an existing subnetwork resource in the network. You can specify the subnetwork as a full or partial URL. For example, the following are all valid URLs: * https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/subnetworks/{subnetwork} * projects/{project}/regions/{region}/subnetworks/{subnetwork} * regions/{region}/subnetworks/{subnetwork}
	Subnetwork *string `pulumi:"subnetwork"`
}

// NetworkInterfaceInput is an input type that accepts NetworkInterfaceArgs and NetworkInterfaceOutput values.
// You can construct a concrete instance of `NetworkInterfaceInput` via:
//
//	NetworkInterfaceArgs{...}
type NetworkInterfaceInput interface {
	pulumi.Input

	ToNetworkInterfaceOutput() NetworkInterfaceOutput
	ToNetworkInterfaceOutputWithContext(context.Context) NetworkInterfaceOutput
}

// A network interface.
type NetworkInterfaceArgs struct {
	// The URL of an existing network resource. You can specify the network as a full or partial URL. For example, the following are all valid URLs: * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network} * projects/{project}/global/networks/{network} * global/networks/{network}
	Network pulumi.StringPtrInput `pulumi:"network"`
	// Default is false (with an external IP address). Required if no external public IP address is attached to the VM. If no external public IP address, additional configuration is required to allow the VM to access Google Services. See https://cloud.google.com/vpc/docs/configure-private-google-access and https://cloud.google.com/nat/docs/gce-example#create-nat for more information.
	NoExternalIpAddress pulumi.BoolPtrInput `pulumi:"noExternalIpAddress"`
	// The URL of an existing subnetwork resource in the network. You can specify the subnetwork as a full or partial URL. For example, the following are all valid URLs: * https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/subnetworks/{subnetwork} * projects/{project}/regions/{region}/subnetworks/{subnetwork} * regions/{region}/subnetworks/{subnetwork}
	Subnetwork pulumi.StringPtrInput `pulumi:"subnetwork"`
}

func (NetworkInterfaceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkInterface)(nil)).Elem()
}

func (i NetworkInterfaceArgs) ToNetworkInterfaceOutput() NetworkInterfaceOutput {
	return i.ToNetworkInterfaceOutputWithContext(context.Background())
}

func (i NetworkInterfaceArgs) ToNetworkInterfaceOutputWithContext(ctx context.Context) NetworkInterfaceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkInterfaceOutput)
}

// NetworkInterfaceArrayInput is an input type that accepts NetworkInterfaceArray and NetworkInterfaceArrayOutput values.
// You can construct a concrete instance of `NetworkInterfaceArrayInput` via:
//
//	NetworkInterfaceArray{ NetworkInterfaceArgs{...} }
type NetworkInterfaceArrayInput interface {
	pulumi.Input

	ToNetworkInterfaceArrayOutput() NetworkInterfaceArrayOutput
	ToNetworkInterfaceArrayOutputWithContext(context.Context) NetworkInterfaceArrayOutput
}

type NetworkInterfaceArray []NetworkInterfaceInput

func (NetworkInterfaceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkInterface)(nil)).Elem()
}

func (i NetworkInterfaceArray) ToNetworkInterfaceArrayOutput() NetworkInterfaceArrayOutput {
	return i.ToNetworkInterfaceArrayOutputWithContext(context.Background())
}

func (i NetworkInterfaceArray) ToNetworkInterfaceArrayOutputWithContext(ctx context.Context) NetworkInterfaceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkInterfaceArrayOutput)
}

// A network interface.
type NetworkInterfaceOutput struct{ *pulumi.OutputState }

func (NetworkInterfaceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkInterface)(nil)).Elem()
}

func (o NetworkInterfaceOutput) ToNetworkInterfaceOutput() NetworkInterfaceOutput {
	return o
}

func (o NetworkInterfaceOutput) ToNetworkInterfaceOutputWithContext(ctx context.Context) NetworkInterfaceOutput {
	return o
}

// The URL of an existing network resource. You can specify the network as a full or partial URL. For example, the following are all valid URLs: * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network} * projects/{project}/global/networks/{network} * global/networks/{network}
func (o NetworkInterfaceOutput) Network() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkInterface) *string { return v.Network }).(pulumi.StringPtrOutput)
}

// Default is false (with an external IP address). Required if no external public IP address is attached to the VM. If no external public IP address, additional configuration is required to allow the VM to access Google Services. See https://cloud.google.com/vpc/docs/configure-private-google-access and https://cloud.google.com/nat/docs/gce-example#create-nat for more information.
func (o NetworkInterfaceOutput) NoExternalIpAddress() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v NetworkInterface) *bool { return v.NoExternalIpAddress }).(pulumi.BoolPtrOutput)
}

// The URL of an existing subnetwork resource in the network. You can specify the subnetwork as a full or partial URL. For example, the following are all valid URLs: * https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/subnetworks/{subnetwork} * projects/{project}/regions/{region}/subnetworks/{subnetwork} * regions/{region}/subnetworks/{subnetwork}
func (o NetworkInterfaceOutput) Subnetwork() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkInterface) *string { return v.Subnetwork }).(pulumi.StringPtrOutput)
}

type NetworkInterfaceArrayOutput struct{ *pulumi.OutputState }

func (NetworkInterfaceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkInterface)(nil)).Elem()
}

func (o NetworkInterfaceArrayOutput) ToNetworkInterfaceArrayOutput() NetworkInterfaceArrayOutput {
	return o
}

func (o NetworkInterfaceArrayOutput) ToNetworkInterfaceArrayOutputWithContext(ctx context.Context) NetworkInterfaceArrayOutput {
	return o
}

func (o NetworkInterfaceArrayOutput) Index(i pulumi.IntInput) NetworkInterfaceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NetworkInterface {
		return vs[0].([]NetworkInterface)[vs[1].(int)]
	}).(NetworkInterfaceOutput)
}

// A network interface.
type NetworkInterfaceResponse struct {
	// The URL of an existing network resource. You can specify the network as a full or partial URL. For example, the following are all valid URLs: * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network} * projects/{project}/global/networks/{network} * global/networks/{network}
	Network string `pulumi:"network"`
	// Default is false (with an external IP address). Required if no external public IP address is attached to the VM. If no external public IP address, additional configuration is required to allow the VM to access Google Services. See https://cloud.google.com/vpc/docs/configure-private-google-access and https://cloud.google.com/nat/docs/gce-example#create-nat for more information.
	NoExternalIpAddress bool `pulumi:"noExternalIpAddress"`
	// The URL of an existing subnetwork resource in the network. You can specify the subnetwork as a full or partial URL. For example, the following are all valid URLs: * https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/subnetworks/{subnetwork} * projects/{project}/regions/{region}/subnetworks/{subnetwork} * regions/{region}/subnetworks/{subnetwork}
	Subnetwork string `pulumi:"subnetwork"`
}

// A network interface.
type NetworkInterfaceResponseOutput struct{ *pulumi.OutputState }

func (NetworkInterfaceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkInterfaceResponse)(nil)).Elem()
}

func (o NetworkInterfaceResponseOutput) ToNetworkInterfaceResponseOutput() NetworkInterfaceResponseOutput {
	return o
}

func (o NetworkInterfaceResponseOutput) ToNetworkInterfaceResponseOutputWithContext(ctx context.Context) NetworkInterfaceResponseOutput {
	return o
}

// The URL of an existing network resource. You can specify the network as a full or partial URL. For example, the following are all valid URLs: * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network} * projects/{project}/global/networks/{network} * global/networks/{network}
func (o NetworkInterfaceResponseOutput) Network() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkInterfaceResponse) string { return v.Network }).(pulumi.StringOutput)
}

// Default is false (with an external IP address). Required if no external public IP address is attached to the VM. If no external public IP address, additional configuration is required to allow the VM to access Google Services. See https://cloud.google.com/vpc/docs/configure-private-google-access and https://cloud.google.com/nat/docs/gce-example#create-nat for more information.
func (o NetworkInterfaceResponseOutput) NoExternalIpAddress() pulumi.BoolOutput {
	return o.ApplyT(func(v NetworkInterfaceResponse) bool { return v.NoExternalIpAddress }).(pulumi.BoolOutput)
}

// The URL of an existing subnetwork resource in the network. You can specify the subnetwork as a full or partial URL. For example, the following are all valid URLs: * https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/subnetworks/{subnetwork} * projects/{project}/regions/{region}/subnetworks/{subnetwork} * regions/{region}/subnetworks/{subnetwork}
func (o NetworkInterfaceResponseOutput) Subnetwork() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkInterfaceResponse) string { return v.Subnetwork }).(pulumi.StringOutput)
}

type NetworkInterfaceResponseArrayOutput struct{ *pulumi.OutputState }

func (NetworkInterfaceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkInterfaceResponse)(nil)).Elem()
}

func (o NetworkInterfaceResponseArrayOutput) ToNetworkInterfaceResponseArrayOutput() NetworkInterfaceResponseArrayOutput {
	return o
}

func (o NetworkInterfaceResponseArrayOutput) ToNetworkInterfaceResponseArrayOutputWithContext(ctx context.Context) NetworkInterfaceResponseArrayOutput {
	return o
}

func (o NetworkInterfaceResponseArrayOutput) Index(i pulumi.IntInput) NetworkInterfaceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NetworkInterfaceResponse {
		return vs[0].([]NetworkInterfaceResponse)[vs[1].(int)]
	}).(NetworkInterfaceResponseOutput)
}

// NetworkPolicy describes VM instance network configurations.
type NetworkPolicy struct {
	// Network configurations.
	NetworkInterfaces []NetworkInterface `pulumi:"networkInterfaces"`
}

// NetworkPolicyInput is an input type that accepts NetworkPolicyArgs and NetworkPolicyOutput values.
// You can construct a concrete instance of `NetworkPolicyInput` via:
//
//	NetworkPolicyArgs{...}
type NetworkPolicyInput interface {
	pulumi.Input

	ToNetworkPolicyOutput() NetworkPolicyOutput
	ToNetworkPolicyOutputWithContext(context.Context) NetworkPolicyOutput
}

// NetworkPolicy describes VM instance network configurations.
type NetworkPolicyArgs struct {
	// Network configurations.
	NetworkInterfaces NetworkInterfaceArrayInput `pulumi:"networkInterfaces"`
}

func (NetworkPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkPolicy)(nil)).Elem()
}

func (i NetworkPolicyArgs) ToNetworkPolicyOutput() NetworkPolicyOutput {
	return i.ToNetworkPolicyOutputWithContext(context.Background())
}

func (i NetworkPolicyArgs) ToNetworkPolicyOutputWithContext(ctx context.Context) NetworkPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkPolicyOutput)
}

func (i NetworkPolicyArgs) ToNetworkPolicyPtrOutput() NetworkPolicyPtrOutput {
	return i.ToNetworkPolicyPtrOutputWithContext(context.Background())
}

func (i NetworkPolicyArgs) ToNetworkPolicyPtrOutputWithContext(ctx context.Context) NetworkPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkPolicyOutput).ToNetworkPolicyPtrOutputWithContext(ctx)
}

// NetworkPolicyPtrInput is an input type that accepts NetworkPolicyArgs, NetworkPolicyPtr and NetworkPolicyPtrOutput values.
// You can construct a concrete instance of `NetworkPolicyPtrInput` via:
//
//	        NetworkPolicyArgs{...}
//
//	or:
//
//	        nil
type NetworkPolicyPtrInput interface {
	pulumi.Input

	ToNetworkPolicyPtrOutput() NetworkPolicyPtrOutput
	ToNetworkPolicyPtrOutputWithContext(context.Context) NetworkPolicyPtrOutput
}

type networkPolicyPtrType NetworkPolicyArgs

func NetworkPolicyPtr(v *NetworkPolicyArgs) NetworkPolicyPtrInput {
	return (*networkPolicyPtrType)(v)
}

func (*networkPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkPolicy)(nil)).Elem()
}

func (i *networkPolicyPtrType) ToNetworkPolicyPtrOutput() NetworkPolicyPtrOutput {
	return i.ToNetworkPolicyPtrOutputWithContext(context.Background())
}

func (i *networkPolicyPtrType) ToNetworkPolicyPtrOutputWithContext(ctx context.Context) NetworkPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkPolicyPtrOutput)
}

// NetworkPolicy describes VM instance network configurations.
type NetworkPolicyOutput struct{ *pulumi.OutputState }

func (NetworkPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkPolicy)(nil)).Elem()
}

func (o NetworkPolicyOutput) ToNetworkPolicyOutput() NetworkPolicyOutput {
	return o
}

func (o NetworkPolicyOutput) ToNetworkPolicyOutputWithContext(ctx context.Context) NetworkPolicyOutput {
	return o
}

func (o NetworkPolicyOutput) ToNetworkPolicyPtrOutput() NetworkPolicyPtrOutput {
	return o.ToNetworkPolicyPtrOutputWithContext(context.Background())
}

func (o NetworkPolicyOutput) ToNetworkPolicyPtrOutputWithContext(ctx context.Context) NetworkPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NetworkPolicy) *NetworkPolicy {
		return &v
	}).(NetworkPolicyPtrOutput)
}

// Network configurations.
func (o NetworkPolicyOutput) NetworkInterfaces() NetworkInterfaceArrayOutput {
	return o.ApplyT(func(v NetworkPolicy) []NetworkInterface { return v.NetworkInterfaces }).(NetworkInterfaceArrayOutput)
}

type NetworkPolicyPtrOutput struct{ *pulumi.OutputState }

func (NetworkPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkPolicy)(nil)).Elem()
}

func (o NetworkPolicyPtrOutput) ToNetworkPolicyPtrOutput() NetworkPolicyPtrOutput {
	return o
}

func (o NetworkPolicyPtrOutput) ToNetworkPolicyPtrOutputWithContext(ctx context.Context) NetworkPolicyPtrOutput {
	return o
}

func (o NetworkPolicyPtrOutput) Elem() NetworkPolicyOutput {
	return o.ApplyT(func(v *NetworkPolicy) NetworkPolicy {
		if v != nil {
			return *v
		}
		var ret NetworkPolicy
		return ret
	}).(NetworkPolicyOutput)
}

// Network configurations.
func (o NetworkPolicyPtrOutput) NetworkInterfaces() NetworkInterfaceArrayOutput {
	return o.ApplyT(func(v *NetworkPolicy) []NetworkInterface {
		if v == nil {
			return nil
		}
		return v.NetworkInterfaces
	}).(NetworkInterfaceArrayOutput)
}

// NetworkPolicy describes VM instance network configurations.
type NetworkPolicyResponse struct {
	// Network configurations.
	NetworkInterfaces []NetworkInterfaceResponse `pulumi:"networkInterfaces"`
}

// NetworkPolicy describes VM instance network configurations.
type NetworkPolicyResponseOutput struct{ *pulumi.OutputState }

func (NetworkPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkPolicyResponse)(nil)).Elem()
}

func (o NetworkPolicyResponseOutput) ToNetworkPolicyResponseOutput() NetworkPolicyResponseOutput {
	return o
}

func (o NetworkPolicyResponseOutput) ToNetworkPolicyResponseOutputWithContext(ctx context.Context) NetworkPolicyResponseOutput {
	return o
}

// Network configurations.
func (o NetworkPolicyResponseOutput) NetworkInterfaces() NetworkInterfaceResponseArrayOutput {
	return o.ApplyT(func(v NetworkPolicyResponse) []NetworkInterfaceResponse { return v.NetworkInterfaces }).(NetworkInterfaceResponseArrayOutput)
}

// PlacementPolicy describes a group placement policy for the VMs controlled by this AllocationPolicy.
type PlacementPolicy struct {
	// UNSPECIFIED vs. COLLOCATED (default UNSPECIFIED). Use COLLOCATED when you want VMs to be located close to each other for low network latency between the VMs. No placement policy will be generated when collocation is UNSPECIFIED.
	Collocation *string `pulumi:"collocation"`
	// When specified, causes the job to fail if more than max_distance logical switches are required between VMs. Batch uses the most compact possible placement of VMs even when max_distance is not specified. An explicit max_distance makes that level of compactness a strict requirement. Not yet implemented
	MaxDistance *string `pulumi:"maxDistance"`
}

// PlacementPolicyInput is an input type that accepts PlacementPolicyArgs and PlacementPolicyOutput values.
// You can construct a concrete instance of `PlacementPolicyInput` via:
//
//	PlacementPolicyArgs{...}
type PlacementPolicyInput interface {
	pulumi.Input

	ToPlacementPolicyOutput() PlacementPolicyOutput
	ToPlacementPolicyOutputWithContext(context.Context) PlacementPolicyOutput
}

// PlacementPolicy describes a group placement policy for the VMs controlled by this AllocationPolicy.
type PlacementPolicyArgs struct {
	// UNSPECIFIED vs. COLLOCATED (default UNSPECIFIED). Use COLLOCATED when you want VMs to be located close to each other for low network latency between the VMs. No placement policy will be generated when collocation is UNSPECIFIED.
	Collocation pulumi.StringPtrInput `pulumi:"collocation"`
	// When specified, causes the job to fail if more than max_distance logical switches are required between VMs. Batch uses the most compact possible placement of VMs even when max_distance is not specified. An explicit max_distance makes that level of compactness a strict requirement. Not yet implemented
	MaxDistance pulumi.StringPtrInput `pulumi:"maxDistance"`
}

func (PlacementPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementPolicy)(nil)).Elem()
}

func (i PlacementPolicyArgs) ToPlacementPolicyOutput() PlacementPolicyOutput {
	return i.ToPlacementPolicyOutputWithContext(context.Background())
}

func (i PlacementPolicyArgs) ToPlacementPolicyOutputWithContext(ctx context.Context) PlacementPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementPolicyOutput)
}

func (i PlacementPolicyArgs) ToPlacementPolicyPtrOutput() PlacementPolicyPtrOutput {
	return i.ToPlacementPolicyPtrOutputWithContext(context.Background())
}

func (i PlacementPolicyArgs) ToPlacementPolicyPtrOutputWithContext(ctx context.Context) PlacementPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementPolicyOutput).ToPlacementPolicyPtrOutputWithContext(ctx)
}

// PlacementPolicyPtrInput is an input type that accepts PlacementPolicyArgs, PlacementPolicyPtr and PlacementPolicyPtrOutput values.
// You can construct a concrete instance of `PlacementPolicyPtrInput` via:
//
//	        PlacementPolicyArgs{...}
//
//	or:
//
//	        nil
type PlacementPolicyPtrInput interface {
	pulumi.Input

	ToPlacementPolicyPtrOutput() PlacementPolicyPtrOutput
	ToPlacementPolicyPtrOutputWithContext(context.Context) PlacementPolicyPtrOutput
}

type placementPolicyPtrType PlacementPolicyArgs

func PlacementPolicyPtr(v *PlacementPolicyArgs) PlacementPolicyPtrInput {
	return (*placementPolicyPtrType)(v)
}

func (*placementPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PlacementPolicy)(nil)).Elem()
}

func (i *placementPolicyPtrType) ToPlacementPolicyPtrOutput() PlacementPolicyPtrOutput {
	return i.ToPlacementPolicyPtrOutputWithContext(context.Background())
}

func (i *placementPolicyPtrType) ToPlacementPolicyPtrOutputWithContext(ctx context.Context) PlacementPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementPolicyPtrOutput)
}

// PlacementPolicy describes a group placement policy for the VMs controlled by this AllocationPolicy.
type PlacementPolicyOutput struct{ *pulumi.OutputState }

func (PlacementPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementPolicy)(nil)).Elem()
}

func (o PlacementPolicyOutput) ToPlacementPolicyOutput() PlacementPolicyOutput {
	return o
}

func (o PlacementPolicyOutput) ToPlacementPolicyOutputWithContext(ctx context.Context) PlacementPolicyOutput {
	return o
}

func (o PlacementPolicyOutput) ToPlacementPolicyPtrOutput() PlacementPolicyPtrOutput {
	return o.ToPlacementPolicyPtrOutputWithContext(context.Background())
}

func (o PlacementPolicyOutput) ToPlacementPolicyPtrOutputWithContext(ctx context.Context) PlacementPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PlacementPolicy) *PlacementPolicy {
		return &v
	}).(PlacementPolicyPtrOutput)
}

// UNSPECIFIED vs. COLLOCATED (default UNSPECIFIED). Use COLLOCATED when you want VMs to be located close to each other for low network latency between the VMs. No placement policy will be generated when collocation is UNSPECIFIED.
func (o PlacementPolicyOutput) Collocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementPolicy) *string { return v.Collocation }).(pulumi.StringPtrOutput)
}

// When specified, causes the job to fail if more than max_distance logical switches are required between VMs. Batch uses the most compact possible placement of VMs even when max_distance is not specified. An explicit max_distance makes that level of compactness a strict requirement. Not yet implemented
func (o PlacementPolicyOutput) MaxDistance() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementPolicy) *string { return v.MaxDistance }).(pulumi.StringPtrOutput)
}

type PlacementPolicyPtrOutput struct{ *pulumi.OutputState }

func (PlacementPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PlacementPolicy)(nil)).Elem()
}

func (o PlacementPolicyPtrOutput) ToPlacementPolicyPtrOutput() PlacementPolicyPtrOutput {
	return o
}

func (o PlacementPolicyPtrOutput) ToPlacementPolicyPtrOutputWithContext(ctx context.Context) PlacementPolicyPtrOutput {
	return o
}

func (o PlacementPolicyPtrOutput) Elem() PlacementPolicyOutput {
	return o.ApplyT(func(v *PlacementPolicy) PlacementPolicy {
		if v != nil {
			return *v
		}
		var ret PlacementPolicy
		return ret
	}).(PlacementPolicyOutput)
}

// UNSPECIFIED vs. COLLOCATED (default UNSPECIFIED). Use COLLOCATED when you want VMs to be located close to each other for low network latency between the VMs. No placement policy will be generated when collocation is UNSPECIFIED.
func (o PlacementPolicyPtrOutput) Collocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PlacementPolicy) *string {
		if v == nil {
			return nil
		}
		return v.Collocation
	}).(pulumi.StringPtrOutput)
}

// When specified, causes the job to fail if more than max_distance logical switches are required between VMs. Batch uses the most compact possible placement of VMs even when max_distance is not specified. An explicit max_distance makes that level of compactness a strict requirement. Not yet implemented
func (o PlacementPolicyPtrOutput) MaxDistance() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PlacementPolicy) *string {
		if v == nil {
			return nil
		}
		return v.MaxDistance
	}).(pulumi.StringPtrOutput)
}

// PlacementPolicy describes a group placement policy for the VMs controlled by this AllocationPolicy.
type PlacementPolicyResponse struct {
	// UNSPECIFIED vs. COLLOCATED (default UNSPECIFIED). Use COLLOCATED when you want VMs to be located close to each other for low network latency between the VMs. No placement policy will be generated when collocation is UNSPECIFIED.
	Collocation string `pulumi:"collocation"`
	// When specified, causes the job to fail if more than max_distance logical switches are required between VMs. Batch uses the most compact possible placement of VMs even when max_distance is not specified. An explicit max_distance makes that level of compactness a strict requirement. Not yet implemented
	MaxDistance string `pulumi:"maxDistance"`
}

// PlacementPolicy describes a group placement policy for the VMs controlled by this AllocationPolicy.
type PlacementPolicyResponseOutput struct{ *pulumi.OutputState }

func (PlacementPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementPolicyResponse)(nil)).Elem()
}

func (o PlacementPolicyResponseOutput) ToPlacementPolicyResponseOutput() PlacementPolicyResponseOutput {
	return o
}

func (o PlacementPolicyResponseOutput) ToPlacementPolicyResponseOutputWithContext(ctx context.Context) PlacementPolicyResponseOutput {
	return o
}

// UNSPECIFIED vs. COLLOCATED (default UNSPECIFIED). Use COLLOCATED when you want VMs to be located close to each other for low network latency between the VMs. No placement policy will be generated when collocation is UNSPECIFIED.
func (o PlacementPolicyResponseOutput) Collocation() pulumi.StringOutput {
	return o.ApplyT(func(v PlacementPolicyResponse) string { return v.Collocation }).(pulumi.StringOutput)
}

// When specified, causes the job to fail if more than max_distance logical switches are required between VMs. Batch uses the most compact possible placement of VMs even when max_distance is not specified. An explicit max_distance makes that level of compactness a strict requirement. Not yet implemented
func (o PlacementPolicyResponseOutput) MaxDistance() pulumi.StringOutput {
	return o.ApplyT(func(v PlacementPolicyResponse) string { return v.MaxDistance }).(pulumi.StringOutput)
}

// Runnable describes instructions for executing a specific script or container as part of a Task.
type Runnable struct {
	// By default, after a Runnable fails, no further Runnable are executed. This flag indicates that this Runnable must be run even if the Task has already failed. This is useful for Runnables that copy output files off of the VM or for debugging. The always_run flag does not override the Task's overall max_run_duration. If the max_run_duration has expired then no further Runnables will execute, not even always_run Runnables.
	AlwaysRun *bool `pulumi:"alwaysRun"`
	// This flag allows a Runnable to continue running in the background while the Task executes subsequent Runnables. This is useful to provide services to other Runnables (or to provide debugging support tools like SSH servers).
	Background *bool `pulumi:"background"`
	// Barrier runnable.
	Barrier *Barrier `pulumi:"barrier"`
	// Container runnable.
	Container *Container `pulumi:"container"`
	// Optional. DisplayName is an optional field that can be provided by the caller. If provided, it will be used in logs and other outputs to identify the script, making it easier for users to understand the logs. If not provided the index of the runnable will be used for outputs.
	DisplayName *string `pulumi:"displayName"`
	// Environment variables for this Runnable (overrides variables set for the whole Task or TaskGroup).
	Environment *Environment `pulumi:"environment"`
	// Normally, a non-zero exit status causes the Task to fail. This flag allows execution of other Runnables to continue instead.
	IgnoreExitStatus *bool `pulumi:"ignoreExitStatus"`
	// Labels for this Runnable.
	Labels map[string]string `pulumi:"labels"`
	// Script runnable.
	Script *Script `pulumi:"script"`
	// Timeout for this Runnable.
	Timeout *string `pulumi:"timeout"`
}

// RunnableInput is an input type that accepts RunnableArgs and RunnableOutput values.
// You can construct a concrete instance of `RunnableInput` via:
//
//	RunnableArgs{...}
type RunnableInput interface {
	pulumi.Input

	ToRunnableOutput() RunnableOutput
	ToRunnableOutputWithContext(context.Context) RunnableOutput
}

// Runnable describes instructions for executing a specific script or container as part of a Task.
type RunnableArgs struct {
	// By default, after a Runnable fails, no further Runnable are executed. This flag indicates that this Runnable must be run even if the Task has already failed. This is useful for Runnables that copy output files off of the VM or for debugging. The always_run flag does not override the Task's overall max_run_duration. If the max_run_duration has expired then no further Runnables will execute, not even always_run Runnables.
	AlwaysRun pulumi.BoolPtrInput `pulumi:"alwaysRun"`
	// This flag allows a Runnable to continue running in the background while the Task executes subsequent Runnables. This is useful to provide services to other Runnables (or to provide debugging support tools like SSH servers).
	Background pulumi.BoolPtrInput `pulumi:"background"`
	// Barrier runnable.
	Barrier BarrierPtrInput `pulumi:"barrier"`
	// Container runnable.
	Container ContainerPtrInput `pulumi:"container"`
	// Optional. DisplayName is an optional field that can be provided by the caller. If provided, it will be used in logs and other outputs to identify the script, making it easier for users to understand the logs. If not provided the index of the runnable will be used for outputs.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// Environment variables for this Runnable (overrides variables set for the whole Task or TaskGroup).
	Environment EnvironmentPtrInput `pulumi:"environment"`
	// Normally, a non-zero exit status causes the Task to fail. This flag allows execution of other Runnables to continue instead.
	IgnoreExitStatus pulumi.BoolPtrInput `pulumi:"ignoreExitStatus"`
	// Labels for this Runnable.
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// Script runnable.
	Script ScriptPtrInput `pulumi:"script"`
	// Timeout for this Runnable.
	Timeout pulumi.StringPtrInput `pulumi:"timeout"`
}

func (RunnableArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Runnable)(nil)).Elem()
}

func (i RunnableArgs) ToRunnableOutput() RunnableOutput {
	return i.ToRunnableOutputWithContext(context.Background())
}

func (i RunnableArgs) ToRunnableOutputWithContext(ctx context.Context) RunnableOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RunnableOutput)
}

// RunnableArrayInput is an input type that accepts RunnableArray and RunnableArrayOutput values.
// You can construct a concrete instance of `RunnableArrayInput` via:
//
//	RunnableArray{ RunnableArgs{...} }
type RunnableArrayInput interface {
	pulumi.Input

	ToRunnableArrayOutput() RunnableArrayOutput
	ToRunnableArrayOutputWithContext(context.Context) RunnableArrayOutput
}

type RunnableArray []RunnableInput

func (RunnableArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Runnable)(nil)).Elem()
}

func (i RunnableArray) ToRunnableArrayOutput() RunnableArrayOutput {
	return i.ToRunnableArrayOutputWithContext(context.Background())
}

func (i RunnableArray) ToRunnableArrayOutputWithContext(ctx context.Context) RunnableArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RunnableArrayOutput)
}

// Runnable describes instructions for executing a specific script or container as part of a Task.
type RunnableOutput struct{ *pulumi.OutputState }

func (RunnableOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Runnable)(nil)).Elem()
}

func (o RunnableOutput) ToRunnableOutput() RunnableOutput {
	return o
}

func (o RunnableOutput) ToRunnableOutputWithContext(ctx context.Context) RunnableOutput {
	return o
}

// By default, after a Runnable fails, no further Runnable are executed. This flag indicates that this Runnable must be run even if the Task has already failed. This is useful for Runnables that copy output files off of the VM or for debugging. The always_run flag does not override the Task's overall max_run_duration. If the max_run_duration has expired then no further Runnables will execute, not even always_run Runnables.
func (o RunnableOutput) AlwaysRun() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Runnable) *bool { return v.AlwaysRun }).(pulumi.BoolPtrOutput)
}

// This flag allows a Runnable to continue running in the background while the Task executes subsequent Runnables. This is useful to provide services to other Runnables (or to provide debugging support tools like SSH servers).
func (o RunnableOutput) Background() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Runnable) *bool { return v.Background }).(pulumi.BoolPtrOutput)
}

// Barrier runnable.
func (o RunnableOutput) Barrier() BarrierPtrOutput {
	return o.ApplyT(func(v Runnable) *Barrier { return v.Barrier }).(BarrierPtrOutput)
}

// Container runnable.
func (o RunnableOutput) Container() ContainerPtrOutput {
	return o.ApplyT(func(v Runnable) *Container { return v.Container }).(ContainerPtrOutput)
}

// Optional. DisplayName is an optional field that can be provided by the caller. If provided, it will be used in logs and other outputs to identify the script, making it easier for users to understand the logs. If not provided the index of the runnable will be used for outputs.
func (o RunnableOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Runnable) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Environment variables for this Runnable (overrides variables set for the whole Task or TaskGroup).
func (o RunnableOutput) Environment() EnvironmentPtrOutput {
	return o.ApplyT(func(v Runnable) *Environment { return v.Environment }).(EnvironmentPtrOutput)
}

// Normally, a non-zero exit status causes the Task to fail. This flag allows execution of other Runnables to continue instead.
func (o RunnableOutput) IgnoreExitStatus() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Runnable) *bool { return v.IgnoreExitStatus }).(pulumi.BoolPtrOutput)
}

// Labels for this Runnable.
func (o RunnableOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v Runnable) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// Script runnable.
func (o RunnableOutput) Script() ScriptPtrOutput {
	return o.ApplyT(func(v Runnable) *Script { return v.Script }).(ScriptPtrOutput)
}

// Timeout for this Runnable.
func (o RunnableOutput) Timeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Runnable) *string { return v.Timeout }).(pulumi.StringPtrOutput)
}

type RunnableArrayOutput struct{ *pulumi.OutputState }

func (RunnableArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Runnable)(nil)).Elem()
}

func (o RunnableArrayOutput) ToRunnableArrayOutput() RunnableArrayOutput {
	return o
}

func (o RunnableArrayOutput) ToRunnableArrayOutputWithContext(ctx context.Context) RunnableArrayOutput {
	return o
}

func (o RunnableArrayOutput) Index(i pulumi.IntInput) RunnableOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Runnable {
		return vs[0].([]Runnable)[vs[1].(int)]
	}).(RunnableOutput)
}

// Runnable describes instructions for executing a specific script or container as part of a Task.
type RunnableResponse struct {
	// By default, after a Runnable fails, no further Runnable are executed. This flag indicates that this Runnable must be run even if the Task has already failed. This is useful for Runnables that copy output files off of the VM or for debugging. The always_run flag does not override the Task's overall max_run_duration. If the max_run_duration has expired then no further Runnables will execute, not even always_run Runnables.
	AlwaysRun bool `pulumi:"alwaysRun"`
	// This flag allows a Runnable to continue running in the background while the Task executes subsequent Runnables. This is useful to provide services to other Runnables (or to provide debugging support tools like SSH servers).
	Background bool `pulumi:"background"`
	// Barrier runnable.
	Barrier BarrierResponse `pulumi:"barrier"`
	// Container runnable.
	Container ContainerResponse `pulumi:"container"`
	// Optional. DisplayName is an optional field that can be provided by the caller. If provided, it will be used in logs and other outputs to identify the script, making it easier for users to understand the logs. If not provided the index of the runnable will be used for outputs.
	DisplayName string `pulumi:"displayName"`
	// Environment variables for this Runnable (overrides variables set for the whole Task or TaskGroup).
	Environment EnvironmentResponse `pulumi:"environment"`
	// Normally, a non-zero exit status causes the Task to fail. This flag allows execution of other Runnables to continue instead.
	IgnoreExitStatus bool `pulumi:"ignoreExitStatus"`
	// Labels for this Runnable.
	Labels map[string]string `pulumi:"labels"`
	// Script runnable.
	Script ScriptResponse `pulumi:"script"`
	// Timeout for this Runnable.
	Timeout string `pulumi:"timeout"`
}

// Runnable describes instructions for executing a specific script or container as part of a Task.
type RunnableResponseOutput struct{ *pulumi.OutputState }

func (RunnableResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RunnableResponse)(nil)).Elem()
}

func (o RunnableResponseOutput) ToRunnableResponseOutput() RunnableResponseOutput {
	return o
}

func (o RunnableResponseOutput) ToRunnableResponseOutputWithContext(ctx context.Context) RunnableResponseOutput {
	return o
}

// By default, after a Runnable fails, no further Runnable are executed. This flag indicates that this Runnable must be run even if the Task has already failed. This is useful for Runnables that copy output files off of the VM or for debugging. The always_run flag does not override the Task's overall max_run_duration. If the max_run_duration has expired then no further Runnables will execute, not even always_run Runnables.
func (o RunnableResponseOutput) AlwaysRun() pulumi.BoolOutput {
	return o.ApplyT(func(v RunnableResponse) bool { return v.AlwaysRun }).(pulumi.BoolOutput)
}

// This flag allows a Runnable to continue running in the background while the Task executes subsequent Runnables. This is useful to provide services to other Runnables (or to provide debugging support tools like SSH servers).
func (o RunnableResponseOutput) Background() pulumi.BoolOutput {
	return o.ApplyT(func(v RunnableResponse) bool { return v.Background }).(pulumi.BoolOutput)
}

// Barrier runnable.
func (o RunnableResponseOutput) Barrier() BarrierResponseOutput {
	return o.ApplyT(func(v RunnableResponse) BarrierResponse { return v.Barrier }).(BarrierResponseOutput)
}

// Container runnable.
func (o RunnableResponseOutput) Container() ContainerResponseOutput {
	return o.ApplyT(func(v RunnableResponse) ContainerResponse { return v.Container }).(ContainerResponseOutput)
}

// Optional. DisplayName is an optional field that can be provided by the caller. If provided, it will be used in logs and other outputs to identify the script, making it easier for users to understand the logs. If not provided the index of the runnable will be used for outputs.
func (o RunnableResponseOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v RunnableResponse) string { return v.DisplayName }).(pulumi.StringOutput)
}

// Environment variables for this Runnable (overrides variables set for the whole Task or TaskGroup).
func (o RunnableResponseOutput) Environment() EnvironmentResponseOutput {
	return o.ApplyT(func(v RunnableResponse) EnvironmentResponse { return v.Environment }).(EnvironmentResponseOutput)
}

// Normally, a non-zero exit status causes the Task to fail. This flag allows execution of other Runnables to continue instead.
func (o RunnableResponseOutput) IgnoreExitStatus() pulumi.BoolOutput {
	return o.ApplyT(func(v RunnableResponse) bool { return v.IgnoreExitStatus }).(pulumi.BoolOutput)
}

// Labels for this Runnable.
func (o RunnableResponseOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v RunnableResponse) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// Script runnable.
func (o RunnableResponseOutput) Script() ScriptResponseOutput {
	return o.ApplyT(func(v RunnableResponse) ScriptResponse { return v.Script }).(ScriptResponseOutput)
}

// Timeout for this Runnable.
func (o RunnableResponseOutput) Timeout() pulumi.StringOutput {
	return o.ApplyT(func(v RunnableResponse) string { return v.Timeout }).(pulumi.StringOutput)
}

type RunnableResponseArrayOutput struct{ *pulumi.OutputState }

func (RunnableResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RunnableResponse)(nil)).Elem()
}

func (o RunnableResponseArrayOutput) ToRunnableResponseArrayOutput() RunnableResponseArrayOutput {
	return o
}

func (o RunnableResponseArrayOutput) ToRunnableResponseArrayOutputWithContext(ctx context.Context) RunnableResponseArrayOutput {
	return o
}

func (o RunnableResponseArrayOutput) Index(i pulumi.IntInput) RunnableResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RunnableResponse {
		return vs[0].([]RunnableResponse)[vs[1].(int)]
	}).(RunnableResponseOutput)
}

// Script runnable.
type Script struct {
	// Script file path on the host VM. To specify an interpreter, please add a `#!`(also known as [shebang line](<https://en.wikipedia.org/wiki/Shebang_(Unix)>)) as the first line of the file.(For example, to execute the script using bash, `#!/bin/bash` should be the first line of the file. To execute the script using`Python3`, `#!/usr/bin/env python3` should be the first line of the file.) Otherwise, the file will by default be excuted by `/bin/sh`.
	Path *string `pulumi:"path"`
	// Shell script text. To specify an interpreter, please add a `#!\n` at the beginning of the text.(For example, to execute the script using bash, `#!/bin/bash\n` should be added. To execute the script using`Python3`, `#!/usr/bin/env python3\n` should be added.) Otherwise, the script will by default be excuted by `/bin/sh`.
	Text *string `pulumi:"text"`
}

// ScriptInput is an input type that accepts ScriptArgs and ScriptOutput values.
// You can construct a concrete instance of `ScriptInput` via:
//
//	ScriptArgs{...}
type ScriptInput interface {
	pulumi.Input

	ToScriptOutput() ScriptOutput
	ToScriptOutputWithContext(context.Context) ScriptOutput
}

// Script runnable.
type ScriptArgs struct {
	// Script file path on the host VM. To specify an interpreter, please add a `#!`(also known as [shebang line](<https://en.wikipedia.org/wiki/Shebang_(Unix)>)) as the first line of the file.(For example, to execute the script using bash, `#!/bin/bash` should be the first line of the file. To execute the script using`Python3`, `#!/usr/bin/env python3` should be the first line of the file.) Otherwise, the file will by default be excuted by `/bin/sh`.
	Path pulumi.StringPtrInput `pulumi:"path"`
	// Shell script text. To specify an interpreter, please add a `#!\n` at the beginning of the text.(For example, to execute the script using bash, `#!/bin/bash\n` should be added. To execute the script using`Python3`, `#!/usr/bin/env python3\n` should be added.) Otherwise, the script will by default be excuted by `/bin/sh`.
	Text pulumi.StringPtrInput `pulumi:"text"`
}

func (ScriptArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Script)(nil)).Elem()
}

func (i ScriptArgs) ToScriptOutput() ScriptOutput {
	return i.ToScriptOutputWithContext(context.Background())
}

func (i ScriptArgs) ToScriptOutputWithContext(ctx context.Context) ScriptOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScriptOutput)
}

func (i ScriptArgs) ToScriptPtrOutput() ScriptPtrOutput {
	return i.ToScriptPtrOutputWithContext(context.Background())
}

func (i ScriptArgs) ToScriptPtrOutputWithContext(ctx context.Context) ScriptPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScriptOutput).ToScriptPtrOutputWithContext(ctx)
}

// ScriptPtrInput is an input type that accepts ScriptArgs, ScriptPtr and ScriptPtrOutput values.
// You can construct a concrete instance of `ScriptPtrInput` via:
//
//	        ScriptArgs{...}
//
//	or:
//
//	        nil
type ScriptPtrInput interface {
	pulumi.Input

	ToScriptPtrOutput() ScriptPtrOutput
	ToScriptPtrOutputWithContext(context.Context) ScriptPtrOutput
}

type scriptPtrType ScriptArgs

func ScriptPtr(v *ScriptArgs) ScriptPtrInput {
	return (*scriptPtrType)(v)
}

func (*scriptPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Script)(nil)).Elem()
}

func (i *scriptPtrType) ToScriptPtrOutput() ScriptPtrOutput {
	return i.ToScriptPtrOutputWithContext(context.Background())
}

func (i *scriptPtrType) ToScriptPtrOutputWithContext(ctx context.Context) ScriptPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScriptPtrOutput)
}

// Script runnable.
type ScriptOutput struct{ *pulumi.OutputState }

func (ScriptOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Script)(nil)).Elem()
}

func (o ScriptOutput) ToScriptOutput() ScriptOutput {
	return o
}

func (o ScriptOutput) ToScriptOutputWithContext(ctx context.Context) ScriptOutput {
	return o
}

func (o ScriptOutput) ToScriptPtrOutput() ScriptPtrOutput {
	return o.ToScriptPtrOutputWithContext(context.Background())
}

func (o ScriptOutput) ToScriptPtrOutputWithContext(ctx context.Context) ScriptPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Script) *Script {
		return &v
	}).(ScriptPtrOutput)
}

// Script file path on the host VM. To specify an interpreter, please add a `#!`(also known as [shebang line](<https://en.wikipedia.org/wiki/Shebang_(Unix)>)) as the first line of the file.(For example, to execute the script using bash, `#!/bin/bash` should be the first line of the file. To execute the script using`Python3`, `#!/usr/bin/env python3` should be the first line of the file.) Otherwise, the file will by default be excuted by `/bin/sh`.
func (o ScriptOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Script) *string { return v.Path }).(pulumi.StringPtrOutput)
}

// Shell script text. To specify an interpreter, please add a `#!\n` at the beginning of the text.(For example, to execute the script using bash, `#!/bin/bash\n` should be added. To execute the script using`Python3`, `#!/usr/bin/env python3\n` should be added.) Otherwise, the script will by default be excuted by `/bin/sh`.
func (o ScriptOutput) Text() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Script) *string { return v.Text }).(pulumi.StringPtrOutput)
}

type ScriptPtrOutput struct{ *pulumi.OutputState }

func (ScriptPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Script)(nil)).Elem()
}

func (o ScriptPtrOutput) ToScriptPtrOutput() ScriptPtrOutput {
	return o
}

func (o ScriptPtrOutput) ToScriptPtrOutputWithContext(ctx context.Context) ScriptPtrOutput {
	return o
}

func (o ScriptPtrOutput) Elem() ScriptOutput {
	return o.ApplyT(func(v *Script) Script {
		if v != nil {
			return *v
		}
		var ret Script
		return ret
	}).(ScriptOutput)
}

// Script file path on the host VM. To specify an interpreter, please add a `#!`(also known as [shebang line](<https://en.wikipedia.org/wiki/Shebang_(Unix)>)) as the first line of the file.(For example, to execute the script using bash, `#!/bin/bash` should be the first line of the file. To execute the script using`Python3`, `#!/usr/bin/env python3` should be the first line of the file.) Otherwise, the file will by default be excuted by `/bin/sh`.
func (o ScriptPtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Script) *string {
		if v == nil {
			return nil
		}
		return v.Path
	}).(pulumi.StringPtrOutput)
}

// Shell script text. To specify an interpreter, please add a `#!\n` at the beginning of the text.(For example, to execute the script using bash, `#!/bin/bash\n` should be added. To execute the script using`Python3`, `#!/usr/bin/env python3\n` should be added.) Otherwise, the script will by default be excuted by `/bin/sh`.
func (o ScriptPtrOutput) Text() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Script) *string {
		if v == nil {
			return nil
		}
		return v.Text
	}).(pulumi.StringPtrOutput)
}

// Script runnable.
type ScriptResponse struct {
	// Script file path on the host VM. To specify an interpreter, please add a `#!`(also known as [shebang line](<https://en.wikipedia.org/wiki/Shebang_(Unix)>)) as the first line of the file.(For example, to execute the script using bash, `#!/bin/bash` should be the first line of the file. To execute the script using`Python3`, `#!/usr/bin/env python3` should be the first line of the file.) Otherwise, the file will by default be excuted by `/bin/sh`.
	Path string `pulumi:"path"`
	// Shell script text. To specify an interpreter, please add a `#!\n` at the beginning of the text.(For example, to execute the script using bash, `#!/bin/bash\n` should be added. To execute the script using`Python3`, `#!/usr/bin/env python3\n` should be added.) Otherwise, the script will by default be excuted by `/bin/sh`.
	Text string `pulumi:"text"`
}

// Script runnable.
type ScriptResponseOutput struct{ *pulumi.OutputState }

func (ScriptResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScriptResponse)(nil)).Elem()
}

func (o ScriptResponseOutput) ToScriptResponseOutput() ScriptResponseOutput {
	return o
}

func (o ScriptResponseOutput) ToScriptResponseOutputWithContext(ctx context.Context) ScriptResponseOutput {
	return o
}

// Script file path on the host VM. To specify an interpreter, please add a `#!`(also known as [shebang line](<https://en.wikipedia.org/wiki/Shebang_(Unix)>)) as the first line of the file.(For example, to execute the script using bash, `#!/bin/bash` should be the first line of the file. To execute the script using`Python3`, `#!/usr/bin/env python3` should be the first line of the file.) Otherwise, the file will by default be excuted by `/bin/sh`.
func (o ScriptResponseOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v ScriptResponse) string { return v.Path }).(pulumi.StringOutput)
}

// Shell script text. To specify an interpreter, please add a `#!\n` at the beginning of the text.(For example, to execute the script using bash, `#!/bin/bash\n` should be added. To execute the script using`Python3`, `#!/usr/bin/env python3\n` should be added.) Otherwise, the script will by default be excuted by `/bin/sh`.
func (o ScriptResponseOutput) Text() pulumi.StringOutput {
	return o.ApplyT(func(v ScriptResponse) string { return v.Text }).(pulumi.StringOutput)
}

// Carries information about a Google Cloud service account.
type ServiceAccount struct {
	// Email address of the service account. If not specified, the default Compute Engine service account for the project will be used. If instance template is being used, the service account has to be specified in the instance template and it has to match the email field here.
	Email *string `pulumi:"email"`
	// List of scopes to be enabled for this service account on the VM, in addition to the cloud-platform API scope that will be added by default.
	Scopes []string `pulumi:"scopes"`
}

// ServiceAccountInput is an input type that accepts ServiceAccountArgs and ServiceAccountOutput values.
// You can construct a concrete instance of `ServiceAccountInput` via:
//
//	ServiceAccountArgs{...}
type ServiceAccountInput interface {
	pulumi.Input

	ToServiceAccountOutput() ServiceAccountOutput
	ToServiceAccountOutputWithContext(context.Context) ServiceAccountOutput
}

// Carries information about a Google Cloud service account.
type ServiceAccountArgs struct {
	// Email address of the service account. If not specified, the default Compute Engine service account for the project will be used. If instance template is being used, the service account has to be specified in the instance template and it has to match the email field here.
	Email pulumi.StringPtrInput `pulumi:"email"`
	// List of scopes to be enabled for this service account on the VM, in addition to the cloud-platform API scope that will be added by default.
	Scopes pulumi.StringArrayInput `pulumi:"scopes"`
}

func (ServiceAccountArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAccount)(nil)).Elem()
}

func (i ServiceAccountArgs) ToServiceAccountOutput() ServiceAccountOutput {
	return i.ToServiceAccountOutputWithContext(context.Background())
}

func (i ServiceAccountArgs) ToServiceAccountOutputWithContext(ctx context.Context) ServiceAccountOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccountOutput)
}

func (i ServiceAccountArgs) ToServiceAccountPtrOutput() ServiceAccountPtrOutput {
	return i.ToServiceAccountPtrOutputWithContext(context.Background())
}

func (i ServiceAccountArgs) ToServiceAccountPtrOutputWithContext(ctx context.Context) ServiceAccountPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccountOutput).ToServiceAccountPtrOutputWithContext(ctx)
}

// ServiceAccountPtrInput is an input type that accepts ServiceAccountArgs, ServiceAccountPtr and ServiceAccountPtrOutput values.
// You can construct a concrete instance of `ServiceAccountPtrInput` via:
//
//	        ServiceAccountArgs{...}
//
//	or:
//
//	        nil
type ServiceAccountPtrInput interface {
	pulumi.Input

	ToServiceAccountPtrOutput() ServiceAccountPtrOutput
	ToServiceAccountPtrOutputWithContext(context.Context) ServiceAccountPtrOutput
}

type serviceAccountPtrType ServiceAccountArgs

func ServiceAccountPtr(v *ServiceAccountArgs) ServiceAccountPtrInput {
	return (*serviceAccountPtrType)(v)
}

func (*serviceAccountPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAccount)(nil)).Elem()
}

func (i *serviceAccountPtrType) ToServiceAccountPtrOutput() ServiceAccountPtrOutput {
	return i.ToServiceAccountPtrOutputWithContext(context.Background())
}

func (i *serviceAccountPtrType) ToServiceAccountPtrOutputWithContext(ctx context.Context) ServiceAccountPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccountPtrOutput)
}

// Carries information about a Google Cloud service account.
type ServiceAccountOutput struct{ *pulumi.OutputState }

func (ServiceAccountOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAccount)(nil)).Elem()
}

func (o ServiceAccountOutput) ToServiceAccountOutput() ServiceAccountOutput {
	return o
}

func (o ServiceAccountOutput) ToServiceAccountOutputWithContext(ctx context.Context) ServiceAccountOutput {
	return o
}

func (o ServiceAccountOutput) ToServiceAccountPtrOutput() ServiceAccountPtrOutput {
	return o.ToServiceAccountPtrOutputWithContext(context.Background())
}

func (o ServiceAccountOutput) ToServiceAccountPtrOutputWithContext(ctx context.Context) ServiceAccountPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ServiceAccount) *ServiceAccount {
		return &v
	}).(ServiceAccountPtrOutput)
}

// Email address of the service account. If not specified, the default Compute Engine service account for the project will be used. If instance template is being used, the service account has to be specified in the instance template and it has to match the email field here.
func (o ServiceAccountOutput) Email() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceAccount) *string { return v.Email }).(pulumi.StringPtrOutput)
}

// List of scopes to be enabled for this service account on the VM, in addition to the cloud-platform API scope that will be added by default.
func (o ServiceAccountOutput) Scopes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServiceAccount) []string { return v.Scopes }).(pulumi.StringArrayOutput)
}

type ServiceAccountPtrOutput struct{ *pulumi.OutputState }

func (ServiceAccountPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAccount)(nil)).Elem()
}

func (o ServiceAccountPtrOutput) ToServiceAccountPtrOutput() ServiceAccountPtrOutput {
	return o
}

func (o ServiceAccountPtrOutput) ToServiceAccountPtrOutputWithContext(ctx context.Context) ServiceAccountPtrOutput {
	return o
}

func (o ServiceAccountPtrOutput) Elem() ServiceAccountOutput {
	return o.ApplyT(func(v *ServiceAccount) ServiceAccount {
		if v != nil {
			return *v
		}
		var ret ServiceAccount
		return ret
	}).(ServiceAccountOutput)
}

// Email address of the service account. If not specified, the default Compute Engine service account for the project will be used. If instance template is being used, the service account has to be specified in the instance template and it has to match the email field here.
func (o ServiceAccountPtrOutput) Email() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceAccount) *string {
		if v == nil {
			return nil
		}
		return v.Email
	}).(pulumi.StringPtrOutput)
}

// List of scopes to be enabled for this service account on the VM, in addition to the cloud-platform API scope that will be added by default.
func (o ServiceAccountPtrOutput) Scopes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServiceAccount) []string {
		if v == nil {
			return nil
		}
		return v.Scopes
	}).(pulumi.StringArrayOutput)
}

// Carries information about a Google Cloud service account.
type ServiceAccountResponse struct {
	// Email address of the service account. If not specified, the default Compute Engine service account for the project will be used. If instance template is being used, the service account has to be specified in the instance template and it has to match the email field here.
	Email string `pulumi:"email"`
	// List of scopes to be enabled for this service account on the VM, in addition to the cloud-platform API scope that will be added by default.
	Scopes []string `pulumi:"scopes"`
}

// Carries information about a Google Cloud service account.
type ServiceAccountResponseOutput struct{ *pulumi.OutputState }

func (ServiceAccountResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAccountResponse)(nil)).Elem()
}

func (o ServiceAccountResponseOutput) ToServiceAccountResponseOutput() ServiceAccountResponseOutput {
	return o
}

func (o ServiceAccountResponseOutput) ToServiceAccountResponseOutputWithContext(ctx context.Context) ServiceAccountResponseOutput {
	return o
}

// Email address of the service account. If not specified, the default Compute Engine service account for the project will be used. If instance template is being used, the service account has to be specified in the instance template and it has to match the email field here.
func (o ServiceAccountResponseOutput) Email() pulumi.StringOutput {
	return o.ApplyT(func(v ServiceAccountResponse) string { return v.Email }).(pulumi.StringOutput)
}

// List of scopes to be enabled for this service account on the VM, in addition to the cloud-platform API scope that will be added by default.
func (o ServiceAccountResponseOutput) Scopes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServiceAccountResponse) []string { return v.Scopes }).(pulumi.StringArrayOutput)
}

// Status event
type StatusEventResponse struct {
	// Description of the event.
	Description string `pulumi:"description"`
	// The time this event occurred.
	EventTime string `pulumi:"eventTime"`
	// Task Execution
	TaskExecution TaskExecutionResponse `pulumi:"taskExecution"`
	// Task State
	TaskState string `pulumi:"taskState"`
	// Type of the event.
	Type string `pulumi:"type"`
}

// Status event
type StatusEventResponseOutput struct{ *pulumi.OutputState }

func (StatusEventResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatusEventResponse)(nil)).Elem()
}

func (o StatusEventResponseOutput) ToStatusEventResponseOutput() StatusEventResponseOutput {
	return o
}

func (o StatusEventResponseOutput) ToStatusEventResponseOutputWithContext(ctx context.Context) StatusEventResponseOutput {
	return o
}

// Description of the event.
func (o StatusEventResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v StatusEventResponse) string { return v.Description }).(pulumi.StringOutput)
}

// The time this event occurred.
func (o StatusEventResponseOutput) EventTime() pulumi.StringOutput {
	return o.ApplyT(func(v StatusEventResponse) string { return v.EventTime }).(pulumi.StringOutput)
}

// Task Execution
func (o StatusEventResponseOutput) TaskExecution() TaskExecutionResponseOutput {
	return o.ApplyT(func(v StatusEventResponse) TaskExecutionResponse { return v.TaskExecution }).(TaskExecutionResponseOutput)
}

// Task State
func (o StatusEventResponseOutput) TaskState() pulumi.StringOutput {
	return o.ApplyT(func(v StatusEventResponse) string { return v.TaskState }).(pulumi.StringOutput)
}

// Type of the event.
func (o StatusEventResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v StatusEventResponse) string { return v.Type }).(pulumi.StringOutput)
}

type StatusEventResponseArrayOutput struct{ *pulumi.OutputState }

func (StatusEventResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StatusEventResponse)(nil)).Elem()
}

func (o StatusEventResponseArrayOutput) ToStatusEventResponseArrayOutput() StatusEventResponseArrayOutput {
	return o
}

func (o StatusEventResponseArrayOutput) ToStatusEventResponseArrayOutputWithContext(ctx context.Context) StatusEventResponseArrayOutput {
	return o
}

func (o StatusEventResponseArrayOutput) Index(i pulumi.IntInput) StatusEventResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StatusEventResponse {
		return vs[0].([]StatusEventResponse)[vs[1].(int)]
	}).(StatusEventResponseOutput)
}

// This Task Execution field includes detail information for task execution procedures, based on StatusEvent types.
type TaskExecutionResponse struct {
	// When task is completed as the status of FAILED or SUCCEEDED, exit code is for one task execution result, default is 0 as success.
	ExitCode int `pulumi:"exitCode"`
}

// This Task Execution field includes detail information for task execution procedures, based on StatusEvent types.
type TaskExecutionResponseOutput struct{ *pulumi.OutputState }

func (TaskExecutionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TaskExecutionResponse)(nil)).Elem()
}

func (o TaskExecutionResponseOutput) ToTaskExecutionResponseOutput() TaskExecutionResponseOutput {
	return o
}

func (o TaskExecutionResponseOutput) ToTaskExecutionResponseOutputWithContext(ctx context.Context) TaskExecutionResponseOutput {
	return o
}

// When task is completed as the status of FAILED or SUCCEEDED, exit code is for one task execution result, default is 0 as success.
func (o TaskExecutionResponseOutput) ExitCode() pulumi.IntOutput {
	return o.ApplyT(func(v TaskExecutionResponse) int { return v.ExitCode }).(pulumi.IntOutput)
}

// A TaskGroup defines one or more Tasks that all share the same TaskSpec.
type TaskGroup struct {
	// Max number of tasks that can run in parallel. Default to min(task_count, parallel tasks per job limit). See: [Job Limits](https://cloud.google.com/batch/quotas#job_limits). Field parallelism must be 1 if the scheduling_policy is IN_ORDER.
	Parallelism *string `pulumi:"parallelism"`
	// When true, Batch will configure SSH to allow passwordless login between VMs running the Batch tasks in the same TaskGroup.
	PermissiveSsh *bool `pulumi:"permissiveSsh"`
	// When true, Batch will populate a file with a list of all VMs assigned to the TaskGroup and set the BATCH_HOSTS_FILE environment variable to the path of that file. Defaults to false.
	RequireHostsFile *bool `pulumi:"requireHostsFile"`
	// Scheduling policy for Tasks in the TaskGroup. The default value is AS_SOON_AS_POSSIBLE.
	SchedulingPolicy *TaskGroupSchedulingPolicy `pulumi:"schedulingPolicy"`
	// Number of Tasks in the TaskGroup. Default is 1.
	TaskCount *string `pulumi:"taskCount"`
	// Max number of tasks that can be run on a VM at the same time. If not specified, the system will decide a value based on available compute resources on a VM and task requirements.
	TaskCountPerNode *string `pulumi:"taskCountPerNode"`
	// An array of environment variable mappings, which are passed to Tasks with matching indices. If task_environments is used then task_count should not be specified in the request (and will be ignored). Task count will be the length of task_environments. Tasks get a BATCH_TASK_INDEX and BATCH_TASK_COUNT environment variable, in addition to any environment variables set in task_environments, specifying the number of Tasks in the Task's parent TaskGroup, and the specific Task's index in the TaskGroup (0 through BATCH_TASK_COUNT - 1).
	TaskEnvironments []Environment `pulumi:"taskEnvironments"`
	// Tasks in the group share the same task spec.
	TaskSpec TaskSpec `pulumi:"taskSpec"`
}

// TaskGroupInput is an input type that accepts TaskGroupArgs and TaskGroupOutput values.
// You can construct a concrete instance of `TaskGroupInput` via:
//
//	TaskGroupArgs{...}
type TaskGroupInput interface {
	pulumi.Input

	ToTaskGroupOutput() TaskGroupOutput
	ToTaskGroupOutputWithContext(context.Context) TaskGroupOutput
}

// A TaskGroup defines one or more Tasks that all share the same TaskSpec.
type TaskGroupArgs struct {
	// Max number of tasks that can run in parallel. Default to min(task_count, parallel tasks per job limit). See: [Job Limits](https://cloud.google.com/batch/quotas#job_limits). Field parallelism must be 1 if the scheduling_policy is IN_ORDER.
	Parallelism pulumi.StringPtrInput `pulumi:"parallelism"`
	// When true, Batch will configure SSH to allow passwordless login between VMs running the Batch tasks in the same TaskGroup.
	PermissiveSsh pulumi.BoolPtrInput `pulumi:"permissiveSsh"`
	// When true, Batch will populate a file with a list of all VMs assigned to the TaskGroup and set the BATCH_HOSTS_FILE environment variable to the path of that file. Defaults to false.
	RequireHostsFile pulumi.BoolPtrInput `pulumi:"requireHostsFile"`
	// Scheduling policy for Tasks in the TaskGroup. The default value is AS_SOON_AS_POSSIBLE.
	SchedulingPolicy TaskGroupSchedulingPolicyPtrInput `pulumi:"schedulingPolicy"`
	// Number of Tasks in the TaskGroup. Default is 1.
	TaskCount pulumi.StringPtrInput `pulumi:"taskCount"`
	// Max number of tasks that can be run on a VM at the same time. If not specified, the system will decide a value based on available compute resources on a VM and task requirements.
	TaskCountPerNode pulumi.StringPtrInput `pulumi:"taskCountPerNode"`
	// An array of environment variable mappings, which are passed to Tasks with matching indices. If task_environments is used then task_count should not be specified in the request (and will be ignored). Task count will be the length of task_environments. Tasks get a BATCH_TASK_INDEX and BATCH_TASK_COUNT environment variable, in addition to any environment variables set in task_environments, specifying the number of Tasks in the Task's parent TaskGroup, and the specific Task's index in the TaskGroup (0 through BATCH_TASK_COUNT - 1).
	TaskEnvironments EnvironmentArrayInput `pulumi:"taskEnvironments"`
	// Tasks in the group share the same task spec.
	TaskSpec TaskSpecInput `pulumi:"taskSpec"`
}

func (TaskGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TaskGroup)(nil)).Elem()
}

func (i TaskGroupArgs) ToTaskGroupOutput() TaskGroupOutput {
	return i.ToTaskGroupOutputWithContext(context.Background())
}

func (i TaskGroupArgs) ToTaskGroupOutputWithContext(ctx context.Context) TaskGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TaskGroupOutput)
}

// TaskGroupArrayInput is an input type that accepts TaskGroupArray and TaskGroupArrayOutput values.
// You can construct a concrete instance of `TaskGroupArrayInput` via:
//
//	TaskGroupArray{ TaskGroupArgs{...} }
type TaskGroupArrayInput interface {
	pulumi.Input

	ToTaskGroupArrayOutput() TaskGroupArrayOutput
	ToTaskGroupArrayOutputWithContext(context.Context) TaskGroupArrayOutput
}

type TaskGroupArray []TaskGroupInput

func (TaskGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TaskGroup)(nil)).Elem()
}

func (i TaskGroupArray) ToTaskGroupArrayOutput() TaskGroupArrayOutput {
	return i.ToTaskGroupArrayOutputWithContext(context.Background())
}

func (i TaskGroupArray) ToTaskGroupArrayOutputWithContext(ctx context.Context) TaskGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TaskGroupArrayOutput)
}

// A TaskGroup defines one or more Tasks that all share the same TaskSpec.
type TaskGroupOutput struct{ *pulumi.OutputState }

func (TaskGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TaskGroup)(nil)).Elem()
}

func (o TaskGroupOutput) ToTaskGroupOutput() TaskGroupOutput {
	return o
}

func (o TaskGroupOutput) ToTaskGroupOutputWithContext(ctx context.Context) TaskGroupOutput {
	return o
}

// Max number of tasks that can run in parallel. Default to min(task_count, parallel tasks per job limit). See: [Job Limits](https://cloud.google.com/batch/quotas#job_limits). Field parallelism must be 1 if the scheduling_policy is IN_ORDER.
func (o TaskGroupOutput) Parallelism() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TaskGroup) *string { return v.Parallelism }).(pulumi.StringPtrOutput)
}

// When true, Batch will configure SSH to allow passwordless login between VMs running the Batch tasks in the same TaskGroup.
func (o TaskGroupOutput) PermissiveSsh() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v TaskGroup) *bool { return v.PermissiveSsh }).(pulumi.BoolPtrOutput)
}

// When true, Batch will populate a file with a list of all VMs assigned to the TaskGroup and set the BATCH_HOSTS_FILE environment variable to the path of that file. Defaults to false.
func (o TaskGroupOutput) RequireHostsFile() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v TaskGroup) *bool { return v.RequireHostsFile }).(pulumi.BoolPtrOutput)
}

// Scheduling policy for Tasks in the TaskGroup. The default value is AS_SOON_AS_POSSIBLE.
func (o TaskGroupOutput) SchedulingPolicy() TaskGroupSchedulingPolicyPtrOutput {
	return o.ApplyT(func(v TaskGroup) *TaskGroupSchedulingPolicy { return v.SchedulingPolicy }).(TaskGroupSchedulingPolicyPtrOutput)
}

// Number of Tasks in the TaskGroup. Default is 1.
func (o TaskGroupOutput) TaskCount() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TaskGroup) *string { return v.TaskCount }).(pulumi.StringPtrOutput)
}

// Max number of tasks that can be run on a VM at the same time. If not specified, the system will decide a value based on available compute resources on a VM and task requirements.
func (o TaskGroupOutput) TaskCountPerNode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TaskGroup) *string { return v.TaskCountPerNode }).(pulumi.StringPtrOutput)
}

// An array of environment variable mappings, which are passed to Tasks with matching indices. If task_environments is used then task_count should not be specified in the request (and will be ignored). Task count will be the length of task_environments. Tasks get a BATCH_TASK_INDEX and BATCH_TASK_COUNT environment variable, in addition to any environment variables set in task_environments, specifying the number of Tasks in the Task's parent TaskGroup, and the specific Task's index in the TaskGroup (0 through BATCH_TASK_COUNT - 1).
func (o TaskGroupOutput) TaskEnvironments() EnvironmentArrayOutput {
	return o.ApplyT(func(v TaskGroup) []Environment { return v.TaskEnvironments }).(EnvironmentArrayOutput)
}

// Tasks in the group share the same task spec.
func (o TaskGroupOutput) TaskSpec() TaskSpecOutput {
	return o.ApplyT(func(v TaskGroup) TaskSpec { return v.TaskSpec }).(TaskSpecOutput)
}

type TaskGroupArrayOutput struct{ *pulumi.OutputState }

func (TaskGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TaskGroup)(nil)).Elem()
}

func (o TaskGroupArrayOutput) ToTaskGroupArrayOutput() TaskGroupArrayOutput {
	return o
}

func (o TaskGroupArrayOutput) ToTaskGroupArrayOutputWithContext(ctx context.Context) TaskGroupArrayOutput {
	return o
}

func (o TaskGroupArrayOutput) Index(i pulumi.IntInput) TaskGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TaskGroup {
		return vs[0].([]TaskGroup)[vs[1].(int)]
	}).(TaskGroupOutput)
}

// A TaskGroup defines one or more Tasks that all share the same TaskSpec.
type TaskGroupResponse struct {
	// TaskGroup name. The system generates this field based on parent Job name. For example: "projects/123456/locations/us-west1/jobs/job01/taskGroups/group01".
	Name string `pulumi:"name"`
	// Max number of tasks that can run in parallel. Default to min(task_count, parallel tasks per job limit). See: [Job Limits](https://cloud.google.com/batch/quotas#job_limits). Field parallelism must be 1 if the scheduling_policy is IN_ORDER.
	Parallelism string `pulumi:"parallelism"`
	// When true, Batch will configure SSH to allow passwordless login between VMs running the Batch tasks in the same TaskGroup.
	PermissiveSsh bool `pulumi:"permissiveSsh"`
	// When true, Batch will populate a file with a list of all VMs assigned to the TaskGroup and set the BATCH_HOSTS_FILE environment variable to the path of that file. Defaults to false.
	RequireHostsFile bool `pulumi:"requireHostsFile"`
	// Scheduling policy for Tasks in the TaskGroup. The default value is AS_SOON_AS_POSSIBLE.
	SchedulingPolicy string `pulumi:"schedulingPolicy"`
	// Number of Tasks in the TaskGroup. Default is 1.
	TaskCount string `pulumi:"taskCount"`
	// Max number of tasks that can be run on a VM at the same time. If not specified, the system will decide a value based on available compute resources on a VM and task requirements.
	TaskCountPerNode string `pulumi:"taskCountPerNode"`
	// An array of environment variable mappings, which are passed to Tasks with matching indices. If task_environments is used then task_count should not be specified in the request (and will be ignored). Task count will be the length of task_environments. Tasks get a BATCH_TASK_INDEX and BATCH_TASK_COUNT environment variable, in addition to any environment variables set in task_environments, specifying the number of Tasks in the Task's parent TaskGroup, and the specific Task's index in the TaskGroup (0 through BATCH_TASK_COUNT - 1).
	TaskEnvironments []EnvironmentResponse `pulumi:"taskEnvironments"`
	// Tasks in the group share the same task spec.
	TaskSpec TaskSpecResponse `pulumi:"taskSpec"`
}

// A TaskGroup defines one or more Tasks that all share the same TaskSpec.
type TaskGroupResponseOutput struct{ *pulumi.OutputState }

func (TaskGroupResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TaskGroupResponse)(nil)).Elem()
}

func (o TaskGroupResponseOutput) ToTaskGroupResponseOutput() TaskGroupResponseOutput {
	return o
}

func (o TaskGroupResponseOutput) ToTaskGroupResponseOutputWithContext(ctx context.Context) TaskGroupResponseOutput {
	return o
}

// TaskGroup name. The system generates this field based on parent Job name. For example: "projects/123456/locations/us-west1/jobs/job01/taskGroups/group01".
func (o TaskGroupResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v TaskGroupResponse) string { return v.Name }).(pulumi.StringOutput)
}

// Max number of tasks that can run in parallel. Default to min(task_count, parallel tasks per job limit). See: [Job Limits](https://cloud.google.com/batch/quotas#job_limits). Field parallelism must be 1 if the scheduling_policy is IN_ORDER.
func (o TaskGroupResponseOutput) Parallelism() pulumi.StringOutput {
	return o.ApplyT(func(v TaskGroupResponse) string { return v.Parallelism }).(pulumi.StringOutput)
}

// When true, Batch will configure SSH to allow passwordless login between VMs running the Batch tasks in the same TaskGroup.
func (o TaskGroupResponseOutput) PermissiveSsh() pulumi.BoolOutput {
	return o.ApplyT(func(v TaskGroupResponse) bool { return v.PermissiveSsh }).(pulumi.BoolOutput)
}

// When true, Batch will populate a file with a list of all VMs assigned to the TaskGroup and set the BATCH_HOSTS_FILE environment variable to the path of that file. Defaults to false.
func (o TaskGroupResponseOutput) RequireHostsFile() pulumi.BoolOutput {
	return o.ApplyT(func(v TaskGroupResponse) bool { return v.RequireHostsFile }).(pulumi.BoolOutput)
}

// Scheduling policy for Tasks in the TaskGroup. The default value is AS_SOON_AS_POSSIBLE.
func (o TaskGroupResponseOutput) SchedulingPolicy() pulumi.StringOutput {
	return o.ApplyT(func(v TaskGroupResponse) string { return v.SchedulingPolicy }).(pulumi.StringOutput)
}

// Number of Tasks in the TaskGroup. Default is 1.
func (o TaskGroupResponseOutput) TaskCount() pulumi.StringOutput {
	return o.ApplyT(func(v TaskGroupResponse) string { return v.TaskCount }).(pulumi.StringOutput)
}

// Max number of tasks that can be run on a VM at the same time. If not specified, the system will decide a value based on available compute resources on a VM and task requirements.
func (o TaskGroupResponseOutput) TaskCountPerNode() pulumi.StringOutput {
	return o.ApplyT(func(v TaskGroupResponse) string { return v.TaskCountPerNode }).(pulumi.StringOutput)
}

// An array of environment variable mappings, which are passed to Tasks with matching indices. If task_environments is used then task_count should not be specified in the request (and will be ignored). Task count will be the length of task_environments. Tasks get a BATCH_TASK_INDEX and BATCH_TASK_COUNT environment variable, in addition to any environment variables set in task_environments, specifying the number of Tasks in the Task's parent TaskGroup, and the specific Task's index in the TaskGroup (0 through BATCH_TASK_COUNT - 1).
func (o TaskGroupResponseOutput) TaskEnvironments() EnvironmentResponseArrayOutput {
	return o.ApplyT(func(v TaskGroupResponse) []EnvironmentResponse { return v.TaskEnvironments }).(EnvironmentResponseArrayOutput)
}

// Tasks in the group share the same task spec.
func (o TaskGroupResponseOutput) TaskSpec() TaskSpecResponseOutput {
	return o.ApplyT(func(v TaskGroupResponse) TaskSpecResponse { return v.TaskSpec }).(TaskSpecResponseOutput)
}

type TaskGroupResponseArrayOutput struct{ *pulumi.OutputState }

func (TaskGroupResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TaskGroupResponse)(nil)).Elem()
}

func (o TaskGroupResponseArrayOutput) ToTaskGroupResponseArrayOutput() TaskGroupResponseArrayOutput {
	return o
}

func (o TaskGroupResponseArrayOutput) ToTaskGroupResponseArrayOutputWithContext(ctx context.Context) TaskGroupResponseArrayOutput {
	return o
}

func (o TaskGroupResponseArrayOutput) Index(i pulumi.IntInput) TaskGroupResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TaskGroupResponse {
		return vs[0].([]TaskGroupResponse)[vs[1].(int)]
	}).(TaskGroupResponseOutput)
}

// Aggregated task status for a TaskGroup.
type TaskGroupStatusResponse struct {
	// Count of task in each state in the TaskGroup. The map key is task state name.
	Counts map[string]string `pulumi:"counts"`
	// Status of instances allocated for the TaskGroup.
	Instances []InstanceStatusResponse `pulumi:"instances"`
}

// Aggregated task status for a TaskGroup.
type TaskGroupStatusResponseOutput struct{ *pulumi.OutputState }

func (TaskGroupStatusResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TaskGroupStatusResponse)(nil)).Elem()
}

func (o TaskGroupStatusResponseOutput) ToTaskGroupStatusResponseOutput() TaskGroupStatusResponseOutput {
	return o
}

func (o TaskGroupStatusResponseOutput) ToTaskGroupStatusResponseOutputWithContext(ctx context.Context) TaskGroupStatusResponseOutput {
	return o
}

// Count of task in each state in the TaskGroup. The map key is task state name.
func (o TaskGroupStatusResponseOutput) Counts() pulumi.StringMapOutput {
	return o.ApplyT(func(v TaskGroupStatusResponse) map[string]string { return v.Counts }).(pulumi.StringMapOutput)
}

// Status of instances allocated for the TaskGroup.
func (o TaskGroupStatusResponseOutput) Instances() InstanceStatusResponseArrayOutput {
	return o.ApplyT(func(v TaskGroupStatusResponse) []InstanceStatusResponse { return v.Instances }).(InstanceStatusResponseArrayOutput)
}

type TaskGroupStatusResponseMapOutput struct{ *pulumi.OutputState }

func (TaskGroupStatusResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]TaskGroupStatusResponse)(nil)).Elem()
}

func (o TaskGroupStatusResponseMapOutput) ToTaskGroupStatusResponseMapOutput() TaskGroupStatusResponseMapOutput {
	return o
}

func (o TaskGroupStatusResponseMapOutput) ToTaskGroupStatusResponseMapOutputWithContext(ctx context.Context) TaskGroupStatusResponseMapOutput {
	return o
}

func (o TaskGroupStatusResponseMapOutput) MapIndex(k pulumi.StringInput) TaskGroupStatusResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) TaskGroupStatusResponse {
		return vs[0].(map[string]TaskGroupStatusResponse)[vs[1].(string)]
	}).(TaskGroupStatusResponseOutput)
}

// Spec of a task
type TaskSpec struct {
	// ComputeResource requirements.
	ComputeResource *ComputeResource `pulumi:"computeResource"`
	// Environment variables to set before running the Task.
	Environment *Environment `pulumi:"environment"`
	// Deprecated: please use environment(non-plural) instead.
	//
	// Deprecated: Deprecated: please use environment(non-plural) instead.
	Environments map[string]string `pulumi:"environments"`
	// Lifecycle management schema when any task in a task group is failed. Currently we only support one lifecycle policy. When the lifecycle policy condition is met, the action in the policy will execute. If task execution result does not meet with the defined lifecycle policy, we consider it as the default policy. Default policy means if the exit code is 0, exit task. If task ends with non-zero exit code, retry the task with max_retry_count.
	LifecyclePolicies []LifecyclePolicy `pulumi:"lifecyclePolicies"`
	// Maximum number of retries on failures. The default, 0, which means never retry. The valid value range is [0, 10].
	MaxRetryCount *int `pulumi:"maxRetryCount"`
	// Maximum duration the task should run. The task will be killed and marked as FAILED if over this limit.
	MaxRunDuration *string `pulumi:"maxRunDuration"`
	// The sequence of scripts or containers to run for this Task. Each Task using this TaskSpec executes its list of runnables in order. The Task succeeds if all of its runnables either exit with a zero status or any that exit with a non-zero status have the ignore_exit_status flag. Background runnables are killed automatically (if they have not already exited) a short time after all foreground runnables have completed. Even though this is likely to result in a non-zero exit status for the background runnable, these automatic kills are not treated as Task failures.
	Runnables []Runnable `pulumi:"runnables"`
	// Volumes to mount before running Tasks using this TaskSpec.
	Volumes []Volume `pulumi:"volumes"`
}

// TaskSpecInput is an input type that accepts TaskSpecArgs and TaskSpecOutput values.
// You can construct a concrete instance of `TaskSpecInput` via:
//
//	TaskSpecArgs{...}
type TaskSpecInput interface {
	pulumi.Input

	ToTaskSpecOutput() TaskSpecOutput
	ToTaskSpecOutputWithContext(context.Context) TaskSpecOutput
}

// Spec of a task
type TaskSpecArgs struct {
	// ComputeResource requirements.
	ComputeResource ComputeResourcePtrInput `pulumi:"computeResource"`
	// Environment variables to set before running the Task.
	Environment EnvironmentPtrInput `pulumi:"environment"`
	// Deprecated: please use environment(non-plural) instead.
	//
	// Deprecated: Deprecated: please use environment(non-plural) instead.
	Environments pulumi.StringMapInput `pulumi:"environments"`
	// Lifecycle management schema when any task in a task group is failed. Currently we only support one lifecycle policy. When the lifecycle policy condition is met, the action in the policy will execute. If task execution result does not meet with the defined lifecycle policy, we consider it as the default policy. Default policy means if the exit code is 0, exit task. If task ends with non-zero exit code, retry the task with max_retry_count.
	LifecyclePolicies LifecyclePolicyArrayInput `pulumi:"lifecyclePolicies"`
	// Maximum number of retries on failures. The default, 0, which means never retry. The valid value range is [0, 10].
	MaxRetryCount pulumi.IntPtrInput `pulumi:"maxRetryCount"`
	// Maximum duration the task should run. The task will be killed and marked as FAILED if over this limit.
	MaxRunDuration pulumi.StringPtrInput `pulumi:"maxRunDuration"`
	// The sequence of scripts or containers to run for this Task. Each Task using this TaskSpec executes its list of runnables in order. The Task succeeds if all of its runnables either exit with a zero status or any that exit with a non-zero status have the ignore_exit_status flag. Background runnables are killed automatically (if they have not already exited) a short time after all foreground runnables have completed. Even though this is likely to result in a non-zero exit status for the background runnable, these automatic kills are not treated as Task failures.
	Runnables RunnableArrayInput `pulumi:"runnables"`
	// Volumes to mount before running Tasks using this TaskSpec.
	Volumes VolumeArrayInput `pulumi:"volumes"`
}

func (TaskSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TaskSpec)(nil)).Elem()
}

func (i TaskSpecArgs) ToTaskSpecOutput() TaskSpecOutput {
	return i.ToTaskSpecOutputWithContext(context.Background())
}

func (i TaskSpecArgs) ToTaskSpecOutputWithContext(ctx context.Context) TaskSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TaskSpecOutput)
}

// Spec of a task
type TaskSpecOutput struct{ *pulumi.OutputState }

func (TaskSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TaskSpec)(nil)).Elem()
}

func (o TaskSpecOutput) ToTaskSpecOutput() TaskSpecOutput {
	return o
}

func (o TaskSpecOutput) ToTaskSpecOutputWithContext(ctx context.Context) TaskSpecOutput {
	return o
}

// ComputeResource requirements.
func (o TaskSpecOutput) ComputeResource() ComputeResourcePtrOutput {
	return o.ApplyT(func(v TaskSpec) *ComputeResource { return v.ComputeResource }).(ComputeResourcePtrOutput)
}

// Environment variables to set before running the Task.
func (o TaskSpecOutput) Environment() EnvironmentPtrOutput {
	return o.ApplyT(func(v TaskSpec) *Environment { return v.Environment }).(EnvironmentPtrOutput)
}

// Deprecated: please use environment(non-plural) instead.
//
// Deprecated: Deprecated: please use environment(non-plural) instead.
func (o TaskSpecOutput) Environments() pulumi.StringMapOutput {
	return o.ApplyT(func(v TaskSpec) map[string]string { return v.Environments }).(pulumi.StringMapOutput)
}

// Lifecycle management schema when any task in a task group is failed. Currently we only support one lifecycle policy. When the lifecycle policy condition is met, the action in the policy will execute. If task execution result does not meet with the defined lifecycle policy, we consider it as the default policy. Default policy means if the exit code is 0, exit task. If task ends with non-zero exit code, retry the task with max_retry_count.
func (o TaskSpecOutput) LifecyclePolicies() LifecyclePolicyArrayOutput {
	return o.ApplyT(func(v TaskSpec) []LifecyclePolicy { return v.LifecyclePolicies }).(LifecyclePolicyArrayOutput)
}

// Maximum number of retries on failures. The default, 0, which means never retry. The valid value range is [0, 10].
func (o TaskSpecOutput) MaxRetryCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TaskSpec) *int { return v.MaxRetryCount }).(pulumi.IntPtrOutput)
}

// Maximum duration the task should run. The task will be killed and marked as FAILED if over this limit.
func (o TaskSpecOutput) MaxRunDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TaskSpec) *string { return v.MaxRunDuration }).(pulumi.StringPtrOutput)
}

// The sequence of scripts or containers to run for this Task. Each Task using this TaskSpec executes its list of runnables in order. The Task succeeds if all of its runnables either exit with a zero status or any that exit with a non-zero status have the ignore_exit_status flag. Background runnables are killed automatically (if they have not already exited) a short time after all foreground runnables have completed. Even though this is likely to result in a non-zero exit status for the background runnable, these automatic kills are not treated as Task failures.
func (o TaskSpecOutput) Runnables() RunnableArrayOutput {
	return o.ApplyT(func(v TaskSpec) []Runnable { return v.Runnables }).(RunnableArrayOutput)
}

// Volumes to mount before running Tasks using this TaskSpec.
func (o TaskSpecOutput) Volumes() VolumeArrayOutput {
	return o.ApplyT(func(v TaskSpec) []Volume { return v.Volumes }).(VolumeArrayOutput)
}

// Spec of a task
type TaskSpecResponse struct {
	// ComputeResource requirements.
	ComputeResource ComputeResourceResponse `pulumi:"computeResource"`
	// Environment variables to set before running the Task.
	Environment EnvironmentResponse `pulumi:"environment"`
	// Deprecated: please use environment(non-plural) instead.
	//
	// Deprecated: Deprecated: please use environment(non-plural) instead.
	Environments map[string]string `pulumi:"environments"`
	// Lifecycle management schema when any task in a task group is failed. Currently we only support one lifecycle policy. When the lifecycle policy condition is met, the action in the policy will execute. If task execution result does not meet with the defined lifecycle policy, we consider it as the default policy. Default policy means if the exit code is 0, exit task. If task ends with non-zero exit code, retry the task with max_retry_count.
	LifecyclePolicies []LifecyclePolicyResponse `pulumi:"lifecyclePolicies"`
	// Maximum number of retries on failures. The default, 0, which means never retry. The valid value range is [0, 10].
	MaxRetryCount int `pulumi:"maxRetryCount"`
	// Maximum duration the task should run. The task will be killed and marked as FAILED if over this limit.
	MaxRunDuration string `pulumi:"maxRunDuration"`
	// The sequence of scripts or containers to run for this Task. Each Task using this TaskSpec executes its list of runnables in order. The Task succeeds if all of its runnables either exit with a zero status or any that exit with a non-zero status have the ignore_exit_status flag. Background runnables are killed automatically (if they have not already exited) a short time after all foreground runnables have completed. Even though this is likely to result in a non-zero exit status for the background runnable, these automatic kills are not treated as Task failures.
	Runnables []RunnableResponse `pulumi:"runnables"`
	// Volumes to mount before running Tasks using this TaskSpec.
	Volumes []VolumeResponse `pulumi:"volumes"`
}

// Spec of a task
type TaskSpecResponseOutput struct{ *pulumi.OutputState }

func (TaskSpecResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TaskSpecResponse)(nil)).Elem()
}

func (o TaskSpecResponseOutput) ToTaskSpecResponseOutput() TaskSpecResponseOutput {
	return o
}

func (o TaskSpecResponseOutput) ToTaskSpecResponseOutputWithContext(ctx context.Context) TaskSpecResponseOutput {
	return o
}

// ComputeResource requirements.
func (o TaskSpecResponseOutput) ComputeResource() ComputeResourceResponseOutput {
	return o.ApplyT(func(v TaskSpecResponse) ComputeResourceResponse { return v.ComputeResource }).(ComputeResourceResponseOutput)
}

// Environment variables to set before running the Task.
func (o TaskSpecResponseOutput) Environment() EnvironmentResponseOutput {
	return o.ApplyT(func(v TaskSpecResponse) EnvironmentResponse { return v.Environment }).(EnvironmentResponseOutput)
}

// Deprecated: please use environment(non-plural) instead.
//
// Deprecated: Deprecated: please use environment(non-plural) instead.
func (o TaskSpecResponseOutput) Environments() pulumi.StringMapOutput {
	return o.ApplyT(func(v TaskSpecResponse) map[string]string { return v.Environments }).(pulumi.StringMapOutput)
}

// Lifecycle management schema when any task in a task group is failed. Currently we only support one lifecycle policy. When the lifecycle policy condition is met, the action in the policy will execute. If task execution result does not meet with the defined lifecycle policy, we consider it as the default policy. Default policy means if the exit code is 0, exit task. If task ends with non-zero exit code, retry the task with max_retry_count.
func (o TaskSpecResponseOutput) LifecyclePolicies() LifecyclePolicyResponseArrayOutput {
	return o.ApplyT(func(v TaskSpecResponse) []LifecyclePolicyResponse { return v.LifecyclePolicies }).(LifecyclePolicyResponseArrayOutput)
}

// Maximum number of retries on failures. The default, 0, which means never retry. The valid value range is [0, 10].
func (o TaskSpecResponseOutput) MaxRetryCount() pulumi.IntOutput {
	return o.ApplyT(func(v TaskSpecResponse) int { return v.MaxRetryCount }).(pulumi.IntOutput)
}

// Maximum duration the task should run. The task will be killed and marked as FAILED if over this limit.
func (o TaskSpecResponseOutput) MaxRunDuration() pulumi.StringOutput {
	return o.ApplyT(func(v TaskSpecResponse) string { return v.MaxRunDuration }).(pulumi.StringOutput)
}

// The sequence of scripts or containers to run for this Task. Each Task using this TaskSpec executes its list of runnables in order. The Task succeeds if all of its runnables either exit with a zero status or any that exit with a non-zero status have the ignore_exit_status flag. Background runnables are killed automatically (if they have not already exited) a short time after all foreground runnables have completed. Even though this is likely to result in a non-zero exit status for the background runnable, these automatic kills are not treated as Task failures.
func (o TaskSpecResponseOutput) Runnables() RunnableResponseArrayOutput {
	return o.ApplyT(func(v TaskSpecResponse) []RunnableResponse { return v.Runnables }).(RunnableResponseArrayOutput)
}

// Volumes to mount before running Tasks using this TaskSpec.
func (o TaskSpecResponseOutput) Volumes() VolumeResponseArrayOutput {
	return o.ApplyT(func(v TaskSpecResponse) []VolumeResponse { return v.Volumes }).(VolumeResponseArrayOutput)
}

// Volume describes a volume and parameters for it to be mounted to a VM.
type Volume struct {
	// Device name of an attached disk volume, which should align with a device_name specified by job.allocation_policy.instances[0].policy.disks[i].device_name or defined by the given instance template in job.allocation_policy.instances[0].instance_template.
	DeviceName *string `pulumi:"deviceName"`
	// A Google Cloud Storage (GCS) volume.
	Gcs *GCS `pulumi:"gcs"`
	// For Google Cloud Storage (GCS), mount options are the options supported by the gcsfuse tool (https://github.com/GoogleCloudPlatform/gcsfuse). For existing persistent disks, mount options provided by the mount command (https://man7.org/linux/man-pages/man8/mount.8.html) except writing are supported. This is due to restrictions of multi-writer mode (https://cloud.google.com/compute/docs/disks/sharing-disks-between-vms). For other attached disks and Network File System (NFS), mount options are these supported by the mount command (https://man7.org/linux/man-pages/man8/mount.8.html).
	MountOptions []string `pulumi:"mountOptions"`
	// The mount path for the volume, e.g. /mnt/disks/share.
	MountPath *string `pulumi:"mountPath"`
	// A Network File System (NFS) volume. For example, a Filestore file share.
	Nfs *NFS `pulumi:"nfs"`
}

// VolumeInput is an input type that accepts VolumeArgs and VolumeOutput values.
// You can construct a concrete instance of `VolumeInput` via:
//
//	VolumeArgs{...}
type VolumeInput interface {
	pulumi.Input

	ToVolumeOutput() VolumeOutput
	ToVolumeOutputWithContext(context.Context) VolumeOutput
}

// Volume describes a volume and parameters for it to be mounted to a VM.
type VolumeArgs struct {
	// Device name of an attached disk volume, which should align with a device_name specified by job.allocation_policy.instances[0].policy.disks[i].device_name or defined by the given instance template in job.allocation_policy.instances[0].instance_template.
	DeviceName pulumi.StringPtrInput `pulumi:"deviceName"`
	// A Google Cloud Storage (GCS) volume.
	Gcs GCSPtrInput `pulumi:"gcs"`
	// For Google Cloud Storage (GCS), mount options are the options supported by the gcsfuse tool (https://github.com/GoogleCloudPlatform/gcsfuse). For existing persistent disks, mount options provided by the mount command (https://man7.org/linux/man-pages/man8/mount.8.html) except writing are supported. This is due to restrictions of multi-writer mode (https://cloud.google.com/compute/docs/disks/sharing-disks-between-vms). For other attached disks and Network File System (NFS), mount options are these supported by the mount command (https://man7.org/linux/man-pages/man8/mount.8.html).
	MountOptions pulumi.StringArrayInput `pulumi:"mountOptions"`
	// The mount path for the volume, e.g. /mnt/disks/share.
	MountPath pulumi.StringPtrInput `pulumi:"mountPath"`
	// A Network File System (NFS) volume. For example, a Filestore file share.
	Nfs NFSPtrInput `pulumi:"nfs"`
}

func (VolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Volume)(nil)).Elem()
}

func (i VolumeArgs) ToVolumeOutput() VolumeOutput {
	return i.ToVolumeOutputWithContext(context.Background())
}

func (i VolumeArgs) ToVolumeOutputWithContext(ctx context.Context) VolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeOutput)
}

// VolumeArrayInput is an input type that accepts VolumeArray and VolumeArrayOutput values.
// You can construct a concrete instance of `VolumeArrayInput` via:
//
//	VolumeArray{ VolumeArgs{...} }
type VolumeArrayInput interface {
	pulumi.Input

	ToVolumeArrayOutput() VolumeArrayOutput
	ToVolumeArrayOutputWithContext(context.Context) VolumeArrayOutput
}

type VolumeArray []VolumeInput

func (VolumeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Volume)(nil)).Elem()
}

func (i VolumeArray) ToVolumeArrayOutput() VolumeArrayOutput {
	return i.ToVolumeArrayOutputWithContext(context.Background())
}

func (i VolumeArray) ToVolumeArrayOutputWithContext(ctx context.Context) VolumeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeArrayOutput)
}

// Volume describes a volume and parameters for it to be mounted to a VM.
type VolumeOutput struct{ *pulumi.OutputState }

func (VolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Volume)(nil)).Elem()
}

func (o VolumeOutput) ToVolumeOutput() VolumeOutput {
	return o
}

func (o VolumeOutput) ToVolumeOutputWithContext(ctx context.Context) VolumeOutput {
	return o
}

// Device name of an attached disk volume, which should align with a device_name specified by job.allocation_policy.instances[0].policy.disks[i].device_name or defined by the given instance template in job.allocation_policy.instances[0].instance_template.
func (o VolumeOutput) DeviceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Volume) *string { return v.DeviceName }).(pulumi.StringPtrOutput)
}

// A Google Cloud Storage (GCS) volume.
func (o VolumeOutput) Gcs() GCSPtrOutput {
	return o.ApplyT(func(v Volume) *GCS { return v.Gcs }).(GCSPtrOutput)
}

// For Google Cloud Storage (GCS), mount options are the options supported by the gcsfuse tool (https://github.com/GoogleCloudPlatform/gcsfuse). For existing persistent disks, mount options provided by the mount command (https://man7.org/linux/man-pages/man8/mount.8.html) except writing are supported. This is due to restrictions of multi-writer mode (https://cloud.google.com/compute/docs/disks/sharing-disks-between-vms). For other attached disks and Network File System (NFS), mount options are these supported by the mount command (https://man7.org/linux/man-pages/man8/mount.8.html).
func (o VolumeOutput) MountOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Volume) []string { return v.MountOptions }).(pulumi.StringArrayOutput)
}

// The mount path for the volume, e.g. /mnt/disks/share.
func (o VolumeOutput) MountPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Volume) *string { return v.MountPath }).(pulumi.StringPtrOutput)
}

// A Network File System (NFS) volume. For example, a Filestore file share.
func (o VolumeOutput) Nfs() NFSPtrOutput {
	return o.ApplyT(func(v Volume) *NFS { return v.Nfs }).(NFSPtrOutput)
}

type VolumeArrayOutput struct{ *pulumi.OutputState }

func (VolumeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Volume)(nil)).Elem()
}

func (o VolumeArrayOutput) ToVolumeArrayOutput() VolumeArrayOutput {
	return o
}

func (o VolumeArrayOutput) ToVolumeArrayOutputWithContext(ctx context.Context) VolumeArrayOutput {
	return o
}

func (o VolumeArrayOutput) Index(i pulumi.IntInput) VolumeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Volume {
		return vs[0].([]Volume)[vs[1].(int)]
	}).(VolumeOutput)
}

// Volume describes a volume and parameters for it to be mounted to a VM.
type VolumeResponse struct {
	// Device name of an attached disk volume, which should align with a device_name specified by job.allocation_policy.instances[0].policy.disks[i].device_name or defined by the given instance template in job.allocation_policy.instances[0].instance_template.
	DeviceName string `pulumi:"deviceName"`
	// A Google Cloud Storage (GCS) volume.
	Gcs GCSResponse `pulumi:"gcs"`
	// For Google Cloud Storage (GCS), mount options are the options supported by the gcsfuse tool (https://github.com/GoogleCloudPlatform/gcsfuse). For existing persistent disks, mount options provided by the mount command (https://man7.org/linux/man-pages/man8/mount.8.html) except writing are supported. This is due to restrictions of multi-writer mode (https://cloud.google.com/compute/docs/disks/sharing-disks-between-vms). For other attached disks and Network File System (NFS), mount options are these supported by the mount command (https://man7.org/linux/man-pages/man8/mount.8.html).
	MountOptions []string `pulumi:"mountOptions"`
	// The mount path for the volume, e.g. /mnt/disks/share.
	MountPath string `pulumi:"mountPath"`
	// A Network File System (NFS) volume. For example, a Filestore file share.
	Nfs NFSResponse `pulumi:"nfs"`
}

// Volume describes a volume and parameters for it to be mounted to a VM.
type VolumeResponseOutput struct{ *pulumi.OutputState }

func (VolumeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VolumeResponse)(nil)).Elem()
}

func (o VolumeResponseOutput) ToVolumeResponseOutput() VolumeResponseOutput {
	return o
}

func (o VolumeResponseOutput) ToVolumeResponseOutputWithContext(ctx context.Context) VolumeResponseOutput {
	return o
}

// Device name of an attached disk volume, which should align with a device_name specified by job.allocation_policy.instances[0].policy.disks[i].device_name or defined by the given instance template in job.allocation_policy.instances[0].instance_template.
func (o VolumeResponseOutput) DeviceName() pulumi.StringOutput {
	return o.ApplyT(func(v VolumeResponse) string { return v.DeviceName }).(pulumi.StringOutput)
}

// A Google Cloud Storage (GCS) volume.
func (o VolumeResponseOutput) Gcs() GCSResponseOutput {
	return o.ApplyT(func(v VolumeResponse) GCSResponse { return v.Gcs }).(GCSResponseOutput)
}

// For Google Cloud Storage (GCS), mount options are the options supported by the gcsfuse tool (https://github.com/GoogleCloudPlatform/gcsfuse). For existing persistent disks, mount options provided by the mount command (https://man7.org/linux/man-pages/man8/mount.8.html) except writing are supported. This is due to restrictions of multi-writer mode (https://cloud.google.com/compute/docs/disks/sharing-disks-between-vms). For other attached disks and Network File System (NFS), mount options are these supported by the mount command (https://man7.org/linux/man-pages/man8/mount.8.html).
func (o VolumeResponseOutput) MountOptions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VolumeResponse) []string { return v.MountOptions }).(pulumi.StringArrayOutput)
}

// The mount path for the volume, e.g. /mnt/disks/share.
func (o VolumeResponseOutput) MountPath() pulumi.StringOutput {
	return o.ApplyT(func(v VolumeResponse) string { return v.MountPath }).(pulumi.StringOutput)
}

// A Network File System (NFS) volume. For example, a Filestore file share.
func (o VolumeResponseOutput) Nfs() NFSResponseOutput {
	return o.ApplyT(func(v VolumeResponse) NFSResponse { return v.Nfs }).(NFSResponseOutput)
}

type VolumeResponseArrayOutput struct{ *pulumi.OutputState }

func (VolumeResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VolumeResponse)(nil)).Elem()
}

func (o VolumeResponseArrayOutput) ToVolumeResponseArrayOutput() VolumeResponseArrayOutput {
	return o
}

func (o VolumeResponseArrayOutput) ToVolumeResponseArrayOutputWithContext(ctx context.Context) VolumeResponseArrayOutput {
	return o
}

func (o VolumeResponseArrayOutput) Index(i pulumi.IntInput) VolumeResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VolumeResponse {
		return vs[0].([]VolumeResponse)[vs[1].(int)]
	}).(VolumeResponseOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AcceleratorInput)(nil)).Elem(), AcceleratorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AcceleratorArrayInput)(nil)).Elem(), AcceleratorArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ActionConditionInput)(nil)).Elem(), ActionConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ActionConditionPtrInput)(nil)).Elem(), ActionConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AllocationPolicyInput)(nil)).Elem(), AllocationPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AllocationPolicyPtrInput)(nil)).Elem(), AllocationPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttachedDiskInput)(nil)).Elem(), AttachedDiskArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttachedDiskArrayInput)(nil)).Elem(), AttachedDiskArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BarrierInput)(nil)).Elem(), BarrierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BarrierPtrInput)(nil)).Elem(), BarrierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CloudLoggingOptionInput)(nil)).Elem(), CloudLoggingOptionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CloudLoggingOptionPtrInput)(nil)).Elem(), CloudLoggingOptionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ComputeResourceInput)(nil)).Elem(), ComputeResourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ComputeResourcePtrInput)(nil)).Elem(), ComputeResourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerInput)(nil)).Elem(), ContainerArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerPtrInput)(nil)).Elem(), ContainerArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DiskInput)(nil)).Elem(), DiskArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DiskPtrInput)(nil)).Elem(), DiskArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*EnvironmentInput)(nil)).Elem(), EnvironmentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*EnvironmentPtrInput)(nil)).Elem(), EnvironmentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*EnvironmentArrayInput)(nil)).Elem(), EnvironmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GCSInput)(nil)).Elem(), GCSArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GCSPtrInput)(nil)).Elem(), GCSArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstancePolicyInput)(nil)).Elem(), InstancePolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstancePolicyPtrInput)(nil)).Elem(), InstancePolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstancePolicyOrTemplateInput)(nil)).Elem(), InstancePolicyOrTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstancePolicyOrTemplateArrayInput)(nil)).Elem(), InstancePolicyOrTemplateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*JobNotificationInput)(nil)).Elem(), JobNotificationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*JobNotificationArrayInput)(nil)).Elem(), JobNotificationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KMSEnvMapInput)(nil)).Elem(), KMSEnvMapArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KMSEnvMapPtrInput)(nil)).Elem(), KMSEnvMapArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LifecyclePolicyInput)(nil)).Elem(), LifecyclePolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LifecyclePolicyArrayInput)(nil)).Elem(), LifecyclePolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LocationPolicyInput)(nil)).Elem(), LocationPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LocationPolicyPtrInput)(nil)).Elem(), LocationPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogsPolicyInput)(nil)).Elem(), LogsPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogsPolicyPtrInput)(nil)).Elem(), LogsPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MessageInput)(nil)).Elem(), MessageArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MessagePtrInput)(nil)).Elem(), MessageArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NFSInput)(nil)).Elem(), NFSArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NFSPtrInput)(nil)).Elem(), NFSArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkInterfaceInput)(nil)).Elem(), NetworkInterfaceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkInterfaceArrayInput)(nil)).Elem(), NetworkInterfaceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkPolicyInput)(nil)).Elem(), NetworkPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkPolicyPtrInput)(nil)).Elem(), NetworkPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PlacementPolicyInput)(nil)).Elem(), PlacementPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PlacementPolicyPtrInput)(nil)).Elem(), PlacementPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RunnableInput)(nil)).Elem(), RunnableArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RunnableArrayInput)(nil)).Elem(), RunnableArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScriptInput)(nil)).Elem(), ScriptArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScriptPtrInput)(nil)).Elem(), ScriptArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceAccountInput)(nil)).Elem(), ServiceAccountArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceAccountPtrInput)(nil)).Elem(), ServiceAccountArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TaskGroupInput)(nil)).Elem(), TaskGroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TaskGroupArrayInput)(nil)).Elem(), TaskGroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TaskSpecInput)(nil)).Elem(), TaskSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeInput)(nil)).Elem(), VolumeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeArrayInput)(nil)).Elem(), VolumeArray{})
	pulumi.RegisterOutputType(AcceleratorOutput{})
	pulumi.RegisterOutputType(AcceleratorArrayOutput{})
	pulumi.RegisterOutputType(AcceleratorResponseOutput{})
	pulumi.RegisterOutputType(AcceleratorResponseArrayOutput{})
	pulumi.RegisterOutputType(ActionConditionOutput{})
	pulumi.RegisterOutputType(ActionConditionPtrOutput{})
	pulumi.RegisterOutputType(ActionConditionResponseOutput{})
	pulumi.RegisterOutputType(AllocationPolicyOutput{})
	pulumi.RegisterOutputType(AllocationPolicyPtrOutput{})
	pulumi.RegisterOutputType(AllocationPolicyResponseOutput{})
	pulumi.RegisterOutputType(AttachedDiskOutput{})
	pulumi.RegisterOutputType(AttachedDiskArrayOutput{})
	pulumi.RegisterOutputType(AttachedDiskResponseOutput{})
	pulumi.RegisterOutputType(AttachedDiskResponseArrayOutput{})
	pulumi.RegisterOutputType(BarrierOutput{})
	pulumi.RegisterOutputType(BarrierPtrOutput{})
	pulumi.RegisterOutputType(BarrierResponseOutput{})
	pulumi.RegisterOutputType(CloudLoggingOptionOutput{})
	pulumi.RegisterOutputType(CloudLoggingOptionPtrOutput{})
	pulumi.RegisterOutputType(CloudLoggingOptionResponseOutput{})
	pulumi.RegisterOutputType(ComputeResourceOutput{})
	pulumi.RegisterOutputType(ComputeResourcePtrOutput{})
	pulumi.RegisterOutputType(ComputeResourceResponseOutput{})
	pulumi.RegisterOutputType(ContainerOutput{})
	pulumi.RegisterOutputType(ContainerPtrOutput{})
	pulumi.RegisterOutputType(ContainerResponseOutput{})
	pulumi.RegisterOutputType(DiskOutput{})
	pulumi.RegisterOutputType(DiskPtrOutput{})
	pulumi.RegisterOutputType(DiskResponseOutput{})
	pulumi.RegisterOutputType(EnvironmentOutput{})
	pulumi.RegisterOutputType(EnvironmentPtrOutput{})
	pulumi.RegisterOutputType(EnvironmentArrayOutput{})
	pulumi.RegisterOutputType(EnvironmentResponseOutput{})
	pulumi.RegisterOutputType(EnvironmentResponseArrayOutput{})
	pulumi.RegisterOutputType(GCSOutput{})
	pulumi.RegisterOutputType(GCSPtrOutput{})
	pulumi.RegisterOutputType(GCSResponseOutput{})
	pulumi.RegisterOutputType(InstancePolicyOutput{})
	pulumi.RegisterOutputType(InstancePolicyPtrOutput{})
	pulumi.RegisterOutputType(InstancePolicyOrTemplateOutput{})
	pulumi.RegisterOutputType(InstancePolicyOrTemplateArrayOutput{})
	pulumi.RegisterOutputType(InstancePolicyOrTemplateResponseOutput{})
	pulumi.RegisterOutputType(InstancePolicyOrTemplateResponseArrayOutput{})
	pulumi.RegisterOutputType(InstancePolicyResponseOutput{})
	pulumi.RegisterOutputType(InstanceStatusResponseOutput{})
	pulumi.RegisterOutputType(InstanceStatusResponseArrayOutput{})
	pulumi.RegisterOutputType(JobNotificationOutput{})
	pulumi.RegisterOutputType(JobNotificationArrayOutput{})
	pulumi.RegisterOutputType(JobNotificationResponseOutput{})
	pulumi.RegisterOutputType(JobNotificationResponseArrayOutput{})
	pulumi.RegisterOutputType(JobStatusResponseOutput{})
	pulumi.RegisterOutputType(KMSEnvMapOutput{})
	pulumi.RegisterOutputType(KMSEnvMapPtrOutput{})
	pulumi.RegisterOutputType(KMSEnvMapResponseOutput{})
	pulumi.RegisterOutputType(LifecyclePolicyOutput{})
	pulumi.RegisterOutputType(LifecyclePolicyArrayOutput{})
	pulumi.RegisterOutputType(LifecyclePolicyResponseOutput{})
	pulumi.RegisterOutputType(LifecyclePolicyResponseArrayOutput{})
	pulumi.RegisterOutputType(LocationPolicyOutput{})
	pulumi.RegisterOutputType(LocationPolicyPtrOutput{})
	pulumi.RegisterOutputType(LocationPolicyResponseOutput{})
	pulumi.RegisterOutputType(LogsPolicyOutput{})
	pulumi.RegisterOutputType(LogsPolicyPtrOutput{})
	pulumi.RegisterOutputType(LogsPolicyResponseOutput{})
	pulumi.RegisterOutputType(MessageOutput{})
	pulumi.RegisterOutputType(MessagePtrOutput{})
	pulumi.RegisterOutputType(MessageResponseOutput{})
	pulumi.RegisterOutputType(NFSOutput{})
	pulumi.RegisterOutputType(NFSPtrOutput{})
	pulumi.RegisterOutputType(NFSResponseOutput{})
	pulumi.RegisterOutputType(NetworkInterfaceOutput{})
	pulumi.RegisterOutputType(NetworkInterfaceArrayOutput{})
	pulumi.RegisterOutputType(NetworkInterfaceResponseOutput{})
	pulumi.RegisterOutputType(NetworkInterfaceResponseArrayOutput{})
	pulumi.RegisterOutputType(NetworkPolicyOutput{})
	pulumi.RegisterOutputType(NetworkPolicyPtrOutput{})
	pulumi.RegisterOutputType(NetworkPolicyResponseOutput{})
	pulumi.RegisterOutputType(PlacementPolicyOutput{})
	pulumi.RegisterOutputType(PlacementPolicyPtrOutput{})
	pulumi.RegisterOutputType(PlacementPolicyResponseOutput{})
	pulumi.RegisterOutputType(RunnableOutput{})
	pulumi.RegisterOutputType(RunnableArrayOutput{})
	pulumi.RegisterOutputType(RunnableResponseOutput{})
	pulumi.RegisterOutputType(RunnableResponseArrayOutput{})
	pulumi.RegisterOutputType(ScriptOutput{})
	pulumi.RegisterOutputType(ScriptPtrOutput{})
	pulumi.RegisterOutputType(ScriptResponseOutput{})
	pulumi.RegisterOutputType(ServiceAccountOutput{})
	pulumi.RegisterOutputType(ServiceAccountPtrOutput{})
	pulumi.RegisterOutputType(ServiceAccountResponseOutput{})
	pulumi.RegisterOutputType(StatusEventResponseOutput{})
	pulumi.RegisterOutputType(StatusEventResponseArrayOutput{})
	pulumi.RegisterOutputType(TaskExecutionResponseOutput{})
	pulumi.RegisterOutputType(TaskGroupOutput{})
	pulumi.RegisterOutputType(TaskGroupArrayOutput{})
	pulumi.RegisterOutputType(TaskGroupResponseOutput{})
	pulumi.RegisterOutputType(TaskGroupResponseArrayOutput{})
	pulumi.RegisterOutputType(TaskGroupStatusResponseOutput{})
	pulumi.RegisterOutputType(TaskGroupStatusResponseMapOutput{})
	pulumi.RegisterOutputType(TaskSpecOutput{})
	pulumi.RegisterOutputType(TaskSpecResponseOutput{})
	pulumi.RegisterOutputType(VolumeOutput{})
	pulumi.RegisterOutputType(VolumeArrayOutput{})
	pulumi.RegisterOutputType(VolumeResponseOutput{})
	pulumi.RegisterOutputType(VolumeResponseArrayOutput{})
}

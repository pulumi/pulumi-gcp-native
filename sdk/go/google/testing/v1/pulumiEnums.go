// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The option of whether running each test within its own invocation of instrumentation with Android Test Orchestrator or not. ** Orchestrator is only compatible with AndroidJUnitRunner version 1.0 or higher! ** Orchestrator offers the following benefits: - No shared state - Crashes are isolated - Logs are scoped per test See for more information about Android Test Orchestrator. If not set, the test will be run without the orchestrator.
type AndroidInstrumentationTestOrchestratorOption pulumi.String

const (
	// Default value: the server will choose the mode. Currently implies that the test will run without the orchestrator. In the future, all instrumentation tests will be run with the orchestrator. Using the orchestrator is highly encouraged because of all the benefits it offers.
	AndroidInstrumentationTestOrchestratorOptionOrchestratorOptionUnspecified = AndroidInstrumentationTestOrchestratorOption("ORCHESTRATOR_OPTION_UNSPECIFIED")
	// Run test using orchestrator. ** Only compatible with AndroidJUnitRunner version 1.0 or higher! ** Recommended.
	AndroidInstrumentationTestOrchestratorOptionUseOrchestrator = AndroidInstrumentationTestOrchestratorOption("USE_ORCHESTRATOR")
	// Run test without using orchestrator.
	AndroidInstrumentationTestOrchestratorOptionDoNotUseOrchestrator = AndroidInstrumentationTestOrchestratorOption("DO_NOT_USE_ORCHESTRATOR")
)

func (AndroidInstrumentationTestOrchestratorOption) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AndroidInstrumentationTestOrchestratorOption) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AndroidInstrumentationTestOrchestratorOption) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AndroidInstrumentationTestOrchestratorOption) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AndroidInstrumentationTestOrchestratorOption) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Required. The type of action that Robo should perform on the specified element.
type RoboDirectiveActionType pulumi.String

const (
	// DO NOT USE. For proto versioning only.
	RoboDirectiveActionTypeActionTypeUnspecified = RoboDirectiveActionType("ACTION_TYPE_UNSPECIFIED")
	// Direct Robo to click on the specified element. No-op if specified element is not clickable.
	RoboDirectiveActionTypeSingleClick = RoboDirectiveActionType("SINGLE_CLICK")
	// Direct Robo to enter text on the specified element. No-op if specified element is not enabled or does not allow text entry.
	RoboDirectiveActionTypeEnterText = RoboDirectiveActionType("ENTER_TEXT")
	// Direct Robo to ignore interactions with a specific element.
	RoboDirectiveActionTypeIgnore = RoboDirectiveActionType("IGNORE")
)

func (RoboDirectiveActionType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RoboDirectiveActionType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RoboDirectiveActionType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RoboDirectiveActionType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RoboDirectiveActionType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Output only. Indicates the current progress of the test execution (e.g., FINISHED).
type TestExecutionState pulumi.String

const (
	// Do not use. For proto versioning only.
	TestExecutionStateTestStateUnspecified = TestExecutionState("TEST_STATE_UNSPECIFIED")
	// The execution or matrix is being validated.
	TestExecutionStateValidating = TestExecutionState("VALIDATING")
	// The execution or matrix is waiting for resources to become available.
	TestExecutionStatePending = TestExecutionState("PENDING")
	// The execution is currently being processed. Can only be set on an execution.
	TestExecutionStateRunning = TestExecutionState("RUNNING")
	// The execution or matrix has terminated normally. On a matrix this means that the matrix level processing completed normally, but individual executions may be in an ERROR state.
	TestExecutionStateFinished = TestExecutionState("FINISHED")
	// The execution or matrix has stopped because it encountered an infrastructure failure.
	TestExecutionStateError = TestExecutionState("ERROR")
	// The execution was not run because it corresponds to a unsupported environment. Can only be set on an execution.
	TestExecutionStateUnsupportedEnvironment = TestExecutionState("UNSUPPORTED_ENVIRONMENT")
	// The execution was not run because the provided inputs are incompatible with the requested environment. Example: requested AndroidVersion is lower than APK's minSdkVersion Can only be set on an execution.
	TestExecutionStateIncompatibleEnvironment = TestExecutionState("INCOMPATIBLE_ENVIRONMENT")
	// The execution was not run because the provided inputs are incompatible with the requested architecture. Example: requested device does not support running the native code in the supplied APK Can only be set on an execution.
	TestExecutionStateIncompatibleArchitecture = TestExecutionState("INCOMPATIBLE_ARCHITECTURE")
	// The user cancelled the execution. Can only be set on an execution.
	TestExecutionStateCancelled = TestExecutionState("CANCELLED")
	// The execution or matrix was not run because the provided inputs are not valid. Examples: input file is not of the expected type, is malformed/corrupt, or was flagged as malware
	TestExecutionStateInvalid = TestExecutionState("INVALID")
)

func (TestExecutionState) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e TestExecutionState) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e TestExecutionState) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e TestExecutionState) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e TestExecutionState) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Output only. Describes why the matrix is considered invalid. Only useful for matrices in the INVALID state.
type TestMatrixInvalidMatrixDetails pulumi.String

const (
	// Do not use. For proto versioning only.
	TestMatrixInvalidMatrixDetailsInvalidMatrixDetailsUnspecified = TestMatrixInvalidMatrixDetails("INVALID_MATRIX_DETAILS_UNSPECIFIED")
	// The matrix is INVALID, but there are no further details available.
	TestMatrixInvalidMatrixDetailsDetailsUnavailable = TestMatrixInvalidMatrixDetails("DETAILS_UNAVAILABLE")
	// The input app APK could not be parsed.
	TestMatrixInvalidMatrixDetailsMalformedApk = TestMatrixInvalidMatrixDetails("MALFORMED_APK")
	// The input test APK could not be parsed.
	TestMatrixInvalidMatrixDetailsMalformedTestApk = TestMatrixInvalidMatrixDetails("MALFORMED_TEST_APK")
	// The AndroidManifest.xml could not be found.
	TestMatrixInvalidMatrixDetailsNoManifest = TestMatrixInvalidMatrixDetails("NO_MANIFEST")
	// The APK manifest does not declare a package name.
	TestMatrixInvalidMatrixDetailsNoPackageName = TestMatrixInvalidMatrixDetails("NO_PACKAGE_NAME")
	// The APK application ID (aka package name) is invalid. See also https://developer.android.com/studio/build/application-id
	TestMatrixInvalidMatrixDetailsInvalidPackageName = TestMatrixInvalidMatrixDetails("INVALID_PACKAGE_NAME")
	// The test package and app package are the same.
	TestMatrixInvalidMatrixDetailsTestSameAsApp = TestMatrixInvalidMatrixDetails("TEST_SAME_AS_APP")
	// The test apk does not declare an instrumentation.
	TestMatrixInvalidMatrixDetailsNoInstrumentation = TestMatrixInvalidMatrixDetails("NO_INSTRUMENTATION")
	// The input app apk does not have a signature.
	TestMatrixInvalidMatrixDetailsNoSignature = TestMatrixInvalidMatrixDetails("NO_SIGNATURE")
	// The test runner class specified by user or in the test APK's manifest file is not compatible with Android Test Orchestrator. Orchestrator is only compatible with AndroidJUnitRunner version 1.0 or higher. Orchestrator can be disabled by using DO_NOT_USE_ORCHESTRATOR OrchestratorOption.
	TestMatrixInvalidMatrixDetailsInstrumentationOrchestratorIncompatible = TestMatrixInvalidMatrixDetails("INSTRUMENTATION_ORCHESTRATOR_INCOMPATIBLE")
	// The test APK does not contain the test runner class specified by user or in the manifest file. This can be caused by either of the following reasons: - the user provided a runner class name that's incorrect, or - the test runner isn't built into the test APK (might be in the app APK instead).
	TestMatrixInvalidMatrixDetailsNoTestRunnerClass = TestMatrixInvalidMatrixDetails("NO_TEST_RUNNER_CLASS")
	// A main launcher activity could not be found.
	TestMatrixInvalidMatrixDetailsNoLauncherActivity = TestMatrixInvalidMatrixDetails("NO_LAUNCHER_ACTIVITY")
	// The app declares one or more permissions that are not allowed.
	TestMatrixInvalidMatrixDetailsForbiddenPermissions = TestMatrixInvalidMatrixDetails("FORBIDDEN_PERMISSIONS")
	// There is a conflict in the provided robo_directives.
	TestMatrixInvalidMatrixDetailsInvalidRoboDirectives = TestMatrixInvalidMatrixDetails("INVALID_ROBO_DIRECTIVES")
	// There is at least one invalid resource name in the provided robo directives
	TestMatrixInvalidMatrixDetailsInvalidResourceName = TestMatrixInvalidMatrixDetails("INVALID_RESOURCE_NAME")
	// Invalid definition of action in the robo directives (e.g. a click or ignore action includes an input text field)
	TestMatrixInvalidMatrixDetailsInvalidDirectiveAction = TestMatrixInvalidMatrixDetails("INVALID_DIRECTIVE_ACTION")
	// There is no test loop intent filter, or the one that is given is not formatted correctly.
	TestMatrixInvalidMatrixDetailsTestLoopIntentFilterNotFound = TestMatrixInvalidMatrixDetails("TEST_LOOP_INTENT_FILTER_NOT_FOUND")
	// The request contains a scenario label that was not declared in the manifest.
	TestMatrixInvalidMatrixDetailsScenarioLabelNotDeclared = TestMatrixInvalidMatrixDetails("SCENARIO_LABEL_NOT_DECLARED")
	// There was an error when parsing a label's value.
	TestMatrixInvalidMatrixDetailsScenarioLabelMalformed = TestMatrixInvalidMatrixDetails("SCENARIO_LABEL_MALFORMED")
	// The request contains a scenario number that was not declared in the manifest.
	TestMatrixInvalidMatrixDetailsScenarioNotDeclared = TestMatrixInvalidMatrixDetails("SCENARIO_NOT_DECLARED")
	// Device administrator applications are not allowed.
	TestMatrixInvalidMatrixDetailsDeviceAdminReceiver = TestMatrixInvalidMatrixDetails("DEVICE_ADMIN_RECEIVER")
	// The zipped XCTest was malformed. The zip did not contain a single .xctestrun file and the contents of the DerivedData/Build/Products directory.
	TestMatrixInvalidMatrixDetailsMalformedXcTestZip = TestMatrixInvalidMatrixDetails("MALFORMED_XC_TEST_ZIP")
	// The zipped XCTest was built for the iOS simulator rather than for a physical device.
	TestMatrixInvalidMatrixDetailsBuiltForIosSimulator = TestMatrixInvalidMatrixDetails("BUILT_FOR_IOS_SIMULATOR")
	// The .xctestrun file did not specify any test targets.
	TestMatrixInvalidMatrixDetailsNoTestsInXcTestZip = TestMatrixInvalidMatrixDetails("NO_TESTS_IN_XC_TEST_ZIP")
	// One or more of the test targets defined in the .xctestrun file specifies "UseDestinationArtifacts", which is disallowed.
	TestMatrixInvalidMatrixDetailsUseDestinationArtifacts = TestMatrixInvalidMatrixDetails("USE_DESTINATION_ARTIFACTS")
	// XC tests which run on physical devices must have "IsAppHostedTestBundle" == "true" in the xctestrun file.
	TestMatrixInvalidMatrixDetailsTestNotAppHosted = TestMatrixInvalidMatrixDetails("TEST_NOT_APP_HOSTED")
	// An Info.plist file in the XCTest zip could not be parsed.
	TestMatrixInvalidMatrixDetailsPlistCannotBeParsed = TestMatrixInvalidMatrixDetails("PLIST_CANNOT_BE_PARSED")
	// The APK is marked as "testOnly". Deprecated and not currently used.
	TestMatrixInvalidMatrixDetailsTestOnlyApk = TestMatrixInvalidMatrixDetails("TEST_ONLY_APK")
	// The input IPA could not be parsed.
	TestMatrixInvalidMatrixDetailsMalformedIpa = TestMatrixInvalidMatrixDetails("MALFORMED_IPA")
	// The application doesn't register the game loop URL scheme.
	TestMatrixInvalidMatrixDetailsMissingUrlScheme = TestMatrixInvalidMatrixDetails("MISSING_URL_SCHEME")
	// The iOS application bundle (.app) couldn't be processed.
	TestMatrixInvalidMatrixDetailsMalformedAppBundle = TestMatrixInvalidMatrixDetails("MALFORMED_APP_BUNDLE")
	// APK contains no code. See also https://developer.android.com/guide/topics/manifest/application-element.html#code
	TestMatrixInvalidMatrixDetailsNoCodeApk = TestMatrixInvalidMatrixDetails("NO_CODE_APK")
	// Either the provided input APK path was malformed, the APK file does not exist, or the user does not have permission to access the APK file.
	TestMatrixInvalidMatrixDetailsInvalidInputApk = TestMatrixInvalidMatrixDetails("INVALID_INPUT_APK")
	// APK is built for a preview SDK which is unsupported
	TestMatrixInvalidMatrixDetailsInvalidApkPreviewSdk = TestMatrixInvalidMatrixDetails("INVALID_APK_PREVIEW_SDK")
)

func (TestMatrixInvalidMatrixDetails) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e TestMatrixInvalidMatrixDetails) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e TestMatrixInvalidMatrixDetails) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e TestMatrixInvalidMatrixDetails) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e TestMatrixInvalidMatrixDetails) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Output Only. The overall outcome of the test. Only set when the test matrix state is FINISHED.
type TestMatrixOutcomeSummary pulumi.String

const (
	// Do not use. For proto versioning only.
	TestMatrixOutcomeSummaryOutcomeSummaryUnspecified = TestMatrixOutcomeSummary("OUTCOME_SUMMARY_UNSPECIFIED")
	// The test matrix run was successful, for instance: - All the test cases passed. - Robo did not detect a crash of the application under test.
	TestMatrixOutcomeSummarySuccess = TestMatrixOutcomeSummary("SUCCESS")
	// A run failed, for instance: - One or more test case failed. - A test timed out. - The application under test crashed.
	TestMatrixOutcomeSummaryFailure = TestMatrixOutcomeSummary("FAILURE")
	// Something unexpected happened. The run should still be considered unsuccessful but this is likely a transient problem and re-running the test might be successful.
	TestMatrixOutcomeSummaryInconclusive = TestMatrixOutcomeSummary("INCONCLUSIVE")
	// All tests were skipped, for instance: - All device configurations were incompatible.
	TestMatrixOutcomeSummarySkipped = TestMatrixOutcomeSummary("SKIPPED")
)

func (TestMatrixOutcomeSummary) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e TestMatrixOutcomeSummary) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e TestMatrixOutcomeSummary) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e TestMatrixOutcomeSummary) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e TestMatrixOutcomeSummary) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Output only. Indicates the current progress of the test matrix.
type TestMatrixStateEnum pulumi.String

const (
	// Do not use. For proto versioning only.
	TestMatrixStateEnumTestStateUnspecified = TestMatrixStateEnum("TEST_STATE_UNSPECIFIED")
	// The execution or matrix is being validated.
	TestMatrixStateEnumValidating = TestMatrixStateEnum("VALIDATING")
	// The execution or matrix is waiting for resources to become available.
	TestMatrixStateEnumPending = TestMatrixStateEnum("PENDING")
	// The execution is currently being processed. Can only be set on an execution.
	TestMatrixStateEnumRunning = TestMatrixStateEnum("RUNNING")
	// The execution or matrix has terminated normally. On a matrix this means that the matrix level processing completed normally, but individual executions may be in an ERROR state.
	TestMatrixStateEnumFinished = TestMatrixStateEnum("FINISHED")
	// The execution or matrix has stopped because it encountered an infrastructure failure.
	TestMatrixStateEnumError = TestMatrixStateEnum("ERROR")
	// The execution was not run because it corresponds to a unsupported environment. Can only be set on an execution.
	TestMatrixStateEnumUnsupportedEnvironment = TestMatrixStateEnum("UNSUPPORTED_ENVIRONMENT")
	// The execution was not run because the provided inputs are incompatible with the requested environment. Example: requested AndroidVersion is lower than APK's minSdkVersion Can only be set on an execution.
	TestMatrixStateEnumIncompatibleEnvironment = TestMatrixStateEnum("INCOMPATIBLE_ENVIRONMENT")
	// The execution was not run because the provided inputs are incompatible with the requested architecture. Example: requested device does not support running the native code in the supplied APK Can only be set on an execution.
	TestMatrixStateEnumIncompatibleArchitecture = TestMatrixStateEnum("INCOMPATIBLE_ARCHITECTURE")
	// The user cancelled the execution. Can only be set on an execution.
	TestMatrixStateEnumCancelled = TestMatrixStateEnum("CANCELLED")
	// The execution or matrix was not run because the provided inputs are not valid. Examples: input file is not of the expected type, is malformed/corrupt, or was flagged as malware
	TestMatrixStateEnumInvalid = TestMatrixStateEnum("INVALID")
)

func (TestMatrixStateEnum) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e TestMatrixStateEnum) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e TestMatrixStateEnum) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e TestMatrixStateEnum) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e TestMatrixStateEnum) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

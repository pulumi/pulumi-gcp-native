// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Information for connecting over HTTP(s).
type Addressable struct {
	// Deprecated - use url instead.
	Hostname *string `pulumi:"hostname"`
	Url      *string `pulumi:"url"`
}

// AddressableInput is an input type that accepts AddressableArgs and AddressableOutput values.
// You can construct a concrete instance of `AddressableInput` via:
//
//          AddressableArgs{...}
type AddressableInput interface {
	pulumi.Input

	ToAddressableOutput() AddressableOutput
	ToAddressableOutputWithContext(context.Context) AddressableOutput
}

// Information for connecting over HTTP(s).
type AddressableArgs struct {
	// Deprecated - use url instead.
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	Url      pulumi.StringPtrInput `pulumi:"url"`
}

func (AddressableArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Addressable)(nil)).Elem()
}

func (i AddressableArgs) ToAddressableOutput() AddressableOutput {
	return i.ToAddressableOutputWithContext(context.Background())
}

func (i AddressableArgs) ToAddressableOutputWithContext(ctx context.Context) AddressableOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AddressableOutput)
}

func (i AddressableArgs) ToAddressablePtrOutput() AddressablePtrOutput {
	return i.ToAddressablePtrOutputWithContext(context.Background())
}

func (i AddressableArgs) ToAddressablePtrOutputWithContext(ctx context.Context) AddressablePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AddressableOutput).ToAddressablePtrOutputWithContext(ctx)
}

// AddressablePtrInput is an input type that accepts AddressableArgs, AddressablePtr and AddressablePtrOutput values.
// You can construct a concrete instance of `AddressablePtrInput` via:
//
//          AddressableArgs{...}
//
//  or:
//
//          nil
type AddressablePtrInput interface {
	pulumi.Input

	ToAddressablePtrOutput() AddressablePtrOutput
	ToAddressablePtrOutputWithContext(context.Context) AddressablePtrOutput
}

type addressablePtrType AddressableArgs

func AddressablePtr(v *AddressableArgs) AddressablePtrInput {
	return (*addressablePtrType)(v)
}

func (*addressablePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Addressable)(nil)).Elem()
}

func (i *addressablePtrType) ToAddressablePtrOutput() AddressablePtrOutput {
	return i.ToAddressablePtrOutputWithContext(context.Background())
}

func (i *addressablePtrType) ToAddressablePtrOutputWithContext(ctx context.Context) AddressablePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AddressablePtrOutput)
}

// Information for connecting over HTTP(s).
type AddressableOutput struct{ *pulumi.OutputState }

func (AddressableOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Addressable)(nil)).Elem()
}

func (o AddressableOutput) ToAddressableOutput() AddressableOutput {
	return o
}

func (o AddressableOutput) ToAddressableOutputWithContext(ctx context.Context) AddressableOutput {
	return o
}

func (o AddressableOutput) ToAddressablePtrOutput() AddressablePtrOutput {
	return o.ToAddressablePtrOutputWithContext(context.Background())
}

func (o AddressableOutput) ToAddressablePtrOutputWithContext(ctx context.Context) AddressablePtrOutput {
	return o.ApplyT(func(v Addressable) *Addressable {
		return &v
	}).(AddressablePtrOutput)
}

// Deprecated - use url instead.
func (o AddressableOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Addressable) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o AddressableOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Addressable) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type AddressablePtrOutput struct{ *pulumi.OutputState }

func (AddressablePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Addressable)(nil)).Elem()
}

func (o AddressablePtrOutput) ToAddressablePtrOutput() AddressablePtrOutput {
	return o
}

func (o AddressablePtrOutput) ToAddressablePtrOutputWithContext(ctx context.Context) AddressablePtrOutput {
	return o
}

func (o AddressablePtrOutput) Elem() AddressableOutput {
	return o.ApplyT(func(v *Addressable) Addressable { return *v }).(AddressableOutput)
}

// Deprecated - use url instead.
func (o AddressablePtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Addressable) *string {
		if v == nil {
			return nil
		}
		return v.Hostname
	}).(pulumi.StringPtrOutput)
}

func (o AddressablePtrOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Addressable) *string {
		if v == nil {
			return nil
		}
		return v.Url
	}).(pulumi.StringPtrOutput)
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts jose@example.com from DATA_READ logging, and aliya@example.com from DATA_WRITE logging.
type AuditConfig struct {
	// The configuration for logging of each type of permission.
	AuditLogConfigs []AuditLogConfig `pulumi:"auditLogConfigs"`
	// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
	Service *string `pulumi:"service"`
}

// AuditConfigInput is an input type that accepts AuditConfigArgs and AuditConfigOutput values.
// You can construct a concrete instance of `AuditConfigInput` via:
//
//          AuditConfigArgs{...}
type AuditConfigInput interface {
	pulumi.Input

	ToAuditConfigOutput() AuditConfigOutput
	ToAuditConfigOutputWithContext(context.Context) AuditConfigOutput
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts jose@example.com from DATA_READ logging, and aliya@example.com from DATA_WRITE logging.
type AuditConfigArgs struct {
	// The configuration for logging of each type of permission.
	AuditLogConfigs AuditLogConfigArrayInput `pulumi:"auditLogConfigs"`
	// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
	Service pulumi.StringPtrInput `pulumi:"service"`
}

func (AuditConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditConfig)(nil)).Elem()
}

func (i AuditConfigArgs) ToAuditConfigOutput() AuditConfigOutput {
	return i.ToAuditConfigOutputWithContext(context.Background())
}

func (i AuditConfigArgs) ToAuditConfigOutputWithContext(ctx context.Context) AuditConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditConfigOutput)
}

// AuditConfigArrayInput is an input type that accepts AuditConfigArray and AuditConfigArrayOutput values.
// You can construct a concrete instance of `AuditConfigArrayInput` via:
//
//          AuditConfigArray{ AuditConfigArgs{...} }
type AuditConfigArrayInput interface {
	pulumi.Input

	ToAuditConfigArrayOutput() AuditConfigArrayOutput
	ToAuditConfigArrayOutputWithContext(context.Context) AuditConfigArrayOutput
}

type AuditConfigArray []AuditConfigInput

func (AuditConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditConfig)(nil)).Elem()
}

func (i AuditConfigArray) ToAuditConfigArrayOutput() AuditConfigArrayOutput {
	return i.ToAuditConfigArrayOutputWithContext(context.Background())
}

func (i AuditConfigArray) ToAuditConfigArrayOutputWithContext(ctx context.Context) AuditConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditConfigArrayOutput)
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts jose@example.com from DATA_READ logging, and aliya@example.com from DATA_WRITE logging.
type AuditConfigOutput struct{ *pulumi.OutputState }

func (AuditConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditConfig)(nil)).Elem()
}

func (o AuditConfigOutput) ToAuditConfigOutput() AuditConfigOutput {
	return o
}

func (o AuditConfigOutput) ToAuditConfigOutputWithContext(ctx context.Context) AuditConfigOutput {
	return o
}

// The configuration for logging of each type of permission.
func (o AuditConfigOutput) AuditLogConfigs() AuditLogConfigArrayOutput {
	return o.ApplyT(func(v AuditConfig) []AuditLogConfig { return v.AuditLogConfigs }).(AuditLogConfigArrayOutput)
}

// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
func (o AuditConfigOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AuditConfig) *string { return v.Service }).(pulumi.StringPtrOutput)
}

type AuditConfigArrayOutput struct{ *pulumi.OutputState }

func (AuditConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditConfig)(nil)).Elem()
}

func (o AuditConfigArrayOutput) ToAuditConfigArrayOutput() AuditConfigArrayOutput {
	return o
}

func (o AuditConfigArrayOutput) ToAuditConfigArrayOutputWithContext(ctx context.Context) AuditConfigArrayOutput {
	return o
}

func (o AuditConfigArrayOutput) Index(i pulumi.IntInput) AuditConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AuditConfig {
		return vs[0].([]AuditConfig)[vs[1].(int)]
	}).(AuditConfigOutput)
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfig struct {
	// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
	ExemptedMembers []string `pulumi:"exemptedMembers"`
	// The log type that this config enables.
	LogType *string `pulumi:"logType"`
}

// AuditLogConfigInput is an input type that accepts AuditLogConfigArgs and AuditLogConfigOutput values.
// You can construct a concrete instance of `AuditLogConfigInput` via:
//
//          AuditLogConfigArgs{...}
type AuditLogConfigInput interface {
	pulumi.Input

	ToAuditLogConfigOutput() AuditLogConfigOutput
	ToAuditLogConfigOutputWithContext(context.Context) AuditLogConfigOutput
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfigArgs struct {
	// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
	ExemptedMembers pulumi.StringArrayInput `pulumi:"exemptedMembers"`
	// The log type that this config enables.
	LogType pulumi.StringPtrInput `pulumi:"logType"`
}

func (AuditLogConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditLogConfig)(nil)).Elem()
}

func (i AuditLogConfigArgs) ToAuditLogConfigOutput() AuditLogConfigOutput {
	return i.ToAuditLogConfigOutputWithContext(context.Background())
}

func (i AuditLogConfigArgs) ToAuditLogConfigOutputWithContext(ctx context.Context) AuditLogConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditLogConfigOutput)
}

// AuditLogConfigArrayInput is an input type that accepts AuditLogConfigArray and AuditLogConfigArrayOutput values.
// You can construct a concrete instance of `AuditLogConfigArrayInput` via:
//
//          AuditLogConfigArray{ AuditLogConfigArgs{...} }
type AuditLogConfigArrayInput interface {
	pulumi.Input

	ToAuditLogConfigArrayOutput() AuditLogConfigArrayOutput
	ToAuditLogConfigArrayOutputWithContext(context.Context) AuditLogConfigArrayOutput
}

type AuditLogConfigArray []AuditLogConfigInput

func (AuditLogConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditLogConfig)(nil)).Elem()
}

func (i AuditLogConfigArray) ToAuditLogConfigArrayOutput() AuditLogConfigArrayOutput {
	return i.ToAuditLogConfigArrayOutputWithContext(context.Background())
}

func (i AuditLogConfigArray) ToAuditLogConfigArrayOutputWithContext(ctx context.Context) AuditLogConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditLogConfigArrayOutput)
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfigOutput struct{ *pulumi.OutputState }

func (AuditLogConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditLogConfig)(nil)).Elem()
}

func (o AuditLogConfigOutput) ToAuditLogConfigOutput() AuditLogConfigOutput {
	return o
}

func (o AuditLogConfigOutput) ToAuditLogConfigOutputWithContext(ctx context.Context) AuditLogConfigOutput {
	return o
}

// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
func (o AuditLogConfigOutput) ExemptedMembers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AuditLogConfig) []string { return v.ExemptedMembers }).(pulumi.StringArrayOutput)
}

// The log type that this config enables.
func (o AuditLogConfigOutput) LogType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AuditLogConfig) *string { return v.LogType }).(pulumi.StringPtrOutput)
}

type AuditLogConfigArrayOutput struct{ *pulumi.OutputState }

func (AuditLogConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditLogConfig)(nil)).Elem()
}

func (o AuditLogConfigArrayOutput) ToAuditLogConfigArrayOutput() AuditLogConfigArrayOutput {
	return o
}

func (o AuditLogConfigArrayOutput) ToAuditLogConfigArrayOutputWithContext(ctx context.Context) AuditLogConfigArrayOutput {
	return o
}

func (o AuditLogConfigArrayOutput) Index(i pulumi.IntInput) AuditLogConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AuditLogConfig {
		return vs[0].([]AuditLogConfig)[vs[1].(int)]
	}).(AuditLogConfigOutput)
}

// Associates `members` with a `role`.
type Binding struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition *Expr `pulumi:"condition"`
	// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
	Members []string `pulumi:"members"`
	// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role *string `pulumi:"role"`
}

// BindingInput is an input type that accepts BindingArgs and BindingOutput values.
// You can construct a concrete instance of `BindingInput` via:
//
//          BindingArgs{...}
type BindingInput interface {
	pulumi.Input

	ToBindingOutput() BindingOutput
	ToBindingOutputWithContext(context.Context) BindingOutput
}

// Associates `members` with a `role`.
type BindingArgs struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition ExprPtrInput `pulumi:"condition"`
	// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
	Members pulumi.StringArrayInput `pulumi:"members"`
	// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role pulumi.StringPtrInput `pulumi:"role"`
}

func (BindingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Binding)(nil)).Elem()
}

func (i BindingArgs) ToBindingOutput() BindingOutput {
	return i.ToBindingOutputWithContext(context.Background())
}

func (i BindingArgs) ToBindingOutputWithContext(ctx context.Context) BindingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingOutput)
}

// BindingArrayInput is an input type that accepts BindingArray and BindingArrayOutput values.
// You can construct a concrete instance of `BindingArrayInput` via:
//
//          BindingArray{ BindingArgs{...} }
type BindingArrayInput interface {
	pulumi.Input

	ToBindingArrayOutput() BindingArrayOutput
	ToBindingArrayOutputWithContext(context.Context) BindingArrayOutput
}

type BindingArray []BindingInput

func (BindingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Binding)(nil)).Elem()
}

func (i BindingArray) ToBindingArrayOutput() BindingArrayOutput {
	return i.ToBindingArrayOutputWithContext(context.Background())
}

func (i BindingArray) ToBindingArrayOutputWithContext(ctx context.Context) BindingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingArrayOutput)
}

// Associates `members` with a `role`.
type BindingOutput struct{ *pulumi.OutputState }

func (BindingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Binding)(nil)).Elem()
}

func (o BindingOutput) ToBindingOutput() BindingOutput {
	return o
}

func (o BindingOutput) ToBindingOutputWithContext(ctx context.Context) BindingOutput {
	return o
}

// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o BindingOutput) Condition() ExprPtrOutput {
	return o.ApplyT(func(v Binding) *Expr { return v.Condition }).(ExprPtrOutput)
}

// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
func (o BindingOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Binding) []string { return v.Members }).(pulumi.StringArrayOutput)
}

// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
func (o BindingOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Binding) *string { return v.Role }).(pulumi.StringPtrOutput)
}

type BindingArrayOutput struct{ *pulumi.OutputState }

func (BindingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Binding)(nil)).Elem()
}

func (o BindingArrayOutput) ToBindingArrayOutput() BindingArrayOutput {
	return o
}

func (o BindingArrayOutput) ToBindingArrayOutputWithContext(ctx context.Context) BindingArrayOutput {
	return o
}

func (o BindingArrayOutput) Index(i pulumi.IntInput) BindingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Binding {
		return vs[0].([]Binding)[vs[1].(int)]
	}).(BindingOutput)
}

// Adds and removes POSIX capabilities from running containers.
type Capabilities struct {
	// Added capabilities +optional
	Add []string `pulumi:"add"`
	// Removed capabilities +optional
	Drop []string `pulumi:"drop"`
}

// CapabilitiesInput is an input type that accepts CapabilitiesArgs and CapabilitiesOutput values.
// You can construct a concrete instance of `CapabilitiesInput` via:
//
//          CapabilitiesArgs{...}
type CapabilitiesInput interface {
	pulumi.Input

	ToCapabilitiesOutput() CapabilitiesOutput
	ToCapabilitiesOutputWithContext(context.Context) CapabilitiesOutput
}

// Adds and removes POSIX capabilities from running containers.
type CapabilitiesArgs struct {
	// Added capabilities +optional
	Add pulumi.StringArrayInput `pulumi:"add"`
	// Removed capabilities +optional
	Drop pulumi.StringArrayInput `pulumi:"drop"`
}

func (CapabilitiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Capabilities)(nil)).Elem()
}

func (i CapabilitiesArgs) ToCapabilitiesOutput() CapabilitiesOutput {
	return i.ToCapabilitiesOutputWithContext(context.Background())
}

func (i CapabilitiesArgs) ToCapabilitiesOutputWithContext(ctx context.Context) CapabilitiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CapabilitiesOutput)
}

func (i CapabilitiesArgs) ToCapabilitiesPtrOutput() CapabilitiesPtrOutput {
	return i.ToCapabilitiesPtrOutputWithContext(context.Background())
}

func (i CapabilitiesArgs) ToCapabilitiesPtrOutputWithContext(ctx context.Context) CapabilitiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CapabilitiesOutput).ToCapabilitiesPtrOutputWithContext(ctx)
}

// CapabilitiesPtrInput is an input type that accepts CapabilitiesArgs, CapabilitiesPtr and CapabilitiesPtrOutput values.
// You can construct a concrete instance of `CapabilitiesPtrInput` via:
//
//          CapabilitiesArgs{...}
//
//  or:
//
//          nil
type CapabilitiesPtrInput interface {
	pulumi.Input

	ToCapabilitiesPtrOutput() CapabilitiesPtrOutput
	ToCapabilitiesPtrOutputWithContext(context.Context) CapabilitiesPtrOutput
}

type capabilitiesPtrType CapabilitiesArgs

func CapabilitiesPtr(v *CapabilitiesArgs) CapabilitiesPtrInput {
	return (*capabilitiesPtrType)(v)
}

func (*capabilitiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Capabilities)(nil)).Elem()
}

func (i *capabilitiesPtrType) ToCapabilitiesPtrOutput() CapabilitiesPtrOutput {
	return i.ToCapabilitiesPtrOutputWithContext(context.Background())
}

func (i *capabilitiesPtrType) ToCapabilitiesPtrOutputWithContext(ctx context.Context) CapabilitiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CapabilitiesPtrOutput)
}

// Adds and removes POSIX capabilities from running containers.
type CapabilitiesOutput struct{ *pulumi.OutputState }

func (CapabilitiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Capabilities)(nil)).Elem()
}

func (o CapabilitiesOutput) ToCapabilitiesOutput() CapabilitiesOutput {
	return o
}

func (o CapabilitiesOutput) ToCapabilitiesOutputWithContext(ctx context.Context) CapabilitiesOutput {
	return o
}

func (o CapabilitiesOutput) ToCapabilitiesPtrOutput() CapabilitiesPtrOutput {
	return o.ToCapabilitiesPtrOutputWithContext(context.Background())
}

func (o CapabilitiesOutput) ToCapabilitiesPtrOutputWithContext(ctx context.Context) CapabilitiesPtrOutput {
	return o.ApplyT(func(v Capabilities) *Capabilities {
		return &v
	}).(CapabilitiesPtrOutput)
}

// Added capabilities +optional
func (o CapabilitiesOutput) Add() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Capabilities) []string { return v.Add }).(pulumi.StringArrayOutput)
}

// Removed capabilities +optional
func (o CapabilitiesOutput) Drop() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Capabilities) []string { return v.Drop }).(pulumi.StringArrayOutput)
}

type CapabilitiesPtrOutput struct{ *pulumi.OutputState }

func (CapabilitiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Capabilities)(nil)).Elem()
}

func (o CapabilitiesPtrOutput) ToCapabilitiesPtrOutput() CapabilitiesPtrOutput {
	return o
}

func (o CapabilitiesPtrOutput) ToCapabilitiesPtrOutputWithContext(ctx context.Context) CapabilitiesPtrOutput {
	return o
}

func (o CapabilitiesPtrOutput) Elem() CapabilitiesOutput {
	return o.ApplyT(func(v *Capabilities) Capabilities { return *v }).(CapabilitiesOutput)
}

// Added capabilities +optional
func (o CapabilitiesPtrOutput) Add() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Capabilities) []string {
		if v == nil {
			return nil
		}
		return v.Add
	}).(pulumi.StringArrayOutput)
}

// Removed capabilities +optional
func (o CapabilitiesPtrOutput) Drop() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Capabilities) []string {
		if v == nil {
			return nil
		}
		return v.Drop
	}).(pulumi.StringArrayOutput)
}

// ConfigMapEnvSource selects a ConfigMap to populate the environment variables with. The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
type ConfigMapEnvSource struct {
	// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
	LocalObjectReference *LocalObjectReference `pulumi:"localObjectReference"`
	// Cloud Run fully managed: not supported Cloud Run for Anthos: supported The ConfigMap to select from.
	Name *string `pulumi:"name"`
	// Cloud Run fully managed: not supported Cloud Run for Anthos: supported Specify whether the ConfigMap must be defined +optional
	Optional *bool `pulumi:"optional"`
}

// ConfigMapEnvSourceInput is an input type that accepts ConfigMapEnvSourceArgs and ConfigMapEnvSourceOutput values.
// You can construct a concrete instance of `ConfigMapEnvSourceInput` via:
//
//          ConfigMapEnvSourceArgs{...}
type ConfigMapEnvSourceInput interface {
	pulumi.Input

	ToConfigMapEnvSourceOutput() ConfigMapEnvSourceOutput
	ToConfigMapEnvSourceOutputWithContext(context.Context) ConfigMapEnvSourceOutput
}

// ConfigMapEnvSource selects a ConfigMap to populate the environment variables with. The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
type ConfigMapEnvSourceArgs struct {
	// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
	LocalObjectReference LocalObjectReferencePtrInput `pulumi:"localObjectReference"`
	// Cloud Run fully managed: not supported Cloud Run for Anthos: supported The ConfigMap to select from.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Cloud Run fully managed: not supported Cloud Run for Anthos: supported Specify whether the ConfigMap must be defined +optional
	Optional pulumi.BoolPtrInput `pulumi:"optional"`
}

func (ConfigMapEnvSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConfigMapEnvSource)(nil)).Elem()
}

func (i ConfigMapEnvSourceArgs) ToConfigMapEnvSourceOutput() ConfigMapEnvSourceOutput {
	return i.ToConfigMapEnvSourceOutputWithContext(context.Background())
}

func (i ConfigMapEnvSourceArgs) ToConfigMapEnvSourceOutputWithContext(ctx context.Context) ConfigMapEnvSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigMapEnvSourceOutput)
}

func (i ConfigMapEnvSourceArgs) ToConfigMapEnvSourcePtrOutput() ConfigMapEnvSourcePtrOutput {
	return i.ToConfigMapEnvSourcePtrOutputWithContext(context.Background())
}

func (i ConfigMapEnvSourceArgs) ToConfigMapEnvSourcePtrOutputWithContext(ctx context.Context) ConfigMapEnvSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigMapEnvSourceOutput).ToConfigMapEnvSourcePtrOutputWithContext(ctx)
}

// ConfigMapEnvSourcePtrInput is an input type that accepts ConfigMapEnvSourceArgs, ConfigMapEnvSourcePtr and ConfigMapEnvSourcePtrOutput values.
// You can construct a concrete instance of `ConfigMapEnvSourcePtrInput` via:
//
//          ConfigMapEnvSourceArgs{...}
//
//  or:
//
//          nil
type ConfigMapEnvSourcePtrInput interface {
	pulumi.Input

	ToConfigMapEnvSourcePtrOutput() ConfigMapEnvSourcePtrOutput
	ToConfigMapEnvSourcePtrOutputWithContext(context.Context) ConfigMapEnvSourcePtrOutput
}

type configMapEnvSourcePtrType ConfigMapEnvSourceArgs

func ConfigMapEnvSourcePtr(v *ConfigMapEnvSourceArgs) ConfigMapEnvSourcePtrInput {
	return (*configMapEnvSourcePtrType)(v)
}

func (*configMapEnvSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ConfigMapEnvSource)(nil)).Elem()
}

func (i *configMapEnvSourcePtrType) ToConfigMapEnvSourcePtrOutput() ConfigMapEnvSourcePtrOutput {
	return i.ToConfigMapEnvSourcePtrOutputWithContext(context.Background())
}

func (i *configMapEnvSourcePtrType) ToConfigMapEnvSourcePtrOutputWithContext(ctx context.Context) ConfigMapEnvSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigMapEnvSourcePtrOutput)
}

// ConfigMapEnvSource selects a ConfigMap to populate the environment variables with. The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
type ConfigMapEnvSourceOutput struct{ *pulumi.OutputState }

func (ConfigMapEnvSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConfigMapEnvSource)(nil)).Elem()
}

func (o ConfigMapEnvSourceOutput) ToConfigMapEnvSourceOutput() ConfigMapEnvSourceOutput {
	return o
}

func (o ConfigMapEnvSourceOutput) ToConfigMapEnvSourceOutputWithContext(ctx context.Context) ConfigMapEnvSourceOutput {
	return o
}

func (o ConfigMapEnvSourceOutput) ToConfigMapEnvSourcePtrOutput() ConfigMapEnvSourcePtrOutput {
	return o.ToConfigMapEnvSourcePtrOutputWithContext(context.Background())
}

func (o ConfigMapEnvSourceOutput) ToConfigMapEnvSourcePtrOutputWithContext(ctx context.Context) ConfigMapEnvSourcePtrOutput {
	return o.ApplyT(func(v ConfigMapEnvSource) *ConfigMapEnvSource {
		return &v
	}).(ConfigMapEnvSourcePtrOutput)
}

// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
func (o ConfigMapEnvSourceOutput) LocalObjectReference() LocalObjectReferencePtrOutput {
	return o.ApplyT(func(v ConfigMapEnvSource) *LocalObjectReference { return v.LocalObjectReference }).(LocalObjectReferencePtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run for Anthos: supported The ConfigMap to select from.
func (o ConfigMapEnvSourceOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ConfigMapEnvSource) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run for Anthos: supported Specify whether the ConfigMap must be defined +optional
func (o ConfigMapEnvSourceOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ConfigMapEnvSource) *bool { return v.Optional }).(pulumi.BoolPtrOutput)
}

type ConfigMapEnvSourcePtrOutput struct{ *pulumi.OutputState }

func (ConfigMapEnvSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConfigMapEnvSource)(nil)).Elem()
}

func (o ConfigMapEnvSourcePtrOutput) ToConfigMapEnvSourcePtrOutput() ConfigMapEnvSourcePtrOutput {
	return o
}

func (o ConfigMapEnvSourcePtrOutput) ToConfigMapEnvSourcePtrOutputWithContext(ctx context.Context) ConfigMapEnvSourcePtrOutput {
	return o
}

func (o ConfigMapEnvSourcePtrOutput) Elem() ConfigMapEnvSourceOutput {
	return o.ApplyT(func(v *ConfigMapEnvSource) ConfigMapEnvSource { return *v }).(ConfigMapEnvSourceOutput)
}

// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
func (o ConfigMapEnvSourcePtrOutput) LocalObjectReference() LocalObjectReferencePtrOutput {
	return o.ApplyT(func(v *ConfigMapEnvSource) *LocalObjectReference {
		if v == nil {
			return nil
		}
		return v.LocalObjectReference
	}).(LocalObjectReferencePtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run for Anthos: supported The ConfigMap to select from.
func (o ConfigMapEnvSourcePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ConfigMapEnvSource) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run for Anthos: supported Specify whether the ConfigMap must be defined +optional
func (o ConfigMapEnvSourcePtrOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ConfigMapEnvSource) *bool {
		if v == nil {
			return nil
		}
		return v.Optional
	}).(pulumi.BoolPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported Selects a key from a ConfigMap.
type ConfigMapKeySelector struct {
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported The key to select.
	Key *string `pulumi:"key"`
	// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
	LocalObjectReference *LocalObjectReference `pulumi:"localObjectReference"`
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported The ConfigMap to select from.
	Name *string `pulumi:"name"`
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported Specify whether the ConfigMap or its key must be defined +optional
	Optional *bool `pulumi:"optional"`
}

// ConfigMapKeySelectorInput is an input type that accepts ConfigMapKeySelectorArgs and ConfigMapKeySelectorOutput values.
// You can construct a concrete instance of `ConfigMapKeySelectorInput` via:
//
//          ConfigMapKeySelectorArgs{...}
type ConfigMapKeySelectorInput interface {
	pulumi.Input

	ToConfigMapKeySelectorOutput() ConfigMapKeySelectorOutput
	ToConfigMapKeySelectorOutputWithContext(context.Context) ConfigMapKeySelectorOutput
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported Selects a key from a ConfigMap.
type ConfigMapKeySelectorArgs struct {
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported The key to select.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
	LocalObjectReference LocalObjectReferencePtrInput `pulumi:"localObjectReference"`
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported The ConfigMap to select from.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported Specify whether the ConfigMap or its key must be defined +optional
	Optional pulumi.BoolPtrInput `pulumi:"optional"`
}

func (ConfigMapKeySelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConfigMapKeySelector)(nil)).Elem()
}

func (i ConfigMapKeySelectorArgs) ToConfigMapKeySelectorOutput() ConfigMapKeySelectorOutput {
	return i.ToConfigMapKeySelectorOutputWithContext(context.Background())
}

func (i ConfigMapKeySelectorArgs) ToConfigMapKeySelectorOutputWithContext(ctx context.Context) ConfigMapKeySelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigMapKeySelectorOutput)
}

func (i ConfigMapKeySelectorArgs) ToConfigMapKeySelectorPtrOutput() ConfigMapKeySelectorPtrOutput {
	return i.ToConfigMapKeySelectorPtrOutputWithContext(context.Background())
}

func (i ConfigMapKeySelectorArgs) ToConfigMapKeySelectorPtrOutputWithContext(ctx context.Context) ConfigMapKeySelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigMapKeySelectorOutput).ToConfigMapKeySelectorPtrOutputWithContext(ctx)
}

// ConfigMapKeySelectorPtrInput is an input type that accepts ConfigMapKeySelectorArgs, ConfigMapKeySelectorPtr and ConfigMapKeySelectorPtrOutput values.
// You can construct a concrete instance of `ConfigMapKeySelectorPtrInput` via:
//
//          ConfigMapKeySelectorArgs{...}
//
//  or:
//
//          nil
type ConfigMapKeySelectorPtrInput interface {
	pulumi.Input

	ToConfigMapKeySelectorPtrOutput() ConfigMapKeySelectorPtrOutput
	ToConfigMapKeySelectorPtrOutputWithContext(context.Context) ConfigMapKeySelectorPtrOutput
}

type configMapKeySelectorPtrType ConfigMapKeySelectorArgs

func ConfigMapKeySelectorPtr(v *ConfigMapKeySelectorArgs) ConfigMapKeySelectorPtrInput {
	return (*configMapKeySelectorPtrType)(v)
}

func (*configMapKeySelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ConfigMapKeySelector)(nil)).Elem()
}

func (i *configMapKeySelectorPtrType) ToConfigMapKeySelectorPtrOutput() ConfigMapKeySelectorPtrOutput {
	return i.ToConfigMapKeySelectorPtrOutputWithContext(context.Background())
}

func (i *configMapKeySelectorPtrType) ToConfigMapKeySelectorPtrOutputWithContext(ctx context.Context) ConfigMapKeySelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigMapKeySelectorPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported Selects a key from a ConfigMap.
type ConfigMapKeySelectorOutput struct{ *pulumi.OutputState }

func (ConfigMapKeySelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConfigMapKeySelector)(nil)).Elem()
}

func (o ConfigMapKeySelectorOutput) ToConfigMapKeySelectorOutput() ConfigMapKeySelectorOutput {
	return o
}

func (o ConfigMapKeySelectorOutput) ToConfigMapKeySelectorOutputWithContext(ctx context.Context) ConfigMapKeySelectorOutput {
	return o
}

func (o ConfigMapKeySelectorOutput) ToConfigMapKeySelectorPtrOutput() ConfigMapKeySelectorPtrOutput {
	return o.ToConfigMapKeySelectorPtrOutputWithContext(context.Background())
}

func (o ConfigMapKeySelectorOutput) ToConfigMapKeySelectorPtrOutputWithContext(ctx context.Context) ConfigMapKeySelectorPtrOutput {
	return o.ApplyT(func(v ConfigMapKeySelector) *ConfigMapKeySelector {
		return &v
	}).(ConfigMapKeySelectorPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported The key to select.
func (o ConfigMapKeySelectorOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ConfigMapKeySelector) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
func (o ConfigMapKeySelectorOutput) LocalObjectReference() LocalObjectReferencePtrOutput {
	return o.ApplyT(func(v ConfigMapKeySelector) *LocalObjectReference { return v.LocalObjectReference }).(LocalObjectReferencePtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported The ConfigMap to select from.
func (o ConfigMapKeySelectorOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ConfigMapKeySelector) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported Specify whether the ConfigMap or its key must be defined +optional
func (o ConfigMapKeySelectorOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ConfigMapKeySelector) *bool { return v.Optional }).(pulumi.BoolPtrOutput)
}

type ConfigMapKeySelectorPtrOutput struct{ *pulumi.OutputState }

func (ConfigMapKeySelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConfigMapKeySelector)(nil)).Elem()
}

func (o ConfigMapKeySelectorPtrOutput) ToConfigMapKeySelectorPtrOutput() ConfigMapKeySelectorPtrOutput {
	return o
}

func (o ConfigMapKeySelectorPtrOutput) ToConfigMapKeySelectorPtrOutputWithContext(ctx context.Context) ConfigMapKeySelectorPtrOutput {
	return o
}

func (o ConfigMapKeySelectorPtrOutput) Elem() ConfigMapKeySelectorOutput {
	return o.ApplyT(func(v *ConfigMapKeySelector) ConfigMapKeySelector { return *v }).(ConfigMapKeySelectorOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported The key to select.
func (o ConfigMapKeySelectorPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ConfigMapKeySelector) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
func (o ConfigMapKeySelectorPtrOutput) LocalObjectReference() LocalObjectReferencePtrOutput {
	return o.ApplyT(func(v *ConfigMapKeySelector) *LocalObjectReference {
		if v == nil {
			return nil
		}
		return v.LocalObjectReference
	}).(LocalObjectReferencePtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported The ConfigMap to select from.
func (o ConfigMapKeySelectorPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ConfigMapKeySelector) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported Specify whether the ConfigMap or its key must be defined +optional
func (o ConfigMapKeySelectorPtrOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ConfigMapKeySelector) *bool {
		if v == nil {
			return nil
		}
		return v.Optional
	}).(pulumi.BoolPtrOutput)
}

// Adapts a ConfigMap into a volume. The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths.
type ConfigMapVolumeSource struct {
	// Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode *int `pulumi:"defaultMode"`
	// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional.
	Items []KeyToPath `pulumi:"items"`
	// Name of the config.
	Name *string `pulumi:"name"`
	// Specify whether the Secret or its keys must be defined.
	Optional *bool `pulumi:"optional"`
}

// ConfigMapVolumeSourceInput is an input type that accepts ConfigMapVolumeSourceArgs and ConfigMapVolumeSourceOutput values.
// You can construct a concrete instance of `ConfigMapVolumeSourceInput` via:
//
//          ConfigMapVolumeSourceArgs{...}
type ConfigMapVolumeSourceInput interface {
	pulumi.Input

	ToConfigMapVolumeSourceOutput() ConfigMapVolumeSourceOutput
	ToConfigMapVolumeSourceOutputWithContext(context.Context) ConfigMapVolumeSourceOutput
}

// Adapts a ConfigMap into a volume. The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths.
type ConfigMapVolumeSourceArgs struct {
	// Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode pulumi.IntPtrInput `pulumi:"defaultMode"`
	// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional.
	Items KeyToPathArrayInput `pulumi:"items"`
	// Name of the config.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Specify whether the Secret or its keys must be defined.
	Optional pulumi.BoolPtrInput `pulumi:"optional"`
}

func (ConfigMapVolumeSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConfigMapVolumeSource)(nil)).Elem()
}

func (i ConfigMapVolumeSourceArgs) ToConfigMapVolumeSourceOutput() ConfigMapVolumeSourceOutput {
	return i.ToConfigMapVolumeSourceOutputWithContext(context.Background())
}

func (i ConfigMapVolumeSourceArgs) ToConfigMapVolumeSourceOutputWithContext(ctx context.Context) ConfigMapVolumeSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigMapVolumeSourceOutput)
}

func (i ConfigMapVolumeSourceArgs) ToConfigMapVolumeSourcePtrOutput() ConfigMapVolumeSourcePtrOutput {
	return i.ToConfigMapVolumeSourcePtrOutputWithContext(context.Background())
}

func (i ConfigMapVolumeSourceArgs) ToConfigMapVolumeSourcePtrOutputWithContext(ctx context.Context) ConfigMapVolumeSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigMapVolumeSourceOutput).ToConfigMapVolumeSourcePtrOutputWithContext(ctx)
}

// ConfigMapVolumeSourcePtrInput is an input type that accepts ConfigMapVolumeSourceArgs, ConfigMapVolumeSourcePtr and ConfigMapVolumeSourcePtrOutput values.
// You can construct a concrete instance of `ConfigMapVolumeSourcePtrInput` via:
//
//          ConfigMapVolumeSourceArgs{...}
//
//  or:
//
//          nil
type ConfigMapVolumeSourcePtrInput interface {
	pulumi.Input

	ToConfigMapVolumeSourcePtrOutput() ConfigMapVolumeSourcePtrOutput
	ToConfigMapVolumeSourcePtrOutputWithContext(context.Context) ConfigMapVolumeSourcePtrOutput
}

type configMapVolumeSourcePtrType ConfigMapVolumeSourceArgs

func ConfigMapVolumeSourcePtr(v *ConfigMapVolumeSourceArgs) ConfigMapVolumeSourcePtrInput {
	return (*configMapVolumeSourcePtrType)(v)
}

func (*configMapVolumeSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ConfigMapVolumeSource)(nil)).Elem()
}

func (i *configMapVolumeSourcePtrType) ToConfigMapVolumeSourcePtrOutput() ConfigMapVolumeSourcePtrOutput {
	return i.ToConfigMapVolumeSourcePtrOutputWithContext(context.Background())
}

func (i *configMapVolumeSourcePtrType) ToConfigMapVolumeSourcePtrOutputWithContext(ctx context.Context) ConfigMapVolumeSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigMapVolumeSourcePtrOutput)
}

// Adapts a ConfigMap into a volume. The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths.
type ConfigMapVolumeSourceOutput struct{ *pulumi.OutputState }

func (ConfigMapVolumeSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConfigMapVolumeSource)(nil)).Elem()
}

func (o ConfigMapVolumeSourceOutput) ToConfigMapVolumeSourceOutput() ConfigMapVolumeSourceOutput {
	return o
}

func (o ConfigMapVolumeSourceOutput) ToConfigMapVolumeSourceOutputWithContext(ctx context.Context) ConfigMapVolumeSourceOutput {
	return o
}

func (o ConfigMapVolumeSourceOutput) ToConfigMapVolumeSourcePtrOutput() ConfigMapVolumeSourcePtrOutput {
	return o.ToConfigMapVolumeSourcePtrOutputWithContext(context.Background())
}

func (o ConfigMapVolumeSourceOutput) ToConfigMapVolumeSourcePtrOutputWithContext(ctx context.Context) ConfigMapVolumeSourcePtrOutput {
	return o.ApplyT(func(v ConfigMapVolumeSource) *ConfigMapVolumeSource {
		return &v
	}).(ConfigMapVolumeSourcePtrOutput)
}

// Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o ConfigMapVolumeSourceOutput) DefaultMode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ConfigMapVolumeSource) *int { return v.DefaultMode }).(pulumi.IntPtrOutput)
}

// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional.
func (o ConfigMapVolumeSourceOutput) Items() KeyToPathArrayOutput {
	return o.ApplyT(func(v ConfigMapVolumeSource) []KeyToPath { return v.Items }).(KeyToPathArrayOutput)
}

// Name of the config.
func (o ConfigMapVolumeSourceOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ConfigMapVolumeSource) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Specify whether the Secret or its keys must be defined.
func (o ConfigMapVolumeSourceOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ConfigMapVolumeSource) *bool { return v.Optional }).(pulumi.BoolPtrOutput)
}

type ConfigMapVolumeSourcePtrOutput struct{ *pulumi.OutputState }

func (ConfigMapVolumeSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConfigMapVolumeSource)(nil)).Elem()
}

func (o ConfigMapVolumeSourcePtrOutput) ToConfigMapVolumeSourcePtrOutput() ConfigMapVolumeSourcePtrOutput {
	return o
}

func (o ConfigMapVolumeSourcePtrOutput) ToConfigMapVolumeSourcePtrOutputWithContext(ctx context.Context) ConfigMapVolumeSourcePtrOutput {
	return o
}

func (o ConfigMapVolumeSourcePtrOutput) Elem() ConfigMapVolumeSourceOutput {
	return o.ApplyT(func(v *ConfigMapVolumeSource) ConfigMapVolumeSource { return *v }).(ConfigMapVolumeSourceOutput)
}

// Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o ConfigMapVolumeSourcePtrOutput) DefaultMode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ConfigMapVolumeSource) *int {
		if v == nil {
			return nil
		}
		return v.DefaultMode
	}).(pulumi.IntPtrOutput)
}

// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional.
func (o ConfigMapVolumeSourcePtrOutput) Items() KeyToPathArrayOutput {
	return o.ApplyT(func(v *ConfigMapVolumeSource) []KeyToPath {
		if v == nil {
			return nil
		}
		return v.Items
	}).(KeyToPathArrayOutput)
}

// Name of the config.
func (o ConfigMapVolumeSourcePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ConfigMapVolumeSource) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Specify whether the Secret or its keys must be defined.
func (o ConfigMapVolumeSourcePtrOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ConfigMapVolumeSource) *bool {
		if v == nil {
			return nil
		}
		return v.Optional
	}).(pulumi.BoolPtrOutput)
}

// ConfigurationSpec holds the desired state of the Configuration (from the client).
type ConfigurationSpec struct {
	// Deprecated and not currently populated by Cloud Run. See metadata.generation instead, which is the sequence number containing the latest generation of the desired state. Read-only.
	Generation *int `pulumi:"generation"`
	// RevisionTemplate holds the latest specification for the Revision to be stamped out. The template references the container image, and may also include labels and annotations that should be attached to the Revision. To correlate a Revision, and/or to force a Revision to be created when the spec doesn't otherwise change, a nonce label may be provided in the template metadata. For more details, see: https://github.com/knative/serving/blob/master/docs/client-conventions.md#associate-modifications-with-revisions Cloud Run does not currently support referencing a build that is responsible for materializing the container image from source.
	RevisionTemplate *RevisionTemplate `pulumi:"revisionTemplate"`
	// Template holds the latest specification for the Revision to be stamped out.
	Template *RevisionTemplate `pulumi:"template"`
}

// ConfigurationSpecInput is an input type that accepts ConfigurationSpecArgs and ConfigurationSpecOutput values.
// You can construct a concrete instance of `ConfigurationSpecInput` via:
//
//          ConfigurationSpecArgs{...}
type ConfigurationSpecInput interface {
	pulumi.Input

	ToConfigurationSpecOutput() ConfigurationSpecOutput
	ToConfigurationSpecOutputWithContext(context.Context) ConfigurationSpecOutput
}

// ConfigurationSpec holds the desired state of the Configuration (from the client).
type ConfigurationSpecArgs struct {
	// Deprecated and not currently populated by Cloud Run. See metadata.generation instead, which is the sequence number containing the latest generation of the desired state. Read-only.
	Generation pulumi.IntPtrInput `pulumi:"generation"`
	// RevisionTemplate holds the latest specification for the Revision to be stamped out. The template references the container image, and may also include labels and annotations that should be attached to the Revision. To correlate a Revision, and/or to force a Revision to be created when the spec doesn't otherwise change, a nonce label may be provided in the template metadata. For more details, see: https://github.com/knative/serving/blob/master/docs/client-conventions.md#associate-modifications-with-revisions Cloud Run does not currently support referencing a build that is responsible for materializing the container image from source.
	RevisionTemplate RevisionTemplatePtrInput `pulumi:"revisionTemplate"`
	// Template holds the latest specification for the Revision to be stamped out.
	Template RevisionTemplatePtrInput `pulumi:"template"`
}

func (ConfigurationSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConfigurationSpec)(nil)).Elem()
}

func (i ConfigurationSpecArgs) ToConfigurationSpecOutput() ConfigurationSpecOutput {
	return i.ToConfigurationSpecOutputWithContext(context.Background())
}

func (i ConfigurationSpecArgs) ToConfigurationSpecOutputWithContext(ctx context.Context) ConfigurationSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigurationSpecOutput)
}

func (i ConfigurationSpecArgs) ToConfigurationSpecPtrOutput() ConfigurationSpecPtrOutput {
	return i.ToConfigurationSpecPtrOutputWithContext(context.Background())
}

func (i ConfigurationSpecArgs) ToConfigurationSpecPtrOutputWithContext(ctx context.Context) ConfigurationSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigurationSpecOutput).ToConfigurationSpecPtrOutputWithContext(ctx)
}

// ConfigurationSpecPtrInput is an input type that accepts ConfigurationSpecArgs, ConfigurationSpecPtr and ConfigurationSpecPtrOutput values.
// You can construct a concrete instance of `ConfigurationSpecPtrInput` via:
//
//          ConfigurationSpecArgs{...}
//
//  or:
//
//          nil
type ConfigurationSpecPtrInput interface {
	pulumi.Input

	ToConfigurationSpecPtrOutput() ConfigurationSpecPtrOutput
	ToConfigurationSpecPtrOutputWithContext(context.Context) ConfigurationSpecPtrOutput
}

type configurationSpecPtrType ConfigurationSpecArgs

func ConfigurationSpecPtr(v *ConfigurationSpecArgs) ConfigurationSpecPtrInput {
	return (*configurationSpecPtrType)(v)
}

func (*configurationSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ConfigurationSpec)(nil)).Elem()
}

func (i *configurationSpecPtrType) ToConfigurationSpecPtrOutput() ConfigurationSpecPtrOutput {
	return i.ToConfigurationSpecPtrOutputWithContext(context.Background())
}

func (i *configurationSpecPtrType) ToConfigurationSpecPtrOutputWithContext(ctx context.Context) ConfigurationSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigurationSpecPtrOutput)
}

// ConfigurationSpec holds the desired state of the Configuration (from the client).
type ConfigurationSpecOutput struct{ *pulumi.OutputState }

func (ConfigurationSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConfigurationSpec)(nil)).Elem()
}

func (o ConfigurationSpecOutput) ToConfigurationSpecOutput() ConfigurationSpecOutput {
	return o
}

func (o ConfigurationSpecOutput) ToConfigurationSpecOutputWithContext(ctx context.Context) ConfigurationSpecOutput {
	return o
}

func (o ConfigurationSpecOutput) ToConfigurationSpecPtrOutput() ConfigurationSpecPtrOutput {
	return o.ToConfigurationSpecPtrOutputWithContext(context.Background())
}

func (o ConfigurationSpecOutput) ToConfigurationSpecPtrOutputWithContext(ctx context.Context) ConfigurationSpecPtrOutput {
	return o.ApplyT(func(v ConfigurationSpec) *ConfigurationSpec {
		return &v
	}).(ConfigurationSpecPtrOutput)
}

// Deprecated and not currently populated by Cloud Run. See metadata.generation instead, which is the sequence number containing the latest generation of the desired state. Read-only.
func (o ConfigurationSpecOutput) Generation() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ConfigurationSpec) *int { return v.Generation }).(pulumi.IntPtrOutput)
}

// RevisionTemplate holds the latest specification for the Revision to be stamped out. The template references the container image, and may also include labels and annotations that should be attached to the Revision. To correlate a Revision, and/or to force a Revision to be created when the spec doesn't otherwise change, a nonce label may be provided in the template metadata. For more details, see: https://github.com/knative/serving/blob/master/docs/client-conventions.md#associate-modifications-with-revisions Cloud Run does not currently support referencing a build that is responsible for materializing the container image from source.
func (o ConfigurationSpecOutput) RevisionTemplate() RevisionTemplatePtrOutput {
	return o.ApplyT(func(v ConfigurationSpec) *RevisionTemplate { return v.RevisionTemplate }).(RevisionTemplatePtrOutput)
}

// Template holds the latest specification for the Revision to be stamped out.
func (o ConfigurationSpecOutput) Template() RevisionTemplatePtrOutput {
	return o.ApplyT(func(v ConfigurationSpec) *RevisionTemplate { return v.Template }).(RevisionTemplatePtrOutput)
}

type ConfigurationSpecPtrOutput struct{ *pulumi.OutputState }

func (ConfigurationSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConfigurationSpec)(nil)).Elem()
}

func (o ConfigurationSpecPtrOutput) ToConfigurationSpecPtrOutput() ConfigurationSpecPtrOutput {
	return o
}

func (o ConfigurationSpecPtrOutput) ToConfigurationSpecPtrOutputWithContext(ctx context.Context) ConfigurationSpecPtrOutput {
	return o
}

func (o ConfigurationSpecPtrOutput) Elem() ConfigurationSpecOutput {
	return o.ApplyT(func(v *ConfigurationSpec) ConfigurationSpec { return *v }).(ConfigurationSpecOutput)
}

// Deprecated and not currently populated by Cloud Run. See metadata.generation instead, which is the sequence number containing the latest generation of the desired state. Read-only.
func (o ConfigurationSpecPtrOutput) Generation() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ConfigurationSpec) *int {
		if v == nil {
			return nil
		}
		return v.Generation
	}).(pulumi.IntPtrOutput)
}

// RevisionTemplate holds the latest specification for the Revision to be stamped out. The template references the container image, and may also include labels and annotations that should be attached to the Revision. To correlate a Revision, and/or to force a Revision to be created when the spec doesn't otherwise change, a nonce label may be provided in the template metadata. For more details, see: https://github.com/knative/serving/blob/master/docs/client-conventions.md#associate-modifications-with-revisions Cloud Run does not currently support referencing a build that is responsible for materializing the container image from source.
func (o ConfigurationSpecPtrOutput) RevisionTemplate() RevisionTemplatePtrOutput {
	return o.ApplyT(func(v *ConfigurationSpec) *RevisionTemplate {
		if v == nil {
			return nil
		}
		return v.RevisionTemplate
	}).(RevisionTemplatePtrOutput)
}

// Template holds the latest specification for the Revision to be stamped out.
func (o ConfigurationSpecPtrOutput) Template() RevisionTemplatePtrOutput {
	return o.ApplyT(func(v *ConfigurationSpec) *RevisionTemplate {
		if v == nil {
			return nil
		}
		return v.Template
	}).(RevisionTemplatePtrOutput)
}

// A single application container. This specifies both the container to run, the command to run in the container and the arguments to supply to it. Note that additional arguments may be supplied by the system to the container at runtime.
type Container struct {
	// Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell +optional
	Args []string `pulumi:"args"`
	// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell +optional
	Command []string `pulumi:"command"`
	// List of environment variables to set in the container. Cannot be updated. +optional
	Env []EnvVar `pulumi:"env"`
	// List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated. +optional
	EnvFrom []EnvFromSource `pulumi:"envFrom"`
	// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
	Image *string `pulumi:"image"`
	// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images +optional
	ImagePullPolicy *string `pulumi:"imagePullPolicy"`
	// Actions that the management system should take in response to container lifecycle events. Cannot be updated. +optional
	Lifecycle *Lifecycle `pulumi:"lifecycle"`
	// Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
	LivenessProbe *Probe `pulumi:"livenessProbe"`
	// Name of the container specified as a DNS_LABEL. Each container must have a unique name (DNS_LABEL). Cannot be updated.
	Name *string `pulumi:"name"`
	// List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated. +optional
	Ports []ContainerPort `pulumi:"ports"`
	// Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
	ReadinessProbe *Probe `pulumi:"readinessProbe"`
	// Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources +optional
	Resources *ResourceRequirements `pulumi:"resources"`
	// Security options the pod should run with. More info: https://kubernetes.io/docs/concepts/policy/security-context/ More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ +optional
	SecurityContext *SecurityContext `pulumi:"securityContext"`
	// Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false. +optional
	Stdin *bool `pulumi:"stdin"`
	// Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false +optional
	StdinOnce *bool `pulumi:"stdinOnce"`
	// Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated. +optional
	TerminationMessagePath *string `pulumi:"terminationMessagePath"`
	// Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated. +optional
	TerminationMessagePolicy *string `pulumi:"terminationMessagePolicy"`
	// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false. +optional
	Tty *bool `pulumi:"tty"`
	// volumeDevices is the list of block devices to be used by the container. This is an alpha feature and may change in the future. +optional
	VolumeDevices []VolumeDevice `pulumi:"volumeDevices"`
	// Pod volumes to mount into the container's filesystem. Cannot be updated. +optional
	VolumeMounts []VolumeMount `pulumi:"volumeMounts"`
	// Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated. +optional
	WorkingDir *string `pulumi:"workingDir"`
}

// ContainerInput is an input type that accepts ContainerArgs and ContainerOutput values.
// You can construct a concrete instance of `ContainerInput` via:
//
//          ContainerArgs{...}
type ContainerInput interface {
	pulumi.Input

	ToContainerOutput() ContainerOutput
	ToContainerOutputWithContext(context.Context) ContainerOutput
}

// A single application container. This specifies both the container to run, the command to run in the container and the arguments to supply to it. Note that additional arguments may be supplied by the system to the container at runtime.
type ContainerArgs struct {
	// Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell +optional
	Args pulumi.StringArrayInput `pulumi:"args"`
	// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell +optional
	Command pulumi.StringArrayInput `pulumi:"command"`
	// List of environment variables to set in the container. Cannot be updated. +optional
	Env EnvVarArrayInput `pulumi:"env"`
	// List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated. +optional
	EnvFrom EnvFromSourceArrayInput `pulumi:"envFrom"`
	// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
	Image pulumi.StringPtrInput `pulumi:"image"`
	// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images +optional
	ImagePullPolicy pulumi.StringPtrInput `pulumi:"imagePullPolicy"`
	// Actions that the management system should take in response to container lifecycle events. Cannot be updated. +optional
	Lifecycle LifecyclePtrInput `pulumi:"lifecycle"`
	// Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
	LivenessProbe ProbePtrInput `pulumi:"livenessProbe"`
	// Name of the container specified as a DNS_LABEL. Each container must have a unique name (DNS_LABEL). Cannot be updated.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated. +optional
	Ports ContainerPortArrayInput `pulumi:"ports"`
	// Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
	ReadinessProbe ProbePtrInput `pulumi:"readinessProbe"`
	// Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources +optional
	Resources ResourceRequirementsPtrInput `pulumi:"resources"`
	// Security options the pod should run with. More info: https://kubernetes.io/docs/concepts/policy/security-context/ More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ +optional
	SecurityContext SecurityContextPtrInput `pulumi:"securityContext"`
	// Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false. +optional
	Stdin pulumi.BoolPtrInput `pulumi:"stdin"`
	// Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false +optional
	StdinOnce pulumi.BoolPtrInput `pulumi:"stdinOnce"`
	// Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated. +optional
	TerminationMessagePath pulumi.StringPtrInput `pulumi:"terminationMessagePath"`
	// Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated. +optional
	TerminationMessagePolicy pulumi.StringPtrInput `pulumi:"terminationMessagePolicy"`
	// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false. +optional
	Tty pulumi.BoolPtrInput `pulumi:"tty"`
	// volumeDevices is the list of block devices to be used by the container. This is an alpha feature and may change in the future. +optional
	VolumeDevices VolumeDeviceArrayInput `pulumi:"volumeDevices"`
	// Pod volumes to mount into the container's filesystem. Cannot be updated. +optional
	VolumeMounts VolumeMountArrayInput `pulumi:"volumeMounts"`
	// Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated. +optional
	WorkingDir pulumi.StringPtrInput `pulumi:"workingDir"`
}

func (ContainerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Container)(nil)).Elem()
}

func (i ContainerArgs) ToContainerOutput() ContainerOutput {
	return i.ToContainerOutputWithContext(context.Background())
}

func (i ContainerArgs) ToContainerOutputWithContext(ctx context.Context) ContainerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerOutput)
}

func (i ContainerArgs) ToContainerPtrOutput() ContainerPtrOutput {
	return i.ToContainerPtrOutputWithContext(context.Background())
}

func (i ContainerArgs) ToContainerPtrOutputWithContext(ctx context.Context) ContainerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerOutput).ToContainerPtrOutputWithContext(ctx)
}

// ContainerPtrInput is an input type that accepts ContainerArgs, ContainerPtr and ContainerPtrOutput values.
// You can construct a concrete instance of `ContainerPtrInput` via:
//
//          ContainerArgs{...}
//
//  or:
//
//          nil
type ContainerPtrInput interface {
	pulumi.Input

	ToContainerPtrOutput() ContainerPtrOutput
	ToContainerPtrOutputWithContext(context.Context) ContainerPtrOutput
}

type containerPtrType ContainerArgs

func ContainerPtr(v *ContainerArgs) ContainerPtrInput {
	return (*containerPtrType)(v)
}

func (*containerPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Container)(nil)).Elem()
}

func (i *containerPtrType) ToContainerPtrOutput() ContainerPtrOutput {
	return i.ToContainerPtrOutputWithContext(context.Background())
}

func (i *containerPtrType) ToContainerPtrOutputWithContext(ctx context.Context) ContainerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerPtrOutput)
}

// ContainerArrayInput is an input type that accepts ContainerArray and ContainerArrayOutput values.
// You can construct a concrete instance of `ContainerArrayInput` via:
//
//          ContainerArray{ ContainerArgs{...} }
type ContainerArrayInput interface {
	pulumi.Input

	ToContainerArrayOutput() ContainerArrayOutput
	ToContainerArrayOutputWithContext(context.Context) ContainerArrayOutput
}

type ContainerArray []ContainerInput

func (ContainerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Container)(nil)).Elem()
}

func (i ContainerArray) ToContainerArrayOutput() ContainerArrayOutput {
	return i.ToContainerArrayOutputWithContext(context.Background())
}

func (i ContainerArray) ToContainerArrayOutputWithContext(ctx context.Context) ContainerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerArrayOutput)
}

// A single application container. This specifies both the container to run, the command to run in the container and the arguments to supply to it. Note that additional arguments may be supplied by the system to the container at runtime.
type ContainerOutput struct{ *pulumi.OutputState }

func (ContainerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Container)(nil)).Elem()
}

func (o ContainerOutput) ToContainerOutput() ContainerOutput {
	return o
}

func (o ContainerOutput) ToContainerOutputWithContext(ctx context.Context) ContainerOutput {
	return o
}

func (o ContainerOutput) ToContainerPtrOutput() ContainerPtrOutput {
	return o.ToContainerPtrOutputWithContext(context.Background())
}

func (o ContainerOutput) ToContainerPtrOutputWithContext(ctx context.Context) ContainerPtrOutput {
	return o.ApplyT(func(v Container) *Container {
		return &v
	}).(ContainerPtrOutput)
}

// Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell +optional
func (o ContainerOutput) Args() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Container) []string { return v.Args }).(pulumi.StringArrayOutput)
}

// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell +optional
func (o ContainerOutput) Command() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Container) []string { return v.Command }).(pulumi.StringArrayOutput)
}

// List of environment variables to set in the container. Cannot be updated. +optional
func (o ContainerOutput) Env() EnvVarArrayOutput {
	return o.ApplyT(func(v Container) []EnvVar { return v.Env }).(EnvVarArrayOutput)
}

// List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated. +optional
func (o ContainerOutput) EnvFrom() EnvFromSourceArrayOutput {
	return o.ApplyT(func(v Container) []EnvFromSource { return v.EnvFrom }).(EnvFromSourceArrayOutput)
}

// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
func (o ContainerOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Container) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images +optional
func (o ContainerOutput) ImagePullPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Container) *string { return v.ImagePullPolicy }).(pulumi.StringPtrOutput)
}

// Actions that the management system should take in response to container lifecycle events. Cannot be updated. +optional
func (o ContainerOutput) Lifecycle() LifecyclePtrOutput {
	return o.ApplyT(func(v Container) *Lifecycle { return v.Lifecycle }).(LifecyclePtrOutput)
}

// Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
func (o ContainerOutput) LivenessProbe() ProbePtrOutput {
	return o.ApplyT(func(v Container) *Probe { return v.LivenessProbe }).(ProbePtrOutput)
}

// Name of the container specified as a DNS_LABEL. Each container must have a unique name (DNS_LABEL). Cannot be updated.
func (o ContainerOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Container) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated. +optional
func (o ContainerOutput) Ports() ContainerPortArrayOutput {
	return o.ApplyT(func(v Container) []ContainerPort { return v.Ports }).(ContainerPortArrayOutput)
}

// Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
func (o ContainerOutput) ReadinessProbe() ProbePtrOutput {
	return o.ApplyT(func(v Container) *Probe { return v.ReadinessProbe }).(ProbePtrOutput)
}

// Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources +optional
func (o ContainerOutput) Resources() ResourceRequirementsPtrOutput {
	return o.ApplyT(func(v Container) *ResourceRequirements { return v.Resources }).(ResourceRequirementsPtrOutput)
}

// Security options the pod should run with. More info: https://kubernetes.io/docs/concepts/policy/security-context/ More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ +optional
func (o ContainerOutput) SecurityContext() SecurityContextPtrOutput {
	return o.ApplyT(func(v Container) *SecurityContext { return v.SecurityContext }).(SecurityContextPtrOutput)
}

// Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false. +optional
func (o ContainerOutput) Stdin() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Container) *bool { return v.Stdin }).(pulumi.BoolPtrOutput)
}

// Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false +optional
func (o ContainerOutput) StdinOnce() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Container) *bool { return v.StdinOnce }).(pulumi.BoolPtrOutput)
}

// Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated. +optional
func (o ContainerOutput) TerminationMessagePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Container) *string { return v.TerminationMessagePath }).(pulumi.StringPtrOutput)
}

// Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated. +optional
func (o ContainerOutput) TerminationMessagePolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Container) *string { return v.TerminationMessagePolicy }).(pulumi.StringPtrOutput)
}

// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false. +optional
func (o ContainerOutput) Tty() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Container) *bool { return v.Tty }).(pulumi.BoolPtrOutput)
}

// volumeDevices is the list of block devices to be used by the container. This is an alpha feature and may change in the future. +optional
func (o ContainerOutput) VolumeDevices() VolumeDeviceArrayOutput {
	return o.ApplyT(func(v Container) []VolumeDevice { return v.VolumeDevices }).(VolumeDeviceArrayOutput)
}

// Pod volumes to mount into the container's filesystem. Cannot be updated. +optional
func (o ContainerOutput) VolumeMounts() VolumeMountArrayOutput {
	return o.ApplyT(func(v Container) []VolumeMount { return v.VolumeMounts }).(VolumeMountArrayOutput)
}

// Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated. +optional
func (o ContainerOutput) WorkingDir() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Container) *string { return v.WorkingDir }).(pulumi.StringPtrOutput)
}

type ContainerPtrOutput struct{ *pulumi.OutputState }

func (ContainerPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Container)(nil)).Elem()
}

func (o ContainerPtrOutput) ToContainerPtrOutput() ContainerPtrOutput {
	return o
}

func (o ContainerPtrOutput) ToContainerPtrOutputWithContext(ctx context.Context) ContainerPtrOutput {
	return o
}

func (o ContainerPtrOutput) Elem() ContainerOutput {
	return o.ApplyT(func(v *Container) Container { return *v }).(ContainerOutput)
}

// Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell +optional
func (o ContainerPtrOutput) Args() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Container) []string {
		if v == nil {
			return nil
		}
		return v.Args
	}).(pulumi.StringArrayOutput)
}

// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell +optional
func (o ContainerPtrOutput) Command() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Container) []string {
		if v == nil {
			return nil
		}
		return v.Command
	}).(pulumi.StringArrayOutput)
}

// List of environment variables to set in the container. Cannot be updated. +optional
func (o ContainerPtrOutput) Env() EnvVarArrayOutput {
	return o.ApplyT(func(v *Container) []EnvVar {
		if v == nil {
			return nil
		}
		return v.Env
	}).(EnvVarArrayOutput)
}

// List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated. +optional
func (o ContainerPtrOutput) EnvFrom() EnvFromSourceArrayOutput {
	return o.ApplyT(func(v *Container) []EnvFromSource {
		if v == nil {
			return nil
		}
		return v.EnvFrom
	}).(EnvFromSourceArrayOutput)
}

// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
func (o ContainerPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Container) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images +optional
func (o ContainerPtrOutput) ImagePullPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Container) *string {
		if v == nil {
			return nil
		}
		return v.ImagePullPolicy
	}).(pulumi.StringPtrOutput)
}

// Actions that the management system should take in response to container lifecycle events. Cannot be updated. +optional
func (o ContainerPtrOutput) Lifecycle() LifecyclePtrOutput {
	return o.ApplyT(func(v *Container) *Lifecycle {
		if v == nil {
			return nil
		}
		return v.Lifecycle
	}).(LifecyclePtrOutput)
}

// Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
func (o ContainerPtrOutput) LivenessProbe() ProbePtrOutput {
	return o.ApplyT(func(v *Container) *Probe {
		if v == nil {
			return nil
		}
		return v.LivenessProbe
	}).(ProbePtrOutput)
}

// Name of the container specified as a DNS_LABEL. Each container must have a unique name (DNS_LABEL). Cannot be updated.
func (o ContainerPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Container) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated. +optional
func (o ContainerPtrOutput) Ports() ContainerPortArrayOutput {
	return o.ApplyT(func(v *Container) []ContainerPort {
		if v == nil {
			return nil
		}
		return v.Ports
	}).(ContainerPortArrayOutput)
}

// Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
func (o ContainerPtrOutput) ReadinessProbe() ProbePtrOutput {
	return o.ApplyT(func(v *Container) *Probe {
		if v == nil {
			return nil
		}
		return v.ReadinessProbe
	}).(ProbePtrOutput)
}

// Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources +optional
func (o ContainerPtrOutput) Resources() ResourceRequirementsPtrOutput {
	return o.ApplyT(func(v *Container) *ResourceRequirements {
		if v == nil {
			return nil
		}
		return v.Resources
	}).(ResourceRequirementsPtrOutput)
}

// Security options the pod should run with. More info: https://kubernetes.io/docs/concepts/policy/security-context/ More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ +optional
func (o ContainerPtrOutput) SecurityContext() SecurityContextPtrOutput {
	return o.ApplyT(func(v *Container) *SecurityContext {
		if v == nil {
			return nil
		}
		return v.SecurityContext
	}).(SecurityContextPtrOutput)
}

// Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false. +optional
func (o ContainerPtrOutput) Stdin() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Container) *bool {
		if v == nil {
			return nil
		}
		return v.Stdin
	}).(pulumi.BoolPtrOutput)
}

// Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false +optional
func (o ContainerPtrOutput) StdinOnce() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Container) *bool {
		if v == nil {
			return nil
		}
		return v.StdinOnce
	}).(pulumi.BoolPtrOutput)
}

// Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated. +optional
func (o ContainerPtrOutput) TerminationMessagePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Container) *string {
		if v == nil {
			return nil
		}
		return v.TerminationMessagePath
	}).(pulumi.StringPtrOutput)
}

// Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated. +optional
func (o ContainerPtrOutput) TerminationMessagePolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Container) *string {
		if v == nil {
			return nil
		}
		return v.TerminationMessagePolicy
	}).(pulumi.StringPtrOutput)
}

// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false. +optional
func (o ContainerPtrOutput) Tty() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Container) *bool {
		if v == nil {
			return nil
		}
		return v.Tty
	}).(pulumi.BoolPtrOutput)
}

// volumeDevices is the list of block devices to be used by the container. This is an alpha feature and may change in the future. +optional
func (o ContainerPtrOutput) VolumeDevices() VolumeDeviceArrayOutput {
	return o.ApplyT(func(v *Container) []VolumeDevice {
		if v == nil {
			return nil
		}
		return v.VolumeDevices
	}).(VolumeDeviceArrayOutput)
}

// Pod volumes to mount into the container's filesystem. Cannot be updated. +optional
func (o ContainerPtrOutput) VolumeMounts() VolumeMountArrayOutput {
	return o.ApplyT(func(v *Container) []VolumeMount {
		if v == nil {
			return nil
		}
		return v.VolumeMounts
	}).(VolumeMountArrayOutput)
}

// Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated. +optional
func (o ContainerPtrOutput) WorkingDir() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Container) *string {
		if v == nil {
			return nil
		}
		return v.WorkingDir
	}).(pulumi.StringPtrOutput)
}

type ContainerArrayOutput struct{ *pulumi.OutputState }

func (ContainerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Container)(nil)).Elem()
}

func (o ContainerArrayOutput) ToContainerArrayOutput() ContainerArrayOutput {
	return o
}

func (o ContainerArrayOutput) ToContainerArrayOutputWithContext(ctx context.Context) ContainerArrayOutput {
	return o
}

func (o ContainerArrayOutput) Index(i pulumi.IntInput) ContainerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Container {
		return vs[0].([]Container)[vs[1].(int)]
	}).(ContainerOutput)
}

// ContainerPort represents a network port in a single container.
type ContainerPort struct {
	// Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
	ContainerPort *int `pulumi:"containerPort"`
	// What host IP to bind the external port to. +optional
	HostIP *string `pulumi:"hostIP"`
	// Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this. +optional
	HostPort *int `pulumi:"hostPort"`
	// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. +optional
	Name *string `pulumi:"name"`
	// Protocol for port. Must be UDP or TCP. Defaults to "TCP". +optional
	Protocol *string `pulumi:"protocol"`
}

// ContainerPortInput is an input type that accepts ContainerPortArgs and ContainerPortOutput values.
// You can construct a concrete instance of `ContainerPortInput` via:
//
//          ContainerPortArgs{...}
type ContainerPortInput interface {
	pulumi.Input

	ToContainerPortOutput() ContainerPortOutput
	ToContainerPortOutputWithContext(context.Context) ContainerPortOutput
}

// ContainerPort represents a network port in a single container.
type ContainerPortArgs struct {
	// Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
	ContainerPort pulumi.IntPtrInput `pulumi:"containerPort"`
	// What host IP to bind the external port to. +optional
	HostIP pulumi.StringPtrInput `pulumi:"hostIP"`
	// Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this. +optional
	HostPort pulumi.IntPtrInput `pulumi:"hostPort"`
	// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. +optional
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Protocol for port. Must be UDP or TCP. Defaults to "TCP". +optional
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
}

func (ContainerPortArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerPort)(nil)).Elem()
}

func (i ContainerPortArgs) ToContainerPortOutput() ContainerPortOutput {
	return i.ToContainerPortOutputWithContext(context.Background())
}

func (i ContainerPortArgs) ToContainerPortOutputWithContext(ctx context.Context) ContainerPortOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerPortOutput)
}

// ContainerPortArrayInput is an input type that accepts ContainerPortArray and ContainerPortArrayOutput values.
// You can construct a concrete instance of `ContainerPortArrayInput` via:
//
//          ContainerPortArray{ ContainerPortArgs{...} }
type ContainerPortArrayInput interface {
	pulumi.Input

	ToContainerPortArrayOutput() ContainerPortArrayOutput
	ToContainerPortArrayOutputWithContext(context.Context) ContainerPortArrayOutput
}

type ContainerPortArray []ContainerPortInput

func (ContainerPortArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerPort)(nil)).Elem()
}

func (i ContainerPortArray) ToContainerPortArrayOutput() ContainerPortArrayOutput {
	return i.ToContainerPortArrayOutputWithContext(context.Background())
}

func (i ContainerPortArray) ToContainerPortArrayOutputWithContext(ctx context.Context) ContainerPortArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerPortArrayOutput)
}

// ContainerPort represents a network port in a single container.
type ContainerPortOutput struct{ *pulumi.OutputState }

func (ContainerPortOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerPort)(nil)).Elem()
}

func (o ContainerPortOutput) ToContainerPortOutput() ContainerPortOutput {
	return o
}

func (o ContainerPortOutput) ToContainerPortOutputWithContext(ctx context.Context) ContainerPortOutput {
	return o
}

// Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
func (o ContainerPortOutput) ContainerPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerPort) *int { return v.ContainerPort }).(pulumi.IntPtrOutput)
}

// What host IP to bind the external port to. +optional
func (o ContainerPortOutput) HostIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContainerPort) *string { return v.HostIP }).(pulumi.StringPtrOutput)
}

// Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this. +optional
func (o ContainerPortOutput) HostPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerPort) *int { return v.HostPort }).(pulumi.IntPtrOutput)
}

// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services. +optional
func (o ContainerPortOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContainerPort) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Protocol for port. Must be UDP or TCP. Defaults to "TCP". +optional
func (o ContainerPortOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContainerPort) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

type ContainerPortArrayOutput struct{ *pulumi.OutputState }

func (ContainerPortArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerPort)(nil)).Elem()
}

func (o ContainerPortArrayOutput) ToContainerPortArrayOutput() ContainerPortArrayOutput {
	return o
}

func (o ContainerPortArrayOutput) ToContainerPortArrayOutputWithContext(ctx context.Context) ContainerPortArrayOutput {
	return o
}

func (o ContainerPortArrayOutput) Index(i pulumi.IntInput) ContainerPortOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContainerPort {
		return vs[0].([]ContainerPort)[vs[1].(int)]
	}).(ContainerPortOutput)
}

// DomainMappingCondition contains state information for a DomainMapping.
type DomainMappingCondition struct {
	// Last time the condition transitioned from one status to another. +optional
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// Human readable message indicating details about the current status. +optional
	Message *string `pulumi:"message"`
	// One-word CamelCase reason for the condition's current status. +optional
	Reason *string `pulumi:"reason"`
	// How to interpret failures of this condition, one of Error, Warning, Info +optional
	Severity *string `pulumi:"severity"`
	// Status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// Type of domain mapping condition.
	Type *string `pulumi:"type"`
}

// DomainMappingConditionInput is an input type that accepts DomainMappingConditionArgs and DomainMappingConditionOutput values.
// You can construct a concrete instance of `DomainMappingConditionInput` via:
//
//          DomainMappingConditionArgs{...}
type DomainMappingConditionInput interface {
	pulumi.Input

	ToDomainMappingConditionOutput() DomainMappingConditionOutput
	ToDomainMappingConditionOutputWithContext(context.Context) DomainMappingConditionOutput
}

// DomainMappingCondition contains state information for a DomainMapping.
type DomainMappingConditionArgs struct {
	// Last time the condition transitioned from one status to another. +optional
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// Human readable message indicating details about the current status. +optional
	Message pulumi.StringPtrInput `pulumi:"message"`
	// One-word CamelCase reason for the condition's current status. +optional
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// How to interpret failures of this condition, one of Error, Warning, Info +optional
	Severity pulumi.StringPtrInput `pulumi:"severity"`
	// Status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// Type of domain mapping condition.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (DomainMappingConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainMappingCondition)(nil)).Elem()
}

func (i DomainMappingConditionArgs) ToDomainMappingConditionOutput() DomainMappingConditionOutput {
	return i.ToDomainMappingConditionOutputWithContext(context.Background())
}

func (i DomainMappingConditionArgs) ToDomainMappingConditionOutputWithContext(ctx context.Context) DomainMappingConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainMappingConditionOutput)
}

// DomainMappingConditionArrayInput is an input type that accepts DomainMappingConditionArray and DomainMappingConditionArrayOutput values.
// You can construct a concrete instance of `DomainMappingConditionArrayInput` via:
//
//          DomainMappingConditionArray{ DomainMappingConditionArgs{...} }
type DomainMappingConditionArrayInput interface {
	pulumi.Input

	ToDomainMappingConditionArrayOutput() DomainMappingConditionArrayOutput
	ToDomainMappingConditionArrayOutputWithContext(context.Context) DomainMappingConditionArrayOutput
}

type DomainMappingConditionArray []DomainMappingConditionInput

func (DomainMappingConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DomainMappingCondition)(nil)).Elem()
}

func (i DomainMappingConditionArray) ToDomainMappingConditionArrayOutput() DomainMappingConditionArrayOutput {
	return i.ToDomainMappingConditionArrayOutputWithContext(context.Background())
}

func (i DomainMappingConditionArray) ToDomainMappingConditionArrayOutputWithContext(ctx context.Context) DomainMappingConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainMappingConditionArrayOutput)
}

// DomainMappingCondition contains state information for a DomainMapping.
type DomainMappingConditionOutput struct{ *pulumi.OutputState }

func (DomainMappingConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainMappingCondition)(nil)).Elem()
}

func (o DomainMappingConditionOutput) ToDomainMappingConditionOutput() DomainMappingConditionOutput {
	return o
}

func (o DomainMappingConditionOutput) ToDomainMappingConditionOutputWithContext(ctx context.Context) DomainMappingConditionOutput {
	return o
}

// Last time the condition transitioned from one status to another. +optional
func (o DomainMappingConditionOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainMappingCondition) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// Human readable message indicating details about the current status. +optional
func (o DomainMappingConditionOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainMappingCondition) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// One-word CamelCase reason for the condition's current status. +optional
func (o DomainMappingConditionOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainMappingCondition) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// How to interpret failures of this condition, one of Error, Warning, Info +optional
func (o DomainMappingConditionOutput) Severity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainMappingCondition) *string { return v.Severity }).(pulumi.StringPtrOutput)
}

// Status of the condition, one of True, False, Unknown.
func (o DomainMappingConditionOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainMappingCondition) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// Type of domain mapping condition.
func (o DomainMappingConditionOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainMappingCondition) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type DomainMappingConditionArrayOutput struct{ *pulumi.OutputState }

func (DomainMappingConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DomainMappingCondition)(nil)).Elem()
}

func (o DomainMappingConditionArrayOutput) ToDomainMappingConditionArrayOutput() DomainMappingConditionArrayOutput {
	return o
}

func (o DomainMappingConditionArrayOutput) ToDomainMappingConditionArrayOutputWithContext(ctx context.Context) DomainMappingConditionArrayOutput {
	return o
}

func (o DomainMappingConditionArrayOutput) Index(i pulumi.IntInput) DomainMappingConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DomainMappingCondition {
		return vs[0].([]DomainMappingCondition)[vs[1].(int)]
	}).(DomainMappingConditionOutput)
}

// The desired state of the Domain Mapping.
type DomainMappingSpec struct {
	// The mode of the certificate.
	CertificateMode *string `pulumi:"certificateMode"`
	// If set, the mapping will override any mapping set before this spec was set. It is recommended that the user leaves this empty to receive an error warning about a potential conflict and only set it once the respective UI has given such a warning.
	ForceOverride *bool `pulumi:"forceOverride"`
	// The name of the Knative Route that this DomainMapping applies to. The route must exist.
	RouteName *string `pulumi:"routeName"`
}

// DomainMappingSpecInput is an input type that accepts DomainMappingSpecArgs and DomainMappingSpecOutput values.
// You can construct a concrete instance of `DomainMappingSpecInput` via:
//
//          DomainMappingSpecArgs{...}
type DomainMappingSpecInput interface {
	pulumi.Input

	ToDomainMappingSpecOutput() DomainMappingSpecOutput
	ToDomainMappingSpecOutputWithContext(context.Context) DomainMappingSpecOutput
}

// The desired state of the Domain Mapping.
type DomainMappingSpecArgs struct {
	// The mode of the certificate.
	CertificateMode pulumi.StringPtrInput `pulumi:"certificateMode"`
	// If set, the mapping will override any mapping set before this spec was set. It is recommended that the user leaves this empty to receive an error warning about a potential conflict and only set it once the respective UI has given such a warning.
	ForceOverride pulumi.BoolPtrInput `pulumi:"forceOverride"`
	// The name of the Knative Route that this DomainMapping applies to. The route must exist.
	RouteName pulumi.StringPtrInput `pulumi:"routeName"`
}

func (DomainMappingSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainMappingSpec)(nil)).Elem()
}

func (i DomainMappingSpecArgs) ToDomainMappingSpecOutput() DomainMappingSpecOutput {
	return i.ToDomainMappingSpecOutputWithContext(context.Background())
}

func (i DomainMappingSpecArgs) ToDomainMappingSpecOutputWithContext(ctx context.Context) DomainMappingSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainMappingSpecOutput)
}

func (i DomainMappingSpecArgs) ToDomainMappingSpecPtrOutput() DomainMappingSpecPtrOutput {
	return i.ToDomainMappingSpecPtrOutputWithContext(context.Background())
}

func (i DomainMappingSpecArgs) ToDomainMappingSpecPtrOutputWithContext(ctx context.Context) DomainMappingSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainMappingSpecOutput).ToDomainMappingSpecPtrOutputWithContext(ctx)
}

// DomainMappingSpecPtrInput is an input type that accepts DomainMappingSpecArgs, DomainMappingSpecPtr and DomainMappingSpecPtrOutput values.
// You can construct a concrete instance of `DomainMappingSpecPtrInput` via:
//
//          DomainMappingSpecArgs{...}
//
//  or:
//
//          nil
type DomainMappingSpecPtrInput interface {
	pulumi.Input

	ToDomainMappingSpecPtrOutput() DomainMappingSpecPtrOutput
	ToDomainMappingSpecPtrOutputWithContext(context.Context) DomainMappingSpecPtrOutput
}

type domainMappingSpecPtrType DomainMappingSpecArgs

func DomainMappingSpecPtr(v *DomainMappingSpecArgs) DomainMappingSpecPtrInput {
	return (*domainMappingSpecPtrType)(v)
}

func (*domainMappingSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainMappingSpec)(nil)).Elem()
}

func (i *domainMappingSpecPtrType) ToDomainMappingSpecPtrOutput() DomainMappingSpecPtrOutput {
	return i.ToDomainMappingSpecPtrOutputWithContext(context.Background())
}

func (i *domainMappingSpecPtrType) ToDomainMappingSpecPtrOutputWithContext(ctx context.Context) DomainMappingSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainMappingSpecPtrOutput)
}

// The desired state of the Domain Mapping.
type DomainMappingSpecOutput struct{ *pulumi.OutputState }

func (DomainMappingSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainMappingSpec)(nil)).Elem()
}

func (o DomainMappingSpecOutput) ToDomainMappingSpecOutput() DomainMappingSpecOutput {
	return o
}

func (o DomainMappingSpecOutput) ToDomainMappingSpecOutputWithContext(ctx context.Context) DomainMappingSpecOutput {
	return o
}

func (o DomainMappingSpecOutput) ToDomainMappingSpecPtrOutput() DomainMappingSpecPtrOutput {
	return o.ToDomainMappingSpecPtrOutputWithContext(context.Background())
}

func (o DomainMappingSpecOutput) ToDomainMappingSpecPtrOutputWithContext(ctx context.Context) DomainMappingSpecPtrOutput {
	return o.ApplyT(func(v DomainMappingSpec) *DomainMappingSpec {
		return &v
	}).(DomainMappingSpecPtrOutput)
}

// The mode of the certificate.
func (o DomainMappingSpecOutput) CertificateMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainMappingSpec) *string { return v.CertificateMode }).(pulumi.StringPtrOutput)
}

// If set, the mapping will override any mapping set before this spec was set. It is recommended that the user leaves this empty to receive an error warning about a potential conflict and only set it once the respective UI has given such a warning.
func (o DomainMappingSpecOutput) ForceOverride() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DomainMappingSpec) *bool { return v.ForceOverride }).(pulumi.BoolPtrOutput)
}

// The name of the Knative Route that this DomainMapping applies to. The route must exist.
func (o DomainMappingSpecOutput) RouteName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainMappingSpec) *string { return v.RouteName }).(pulumi.StringPtrOutput)
}

type DomainMappingSpecPtrOutput struct{ *pulumi.OutputState }

func (DomainMappingSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainMappingSpec)(nil)).Elem()
}

func (o DomainMappingSpecPtrOutput) ToDomainMappingSpecPtrOutput() DomainMappingSpecPtrOutput {
	return o
}

func (o DomainMappingSpecPtrOutput) ToDomainMappingSpecPtrOutputWithContext(ctx context.Context) DomainMappingSpecPtrOutput {
	return o
}

func (o DomainMappingSpecPtrOutput) Elem() DomainMappingSpecOutput {
	return o.ApplyT(func(v *DomainMappingSpec) DomainMappingSpec { return *v }).(DomainMappingSpecOutput)
}

// The mode of the certificate.
func (o DomainMappingSpecPtrOutput) CertificateMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainMappingSpec) *string {
		if v == nil {
			return nil
		}
		return v.CertificateMode
	}).(pulumi.StringPtrOutput)
}

// If set, the mapping will override any mapping set before this spec was set. It is recommended that the user leaves this empty to receive an error warning about a potential conflict and only set it once the respective UI has given such a warning.
func (o DomainMappingSpecPtrOutput) ForceOverride() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DomainMappingSpec) *bool {
		if v == nil {
			return nil
		}
		return v.ForceOverride
	}).(pulumi.BoolPtrOutput)
}

// The name of the Knative Route that this DomainMapping applies to. The route must exist.
func (o DomainMappingSpecPtrOutput) RouteName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainMappingSpec) *string {
		if v == nil {
			return nil
		}
		return v.RouteName
	}).(pulumi.StringPtrOutput)
}

// The current state of the Domain Mapping.
type DomainMappingStatus struct {
	// Array of observed DomainMappingConditions, indicating the current state of the DomainMapping.
	Conditions []DomainMappingCondition `pulumi:"conditions"`
	// The name of the route that the mapping currently points to.
	MappedRouteName *string `pulumi:"mappedRouteName"`
	// ObservedGeneration is the 'Generation' of the DomainMapping that was last processed by the controller. Clients polling for completed reconciliation should poll until observedGeneration = metadata.generation and the Ready condition's status is True or False.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// The resource records required to configure this domain mapping. These records must be added to the domain's DNS configuration in order to serve the application via this domain mapping.
	ResourceRecords []ResourceRecord `pulumi:"resourceRecords"`
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported Holds the URL that will serve the traffic of the DomainMapping. +optional
	Url *string `pulumi:"url"`
}

// DomainMappingStatusInput is an input type that accepts DomainMappingStatusArgs and DomainMappingStatusOutput values.
// You can construct a concrete instance of `DomainMappingStatusInput` via:
//
//          DomainMappingStatusArgs{...}
type DomainMappingStatusInput interface {
	pulumi.Input

	ToDomainMappingStatusOutput() DomainMappingStatusOutput
	ToDomainMappingStatusOutputWithContext(context.Context) DomainMappingStatusOutput
}

// The current state of the Domain Mapping.
type DomainMappingStatusArgs struct {
	// Array of observed DomainMappingConditions, indicating the current state of the DomainMapping.
	Conditions DomainMappingConditionArrayInput `pulumi:"conditions"`
	// The name of the route that the mapping currently points to.
	MappedRouteName pulumi.StringPtrInput `pulumi:"mappedRouteName"`
	// ObservedGeneration is the 'Generation' of the DomainMapping that was last processed by the controller. Clients polling for completed reconciliation should poll until observedGeneration = metadata.generation and the Ready condition's status is True or False.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// The resource records required to configure this domain mapping. These records must be added to the domain's DNS configuration in order to serve the application via this domain mapping.
	ResourceRecords ResourceRecordArrayInput `pulumi:"resourceRecords"`
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported Holds the URL that will serve the traffic of the DomainMapping. +optional
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (DomainMappingStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainMappingStatus)(nil)).Elem()
}

func (i DomainMappingStatusArgs) ToDomainMappingStatusOutput() DomainMappingStatusOutput {
	return i.ToDomainMappingStatusOutputWithContext(context.Background())
}

func (i DomainMappingStatusArgs) ToDomainMappingStatusOutputWithContext(ctx context.Context) DomainMappingStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainMappingStatusOutput)
}

func (i DomainMappingStatusArgs) ToDomainMappingStatusPtrOutput() DomainMappingStatusPtrOutput {
	return i.ToDomainMappingStatusPtrOutputWithContext(context.Background())
}

func (i DomainMappingStatusArgs) ToDomainMappingStatusPtrOutputWithContext(ctx context.Context) DomainMappingStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainMappingStatusOutput).ToDomainMappingStatusPtrOutputWithContext(ctx)
}

// DomainMappingStatusPtrInput is an input type that accepts DomainMappingStatusArgs, DomainMappingStatusPtr and DomainMappingStatusPtrOutput values.
// You can construct a concrete instance of `DomainMappingStatusPtrInput` via:
//
//          DomainMappingStatusArgs{...}
//
//  or:
//
//          nil
type DomainMappingStatusPtrInput interface {
	pulumi.Input

	ToDomainMappingStatusPtrOutput() DomainMappingStatusPtrOutput
	ToDomainMappingStatusPtrOutputWithContext(context.Context) DomainMappingStatusPtrOutput
}

type domainMappingStatusPtrType DomainMappingStatusArgs

func DomainMappingStatusPtr(v *DomainMappingStatusArgs) DomainMappingStatusPtrInput {
	return (*domainMappingStatusPtrType)(v)
}

func (*domainMappingStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainMappingStatus)(nil)).Elem()
}

func (i *domainMappingStatusPtrType) ToDomainMappingStatusPtrOutput() DomainMappingStatusPtrOutput {
	return i.ToDomainMappingStatusPtrOutputWithContext(context.Background())
}

func (i *domainMappingStatusPtrType) ToDomainMappingStatusPtrOutputWithContext(ctx context.Context) DomainMappingStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainMappingStatusPtrOutput)
}

// The current state of the Domain Mapping.
type DomainMappingStatusOutput struct{ *pulumi.OutputState }

func (DomainMappingStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainMappingStatus)(nil)).Elem()
}

func (o DomainMappingStatusOutput) ToDomainMappingStatusOutput() DomainMappingStatusOutput {
	return o
}

func (o DomainMappingStatusOutput) ToDomainMappingStatusOutputWithContext(ctx context.Context) DomainMappingStatusOutput {
	return o
}

func (o DomainMappingStatusOutput) ToDomainMappingStatusPtrOutput() DomainMappingStatusPtrOutput {
	return o.ToDomainMappingStatusPtrOutputWithContext(context.Background())
}

func (o DomainMappingStatusOutput) ToDomainMappingStatusPtrOutputWithContext(ctx context.Context) DomainMappingStatusPtrOutput {
	return o.ApplyT(func(v DomainMappingStatus) *DomainMappingStatus {
		return &v
	}).(DomainMappingStatusPtrOutput)
}

// Array of observed DomainMappingConditions, indicating the current state of the DomainMapping.
func (o DomainMappingStatusOutput) Conditions() DomainMappingConditionArrayOutput {
	return o.ApplyT(func(v DomainMappingStatus) []DomainMappingCondition { return v.Conditions }).(DomainMappingConditionArrayOutput)
}

// The name of the route that the mapping currently points to.
func (o DomainMappingStatusOutput) MappedRouteName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainMappingStatus) *string { return v.MappedRouteName }).(pulumi.StringPtrOutput)
}

// ObservedGeneration is the 'Generation' of the DomainMapping that was last processed by the controller. Clients polling for completed reconciliation should poll until observedGeneration = metadata.generation and the Ready condition's status is True or False.
func (o DomainMappingStatusOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DomainMappingStatus) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// The resource records required to configure this domain mapping. These records must be added to the domain's DNS configuration in order to serve the application via this domain mapping.
func (o DomainMappingStatusOutput) ResourceRecords() ResourceRecordArrayOutput {
	return o.ApplyT(func(v DomainMappingStatus) []ResourceRecord { return v.ResourceRecords }).(ResourceRecordArrayOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported Holds the URL that will serve the traffic of the DomainMapping. +optional
func (o DomainMappingStatusOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainMappingStatus) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type DomainMappingStatusPtrOutput struct{ *pulumi.OutputState }

func (DomainMappingStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainMappingStatus)(nil)).Elem()
}

func (o DomainMappingStatusPtrOutput) ToDomainMappingStatusPtrOutput() DomainMappingStatusPtrOutput {
	return o
}

func (o DomainMappingStatusPtrOutput) ToDomainMappingStatusPtrOutputWithContext(ctx context.Context) DomainMappingStatusPtrOutput {
	return o
}

func (o DomainMappingStatusPtrOutput) Elem() DomainMappingStatusOutput {
	return o.ApplyT(func(v *DomainMappingStatus) DomainMappingStatus { return *v }).(DomainMappingStatusOutput)
}

// Array of observed DomainMappingConditions, indicating the current state of the DomainMapping.
func (o DomainMappingStatusPtrOutput) Conditions() DomainMappingConditionArrayOutput {
	return o.ApplyT(func(v *DomainMappingStatus) []DomainMappingCondition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(DomainMappingConditionArrayOutput)
}

// The name of the route that the mapping currently points to.
func (o DomainMappingStatusPtrOutput) MappedRouteName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainMappingStatus) *string {
		if v == nil {
			return nil
		}
		return v.MappedRouteName
	}).(pulumi.StringPtrOutput)
}

// ObservedGeneration is the 'Generation' of the DomainMapping that was last processed by the controller. Clients polling for completed reconciliation should poll until observedGeneration = metadata.generation and the Ready condition's status is True or False.
func (o DomainMappingStatusPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DomainMappingStatus) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

// The resource records required to configure this domain mapping. These records must be added to the domain's DNS configuration in order to serve the application via this domain mapping.
func (o DomainMappingStatusPtrOutput) ResourceRecords() ResourceRecordArrayOutput {
	return o.ApplyT(func(v *DomainMappingStatus) []ResourceRecord {
		if v == nil {
			return nil
		}
		return v.ResourceRecords
	}).(ResourceRecordArrayOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported Holds the URL that will serve the traffic of the DomainMapping. +optional
func (o DomainMappingStatusPtrOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainMappingStatus) *string {
		if v == nil {
			return nil
		}
		return v.Url
	}).(pulumi.StringPtrOutput)
}

// EnvFromSource represents the source of a set of ConfigMaps
type EnvFromSource struct {
	// The ConfigMap to select from +optional
	ConfigMapRef *ConfigMapEnvSource `pulumi:"configMapRef"`
	// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. +optional
	Prefix *string `pulumi:"prefix"`
	// The Secret to select from +optional
	SecretRef *SecretEnvSource `pulumi:"secretRef"`
}

// EnvFromSourceInput is an input type that accepts EnvFromSourceArgs and EnvFromSourceOutput values.
// You can construct a concrete instance of `EnvFromSourceInput` via:
//
//          EnvFromSourceArgs{...}
type EnvFromSourceInput interface {
	pulumi.Input

	ToEnvFromSourceOutput() EnvFromSourceOutput
	ToEnvFromSourceOutputWithContext(context.Context) EnvFromSourceOutput
}

// EnvFromSource represents the source of a set of ConfigMaps
type EnvFromSourceArgs struct {
	// The ConfigMap to select from +optional
	ConfigMapRef ConfigMapEnvSourcePtrInput `pulumi:"configMapRef"`
	// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. +optional
	Prefix pulumi.StringPtrInput `pulumi:"prefix"`
	// The Secret to select from +optional
	SecretRef SecretEnvSourcePtrInput `pulumi:"secretRef"`
}

func (EnvFromSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvFromSource)(nil)).Elem()
}

func (i EnvFromSourceArgs) ToEnvFromSourceOutput() EnvFromSourceOutput {
	return i.ToEnvFromSourceOutputWithContext(context.Background())
}

func (i EnvFromSourceArgs) ToEnvFromSourceOutputWithContext(ctx context.Context) EnvFromSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvFromSourceOutput)
}

// EnvFromSourceArrayInput is an input type that accepts EnvFromSourceArray and EnvFromSourceArrayOutput values.
// You can construct a concrete instance of `EnvFromSourceArrayInput` via:
//
//          EnvFromSourceArray{ EnvFromSourceArgs{...} }
type EnvFromSourceArrayInput interface {
	pulumi.Input

	ToEnvFromSourceArrayOutput() EnvFromSourceArrayOutput
	ToEnvFromSourceArrayOutputWithContext(context.Context) EnvFromSourceArrayOutput
}

type EnvFromSourceArray []EnvFromSourceInput

func (EnvFromSourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EnvFromSource)(nil)).Elem()
}

func (i EnvFromSourceArray) ToEnvFromSourceArrayOutput() EnvFromSourceArrayOutput {
	return i.ToEnvFromSourceArrayOutputWithContext(context.Background())
}

func (i EnvFromSourceArray) ToEnvFromSourceArrayOutputWithContext(ctx context.Context) EnvFromSourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvFromSourceArrayOutput)
}

// EnvFromSource represents the source of a set of ConfigMaps
type EnvFromSourceOutput struct{ *pulumi.OutputState }

func (EnvFromSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvFromSource)(nil)).Elem()
}

func (o EnvFromSourceOutput) ToEnvFromSourceOutput() EnvFromSourceOutput {
	return o
}

func (o EnvFromSourceOutput) ToEnvFromSourceOutputWithContext(ctx context.Context) EnvFromSourceOutput {
	return o
}

// The ConfigMap to select from +optional
func (o EnvFromSourceOutput) ConfigMapRef() ConfigMapEnvSourcePtrOutput {
	return o.ApplyT(func(v EnvFromSource) *ConfigMapEnvSource { return v.ConfigMapRef }).(ConfigMapEnvSourcePtrOutput)
}

// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. +optional
func (o EnvFromSourceOutput) Prefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvFromSource) *string { return v.Prefix }).(pulumi.StringPtrOutput)
}

// The Secret to select from +optional
func (o EnvFromSourceOutput) SecretRef() SecretEnvSourcePtrOutput {
	return o.ApplyT(func(v EnvFromSource) *SecretEnvSource { return v.SecretRef }).(SecretEnvSourcePtrOutput)
}

type EnvFromSourceArrayOutput struct{ *pulumi.OutputState }

func (EnvFromSourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EnvFromSource)(nil)).Elem()
}

func (o EnvFromSourceArrayOutput) ToEnvFromSourceArrayOutput() EnvFromSourceArrayOutput {
	return o
}

func (o EnvFromSourceArrayOutput) ToEnvFromSourceArrayOutputWithContext(ctx context.Context) EnvFromSourceArrayOutput {
	return o
}

func (o EnvFromSourceArrayOutput) Index(i pulumi.IntInput) EnvFromSourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) EnvFromSource {
		return vs[0].([]EnvFromSource)[vs[1].(int)]
	}).(EnvFromSourceOutput)
}

// EnvVar represents an environment variable present in a Container.
type EnvVar struct {
	// Name of the environment variable. Must be a C_IDENTIFIER.
	Name *string `pulumi:"name"`
	// Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any route environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "". +optional
	Value *string `pulumi:"value"`
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported Source for the environment variable's value. Cannot be used if value is not empty. +optional
	ValueFrom *EnvVarSource `pulumi:"valueFrom"`
}

// EnvVarInput is an input type that accepts EnvVarArgs and EnvVarOutput values.
// You can construct a concrete instance of `EnvVarInput` via:
//
//          EnvVarArgs{...}
type EnvVarInput interface {
	pulumi.Input

	ToEnvVarOutput() EnvVarOutput
	ToEnvVarOutputWithContext(context.Context) EnvVarOutput
}

// EnvVar represents an environment variable present in a Container.
type EnvVarArgs struct {
	// Name of the environment variable. Must be a C_IDENTIFIER.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any route environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "". +optional
	Value pulumi.StringPtrInput `pulumi:"value"`
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported Source for the environment variable's value. Cannot be used if value is not empty. +optional
	ValueFrom EnvVarSourcePtrInput `pulumi:"valueFrom"`
}

func (EnvVarArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvVar)(nil)).Elem()
}

func (i EnvVarArgs) ToEnvVarOutput() EnvVarOutput {
	return i.ToEnvVarOutputWithContext(context.Background())
}

func (i EnvVarArgs) ToEnvVarOutputWithContext(ctx context.Context) EnvVarOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvVarOutput)
}

// EnvVarArrayInput is an input type that accepts EnvVarArray and EnvVarArrayOutput values.
// You can construct a concrete instance of `EnvVarArrayInput` via:
//
//          EnvVarArray{ EnvVarArgs{...} }
type EnvVarArrayInput interface {
	pulumi.Input

	ToEnvVarArrayOutput() EnvVarArrayOutput
	ToEnvVarArrayOutputWithContext(context.Context) EnvVarArrayOutput
}

type EnvVarArray []EnvVarInput

func (EnvVarArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EnvVar)(nil)).Elem()
}

func (i EnvVarArray) ToEnvVarArrayOutput() EnvVarArrayOutput {
	return i.ToEnvVarArrayOutputWithContext(context.Background())
}

func (i EnvVarArray) ToEnvVarArrayOutputWithContext(ctx context.Context) EnvVarArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvVarArrayOutput)
}

// EnvVar represents an environment variable present in a Container.
type EnvVarOutput struct{ *pulumi.OutputState }

func (EnvVarOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvVar)(nil)).Elem()
}

func (o EnvVarOutput) ToEnvVarOutput() EnvVarOutput {
	return o
}

func (o EnvVarOutput) ToEnvVarOutputWithContext(ctx context.Context) EnvVarOutput {
	return o
}

// Name of the environment variable. Must be a C_IDENTIFIER.
func (o EnvVarOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvVar) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any route environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "". +optional
func (o EnvVarOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvVar) *string { return v.Value }).(pulumi.StringPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported Source for the environment variable's value. Cannot be used if value is not empty. +optional
func (o EnvVarOutput) ValueFrom() EnvVarSourcePtrOutput {
	return o.ApplyT(func(v EnvVar) *EnvVarSource { return v.ValueFrom }).(EnvVarSourcePtrOutput)
}

type EnvVarArrayOutput struct{ *pulumi.OutputState }

func (EnvVarArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EnvVar)(nil)).Elem()
}

func (o EnvVarArrayOutput) ToEnvVarArrayOutput() EnvVarArrayOutput {
	return o
}

func (o EnvVarArrayOutput) ToEnvVarArrayOutputWithContext(ctx context.Context) EnvVarArrayOutput {
	return o
}

func (o EnvVarArrayOutput) Index(i pulumi.IntInput) EnvVarOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) EnvVar {
		return vs[0].([]EnvVar)[vs[1].(int)]
	}).(EnvVarOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported EnvVarSource represents a source for the value of an EnvVar.
type EnvVarSource struct {
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported Selects a key of a ConfigMap. +optional
	ConfigMapKeyRef *ConfigMapKeySelector `pulumi:"configMapKeyRef"`
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported Selects a key of a secret in the pod's namespace +optional
	SecretKeyRef *SecretKeySelector `pulumi:"secretKeyRef"`
}

// EnvVarSourceInput is an input type that accepts EnvVarSourceArgs and EnvVarSourceOutput values.
// You can construct a concrete instance of `EnvVarSourceInput` via:
//
//          EnvVarSourceArgs{...}
type EnvVarSourceInput interface {
	pulumi.Input

	ToEnvVarSourceOutput() EnvVarSourceOutput
	ToEnvVarSourceOutputWithContext(context.Context) EnvVarSourceOutput
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported EnvVarSource represents a source for the value of an EnvVar.
type EnvVarSourceArgs struct {
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported Selects a key of a ConfigMap. +optional
	ConfigMapKeyRef ConfigMapKeySelectorPtrInput `pulumi:"configMapKeyRef"`
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported Selects a key of a secret in the pod's namespace +optional
	SecretKeyRef SecretKeySelectorPtrInput `pulumi:"secretKeyRef"`
}

func (EnvVarSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvVarSource)(nil)).Elem()
}

func (i EnvVarSourceArgs) ToEnvVarSourceOutput() EnvVarSourceOutput {
	return i.ToEnvVarSourceOutputWithContext(context.Background())
}

func (i EnvVarSourceArgs) ToEnvVarSourceOutputWithContext(ctx context.Context) EnvVarSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvVarSourceOutput)
}

func (i EnvVarSourceArgs) ToEnvVarSourcePtrOutput() EnvVarSourcePtrOutput {
	return i.ToEnvVarSourcePtrOutputWithContext(context.Background())
}

func (i EnvVarSourceArgs) ToEnvVarSourcePtrOutputWithContext(ctx context.Context) EnvVarSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvVarSourceOutput).ToEnvVarSourcePtrOutputWithContext(ctx)
}

// EnvVarSourcePtrInput is an input type that accepts EnvVarSourceArgs, EnvVarSourcePtr and EnvVarSourcePtrOutput values.
// You can construct a concrete instance of `EnvVarSourcePtrInput` via:
//
//          EnvVarSourceArgs{...}
//
//  or:
//
//          nil
type EnvVarSourcePtrInput interface {
	pulumi.Input

	ToEnvVarSourcePtrOutput() EnvVarSourcePtrOutput
	ToEnvVarSourcePtrOutputWithContext(context.Context) EnvVarSourcePtrOutput
}

type envVarSourcePtrType EnvVarSourceArgs

func EnvVarSourcePtr(v *EnvVarSourceArgs) EnvVarSourcePtrInput {
	return (*envVarSourcePtrType)(v)
}

func (*envVarSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EnvVarSource)(nil)).Elem()
}

func (i *envVarSourcePtrType) ToEnvVarSourcePtrOutput() EnvVarSourcePtrOutput {
	return i.ToEnvVarSourcePtrOutputWithContext(context.Background())
}

func (i *envVarSourcePtrType) ToEnvVarSourcePtrOutputWithContext(ctx context.Context) EnvVarSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvVarSourcePtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported EnvVarSource represents a source for the value of an EnvVar.
type EnvVarSourceOutput struct{ *pulumi.OutputState }

func (EnvVarSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvVarSource)(nil)).Elem()
}

func (o EnvVarSourceOutput) ToEnvVarSourceOutput() EnvVarSourceOutput {
	return o
}

func (o EnvVarSourceOutput) ToEnvVarSourceOutputWithContext(ctx context.Context) EnvVarSourceOutput {
	return o
}

func (o EnvVarSourceOutput) ToEnvVarSourcePtrOutput() EnvVarSourcePtrOutput {
	return o.ToEnvVarSourcePtrOutputWithContext(context.Background())
}

func (o EnvVarSourceOutput) ToEnvVarSourcePtrOutputWithContext(ctx context.Context) EnvVarSourcePtrOutput {
	return o.ApplyT(func(v EnvVarSource) *EnvVarSource {
		return &v
	}).(EnvVarSourcePtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported Selects a key of a ConfigMap. +optional
func (o EnvVarSourceOutput) ConfigMapKeyRef() ConfigMapKeySelectorPtrOutput {
	return o.ApplyT(func(v EnvVarSource) *ConfigMapKeySelector { return v.ConfigMapKeyRef }).(ConfigMapKeySelectorPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported Selects a key of a secret in the pod's namespace +optional
func (o EnvVarSourceOutput) SecretKeyRef() SecretKeySelectorPtrOutput {
	return o.ApplyT(func(v EnvVarSource) *SecretKeySelector { return v.SecretKeyRef }).(SecretKeySelectorPtrOutput)
}

type EnvVarSourcePtrOutput struct{ *pulumi.OutputState }

func (EnvVarSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EnvVarSource)(nil)).Elem()
}

func (o EnvVarSourcePtrOutput) ToEnvVarSourcePtrOutput() EnvVarSourcePtrOutput {
	return o
}

func (o EnvVarSourcePtrOutput) ToEnvVarSourcePtrOutputWithContext(ctx context.Context) EnvVarSourcePtrOutput {
	return o
}

func (o EnvVarSourcePtrOutput) Elem() EnvVarSourceOutput {
	return o.ApplyT(func(v *EnvVarSource) EnvVarSource { return *v }).(EnvVarSourceOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported Selects a key of a ConfigMap. +optional
func (o EnvVarSourcePtrOutput) ConfigMapKeyRef() ConfigMapKeySelectorPtrOutput {
	return o.ApplyT(func(v *EnvVarSource) *ConfigMapKeySelector {
		if v == nil {
			return nil
		}
		return v.ConfigMapKeyRef
	}).(ConfigMapKeySelectorPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported Selects a key of a secret in the pod's namespace +optional
func (o EnvVarSourcePtrOutput) SecretKeyRef() SecretKeySelectorPtrOutput {
	return o.ApplyT(func(v *EnvVarSource) *SecretKeySelector {
		if v == nil {
			return nil
		}
		return v.SecretKeyRef
	}).(SecretKeySelectorPtrOutput)
}

// ExecAction describes a "run in container" action.
type ExecAction struct {
	// Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. +optional
	Command []string `pulumi:"command"`
}

// ExecActionInput is an input type that accepts ExecActionArgs and ExecActionOutput values.
// You can construct a concrete instance of `ExecActionInput` via:
//
//          ExecActionArgs{...}
type ExecActionInput interface {
	pulumi.Input

	ToExecActionOutput() ExecActionOutput
	ToExecActionOutputWithContext(context.Context) ExecActionOutput
}

// ExecAction describes a "run in container" action.
type ExecActionArgs struct {
	// Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. +optional
	Command pulumi.StringArrayInput `pulumi:"command"`
}

func (ExecActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ExecAction)(nil)).Elem()
}

func (i ExecActionArgs) ToExecActionOutput() ExecActionOutput {
	return i.ToExecActionOutputWithContext(context.Background())
}

func (i ExecActionArgs) ToExecActionOutputWithContext(ctx context.Context) ExecActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExecActionOutput)
}

func (i ExecActionArgs) ToExecActionPtrOutput() ExecActionPtrOutput {
	return i.ToExecActionPtrOutputWithContext(context.Background())
}

func (i ExecActionArgs) ToExecActionPtrOutputWithContext(ctx context.Context) ExecActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExecActionOutput).ToExecActionPtrOutputWithContext(ctx)
}

// ExecActionPtrInput is an input type that accepts ExecActionArgs, ExecActionPtr and ExecActionPtrOutput values.
// You can construct a concrete instance of `ExecActionPtrInput` via:
//
//          ExecActionArgs{...}
//
//  or:
//
//          nil
type ExecActionPtrInput interface {
	pulumi.Input

	ToExecActionPtrOutput() ExecActionPtrOutput
	ToExecActionPtrOutputWithContext(context.Context) ExecActionPtrOutput
}

type execActionPtrType ExecActionArgs

func ExecActionPtr(v *ExecActionArgs) ExecActionPtrInput {
	return (*execActionPtrType)(v)
}

func (*execActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ExecAction)(nil)).Elem()
}

func (i *execActionPtrType) ToExecActionPtrOutput() ExecActionPtrOutput {
	return i.ToExecActionPtrOutputWithContext(context.Background())
}

func (i *execActionPtrType) ToExecActionPtrOutputWithContext(ctx context.Context) ExecActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExecActionPtrOutput)
}

// ExecAction describes a "run in container" action.
type ExecActionOutput struct{ *pulumi.OutputState }

func (ExecActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExecAction)(nil)).Elem()
}

func (o ExecActionOutput) ToExecActionOutput() ExecActionOutput {
	return o
}

func (o ExecActionOutput) ToExecActionOutputWithContext(ctx context.Context) ExecActionOutput {
	return o
}

func (o ExecActionOutput) ToExecActionPtrOutput() ExecActionPtrOutput {
	return o.ToExecActionPtrOutputWithContext(context.Background())
}

func (o ExecActionOutput) ToExecActionPtrOutputWithContext(ctx context.Context) ExecActionPtrOutput {
	return o.ApplyT(func(v ExecAction) *ExecAction {
		return &v
	}).(ExecActionPtrOutput)
}

// Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. +optional
func (o ExecActionOutput) Command() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ExecAction) []string { return v.Command }).(pulumi.StringArrayOutput)
}

type ExecActionPtrOutput struct{ *pulumi.OutputState }

func (ExecActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ExecAction)(nil)).Elem()
}

func (o ExecActionPtrOutput) ToExecActionPtrOutput() ExecActionPtrOutput {
	return o
}

func (o ExecActionPtrOutput) ToExecActionPtrOutputWithContext(ctx context.Context) ExecActionPtrOutput {
	return o
}

func (o ExecActionPtrOutput) Elem() ExecActionOutput {
	return o.ApplyT(func(v *ExecAction) ExecAction { return *v }).(ExecActionOutput)
}

// Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy. +optional
func (o ExecActionPtrOutput) Command() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ExecAction) []string {
		if v == nil {
			return nil
		}
		return v.Command
	}).(pulumi.StringArrayOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type Expr struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description *string `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression *string `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location *string `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title *string `pulumi:"title"`
}

// ExprInput is an input type that accepts ExprArgs and ExprOutput values.
// You can construct a concrete instance of `ExprInput` via:
//
//          ExprArgs{...}
type ExprInput interface {
	pulumi.Input

	ToExprOutput() ExprOutput
	ToExprOutputWithContext(context.Context) ExprOutput
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprArgs struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression pulumi.StringPtrInput `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title pulumi.StringPtrInput `pulumi:"title"`
}

func (ExprArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (i ExprArgs) ToExprOutput() ExprOutput {
	return i.ToExprOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput)
}

func (i ExprArgs) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput).ToExprPtrOutputWithContext(ctx)
}

// ExprPtrInput is an input type that accepts ExprArgs, ExprPtr and ExprPtrOutput values.
// You can construct a concrete instance of `ExprPtrInput` via:
//
//          ExprArgs{...}
//
//  or:
//
//          nil
type ExprPtrInput interface {
	pulumi.Input

	ToExprPtrOutput() ExprPtrOutput
	ToExprPtrOutputWithContext(context.Context) ExprPtrOutput
}

type exprPtrType ExprArgs

func ExprPtr(v *ExprArgs) ExprPtrInput {
	return (*exprPtrType)(v)
}

func (*exprPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (i *exprPtrType) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i *exprPtrType) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprOutput struct{ *pulumi.OutputState }

func (ExprOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (o ExprOutput) ToExprOutput() ExprOutput {
	return o
}

func (o ExprOutput) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return o
}

func (o ExprOutput) ToExprPtrOutput() ExprPtrOutput {
	return o.ToExprPtrOutputWithContext(context.Background())
}

func (o ExprOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o.ApplyT(func(v Expr) *Expr {
		return &v
	}).(ExprPtrOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Expression }).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Title }).(pulumi.StringPtrOutput)
}

type ExprPtrOutput struct{ *pulumi.OutputState }

func (ExprPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (o ExprPtrOutput) ToExprPtrOutput() ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) Elem() ExprOutput {
	return o.ApplyT(func(v *Expr) Expr { return *v }).(ExprOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprPtrOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Expression
	}).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprPtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprPtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// HTTPGetAction describes an action based on HTTP Get requests.
type HTTPGetAction struct {
	// Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. +optional
	Host *string `pulumi:"host"`
	// Custom headers to set in the request. HTTP allows repeated headers. +optional
	HttpHeaders []HTTPHeader `pulumi:"httpHeaders"`
	// Path to access on the HTTP server. +optional
	Path *string `pulumi:"path"`
	// Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	Port *IntOrString `pulumi:"port"`
	// Scheme to use for connecting to the host. Defaults to HTTP. +optional
	Scheme *string `pulumi:"scheme"`
}

// HTTPGetActionInput is an input type that accepts HTTPGetActionArgs and HTTPGetActionOutput values.
// You can construct a concrete instance of `HTTPGetActionInput` via:
//
//          HTTPGetActionArgs{...}
type HTTPGetActionInput interface {
	pulumi.Input

	ToHTTPGetActionOutput() HTTPGetActionOutput
	ToHTTPGetActionOutputWithContext(context.Context) HTTPGetActionOutput
}

// HTTPGetAction describes an action based on HTTP Get requests.
type HTTPGetActionArgs struct {
	// Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. +optional
	Host pulumi.StringPtrInput `pulumi:"host"`
	// Custom headers to set in the request. HTTP allows repeated headers. +optional
	HttpHeaders HTTPHeaderArrayInput `pulumi:"httpHeaders"`
	// Path to access on the HTTP server. +optional
	Path pulumi.StringPtrInput `pulumi:"path"`
	// Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	Port IntOrStringPtrInput `pulumi:"port"`
	// Scheme to use for connecting to the host. Defaults to HTTP. +optional
	Scheme pulumi.StringPtrInput `pulumi:"scheme"`
}

func (HTTPGetActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPGetAction)(nil)).Elem()
}

func (i HTTPGetActionArgs) ToHTTPGetActionOutput() HTTPGetActionOutput {
	return i.ToHTTPGetActionOutputWithContext(context.Background())
}

func (i HTTPGetActionArgs) ToHTTPGetActionOutputWithContext(ctx context.Context) HTTPGetActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPGetActionOutput)
}

func (i HTTPGetActionArgs) ToHTTPGetActionPtrOutput() HTTPGetActionPtrOutput {
	return i.ToHTTPGetActionPtrOutputWithContext(context.Background())
}

func (i HTTPGetActionArgs) ToHTTPGetActionPtrOutputWithContext(ctx context.Context) HTTPGetActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPGetActionOutput).ToHTTPGetActionPtrOutputWithContext(ctx)
}

// HTTPGetActionPtrInput is an input type that accepts HTTPGetActionArgs, HTTPGetActionPtr and HTTPGetActionPtrOutput values.
// You can construct a concrete instance of `HTTPGetActionPtrInput` via:
//
//          HTTPGetActionArgs{...}
//
//  or:
//
//          nil
type HTTPGetActionPtrInput interface {
	pulumi.Input

	ToHTTPGetActionPtrOutput() HTTPGetActionPtrOutput
	ToHTTPGetActionPtrOutputWithContext(context.Context) HTTPGetActionPtrOutput
}

type httpgetActionPtrType HTTPGetActionArgs

func HTTPGetActionPtr(v *HTTPGetActionArgs) HTTPGetActionPtrInput {
	return (*httpgetActionPtrType)(v)
}

func (*httpgetActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPGetAction)(nil)).Elem()
}

func (i *httpgetActionPtrType) ToHTTPGetActionPtrOutput() HTTPGetActionPtrOutput {
	return i.ToHTTPGetActionPtrOutputWithContext(context.Background())
}

func (i *httpgetActionPtrType) ToHTTPGetActionPtrOutputWithContext(ctx context.Context) HTTPGetActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPGetActionPtrOutput)
}

// HTTPGetAction describes an action based on HTTP Get requests.
type HTTPGetActionOutput struct{ *pulumi.OutputState }

func (HTTPGetActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPGetAction)(nil)).Elem()
}

func (o HTTPGetActionOutput) ToHTTPGetActionOutput() HTTPGetActionOutput {
	return o
}

func (o HTTPGetActionOutput) ToHTTPGetActionOutputWithContext(ctx context.Context) HTTPGetActionOutput {
	return o
}

func (o HTTPGetActionOutput) ToHTTPGetActionPtrOutput() HTTPGetActionPtrOutput {
	return o.ToHTTPGetActionPtrOutputWithContext(context.Background())
}

func (o HTTPGetActionOutput) ToHTTPGetActionPtrOutputWithContext(ctx context.Context) HTTPGetActionPtrOutput {
	return o.ApplyT(func(v HTTPGetAction) *HTTPGetAction {
		return &v
	}).(HTTPGetActionPtrOutput)
}

// Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. +optional
func (o HTTPGetActionOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPGetAction) *string { return v.Host }).(pulumi.StringPtrOutput)
}

// Custom headers to set in the request. HTTP allows repeated headers. +optional
func (o HTTPGetActionOutput) HttpHeaders() HTTPHeaderArrayOutput {
	return o.ApplyT(func(v HTTPGetAction) []HTTPHeader { return v.HttpHeaders }).(HTTPHeaderArrayOutput)
}

// Path to access on the HTTP server. +optional
func (o HTTPGetActionOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPGetAction) *string { return v.Path }).(pulumi.StringPtrOutput)
}

// Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
func (o HTTPGetActionOutput) Port() IntOrStringPtrOutput {
	return o.ApplyT(func(v HTTPGetAction) *IntOrString { return v.Port }).(IntOrStringPtrOutput)
}

// Scheme to use for connecting to the host. Defaults to HTTP. +optional
func (o HTTPGetActionOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPGetAction) *string { return v.Scheme }).(pulumi.StringPtrOutput)
}

type HTTPGetActionPtrOutput struct{ *pulumi.OutputState }

func (HTTPGetActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HTTPGetAction)(nil)).Elem()
}

func (o HTTPGetActionPtrOutput) ToHTTPGetActionPtrOutput() HTTPGetActionPtrOutput {
	return o
}

func (o HTTPGetActionPtrOutput) ToHTTPGetActionPtrOutputWithContext(ctx context.Context) HTTPGetActionPtrOutput {
	return o
}

func (o HTTPGetActionPtrOutput) Elem() HTTPGetActionOutput {
	return o.ApplyT(func(v *HTTPGetAction) HTTPGetAction { return *v }).(HTTPGetActionOutput)
}

// Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead. +optional
func (o HTTPGetActionPtrOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPGetAction) *string {
		if v == nil {
			return nil
		}
		return v.Host
	}).(pulumi.StringPtrOutput)
}

// Custom headers to set in the request. HTTP allows repeated headers. +optional
func (o HTTPGetActionPtrOutput) HttpHeaders() HTTPHeaderArrayOutput {
	return o.ApplyT(func(v *HTTPGetAction) []HTTPHeader {
		if v == nil {
			return nil
		}
		return v.HttpHeaders
	}).(HTTPHeaderArrayOutput)
}

// Path to access on the HTTP server. +optional
func (o HTTPGetActionPtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPGetAction) *string {
		if v == nil {
			return nil
		}
		return v.Path
	}).(pulumi.StringPtrOutput)
}

// Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
func (o HTTPGetActionPtrOutput) Port() IntOrStringPtrOutput {
	return o.ApplyT(func(v *HTTPGetAction) *IntOrString {
		if v == nil {
			return nil
		}
		return v.Port
	}).(IntOrStringPtrOutput)
}

// Scheme to use for connecting to the host. Defaults to HTTP. +optional
func (o HTTPGetActionPtrOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HTTPGetAction) *string {
		if v == nil {
			return nil
		}
		return v.Scheme
	}).(pulumi.StringPtrOutput)
}

// HTTPHeader describes a custom header to be used in HTTP probes
type HTTPHeader struct {
	// The header field name
	Name *string `pulumi:"name"`
	// The header field value
	Value *string `pulumi:"value"`
}

// HTTPHeaderInput is an input type that accepts HTTPHeaderArgs and HTTPHeaderOutput values.
// You can construct a concrete instance of `HTTPHeaderInput` via:
//
//          HTTPHeaderArgs{...}
type HTTPHeaderInput interface {
	pulumi.Input

	ToHTTPHeaderOutput() HTTPHeaderOutput
	ToHTTPHeaderOutputWithContext(context.Context) HTTPHeaderOutput
}

// HTTPHeader describes a custom header to be used in HTTP probes
type HTTPHeaderArgs struct {
	// The header field name
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The header field value
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (HTTPHeaderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPHeader)(nil)).Elem()
}

func (i HTTPHeaderArgs) ToHTTPHeaderOutput() HTTPHeaderOutput {
	return i.ToHTTPHeaderOutputWithContext(context.Background())
}

func (i HTTPHeaderArgs) ToHTTPHeaderOutputWithContext(ctx context.Context) HTTPHeaderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPHeaderOutput)
}

// HTTPHeaderArrayInput is an input type that accepts HTTPHeaderArray and HTTPHeaderArrayOutput values.
// You can construct a concrete instance of `HTTPHeaderArrayInput` via:
//
//          HTTPHeaderArray{ HTTPHeaderArgs{...} }
type HTTPHeaderArrayInput interface {
	pulumi.Input

	ToHTTPHeaderArrayOutput() HTTPHeaderArrayOutput
	ToHTTPHeaderArrayOutputWithContext(context.Context) HTTPHeaderArrayOutput
}

type HTTPHeaderArray []HTTPHeaderInput

func (HTTPHeaderArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPHeader)(nil)).Elem()
}

func (i HTTPHeaderArray) ToHTTPHeaderArrayOutput() HTTPHeaderArrayOutput {
	return i.ToHTTPHeaderArrayOutputWithContext(context.Background())
}

func (i HTTPHeaderArray) ToHTTPHeaderArrayOutputWithContext(ctx context.Context) HTTPHeaderArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HTTPHeaderArrayOutput)
}

// HTTPHeader describes a custom header to be used in HTTP probes
type HTTPHeaderOutput struct{ *pulumi.OutputState }

func (HTTPHeaderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HTTPHeader)(nil)).Elem()
}

func (o HTTPHeaderOutput) ToHTTPHeaderOutput() HTTPHeaderOutput {
	return o
}

func (o HTTPHeaderOutput) ToHTTPHeaderOutputWithContext(ctx context.Context) HTTPHeaderOutput {
	return o
}

// The header field name
func (o HTTPHeaderOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPHeader) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The header field value
func (o HTTPHeaderOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HTTPHeader) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type HTTPHeaderArrayOutput struct{ *pulumi.OutputState }

func (HTTPHeaderArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HTTPHeader)(nil)).Elem()
}

func (o HTTPHeaderArrayOutput) ToHTTPHeaderArrayOutput() HTTPHeaderArrayOutput {
	return o
}

func (o HTTPHeaderArrayOutput) ToHTTPHeaderArrayOutputWithContext(ctx context.Context) HTTPHeaderArrayOutput {
	return o
}

func (o HTTPHeaderArrayOutput) Index(i pulumi.IntInput) HTTPHeaderOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HTTPHeader {
		return vs[0].([]HTTPHeader)[vs[1].(int)]
	}).(HTTPHeaderOutput)
}

// Handler defines a specific action that should be taken
type Handler struct {
	// One and only one of the following should be specified. Exec specifies the action to take. +optional
	Exec *ExecAction `pulumi:"exec"`
	// HTTPGet specifies the http request to perform. +optional
	HttpGet *HTTPGetAction `pulumi:"httpGet"`
	// TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
	TcpSocket *TCPSocketAction `pulumi:"tcpSocket"`
}

// HandlerInput is an input type that accepts HandlerArgs and HandlerOutput values.
// You can construct a concrete instance of `HandlerInput` via:
//
//          HandlerArgs{...}
type HandlerInput interface {
	pulumi.Input

	ToHandlerOutput() HandlerOutput
	ToHandlerOutputWithContext(context.Context) HandlerOutput
}

// Handler defines a specific action that should be taken
type HandlerArgs struct {
	// One and only one of the following should be specified. Exec specifies the action to take. +optional
	Exec ExecActionPtrInput `pulumi:"exec"`
	// HTTPGet specifies the http request to perform. +optional
	HttpGet HTTPGetActionPtrInput `pulumi:"httpGet"`
	// TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
	TcpSocket TCPSocketActionPtrInput `pulumi:"tcpSocket"`
}

func (HandlerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Handler)(nil)).Elem()
}

func (i HandlerArgs) ToHandlerOutput() HandlerOutput {
	return i.ToHandlerOutputWithContext(context.Background())
}

func (i HandlerArgs) ToHandlerOutputWithContext(ctx context.Context) HandlerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HandlerOutput)
}

func (i HandlerArgs) ToHandlerPtrOutput() HandlerPtrOutput {
	return i.ToHandlerPtrOutputWithContext(context.Background())
}

func (i HandlerArgs) ToHandlerPtrOutputWithContext(ctx context.Context) HandlerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HandlerOutput).ToHandlerPtrOutputWithContext(ctx)
}

// HandlerPtrInput is an input type that accepts HandlerArgs, HandlerPtr and HandlerPtrOutput values.
// You can construct a concrete instance of `HandlerPtrInput` via:
//
//          HandlerArgs{...}
//
//  or:
//
//          nil
type HandlerPtrInput interface {
	pulumi.Input

	ToHandlerPtrOutput() HandlerPtrOutput
	ToHandlerPtrOutputWithContext(context.Context) HandlerPtrOutput
}

type handlerPtrType HandlerArgs

func HandlerPtr(v *HandlerArgs) HandlerPtrInput {
	return (*handlerPtrType)(v)
}

func (*handlerPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Handler)(nil)).Elem()
}

func (i *handlerPtrType) ToHandlerPtrOutput() HandlerPtrOutput {
	return i.ToHandlerPtrOutputWithContext(context.Background())
}

func (i *handlerPtrType) ToHandlerPtrOutputWithContext(ctx context.Context) HandlerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HandlerPtrOutput)
}

// Handler defines a specific action that should be taken
type HandlerOutput struct{ *pulumi.OutputState }

func (HandlerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Handler)(nil)).Elem()
}

func (o HandlerOutput) ToHandlerOutput() HandlerOutput {
	return o
}

func (o HandlerOutput) ToHandlerOutputWithContext(ctx context.Context) HandlerOutput {
	return o
}

func (o HandlerOutput) ToHandlerPtrOutput() HandlerPtrOutput {
	return o.ToHandlerPtrOutputWithContext(context.Background())
}

func (o HandlerOutput) ToHandlerPtrOutputWithContext(ctx context.Context) HandlerPtrOutput {
	return o.ApplyT(func(v Handler) *Handler {
		return &v
	}).(HandlerPtrOutput)
}

// One and only one of the following should be specified. Exec specifies the action to take. +optional
func (o HandlerOutput) Exec() ExecActionPtrOutput {
	return o.ApplyT(func(v Handler) *ExecAction { return v.Exec }).(ExecActionPtrOutput)
}

// HTTPGet specifies the http request to perform. +optional
func (o HandlerOutput) HttpGet() HTTPGetActionPtrOutput {
	return o.ApplyT(func(v Handler) *HTTPGetAction { return v.HttpGet }).(HTTPGetActionPtrOutput)
}

// TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
func (o HandlerOutput) TcpSocket() TCPSocketActionPtrOutput {
	return o.ApplyT(func(v Handler) *TCPSocketAction { return v.TcpSocket }).(TCPSocketActionPtrOutput)
}

type HandlerPtrOutput struct{ *pulumi.OutputState }

func (HandlerPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Handler)(nil)).Elem()
}

func (o HandlerPtrOutput) ToHandlerPtrOutput() HandlerPtrOutput {
	return o
}

func (o HandlerPtrOutput) ToHandlerPtrOutputWithContext(ctx context.Context) HandlerPtrOutput {
	return o
}

func (o HandlerPtrOutput) Elem() HandlerOutput {
	return o.ApplyT(func(v *Handler) Handler { return *v }).(HandlerOutput)
}

// One and only one of the following should be specified. Exec specifies the action to take. +optional
func (o HandlerPtrOutput) Exec() ExecActionPtrOutput {
	return o.ApplyT(func(v *Handler) *ExecAction {
		if v == nil {
			return nil
		}
		return v.Exec
	}).(ExecActionPtrOutput)
}

// HTTPGet specifies the http request to perform. +optional
func (o HandlerPtrOutput) HttpGet() HTTPGetActionPtrOutput {
	return o.ApplyT(func(v *Handler) *HTTPGetAction {
		if v == nil {
			return nil
		}
		return v.HttpGet
	}).(HTTPGetActionPtrOutput)
}

// TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
func (o HandlerPtrOutput) TcpSocket() TCPSocketActionPtrOutput {
	return o.ApplyT(func(v *Handler) *TCPSocketAction {
		if v == nil {
			return nil
		}
		return v.TcpSocket
	}).(TCPSocketActionPtrOutput)
}

// InstanceSpec is a description of an instance.
type InstanceSpec struct {
	// Optional. Optional duration in seconds the instance may be active relative to StartTime before the system will actively try to mark it failed and kill associated containers. If set to zero, the system will never attempt to kill an instance based on time. Otherwise, value must be a positive integer. +optional
	ActiveDeadlineSeconds *string `pulumi:"activeDeadlineSeconds"`
	// Optional. List of containers belonging to the instance. We disallow a number of fields on this Container. Only a single container may be provided.
	Containers []Container `pulumi:"containers"`
	// Optional. Restart policy for all containers within the instance. Allowed values are: - OnFailure: Instances will always be restarted on failure if the backoffLimit has not been reached. - Never: Instances are never restarted and all failures are permanent. Cannot be used if backoffLimit is set. +optional
	RestartPolicy *string `pulumi:"restartPolicy"`
	// Optional. Email address of the IAM service account associated with the instance of a Job. The service account represents the identity of the running instance, and determines what permissions the instance has. If not provided, the instance will use the project's default service account. +optional
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// Optional. Optional duration in seconds the instance needs to terminate gracefully. Value must be non-negative integer. The value zero indicates delete immediately. The grace period is the duration in seconds after the processes running in the instance are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. +optional
	TerminationGracePeriodSeconds *string `pulumi:"terminationGracePeriodSeconds"`
	// Optional. List of volumes that can be mounted by containers belonging to the instance. More info: https://kubernetes.io/docs/concepts/storage/volumes +optional
	Volumes []Volume `pulumi:"volumes"`
}

// InstanceSpecInput is an input type that accepts InstanceSpecArgs and InstanceSpecOutput values.
// You can construct a concrete instance of `InstanceSpecInput` via:
//
//          InstanceSpecArgs{...}
type InstanceSpecInput interface {
	pulumi.Input

	ToInstanceSpecOutput() InstanceSpecOutput
	ToInstanceSpecOutputWithContext(context.Context) InstanceSpecOutput
}

// InstanceSpec is a description of an instance.
type InstanceSpecArgs struct {
	// Optional. Optional duration in seconds the instance may be active relative to StartTime before the system will actively try to mark it failed and kill associated containers. If set to zero, the system will never attempt to kill an instance based on time. Otherwise, value must be a positive integer. +optional
	ActiveDeadlineSeconds pulumi.StringPtrInput `pulumi:"activeDeadlineSeconds"`
	// Optional. List of containers belonging to the instance. We disallow a number of fields on this Container. Only a single container may be provided.
	Containers ContainerArrayInput `pulumi:"containers"`
	// Optional. Restart policy for all containers within the instance. Allowed values are: - OnFailure: Instances will always be restarted on failure if the backoffLimit has not been reached. - Never: Instances are never restarted and all failures are permanent. Cannot be used if backoffLimit is set. +optional
	RestartPolicy pulumi.StringPtrInput `pulumi:"restartPolicy"`
	// Optional. Email address of the IAM service account associated with the instance of a Job. The service account represents the identity of the running instance, and determines what permissions the instance has. If not provided, the instance will use the project's default service account. +optional
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// Optional. Optional duration in seconds the instance needs to terminate gracefully. Value must be non-negative integer. The value zero indicates delete immediately. The grace period is the duration in seconds after the processes running in the instance are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. +optional
	TerminationGracePeriodSeconds pulumi.StringPtrInput `pulumi:"terminationGracePeriodSeconds"`
	// Optional. List of volumes that can be mounted by containers belonging to the instance. More info: https://kubernetes.io/docs/concepts/storage/volumes +optional
	Volumes VolumeArrayInput `pulumi:"volumes"`
}

func (InstanceSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceSpec)(nil)).Elem()
}

func (i InstanceSpecArgs) ToInstanceSpecOutput() InstanceSpecOutput {
	return i.ToInstanceSpecOutputWithContext(context.Background())
}

func (i InstanceSpecArgs) ToInstanceSpecOutputWithContext(ctx context.Context) InstanceSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceSpecOutput)
}

func (i InstanceSpecArgs) ToInstanceSpecPtrOutput() InstanceSpecPtrOutput {
	return i.ToInstanceSpecPtrOutputWithContext(context.Background())
}

func (i InstanceSpecArgs) ToInstanceSpecPtrOutputWithContext(ctx context.Context) InstanceSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceSpecOutput).ToInstanceSpecPtrOutputWithContext(ctx)
}

// InstanceSpecPtrInput is an input type that accepts InstanceSpecArgs, InstanceSpecPtr and InstanceSpecPtrOutput values.
// You can construct a concrete instance of `InstanceSpecPtrInput` via:
//
//          InstanceSpecArgs{...}
//
//  or:
//
//          nil
type InstanceSpecPtrInput interface {
	pulumi.Input

	ToInstanceSpecPtrOutput() InstanceSpecPtrOutput
	ToInstanceSpecPtrOutputWithContext(context.Context) InstanceSpecPtrOutput
}

type instanceSpecPtrType InstanceSpecArgs

func InstanceSpecPtr(v *InstanceSpecArgs) InstanceSpecPtrInput {
	return (*instanceSpecPtrType)(v)
}

func (*instanceSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceSpec)(nil)).Elem()
}

func (i *instanceSpecPtrType) ToInstanceSpecPtrOutput() InstanceSpecPtrOutput {
	return i.ToInstanceSpecPtrOutputWithContext(context.Background())
}

func (i *instanceSpecPtrType) ToInstanceSpecPtrOutputWithContext(ctx context.Context) InstanceSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceSpecPtrOutput)
}

// InstanceSpec is a description of an instance.
type InstanceSpecOutput struct{ *pulumi.OutputState }

func (InstanceSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceSpec)(nil)).Elem()
}

func (o InstanceSpecOutput) ToInstanceSpecOutput() InstanceSpecOutput {
	return o
}

func (o InstanceSpecOutput) ToInstanceSpecOutputWithContext(ctx context.Context) InstanceSpecOutput {
	return o
}

func (o InstanceSpecOutput) ToInstanceSpecPtrOutput() InstanceSpecPtrOutput {
	return o.ToInstanceSpecPtrOutputWithContext(context.Background())
}

func (o InstanceSpecOutput) ToInstanceSpecPtrOutputWithContext(ctx context.Context) InstanceSpecPtrOutput {
	return o.ApplyT(func(v InstanceSpec) *InstanceSpec {
		return &v
	}).(InstanceSpecPtrOutput)
}

// Optional. Optional duration in seconds the instance may be active relative to StartTime before the system will actively try to mark it failed and kill associated containers. If set to zero, the system will never attempt to kill an instance based on time. Otherwise, value must be a positive integer. +optional
func (o InstanceSpecOutput) ActiveDeadlineSeconds() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceSpec) *string { return v.ActiveDeadlineSeconds }).(pulumi.StringPtrOutput)
}

// Optional. List of containers belonging to the instance. We disallow a number of fields on this Container. Only a single container may be provided.
func (o InstanceSpecOutput) Containers() ContainerArrayOutput {
	return o.ApplyT(func(v InstanceSpec) []Container { return v.Containers }).(ContainerArrayOutput)
}

// Optional. Restart policy for all containers within the instance. Allowed values are: - OnFailure: Instances will always be restarted on failure if the backoffLimit has not been reached. - Never: Instances are never restarted and all failures are permanent. Cannot be used if backoffLimit is set. +optional
func (o InstanceSpecOutput) RestartPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceSpec) *string { return v.RestartPolicy }).(pulumi.StringPtrOutput)
}

// Optional. Email address of the IAM service account associated with the instance of a Job. The service account represents the identity of the running instance, and determines what permissions the instance has. If not provided, the instance will use the project's default service account. +optional
func (o InstanceSpecOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceSpec) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// Optional. Optional duration in seconds the instance needs to terminate gracefully. Value must be non-negative integer. The value zero indicates delete immediately. The grace period is the duration in seconds after the processes running in the instance are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. +optional
func (o InstanceSpecOutput) TerminationGracePeriodSeconds() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceSpec) *string { return v.TerminationGracePeriodSeconds }).(pulumi.StringPtrOutput)
}

// Optional. List of volumes that can be mounted by containers belonging to the instance. More info: https://kubernetes.io/docs/concepts/storage/volumes +optional
func (o InstanceSpecOutput) Volumes() VolumeArrayOutput {
	return o.ApplyT(func(v InstanceSpec) []Volume { return v.Volumes }).(VolumeArrayOutput)
}

type InstanceSpecPtrOutput struct{ *pulumi.OutputState }

func (InstanceSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceSpec)(nil)).Elem()
}

func (o InstanceSpecPtrOutput) ToInstanceSpecPtrOutput() InstanceSpecPtrOutput {
	return o
}

func (o InstanceSpecPtrOutput) ToInstanceSpecPtrOutputWithContext(ctx context.Context) InstanceSpecPtrOutput {
	return o
}

func (o InstanceSpecPtrOutput) Elem() InstanceSpecOutput {
	return o.ApplyT(func(v *InstanceSpec) InstanceSpec { return *v }).(InstanceSpecOutput)
}

// Optional. Optional duration in seconds the instance may be active relative to StartTime before the system will actively try to mark it failed and kill associated containers. If set to zero, the system will never attempt to kill an instance based on time. Otherwise, value must be a positive integer. +optional
func (o InstanceSpecPtrOutput) ActiveDeadlineSeconds() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstanceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ActiveDeadlineSeconds
	}).(pulumi.StringPtrOutput)
}

// Optional. List of containers belonging to the instance. We disallow a number of fields on this Container. Only a single container may be provided.
func (o InstanceSpecPtrOutput) Containers() ContainerArrayOutput {
	return o.ApplyT(func(v *InstanceSpec) []Container {
		if v == nil {
			return nil
		}
		return v.Containers
	}).(ContainerArrayOutput)
}

// Optional. Restart policy for all containers within the instance. Allowed values are: - OnFailure: Instances will always be restarted on failure if the backoffLimit has not been reached. - Never: Instances are never restarted and all failures are permanent. Cannot be used if backoffLimit is set. +optional
func (o InstanceSpecPtrOutput) RestartPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstanceSpec) *string {
		if v == nil {
			return nil
		}
		return v.RestartPolicy
	}).(pulumi.StringPtrOutput)
}

// Optional. Email address of the IAM service account associated with the instance of a Job. The service account represents the identity of the running instance, and determines what permissions the instance has. If not provided, the instance will use the project's default service account. +optional
func (o InstanceSpecPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstanceSpec) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// Optional. Optional duration in seconds the instance needs to terminate gracefully. Value must be non-negative integer. The value zero indicates delete immediately. The grace period is the duration in seconds after the processes running in the instance are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. +optional
func (o InstanceSpecPtrOutput) TerminationGracePeriodSeconds() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstanceSpec) *string {
		if v == nil {
			return nil
		}
		return v.TerminationGracePeriodSeconds
	}).(pulumi.StringPtrOutput)
}

// Optional. List of volumes that can be mounted by containers belonging to the instance. More info: https://kubernetes.io/docs/concepts/storage/volumes +optional
func (o InstanceSpecPtrOutput) Volumes() VolumeArrayOutput {
	return o.ApplyT(func(v *InstanceSpec) []Volume {
		if v == nil {
			return nil
		}
		return v.Volumes
	}).(VolumeArrayOutput)
}

// Instance represents the status of an instance of a Job.
type InstanceStatus struct {
	// Optional. Represents time when the instance was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. +optional
	CompletionTime *string `pulumi:"completionTime"`
	// Optional. The number of times this instance exited with code > 0; +optional
	Failed *int `pulumi:"failed"`
	// Required. Index of the instance, unique per Job, and beginning at 0.
	Index *int `pulumi:"index"`
	// Optional. Last exit code seen for this instance. +optional
	LastExitCode *int `pulumi:"lastExitCode"`
	// Optional. The number of times this instance was restarted. Instances are restarted according the restartPolicy configured in the Job template. +optional
	Restarted *int `pulumi:"restarted"`
	// Optional. Represents time when the instance was created by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. +optional
	StartTime *string `pulumi:"startTime"`
	// Optional. The number of times this instance exited with code == 0. +optional
	Succeeded *int `pulumi:"succeeded"`
}

// InstanceStatusInput is an input type that accepts InstanceStatusArgs and InstanceStatusOutput values.
// You can construct a concrete instance of `InstanceStatusInput` via:
//
//          InstanceStatusArgs{...}
type InstanceStatusInput interface {
	pulumi.Input

	ToInstanceStatusOutput() InstanceStatusOutput
	ToInstanceStatusOutputWithContext(context.Context) InstanceStatusOutput
}

// Instance represents the status of an instance of a Job.
type InstanceStatusArgs struct {
	// Optional. Represents time when the instance was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. +optional
	CompletionTime pulumi.StringPtrInput `pulumi:"completionTime"`
	// Optional. The number of times this instance exited with code > 0; +optional
	Failed pulumi.IntPtrInput `pulumi:"failed"`
	// Required. Index of the instance, unique per Job, and beginning at 0.
	Index pulumi.IntPtrInput `pulumi:"index"`
	// Optional. Last exit code seen for this instance. +optional
	LastExitCode pulumi.IntPtrInput `pulumi:"lastExitCode"`
	// Optional. The number of times this instance was restarted. Instances are restarted according the restartPolicy configured in the Job template. +optional
	Restarted pulumi.IntPtrInput `pulumi:"restarted"`
	// Optional. Represents time when the instance was created by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. +optional
	StartTime pulumi.StringPtrInput `pulumi:"startTime"`
	// Optional. The number of times this instance exited with code == 0. +optional
	Succeeded pulumi.IntPtrInput `pulumi:"succeeded"`
}

func (InstanceStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceStatus)(nil)).Elem()
}

func (i InstanceStatusArgs) ToInstanceStatusOutput() InstanceStatusOutput {
	return i.ToInstanceStatusOutputWithContext(context.Background())
}

func (i InstanceStatusArgs) ToInstanceStatusOutputWithContext(ctx context.Context) InstanceStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceStatusOutput)
}

// InstanceStatusArrayInput is an input type that accepts InstanceStatusArray and InstanceStatusArrayOutput values.
// You can construct a concrete instance of `InstanceStatusArrayInput` via:
//
//          InstanceStatusArray{ InstanceStatusArgs{...} }
type InstanceStatusArrayInput interface {
	pulumi.Input

	ToInstanceStatusArrayOutput() InstanceStatusArrayOutput
	ToInstanceStatusArrayOutputWithContext(context.Context) InstanceStatusArrayOutput
}

type InstanceStatusArray []InstanceStatusInput

func (InstanceStatusArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceStatus)(nil)).Elem()
}

func (i InstanceStatusArray) ToInstanceStatusArrayOutput() InstanceStatusArrayOutput {
	return i.ToInstanceStatusArrayOutputWithContext(context.Background())
}

func (i InstanceStatusArray) ToInstanceStatusArrayOutputWithContext(ctx context.Context) InstanceStatusArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceStatusArrayOutput)
}

// Instance represents the status of an instance of a Job.
type InstanceStatusOutput struct{ *pulumi.OutputState }

func (InstanceStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceStatus)(nil)).Elem()
}

func (o InstanceStatusOutput) ToInstanceStatusOutput() InstanceStatusOutput {
	return o
}

func (o InstanceStatusOutput) ToInstanceStatusOutputWithContext(ctx context.Context) InstanceStatusOutput {
	return o
}

// Optional. Represents time when the instance was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. +optional
func (o InstanceStatusOutput) CompletionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceStatus) *string { return v.CompletionTime }).(pulumi.StringPtrOutput)
}

// Optional. The number of times this instance exited with code > 0; +optional
func (o InstanceStatusOutput) Failed() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceStatus) *int { return v.Failed }).(pulumi.IntPtrOutput)
}

// Required. Index of the instance, unique per Job, and beginning at 0.
func (o InstanceStatusOutput) Index() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceStatus) *int { return v.Index }).(pulumi.IntPtrOutput)
}

// Optional. Last exit code seen for this instance. +optional
func (o InstanceStatusOutput) LastExitCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceStatus) *int { return v.LastExitCode }).(pulumi.IntPtrOutput)
}

// Optional. The number of times this instance was restarted. Instances are restarted according the restartPolicy configured in the Job template. +optional
func (o InstanceStatusOutput) Restarted() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceStatus) *int { return v.Restarted }).(pulumi.IntPtrOutput)
}

// Optional. Represents time when the instance was created by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. +optional
func (o InstanceStatusOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceStatus) *string { return v.StartTime }).(pulumi.StringPtrOutput)
}

// Optional. The number of times this instance exited with code == 0. +optional
func (o InstanceStatusOutput) Succeeded() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceStatus) *int { return v.Succeeded }).(pulumi.IntPtrOutput)
}

type InstanceStatusArrayOutput struct{ *pulumi.OutputState }

func (InstanceStatusArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceStatus)(nil)).Elem()
}

func (o InstanceStatusArrayOutput) ToInstanceStatusArrayOutput() InstanceStatusArrayOutput {
	return o
}

func (o InstanceStatusArrayOutput) ToInstanceStatusArrayOutputWithContext(ctx context.Context) InstanceStatusArrayOutput {
	return o
}

func (o InstanceStatusArrayOutput) Index(i pulumi.IntInput) InstanceStatusOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstanceStatus {
		return vs[0].([]InstanceStatus)[vs[1].(int)]
	}).(InstanceStatusOutput)
}

// InstanceTemplateSpec describes the data an instance should have when created from a template.
type InstanceTemplateSpec struct {
	// Optional. Specification of the desired behavior of the instance. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status +optional
	Spec *InstanceSpec `pulumi:"spec"`
}

// InstanceTemplateSpecInput is an input type that accepts InstanceTemplateSpecArgs and InstanceTemplateSpecOutput values.
// You can construct a concrete instance of `InstanceTemplateSpecInput` via:
//
//          InstanceTemplateSpecArgs{...}
type InstanceTemplateSpecInput interface {
	pulumi.Input

	ToInstanceTemplateSpecOutput() InstanceTemplateSpecOutput
	ToInstanceTemplateSpecOutputWithContext(context.Context) InstanceTemplateSpecOutput
}

// InstanceTemplateSpec describes the data an instance should have when created from a template.
type InstanceTemplateSpecArgs struct {
	// Optional. Specification of the desired behavior of the instance. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status +optional
	Spec InstanceSpecPtrInput `pulumi:"spec"`
}

func (InstanceTemplateSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceTemplateSpec)(nil)).Elem()
}

func (i InstanceTemplateSpecArgs) ToInstanceTemplateSpecOutput() InstanceTemplateSpecOutput {
	return i.ToInstanceTemplateSpecOutputWithContext(context.Background())
}

func (i InstanceTemplateSpecArgs) ToInstanceTemplateSpecOutputWithContext(ctx context.Context) InstanceTemplateSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceTemplateSpecOutput)
}

func (i InstanceTemplateSpecArgs) ToInstanceTemplateSpecPtrOutput() InstanceTemplateSpecPtrOutput {
	return i.ToInstanceTemplateSpecPtrOutputWithContext(context.Background())
}

func (i InstanceTemplateSpecArgs) ToInstanceTemplateSpecPtrOutputWithContext(ctx context.Context) InstanceTemplateSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceTemplateSpecOutput).ToInstanceTemplateSpecPtrOutputWithContext(ctx)
}

// InstanceTemplateSpecPtrInput is an input type that accepts InstanceTemplateSpecArgs, InstanceTemplateSpecPtr and InstanceTemplateSpecPtrOutput values.
// You can construct a concrete instance of `InstanceTemplateSpecPtrInput` via:
//
//          InstanceTemplateSpecArgs{...}
//
//  or:
//
//          nil
type InstanceTemplateSpecPtrInput interface {
	pulumi.Input

	ToInstanceTemplateSpecPtrOutput() InstanceTemplateSpecPtrOutput
	ToInstanceTemplateSpecPtrOutputWithContext(context.Context) InstanceTemplateSpecPtrOutput
}

type instanceTemplateSpecPtrType InstanceTemplateSpecArgs

func InstanceTemplateSpecPtr(v *InstanceTemplateSpecArgs) InstanceTemplateSpecPtrInput {
	return (*instanceTemplateSpecPtrType)(v)
}

func (*instanceTemplateSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceTemplateSpec)(nil)).Elem()
}

func (i *instanceTemplateSpecPtrType) ToInstanceTemplateSpecPtrOutput() InstanceTemplateSpecPtrOutput {
	return i.ToInstanceTemplateSpecPtrOutputWithContext(context.Background())
}

func (i *instanceTemplateSpecPtrType) ToInstanceTemplateSpecPtrOutputWithContext(ctx context.Context) InstanceTemplateSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceTemplateSpecPtrOutput)
}

// InstanceTemplateSpec describes the data an instance should have when created from a template.
type InstanceTemplateSpecOutput struct{ *pulumi.OutputState }

func (InstanceTemplateSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceTemplateSpec)(nil)).Elem()
}

func (o InstanceTemplateSpecOutput) ToInstanceTemplateSpecOutput() InstanceTemplateSpecOutput {
	return o
}

func (o InstanceTemplateSpecOutput) ToInstanceTemplateSpecOutputWithContext(ctx context.Context) InstanceTemplateSpecOutput {
	return o
}

func (o InstanceTemplateSpecOutput) ToInstanceTemplateSpecPtrOutput() InstanceTemplateSpecPtrOutput {
	return o.ToInstanceTemplateSpecPtrOutputWithContext(context.Background())
}

func (o InstanceTemplateSpecOutput) ToInstanceTemplateSpecPtrOutputWithContext(ctx context.Context) InstanceTemplateSpecPtrOutput {
	return o.ApplyT(func(v InstanceTemplateSpec) *InstanceTemplateSpec {
		return &v
	}).(InstanceTemplateSpecPtrOutput)
}

// Optional. Specification of the desired behavior of the instance. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status +optional
func (o InstanceTemplateSpecOutput) Spec() InstanceSpecPtrOutput {
	return o.ApplyT(func(v InstanceTemplateSpec) *InstanceSpec { return v.Spec }).(InstanceSpecPtrOutput)
}

type InstanceTemplateSpecPtrOutput struct{ *pulumi.OutputState }

func (InstanceTemplateSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceTemplateSpec)(nil)).Elem()
}

func (o InstanceTemplateSpecPtrOutput) ToInstanceTemplateSpecPtrOutput() InstanceTemplateSpecPtrOutput {
	return o
}

func (o InstanceTemplateSpecPtrOutput) ToInstanceTemplateSpecPtrOutputWithContext(ctx context.Context) InstanceTemplateSpecPtrOutput {
	return o
}

func (o InstanceTemplateSpecPtrOutput) Elem() InstanceTemplateSpecOutput {
	return o.ApplyT(func(v *InstanceTemplateSpec) InstanceTemplateSpec { return *v }).(InstanceTemplateSpecOutput)
}

// Optional. Specification of the desired behavior of the instance. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status +optional
func (o InstanceTemplateSpecPtrOutput) Spec() InstanceSpecPtrOutput {
	return o.ApplyT(func(v *InstanceTemplateSpec) *InstanceSpec {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(InstanceSpecPtrOutput)
}

// IntOrString is a type that can hold an int32 or a string. When used in JSON or YAML marshalling and unmarshalling, it produces or consumes the inner type. This allows you to have, for example, a JSON field that can accept a name or number.
type IntOrString struct {
	// The int value.
	IntVal *int `pulumi:"intVal"`
	// The string value.
	StrVal *string `pulumi:"strVal"`
	// The type of the value.
	Type *int `pulumi:"type"`
}

// IntOrStringInput is an input type that accepts IntOrStringArgs and IntOrStringOutput values.
// You can construct a concrete instance of `IntOrStringInput` via:
//
//          IntOrStringArgs{...}
type IntOrStringInput interface {
	pulumi.Input

	ToIntOrStringOutput() IntOrStringOutput
	ToIntOrStringOutputWithContext(context.Context) IntOrStringOutput
}

// IntOrString is a type that can hold an int32 or a string. When used in JSON or YAML marshalling and unmarshalling, it produces or consumes the inner type. This allows you to have, for example, a JSON field that can accept a name or number.
type IntOrStringArgs struct {
	// The int value.
	IntVal pulumi.IntPtrInput `pulumi:"intVal"`
	// The string value.
	StrVal pulumi.StringPtrInput `pulumi:"strVal"`
	// The type of the value.
	Type pulumi.IntPtrInput `pulumi:"type"`
}

func (IntOrStringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IntOrString)(nil)).Elem()
}

func (i IntOrStringArgs) ToIntOrStringOutput() IntOrStringOutput {
	return i.ToIntOrStringOutputWithContext(context.Background())
}

func (i IntOrStringArgs) ToIntOrStringOutputWithContext(ctx context.Context) IntOrStringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntOrStringOutput)
}

func (i IntOrStringArgs) ToIntOrStringPtrOutput() IntOrStringPtrOutput {
	return i.ToIntOrStringPtrOutputWithContext(context.Background())
}

func (i IntOrStringArgs) ToIntOrStringPtrOutputWithContext(ctx context.Context) IntOrStringPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntOrStringOutput).ToIntOrStringPtrOutputWithContext(ctx)
}

// IntOrStringPtrInput is an input type that accepts IntOrStringArgs, IntOrStringPtr and IntOrStringPtrOutput values.
// You can construct a concrete instance of `IntOrStringPtrInput` via:
//
//          IntOrStringArgs{...}
//
//  or:
//
//          nil
type IntOrStringPtrInput interface {
	pulumi.Input

	ToIntOrStringPtrOutput() IntOrStringPtrOutput
	ToIntOrStringPtrOutputWithContext(context.Context) IntOrStringPtrOutput
}

type intOrStringPtrType IntOrStringArgs

func IntOrStringPtr(v *IntOrStringArgs) IntOrStringPtrInput {
	return (*intOrStringPtrType)(v)
}

func (*intOrStringPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IntOrString)(nil)).Elem()
}

func (i *intOrStringPtrType) ToIntOrStringPtrOutput() IntOrStringPtrOutput {
	return i.ToIntOrStringPtrOutputWithContext(context.Background())
}

func (i *intOrStringPtrType) ToIntOrStringPtrOutputWithContext(ctx context.Context) IntOrStringPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntOrStringPtrOutput)
}

// IntOrString is a type that can hold an int32 or a string. When used in JSON or YAML marshalling and unmarshalling, it produces or consumes the inner type. This allows you to have, for example, a JSON field that can accept a name or number.
type IntOrStringOutput struct{ *pulumi.OutputState }

func (IntOrStringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IntOrString)(nil)).Elem()
}

func (o IntOrStringOutput) ToIntOrStringOutput() IntOrStringOutput {
	return o
}

func (o IntOrStringOutput) ToIntOrStringOutputWithContext(ctx context.Context) IntOrStringOutput {
	return o
}

func (o IntOrStringOutput) ToIntOrStringPtrOutput() IntOrStringPtrOutput {
	return o.ToIntOrStringPtrOutputWithContext(context.Background())
}

func (o IntOrStringOutput) ToIntOrStringPtrOutputWithContext(ctx context.Context) IntOrStringPtrOutput {
	return o.ApplyT(func(v IntOrString) *IntOrString {
		return &v
	}).(IntOrStringPtrOutput)
}

// The int value.
func (o IntOrStringOutput) IntVal() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IntOrString) *int { return v.IntVal }).(pulumi.IntPtrOutput)
}

// The string value.
func (o IntOrStringOutput) StrVal() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IntOrString) *string { return v.StrVal }).(pulumi.StringPtrOutput)
}

// The type of the value.
func (o IntOrStringOutput) Type() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IntOrString) *int { return v.Type }).(pulumi.IntPtrOutput)
}

type IntOrStringPtrOutput struct{ *pulumi.OutputState }

func (IntOrStringPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IntOrString)(nil)).Elem()
}

func (o IntOrStringPtrOutput) ToIntOrStringPtrOutput() IntOrStringPtrOutput {
	return o
}

func (o IntOrStringPtrOutput) ToIntOrStringPtrOutputWithContext(ctx context.Context) IntOrStringPtrOutput {
	return o
}

func (o IntOrStringPtrOutput) Elem() IntOrStringOutput {
	return o.ApplyT(func(v *IntOrString) IntOrString { return *v }).(IntOrStringOutput)
}

// The int value.
func (o IntOrStringPtrOutput) IntVal() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IntOrString) *int {
		if v == nil {
			return nil
		}
		return v.IntVal
	}).(pulumi.IntPtrOutput)
}

// The string value.
func (o IntOrStringPtrOutput) StrVal() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IntOrString) *string {
		if v == nil {
			return nil
		}
		return v.StrVal
	}).(pulumi.StringPtrOutput)
}

// The type of the value.
func (o IntOrStringPtrOutput) Type() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IntOrString) *int {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.IntPtrOutput)
}

// JobCondition defines a readiness condition for a Revision.
type JobCondition struct {
	// Optional. Last time the condition transitioned from one status to another.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// Optional. Human readable message indicating details about the current status.
	Message *string `pulumi:"message"`
	// Optional. One-word CamelCase reason for the condition's last transition.
	Reason *string `pulumi:"reason"`
	// Optional. How to interpret failures of this condition, one of Error, Warning, Info
	Severity *string `pulumi:"severity"`
	// Required. Status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// Required. Type is used to communicate the status of the reconciliation process. See also: https://github.com/knative/serving/blob/master/docs/spec/errors.md#error-conditions-and-reporting Types include: * "Completed": True when the Job has successfully completed. * "Started": True when the Job has successfully started running. * "ResourcesAvailable": True when underlying resources have been provisioned.
	Type *string `pulumi:"type"`
}

// JobConditionInput is an input type that accepts JobConditionArgs and JobConditionOutput values.
// You can construct a concrete instance of `JobConditionInput` via:
//
//          JobConditionArgs{...}
type JobConditionInput interface {
	pulumi.Input

	ToJobConditionOutput() JobConditionOutput
	ToJobConditionOutputWithContext(context.Context) JobConditionOutput
}

// JobCondition defines a readiness condition for a Revision.
type JobConditionArgs struct {
	// Optional. Last time the condition transitioned from one status to another.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// Optional. Human readable message indicating details about the current status.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// Optional. One-word CamelCase reason for the condition's last transition.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// Optional. How to interpret failures of this condition, one of Error, Warning, Info
	Severity pulumi.StringPtrInput `pulumi:"severity"`
	// Required. Status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// Required. Type is used to communicate the status of the reconciliation process. See also: https://github.com/knative/serving/blob/master/docs/spec/errors.md#error-conditions-and-reporting Types include: * "Completed": True when the Job has successfully completed. * "Started": True when the Job has successfully started running. * "ResourcesAvailable": True when underlying resources have been provisioned.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (JobConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobCondition)(nil)).Elem()
}

func (i JobConditionArgs) ToJobConditionOutput() JobConditionOutput {
	return i.ToJobConditionOutputWithContext(context.Background())
}

func (i JobConditionArgs) ToJobConditionOutputWithContext(ctx context.Context) JobConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobConditionOutput)
}

// JobConditionArrayInput is an input type that accepts JobConditionArray and JobConditionArrayOutput values.
// You can construct a concrete instance of `JobConditionArrayInput` via:
//
//          JobConditionArray{ JobConditionArgs{...} }
type JobConditionArrayInput interface {
	pulumi.Input

	ToJobConditionArrayOutput() JobConditionArrayOutput
	ToJobConditionArrayOutputWithContext(context.Context) JobConditionArrayOutput
}

type JobConditionArray []JobConditionInput

func (JobConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobCondition)(nil)).Elem()
}

func (i JobConditionArray) ToJobConditionArrayOutput() JobConditionArrayOutput {
	return i.ToJobConditionArrayOutputWithContext(context.Background())
}

func (i JobConditionArray) ToJobConditionArrayOutputWithContext(ctx context.Context) JobConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobConditionArrayOutput)
}

// JobCondition defines a readiness condition for a Revision.
type JobConditionOutput struct{ *pulumi.OutputState }

func (JobConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobCondition)(nil)).Elem()
}

func (o JobConditionOutput) ToJobConditionOutput() JobConditionOutput {
	return o
}

func (o JobConditionOutput) ToJobConditionOutputWithContext(ctx context.Context) JobConditionOutput {
	return o
}

// Optional. Last time the condition transitioned from one status to another.
func (o JobConditionOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobCondition) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// Optional. Human readable message indicating details about the current status.
func (o JobConditionOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobCondition) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// Optional. One-word CamelCase reason for the condition's last transition.
func (o JobConditionOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobCondition) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// Optional. How to interpret failures of this condition, one of Error, Warning, Info
func (o JobConditionOutput) Severity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobCondition) *string { return v.Severity }).(pulumi.StringPtrOutput)
}

// Required. Status of the condition, one of True, False, Unknown.
func (o JobConditionOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobCondition) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// Required. Type is used to communicate the status of the reconciliation process. See also: https://github.com/knative/serving/blob/master/docs/spec/errors.md#error-conditions-and-reporting Types include: * "Completed": True when the Job has successfully completed. * "Started": True when the Job has successfully started running. * "ResourcesAvailable": True when underlying resources have been provisioned.
func (o JobConditionOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobCondition) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type JobConditionArrayOutput struct{ *pulumi.OutputState }

func (JobConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]JobCondition)(nil)).Elem()
}

func (o JobConditionArrayOutput) ToJobConditionArrayOutput() JobConditionArrayOutput {
	return o
}

func (o JobConditionArrayOutput) ToJobConditionArrayOutputWithContext(ctx context.Context) JobConditionArrayOutput {
	return o
}

func (o JobConditionArrayOutput) Index(i pulumi.IntInput) JobConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) JobCondition {
		return vs[0].([]JobCondition)[vs[1].(int)]
	}).(JobConditionOutput)
}

// JobSpec describes how the job execution will look like.
type JobSpec struct {
	// Optional. Specifies the duration in seconds relative to the startTime that the job may be active before the system tries to terminate it. If set to zero, the system will never attempt to terminate the job based on time. Otherwise, the value must be positive integer. +optional
	ActiveDeadlineSeconds *string `pulumi:"activeDeadlineSeconds"`
	// Optional. Specifies the number of retries per instance, before marking this job failed. If set to zero, instances will never retry on failure. +optional
	BackoffLimit *int `pulumi:"backoffLimit"`
	// Optional. Specifies the desired number of successfully finished instances the job should be run with. Setting to 1 means that parallelism is limited to 1 and the success of that instance signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ +optional
	Completions *int `pulumi:"completions"`
	// Optional. Specifies the maximum desired number of instances the job should run at any given time. Must be <= completions. The actual number of instances running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ +optional
	Parallelism *int `pulumi:"parallelism"`
	// Optional. Describes the instance that will be created when executing a job.
	Template *InstanceTemplateSpec `pulumi:"template"`
	// Optional. ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job won't be automatically deleted. +optional
	TtlSecondsAfterFinished *int `pulumi:"ttlSecondsAfterFinished"`
}

// JobSpecInput is an input type that accepts JobSpecArgs and JobSpecOutput values.
// You can construct a concrete instance of `JobSpecInput` via:
//
//          JobSpecArgs{...}
type JobSpecInput interface {
	pulumi.Input

	ToJobSpecOutput() JobSpecOutput
	ToJobSpecOutputWithContext(context.Context) JobSpecOutput
}

// JobSpec describes how the job execution will look like.
type JobSpecArgs struct {
	// Optional. Specifies the duration in seconds relative to the startTime that the job may be active before the system tries to terminate it. If set to zero, the system will never attempt to terminate the job based on time. Otherwise, the value must be positive integer. +optional
	ActiveDeadlineSeconds pulumi.StringPtrInput `pulumi:"activeDeadlineSeconds"`
	// Optional. Specifies the number of retries per instance, before marking this job failed. If set to zero, instances will never retry on failure. +optional
	BackoffLimit pulumi.IntPtrInput `pulumi:"backoffLimit"`
	// Optional. Specifies the desired number of successfully finished instances the job should be run with. Setting to 1 means that parallelism is limited to 1 and the success of that instance signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ +optional
	Completions pulumi.IntPtrInput `pulumi:"completions"`
	// Optional. Specifies the maximum desired number of instances the job should run at any given time. Must be <= completions. The actual number of instances running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ +optional
	Parallelism pulumi.IntPtrInput `pulumi:"parallelism"`
	// Optional. Describes the instance that will be created when executing a job.
	Template InstanceTemplateSpecPtrInput `pulumi:"template"`
	// Optional. ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job won't be automatically deleted. +optional
	TtlSecondsAfterFinished pulumi.IntPtrInput `pulumi:"ttlSecondsAfterFinished"`
}

func (JobSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobSpec)(nil)).Elem()
}

func (i JobSpecArgs) ToJobSpecOutput() JobSpecOutput {
	return i.ToJobSpecOutputWithContext(context.Background())
}

func (i JobSpecArgs) ToJobSpecOutputWithContext(ctx context.Context) JobSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobSpecOutput)
}

func (i JobSpecArgs) ToJobSpecPtrOutput() JobSpecPtrOutput {
	return i.ToJobSpecPtrOutputWithContext(context.Background())
}

func (i JobSpecArgs) ToJobSpecPtrOutputWithContext(ctx context.Context) JobSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobSpecOutput).ToJobSpecPtrOutputWithContext(ctx)
}

// JobSpecPtrInput is an input type that accepts JobSpecArgs, JobSpecPtr and JobSpecPtrOutput values.
// You can construct a concrete instance of `JobSpecPtrInput` via:
//
//          JobSpecArgs{...}
//
//  or:
//
//          nil
type JobSpecPtrInput interface {
	pulumi.Input

	ToJobSpecPtrOutput() JobSpecPtrOutput
	ToJobSpecPtrOutputWithContext(context.Context) JobSpecPtrOutput
}

type jobSpecPtrType JobSpecArgs

func JobSpecPtr(v *JobSpecArgs) JobSpecPtrInput {
	return (*jobSpecPtrType)(v)
}

func (*jobSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**JobSpec)(nil)).Elem()
}

func (i *jobSpecPtrType) ToJobSpecPtrOutput() JobSpecPtrOutput {
	return i.ToJobSpecPtrOutputWithContext(context.Background())
}

func (i *jobSpecPtrType) ToJobSpecPtrOutputWithContext(ctx context.Context) JobSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobSpecPtrOutput)
}

// JobSpec describes how the job execution will look like.
type JobSpecOutput struct{ *pulumi.OutputState }

func (JobSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobSpec)(nil)).Elem()
}

func (o JobSpecOutput) ToJobSpecOutput() JobSpecOutput {
	return o
}

func (o JobSpecOutput) ToJobSpecOutputWithContext(ctx context.Context) JobSpecOutput {
	return o
}

func (o JobSpecOutput) ToJobSpecPtrOutput() JobSpecPtrOutput {
	return o.ToJobSpecPtrOutputWithContext(context.Background())
}

func (o JobSpecOutput) ToJobSpecPtrOutputWithContext(ctx context.Context) JobSpecPtrOutput {
	return o.ApplyT(func(v JobSpec) *JobSpec {
		return &v
	}).(JobSpecPtrOutput)
}

// Optional. Specifies the duration in seconds relative to the startTime that the job may be active before the system tries to terminate it. If set to zero, the system will never attempt to terminate the job based on time. Otherwise, the value must be positive integer. +optional
func (o JobSpecOutput) ActiveDeadlineSeconds() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobSpec) *string { return v.ActiveDeadlineSeconds }).(pulumi.StringPtrOutput)
}

// Optional. Specifies the number of retries per instance, before marking this job failed. If set to zero, instances will never retry on failure. +optional
func (o JobSpecOutput) BackoffLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JobSpec) *int { return v.BackoffLimit }).(pulumi.IntPtrOutput)
}

// Optional. Specifies the desired number of successfully finished instances the job should be run with. Setting to 1 means that parallelism is limited to 1 and the success of that instance signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ +optional
func (o JobSpecOutput) Completions() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JobSpec) *int { return v.Completions }).(pulumi.IntPtrOutput)
}

// Optional. Specifies the maximum desired number of instances the job should run at any given time. Must be <= completions. The actual number of instances running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ +optional
func (o JobSpecOutput) Parallelism() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JobSpec) *int { return v.Parallelism }).(pulumi.IntPtrOutput)
}

// Optional. Describes the instance that will be created when executing a job.
func (o JobSpecOutput) Template() InstanceTemplateSpecPtrOutput {
	return o.ApplyT(func(v JobSpec) *InstanceTemplateSpec { return v.Template }).(InstanceTemplateSpecPtrOutput)
}

// Optional. ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job won't be automatically deleted. +optional
func (o JobSpecOutput) TtlSecondsAfterFinished() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JobSpec) *int { return v.TtlSecondsAfterFinished }).(pulumi.IntPtrOutput)
}

type JobSpecPtrOutput struct{ *pulumi.OutputState }

func (JobSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**JobSpec)(nil)).Elem()
}

func (o JobSpecPtrOutput) ToJobSpecPtrOutput() JobSpecPtrOutput {
	return o
}

func (o JobSpecPtrOutput) ToJobSpecPtrOutputWithContext(ctx context.Context) JobSpecPtrOutput {
	return o
}

func (o JobSpecPtrOutput) Elem() JobSpecOutput {
	return o.ApplyT(func(v *JobSpec) JobSpec { return *v }).(JobSpecOutput)
}

// Optional. Specifies the duration in seconds relative to the startTime that the job may be active before the system tries to terminate it. If set to zero, the system will never attempt to terminate the job based on time. Otherwise, the value must be positive integer. +optional
func (o JobSpecPtrOutput) ActiveDeadlineSeconds() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobSpec) *string {
		if v == nil {
			return nil
		}
		return v.ActiveDeadlineSeconds
	}).(pulumi.StringPtrOutput)
}

// Optional. Specifies the number of retries per instance, before marking this job failed. If set to zero, instances will never retry on failure. +optional
func (o JobSpecPtrOutput) BackoffLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *JobSpec) *int {
		if v == nil {
			return nil
		}
		return v.BackoffLimit
	}).(pulumi.IntPtrOutput)
}

// Optional. Specifies the desired number of successfully finished instances the job should be run with. Setting to 1 means that parallelism is limited to 1 and the success of that instance signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ +optional
func (o JobSpecPtrOutput) Completions() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *JobSpec) *int {
		if v == nil {
			return nil
		}
		return v.Completions
	}).(pulumi.IntPtrOutput)
}

// Optional. Specifies the maximum desired number of instances the job should run at any given time. Must be <= completions. The actual number of instances running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ +optional
func (o JobSpecPtrOutput) Parallelism() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *JobSpec) *int {
		if v == nil {
			return nil
		}
		return v.Parallelism
	}).(pulumi.IntPtrOutput)
}

// Optional. Describes the instance that will be created when executing a job.
func (o JobSpecPtrOutput) Template() InstanceTemplateSpecPtrOutput {
	return o.ApplyT(func(v *JobSpec) *InstanceTemplateSpec {
		if v == nil {
			return nil
		}
		return v.Template
	}).(InstanceTemplateSpecPtrOutput)
}

// Optional. ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job won't be automatically deleted. +optional
func (o JobSpecPtrOutput) TtlSecondsAfterFinished() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *JobSpec) *int {
		if v == nil {
			return nil
		}
		return v.TtlSecondsAfterFinished
	}).(pulumi.IntPtrOutput)
}

// JobStatus represents the current state of a Job.
type JobStatus struct {
	// Optional. The number of actively running instances. +optional
	Active *int `pulumi:"active"`
	// Optional. Represents time when the job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. +optional
	CompletionTime *string `pulumi:"completionTime"`
	// Optional. The latest available observations of a job's current state. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ +optional
	Conditions []JobCondition `pulumi:"conditions"`
	// Optional. The number of instances which reached phase Failed. +optional
	Failed *int `pulumi:"failed"`
	// Optional. ImageDigest holds the resolved digest for the image specified within .Spec.Template.Spec.Container.Image. The digest is resolved during the creation of the Job. This field holds the digest value regardless of whether a tag or digest was originally specified in the Container object.
	ImageDigest *string `pulumi:"imageDigest"`
	// Optional. Status of completed, failed, and running instances. +optional
	Instances []InstanceStatus `pulumi:"instances"`
	// Optional. The 'generation' of the job that was last processed by the controller.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// Optional. Represents time when the job was acknowledged by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. +optional
	StartTime *string `pulumi:"startTime"`
	// Optional. The number of instances which reached phase Succeeded. +optional
	Succeeded *int `pulumi:"succeeded"`
}

// JobStatusInput is an input type that accepts JobStatusArgs and JobStatusOutput values.
// You can construct a concrete instance of `JobStatusInput` via:
//
//          JobStatusArgs{...}
type JobStatusInput interface {
	pulumi.Input

	ToJobStatusOutput() JobStatusOutput
	ToJobStatusOutputWithContext(context.Context) JobStatusOutput
}

// JobStatus represents the current state of a Job.
type JobStatusArgs struct {
	// Optional. The number of actively running instances. +optional
	Active pulumi.IntPtrInput `pulumi:"active"`
	// Optional. Represents time when the job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. +optional
	CompletionTime pulumi.StringPtrInput `pulumi:"completionTime"`
	// Optional. The latest available observations of a job's current state. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ +optional
	Conditions JobConditionArrayInput `pulumi:"conditions"`
	// Optional. The number of instances which reached phase Failed. +optional
	Failed pulumi.IntPtrInput `pulumi:"failed"`
	// Optional. ImageDigest holds the resolved digest for the image specified within .Spec.Template.Spec.Container.Image. The digest is resolved during the creation of the Job. This field holds the digest value regardless of whether a tag or digest was originally specified in the Container object.
	ImageDigest pulumi.StringPtrInput `pulumi:"imageDigest"`
	// Optional. Status of completed, failed, and running instances. +optional
	Instances InstanceStatusArrayInput `pulumi:"instances"`
	// Optional. The 'generation' of the job that was last processed by the controller.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// Optional. Represents time when the job was acknowledged by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. +optional
	StartTime pulumi.StringPtrInput `pulumi:"startTime"`
	// Optional. The number of instances which reached phase Succeeded. +optional
	Succeeded pulumi.IntPtrInput `pulumi:"succeeded"`
}

func (JobStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobStatus)(nil)).Elem()
}

func (i JobStatusArgs) ToJobStatusOutput() JobStatusOutput {
	return i.ToJobStatusOutputWithContext(context.Background())
}

func (i JobStatusArgs) ToJobStatusOutputWithContext(ctx context.Context) JobStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobStatusOutput)
}

func (i JobStatusArgs) ToJobStatusPtrOutput() JobStatusPtrOutput {
	return i.ToJobStatusPtrOutputWithContext(context.Background())
}

func (i JobStatusArgs) ToJobStatusPtrOutputWithContext(ctx context.Context) JobStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobStatusOutput).ToJobStatusPtrOutputWithContext(ctx)
}

// JobStatusPtrInput is an input type that accepts JobStatusArgs, JobStatusPtr and JobStatusPtrOutput values.
// You can construct a concrete instance of `JobStatusPtrInput` via:
//
//          JobStatusArgs{...}
//
//  or:
//
//          nil
type JobStatusPtrInput interface {
	pulumi.Input

	ToJobStatusPtrOutput() JobStatusPtrOutput
	ToJobStatusPtrOutputWithContext(context.Context) JobStatusPtrOutput
}

type jobStatusPtrType JobStatusArgs

func JobStatusPtr(v *JobStatusArgs) JobStatusPtrInput {
	return (*jobStatusPtrType)(v)
}

func (*jobStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**JobStatus)(nil)).Elem()
}

func (i *jobStatusPtrType) ToJobStatusPtrOutput() JobStatusPtrOutput {
	return i.ToJobStatusPtrOutputWithContext(context.Background())
}

func (i *jobStatusPtrType) ToJobStatusPtrOutputWithContext(ctx context.Context) JobStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobStatusPtrOutput)
}

// JobStatus represents the current state of a Job.
type JobStatusOutput struct{ *pulumi.OutputState }

func (JobStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobStatus)(nil)).Elem()
}

func (o JobStatusOutput) ToJobStatusOutput() JobStatusOutput {
	return o
}

func (o JobStatusOutput) ToJobStatusOutputWithContext(ctx context.Context) JobStatusOutput {
	return o
}

func (o JobStatusOutput) ToJobStatusPtrOutput() JobStatusPtrOutput {
	return o.ToJobStatusPtrOutputWithContext(context.Background())
}

func (o JobStatusOutput) ToJobStatusPtrOutputWithContext(ctx context.Context) JobStatusPtrOutput {
	return o.ApplyT(func(v JobStatus) *JobStatus {
		return &v
	}).(JobStatusPtrOutput)
}

// Optional. The number of actively running instances. +optional
func (o JobStatusOutput) Active() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JobStatus) *int { return v.Active }).(pulumi.IntPtrOutput)
}

// Optional. Represents time when the job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. +optional
func (o JobStatusOutput) CompletionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobStatus) *string { return v.CompletionTime }).(pulumi.StringPtrOutput)
}

// Optional. The latest available observations of a job's current state. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ +optional
func (o JobStatusOutput) Conditions() JobConditionArrayOutput {
	return o.ApplyT(func(v JobStatus) []JobCondition { return v.Conditions }).(JobConditionArrayOutput)
}

// Optional. The number of instances which reached phase Failed. +optional
func (o JobStatusOutput) Failed() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JobStatus) *int { return v.Failed }).(pulumi.IntPtrOutput)
}

// Optional. ImageDigest holds the resolved digest for the image specified within .Spec.Template.Spec.Container.Image. The digest is resolved during the creation of the Job. This field holds the digest value regardless of whether a tag or digest was originally specified in the Container object.
func (o JobStatusOutput) ImageDigest() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobStatus) *string { return v.ImageDigest }).(pulumi.StringPtrOutput)
}

// Optional. Status of completed, failed, and running instances. +optional
func (o JobStatusOutput) Instances() InstanceStatusArrayOutput {
	return o.ApplyT(func(v JobStatus) []InstanceStatus { return v.Instances }).(InstanceStatusArrayOutput)
}

// Optional. The 'generation' of the job that was last processed by the controller.
func (o JobStatusOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JobStatus) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// Optional. Represents time when the job was acknowledged by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. +optional
func (o JobStatusOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobStatus) *string { return v.StartTime }).(pulumi.StringPtrOutput)
}

// Optional. The number of instances which reached phase Succeeded. +optional
func (o JobStatusOutput) Succeeded() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JobStatus) *int { return v.Succeeded }).(pulumi.IntPtrOutput)
}

type JobStatusPtrOutput struct{ *pulumi.OutputState }

func (JobStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**JobStatus)(nil)).Elem()
}

func (o JobStatusPtrOutput) ToJobStatusPtrOutput() JobStatusPtrOutput {
	return o
}

func (o JobStatusPtrOutput) ToJobStatusPtrOutputWithContext(ctx context.Context) JobStatusPtrOutput {
	return o
}

func (o JobStatusPtrOutput) Elem() JobStatusOutput {
	return o.ApplyT(func(v *JobStatus) JobStatus { return *v }).(JobStatusOutput)
}

// Optional. The number of actively running instances. +optional
func (o JobStatusPtrOutput) Active() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *JobStatus) *int {
		if v == nil {
			return nil
		}
		return v.Active
	}).(pulumi.IntPtrOutput)
}

// Optional. Represents time when the job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. +optional
func (o JobStatusPtrOutput) CompletionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobStatus) *string {
		if v == nil {
			return nil
		}
		return v.CompletionTime
	}).(pulumi.StringPtrOutput)
}

// Optional. The latest available observations of a job's current state. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ +optional
func (o JobStatusPtrOutput) Conditions() JobConditionArrayOutput {
	return o.ApplyT(func(v *JobStatus) []JobCondition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(JobConditionArrayOutput)
}

// Optional. The number of instances which reached phase Failed. +optional
func (o JobStatusPtrOutput) Failed() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *JobStatus) *int {
		if v == nil {
			return nil
		}
		return v.Failed
	}).(pulumi.IntPtrOutput)
}

// Optional. ImageDigest holds the resolved digest for the image specified within .Spec.Template.Spec.Container.Image. The digest is resolved during the creation of the Job. This field holds the digest value regardless of whether a tag or digest was originally specified in the Container object.
func (o JobStatusPtrOutput) ImageDigest() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobStatus) *string {
		if v == nil {
			return nil
		}
		return v.ImageDigest
	}).(pulumi.StringPtrOutput)
}

// Optional. Status of completed, failed, and running instances. +optional
func (o JobStatusPtrOutput) Instances() InstanceStatusArrayOutput {
	return o.ApplyT(func(v *JobStatus) []InstanceStatus {
		if v == nil {
			return nil
		}
		return v.Instances
	}).(InstanceStatusArrayOutput)
}

// Optional. The 'generation' of the job that was last processed by the controller.
func (o JobStatusPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *JobStatus) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

// Optional. Represents time when the job was acknowledged by the job controller. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. +optional
func (o JobStatusPtrOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobStatus) *string {
		if v == nil {
			return nil
		}
		return v.StartTime
	}).(pulumi.StringPtrOutput)
}

// Optional. The number of instances which reached phase Succeeded. +optional
func (o JobStatusPtrOutput) Succeeded() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *JobStatus) *int {
		if v == nil {
			return nil
		}
		return v.Succeeded
	}).(pulumi.IntPtrOutput)
}

// Maps a string key to a path within a volume.
type KeyToPath struct {
	// The key to project.
	Key *string `pulumi:"key"`
	// Mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. +optional
	Mode *int `pulumi:"mode"`
	// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
	Path *string `pulumi:"path"`
}

// KeyToPathInput is an input type that accepts KeyToPathArgs and KeyToPathOutput values.
// You can construct a concrete instance of `KeyToPathInput` via:
//
//          KeyToPathArgs{...}
type KeyToPathInput interface {
	pulumi.Input

	ToKeyToPathOutput() KeyToPathOutput
	ToKeyToPathOutputWithContext(context.Context) KeyToPathOutput
}

// Maps a string key to a path within a volume.
type KeyToPathArgs struct {
	// The key to project.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. +optional
	Mode pulumi.IntPtrInput `pulumi:"mode"`
	// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
	Path pulumi.StringPtrInput `pulumi:"path"`
}

func (KeyToPathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyToPath)(nil)).Elem()
}

func (i KeyToPathArgs) ToKeyToPathOutput() KeyToPathOutput {
	return i.ToKeyToPathOutputWithContext(context.Background())
}

func (i KeyToPathArgs) ToKeyToPathOutputWithContext(ctx context.Context) KeyToPathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyToPathOutput)
}

// KeyToPathArrayInput is an input type that accepts KeyToPathArray and KeyToPathArrayOutput values.
// You can construct a concrete instance of `KeyToPathArrayInput` via:
//
//          KeyToPathArray{ KeyToPathArgs{...} }
type KeyToPathArrayInput interface {
	pulumi.Input

	ToKeyToPathArrayOutput() KeyToPathArrayOutput
	ToKeyToPathArrayOutputWithContext(context.Context) KeyToPathArrayOutput
}

type KeyToPathArray []KeyToPathInput

func (KeyToPathArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KeyToPath)(nil)).Elem()
}

func (i KeyToPathArray) ToKeyToPathArrayOutput() KeyToPathArrayOutput {
	return i.ToKeyToPathArrayOutputWithContext(context.Background())
}

func (i KeyToPathArray) ToKeyToPathArrayOutputWithContext(ctx context.Context) KeyToPathArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyToPathArrayOutput)
}

// Maps a string key to a path within a volume.
type KeyToPathOutput struct{ *pulumi.OutputState }

func (KeyToPathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyToPath)(nil)).Elem()
}

func (o KeyToPathOutput) ToKeyToPathOutput() KeyToPathOutput {
	return o
}

func (o KeyToPathOutput) ToKeyToPathOutputWithContext(ctx context.Context) KeyToPathOutput {
	return o
}

// The key to project.
func (o KeyToPathOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KeyToPath) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. +optional
func (o KeyToPathOutput) Mode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v KeyToPath) *int { return v.Mode }).(pulumi.IntPtrOutput)
}

// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
func (o KeyToPathOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KeyToPath) *string { return v.Path }).(pulumi.StringPtrOutput)
}

type KeyToPathArrayOutput struct{ *pulumi.OutputState }

func (KeyToPathArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KeyToPath)(nil)).Elem()
}

func (o KeyToPathArrayOutput) ToKeyToPathArrayOutput() KeyToPathArrayOutput {
	return o
}

func (o KeyToPathArrayOutput) ToKeyToPathArrayOutputWithContext(ctx context.Context) KeyToPathArrayOutput {
	return o
}

func (o KeyToPathArrayOutput) Index(i pulumi.IntInput) KeyToPathOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KeyToPath {
		return vs[0].([]KeyToPath)[vs[1].(int)]
	}).(KeyToPathOutput)
}

// Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
type Lifecycle struct {
	// PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks +optional
	PostStart *Handler `pulumi:"postStart"`
	// PreStop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks +optional
	PreStop *Handler `pulumi:"preStop"`
}

// LifecycleInput is an input type that accepts LifecycleArgs and LifecycleOutput values.
// You can construct a concrete instance of `LifecycleInput` via:
//
//          LifecycleArgs{...}
type LifecycleInput interface {
	pulumi.Input

	ToLifecycleOutput() LifecycleOutput
	ToLifecycleOutputWithContext(context.Context) LifecycleOutput
}

// Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
type LifecycleArgs struct {
	// PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks +optional
	PostStart HandlerPtrInput `pulumi:"postStart"`
	// PreStop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks +optional
	PreStop HandlerPtrInput `pulumi:"preStop"`
}

func (LifecycleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Lifecycle)(nil)).Elem()
}

func (i LifecycleArgs) ToLifecycleOutput() LifecycleOutput {
	return i.ToLifecycleOutputWithContext(context.Background())
}

func (i LifecycleArgs) ToLifecycleOutputWithContext(ctx context.Context) LifecycleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LifecycleOutput)
}

func (i LifecycleArgs) ToLifecyclePtrOutput() LifecyclePtrOutput {
	return i.ToLifecyclePtrOutputWithContext(context.Background())
}

func (i LifecycleArgs) ToLifecyclePtrOutputWithContext(ctx context.Context) LifecyclePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LifecycleOutput).ToLifecyclePtrOutputWithContext(ctx)
}

// LifecyclePtrInput is an input type that accepts LifecycleArgs, LifecyclePtr and LifecyclePtrOutput values.
// You can construct a concrete instance of `LifecyclePtrInput` via:
//
//          LifecycleArgs{...}
//
//  or:
//
//          nil
type LifecyclePtrInput interface {
	pulumi.Input

	ToLifecyclePtrOutput() LifecyclePtrOutput
	ToLifecyclePtrOutputWithContext(context.Context) LifecyclePtrOutput
}

type lifecyclePtrType LifecycleArgs

func LifecyclePtr(v *LifecycleArgs) LifecyclePtrInput {
	return (*lifecyclePtrType)(v)
}

func (*lifecyclePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Lifecycle)(nil)).Elem()
}

func (i *lifecyclePtrType) ToLifecyclePtrOutput() LifecyclePtrOutput {
	return i.ToLifecyclePtrOutputWithContext(context.Background())
}

func (i *lifecyclePtrType) ToLifecyclePtrOutputWithContext(ctx context.Context) LifecyclePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LifecyclePtrOutput)
}

// Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
type LifecycleOutput struct{ *pulumi.OutputState }

func (LifecycleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Lifecycle)(nil)).Elem()
}

func (o LifecycleOutput) ToLifecycleOutput() LifecycleOutput {
	return o
}

func (o LifecycleOutput) ToLifecycleOutputWithContext(ctx context.Context) LifecycleOutput {
	return o
}

func (o LifecycleOutput) ToLifecyclePtrOutput() LifecyclePtrOutput {
	return o.ToLifecyclePtrOutputWithContext(context.Background())
}

func (o LifecycleOutput) ToLifecyclePtrOutputWithContext(ctx context.Context) LifecyclePtrOutput {
	return o.ApplyT(func(v Lifecycle) *Lifecycle {
		return &v
	}).(LifecyclePtrOutput)
}

// PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks +optional
func (o LifecycleOutput) PostStart() HandlerPtrOutput {
	return o.ApplyT(func(v Lifecycle) *Handler { return v.PostStart }).(HandlerPtrOutput)
}

// PreStop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks +optional
func (o LifecycleOutput) PreStop() HandlerPtrOutput {
	return o.ApplyT(func(v Lifecycle) *Handler { return v.PreStop }).(HandlerPtrOutput)
}

type LifecyclePtrOutput struct{ *pulumi.OutputState }

func (LifecyclePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Lifecycle)(nil)).Elem()
}

func (o LifecyclePtrOutput) ToLifecyclePtrOutput() LifecyclePtrOutput {
	return o
}

func (o LifecyclePtrOutput) ToLifecyclePtrOutputWithContext(ctx context.Context) LifecyclePtrOutput {
	return o
}

func (o LifecyclePtrOutput) Elem() LifecycleOutput {
	return o.ApplyT(func(v *Lifecycle) Lifecycle { return *v }).(LifecycleOutput)
}

// PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks +optional
func (o LifecyclePtrOutput) PostStart() HandlerPtrOutput {
	return o.ApplyT(func(v *Lifecycle) *Handler {
		if v == nil {
			return nil
		}
		return v.PostStart
	}).(HandlerPtrOutput)
}

// PreStop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks +optional
func (o LifecyclePtrOutput) PreStop() HandlerPtrOutput {
	return o.ApplyT(func(v *Lifecycle) *Handler {
		if v == nil {
			return nil
		}
		return v.PreStop
	}).(HandlerPtrOutput)
}

// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
type LocalObjectReference struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// LocalObjectReferenceInput is an input type that accepts LocalObjectReferenceArgs and LocalObjectReferenceOutput values.
// You can construct a concrete instance of `LocalObjectReferenceInput` via:
//
//          LocalObjectReferenceArgs{...}
type LocalObjectReferenceInput interface {
	pulumi.Input

	ToLocalObjectReferenceOutput() LocalObjectReferenceOutput
	ToLocalObjectReferenceOutputWithContext(context.Context) LocalObjectReferenceOutput
}

// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
type LocalObjectReferenceArgs struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (LocalObjectReferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LocalObjectReference)(nil)).Elem()
}

func (i LocalObjectReferenceArgs) ToLocalObjectReferenceOutput() LocalObjectReferenceOutput {
	return i.ToLocalObjectReferenceOutputWithContext(context.Background())
}

func (i LocalObjectReferenceArgs) ToLocalObjectReferenceOutputWithContext(ctx context.Context) LocalObjectReferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocalObjectReferenceOutput)
}

func (i LocalObjectReferenceArgs) ToLocalObjectReferencePtrOutput() LocalObjectReferencePtrOutput {
	return i.ToLocalObjectReferencePtrOutputWithContext(context.Background())
}

func (i LocalObjectReferenceArgs) ToLocalObjectReferencePtrOutputWithContext(ctx context.Context) LocalObjectReferencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocalObjectReferenceOutput).ToLocalObjectReferencePtrOutputWithContext(ctx)
}

// LocalObjectReferencePtrInput is an input type that accepts LocalObjectReferenceArgs, LocalObjectReferencePtr and LocalObjectReferencePtrOutput values.
// You can construct a concrete instance of `LocalObjectReferencePtrInput` via:
//
//          LocalObjectReferenceArgs{...}
//
//  or:
//
//          nil
type LocalObjectReferencePtrInput interface {
	pulumi.Input

	ToLocalObjectReferencePtrOutput() LocalObjectReferencePtrOutput
	ToLocalObjectReferencePtrOutputWithContext(context.Context) LocalObjectReferencePtrOutput
}

type localObjectReferencePtrType LocalObjectReferenceArgs

func LocalObjectReferencePtr(v *LocalObjectReferenceArgs) LocalObjectReferencePtrInput {
	return (*localObjectReferencePtrType)(v)
}

func (*localObjectReferencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LocalObjectReference)(nil)).Elem()
}

func (i *localObjectReferencePtrType) ToLocalObjectReferencePtrOutput() LocalObjectReferencePtrOutput {
	return i.ToLocalObjectReferencePtrOutputWithContext(context.Background())
}

func (i *localObjectReferencePtrType) ToLocalObjectReferencePtrOutputWithContext(ctx context.Context) LocalObjectReferencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocalObjectReferencePtrOutput)
}

// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
type LocalObjectReferenceOutput struct{ *pulumi.OutputState }

func (LocalObjectReferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LocalObjectReference)(nil)).Elem()
}

func (o LocalObjectReferenceOutput) ToLocalObjectReferenceOutput() LocalObjectReferenceOutput {
	return o
}

func (o LocalObjectReferenceOutput) ToLocalObjectReferenceOutputWithContext(ctx context.Context) LocalObjectReferenceOutput {
	return o
}

func (o LocalObjectReferenceOutput) ToLocalObjectReferencePtrOutput() LocalObjectReferencePtrOutput {
	return o.ToLocalObjectReferencePtrOutputWithContext(context.Background())
}

func (o LocalObjectReferenceOutput) ToLocalObjectReferencePtrOutputWithContext(ctx context.Context) LocalObjectReferencePtrOutput {
	return o.ApplyT(func(v LocalObjectReference) *LocalObjectReference {
		return &v
	}).(LocalObjectReferencePtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o LocalObjectReferenceOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LocalObjectReference) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type LocalObjectReferencePtrOutput struct{ *pulumi.OutputState }

func (LocalObjectReferencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LocalObjectReference)(nil)).Elem()
}

func (o LocalObjectReferencePtrOutput) ToLocalObjectReferencePtrOutput() LocalObjectReferencePtrOutput {
	return o
}

func (o LocalObjectReferencePtrOutput) ToLocalObjectReferencePtrOutputWithContext(ctx context.Context) LocalObjectReferencePtrOutput {
	return o
}

func (o LocalObjectReferencePtrOutput) Elem() LocalObjectReferenceOutput {
	return o.ApplyT(func(v *LocalObjectReference) LocalObjectReference { return *v }).(LocalObjectReferenceOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o LocalObjectReferencePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LocalObjectReference) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
type ObjectMeta struct {
	// Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations +optional
	Annotations map[string]string `pulumi:"annotations"`
	// Not currently supported by Cloud Run. The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request. +optional
	ClusterName *string `pulumi:"clusterName"`
	// CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC. Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata +optional
	CreationTimestamp *string `pulumi:"creationTimestamp"`
	// Not currently supported by Cloud Run. Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only. +optional
	DeletionGracePeriodSeconds *int `pulumi:"deletionGracePeriodSeconds"`
	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested. Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata +optional
	DeletionTimestamp *string `pulumi:"deletionTimestamp"`
	// Not currently supported by Cloud Run. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. +optional +patchStrategy=merge
	Finalizers []string `pulumi:"finalizers"`
	// Not currently supported by Cloud Run. GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server. If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header). Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency +optional string generateName = 2;
	GenerateName *string `pulumi:"generateName"`
	// A sequence number representing a specific generation of the desired state. Populated by the system. Read-only. +optional
	Generation *int `pulumi:"generation"`
	// Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and routes. More info: http://kubernetes.io/docs/user-guide/labels +optional
	Labels map[string]string `pulumi:"labels"`
	// Name must be unique within a namespace, within a Cloud Run region. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names +optional
	Name *string `pulumi:"name"`
	// Namespace defines the space within each name must be unique, within a Cloud Run region. In Cloud Run the namespace must be equal to either the project ID or project number.
	Namespace *string `pulumi:"namespace"`
	// List of objects that own this object. If ALL objects in the list have been deleted, this object will be garbage collected. +optional
	OwnerReferences []OwnerReference `pulumi:"ownerReferences"`
	// An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources. Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency +optional
	ResourceVersion *string `pulumi:"resourceVersion"`
	// SelfLink is a URL representing this object. Populated by the system. Read-only. +optional string selfLink = 4;
	SelfLink *string `pulumi:"selfLink"`
	// UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations. Populated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids +optional
	Uid *string `pulumi:"uid"`
}

// ObjectMetaInput is an input type that accepts ObjectMetaArgs and ObjectMetaOutput values.
// You can construct a concrete instance of `ObjectMetaInput` via:
//
//          ObjectMetaArgs{...}
type ObjectMetaInput interface {
	pulumi.Input

	ToObjectMetaOutput() ObjectMetaOutput
	ToObjectMetaOutputWithContext(context.Context) ObjectMetaOutput
}

// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
type ObjectMetaArgs struct {
	// Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations +optional
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// Not currently supported by Cloud Run. The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request. +optional
	ClusterName pulumi.StringPtrInput `pulumi:"clusterName"`
	// CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC. Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata +optional
	CreationTimestamp pulumi.StringPtrInput `pulumi:"creationTimestamp"`
	// Not currently supported by Cloud Run. Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only. +optional
	DeletionGracePeriodSeconds pulumi.IntPtrInput `pulumi:"deletionGracePeriodSeconds"`
	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested. Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata +optional
	DeletionTimestamp pulumi.StringPtrInput `pulumi:"deletionTimestamp"`
	// Not currently supported by Cloud Run. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. +optional +patchStrategy=merge
	Finalizers pulumi.StringArrayInput `pulumi:"finalizers"`
	// Not currently supported by Cloud Run. GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server. If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header). Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency +optional string generateName = 2;
	GenerateName pulumi.StringPtrInput `pulumi:"generateName"`
	// A sequence number representing a specific generation of the desired state. Populated by the system. Read-only. +optional
	Generation pulumi.IntPtrInput `pulumi:"generation"`
	// Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and routes. More info: http://kubernetes.io/docs/user-guide/labels +optional
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// Name must be unique within a namespace, within a Cloud Run region. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names +optional
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace defines the space within each name must be unique, within a Cloud Run region. In Cloud Run the namespace must be equal to either the project ID or project number.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// List of objects that own this object. If ALL objects in the list have been deleted, this object will be garbage collected. +optional
	OwnerReferences OwnerReferenceArrayInput `pulumi:"ownerReferences"`
	// An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources. Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency +optional
	ResourceVersion pulumi.StringPtrInput `pulumi:"resourceVersion"`
	// SelfLink is a URL representing this object. Populated by the system. Read-only. +optional string selfLink = 4;
	SelfLink pulumi.StringPtrInput `pulumi:"selfLink"`
	// UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations. Populated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids +optional
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (ObjectMetaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ObjectMeta)(nil)).Elem()
}

func (i ObjectMetaArgs) ToObjectMetaOutput() ObjectMetaOutput {
	return i.ToObjectMetaOutputWithContext(context.Background())
}

func (i ObjectMetaArgs) ToObjectMetaOutputWithContext(ctx context.Context) ObjectMetaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ObjectMetaOutput)
}

func (i ObjectMetaArgs) ToObjectMetaPtrOutput() ObjectMetaPtrOutput {
	return i.ToObjectMetaPtrOutputWithContext(context.Background())
}

func (i ObjectMetaArgs) ToObjectMetaPtrOutputWithContext(ctx context.Context) ObjectMetaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ObjectMetaOutput).ToObjectMetaPtrOutputWithContext(ctx)
}

// ObjectMetaPtrInput is an input type that accepts ObjectMetaArgs, ObjectMetaPtr and ObjectMetaPtrOutput values.
// You can construct a concrete instance of `ObjectMetaPtrInput` via:
//
//          ObjectMetaArgs{...}
//
//  or:
//
//          nil
type ObjectMetaPtrInput interface {
	pulumi.Input

	ToObjectMetaPtrOutput() ObjectMetaPtrOutput
	ToObjectMetaPtrOutputWithContext(context.Context) ObjectMetaPtrOutput
}

type objectMetaPtrType ObjectMetaArgs

func ObjectMetaPtr(v *ObjectMetaArgs) ObjectMetaPtrInput {
	return (*objectMetaPtrType)(v)
}

func (*objectMetaPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ObjectMeta)(nil)).Elem()
}

func (i *objectMetaPtrType) ToObjectMetaPtrOutput() ObjectMetaPtrOutput {
	return i.ToObjectMetaPtrOutputWithContext(context.Background())
}

func (i *objectMetaPtrType) ToObjectMetaPtrOutputWithContext(ctx context.Context) ObjectMetaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ObjectMetaPtrOutput)
}

// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
type ObjectMetaOutput struct{ *pulumi.OutputState }

func (ObjectMetaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ObjectMeta)(nil)).Elem()
}

func (o ObjectMetaOutput) ToObjectMetaOutput() ObjectMetaOutput {
	return o
}

func (o ObjectMetaOutput) ToObjectMetaOutputWithContext(ctx context.Context) ObjectMetaOutput {
	return o
}

func (o ObjectMetaOutput) ToObjectMetaPtrOutput() ObjectMetaPtrOutput {
	return o.ToObjectMetaPtrOutputWithContext(context.Background())
}

func (o ObjectMetaOutput) ToObjectMetaPtrOutputWithContext(ctx context.Context) ObjectMetaPtrOutput {
	return o.ApplyT(func(v ObjectMeta) *ObjectMeta {
		return &v
	}).(ObjectMetaPtrOutput)
}

// Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations +optional
func (o ObjectMetaOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ObjectMeta) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

// Not currently supported by Cloud Run. The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request. +optional
func (o ObjectMetaOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ObjectMeta) *string { return v.ClusterName }).(pulumi.StringPtrOutput)
}

// CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC. Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata +optional
func (o ObjectMetaOutput) CreationTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ObjectMeta) *string { return v.CreationTimestamp }).(pulumi.StringPtrOutput)
}

// Not currently supported by Cloud Run. Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only. +optional
func (o ObjectMetaOutput) DeletionGracePeriodSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ObjectMeta) *int { return v.DeletionGracePeriodSeconds }).(pulumi.IntPtrOutput)
}

// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested. Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata +optional
func (o ObjectMetaOutput) DeletionTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ObjectMeta) *string { return v.DeletionTimestamp }).(pulumi.StringPtrOutput)
}

// Not currently supported by Cloud Run. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. +optional +patchStrategy=merge
func (o ObjectMetaOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ObjectMeta) []string { return v.Finalizers }).(pulumi.StringArrayOutput)
}

// Not currently supported by Cloud Run. GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server. If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header). Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency +optional string generateName = 2;
func (o ObjectMetaOutput) GenerateName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ObjectMeta) *string { return v.GenerateName }).(pulumi.StringPtrOutput)
}

// A sequence number representing a specific generation of the desired state. Populated by the system. Read-only. +optional
func (o ObjectMetaOutput) Generation() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ObjectMeta) *int { return v.Generation }).(pulumi.IntPtrOutput)
}

// Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and routes. More info: http://kubernetes.io/docs/user-guide/labels +optional
func (o ObjectMetaOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ObjectMeta) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// Name must be unique within a namespace, within a Cloud Run region. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names +optional
func (o ObjectMetaOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ObjectMeta) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace defines the space within each name must be unique, within a Cloud Run region. In Cloud Run the namespace must be equal to either the project ID or project number.
func (o ObjectMetaOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ObjectMeta) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// List of objects that own this object. If ALL objects in the list have been deleted, this object will be garbage collected. +optional
func (o ObjectMetaOutput) OwnerReferences() OwnerReferenceArrayOutput {
	return o.ApplyT(func(v ObjectMeta) []OwnerReference { return v.OwnerReferences }).(OwnerReferenceArrayOutput)
}

// An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources. Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency +optional
func (o ObjectMetaOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ObjectMeta) *string { return v.ResourceVersion }).(pulumi.StringPtrOutput)
}

// SelfLink is a URL representing this object. Populated by the system. Read-only. +optional string selfLink = 4;
func (o ObjectMetaOutput) SelfLink() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ObjectMeta) *string { return v.SelfLink }).(pulumi.StringPtrOutput)
}

// UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations. Populated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids +optional
func (o ObjectMetaOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ObjectMeta) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type ObjectMetaPtrOutput struct{ *pulumi.OutputState }

func (ObjectMetaPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ObjectMeta)(nil)).Elem()
}

func (o ObjectMetaPtrOutput) ToObjectMetaPtrOutput() ObjectMetaPtrOutput {
	return o
}

func (o ObjectMetaPtrOutput) ToObjectMetaPtrOutputWithContext(ctx context.Context) ObjectMetaPtrOutput {
	return o
}

func (o ObjectMetaPtrOutput) Elem() ObjectMetaOutput {
	return o.ApplyT(func(v *ObjectMeta) ObjectMeta { return *v }).(ObjectMetaOutput)
}

// Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations +optional
func (o ObjectMetaPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ObjectMeta) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Not currently supported by Cloud Run. The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request. +optional
func (o ObjectMetaPtrOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ObjectMeta) *string {
		if v == nil {
			return nil
		}
		return v.ClusterName
	}).(pulumi.StringPtrOutput)
}

// CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC. Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata +optional
func (o ObjectMetaPtrOutput) CreationTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ObjectMeta) *string {
		if v == nil {
			return nil
		}
		return v.CreationTimestamp
	}).(pulumi.StringPtrOutput)
}

// Not currently supported by Cloud Run. Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only. +optional
func (o ObjectMetaPtrOutput) DeletionGracePeriodSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ObjectMeta) *int {
		if v == nil {
			return nil
		}
		return v.DeletionGracePeriodSeconds
	}).(pulumi.IntPtrOutput)
}

// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested. Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata +optional
func (o ObjectMetaPtrOutput) DeletionTimestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ObjectMeta) *string {
		if v == nil {
			return nil
		}
		return v.DeletionTimestamp
	}).(pulumi.StringPtrOutput)
}

// Not currently supported by Cloud Run. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. +optional +patchStrategy=merge
func (o ObjectMetaPtrOutput) Finalizers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ObjectMeta) []string {
		if v == nil {
			return nil
		}
		return v.Finalizers
	}).(pulumi.StringArrayOutput)
}

// Not currently supported by Cloud Run. GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server. If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header). Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency +optional string generateName = 2;
func (o ObjectMetaPtrOutput) GenerateName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ObjectMeta) *string {
		if v == nil {
			return nil
		}
		return v.GenerateName
	}).(pulumi.StringPtrOutput)
}

// A sequence number representing a specific generation of the desired state. Populated by the system. Read-only. +optional
func (o ObjectMetaPtrOutput) Generation() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ObjectMeta) *int {
		if v == nil {
			return nil
		}
		return v.Generation
	}).(pulumi.IntPtrOutput)
}

// Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and routes. More info: http://kubernetes.io/docs/user-guide/labels +optional
func (o ObjectMetaPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ObjectMeta) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// Name must be unique within a namespace, within a Cloud Run region. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names +optional
func (o ObjectMetaPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ObjectMeta) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace defines the space within each name must be unique, within a Cloud Run region. In Cloud Run the namespace must be equal to either the project ID or project number.
func (o ObjectMetaPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ObjectMeta) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// List of objects that own this object. If ALL objects in the list have been deleted, this object will be garbage collected. +optional
func (o ObjectMetaPtrOutput) OwnerReferences() OwnerReferenceArrayOutput {
	return o.ApplyT(func(v *ObjectMeta) []OwnerReference {
		if v == nil {
			return nil
		}
		return v.OwnerReferences
	}).(OwnerReferenceArrayOutput)
}

// An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources. Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency +optional
func (o ObjectMetaPtrOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ObjectMeta) *string {
		if v == nil {
			return nil
		}
		return v.ResourceVersion
	}).(pulumi.StringPtrOutput)
}

// SelfLink is a URL representing this object. Populated by the system. Read-only. +optional string selfLink = 4;
func (o ObjectMetaPtrOutput) SelfLink() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ObjectMeta) *string {
		if v == nil {
			return nil
		}
		return v.SelfLink
	}).(pulumi.StringPtrOutput)
}

// UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations. Populated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids +optional
func (o ObjectMetaPtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ObjectMeta) *string {
		if v == nil {
			return nil
		}
		return v.Uid
	}).(pulumi.StringPtrOutput)
}

// OwnerReference contains enough information to let you identify an owning object. Currently, an owning object must be in the same namespace, so there is no namespace field.
type OwnerReference struct {
	// API version of the referent.
	ApiVersion *string `pulumi:"apiVersion"`
	// If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. +optional
	BlockOwnerDeletion *bool `pulumi:"blockOwnerDeletion"`
	// If true, this reference points to the managing controller. +optional
	Controller *bool `pulumi:"controller"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names
	Name *string `pulumi:"name"`
	// UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
	Uid *string `pulumi:"uid"`
}

// OwnerReferenceInput is an input type that accepts OwnerReferenceArgs and OwnerReferenceOutput values.
// You can construct a concrete instance of `OwnerReferenceInput` via:
//
//          OwnerReferenceArgs{...}
type OwnerReferenceInput interface {
	pulumi.Input

	ToOwnerReferenceOutput() OwnerReferenceOutput
	ToOwnerReferenceOutputWithContext(context.Context) OwnerReferenceOutput
}

// OwnerReference contains enough information to let you identify an owning object. Currently, an owning object must be in the same namespace, so there is no namespace field.
type OwnerReferenceArgs struct {
	// API version of the referent.
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. +optional
	BlockOwnerDeletion pulumi.BoolPtrInput `pulumi:"blockOwnerDeletion"`
	// If true, this reference points to the managing controller. +optional
	Controller pulumi.BoolPtrInput `pulumi:"controller"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names
	Name pulumi.StringPtrInput `pulumi:"name"`
	// UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (OwnerReferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OwnerReference)(nil)).Elem()
}

func (i OwnerReferenceArgs) ToOwnerReferenceOutput() OwnerReferenceOutput {
	return i.ToOwnerReferenceOutputWithContext(context.Background())
}

func (i OwnerReferenceArgs) ToOwnerReferenceOutputWithContext(ctx context.Context) OwnerReferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OwnerReferenceOutput)
}

// OwnerReferenceArrayInput is an input type that accepts OwnerReferenceArray and OwnerReferenceArrayOutput values.
// You can construct a concrete instance of `OwnerReferenceArrayInput` via:
//
//          OwnerReferenceArray{ OwnerReferenceArgs{...} }
type OwnerReferenceArrayInput interface {
	pulumi.Input

	ToOwnerReferenceArrayOutput() OwnerReferenceArrayOutput
	ToOwnerReferenceArrayOutputWithContext(context.Context) OwnerReferenceArrayOutput
}

type OwnerReferenceArray []OwnerReferenceInput

func (OwnerReferenceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OwnerReference)(nil)).Elem()
}

func (i OwnerReferenceArray) ToOwnerReferenceArrayOutput() OwnerReferenceArrayOutput {
	return i.ToOwnerReferenceArrayOutputWithContext(context.Background())
}

func (i OwnerReferenceArray) ToOwnerReferenceArrayOutputWithContext(ctx context.Context) OwnerReferenceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OwnerReferenceArrayOutput)
}

// OwnerReference contains enough information to let you identify an owning object. Currently, an owning object must be in the same namespace, so there is no namespace field.
type OwnerReferenceOutput struct{ *pulumi.OutputState }

func (OwnerReferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OwnerReference)(nil)).Elem()
}

func (o OwnerReferenceOutput) ToOwnerReferenceOutput() OwnerReferenceOutput {
	return o
}

func (o OwnerReferenceOutput) ToOwnerReferenceOutputWithContext(ctx context.Context) OwnerReferenceOutput {
	return o
}

// API version of the referent.
func (o OwnerReferenceOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OwnerReference) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. +optional
func (o OwnerReferenceOutput) BlockOwnerDeletion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v OwnerReference) *bool { return v.BlockOwnerDeletion }).(pulumi.BoolPtrOutput)
}

// If true, this reference points to the managing controller. +optional
func (o OwnerReferenceOutput) Controller() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v OwnerReference) *bool { return v.Controller }).(pulumi.BoolPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o OwnerReferenceOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OwnerReference) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names
func (o OwnerReferenceOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OwnerReference) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
func (o OwnerReferenceOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OwnerReference) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type OwnerReferenceArrayOutput struct{ *pulumi.OutputState }

func (OwnerReferenceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OwnerReference)(nil)).Elem()
}

func (o OwnerReferenceArrayOutput) ToOwnerReferenceArrayOutput() OwnerReferenceArrayOutput {
	return o
}

func (o OwnerReferenceArrayOutput) ToOwnerReferenceArrayOutputWithContext(ctx context.Context) OwnerReferenceArrayOutput {
	return o
}

func (o OwnerReferenceArrayOutput) Index(i pulumi.IntInput) OwnerReferenceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OwnerReference {
		return vs[0].([]OwnerReference)[vs[1].(int)]
	}).(OwnerReferenceOutput)
}

// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members` to a single `role`. Members can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') - etag: BwWWja0YfJA= - version: 3 For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
type PolicyType struct {
	// Specifies cloud audit logging configuration for this policy.
	AuditConfigs []AuditConfig `pulumi:"auditConfigs"`
	// Associates a list of `members` to a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one member.
	Bindings []Binding `pulumi:"bindings"`
	// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
	Etag *string `pulumi:"etag"`
	// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Version *int `pulumi:"version"`
}

// PolicyTypeInput is an input type that accepts PolicyTypeArgs and PolicyTypeOutput values.
// You can construct a concrete instance of `PolicyTypeInput` via:
//
//          PolicyTypeArgs{...}
type PolicyTypeInput interface {
	pulumi.Input

	ToPolicyTypeOutput() PolicyTypeOutput
	ToPolicyTypeOutputWithContext(context.Context) PolicyTypeOutput
}

// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members` to a single `role`. Members can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') - etag: BwWWja0YfJA= - version: 3 For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
type PolicyTypeArgs struct {
	// Specifies cloud audit logging configuration for this policy.
	AuditConfigs AuditConfigArrayInput `pulumi:"auditConfigs"`
	// Associates a list of `members` to a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one member.
	Bindings BindingArrayInput `pulumi:"bindings"`
	// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
	Etag pulumi.StringPtrInput `pulumi:"etag"`
	// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Version pulumi.IntPtrInput `pulumi:"version"`
}

func (PolicyTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PolicyType)(nil)).Elem()
}

func (i PolicyTypeArgs) ToPolicyTypeOutput() PolicyTypeOutput {
	return i.ToPolicyTypeOutputWithContext(context.Background())
}

func (i PolicyTypeArgs) ToPolicyTypeOutputWithContext(ctx context.Context) PolicyTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyTypeOutput)
}

func (i PolicyTypeArgs) ToPolicyTypePtrOutput() PolicyTypePtrOutput {
	return i.ToPolicyTypePtrOutputWithContext(context.Background())
}

func (i PolicyTypeArgs) ToPolicyTypePtrOutputWithContext(ctx context.Context) PolicyTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyTypeOutput).ToPolicyTypePtrOutputWithContext(ctx)
}

// PolicyTypePtrInput is an input type that accepts PolicyTypeArgs, PolicyTypePtr and PolicyTypePtrOutput values.
// You can construct a concrete instance of `PolicyTypePtrInput` via:
//
//          PolicyTypeArgs{...}
//
//  or:
//
//          nil
type PolicyTypePtrInput interface {
	pulumi.Input

	ToPolicyTypePtrOutput() PolicyTypePtrOutput
	ToPolicyTypePtrOutputWithContext(context.Context) PolicyTypePtrOutput
}

type policyTypePtrType PolicyTypeArgs

func PolicyTypePtr(v *PolicyTypeArgs) PolicyTypePtrInput {
	return (*policyTypePtrType)(v)
}

func (*policyTypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PolicyType)(nil)).Elem()
}

func (i *policyTypePtrType) ToPolicyTypePtrOutput() PolicyTypePtrOutput {
	return i.ToPolicyTypePtrOutputWithContext(context.Background())
}

func (i *policyTypePtrType) ToPolicyTypePtrOutputWithContext(ctx context.Context) PolicyTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyTypePtrOutput)
}

// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members` to a single `role`. Members can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') - etag: BwWWja0YfJA= - version: 3 For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
type PolicyTypeOutput struct{ *pulumi.OutputState }

func (PolicyTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PolicyType)(nil)).Elem()
}

func (o PolicyTypeOutput) ToPolicyTypeOutput() PolicyTypeOutput {
	return o
}

func (o PolicyTypeOutput) ToPolicyTypeOutputWithContext(ctx context.Context) PolicyTypeOutput {
	return o
}

func (o PolicyTypeOutput) ToPolicyTypePtrOutput() PolicyTypePtrOutput {
	return o.ToPolicyTypePtrOutputWithContext(context.Background())
}

func (o PolicyTypeOutput) ToPolicyTypePtrOutputWithContext(ctx context.Context) PolicyTypePtrOutput {
	return o.ApplyT(func(v PolicyType) *PolicyType {
		return &v
	}).(PolicyTypePtrOutput)
}

// Specifies cloud audit logging configuration for this policy.
func (o PolicyTypeOutput) AuditConfigs() AuditConfigArrayOutput {
	return o.ApplyT(func(v PolicyType) []AuditConfig { return v.AuditConfigs }).(AuditConfigArrayOutput)
}

// Associates a list of `members` to a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one member.
func (o PolicyTypeOutput) Bindings() BindingArrayOutput {
	return o.ApplyT(func(v PolicyType) []Binding { return v.Bindings }).(BindingArrayOutput)
}

// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
func (o PolicyTypeOutput) Etag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PolicyType) *string { return v.Etag }).(pulumi.StringPtrOutput)
}

// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o PolicyTypeOutput) Version() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PolicyType) *int { return v.Version }).(pulumi.IntPtrOutput)
}

type PolicyTypePtrOutput struct{ *pulumi.OutputState }

func (PolicyTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PolicyType)(nil)).Elem()
}

func (o PolicyTypePtrOutput) ToPolicyTypePtrOutput() PolicyTypePtrOutput {
	return o
}

func (o PolicyTypePtrOutput) ToPolicyTypePtrOutputWithContext(ctx context.Context) PolicyTypePtrOutput {
	return o
}

func (o PolicyTypePtrOutput) Elem() PolicyTypeOutput {
	return o.ApplyT(func(v *PolicyType) PolicyType { return *v }).(PolicyTypeOutput)
}

// Specifies cloud audit logging configuration for this policy.
func (o PolicyTypePtrOutput) AuditConfigs() AuditConfigArrayOutput {
	return o.ApplyT(func(v *PolicyType) []AuditConfig {
		if v == nil {
			return nil
		}
		return v.AuditConfigs
	}).(AuditConfigArrayOutput)
}

// Associates a list of `members` to a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one member.
func (o PolicyTypePtrOutput) Bindings() BindingArrayOutput {
	return o.ApplyT(func(v *PolicyType) []Binding {
		if v == nil {
			return nil
		}
		return v.Bindings
	}).(BindingArrayOutput)
}

// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
func (o PolicyTypePtrOutput) Etag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PolicyType) *string {
		if v == nil {
			return nil
		}
		return v.Etag
	}).(pulumi.StringPtrOutput)
}

// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o PolicyTypePtrOutput) Version() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PolicyType) *int {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.IntPtrOutput)
}

// Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
type Probe struct {
	// Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. +optional
	FailureThreshold *int `pulumi:"failureThreshold"`
	// The action taken to determine the health of a container
	Handler *Handler `pulumi:"handler"`
	// Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
	InitialDelaySeconds *int `pulumi:"initialDelaySeconds"`
	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. +optional
	PeriodSeconds *int `pulumi:"periodSeconds"`
	// Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1. +optional
	SuccessThreshold *int `pulumi:"successThreshold"`
	// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
	TimeoutSeconds *int `pulumi:"timeoutSeconds"`
}

// ProbeInput is an input type that accepts ProbeArgs and ProbeOutput values.
// You can construct a concrete instance of `ProbeInput` via:
//
//          ProbeArgs{...}
type ProbeInput interface {
	pulumi.Input

	ToProbeOutput() ProbeOutput
	ToProbeOutputWithContext(context.Context) ProbeOutput
}

// Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
type ProbeArgs struct {
	// Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. +optional
	FailureThreshold pulumi.IntPtrInput `pulumi:"failureThreshold"`
	// The action taken to determine the health of a container
	Handler HandlerPtrInput `pulumi:"handler"`
	// Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
	InitialDelaySeconds pulumi.IntPtrInput `pulumi:"initialDelaySeconds"`
	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. +optional
	PeriodSeconds pulumi.IntPtrInput `pulumi:"periodSeconds"`
	// Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1. +optional
	SuccessThreshold pulumi.IntPtrInput `pulumi:"successThreshold"`
	// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
	TimeoutSeconds pulumi.IntPtrInput `pulumi:"timeoutSeconds"`
}

func (ProbeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Probe)(nil)).Elem()
}

func (i ProbeArgs) ToProbeOutput() ProbeOutput {
	return i.ToProbeOutputWithContext(context.Background())
}

func (i ProbeArgs) ToProbeOutputWithContext(ctx context.Context) ProbeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProbeOutput)
}

func (i ProbeArgs) ToProbePtrOutput() ProbePtrOutput {
	return i.ToProbePtrOutputWithContext(context.Background())
}

func (i ProbeArgs) ToProbePtrOutputWithContext(ctx context.Context) ProbePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProbeOutput).ToProbePtrOutputWithContext(ctx)
}

// ProbePtrInput is an input type that accepts ProbeArgs, ProbePtr and ProbePtrOutput values.
// You can construct a concrete instance of `ProbePtrInput` via:
//
//          ProbeArgs{...}
//
//  or:
//
//          nil
type ProbePtrInput interface {
	pulumi.Input

	ToProbePtrOutput() ProbePtrOutput
	ToProbePtrOutputWithContext(context.Context) ProbePtrOutput
}

type probePtrType ProbeArgs

func ProbePtr(v *ProbeArgs) ProbePtrInput {
	return (*probePtrType)(v)
}

func (*probePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Probe)(nil)).Elem()
}

func (i *probePtrType) ToProbePtrOutput() ProbePtrOutput {
	return i.ToProbePtrOutputWithContext(context.Background())
}

func (i *probePtrType) ToProbePtrOutputWithContext(ctx context.Context) ProbePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProbePtrOutput)
}

// Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
type ProbeOutput struct{ *pulumi.OutputState }

func (ProbeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Probe)(nil)).Elem()
}

func (o ProbeOutput) ToProbeOutput() ProbeOutput {
	return o
}

func (o ProbeOutput) ToProbeOutputWithContext(ctx context.Context) ProbeOutput {
	return o
}

func (o ProbeOutput) ToProbePtrOutput() ProbePtrOutput {
	return o.ToProbePtrOutputWithContext(context.Background())
}

func (o ProbeOutput) ToProbePtrOutputWithContext(ctx context.Context) ProbePtrOutput {
	return o.ApplyT(func(v Probe) *Probe {
		return &v
	}).(ProbePtrOutput)
}

// Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. +optional
func (o ProbeOutput) FailureThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Probe) *int { return v.FailureThreshold }).(pulumi.IntPtrOutput)
}

// The action taken to determine the health of a container
func (o ProbeOutput) Handler() HandlerPtrOutput {
	return o.ApplyT(func(v Probe) *Handler { return v.Handler }).(HandlerPtrOutput)
}

// Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
func (o ProbeOutput) InitialDelaySeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Probe) *int { return v.InitialDelaySeconds }).(pulumi.IntPtrOutput)
}

// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. +optional
func (o ProbeOutput) PeriodSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Probe) *int { return v.PeriodSeconds }).(pulumi.IntPtrOutput)
}

// Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1. +optional
func (o ProbeOutput) SuccessThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Probe) *int { return v.SuccessThreshold }).(pulumi.IntPtrOutput)
}

// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
func (o ProbeOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Probe) *int { return v.TimeoutSeconds }).(pulumi.IntPtrOutput)
}

type ProbePtrOutput struct{ *pulumi.OutputState }

func (ProbePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Probe)(nil)).Elem()
}

func (o ProbePtrOutput) ToProbePtrOutput() ProbePtrOutput {
	return o
}

func (o ProbePtrOutput) ToProbePtrOutputWithContext(ctx context.Context) ProbePtrOutput {
	return o
}

func (o ProbePtrOutput) Elem() ProbeOutput {
	return o.ApplyT(func(v *Probe) Probe { return *v }).(ProbeOutput)
}

// Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. +optional
func (o ProbePtrOutput) FailureThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Probe) *int {
		if v == nil {
			return nil
		}
		return v.FailureThreshold
	}).(pulumi.IntPtrOutput)
}

// The action taken to determine the health of a container
func (o ProbePtrOutput) Handler() HandlerPtrOutput {
	return o.ApplyT(func(v *Probe) *Handler {
		if v == nil {
			return nil
		}
		return v.Handler
	}).(HandlerPtrOutput)
}

// Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
func (o ProbePtrOutput) InitialDelaySeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Probe) *int {
		if v == nil {
			return nil
		}
		return v.InitialDelaySeconds
	}).(pulumi.IntPtrOutput)
}

// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. +optional
func (o ProbePtrOutput) PeriodSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Probe) *int {
		if v == nil {
			return nil
		}
		return v.PeriodSeconds
	}).(pulumi.IntPtrOutput)
}

// Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1. +optional
func (o ProbePtrOutput) SuccessThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Probe) *int {
		if v == nil {
			return nil
		}
		return v.SuccessThreshold
	}).(pulumi.IntPtrOutput)
}

// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes +optional
func (o ProbePtrOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Probe) *int {
		if v == nil {
			return nil
		}
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// A DNS resource record.
type ResourceRecord struct {
	// Relative name of the object affected by this record. Only applicable for `CNAME` records. Example: 'www'.
	Name *string `pulumi:"name"`
	// Data for this record. Values vary by record type, as defined in RFC 1035 (section 5) and RFC 1034 (section 3.6.1).
	Rrdata *string `pulumi:"rrdata"`
	// Resource record type. Example: `AAAA`.
	Type *string `pulumi:"type"`
}

// ResourceRecordInput is an input type that accepts ResourceRecordArgs and ResourceRecordOutput values.
// You can construct a concrete instance of `ResourceRecordInput` via:
//
//          ResourceRecordArgs{...}
type ResourceRecordInput interface {
	pulumi.Input

	ToResourceRecordOutput() ResourceRecordOutput
	ToResourceRecordOutputWithContext(context.Context) ResourceRecordOutput
}

// A DNS resource record.
type ResourceRecordArgs struct {
	// Relative name of the object affected by this record. Only applicable for `CNAME` records. Example: 'www'.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Data for this record. Values vary by record type, as defined in RFC 1035 (section 5) and RFC 1034 (section 3.6.1).
	Rrdata pulumi.StringPtrInput `pulumi:"rrdata"`
	// Resource record type. Example: `AAAA`.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (ResourceRecordArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceRecord)(nil)).Elem()
}

func (i ResourceRecordArgs) ToResourceRecordOutput() ResourceRecordOutput {
	return i.ToResourceRecordOutputWithContext(context.Background())
}

func (i ResourceRecordArgs) ToResourceRecordOutputWithContext(ctx context.Context) ResourceRecordOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceRecordOutput)
}

// ResourceRecordArrayInput is an input type that accepts ResourceRecordArray and ResourceRecordArrayOutput values.
// You can construct a concrete instance of `ResourceRecordArrayInput` via:
//
//          ResourceRecordArray{ ResourceRecordArgs{...} }
type ResourceRecordArrayInput interface {
	pulumi.Input

	ToResourceRecordArrayOutput() ResourceRecordArrayOutput
	ToResourceRecordArrayOutputWithContext(context.Context) ResourceRecordArrayOutput
}

type ResourceRecordArray []ResourceRecordInput

func (ResourceRecordArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceRecord)(nil)).Elem()
}

func (i ResourceRecordArray) ToResourceRecordArrayOutput() ResourceRecordArrayOutput {
	return i.ToResourceRecordArrayOutputWithContext(context.Background())
}

func (i ResourceRecordArray) ToResourceRecordArrayOutputWithContext(ctx context.Context) ResourceRecordArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceRecordArrayOutput)
}

// A DNS resource record.
type ResourceRecordOutput struct{ *pulumi.OutputState }

func (ResourceRecordOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceRecord)(nil)).Elem()
}

func (o ResourceRecordOutput) ToResourceRecordOutput() ResourceRecordOutput {
	return o
}

func (o ResourceRecordOutput) ToResourceRecordOutputWithContext(ctx context.Context) ResourceRecordOutput {
	return o
}

// Relative name of the object affected by this record. Only applicable for `CNAME` records. Example: 'www'.
func (o ResourceRecordOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceRecord) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Data for this record. Values vary by record type, as defined in RFC 1035 (section 5) and RFC 1034 (section 3.6.1).
func (o ResourceRecordOutput) Rrdata() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceRecord) *string { return v.Rrdata }).(pulumi.StringPtrOutput)
}

// Resource record type. Example: `AAAA`.
func (o ResourceRecordOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceRecord) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type ResourceRecordArrayOutput struct{ *pulumi.OutputState }

func (ResourceRecordArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResourceRecord)(nil)).Elem()
}

func (o ResourceRecordArrayOutput) ToResourceRecordArrayOutput() ResourceRecordArrayOutput {
	return o
}

func (o ResourceRecordArrayOutput) ToResourceRecordArrayOutputWithContext(ctx context.Context) ResourceRecordArrayOutput {
	return o
}

func (o ResourceRecordArrayOutput) Index(i pulumi.IntInput) ResourceRecordOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResourceRecord {
		return vs[0].([]ResourceRecord)[vs[1].(int)]
	}).(ResourceRecordOutput)
}

// ResourceRequirements describes the compute resource requirements.
type ResourceRequirements struct {
	// Limits describes the maximum amount of compute resources allowed. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
	Limits map[string]string `pulumi:"limits"`
	// Limits describes the maximum amount of compute resources allowed. This is a temporary field created to migrate away from the map limits field. This is done to become compliant with k8s style API. This field is deprecated in favor of limits field.
	LimitsInMap map[string]string `pulumi:"limitsInMap"`
	// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
	Requests map[string]string `pulumi:"requests"`
	// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. This is a temporary field created to migrate away from the map requests field. This is done to become compliant with k8s style API. This field is deprecated in favor of requests field.
	RequestsInMap map[string]string `pulumi:"requestsInMap"`
}

// ResourceRequirementsInput is an input type that accepts ResourceRequirementsArgs and ResourceRequirementsOutput values.
// You can construct a concrete instance of `ResourceRequirementsInput` via:
//
//          ResourceRequirementsArgs{...}
type ResourceRequirementsInput interface {
	pulumi.Input

	ToResourceRequirementsOutput() ResourceRequirementsOutput
	ToResourceRequirementsOutputWithContext(context.Context) ResourceRequirementsOutput
}

// ResourceRequirements describes the compute resource requirements.
type ResourceRequirementsArgs struct {
	// Limits describes the maximum amount of compute resources allowed. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
	Limits pulumi.StringMapInput `pulumi:"limits"`
	// Limits describes the maximum amount of compute resources allowed. This is a temporary field created to migrate away from the map limits field. This is done to become compliant with k8s style API. This field is deprecated in favor of limits field.
	LimitsInMap pulumi.StringMapInput `pulumi:"limitsInMap"`
	// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
	Requests pulumi.StringMapInput `pulumi:"requests"`
	// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. This is a temporary field created to migrate away from the map requests field. This is done to become compliant with k8s style API. This field is deprecated in favor of requests field.
	RequestsInMap pulumi.StringMapInput `pulumi:"requestsInMap"`
}

func (ResourceRequirementsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceRequirements)(nil)).Elem()
}

func (i ResourceRequirementsArgs) ToResourceRequirementsOutput() ResourceRequirementsOutput {
	return i.ToResourceRequirementsOutputWithContext(context.Background())
}

func (i ResourceRequirementsArgs) ToResourceRequirementsOutputWithContext(ctx context.Context) ResourceRequirementsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceRequirementsOutput)
}

func (i ResourceRequirementsArgs) ToResourceRequirementsPtrOutput() ResourceRequirementsPtrOutput {
	return i.ToResourceRequirementsPtrOutputWithContext(context.Background())
}

func (i ResourceRequirementsArgs) ToResourceRequirementsPtrOutputWithContext(ctx context.Context) ResourceRequirementsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceRequirementsOutput).ToResourceRequirementsPtrOutputWithContext(ctx)
}

// ResourceRequirementsPtrInput is an input type that accepts ResourceRequirementsArgs, ResourceRequirementsPtr and ResourceRequirementsPtrOutput values.
// You can construct a concrete instance of `ResourceRequirementsPtrInput` via:
//
//          ResourceRequirementsArgs{...}
//
//  or:
//
//          nil
type ResourceRequirementsPtrInput interface {
	pulumi.Input

	ToResourceRequirementsPtrOutput() ResourceRequirementsPtrOutput
	ToResourceRequirementsPtrOutputWithContext(context.Context) ResourceRequirementsPtrOutput
}

type resourceRequirementsPtrType ResourceRequirementsArgs

func ResourceRequirementsPtr(v *ResourceRequirementsArgs) ResourceRequirementsPtrInput {
	return (*resourceRequirementsPtrType)(v)
}

func (*resourceRequirementsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceRequirements)(nil)).Elem()
}

func (i *resourceRequirementsPtrType) ToResourceRequirementsPtrOutput() ResourceRequirementsPtrOutput {
	return i.ToResourceRequirementsPtrOutputWithContext(context.Background())
}

func (i *resourceRequirementsPtrType) ToResourceRequirementsPtrOutputWithContext(ctx context.Context) ResourceRequirementsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceRequirementsPtrOutput)
}

// ResourceRequirements describes the compute resource requirements.
type ResourceRequirementsOutput struct{ *pulumi.OutputState }

func (ResourceRequirementsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceRequirements)(nil)).Elem()
}

func (o ResourceRequirementsOutput) ToResourceRequirementsOutput() ResourceRequirementsOutput {
	return o
}

func (o ResourceRequirementsOutput) ToResourceRequirementsOutputWithContext(ctx context.Context) ResourceRequirementsOutput {
	return o
}

func (o ResourceRequirementsOutput) ToResourceRequirementsPtrOutput() ResourceRequirementsPtrOutput {
	return o.ToResourceRequirementsPtrOutputWithContext(context.Background())
}

func (o ResourceRequirementsOutput) ToResourceRequirementsPtrOutputWithContext(ctx context.Context) ResourceRequirementsPtrOutput {
	return o.ApplyT(func(v ResourceRequirements) *ResourceRequirements {
		return &v
	}).(ResourceRequirementsPtrOutput)
}

// Limits describes the maximum amount of compute resources allowed. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
func (o ResourceRequirementsOutput) Limits() pulumi.StringMapOutput {
	return o.ApplyT(func(v ResourceRequirements) map[string]string { return v.Limits }).(pulumi.StringMapOutput)
}

// Limits describes the maximum amount of compute resources allowed. This is a temporary field created to migrate away from the map limits field. This is done to become compliant with k8s style API. This field is deprecated in favor of limits field.
func (o ResourceRequirementsOutput) LimitsInMap() pulumi.StringMapOutput {
	return o.ApplyT(func(v ResourceRequirements) map[string]string { return v.LimitsInMap }).(pulumi.StringMapOutput)
}

// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
func (o ResourceRequirementsOutput) Requests() pulumi.StringMapOutput {
	return o.ApplyT(func(v ResourceRequirements) map[string]string { return v.Requests }).(pulumi.StringMapOutput)
}

// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. This is a temporary field created to migrate away from the map requests field. This is done to become compliant with k8s style API. This field is deprecated in favor of requests field.
func (o ResourceRequirementsOutput) RequestsInMap() pulumi.StringMapOutput {
	return o.ApplyT(func(v ResourceRequirements) map[string]string { return v.RequestsInMap }).(pulumi.StringMapOutput)
}

type ResourceRequirementsPtrOutput struct{ *pulumi.OutputState }

func (ResourceRequirementsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceRequirements)(nil)).Elem()
}

func (o ResourceRequirementsPtrOutput) ToResourceRequirementsPtrOutput() ResourceRequirementsPtrOutput {
	return o
}

func (o ResourceRequirementsPtrOutput) ToResourceRequirementsPtrOutputWithContext(ctx context.Context) ResourceRequirementsPtrOutput {
	return o
}

func (o ResourceRequirementsPtrOutput) Elem() ResourceRequirementsOutput {
	return o.ApplyT(func(v *ResourceRequirements) ResourceRequirements { return *v }).(ResourceRequirementsOutput)
}

// Limits describes the maximum amount of compute resources allowed. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
func (o ResourceRequirementsPtrOutput) Limits() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ResourceRequirements) map[string]string {
		if v == nil {
			return nil
		}
		return v.Limits
	}).(pulumi.StringMapOutput)
}

// Limits describes the maximum amount of compute resources allowed. This is a temporary field created to migrate away from the map limits field. This is done to become compliant with k8s style API. This field is deprecated in favor of limits field.
func (o ResourceRequirementsPtrOutput) LimitsInMap() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ResourceRequirements) map[string]string {
		if v == nil {
			return nil
		}
		return v.LimitsInMap
	}).(pulumi.StringMapOutput)
}

// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
func (o ResourceRequirementsPtrOutput) Requests() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ResourceRequirements) map[string]string {
		if v == nil {
			return nil
		}
		return v.Requests
	}).(pulumi.StringMapOutput)
}

// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. This is a temporary field created to migrate away from the map requests field. This is done to become compliant with k8s style API. This field is deprecated in favor of requests field.
func (o ResourceRequirementsPtrOutput) RequestsInMap() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ResourceRequirements) map[string]string {
		if v == nil {
			return nil
		}
		return v.RequestsInMap
	}).(pulumi.StringMapOutput)
}

// RevisionSpec holds the desired state of the Revision (from the client).
type RevisionSpec struct {
	// ConcurrencyModel specifies the desired concurrency model (Single or Multi) for the Revision. Defaults to Multi. Deprecated in favor of ContainerConcurrency. +optional
	ConcurrencyModel *string `pulumi:"concurrencyModel"`
	// Container defines the unit of execution for this Revision. In the context of a Revision, we disallow a number of the fields of this Container, including: name, ports, and volumeMounts. The runtime contract is documented here: https://github.com/knative/serving/blob/master/docs/runtime-contract.md
	Container *Container `pulumi:"container"`
	// (Optional) ContainerConcurrency specifies the maximum allowed in-flight (concurrent) requests per container instance of the Revision. Cloud Run fully managed: supported, defaults to 80 Cloud Run on GKE: supported, defaults to 0, which means concurrency to the application is not limited, and the system decides the target concurrency for the autoscaler.
	ContainerConcurrency *int `pulumi:"containerConcurrency"`
	// Containers holds the single container that defines the unit of execution for this Revision. In the context of a Revision, we disallow a number of fields on this Container, including: name and lifecycle. In Cloud Run, only a single container may be provided.
	Containers []Container `pulumi:"containers"`
	// Deprecated and not currently populated by Cloud Run. See metadata.generation instead, which is the sequence number containing the latest generation of the desired state. Read-only.
	Generation *int `pulumi:"generation"`
	// Email address of the IAM service account associated with the revision of the service. The service account represents the identity of the running revision, and determines what permissions the revision has. If not provided, the revision will use the project's default service account.
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// ServingState holds a value describing the state the resources are in for this Revision. Users must not specify this when creating a revision. It is expected that the system will manipulate this based on routability and load. Populated by the system. Read-only.
	ServingState *string `pulumi:"servingState"`
	// TimeoutSeconds holds the max duration the instance is allowed for responding to a request. Not currently used by Cloud Run.
	TimeoutSeconds *int     `pulumi:"timeoutSeconds"`
	Volumes        []Volume `pulumi:"volumes"`
}

// RevisionSpecInput is an input type that accepts RevisionSpecArgs and RevisionSpecOutput values.
// You can construct a concrete instance of `RevisionSpecInput` via:
//
//          RevisionSpecArgs{...}
type RevisionSpecInput interface {
	pulumi.Input

	ToRevisionSpecOutput() RevisionSpecOutput
	ToRevisionSpecOutputWithContext(context.Context) RevisionSpecOutput
}

// RevisionSpec holds the desired state of the Revision (from the client).
type RevisionSpecArgs struct {
	// ConcurrencyModel specifies the desired concurrency model (Single or Multi) for the Revision. Defaults to Multi. Deprecated in favor of ContainerConcurrency. +optional
	ConcurrencyModel pulumi.StringPtrInput `pulumi:"concurrencyModel"`
	// Container defines the unit of execution for this Revision. In the context of a Revision, we disallow a number of the fields of this Container, including: name, ports, and volumeMounts. The runtime contract is documented here: https://github.com/knative/serving/blob/master/docs/runtime-contract.md
	Container ContainerPtrInput `pulumi:"container"`
	// (Optional) ContainerConcurrency specifies the maximum allowed in-flight (concurrent) requests per container instance of the Revision. Cloud Run fully managed: supported, defaults to 80 Cloud Run on GKE: supported, defaults to 0, which means concurrency to the application is not limited, and the system decides the target concurrency for the autoscaler.
	ContainerConcurrency pulumi.IntPtrInput `pulumi:"containerConcurrency"`
	// Containers holds the single container that defines the unit of execution for this Revision. In the context of a Revision, we disallow a number of fields on this Container, including: name and lifecycle. In Cloud Run, only a single container may be provided.
	Containers ContainerArrayInput `pulumi:"containers"`
	// Deprecated and not currently populated by Cloud Run. See metadata.generation instead, which is the sequence number containing the latest generation of the desired state. Read-only.
	Generation pulumi.IntPtrInput `pulumi:"generation"`
	// Email address of the IAM service account associated with the revision of the service. The service account represents the identity of the running revision, and determines what permissions the revision has. If not provided, the revision will use the project's default service account.
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// ServingState holds a value describing the state the resources are in for this Revision. Users must not specify this when creating a revision. It is expected that the system will manipulate this based on routability and load. Populated by the system. Read-only.
	ServingState pulumi.StringPtrInput `pulumi:"servingState"`
	// TimeoutSeconds holds the max duration the instance is allowed for responding to a request. Not currently used by Cloud Run.
	TimeoutSeconds pulumi.IntPtrInput `pulumi:"timeoutSeconds"`
	Volumes        VolumeArrayInput   `pulumi:"volumes"`
}

func (RevisionSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RevisionSpec)(nil)).Elem()
}

func (i RevisionSpecArgs) ToRevisionSpecOutput() RevisionSpecOutput {
	return i.ToRevisionSpecOutputWithContext(context.Background())
}

func (i RevisionSpecArgs) ToRevisionSpecOutputWithContext(ctx context.Context) RevisionSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RevisionSpecOutput)
}

func (i RevisionSpecArgs) ToRevisionSpecPtrOutput() RevisionSpecPtrOutput {
	return i.ToRevisionSpecPtrOutputWithContext(context.Background())
}

func (i RevisionSpecArgs) ToRevisionSpecPtrOutputWithContext(ctx context.Context) RevisionSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RevisionSpecOutput).ToRevisionSpecPtrOutputWithContext(ctx)
}

// RevisionSpecPtrInput is an input type that accepts RevisionSpecArgs, RevisionSpecPtr and RevisionSpecPtrOutput values.
// You can construct a concrete instance of `RevisionSpecPtrInput` via:
//
//          RevisionSpecArgs{...}
//
//  or:
//
//          nil
type RevisionSpecPtrInput interface {
	pulumi.Input

	ToRevisionSpecPtrOutput() RevisionSpecPtrOutput
	ToRevisionSpecPtrOutputWithContext(context.Context) RevisionSpecPtrOutput
}

type revisionSpecPtrType RevisionSpecArgs

func RevisionSpecPtr(v *RevisionSpecArgs) RevisionSpecPtrInput {
	return (*revisionSpecPtrType)(v)
}

func (*revisionSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RevisionSpec)(nil)).Elem()
}

func (i *revisionSpecPtrType) ToRevisionSpecPtrOutput() RevisionSpecPtrOutput {
	return i.ToRevisionSpecPtrOutputWithContext(context.Background())
}

func (i *revisionSpecPtrType) ToRevisionSpecPtrOutputWithContext(ctx context.Context) RevisionSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RevisionSpecPtrOutput)
}

// RevisionSpec holds the desired state of the Revision (from the client).
type RevisionSpecOutput struct{ *pulumi.OutputState }

func (RevisionSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RevisionSpec)(nil)).Elem()
}

func (o RevisionSpecOutput) ToRevisionSpecOutput() RevisionSpecOutput {
	return o
}

func (o RevisionSpecOutput) ToRevisionSpecOutputWithContext(ctx context.Context) RevisionSpecOutput {
	return o
}

func (o RevisionSpecOutput) ToRevisionSpecPtrOutput() RevisionSpecPtrOutput {
	return o.ToRevisionSpecPtrOutputWithContext(context.Background())
}

func (o RevisionSpecOutput) ToRevisionSpecPtrOutputWithContext(ctx context.Context) RevisionSpecPtrOutput {
	return o.ApplyT(func(v RevisionSpec) *RevisionSpec {
		return &v
	}).(RevisionSpecPtrOutput)
}

// ConcurrencyModel specifies the desired concurrency model (Single or Multi) for the Revision. Defaults to Multi. Deprecated in favor of ContainerConcurrency. +optional
func (o RevisionSpecOutput) ConcurrencyModel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RevisionSpec) *string { return v.ConcurrencyModel }).(pulumi.StringPtrOutput)
}

// Container defines the unit of execution for this Revision. In the context of a Revision, we disallow a number of the fields of this Container, including: name, ports, and volumeMounts. The runtime contract is documented here: https://github.com/knative/serving/blob/master/docs/runtime-contract.md
func (o RevisionSpecOutput) Container() ContainerPtrOutput {
	return o.ApplyT(func(v RevisionSpec) *Container { return v.Container }).(ContainerPtrOutput)
}

// (Optional) ContainerConcurrency specifies the maximum allowed in-flight (concurrent) requests per container instance of the Revision. Cloud Run fully managed: supported, defaults to 80 Cloud Run on GKE: supported, defaults to 0, which means concurrency to the application is not limited, and the system decides the target concurrency for the autoscaler.
func (o RevisionSpecOutput) ContainerConcurrency() pulumi.IntPtrOutput {
	return o.ApplyT(func(v RevisionSpec) *int { return v.ContainerConcurrency }).(pulumi.IntPtrOutput)
}

// Containers holds the single container that defines the unit of execution for this Revision. In the context of a Revision, we disallow a number of fields on this Container, including: name and lifecycle. In Cloud Run, only a single container may be provided.
func (o RevisionSpecOutput) Containers() ContainerArrayOutput {
	return o.ApplyT(func(v RevisionSpec) []Container { return v.Containers }).(ContainerArrayOutput)
}

// Deprecated and not currently populated by Cloud Run. See metadata.generation instead, which is the sequence number containing the latest generation of the desired state. Read-only.
func (o RevisionSpecOutput) Generation() pulumi.IntPtrOutput {
	return o.ApplyT(func(v RevisionSpec) *int { return v.Generation }).(pulumi.IntPtrOutput)
}

// Email address of the IAM service account associated with the revision of the service. The service account represents the identity of the running revision, and determines what permissions the revision has. If not provided, the revision will use the project's default service account.
func (o RevisionSpecOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RevisionSpec) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// ServingState holds a value describing the state the resources are in for this Revision. Users must not specify this when creating a revision. It is expected that the system will manipulate this based on routability and load. Populated by the system. Read-only.
func (o RevisionSpecOutput) ServingState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RevisionSpec) *string { return v.ServingState }).(pulumi.StringPtrOutput)
}

// TimeoutSeconds holds the max duration the instance is allowed for responding to a request. Not currently used by Cloud Run.
func (o RevisionSpecOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v RevisionSpec) *int { return v.TimeoutSeconds }).(pulumi.IntPtrOutput)
}

func (o RevisionSpecOutput) Volumes() VolumeArrayOutput {
	return o.ApplyT(func(v RevisionSpec) []Volume { return v.Volumes }).(VolumeArrayOutput)
}

type RevisionSpecPtrOutput struct{ *pulumi.OutputState }

func (RevisionSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RevisionSpec)(nil)).Elem()
}

func (o RevisionSpecPtrOutput) ToRevisionSpecPtrOutput() RevisionSpecPtrOutput {
	return o
}

func (o RevisionSpecPtrOutput) ToRevisionSpecPtrOutputWithContext(ctx context.Context) RevisionSpecPtrOutput {
	return o
}

func (o RevisionSpecPtrOutput) Elem() RevisionSpecOutput {
	return o.ApplyT(func(v *RevisionSpec) RevisionSpec { return *v }).(RevisionSpecOutput)
}

// ConcurrencyModel specifies the desired concurrency model (Single or Multi) for the Revision. Defaults to Multi. Deprecated in favor of ContainerConcurrency. +optional
func (o RevisionSpecPtrOutput) ConcurrencyModel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RevisionSpec) *string {
		if v == nil {
			return nil
		}
		return v.ConcurrencyModel
	}).(pulumi.StringPtrOutput)
}

// Container defines the unit of execution for this Revision. In the context of a Revision, we disallow a number of the fields of this Container, including: name, ports, and volumeMounts. The runtime contract is documented here: https://github.com/knative/serving/blob/master/docs/runtime-contract.md
func (o RevisionSpecPtrOutput) Container() ContainerPtrOutput {
	return o.ApplyT(func(v *RevisionSpec) *Container {
		if v == nil {
			return nil
		}
		return v.Container
	}).(ContainerPtrOutput)
}

// (Optional) ContainerConcurrency specifies the maximum allowed in-flight (concurrent) requests per container instance of the Revision. Cloud Run fully managed: supported, defaults to 80 Cloud Run on GKE: supported, defaults to 0, which means concurrency to the application is not limited, and the system decides the target concurrency for the autoscaler.
func (o RevisionSpecPtrOutput) ContainerConcurrency() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RevisionSpec) *int {
		if v == nil {
			return nil
		}
		return v.ContainerConcurrency
	}).(pulumi.IntPtrOutput)
}

// Containers holds the single container that defines the unit of execution for this Revision. In the context of a Revision, we disallow a number of fields on this Container, including: name and lifecycle. In Cloud Run, only a single container may be provided.
func (o RevisionSpecPtrOutput) Containers() ContainerArrayOutput {
	return o.ApplyT(func(v *RevisionSpec) []Container {
		if v == nil {
			return nil
		}
		return v.Containers
	}).(ContainerArrayOutput)
}

// Deprecated and not currently populated by Cloud Run. See metadata.generation instead, which is the sequence number containing the latest generation of the desired state. Read-only.
func (o RevisionSpecPtrOutput) Generation() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RevisionSpec) *int {
		if v == nil {
			return nil
		}
		return v.Generation
	}).(pulumi.IntPtrOutput)
}

// Email address of the IAM service account associated with the revision of the service. The service account represents the identity of the running revision, and determines what permissions the revision has. If not provided, the revision will use the project's default service account.
func (o RevisionSpecPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RevisionSpec) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// ServingState holds a value describing the state the resources are in for this Revision. Users must not specify this when creating a revision. It is expected that the system will manipulate this based on routability and load. Populated by the system. Read-only.
func (o RevisionSpecPtrOutput) ServingState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RevisionSpec) *string {
		if v == nil {
			return nil
		}
		return v.ServingState
	}).(pulumi.StringPtrOutput)
}

// TimeoutSeconds holds the max duration the instance is allowed for responding to a request. Not currently used by Cloud Run.
func (o RevisionSpecPtrOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RevisionSpec) *int {
		if v == nil {
			return nil
		}
		return v.TimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

func (o RevisionSpecPtrOutput) Volumes() VolumeArrayOutput {
	return o.ApplyT(func(v *RevisionSpec) []Volume {
		if v == nil {
			return nil
		}
		return v.Volumes
	}).(VolumeArrayOutput)
}

// RevisionTemplateSpec describes the data a revision should have when created from a template. Based on: https://github.com/kubernetes/api/blob/e771f807/core/v1/types.go#L3179-L3190
type RevisionTemplate struct {
	// Optional metadata for this Revision, including labels and annotations. Name will be generated by the Configuration. To set minimum instances for this revision, use the "autoscaling.knative.dev/minScale" annotation key. (Cloud Run on GKE only). To set maximum instances for this revision, use the "autoscaling.knative.dev/maxScale" annotation key. To set Cloud SQL connections for the revision, use the "run.googleapis.com/cloudsql-instances" annotation key. Values should be comma separated.
	Metadata *ObjectMeta `pulumi:"metadata"`
	// RevisionSpec holds the desired state of the Revision (from the client).
	Spec *RevisionSpec `pulumi:"spec"`
}

// RevisionTemplateInput is an input type that accepts RevisionTemplateArgs and RevisionTemplateOutput values.
// You can construct a concrete instance of `RevisionTemplateInput` via:
//
//          RevisionTemplateArgs{...}
type RevisionTemplateInput interface {
	pulumi.Input

	ToRevisionTemplateOutput() RevisionTemplateOutput
	ToRevisionTemplateOutputWithContext(context.Context) RevisionTemplateOutput
}

// RevisionTemplateSpec describes the data a revision should have when created from a template. Based on: https://github.com/kubernetes/api/blob/e771f807/core/v1/types.go#L3179-L3190
type RevisionTemplateArgs struct {
	// Optional metadata for this Revision, including labels and annotations. Name will be generated by the Configuration. To set minimum instances for this revision, use the "autoscaling.knative.dev/minScale" annotation key. (Cloud Run on GKE only). To set maximum instances for this revision, use the "autoscaling.knative.dev/maxScale" annotation key. To set Cloud SQL connections for the revision, use the "run.googleapis.com/cloudsql-instances" annotation key. Values should be comma separated.
	Metadata ObjectMetaPtrInput `pulumi:"metadata"`
	// RevisionSpec holds the desired state of the Revision (from the client).
	Spec RevisionSpecPtrInput `pulumi:"spec"`
}

func (RevisionTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RevisionTemplate)(nil)).Elem()
}

func (i RevisionTemplateArgs) ToRevisionTemplateOutput() RevisionTemplateOutput {
	return i.ToRevisionTemplateOutputWithContext(context.Background())
}

func (i RevisionTemplateArgs) ToRevisionTemplateOutputWithContext(ctx context.Context) RevisionTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RevisionTemplateOutput)
}

func (i RevisionTemplateArgs) ToRevisionTemplatePtrOutput() RevisionTemplatePtrOutput {
	return i.ToRevisionTemplatePtrOutputWithContext(context.Background())
}

func (i RevisionTemplateArgs) ToRevisionTemplatePtrOutputWithContext(ctx context.Context) RevisionTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RevisionTemplateOutput).ToRevisionTemplatePtrOutputWithContext(ctx)
}

// RevisionTemplatePtrInput is an input type that accepts RevisionTemplateArgs, RevisionTemplatePtr and RevisionTemplatePtrOutput values.
// You can construct a concrete instance of `RevisionTemplatePtrInput` via:
//
//          RevisionTemplateArgs{...}
//
//  or:
//
//          nil
type RevisionTemplatePtrInput interface {
	pulumi.Input

	ToRevisionTemplatePtrOutput() RevisionTemplatePtrOutput
	ToRevisionTemplatePtrOutputWithContext(context.Context) RevisionTemplatePtrOutput
}

type revisionTemplatePtrType RevisionTemplateArgs

func RevisionTemplatePtr(v *RevisionTemplateArgs) RevisionTemplatePtrInput {
	return (*revisionTemplatePtrType)(v)
}

func (*revisionTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RevisionTemplate)(nil)).Elem()
}

func (i *revisionTemplatePtrType) ToRevisionTemplatePtrOutput() RevisionTemplatePtrOutput {
	return i.ToRevisionTemplatePtrOutputWithContext(context.Background())
}

func (i *revisionTemplatePtrType) ToRevisionTemplatePtrOutputWithContext(ctx context.Context) RevisionTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RevisionTemplatePtrOutput)
}

// RevisionTemplateSpec describes the data a revision should have when created from a template. Based on: https://github.com/kubernetes/api/blob/e771f807/core/v1/types.go#L3179-L3190
type RevisionTemplateOutput struct{ *pulumi.OutputState }

func (RevisionTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RevisionTemplate)(nil)).Elem()
}

func (o RevisionTemplateOutput) ToRevisionTemplateOutput() RevisionTemplateOutput {
	return o
}

func (o RevisionTemplateOutput) ToRevisionTemplateOutputWithContext(ctx context.Context) RevisionTemplateOutput {
	return o
}

func (o RevisionTemplateOutput) ToRevisionTemplatePtrOutput() RevisionTemplatePtrOutput {
	return o.ToRevisionTemplatePtrOutputWithContext(context.Background())
}

func (o RevisionTemplateOutput) ToRevisionTemplatePtrOutputWithContext(ctx context.Context) RevisionTemplatePtrOutput {
	return o.ApplyT(func(v RevisionTemplate) *RevisionTemplate {
		return &v
	}).(RevisionTemplatePtrOutput)
}

// Optional metadata for this Revision, including labels and annotations. Name will be generated by the Configuration. To set minimum instances for this revision, use the "autoscaling.knative.dev/minScale" annotation key. (Cloud Run on GKE only). To set maximum instances for this revision, use the "autoscaling.knative.dev/maxScale" annotation key. To set Cloud SQL connections for the revision, use the "run.googleapis.com/cloudsql-instances" annotation key. Values should be comma separated.
func (o RevisionTemplateOutput) Metadata() ObjectMetaPtrOutput {
	return o.ApplyT(func(v RevisionTemplate) *ObjectMeta { return v.Metadata }).(ObjectMetaPtrOutput)
}

// RevisionSpec holds the desired state of the Revision (from the client).
func (o RevisionTemplateOutput) Spec() RevisionSpecPtrOutput {
	return o.ApplyT(func(v RevisionTemplate) *RevisionSpec { return v.Spec }).(RevisionSpecPtrOutput)
}

type RevisionTemplatePtrOutput struct{ *pulumi.OutputState }

func (RevisionTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RevisionTemplate)(nil)).Elem()
}

func (o RevisionTemplatePtrOutput) ToRevisionTemplatePtrOutput() RevisionTemplatePtrOutput {
	return o
}

func (o RevisionTemplatePtrOutput) ToRevisionTemplatePtrOutputWithContext(ctx context.Context) RevisionTemplatePtrOutput {
	return o
}

func (o RevisionTemplatePtrOutput) Elem() RevisionTemplateOutput {
	return o.ApplyT(func(v *RevisionTemplate) RevisionTemplate { return *v }).(RevisionTemplateOutput)
}

// Optional metadata for this Revision, including labels and annotations. Name will be generated by the Configuration. To set minimum instances for this revision, use the "autoscaling.knative.dev/minScale" annotation key. (Cloud Run on GKE only). To set maximum instances for this revision, use the "autoscaling.knative.dev/maxScale" annotation key. To set Cloud SQL connections for the revision, use the "run.googleapis.com/cloudsql-instances" annotation key. Values should be comma separated.
func (o RevisionTemplatePtrOutput) Metadata() ObjectMetaPtrOutput {
	return o.ApplyT(func(v *RevisionTemplate) *ObjectMeta {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ObjectMetaPtrOutput)
}

// RevisionSpec holds the desired state of the Revision (from the client).
func (o RevisionTemplatePtrOutput) Spec() RevisionSpecPtrOutput {
	return o.ApplyT(func(v *RevisionTemplate) *RevisionSpec {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(RevisionSpecPtrOutput)
}

// SELinuxOptions are the labels to be applied to the container
type SELinuxOptions struct {
	// Level is SELinux level label that applies to the container. +optional
	Level *string `pulumi:"level"`
	// Role is a SELinux role label that applies to the container. +optional
	Role *string `pulumi:"role"`
	// Type is a SELinux type label that applies to the container. +optional
	Type *string `pulumi:"type"`
	// User is a SELinux user label that applies to the container. +optional
	User *string `pulumi:"user"`
}

// SELinuxOptionsInput is an input type that accepts SELinuxOptionsArgs and SELinuxOptionsOutput values.
// You can construct a concrete instance of `SELinuxOptionsInput` via:
//
//          SELinuxOptionsArgs{...}
type SELinuxOptionsInput interface {
	pulumi.Input

	ToSELinuxOptionsOutput() SELinuxOptionsOutput
	ToSELinuxOptionsOutputWithContext(context.Context) SELinuxOptionsOutput
}

// SELinuxOptions are the labels to be applied to the container
type SELinuxOptionsArgs struct {
	// Level is SELinux level label that applies to the container. +optional
	Level pulumi.StringPtrInput `pulumi:"level"`
	// Role is a SELinux role label that applies to the container. +optional
	Role pulumi.StringPtrInput `pulumi:"role"`
	// Type is a SELinux type label that applies to the container. +optional
	Type pulumi.StringPtrInput `pulumi:"type"`
	// User is a SELinux user label that applies to the container. +optional
	User pulumi.StringPtrInput `pulumi:"user"`
}

func (SELinuxOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SELinuxOptions)(nil)).Elem()
}

func (i SELinuxOptionsArgs) ToSELinuxOptionsOutput() SELinuxOptionsOutput {
	return i.ToSELinuxOptionsOutputWithContext(context.Background())
}

func (i SELinuxOptionsArgs) ToSELinuxOptionsOutputWithContext(ctx context.Context) SELinuxOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SELinuxOptionsOutput)
}

func (i SELinuxOptionsArgs) ToSELinuxOptionsPtrOutput() SELinuxOptionsPtrOutput {
	return i.ToSELinuxOptionsPtrOutputWithContext(context.Background())
}

func (i SELinuxOptionsArgs) ToSELinuxOptionsPtrOutputWithContext(ctx context.Context) SELinuxOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SELinuxOptionsOutput).ToSELinuxOptionsPtrOutputWithContext(ctx)
}

// SELinuxOptionsPtrInput is an input type that accepts SELinuxOptionsArgs, SELinuxOptionsPtr and SELinuxOptionsPtrOutput values.
// You can construct a concrete instance of `SELinuxOptionsPtrInput` via:
//
//          SELinuxOptionsArgs{...}
//
//  or:
//
//          nil
type SELinuxOptionsPtrInput interface {
	pulumi.Input

	ToSELinuxOptionsPtrOutput() SELinuxOptionsPtrOutput
	ToSELinuxOptionsPtrOutputWithContext(context.Context) SELinuxOptionsPtrOutput
}

type selinuxOptionsPtrType SELinuxOptionsArgs

func SELinuxOptionsPtr(v *SELinuxOptionsArgs) SELinuxOptionsPtrInput {
	return (*selinuxOptionsPtrType)(v)
}

func (*selinuxOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SELinuxOptions)(nil)).Elem()
}

func (i *selinuxOptionsPtrType) ToSELinuxOptionsPtrOutput() SELinuxOptionsPtrOutput {
	return i.ToSELinuxOptionsPtrOutputWithContext(context.Background())
}

func (i *selinuxOptionsPtrType) ToSELinuxOptionsPtrOutputWithContext(ctx context.Context) SELinuxOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SELinuxOptionsPtrOutput)
}

// SELinuxOptions are the labels to be applied to the container
type SELinuxOptionsOutput struct{ *pulumi.OutputState }

func (SELinuxOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SELinuxOptions)(nil)).Elem()
}

func (o SELinuxOptionsOutput) ToSELinuxOptionsOutput() SELinuxOptionsOutput {
	return o
}

func (o SELinuxOptionsOutput) ToSELinuxOptionsOutputWithContext(ctx context.Context) SELinuxOptionsOutput {
	return o
}

func (o SELinuxOptionsOutput) ToSELinuxOptionsPtrOutput() SELinuxOptionsPtrOutput {
	return o.ToSELinuxOptionsPtrOutputWithContext(context.Background())
}

func (o SELinuxOptionsOutput) ToSELinuxOptionsPtrOutputWithContext(ctx context.Context) SELinuxOptionsPtrOutput {
	return o.ApplyT(func(v SELinuxOptions) *SELinuxOptions {
		return &v
	}).(SELinuxOptionsPtrOutput)
}

// Level is SELinux level label that applies to the container. +optional
func (o SELinuxOptionsOutput) Level() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SELinuxOptions) *string { return v.Level }).(pulumi.StringPtrOutput)
}

// Role is a SELinux role label that applies to the container. +optional
func (o SELinuxOptionsOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SELinuxOptions) *string { return v.Role }).(pulumi.StringPtrOutput)
}

// Type is a SELinux type label that applies to the container. +optional
func (o SELinuxOptionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SELinuxOptions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// User is a SELinux user label that applies to the container. +optional
func (o SELinuxOptionsOutput) User() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SELinuxOptions) *string { return v.User }).(pulumi.StringPtrOutput)
}

type SELinuxOptionsPtrOutput struct{ *pulumi.OutputState }

func (SELinuxOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SELinuxOptions)(nil)).Elem()
}

func (o SELinuxOptionsPtrOutput) ToSELinuxOptionsPtrOutput() SELinuxOptionsPtrOutput {
	return o
}

func (o SELinuxOptionsPtrOutput) ToSELinuxOptionsPtrOutputWithContext(ctx context.Context) SELinuxOptionsPtrOutput {
	return o
}

func (o SELinuxOptionsPtrOutput) Elem() SELinuxOptionsOutput {
	return o.ApplyT(func(v *SELinuxOptions) SELinuxOptions { return *v }).(SELinuxOptionsOutput)
}

// Level is SELinux level label that applies to the container. +optional
func (o SELinuxOptionsPtrOutput) Level() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SELinuxOptions) *string {
		if v == nil {
			return nil
		}
		return v.Level
	}).(pulumi.StringPtrOutput)
}

// Role is a SELinux role label that applies to the container. +optional
func (o SELinuxOptionsPtrOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SELinuxOptions) *string {
		if v == nil {
			return nil
		}
		return v.Role
	}).(pulumi.StringPtrOutput)
}

// Type is a SELinux type label that applies to the container. +optional
func (o SELinuxOptionsPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SELinuxOptions) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// User is a SELinux user label that applies to the container. +optional
func (o SELinuxOptionsPtrOutput) User() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SELinuxOptions) *string {
		if v == nil {
			return nil
		}
		return v.User
	}).(pulumi.StringPtrOutput)
}

// SecretEnvSource selects a Secret to populate the environment variables with. The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
type SecretEnvSource struct {
	// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
	LocalObjectReference *LocalObjectReference `pulumi:"localObjectReference"`
	// Cloud Run fully managed: not supported Cloud Run for Anthos: supported The Secret to select from.
	Name *string `pulumi:"name"`
	// Cloud Run fully managed: not supported Cloud Run for Anthos: supported Specify whether the Secret must be defined +optional
	Optional *bool `pulumi:"optional"`
}

// SecretEnvSourceInput is an input type that accepts SecretEnvSourceArgs and SecretEnvSourceOutput values.
// You can construct a concrete instance of `SecretEnvSourceInput` via:
//
//          SecretEnvSourceArgs{...}
type SecretEnvSourceInput interface {
	pulumi.Input

	ToSecretEnvSourceOutput() SecretEnvSourceOutput
	ToSecretEnvSourceOutputWithContext(context.Context) SecretEnvSourceOutput
}

// SecretEnvSource selects a Secret to populate the environment variables with. The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
type SecretEnvSourceArgs struct {
	// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
	LocalObjectReference LocalObjectReferencePtrInput `pulumi:"localObjectReference"`
	// Cloud Run fully managed: not supported Cloud Run for Anthos: supported The Secret to select from.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Cloud Run fully managed: not supported Cloud Run for Anthos: supported Specify whether the Secret must be defined +optional
	Optional pulumi.BoolPtrInput `pulumi:"optional"`
}

func (SecretEnvSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SecretEnvSource)(nil)).Elem()
}

func (i SecretEnvSourceArgs) ToSecretEnvSourceOutput() SecretEnvSourceOutput {
	return i.ToSecretEnvSourceOutputWithContext(context.Background())
}

func (i SecretEnvSourceArgs) ToSecretEnvSourceOutputWithContext(ctx context.Context) SecretEnvSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretEnvSourceOutput)
}

func (i SecretEnvSourceArgs) ToSecretEnvSourcePtrOutput() SecretEnvSourcePtrOutput {
	return i.ToSecretEnvSourcePtrOutputWithContext(context.Background())
}

func (i SecretEnvSourceArgs) ToSecretEnvSourcePtrOutputWithContext(ctx context.Context) SecretEnvSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretEnvSourceOutput).ToSecretEnvSourcePtrOutputWithContext(ctx)
}

// SecretEnvSourcePtrInput is an input type that accepts SecretEnvSourceArgs, SecretEnvSourcePtr and SecretEnvSourcePtrOutput values.
// You can construct a concrete instance of `SecretEnvSourcePtrInput` via:
//
//          SecretEnvSourceArgs{...}
//
//  or:
//
//          nil
type SecretEnvSourcePtrInput interface {
	pulumi.Input

	ToSecretEnvSourcePtrOutput() SecretEnvSourcePtrOutput
	ToSecretEnvSourcePtrOutputWithContext(context.Context) SecretEnvSourcePtrOutput
}

type secretEnvSourcePtrType SecretEnvSourceArgs

func SecretEnvSourcePtr(v *SecretEnvSourceArgs) SecretEnvSourcePtrInput {
	return (*secretEnvSourcePtrType)(v)
}

func (*secretEnvSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SecretEnvSource)(nil)).Elem()
}

func (i *secretEnvSourcePtrType) ToSecretEnvSourcePtrOutput() SecretEnvSourcePtrOutput {
	return i.ToSecretEnvSourcePtrOutputWithContext(context.Background())
}

func (i *secretEnvSourcePtrType) ToSecretEnvSourcePtrOutputWithContext(ctx context.Context) SecretEnvSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretEnvSourcePtrOutput)
}

// SecretEnvSource selects a Secret to populate the environment variables with. The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
type SecretEnvSourceOutput struct{ *pulumi.OutputState }

func (SecretEnvSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SecretEnvSource)(nil)).Elem()
}

func (o SecretEnvSourceOutput) ToSecretEnvSourceOutput() SecretEnvSourceOutput {
	return o
}

func (o SecretEnvSourceOutput) ToSecretEnvSourceOutputWithContext(ctx context.Context) SecretEnvSourceOutput {
	return o
}

func (o SecretEnvSourceOutput) ToSecretEnvSourcePtrOutput() SecretEnvSourcePtrOutput {
	return o.ToSecretEnvSourcePtrOutputWithContext(context.Background())
}

func (o SecretEnvSourceOutput) ToSecretEnvSourcePtrOutputWithContext(ctx context.Context) SecretEnvSourcePtrOutput {
	return o.ApplyT(func(v SecretEnvSource) *SecretEnvSource {
		return &v
	}).(SecretEnvSourcePtrOutput)
}

// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
func (o SecretEnvSourceOutput) LocalObjectReference() LocalObjectReferencePtrOutput {
	return o.ApplyT(func(v SecretEnvSource) *LocalObjectReference { return v.LocalObjectReference }).(LocalObjectReferencePtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run for Anthos: supported The Secret to select from.
func (o SecretEnvSourceOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SecretEnvSource) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run for Anthos: supported Specify whether the Secret must be defined +optional
func (o SecretEnvSourceOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SecretEnvSource) *bool { return v.Optional }).(pulumi.BoolPtrOutput)
}

type SecretEnvSourcePtrOutput struct{ *pulumi.OutputState }

func (SecretEnvSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SecretEnvSource)(nil)).Elem()
}

func (o SecretEnvSourcePtrOutput) ToSecretEnvSourcePtrOutput() SecretEnvSourcePtrOutput {
	return o
}

func (o SecretEnvSourcePtrOutput) ToSecretEnvSourcePtrOutputWithContext(ctx context.Context) SecretEnvSourcePtrOutput {
	return o
}

func (o SecretEnvSourcePtrOutput) Elem() SecretEnvSourceOutput {
	return o.ApplyT(func(v *SecretEnvSource) SecretEnvSource { return *v }).(SecretEnvSourceOutput)
}

// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
func (o SecretEnvSourcePtrOutput) LocalObjectReference() LocalObjectReferencePtrOutput {
	return o.ApplyT(func(v *SecretEnvSource) *LocalObjectReference {
		if v == nil {
			return nil
		}
		return v.LocalObjectReference
	}).(LocalObjectReferencePtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run for Anthos: supported The Secret to select from.
func (o SecretEnvSourcePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SecretEnvSource) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run for Anthos: supported Specify whether the Secret must be defined +optional
func (o SecretEnvSourcePtrOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecretEnvSource) *bool {
		if v == nil {
			return nil
		}
		return v.Optional
	}).(pulumi.BoolPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported SecretKeySelector selects a key of a Secret.
type SecretKeySelector struct {
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported The key of the secret to select from. Must be a valid secret key.
	Key *string `pulumi:"key"`
	// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
	LocalObjectReference *LocalObjectReference `pulumi:"localObjectReference"`
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported The name of the secret in the pod's namespace to select from.
	Name *string `pulumi:"name"`
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported Specify whether the Secret or its key must be defined +optional
	Optional *bool `pulumi:"optional"`
}

// SecretKeySelectorInput is an input type that accepts SecretKeySelectorArgs and SecretKeySelectorOutput values.
// You can construct a concrete instance of `SecretKeySelectorInput` via:
//
//          SecretKeySelectorArgs{...}
type SecretKeySelectorInput interface {
	pulumi.Input

	ToSecretKeySelectorOutput() SecretKeySelectorOutput
	ToSecretKeySelectorOutputWithContext(context.Context) SecretKeySelectorOutput
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported SecretKeySelector selects a key of a Secret.
type SecretKeySelectorArgs struct {
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported The key of the secret to select from. Must be a valid secret key.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
	LocalObjectReference LocalObjectReferencePtrInput `pulumi:"localObjectReference"`
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported The name of the secret in the pod's namespace to select from.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Cloud Run fully managed: not supported Cloud Run on GKE: supported Specify whether the Secret or its key must be defined +optional
	Optional pulumi.BoolPtrInput `pulumi:"optional"`
}

func (SecretKeySelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SecretKeySelector)(nil)).Elem()
}

func (i SecretKeySelectorArgs) ToSecretKeySelectorOutput() SecretKeySelectorOutput {
	return i.ToSecretKeySelectorOutputWithContext(context.Background())
}

func (i SecretKeySelectorArgs) ToSecretKeySelectorOutputWithContext(ctx context.Context) SecretKeySelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretKeySelectorOutput)
}

func (i SecretKeySelectorArgs) ToSecretKeySelectorPtrOutput() SecretKeySelectorPtrOutput {
	return i.ToSecretKeySelectorPtrOutputWithContext(context.Background())
}

func (i SecretKeySelectorArgs) ToSecretKeySelectorPtrOutputWithContext(ctx context.Context) SecretKeySelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretKeySelectorOutput).ToSecretKeySelectorPtrOutputWithContext(ctx)
}

// SecretKeySelectorPtrInput is an input type that accepts SecretKeySelectorArgs, SecretKeySelectorPtr and SecretKeySelectorPtrOutput values.
// You can construct a concrete instance of `SecretKeySelectorPtrInput` via:
//
//          SecretKeySelectorArgs{...}
//
//  or:
//
//          nil
type SecretKeySelectorPtrInput interface {
	pulumi.Input

	ToSecretKeySelectorPtrOutput() SecretKeySelectorPtrOutput
	ToSecretKeySelectorPtrOutputWithContext(context.Context) SecretKeySelectorPtrOutput
}

type secretKeySelectorPtrType SecretKeySelectorArgs

func SecretKeySelectorPtr(v *SecretKeySelectorArgs) SecretKeySelectorPtrInput {
	return (*secretKeySelectorPtrType)(v)
}

func (*secretKeySelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SecretKeySelector)(nil)).Elem()
}

func (i *secretKeySelectorPtrType) ToSecretKeySelectorPtrOutput() SecretKeySelectorPtrOutput {
	return i.ToSecretKeySelectorPtrOutputWithContext(context.Background())
}

func (i *secretKeySelectorPtrType) ToSecretKeySelectorPtrOutputWithContext(ctx context.Context) SecretKeySelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretKeySelectorPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported SecretKeySelector selects a key of a Secret.
type SecretKeySelectorOutput struct{ *pulumi.OutputState }

func (SecretKeySelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SecretKeySelector)(nil)).Elem()
}

func (o SecretKeySelectorOutput) ToSecretKeySelectorOutput() SecretKeySelectorOutput {
	return o
}

func (o SecretKeySelectorOutput) ToSecretKeySelectorOutputWithContext(ctx context.Context) SecretKeySelectorOutput {
	return o
}

func (o SecretKeySelectorOutput) ToSecretKeySelectorPtrOutput() SecretKeySelectorPtrOutput {
	return o.ToSecretKeySelectorPtrOutputWithContext(context.Background())
}

func (o SecretKeySelectorOutput) ToSecretKeySelectorPtrOutputWithContext(ctx context.Context) SecretKeySelectorPtrOutput {
	return o.ApplyT(func(v SecretKeySelector) *SecretKeySelector {
		return &v
	}).(SecretKeySelectorPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported The key of the secret to select from. Must be a valid secret key.
func (o SecretKeySelectorOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SecretKeySelector) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
func (o SecretKeySelectorOutput) LocalObjectReference() LocalObjectReferencePtrOutput {
	return o.ApplyT(func(v SecretKeySelector) *LocalObjectReference { return v.LocalObjectReference }).(LocalObjectReferencePtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported The name of the secret in the pod's namespace to select from.
func (o SecretKeySelectorOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SecretKeySelector) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported Specify whether the Secret or its key must be defined +optional
func (o SecretKeySelectorOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SecretKeySelector) *bool { return v.Optional }).(pulumi.BoolPtrOutput)
}

type SecretKeySelectorPtrOutput struct{ *pulumi.OutputState }

func (SecretKeySelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SecretKeySelector)(nil)).Elem()
}

func (o SecretKeySelectorPtrOutput) ToSecretKeySelectorPtrOutput() SecretKeySelectorPtrOutput {
	return o
}

func (o SecretKeySelectorPtrOutput) ToSecretKeySelectorPtrOutputWithContext(ctx context.Context) SecretKeySelectorPtrOutput {
	return o
}

func (o SecretKeySelectorPtrOutput) Elem() SecretKeySelectorOutput {
	return o.ApplyT(func(v *SecretKeySelector) SecretKeySelector { return *v }).(SecretKeySelectorOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported The key of the secret to select from. Must be a valid secret key.
func (o SecretKeySelectorPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SecretKeySelector) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// This field should not be used directly as it is meant to be inlined directly into the message. Use the "name" field instead.
func (o SecretKeySelectorPtrOutput) LocalObjectReference() LocalObjectReferencePtrOutput {
	return o.ApplyT(func(v *SecretKeySelector) *LocalObjectReference {
		if v == nil {
			return nil
		}
		return v.LocalObjectReference
	}).(LocalObjectReferencePtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported The name of the secret in the pod's namespace to select from.
func (o SecretKeySelectorPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SecretKeySelector) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Cloud Run fully managed: not supported Cloud Run on GKE: supported Specify whether the Secret or its key must be defined +optional
func (o SecretKeySelectorPtrOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecretKeySelector) *bool {
		if v == nil {
			return nil
		}
		return v.Optional
	}).(pulumi.BoolPtrOutput)
}

// The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names.
type SecretVolumeSource struct {
	// Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode *int `pulumi:"defaultMode"`
	// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional.
	Items []KeyToPath `pulumi:"items"`
	// Specify whether the Secret or its keys must be defined.
	Optional *bool `pulumi:"optional"`
	// Name of the secret in the container's namespace to use.
	SecretName *string `pulumi:"secretName"`
}

// SecretVolumeSourceInput is an input type that accepts SecretVolumeSourceArgs and SecretVolumeSourceOutput values.
// You can construct a concrete instance of `SecretVolumeSourceInput` via:
//
//          SecretVolumeSourceArgs{...}
type SecretVolumeSourceInput interface {
	pulumi.Input

	ToSecretVolumeSourceOutput() SecretVolumeSourceOutput
	ToSecretVolumeSourceOutputWithContext(context.Context) SecretVolumeSourceOutput
}

// The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names.
type SecretVolumeSourceArgs struct {
	// Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
	DefaultMode pulumi.IntPtrInput `pulumi:"defaultMode"`
	// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional.
	Items KeyToPathArrayInput `pulumi:"items"`
	// Specify whether the Secret or its keys must be defined.
	Optional pulumi.BoolPtrInput `pulumi:"optional"`
	// Name of the secret in the container's namespace to use.
	SecretName pulumi.StringPtrInput `pulumi:"secretName"`
}

func (SecretVolumeSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SecretVolumeSource)(nil)).Elem()
}

func (i SecretVolumeSourceArgs) ToSecretVolumeSourceOutput() SecretVolumeSourceOutput {
	return i.ToSecretVolumeSourceOutputWithContext(context.Background())
}

func (i SecretVolumeSourceArgs) ToSecretVolumeSourceOutputWithContext(ctx context.Context) SecretVolumeSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretVolumeSourceOutput)
}

func (i SecretVolumeSourceArgs) ToSecretVolumeSourcePtrOutput() SecretVolumeSourcePtrOutput {
	return i.ToSecretVolumeSourcePtrOutputWithContext(context.Background())
}

func (i SecretVolumeSourceArgs) ToSecretVolumeSourcePtrOutputWithContext(ctx context.Context) SecretVolumeSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretVolumeSourceOutput).ToSecretVolumeSourcePtrOutputWithContext(ctx)
}

// SecretVolumeSourcePtrInput is an input type that accepts SecretVolumeSourceArgs, SecretVolumeSourcePtr and SecretVolumeSourcePtrOutput values.
// You can construct a concrete instance of `SecretVolumeSourcePtrInput` via:
//
//          SecretVolumeSourceArgs{...}
//
//  or:
//
//          nil
type SecretVolumeSourcePtrInput interface {
	pulumi.Input

	ToSecretVolumeSourcePtrOutput() SecretVolumeSourcePtrOutput
	ToSecretVolumeSourcePtrOutputWithContext(context.Context) SecretVolumeSourcePtrOutput
}

type secretVolumeSourcePtrType SecretVolumeSourceArgs

func SecretVolumeSourcePtr(v *SecretVolumeSourceArgs) SecretVolumeSourcePtrInput {
	return (*secretVolumeSourcePtrType)(v)
}

func (*secretVolumeSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SecretVolumeSource)(nil)).Elem()
}

func (i *secretVolumeSourcePtrType) ToSecretVolumeSourcePtrOutput() SecretVolumeSourcePtrOutput {
	return i.ToSecretVolumeSourcePtrOutputWithContext(context.Background())
}

func (i *secretVolumeSourcePtrType) ToSecretVolumeSourcePtrOutputWithContext(ctx context.Context) SecretVolumeSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretVolumeSourcePtrOutput)
}

// The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names.
type SecretVolumeSourceOutput struct{ *pulumi.OutputState }

func (SecretVolumeSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SecretVolumeSource)(nil)).Elem()
}

func (o SecretVolumeSourceOutput) ToSecretVolumeSourceOutput() SecretVolumeSourceOutput {
	return o
}

func (o SecretVolumeSourceOutput) ToSecretVolumeSourceOutputWithContext(ctx context.Context) SecretVolumeSourceOutput {
	return o
}

func (o SecretVolumeSourceOutput) ToSecretVolumeSourcePtrOutput() SecretVolumeSourcePtrOutput {
	return o.ToSecretVolumeSourcePtrOutputWithContext(context.Background())
}

func (o SecretVolumeSourceOutput) ToSecretVolumeSourcePtrOutputWithContext(ctx context.Context) SecretVolumeSourcePtrOutput {
	return o.ApplyT(func(v SecretVolumeSource) *SecretVolumeSource {
		return &v
	}).(SecretVolumeSourcePtrOutput)
}

// Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o SecretVolumeSourceOutput) DefaultMode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v SecretVolumeSource) *int { return v.DefaultMode }).(pulumi.IntPtrOutput)
}

// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional.
func (o SecretVolumeSourceOutput) Items() KeyToPathArrayOutput {
	return o.ApplyT(func(v SecretVolumeSource) []KeyToPath { return v.Items }).(KeyToPathArrayOutput)
}

// Specify whether the Secret or its keys must be defined.
func (o SecretVolumeSourceOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SecretVolumeSource) *bool { return v.Optional }).(pulumi.BoolPtrOutput)
}

// Name of the secret in the container's namespace to use.
func (o SecretVolumeSourceOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SecretVolumeSource) *string { return v.SecretName }).(pulumi.StringPtrOutput)
}

type SecretVolumeSourcePtrOutput struct{ *pulumi.OutputState }

func (SecretVolumeSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SecretVolumeSource)(nil)).Elem()
}

func (o SecretVolumeSourcePtrOutput) ToSecretVolumeSourcePtrOutput() SecretVolumeSourcePtrOutput {
	return o
}

func (o SecretVolumeSourcePtrOutput) ToSecretVolumeSourcePtrOutputWithContext(ctx context.Context) SecretVolumeSourcePtrOutput {
	return o
}

func (o SecretVolumeSourcePtrOutput) Elem() SecretVolumeSourceOutput {
	return o.ApplyT(func(v *SecretVolumeSource) SecretVolumeSource { return *v }).(SecretVolumeSourceOutput)
}

// Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
func (o SecretVolumeSourcePtrOutput) DefaultMode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SecretVolumeSource) *int {
		if v == nil {
			return nil
		}
		return v.DefaultMode
	}).(pulumi.IntPtrOutput)
}

// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional.
func (o SecretVolumeSourcePtrOutput) Items() KeyToPathArrayOutput {
	return o.ApplyT(func(v *SecretVolumeSource) []KeyToPath {
		if v == nil {
			return nil
		}
		return v.Items
	}).(KeyToPathArrayOutput)
}

// Specify whether the Secret or its keys must be defined.
func (o SecretVolumeSourcePtrOutput) Optional() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecretVolumeSource) *bool {
		if v == nil {
			return nil
		}
		return v.Optional
	}).(pulumi.BoolPtrOutput)
}

// Name of the secret in the container's namespace to use.
func (o SecretVolumeSourcePtrOutput) SecretName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SecretVolumeSource) *string {
		if v == nil {
			return nil
		}
		return v.SecretName
	}).(pulumi.StringPtrOutput)
}

// SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext. When both are set, the values in SecurityContext take precedence.
type SecurityContext struct {
	// AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN +optional
	AllowPrivilegeEscalation *bool `pulumi:"allowPrivilegeEscalation"`
	// The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. +optional
	Capabilities *Capabilities `pulumi:"capabilities"`
	// Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. +optional
	Privileged *bool `pulumi:"privileged"`
	// Whether this container has a read-only root filesystem. Default is false. +optional
	ReadOnlyRootFilesystem *bool `pulumi:"readOnlyRootFilesystem"`
	// The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
	RunAsGroup *int `pulumi:"runAsGroup"`
	// Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
	RunAsNonRoot *bool `pulumi:"runAsNonRoot"`
	// The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
	RunAsUser *int `pulumi:"runAsUser"`
	// The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
	SeLinuxOptions *SELinuxOptions `pulumi:"seLinuxOptions"`
}

// SecurityContextInput is an input type that accepts SecurityContextArgs and SecurityContextOutput values.
// You can construct a concrete instance of `SecurityContextInput` via:
//
//          SecurityContextArgs{...}
type SecurityContextInput interface {
	pulumi.Input

	ToSecurityContextOutput() SecurityContextOutput
	ToSecurityContextOutputWithContext(context.Context) SecurityContextOutput
}

// SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext. When both are set, the values in SecurityContext take precedence.
type SecurityContextArgs struct {
	// AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN +optional
	AllowPrivilegeEscalation pulumi.BoolPtrInput `pulumi:"allowPrivilegeEscalation"`
	// The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. +optional
	Capabilities CapabilitiesPtrInput `pulumi:"capabilities"`
	// Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. +optional
	Privileged pulumi.BoolPtrInput `pulumi:"privileged"`
	// Whether this container has a read-only root filesystem. Default is false. +optional
	ReadOnlyRootFilesystem pulumi.BoolPtrInput `pulumi:"readOnlyRootFilesystem"`
	// The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
	RunAsGroup pulumi.IntPtrInput `pulumi:"runAsGroup"`
	// Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
	RunAsNonRoot pulumi.BoolPtrInput `pulumi:"runAsNonRoot"`
	// The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
	RunAsUser pulumi.IntPtrInput `pulumi:"runAsUser"`
	// The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
	SeLinuxOptions SELinuxOptionsPtrInput `pulumi:"seLinuxOptions"`
}

func (SecurityContextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SecurityContext)(nil)).Elem()
}

func (i SecurityContextArgs) ToSecurityContextOutput() SecurityContextOutput {
	return i.ToSecurityContextOutputWithContext(context.Background())
}

func (i SecurityContextArgs) ToSecurityContextOutputWithContext(ctx context.Context) SecurityContextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecurityContextOutput)
}

func (i SecurityContextArgs) ToSecurityContextPtrOutput() SecurityContextPtrOutput {
	return i.ToSecurityContextPtrOutputWithContext(context.Background())
}

func (i SecurityContextArgs) ToSecurityContextPtrOutputWithContext(ctx context.Context) SecurityContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecurityContextOutput).ToSecurityContextPtrOutputWithContext(ctx)
}

// SecurityContextPtrInput is an input type that accepts SecurityContextArgs, SecurityContextPtr and SecurityContextPtrOutput values.
// You can construct a concrete instance of `SecurityContextPtrInput` via:
//
//          SecurityContextArgs{...}
//
//  or:
//
//          nil
type SecurityContextPtrInput interface {
	pulumi.Input

	ToSecurityContextPtrOutput() SecurityContextPtrOutput
	ToSecurityContextPtrOutputWithContext(context.Context) SecurityContextPtrOutput
}

type securityContextPtrType SecurityContextArgs

func SecurityContextPtr(v *SecurityContextArgs) SecurityContextPtrInput {
	return (*securityContextPtrType)(v)
}

func (*securityContextPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SecurityContext)(nil)).Elem()
}

func (i *securityContextPtrType) ToSecurityContextPtrOutput() SecurityContextPtrOutput {
	return i.ToSecurityContextPtrOutputWithContext(context.Background())
}

func (i *securityContextPtrType) ToSecurityContextPtrOutputWithContext(ctx context.Context) SecurityContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecurityContextPtrOutput)
}

// SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext. When both are set, the values in SecurityContext take precedence.
type SecurityContextOutput struct{ *pulumi.OutputState }

func (SecurityContextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SecurityContext)(nil)).Elem()
}

func (o SecurityContextOutput) ToSecurityContextOutput() SecurityContextOutput {
	return o
}

func (o SecurityContextOutput) ToSecurityContextOutputWithContext(ctx context.Context) SecurityContextOutput {
	return o
}

func (o SecurityContextOutput) ToSecurityContextPtrOutput() SecurityContextPtrOutput {
	return o.ToSecurityContextPtrOutputWithContext(context.Background())
}

func (o SecurityContextOutput) ToSecurityContextPtrOutputWithContext(ctx context.Context) SecurityContextPtrOutput {
	return o.ApplyT(func(v SecurityContext) *SecurityContext {
		return &v
	}).(SecurityContextPtrOutput)
}

// AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN +optional
func (o SecurityContextOutput) AllowPrivilegeEscalation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SecurityContext) *bool { return v.AllowPrivilegeEscalation }).(pulumi.BoolPtrOutput)
}

// The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. +optional
func (o SecurityContextOutput) Capabilities() CapabilitiesPtrOutput {
	return o.ApplyT(func(v SecurityContext) *Capabilities { return v.Capabilities }).(CapabilitiesPtrOutput)
}

// Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. +optional
func (o SecurityContextOutput) Privileged() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SecurityContext) *bool { return v.Privileged }).(pulumi.BoolPtrOutput)
}

// Whether this container has a read-only root filesystem. Default is false. +optional
func (o SecurityContextOutput) ReadOnlyRootFilesystem() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SecurityContext) *bool { return v.ReadOnlyRootFilesystem }).(pulumi.BoolPtrOutput)
}

// The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
func (o SecurityContextOutput) RunAsGroup() pulumi.IntPtrOutput {
	return o.ApplyT(func(v SecurityContext) *int { return v.RunAsGroup }).(pulumi.IntPtrOutput)
}

// Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
func (o SecurityContextOutput) RunAsNonRoot() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SecurityContext) *bool { return v.RunAsNonRoot }).(pulumi.BoolPtrOutput)
}

// The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
func (o SecurityContextOutput) RunAsUser() pulumi.IntPtrOutput {
	return o.ApplyT(func(v SecurityContext) *int { return v.RunAsUser }).(pulumi.IntPtrOutput)
}

// The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
func (o SecurityContextOutput) SeLinuxOptions() SELinuxOptionsPtrOutput {
	return o.ApplyT(func(v SecurityContext) *SELinuxOptions { return v.SeLinuxOptions }).(SELinuxOptionsPtrOutput)
}

type SecurityContextPtrOutput struct{ *pulumi.OutputState }

func (SecurityContextPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SecurityContext)(nil)).Elem()
}

func (o SecurityContextPtrOutput) ToSecurityContextPtrOutput() SecurityContextPtrOutput {
	return o
}

func (o SecurityContextPtrOutput) ToSecurityContextPtrOutputWithContext(ctx context.Context) SecurityContextPtrOutput {
	return o
}

func (o SecurityContextPtrOutput) Elem() SecurityContextOutput {
	return o.ApplyT(func(v *SecurityContext) SecurityContext { return *v }).(SecurityContextOutput)
}

// AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN +optional
func (o SecurityContextPtrOutput) AllowPrivilegeEscalation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecurityContext) *bool {
		if v == nil {
			return nil
		}
		return v.AllowPrivilegeEscalation
	}).(pulumi.BoolPtrOutput)
}

// The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. +optional
func (o SecurityContextPtrOutput) Capabilities() CapabilitiesPtrOutput {
	return o.ApplyT(func(v *SecurityContext) *Capabilities {
		if v == nil {
			return nil
		}
		return v.Capabilities
	}).(CapabilitiesPtrOutput)
}

// Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. +optional
func (o SecurityContextPtrOutput) Privileged() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecurityContext) *bool {
		if v == nil {
			return nil
		}
		return v.Privileged
	}).(pulumi.BoolPtrOutput)
}

// Whether this container has a read-only root filesystem. Default is false. +optional
func (o SecurityContextPtrOutput) ReadOnlyRootFilesystem() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecurityContext) *bool {
		if v == nil {
			return nil
		}
		return v.ReadOnlyRootFilesystem
	}).(pulumi.BoolPtrOutput)
}

// The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
func (o SecurityContextPtrOutput) RunAsGroup() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SecurityContext) *int {
		if v == nil {
			return nil
		}
		return v.RunAsGroup
	}).(pulumi.IntPtrOutput)
}

// Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
func (o SecurityContextPtrOutput) RunAsNonRoot() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecurityContext) *bool {
		if v == nil {
			return nil
		}
		return v.RunAsNonRoot
	}).(pulumi.BoolPtrOutput)
}

// The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
func (o SecurityContextPtrOutput) RunAsUser() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SecurityContext) *int {
		if v == nil {
			return nil
		}
		return v.RunAsUser
	}).(pulumi.IntPtrOutput)
}

// The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. +optional
func (o SecurityContextPtrOutput) SeLinuxOptions() SELinuxOptionsPtrOutput {
	return o.ApplyT(func(v *SecurityContext) *SELinuxOptions {
		if v == nil {
			return nil
		}
		return v.SeLinuxOptions
	}).(SELinuxOptionsPtrOutput)
}

// ServiceCondition defines a readiness condition for a Service.
type ServiceCondition struct {
	// Last time the condition transitioned from one status to another. +optional
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// Human-readable message indicating details about last transition. +optional
	Message *string `pulumi:"message"`
	// One-word CamelCase reason for the condition's last transition. +optional
	Reason *string `pulumi:"reason"`
	// How to interpret failures of this condition, one of Error, Warning, Info +optional
	Severity *string `pulumi:"severity"`
	// Status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// ServiceConditionType is used to communicate the status of the reconciliation process. See also: https://github.com/knative/serving/blob/master/docs/spec/errors.md#error-conditions-and-reporting Types include: "Ready", "ConfigurationsReady", and "RoutesReady". "Ready" will be true when the underlying Route and Configuration are ready.
	Type *string `pulumi:"type"`
}

// ServiceConditionInput is an input type that accepts ServiceConditionArgs and ServiceConditionOutput values.
// You can construct a concrete instance of `ServiceConditionInput` via:
//
//          ServiceConditionArgs{...}
type ServiceConditionInput interface {
	pulumi.Input

	ToServiceConditionOutput() ServiceConditionOutput
	ToServiceConditionOutputWithContext(context.Context) ServiceConditionOutput
}

// ServiceCondition defines a readiness condition for a Service.
type ServiceConditionArgs struct {
	// Last time the condition transitioned from one status to another. +optional
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// Human-readable message indicating details about last transition. +optional
	Message pulumi.StringPtrInput `pulumi:"message"`
	// One-word CamelCase reason for the condition's last transition. +optional
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// How to interpret failures of this condition, one of Error, Warning, Info +optional
	Severity pulumi.StringPtrInput `pulumi:"severity"`
	// Status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// ServiceConditionType is used to communicate the status of the reconciliation process. See also: https://github.com/knative/serving/blob/master/docs/spec/errors.md#error-conditions-and-reporting Types include: "Ready", "ConfigurationsReady", and "RoutesReady". "Ready" will be true when the underlying Route and Configuration are ready.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (ServiceConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceCondition)(nil)).Elem()
}

func (i ServiceConditionArgs) ToServiceConditionOutput() ServiceConditionOutput {
	return i.ToServiceConditionOutputWithContext(context.Background())
}

func (i ServiceConditionArgs) ToServiceConditionOutputWithContext(ctx context.Context) ServiceConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceConditionOutput)
}

// ServiceConditionArrayInput is an input type that accepts ServiceConditionArray and ServiceConditionArrayOutput values.
// You can construct a concrete instance of `ServiceConditionArrayInput` via:
//
//          ServiceConditionArray{ ServiceConditionArgs{...} }
type ServiceConditionArrayInput interface {
	pulumi.Input

	ToServiceConditionArrayOutput() ServiceConditionArrayOutput
	ToServiceConditionArrayOutputWithContext(context.Context) ServiceConditionArrayOutput
}

type ServiceConditionArray []ServiceConditionInput

func (ServiceConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceCondition)(nil)).Elem()
}

func (i ServiceConditionArray) ToServiceConditionArrayOutput() ServiceConditionArrayOutput {
	return i.ToServiceConditionArrayOutputWithContext(context.Background())
}

func (i ServiceConditionArray) ToServiceConditionArrayOutputWithContext(ctx context.Context) ServiceConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceConditionArrayOutput)
}

// ServiceCondition defines a readiness condition for a Service.
type ServiceConditionOutput struct{ *pulumi.OutputState }

func (ServiceConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceCondition)(nil)).Elem()
}

func (o ServiceConditionOutput) ToServiceConditionOutput() ServiceConditionOutput {
	return o
}

func (o ServiceConditionOutput) ToServiceConditionOutputWithContext(ctx context.Context) ServiceConditionOutput {
	return o
}

// Last time the condition transitioned from one status to another. +optional
func (o ServiceConditionOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceCondition) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// Human-readable message indicating details about last transition. +optional
func (o ServiceConditionOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceCondition) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// One-word CamelCase reason for the condition's last transition. +optional
func (o ServiceConditionOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceCondition) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// How to interpret failures of this condition, one of Error, Warning, Info +optional
func (o ServiceConditionOutput) Severity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceCondition) *string { return v.Severity }).(pulumi.StringPtrOutput)
}

// Status of the condition, one of True, False, Unknown.
func (o ServiceConditionOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceCondition) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// ServiceConditionType is used to communicate the status of the reconciliation process. See also: https://github.com/knative/serving/blob/master/docs/spec/errors.md#error-conditions-and-reporting Types include: "Ready", "ConfigurationsReady", and "RoutesReady". "Ready" will be true when the underlying Route and Configuration are ready.
func (o ServiceConditionOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceCondition) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type ServiceConditionArrayOutput struct{ *pulumi.OutputState }

func (ServiceConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ServiceCondition)(nil)).Elem()
}

func (o ServiceConditionArrayOutput) ToServiceConditionArrayOutput() ServiceConditionArrayOutput {
	return o
}

func (o ServiceConditionArrayOutput) ToServiceConditionArrayOutputWithContext(ctx context.Context) ServiceConditionArrayOutput {
	return o
}

func (o ServiceConditionArrayOutput) Index(i pulumi.IntInput) ServiceConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ServiceCondition {
		return vs[0].([]ServiceCondition)[vs[1].(int)]
	}).(ServiceConditionOutput)
}

// ServiceSpec holds the desired state of the Route (from the client), which is used to manipulate the underlying Route and Configuration(s).
type ServiceSpec struct {
	// Deprecated and not currently populated by Cloud Run. See metadata.generation instead, which is the sequence number containing the latest generation of the desired state. Read-only.
	Generation *int `pulumi:"generation"`
	// Manual contains the options for configuring a manual service. See ServiceSpec for more details. Not currently supported by Cloud Run.
	Manual *ServiceSpecManualType `pulumi:"manual"`
	// Pins this service to a specific revision name. The revision must be owned by the configuration provided. Deprecated and not supported by Cloud Run. +optional
	Pinned *ServiceSpecPinnedType `pulumi:"pinned"`
	// Release enables gradual promotion of new revisions by allowing traffic to be split between two revisions. This type replaces the deprecated Pinned type. Not currently supported by Cloud Run.
	Release *ServiceSpecReleaseType `pulumi:"release"`
	// RunLatest defines a simple Service. It will automatically configure a route that keeps the latest ready revision from the supplied configuration running. +optional
	RunLatest *ServiceSpecRunLatest `pulumi:"runLatest"`
	// Template holds the latest specification for the Revision to be stamped out.
	Template *RevisionTemplate `pulumi:"template"`
	// Traffic specifies how to distribute traffic over a collection of Knative Revisions and Configurations.
	Traffic []TrafficTarget `pulumi:"traffic"`
}

// ServiceSpecInput is an input type that accepts ServiceSpecArgs and ServiceSpecOutput values.
// You can construct a concrete instance of `ServiceSpecInput` via:
//
//          ServiceSpecArgs{...}
type ServiceSpecInput interface {
	pulumi.Input

	ToServiceSpecOutput() ServiceSpecOutput
	ToServiceSpecOutputWithContext(context.Context) ServiceSpecOutput
}

// ServiceSpec holds the desired state of the Route (from the client), which is used to manipulate the underlying Route and Configuration(s).
type ServiceSpecArgs struct {
	// Deprecated and not currently populated by Cloud Run. See metadata.generation instead, which is the sequence number containing the latest generation of the desired state. Read-only.
	Generation pulumi.IntPtrInput `pulumi:"generation"`
	// Manual contains the options for configuring a manual service. See ServiceSpec for more details. Not currently supported by Cloud Run.
	Manual ServiceSpecManualTypePtrInput `pulumi:"manual"`
	// Pins this service to a specific revision name. The revision must be owned by the configuration provided. Deprecated and not supported by Cloud Run. +optional
	Pinned ServiceSpecPinnedTypePtrInput `pulumi:"pinned"`
	// Release enables gradual promotion of new revisions by allowing traffic to be split between two revisions. This type replaces the deprecated Pinned type. Not currently supported by Cloud Run.
	Release ServiceSpecReleaseTypePtrInput `pulumi:"release"`
	// RunLatest defines a simple Service. It will automatically configure a route that keeps the latest ready revision from the supplied configuration running. +optional
	RunLatest ServiceSpecRunLatestPtrInput `pulumi:"runLatest"`
	// Template holds the latest specification for the Revision to be stamped out.
	Template RevisionTemplatePtrInput `pulumi:"template"`
	// Traffic specifies how to distribute traffic over a collection of Knative Revisions and Configurations.
	Traffic TrafficTargetArrayInput `pulumi:"traffic"`
}

func (ServiceSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceSpec)(nil)).Elem()
}

func (i ServiceSpecArgs) ToServiceSpecOutput() ServiceSpecOutput {
	return i.ToServiceSpecOutputWithContext(context.Background())
}

func (i ServiceSpecArgs) ToServiceSpecOutputWithContext(ctx context.Context) ServiceSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecOutput)
}

func (i ServiceSpecArgs) ToServiceSpecPtrOutput() ServiceSpecPtrOutput {
	return i.ToServiceSpecPtrOutputWithContext(context.Background())
}

func (i ServiceSpecArgs) ToServiceSpecPtrOutputWithContext(ctx context.Context) ServiceSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecOutput).ToServiceSpecPtrOutputWithContext(ctx)
}

// ServiceSpecPtrInput is an input type that accepts ServiceSpecArgs, ServiceSpecPtr and ServiceSpecPtrOutput values.
// You can construct a concrete instance of `ServiceSpecPtrInput` via:
//
//          ServiceSpecArgs{...}
//
//  or:
//
//          nil
type ServiceSpecPtrInput interface {
	pulumi.Input

	ToServiceSpecPtrOutput() ServiceSpecPtrOutput
	ToServiceSpecPtrOutputWithContext(context.Context) ServiceSpecPtrOutput
}

type serviceSpecPtrType ServiceSpecArgs

func ServiceSpecPtr(v *ServiceSpecArgs) ServiceSpecPtrInput {
	return (*serviceSpecPtrType)(v)
}

func (*serviceSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceSpec)(nil)).Elem()
}

func (i *serviceSpecPtrType) ToServiceSpecPtrOutput() ServiceSpecPtrOutput {
	return i.ToServiceSpecPtrOutputWithContext(context.Background())
}

func (i *serviceSpecPtrType) ToServiceSpecPtrOutputWithContext(ctx context.Context) ServiceSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecPtrOutput)
}

// ServiceSpec holds the desired state of the Route (from the client), which is used to manipulate the underlying Route and Configuration(s).
type ServiceSpecOutput struct{ *pulumi.OutputState }

func (ServiceSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceSpec)(nil)).Elem()
}

func (o ServiceSpecOutput) ToServiceSpecOutput() ServiceSpecOutput {
	return o
}

func (o ServiceSpecOutput) ToServiceSpecOutputWithContext(ctx context.Context) ServiceSpecOutput {
	return o
}

func (o ServiceSpecOutput) ToServiceSpecPtrOutput() ServiceSpecPtrOutput {
	return o.ToServiceSpecPtrOutputWithContext(context.Background())
}

func (o ServiceSpecOutput) ToServiceSpecPtrOutputWithContext(ctx context.Context) ServiceSpecPtrOutput {
	return o.ApplyT(func(v ServiceSpec) *ServiceSpec {
		return &v
	}).(ServiceSpecPtrOutput)
}

// Deprecated and not currently populated by Cloud Run. See metadata.generation instead, which is the sequence number containing the latest generation of the desired state. Read-only.
func (o ServiceSpecOutput) Generation() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceSpec) *int { return v.Generation }).(pulumi.IntPtrOutput)
}

// Manual contains the options for configuring a manual service. See ServiceSpec for more details. Not currently supported by Cloud Run.
func (o ServiceSpecOutput) Manual() ServiceSpecManualTypePtrOutput {
	return o.ApplyT(func(v ServiceSpec) *ServiceSpecManualType { return v.Manual }).(ServiceSpecManualTypePtrOutput)
}

// Pins this service to a specific revision name. The revision must be owned by the configuration provided. Deprecated and not supported by Cloud Run. +optional
func (o ServiceSpecOutput) Pinned() ServiceSpecPinnedTypePtrOutput {
	return o.ApplyT(func(v ServiceSpec) *ServiceSpecPinnedType { return v.Pinned }).(ServiceSpecPinnedTypePtrOutput)
}

// Release enables gradual promotion of new revisions by allowing traffic to be split between two revisions. This type replaces the deprecated Pinned type. Not currently supported by Cloud Run.
func (o ServiceSpecOutput) Release() ServiceSpecReleaseTypePtrOutput {
	return o.ApplyT(func(v ServiceSpec) *ServiceSpecReleaseType { return v.Release }).(ServiceSpecReleaseTypePtrOutput)
}

// RunLatest defines a simple Service. It will automatically configure a route that keeps the latest ready revision from the supplied configuration running. +optional
func (o ServiceSpecOutput) RunLatest() ServiceSpecRunLatestPtrOutput {
	return o.ApplyT(func(v ServiceSpec) *ServiceSpecRunLatest { return v.RunLatest }).(ServiceSpecRunLatestPtrOutput)
}

// Template holds the latest specification for the Revision to be stamped out.
func (o ServiceSpecOutput) Template() RevisionTemplatePtrOutput {
	return o.ApplyT(func(v ServiceSpec) *RevisionTemplate { return v.Template }).(RevisionTemplatePtrOutput)
}

// Traffic specifies how to distribute traffic over a collection of Knative Revisions and Configurations.
func (o ServiceSpecOutput) Traffic() TrafficTargetArrayOutput {
	return o.ApplyT(func(v ServiceSpec) []TrafficTarget { return v.Traffic }).(TrafficTargetArrayOutput)
}

type ServiceSpecPtrOutput struct{ *pulumi.OutputState }

func (ServiceSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceSpec)(nil)).Elem()
}

func (o ServiceSpecPtrOutput) ToServiceSpecPtrOutput() ServiceSpecPtrOutput {
	return o
}

func (o ServiceSpecPtrOutput) ToServiceSpecPtrOutputWithContext(ctx context.Context) ServiceSpecPtrOutput {
	return o
}

func (o ServiceSpecPtrOutput) Elem() ServiceSpecOutput {
	return o.ApplyT(func(v *ServiceSpec) ServiceSpec { return *v }).(ServiceSpecOutput)
}

// Deprecated and not currently populated by Cloud Run. See metadata.generation instead, which is the sequence number containing the latest generation of the desired state. Read-only.
func (o ServiceSpecPtrOutput) Generation() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceSpec) *int {
		if v == nil {
			return nil
		}
		return v.Generation
	}).(pulumi.IntPtrOutput)
}

// Manual contains the options for configuring a manual service. See ServiceSpec for more details. Not currently supported by Cloud Run.
func (o ServiceSpecPtrOutput) Manual() ServiceSpecManualTypePtrOutput {
	return o.ApplyT(func(v *ServiceSpec) *ServiceSpecManualType {
		if v == nil {
			return nil
		}
		return v.Manual
	}).(ServiceSpecManualTypePtrOutput)
}

// Pins this service to a specific revision name. The revision must be owned by the configuration provided. Deprecated and not supported by Cloud Run. +optional
func (o ServiceSpecPtrOutput) Pinned() ServiceSpecPinnedTypePtrOutput {
	return o.ApplyT(func(v *ServiceSpec) *ServiceSpecPinnedType {
		if v == nil {
			return nil
		}
		return v.Pinned
	}).(ServiceSpecPinnedTypePtrOutput)
}

// Release enables gradual promotion of new revisions by allowing traffic to be split between two revisions. This type replaces the deprecated Pinned type. Not currently supported by Cloud Run.
func (o ServiceSpecPtrOutput) Release() ServiceSpecReleaseTypePtrOutput {
	return o.ApplyT(func(v *ServiceSpec) *ServiceSpecReleaseType {
		if v == nil {
			return nil
		}
		return v.Release
	}).(ServiceSpecReleaseTypePtrOutput)
}

// RunLatest defines a simple Service. It will automatically configure a route that keeps the latest ready revision from the supplied configuration running. +optional
func (o ServiceSpecPtrOutput) RunLatest() ServiceSpecRunLatestPtrOutput {
	return o.ApplyT(func(v *ServiceSpec) *ServiceSpecRunLatest {
		if v == nil {
			return nil
		}
		return v.RunLatest
	}).(ServiceSpecRunLatestPtrOutput)
}

// Template holds the latest specification for the Revision to be stamped out.
func (o ServiceSpecPtrOutput) Template() RevisionTemplatePtrOutput {
	return o.ApplyT(func(v *ServiceSpec) *RevisionTemplate {
		if v == nil {
			return nil
		}
		return v.Template
	}).(RevisionTemplatePtrOutput)
}

// Traffic specifies how to distribute traffic over a collection of Knative Revisions and Configurations.
func (o ServiceSpecPtrOutput) Traffic() TrafficTargetArrayOutput {
	return o.ApplyT(func(v *ServiceSpec) []TrafficTarget {
		if v == nil {
			return nil
		}
		return v.Traffic
	}).(TrafficTargetArrayOutput)
}

// ServiceSpecManualType contains the options for configuring a manual service. See ServiceSpec for more details. Not currently supported by Cloud Run.
type ServiceSpecManualType struct {
}

// ServiceSpecManualTypeInput is an input type that accepts ServiceSpecManualTypeArgs and ServiceSpecManualTypeOutput values.
// You can construct a concrete instance of `ServiceSpecManualTypeInput` via:
//
//          ServiceSpecManualTypeArgs{...}
type ServiceSpecManualTypeInput interface {
	pulumi.Input

	ToServiceSpecManualTypeOutput() ServiceSpecManualTypeOutput
	ToServiceSpecManualTypeOutputWithContext(context.Context) ServiceSpecManualTypeOutput
}

// ServiceSpecManualType contains the options for configuring a manual service. See ServiceSpec for more details. Not currently supported by Cloud Run.
type ServiceSpecManualTypeArgs struct {
}

func (ServiceSpecManualTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceSpecManualType)(nil)).Elem()
}

func (i ServiceSpecManualTypeArgs) ToServiceSpecManualTypeOutput() ServiceSpecManualTypeOutput {
	return i.ToServiceSpecManualTypeOutputWithContext(context.Background())
}

func (i ServiceSpecManualTypeArgs) ToServiceSpecManualTypeOutputWithContext(ctx context.Context) ServiceSpecManualTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecManualTypeOutput)
}

func (i ServiceSpecManualTypeArgs) ToServiceSpecManualTypePtrOutput() ServiceSpecManualTypePtrOutput {
	return i.ToServiceSpecManualTypePtrOutputWithContext(context.Background())
}

func (i ServiceSpecManualTypeArgs) ToServiceSpecManualTypePtrOutputWithContext(ctx context.Context) ServiceSpecManualTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecManualTypeOutput).ToServiceSpecManualTypePtrOutputWithContext(ctx)
}

// ServiceSpecManualTypePtrInput is an input type that accepts ServiceSpecManualTypeArgs, ServiceSpecManualTypePtr and ServiceSpecManualTypePtrOutput values.
// You can construct a concrete instance of `ServiceSpecManualTypePtrInput` via:
//
//          ServiceSpecManualTypeArgs{...}
//
//  or:
//
//          nil
type ServiceSpecManualTypePtrInput interface {
	pulumi.Input

	ToServiceSpecManualTypePtrOutput() ServiceSpecManualTypePtrOutput
	ToServiceSpecManualTypePtrOutputWithContext(context.Context) ServiceSpecManualTypePtrOutput
}

type serviceSpecManualTypePtrType ServiceSpecManualTypeArgs

func ServiceSpecManualTypePtr(v *ServiceSpecManualTypeArgs) ServiceSpecManualTypePtrInput {
	return (*serviceSpecManualTypePtrType)(v)
}

func (*serviceSpecManualTypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceSpecManualType)(nil)).Elem()
}

func (i *serviceSpecManualTypePtrType) ToServiceSpecManualTypePtrOutput() ServiceSpecManualTypePtrOutput {
	return i.ToServiceSpecManualTypePtrOutputWithContext(context.Background())
}

func (i *serviceSpecManualTypePtrType) ToServiceSpecManualTypePtrOutputWithContext(ctx context.Context) ServiceSpecManualTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecManualTypePtrOutput)
}

// ServiceSpecManualType contains the options for configuring a manual service. See ServiceSpec for more details. Not currently supported by Cloud Run.
type ServiceSpecManualTypeOutput struct{ *pulumi.OutputState }

func (ServiceSpecManualTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceSpecManualType)(nil)).Elem()
}

func (o ServiceSpecManualTypeOutput) ToServiceSpecManualTypeOutput() ServiceSpecManualTypeOutput {
	return o
}

func (o ServiceSpecManualTypeOutput) ToServiceSpecManualTypeOutputWithContext(ctx context.Context) ServiceSpecManualTypeOutput {
	return o
}

func (o ServiceSpecManualTypeOutput) ToServiceSpecManualTypePtrOutput() ServiceSpecManualTypePtrOutput {
	return o.ToServiceSpecManualTypePtrOutputWithContext(context.Background())
}

func (o ServiceSpecManualTypeOutput) ToServiceSpecManualTypePtrOutputWithContext(ctx context.Context) ServiceSpecManualTypePtrOutput {
	return o.ApplyT(func(v ServiceSpecManualType) *ServiceSpecManualType {
		return &v
	}).(ServiceSpecManualTypePtrOutput)
}

type ServiceSpecManualTypePtrOutput struct{ *pulumi.OutputState }

func (ServiceSpecManualTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceSpecManualType)(nil)).Elem()
}

func (o ServiceSpecManualTypePtrOutput) ToServiceSpecManualTypePtrOutput() ServiceSpecManualTypePtrOutput {
	return o
}

func (o ServiceSpecManualTypePtrOutput) ToServiceSpecManualTypePtrOutputWithContext(ctx context.Context) ServiceSpecManualTypePtrOutput {
	return o
}

func (o ServiceSpecManualTypePtrOutput) Elem() ServiceSpecManualTypeOutput {
	return o.ApplyT(func(v *ServiceSpecManualType) ServiceSpecManualType { return *v }).(ServiceSpecManualTypeOutput)
}

// ServiceSpecPinnedType Pins this service to a specific revision name. The revision must be owned by the configuration provided. Deprecated and not supported by Cloud Run.
type ServiceSpecPinnedType struct {
	// The configuration for this service.
	Configuration *ConfigurationSpec `pulumi:"configuration"`
	// The revision name to pin this service to until changed to a different service type.
	RevisionName *string `pulumi:"revisionName"`
}

// ServiceSpecPinnedTypeInput is an input type that accepts ServiceSpecPinnedTypeArgs and ServiceSpecPinnedTypeOutput values.
// You can construct a concrete instance of `ServiceSpecPinnedTypeInput` via:
//
//          ServiceSpecPinnedTypeArgs{...}
type ServiceSpecPinnedTypeInput interface {
	pulumi.Input

	ToServiceSpecPinnedTypeOutput() ServiceSpecPinnedTypeOutput
	ToServiceSpecPinnedTypeOutputWithContext(context.Context) ServiceSpecPinnedTypeOutput
}

// ServiceSpecPinnedType Pins this service to a specific revision name. The revision must be owned by the configuration provided. Deprecated and not supported by Cloud Run.
type ServiceSpecPinnedTypeArgs struct {
	// The configuration for this service.
	Configuration ConfigurationSpecPtrInput `pulumi:"configuration"`
	// The revision name to pin this service to until changed to a different service type.
	RevisionName pulumi.StringPtrInput `pulumi:"revisionName"`
}

func (ServiceSpecPinnedTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceSpecPinnedType)(nil)).Elem()
}

func (i ServiceSpecPinnedTypeArgs) ToServiceSpecPinnedTypeOutput() ServiceSpecPinnedTypeOutput {
	return i.ToServiceSpecPinnedTypeOutputWithContext(context.Background())
}

func (i ServiceSpecPinnedTypeArgs) ToServiceSpecPinnedTypeOutputWithContext(ctx context.Context) ServiceSpecPinnedTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecPinnedTypeOutput)
}

func (i ServiceSpecPinnedTypeArgs) ToServiceSpecPinnedTypePtrOutput() ServiceSpecPinnedTypePtrOutput {
	return i.ToServiceSpecPinnedTypePtrOutputWithContext(context.Background())
}

func (i ServiceSpecPinnedTypeArgs) ToServiceSpecPinnedTypePtrOutputWithContext(ctx context.Context) ServiceSpecPinnedTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecPinnedTypeOutput).ToServiceSpecPinnedTypePtrOutputWithContext(ctx)
}

// ServiceSpecPinnedTypePtrInput is an input type that accepts ServiceSpecPinnedTypeArgs, ServiceSpecPinnedTypePtr and ServiceSpecPinnedTypePtrOutput values.
// You can construct a concrete instance of `ServiceSpecPinnedTypePtrInput` via:
//
//          ServiceSpecPinnedTypeArgs{...}
//
//  or:
//
//          nil
type ServiceSpecPinnedTypePtrInput interface {
	pulumi.Input

	ToServiceSpecPinnedTypePtrOutput() ServiceSpecPinnedTypePtrOutput
	ToServiceSpecPinnedTypePtrOutputWithContext(context.Context) ServiceSpecPinnedTypePtrOutput
}

type serviceSpecPinnedTypePtrType ServiceSpecPinnedTypeArgs

func ServiceSpecPinnedTypePtr(v *ServiceSpecPinnedTypeArgs) ServiceSpecPinnedTypePtrInput {
	return (*serviceSpecPinnedTypePtrType)(v)
}

func (*serviceSpecPinnedTypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceSpecPinnedType)(nil)).Elem()
}

func (i *serviceSpecPinnedTypePtrType) ToServiceSpecPinnedTypePtrOutput() ServiceSpecPinnedTypePtrOutput {
	return i.ToServiceSpecPinnedTypePtrOutputWithContext(context.Background())
}

func (i *serviceSpecPinnedTypePtrType) ToServiceSpecPinnedTypePtrOutputWithContext(ctx context.Context) ServiceSpecPinnedTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecPinnedTypePtrOutput)
}

// ServiceSpecPinnedType Pins this service to a specific revision name. The revision must be owned by the configuration provided. Deprecated and not supported by Cloud Run.
type ServiceSpecPinnedTypeOutput struct{ *pulumi.OutputState }

func (ServiceSpecPinnedTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceSpecPinnedType)(nil)).Elem()
}

func (o ServiceSpecPinnedTypeOutput) ToServiceSpecPinnedTypeOutput() ServiceSpecPinnedTypeOutput {
	return o
}

func (o ServiceSpecPinnedTypeOutput) ToServiceSpecPinnedTypeOutputWithContext(ctx context.Context) ServiceSpecPinnedTypeOutput {
	return o
}

func (o ServiceSpecPinnedTypeOutput) ToServiceSpecPinnedTypePtrOutput() ServiceSpecPinnedTypePtrOutput {
	return o.ToServiceSpecPinnedTypePtrOutputWithContext(context.Background())
}

func (o ServiceSpecPinnedTypeOutput) ToServiceSpecPinnedTypePtrOutputWithContext(ctx context.Context) ServiceSpecPinnedTypePtrOutput {
	return o.ApplyT(func(v ServiceSpecPinnedType) *ServiceSpecPinnedType {
		return &v
	}).(ServiceSpecPinnedTypePtrOutput)
}

// The configuration for this service.
func (o ServiceSpecPinnedTypeOutput) Configuration() ConfigurationSpecPtrOutput {
	return o.ApplyT(func(v ServiceSpecPinnedType) *ConfigurationSpec { return v.Configuration }).(ConfigurationSpecPtrOutput)
}

// The revision name to pin this service to until changed to a different service type.
func (o ServiceSpecPinnedTypeOutput) RevisionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceSpecPinnedType) *string { return v.RevisionName }).(pulumi.StringPtrOutput)
}

type ServiceSpecPinnedTypePtrOutput struct{ *pulumi.OutputState }

func (ServiceSpecPinnedTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceSpecPinnedType)(nil)).Elem()
}

func (o ServiceSpecPinnedTypePtrOutput) ToServiceSpecPinnedTypePtrOutput() ServiceSpecPinnedTypePtrOutput {
	return o
}

func (o ServiceSpecPinnedTypePtrOutput) ToServiceSpecPinnedTypePtrOutputWithContext(ctx context.Context) ServiceSpecPinnedTypePtrOutput {
	return o
}

func (o ServiceSpecPinnedTypePtrOutput) Elem() ServiceSpecPinnedTypeOutput {
	return o.ApplyT(func(v *ServiceSpecPinnedType) ServiceSpecPinnedType { return *v }).(ServiceSpecPinnedTypeOutput)
}

// The configuration for this service.
func (o ServiceSpecPinnedTypePtrOutput) Configuration() ConfigurationSpecPtrOutput {
	return o.ApplyT(func(v *ServiceSpecPinnedType) *ConfigurationSpec {
		if v == nil {
			return nil
		}
		return v.Configuration
	}).(ConfigurationSpecPtrOutput)
}

// The revision name to pin this service to until changed to a different service type.
func (o ServiceSpecPinnedTypePtrOutput) RevisionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceSpecPinnedType) *string {
		if v == nil {
			return nil
		}
		return v.RevisionName
	}).(pulumi.StringPtrOutput)
}

// ServiceSpecReleaseType contains the options for slowly releasing revisions. See ServiceSpec for more details. Not currently supported by Cloud Run.
type ServiceSpecReleaseType struct {
	// The configuration for this service. All revisions from this service must come from a single configuration.
	Configuration *ConfigurationSpec `pulumi:"configuration"`
	// Revisions is an ordered list of 1 or 2 revisions. The first is the current revision, and the second is the candidate revision. If a single revision is provided, traffic will be pinned at that revision. "@latest" is a shortcut for usage that refers to the latest created revision by the configuration.
	Revisions []string `pulumi:"revisions"`
	// RolloutPercent is the percent of traffic that should be sent to the candidate revision, i.e. the 2nd revision in the revisions list. Valid values are between 0 and 99 inclusive.
	RolloutPercent *int `pulumi:"rolloutPercent"`
}

// ServiceSpecReleaseTypeInput is an input type that accepts ServiceSpecReleaseTypeArgs and ServiceSpecReleaseTypeOutput values.
// You can construct a concrete instance of `ServiceSpecReleaseTypeInput` via:
//
//          ServiceSpecReleaseTypeArgs{...}
type ServiceSpecReleaseTypeInput interface {
	pulumi.Input

	ToServiceSpecReleaseTypeOutput() ServiceSpecReleaseTypeOutput
	ToServiceSpecReleaseTypeOutputWithContext(context.Context) ServiceSpecReleaseTypeOutput
}

// ServiceSpecReleaseType contains the options for slowly releasing revisions. See ServiceSpec for more details. Not currently supported by Cloud Run.
type ServiceSpecReleaseTypeArgs struct {
	// The configuration for this service. All revisions from this service must come from a single configuration.
	Configuration ConfigurationSpecPtrInput `pulumi:"configuration"`
	// Revisions is an ordered list of 1 or 2 revisions. The first is the current revision, and the second is the candidate revision. If a single revision is provided, traffic will be pinned at that revision. "@latest" is a shortcut for usage that refers to the latest created revision by the configuration.
	Revisions pulumi.StringArrayInput `pulumi:"revisions"`
	// RolloutPercent is the percent of traffic that should be sent to the candidate revision, i.e. the 2nd revision in the revisions list. Valid values are between 0 and 99 inclusive.
	RolloutPercent pulumi.IntPtrInput `pulumi:"rolloutPercent"`
}

func (ServiceSpecReleaseTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceSpecReleaseType)(nil)).Elem()
}

func (i ServiceSpecReleaseTypeArgs) ToServiceSpecReleaseTypeOutput() ServiceSpecReleaseTypeOutput {
	return i.ToServiceSpecReleaseTypeOutputWithContext(context.Background())
}

func (i ServiceSpecReleaseTypeArgs) ToServiceSpecReleaseTypeOutputWithContext(ctx context.Context) ServiceSpecReleaseTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecReleaseTypeOutput)
}

func (i ServiceSpecReleaseTypeArgs) ToServiceSpecReleaseTypePtrOutput() ServiceSpecReleaseTypePtrOutput {
	return i.ToServiceSpecReleaseTypePtrOutputWithContext(context.Background())
}

func (i ServiceSpecReleaseTypeArgs) ToServiceSpecReleaseTypePtrOutputWithContext(ctx context.Context) ServiceSpecReleaseTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecReleaseTypeOutput).ToServiceSpecReleaseTypePtrOutputWithContext(ctx)
}

// ServiceSpecReleaseTypePtrInput is an input type that accepts ServiceSpecReleaseTypeArgs, ServiceSpecReleaseTypePtr and ServiceSpecReleaseTypePtrOutput values.
// You can construct a concrete instance of `ServiceSpecReleaseTypePtrInput` via:
//
//          ServiceSpecReleaseTypeArgs{...}
//
//  or:
//
//          nil
type ServiceSpecReleaseTypePtrInput interface {
	pulumi.Input

	ToServiceSpecReleaseTypePtrOutput() ServiceSpecReleaseTypePtrOutput
	ToServiceSpecReleaseTypePtrOutputWithContext(context.Context) ServiceSpecReleaseTypePtrOutput
}

type serviceSpecReleaseTypePtrType ServiceSpecReleaseTypeArgs

func ServiceSpecReleaseTypePtr(v *ServiceSpecReleaseTypeArgs) ServiceSpecReleaseTypePtrInput {
	return (*serviceSpecReleaseTypePtrType)(v)
}

func (*serviceSpecReleaseTypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceSpecReleaseType)(nil)).Elem()
}

func (i *serviceSpecReleaseTypePtrType) ToServiceSpecReleaseTypePtrOutput() ServiceSpecReleaseTypePtrOutput {
	return i.ToServiceSpecReleaseTypePtrOutputWithContext(context.Background())
}

func (i *serviceSpecReleaseTypePtrType) ToServiceSpecReleaseTypePtrOutputWithContext(ctx context.Context) ServiceSpecReleaseTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecReleaseTypePtrOutput)
}

// ServiceSpecReleaseType contains the options for slowly releasing revisions. See ServiceSpec for more details. Not currently supported by Cloud Run.
type ServiceSpecReleaseTypeOutput struct{ *pulumi.OutputState }

func (ServiceSpecReleaseTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceSpecReleaseType)(nil)).Elem()
}

func (o ServiceSpecReleaseTypeOutput) ToServiceSpecReleaseTypeOutput() ServiceSpecReleaseTypeOutput {
	return o
}

func (o ServiceSpecReleaseTypeOutput) ToServiceSpecReleaseTypeOutputWithContext(ctx context.Context) ServiceSpecReleaseTypeOutput {
	return o
}

func (o ServiceSpecReleaseTypeOutput) ToServiceSpecReleaseTypePtrOutput() ServiceSpecReleaseTypePtrOutput {
	return o.ToServiceSpecReleaseTypePtrOutputWithContext(context.Background())
}

func (o ServiceSpecReleaseTypeOutput) ToServiceSpecReleaseTypePtrOutputWithContext(ctx context.Context) ServiceSpecReleaseTypePtrOutput {
	return o.ApplyT(func(v ServiceSpecReleaseType) *ServiceSpecReleaseType {
		return &v
	}).(ServiceSpecReleaseTypePtrOutput)
}

// The configuration for this service. All revisions from this service must come from a single configuration.
func (o ServiceSpecReleaseTypeOutput) Configuration() ConfigurationSpecPtrOutput {
	return o.ApplyT(func(v ServiceSpecReleaseType) *ConfigurationSpec { return v.Configuration }).(ConfigurationSpecPtrOutput)
}

// Revisions is an ordered list of 1 or 2 revisions. The first is the current revision, and the second is the candidate revision. If a single revision is provided, traffic will be pinned at that revision. "@latest" is a shortcut for usage that refers to the latest created revision by the configuration.
func (o ServiceSpecReleaseTypeOutput) Revisions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServiceSpecReleaseType) []string { return v.Revisions }).(pulumi.StringArrayOutput)
}

// RolloutPercent is the percent of traffic that should be sent to the candidate revision, i.e. the 2nd revision in the revisions list. Valid values are between 0 and 99 inclusive.
func (o ServiceSpecReleaseTypeOutput) RolloutPercent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceSpecReleaseType) *int { return v.RolloutPercent }).(pulumi.IntPtrOutput)
}

type ServiceSpecReleaseTypePtrOutput struct{ *pulumi.OutputState }

func (ServiceSpecReleaseTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceSpecReleaseType)(nil)).Elem()
}

func (o ServiceSpecReleaseTypePtrOutput) ToServiceSpecReleaseTypePtrOutput() ServiceSpecReleaseTypePtrOutput {
	return o
}

func (o ServiceSpecReleaseTypePtrOutput) ToServiceSpecReleaseTypePtrOutputWithContext(ctx context.Context) ServiceSpecReleaseTypePtrOutput {
	return o
}

func (o ServiceSpecReleaseTypePtrOutput) Elem() ServiceSpecReleaseTypeOutput {
	return o.ApplyT(func(v *ServiceSpecReleaseType) ServiceSpecReleaseType { return *v }).(ServiceSpecReleaseTypeOutput)
}

// The configuration for this service. All revisions from this service must come from a single configuration.
func (o ServiceSpecReleaseTypePtrOutput) Configuration() ConfigurationSpecPtrOutput {
	return o.ApplyT(func(v *ServiceSpecReleaseType) *ConfigurationSpec {
		if v == nil {
			return nil
		}
		return v.Configuration
	}).(ConfigurationSpecPtrOutput)
}

// Revisions is an ordered list of 1 or 2 revisions. The first is the current revision, and the second is the candidate revision. If a single revision is provided, traffic will be pinned at that revision. "@latest" is a shortcut for usage that refers to the latest created revision by the configuration.
func (o ServiceSpecReleaseTypePtrOutput) Revisions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServiceSpecReleaseType) []string {
		if v == nil {
			return nil
		}
		return v.Revisions
	}).(pulumi.StringArrayOutput)
}

// RolloutPercent is the percent of traffic that should be sent to the candidate revision, i.e. the 2nd revision in the revisions list. Valid values are between 0 and 99 inclusive.
func (o ServiceSpecReleaseTypePtrOutput) RolloutPercent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceSpecReleaseType) *int {
		if v == nil {
			return nil
		}
		return v.RolloutPercent
	}).(pulumi.IntPtrOutput)
}

// ServiceSpecRunLatest contains the options for always having a route to the latest configuration. See ServiceSpec for more details.
type ServiceSpecRunLatest struct {
	// The configuration for this service.
	Configuration *ConfigurationSpec `pulumi:"configuration"`
}

// ServiceSpecRunLatestInput is an input type that accepts ServiceSpecRunLatestArgs and ServiceSpecRunLatestOutput values.
// You can construct a concrete instance of `ServiceSpecRunLatestInput` via:
//
//          ServiceSpecRunLatestArgs{...}
type ServiceSpecRunLatestInput interface {
	pulumi.Input

	ToServiceSpecRunLatestOutput() ServiceSpecRunLatestOutput
	ToServiceSpecRunLatestOutputWithContext(context.Context) ServiceSpecRunLatestOutput
}

// ServiceSpecRunLatest contains the options for always having a route to the latest configuration. See ServiceSpec for more details.
type ServiceSpecRunLatestArgs struct {
	// The configuration for this service.
	Configuration ConfigurationSpecPtrInput `pulumi:"configuration"`
}

func (ServiceSpecRunLatestArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceSpecRunLatest)(nil)).Elem()
}

func (i ServiceSpecRunLatestArgs) ToServiceSpecRunLatestOutput() ServiceSpecRunLatestOutput {
	return i.ToServiceSpecRunLatestOutputWithContext(context.Background())
}

func (i ServiceSpecRunLatestArgs) ToServiceSpecRunLatestOutputWithContext(ctx context.Context) ServiceSpecRunLatestOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecRunLatestOutput)
}

func (i ServiceSpecRunLatestArgs) ToServiceSpecRunLatestPtrOutput() ServiceSpecRunLatestPtrOutput {
	return i.ToServiceSpecRunLatestPtrOutputWithContext(context.Background())
}

func (i ServiceSpecRunLatestArgs) ToServiceSpecRunLatestPtrOutputWithContext(ctx context.Context) ServiceSpecRunLatestPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecRunLatestOutput).ToServiceSpecRunLatestPtrOutputWithContext(ctx)
}

// ServiceSpecRunLatestPtrInput is an input type that accepts ServiceSpecRunLatestArgs, ServiceSpecRunLatestPtr and ServiceSpecRunLatestPtrOutput values.
// You can construct a concrete instance of `ServiceSpecRunLatestPtrInput` via:
//
//          ServiceSpecRunLatestArgs{...}
//
//  or:
//
//          nil
type ServiceSpecRunLatestPtrInput interface {
	pulumi.Input

	ToServiceSpecRunLatestPtrOutput() ServiceSpecRunLatestPtrOutput
	ToServiceSpecRunLatestPtrOutputWithContext(context.Context) ServiceSpecRunLatestPtrOutput
}

type serviceSpecRunLatestPtrType ServiceSpecRunLatestArgs

func ServiceSpecRunLatestPtr(v *ServiceSpecRunLatestArgs) ServiceSpecRunLatestPtrInput {
	return (*serviceSpecRunLatestPtrType)(v)
}

func (*serviceSpecRunLatestPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceSpecRunLatest)(nil)).Elem()
}

func (i *serviceSpecRunLatestPtrType) ToServiceSpecRunLatestPtrOutput() ServiceSpecRunLatestPtrOutput {
	return i.ToServiceSpecRunLatestPtrOutputWithContext(context.Background())
}

func (i *serviceSpecRunLatestPtrType) ToServiceSpecRunLatestPtrOutputWithContext(ctx context.Context) ServiceSpecRunLatestPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceSpecRunLatestPtrOutput)
}

// ServiceSpecRunLatest contains the options for always having a route to the latest configuration. See ServiceSpec for more details.
type ServiceSpecRunLatestOutput struct{ *pulumi.OutputState }

func (ServiceSpecRunLatestOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceSpecRunLatest)(nil)).Elem()
}

func (o ServiceSpecRunLatestOutput) ToServiceSpecRunLatestOutput() ServiceSpecRunLatestOutput {
	return o
}

func (o ServiceSpecRunLatestOutput) ToServiceSpecRunLatestOutputWithContext(ctx context.Context) ServiceSpecRunLatestOutput {
	return o
}

func (o ServiceSpecRunLatestOutput) ToServiceSpecRunLatestPtrOutput() ServiceSpecRunLatestPtrOutput {
	return o.ToServiceSpecRunLatestPtrOutputWithContext(context.Background())
}

func (o ServiceSpecRunLatestOutput) ToServiceSpecRunLatestPtrOutputWithContext(ctx context.Context) ServiceSpecRunLatestPtrOutput {
	return o.ApplyT(func(v ServiceSpecRunLatest) *ServiceSpecRunLatest {
		return &v
	}).(ServiceSpecRunLatestPtrOutput)
}

// The configuration for this service.
func (o ServiceSpecRunLatestOutput) Configuration() ConfigurationSpecPtrOutput {
	return o.ApplyT(func(v ServiceSpecRunLatest) *ConfigurationSpec { return v.Configuration }).(ConfigurationSpecPtrOutput)
}

type ServiceSpecRunLatestPtrOutput struct{ *pulumi.OutputState }

func (ServiceSpecRunLatestPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceSpecRunLatest)(nil)).Elem()
}

func (o ServiceSpecRunLatestPtrOutput) ToServiceSpecRunLatestPtrOutput() ServiceSpecRunLatestPtrOutput {
	return o
}

func (o ServiceSpecRunLatestPtrOutput) ToServiceSpecRunLatestPtrOutputWithContext(ctx context.Context) ServiceSpecRunLatestPtrOutput {
	return o
}

func (o ServiceSpecRunLatestPtrOutput) Elem() ServiceSpecRunLatestOutput {
	return o.ApplyT(func(v *ServiceSpecRunLatest) ServiceSpecRunLatest { return *v }).(ServiceSpecRunLatestOutput)
}

// The configuration for this service.
func (o ServiceSpecRunLatestPtrOutput) Configuration() ConfigurationSpecPtrOutput {
	return o.ApplyT(func(v *ServiceSpecRunLatest) *ConfigurationSpec {
		if v == nil {
			return nil
		}
		return v.Configuration
	}).(ConfigurationSpecPtrOutput)
}

// The current state of the Service. Output only.
type ServiceStatus struct {
	// From RouteStatus. Similar to url, information on where the service is available on HTTP.
	Address *Addressable `pulumi:"address"`
	// Conditions communicates information about ongoing/complete reconciliation processes that bring the "spec" inline with the observed state of the world.
	Conditions []ServiceCondition `pulumi:"conditions"`
	// From RouteStatus. Domain holds the top-level domain that will distribute traffic over the provided targets. It generally has the form https://{route-hash}-{project-hash}-{cluster-level-suffix}.a.run.app
	Domain *string `pulumi:"domain"`
	// From ConfigurationStatus. LatestCreatedRevisionName is the last revision that was created from this Service's Configuration. It might not be ready yet, for that use LatestReadyRevisionName.
	LatestCreatedRevisionName *string `pulumi:"latestCreatedRevisionName"`
	// From ConfigurationStatus. LatestReadyRevisionName holds the name of the latest Revision stamped out from this Service's Configuration that has had its "Ready" condition become "True".
	LatestReadyRevisionName *string `pulumi:"latestReadyRevisionName"`
	// ObservedGeneration is the 'Generation' of the Route that was last processed by the controller. Clients polling for completed reconciliation should poll until observedGeneration = metadata.generation and the Ready condition's status is True or False.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// From RouteStatus. Traffic holds the configured traffic distribution. These entries will always contain RevisionName references. When ConfigurationName appears in the spec, this will hold the LatestReadyRevisionName that we last observed.
	Traffic []TrafficTarget `pulumi:"traffic"`
	// From RouteStatus. URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form https://{route-hash}-{project-hash}-{cluster-level-suffix}.a.run.app
	Url *string `pulumi:"url"`
}

// ServiceStatusInput is an input type that accepts ServiceStatusArgs and ServiceStatusOutput values.
// You can construct a concrete instance of `ServiceStatusInput` via:
//
//          ServiceStatusArgs{...}
type ServiceStatusInput interface {
	pulumi.Input

	ToServiceStatusOutput() ServiceStatusOutput
	ToServiceStatusOutputWithContext(context.Context) ServiceStatusOutput
}

// The current state of the Service. Output only.
type ServiceStatusArgs struct {
	// From RouteStatus. Similar to url, information on where the service is available on HTTP.
	Address AddressablePtrInput `pulumi:"address"`
	// Conditions communicates information about ongoing/complete reconciliation processes that bring the "spec" inline with the observed state of the world.
	Conditions ServiceConditionArrayInput `pulumi:"conditions"`
	// From RouteStatus. Domain holds the top-level domain that will distribute traffic over the provided targets. It generally has the form https://{route-hash}-{project-hash}-{cluster-level-suffix}.a.run.app
	Domain pulumi.StringPtrInput `pulumi:"domain"`
	// From ConfigurationStatus. LatestCreatedRevisionName is the last revision that was created from this Service's Configuration. It might not be ready yet, for that use LatestReadyRevisionName.
	LatestCreatedRevisionName pulumi.StringPtrInput `pulumi:"latestCreatedRevisionName"`
	// From ConfigurationStatus. LatestReadyRevisionName holds the name of the latest Revision stamped out from this Service's Configuration that has had its "Ready" condition become "True".
	LatestReadyRevisionName pulumi.StringPtrInput `pulumi:"latestReadyRevisionName"`
	// ObservedGeneration is the 'Generation' of the Route that was last processed by the controller. Clients polling for completed reconciliation should poll until observedGeneration = metadata.generation and the Ready condition's status is True or False.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// From RouteStatus. Traffic holds the configured traffic distribution. These entries will always contain RevisionName references. When ConfigurationName appears in the spec, this will hold the LatestReadyRevisionName that we last observed.
	Traffic TrafficTargetArrayInput `pulumi:"traffic"`
	// From RouteStatus. URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form https://{route-hash}-{project-hash}-{cluster-level-suffix}.a.run.app
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (ServiceStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceStatus)(nil)).Elem()
}

func (i ServiceStatusArgs) ToServiceStatusOutput() ServiceStatusOutput {
	return i.ToServiceStatusOutputWithContext(context.Background())
}

func (i ServiceStatusArgs) ToServiceStatusOutputWithContext(ctx context.Context) ServiceStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceStatusOutput)
}

func (i ServiceStatusArgs) ToServiceStatusPtrOutput() ServiceStatusPtrOutput {
	return i.ToServiceStatusPtrOutputWithContext(context.Background())
}

func (i ServiceStatusArgs) ToServiceStatusPtrOutputWithContext(ctx context.Context) ServiceStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceStatusOutput).ToServiceStatusPtrOutputWithContext(ctx)
}

// ServiceStatusPtrInput is an input type that accepts ServiceStatusArgs, ServiceStatusPtr and ServiceStatusPtrOutput values.
// You can construct a concrete instance of `ServiceStatusPtrInput` via:
//
//          ServiceStatusArgs{...}
//
//  or:
//
//          nil
type ServiceStatusPtrInput interface {
	pulumi.Input

	ToServiceStatusPtrOutput() ServiceStatusPtrOutput
	ToServiceStatusPtrOutputWithContext(context.Context) ServiceStatusPtrOutput
}

type serviceStatusPtrType ServiceStatusArgs

func ServiceStatusPtr(v *ServiceStatusArgs) ServiceStatusPtrInput {
	return (*serviceStatusPtrType)(v)
}

func (*serviceStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceStatus)(nil)).Elem()
}

func (i *serviceStatusPtrType) ToServiceStatusPtrOutput() ServiceStatusPtrOutput {
	return i.ToServiceStatusPtrOutputWithContext(context.Background())
}

func (i *serviceStatusPtrType) ToServiceStatusPtrOutputWithContext(ctx context.Context) ServiceStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceStatusPtrOutput)
}

// The current state of the Service. Output only.
type ServiceStatusOutput struct{ *pulumi.OutputState }

func (ServiceStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceStatus)(nil)).Elem()
}

func (o ServiceStatusOutput) ToServiceStatusOutput() ServiceStatusOutput {
	return o
}

func (o ServiceStatusOutput) ToServiceStatusOutputWithContext(ctx context.Context) ServiceStatusOutput {
	return o
}

func (o ServiceStatusOutput) ToServiceStatusPtrOutput() ServiceStatusPtrOutput {
	return o.ToServiceStatusPtrOutputWithContext(context.Background())
}

func (o ServiceStatusOutput) ToServiceStatusPtrOutputWithContext(ctx context.Context) ServiceStatusPtrOutput {
	return o.ApplyT(func(v ServiceStatus) *ServiceStatus {
		return &v
	}).(ServiceStatusPtrOutput)
}

// From RouteStatus. Similar to url, information on where the service is available on HTTP.
func (o ServiceStatusOutput) Address() AddressablePtrOutput {
	return o.ApplyT(func(v ServiceStatus) *Addressable { return v.Address }).(AddressablePtrOutput)
}

// Conditions communicates information about ongoing/complete reconciliation processes that bring the "spec" inline with the observed state of the world.
func (o ServiceStatusOutput) Conditions() ServiceConditionArrayOutput {
	return o.ApplyT(func(v ServiceStatus) []ServiceCondition { return v.Conditions }).(ServiceConditionArrayOutput)
}

// From RouteStatus. Domain holds the top-level domain that will distribute traffic over the provided targets. It generally has the form https://{route-hash}-{project-hash}-{cluster-level-suffix}.a.run.app
func (o ServiceStatusOutput) Domain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceStatus) *string { return v.Domain }).(pulumi.StringPtrOutput)
}

// From ConfigurationStatus. LatestCreatedRevisionName is the last revision that was created from this Service's Configuration. It might not be ready yet, for that use LatestReadyRevisionName.
func (o ServiceStatusOutput) LatestCreatedRevisionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceStatus) *string { return v.LatestCreatedRevisionName }).(pulumi.StringPtrOutput)
}

// From ConfigurationStatus. LatestReadyRevisionName holds the name of the latest Revision stamped out from this Service's Configuration that has had its "Ready" condition become "True".
func (o ServiceStatusOutput) LatestReadyRevisionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceStatus) *string { return v.LatestReadyRevisionName }).(pulumi.StringPtrOutput)
}

// ObservedGeneration is the 'Generation' of the Route that was last processed by the controller. Clients polling for completed reconciliation should poll until observedGeneration = metadata.generation and the Ready condition's status is True or False.
func (o ServiceStatusOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ServiceStatus) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// From RouteStatus. Traffic holds the configured traffic distribution. These entries will always contain RevisionName references. When ConfigurationName appears in the spec, this will hold the LatestReadyRevisionName that we last observed.
func (o ServiceStatusOutput) Traffic() TrafficTargetArrayOutput {
	return o.ApplyT(func(v ServiceStatus) []TrafficTarget { return v.Traffic }).(TrafficTargetArrayOutput)
}

// From RouteStatus. URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form https://{route-hash}-{project-hash}-{cluster-level-suffix}.a.run.app
func (o ServiceStatusOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ServiceStatus) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type ServiceStatusPtrOutput struct{ *pulumi.OutputState }

func (ServiceStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceStatus)(nil)).Elem()
}

func (o ServiceStatusPtrOutput) ToServiceStatusPtrOutput() ServiceStatusPtrOutput {
	return o
}

func (o ServiceStatusPtrOutput) ToServiceStatusPtrOutputWithContext(ctx context.Context) ServiceStatusPtrOutput {
	return o
}

func (o ServiceStatusPtrOutput) Elem() ServiceStatusOutput {
	return o.ApplyT(func(v *ServiceStatus) ServiceStatus { return *v }).(ServiceStatusOutput)
}

// From RouteStatus. Similar to url, information on where the service is available on HTTP.
func (o ServiceStatusPtrOutput) Address() AddressablePtrOutput {
	return o.ApplyT(func(v *ServiceStatus) *Addressable {
		if v == nil {
			return nil
		}
		return v.Address
	}).(AddressablePtrOutput)
}

// Conditions communicates information about ongoing/complete reconciliation processes that bring the "spec" inline with the observed state of the world.
func (o ServiceStatusPtrOutput) Conditions() ServiceConditionArrayOutput {
	return o.ApplyT(func(v *ServiceStatus) []ServiceCondition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(ServiceConditionArrayOutput)
}

// From RouteStatus. Domain holds the top-level domain that will distribute traffic over the provided targets. It generally has the form https://{route-hash}-{project-hash}-{cluster-level-suffix}.a.run.app
func (o ServiceStatusPtrOutput) Domain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceStatus) *string {
		if v == nil {
			return nil
		}
		return v.Domain
	}).(pulumi.StringPtrOutput)
}

// From ConfigurationStatus. LatestCreatedRevisionName is the last revision that was created from this Service's Configuration. It might not be ready yet, for that use LatestReadyRevisionName.
func (o ServiceStatusPtrOutput) LatestCreatedRevisionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceStatus) *string {
		if v == nil {
			return nil
		}
		return v.LatestCreatedRevisionName
	}).(pulumi.StringPtrOutput)
}

// From ConfigurationStatus. LatestReadyRevisionName holds the name of the latest Revision stamped out from this Service's Configuration that has had its "Ready" condition become "True".
func (o ServiceStatusPtrOutput) LatestReadyRevisionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceStatus) *string {
		if v == nil {
			return nil
		}
		return v.LatestReadyRevisionName
	}).(pulumi.StringPtrOutput)
}

// ObservedGeneration is the 'Generation' of the Route that was last processed by the controller. Clients polling for completed reconciliation should poll until observedGeneration = metadata.generation and the Ready condition's status is True or False.
func (o ServiceStatusPtrOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ServiceStatus) *int {
		if v == nil {
			return nil
		}
		return v.ObservedGeneration
	}).(pulumi.IntPtrOutput)
}

// From RouteStatus. Traffic holds the configured traffic distribution. These entries will always contain RevisionName references. When ConfigurationName appears in the spec, this will hold the LatestReadyRevisionName that we last observed.
func (o ServiceStatusPtrOutput) Traffic() TrafficTargetArrayOutput {
	return o.ApplyT(func(v *ServiceStatus) []TrafficTarget {
		if v == nil {
			return nil
		}
		return v.Traffic
	}).(TrafficTargetArrayOutput)
}

// From RouteStatus. URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form https://{route-hash}-{project-hash}-{cluster-level-suffix}.a.run.app
func (o ServiceStatusPtrOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ServiceStatus) *string {
		if v == nil {
			return nil
		}
		return v.Url
	}).(pulumi.StringPtrOutput)
}

// TCPSocketAction describes an action based on opening a socket
type TCPSocketAction struct {
	// Optional: Host name to connect to, defaults to the pod IP. +optional
	Host *string `pulumi:"host"`
	// Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	Port *IntOrString `pulumi:"port"`
}

// TCPSocketActionInput is an input type that accepts TCPSocketActionArgs and TCPSocketActionOutput values.
// You can construct a concrete instance of `TCPSocketActionInput` via:
//
//          TCPSocketActionArgs{...}
type TCPSocketActionInput interface {
	pulumi.Input

	ToTCPSocketActionOutput() TCPSocketActionOutput
	ToTCPSocketActionOutputWithContext(context.Context) TCPSocketActionOutput
}

// TCPSocketAction describes an action based on opening a socket
type TCPSocketActionArgs struct {
	// Optional: Host name to connect to, defaults to the pod IP. +optional
	Host pulumi.StringPtrInput `pulumi:"host"`
	// Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	Port IntOrStringPtrInput `pulumi:"port"`
}

func (TCPSocketActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPSocketAction)(nil)).Elem()
}

func (i TCPSocketActionArgs) ToTCPSocketActionOutput() TCPSocketActionOutput {
	return i.ToTCPSocketActionOutputWithContext(context.Background())
}

func (i TCPSocketActionArgs) ToTCPSocketActionOutputWithContext(ctx context.Context) TCPSocketActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPSocketActionOutput)
}

func (i TCPSocketActionArgs) ToTCPSocketActionPtrOutput() TCPSocketActionPtrOutput {
	return i.ToTCPSocketActionPtrOutputWithContext(context.Background())
}

func (i TCPSocketActionArgs) ToTCPSocketActionPtrOutputWithContext(ctx context.Context) TCPSocketActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPSocketActionOutput).ToTCPSocketActionPtrOutputWithContext(ctx)
}

// TCPSocketActionPtrInput is an input type that accepts TCPSocketActionArgs, TCPSocketActionPtr and TCPSocketActionPtrOutput values.
// You can construct a concrete instance of `TCPSocketActionPtrInput` via:
//
//          TCPSocketActionArgs{...}
//
//  or:
//
//          nil
type TCPSocketActionPtrInput interface {
	pulumi.Input

	ToTCPSocketActionPtrOutput() TCPSocketActionPtrOutput
	ToTCPSocketActionPtrOutputWithContext(context.Context) TCPSocketActionPtrOutput
}

type tcpsocketActionPtrType TCPSocketActionArgs

func TCPSocketActionPtr(v *TCPSocketActionArgs) TCPSocketActionPtrInput {
	return (*tcpsocketActionPtrType)(v)
}

func (*tcpsocketActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPSocketAction)(nil)).Elem()
}

func (i *tcpsocketActionPtrType) ToTCPSocketActionPtrOutput() TCPSocketActionPtrOutput {
	return i.ToTCPSocketActionPtrOutputWithContext(context.Background())
}

func (i *tcpsocketActionPtrType) ToTCPSocketActionPtrOutputWithContext(ctx context.Context) TCPSocketActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPSocketActionPtrOutput)
}

// TCPSocketAction describes an action based on opening a socket
type TCPSocketActionOutput struct{ *pulumi.OutputState }

func (TCPSocketActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPSocketAction)(nil)).Elem()
}

func (o TCPSocketActionOutput) ToTCPSocketActionOutput() TCPSocketActionOutput {
	return o
}

func (o TCPSocketActionOutput) ToTCPSocketActionOutputWithContext(ctx context.Context) TCPSocketActionOutput {
	return o
}

func (o TCPSocketActionOutput) ToTCPSocketActionPtrOutput() TCPSocketActionPtrOutput {
	return o.ToTCPSocketActionPtrOutputWithContext(context.Background())
}

func (o TCPSocketActionOutput) ToTCPSocketActionPtrOutputWithContext(ctx context.Context) TCPSocketActionPtrOutput {
	return o.ApplyT(func(v TCPSocketAction) *TCPSocketAction {
		return &v
	}).(TCPSocketActionPtrOutput)
}

// Optional: Host name to connect to, defaults to the pod IP. +optional
func (o TCPSocketActionOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPSocketAction) *string { return v.Host }).(pulumi.StringPtrOutput)
}

// Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
func (o TCPSocketActionOutput) Port() IntOrStringPtrOutput {
	return o.ApplyT(func(v TCPSocketAction) *IntOrString { return v.Port }).(IntOrStringPtrOutput)
}

type TCPSocketActionPtrOutput struct{ *pulumi.OutputState }

func (TCPSocketActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPSocketAction)(nil)).Elem()
}

func (o TCPSocketActionPtrOutput) ToTCPSocketActionPtrOutput() TCPSocketActionPtrOutput {
	return o
}

func (o TCPSocketActionPtrOutput) ToTCPSocketActionPtrOutputWithContext(ctx context.Context) TCPSocketActionPtrOutput {
	return o
}

func (o TCPSocketActionPtrOutput) Elem() TCPSocketActionOutput {
	return o.ApplyT(func(v *TCPSocketAction) TCPSocketAction { return *v }).(TCPSocketActionOutput)
}

// Optional: Host name to connect to, defaults to the pod IP. +optional
func (o TCPSocketActionPtrOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TCPSocketAction) *string {
		if v == nil {
			return nil
		}
		return v.Host
	}).(pulumi.StringPtrOutput)
}

// Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
func (o TCPSocketActionPtrOutput) Port() IntOrStringPtrOutput {
	return o.ApplyT(func(v *TCPSocketAction) *IntOrString {
		if v == nil {
			return nil
		}
		return v.Port
	}).(IntOrStringPtrOutput)
}

// TrafficTarget holds a single entry of the routing table for a Route.
type TrafficTarget struct {
	// ConfigurationName of a configuration to whose latest revision we will send this portion of traffic. When the "status.latestReadyRevisionName" of the referenced configuration changes, we will automatically migrate traffic from the prior "latest ready" revision to the new one. This field is never set in Route's status, only its spec. This is mutually exclusive with RevisionName. Cloud Run currently supports a single ConfigurationName.
	ConfigurationName *string `pulumi:"configurationName"`
	// LatestRevision may be optionally provided to indicate that the latest ready Revision of the Configuration should be used for this traffic target. When provided LatestRevision must be true if RevisionName is empty; it must be false when RevisionName is non-empty. +optional
	LatestRevision *bool `pulumi:"latestRevision"`
	// Name is optionally used to expose a dedicated hostname for referencing this target exclusively. Not currently supported by Cloud Run. +optional
	Name *string `pulumi:"name"`
	// Percent specifies percent of the traffic to this Revision or Configuration. This defaults to zero if unspecified. Cloud Run currently requires 100 percent for a single ConfigurationName TrafficTarget entry.
	Percent *int `pulumi:"percent"`
	// RevisionName of a specific revision to which to send this portion of traffic. This is mutually exclusive with ConfigurationName. Providing RevisionName in spec is not currently supported by Cloud Run.
	RevisionName *string `pulumi:"revisionName"`
	// Tag is optionally used to expose a dedicated url for referencing this target exclusively. Not currently supported in Cloud Run. +optional
	Tag *string `pulumi:"tag"`
	// Output only. URL displays the URL for accessing named traffic targets. URL is displayed in status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and a hostname, but may not contain anything else (e.g. basic auth, url path, etc. Not currently supported in Cloud Run.
	Url *string `pulumi:"url"`
}

// TrafficTargetInput is an input type that accepts TrafficTargetArgs and TrafficTargetOutput values.
// You can construct a concrete instance of `TrafficTargetInput` via:
//
//          TrafficTargetArgs{...}
type TrafficTargetInput interface {
	pulumi.Input

	ToTrafficTargetOutput() TrafficTargetOutput
	ToTrafficTargetOutputWithContext(context.Context) TrafficTargetOutput
}

// TrafficTarget holds a single entry of the routing table for a Route.
type TrafficTargetArgs struct {
	// ConfigurationName of a configuration to whose latest revision we will send this portion of traffic. When the "status.latestReadyRevisionName" of the referenced configuration changes, we will automatically migrate traffic from the prior "latest ready" revision to the new one. This field is never set in Route's status, only its spec. This is mutually exclusive with RevisionName. Cloud Run currently supports a single ConfigurationName.
	ConfigurationName pulumi.StringPtrInput `pulumi:"configurationName"`
	// LatestRevision may be optionally provided to indicate that the latest ready Revision of the Configuration should be used for this traffic target. When provided LatestRevision must be true if RevisionName is empty; it must be false when RevisionName is non-empty. +optional
	LatestRevision pulumi.BoolPtrInput `pulumi:"latestRevision"`
	// Name is optionally used to expose a dedicated hostname for referencing this target exclusively. Not currently supported by Cloud Run. +optional
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Percent specifies percent of the traffic to this Revision or Configuration. This defaults to zero if unspecified. Cloud Run currently requires 100 percent for a single ConfigurationName TrafficTarget entry.
	Percent pulumi.IntPtrInput `pulumi:"percent"`
	// RevisionName of a specific revision to which to send this portion of traffic. This is mutually exclusive with ConfigurationName. Providing RevisionName in spec is not currently supported by Cloud Run.
	RevisionName pulumi.StringPtrInput `pulumi:"revisionName"`
	// Tag is optionally used to expose a dedicated url for referencing this target exclusively. Not currently supported in Cloud Run. +optional
	Tag pulumi.StringPtrInput `pulumi:"tag"`
	// Output only. URL displays the URL for accessing named traffic targets. URL is displayed in status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and a hostname, but may not contain anything else (e.g. basic auth, url path, etc. Not currently supported in Cloud Run.
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (TrafficTargetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TrafficTarget)(nil)).Elem()
}

func (i TrafficTargetArgs) ToTrafficTargetOutput() TrafficTargetOutput {
	return i.ToTrafficTargetOutputWithContext(context.Background())
}

func (i TrafficTargetArgs) ToTrafficTargetOutputWithContext(ctx context.Context) TrafficTargetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrafficTargetOutput)
}

// TrafficTargetArrayInput is an input type that accepts TrafficTargetArray and TrafficTargetArrayOutput values.
// You can construct a concrete instance of `TrafficTargetArrayInput` via:
//
//          TrafficTargetArray{ TrafficTargetArgs{...} }
type TrafficTargetArrayInput interface {
	pulumi.Input

	ToTrafficTargetArrayOutput() TrafficTargetArrayOutput
	ToTrafficTargetArrayOutputWithContext(context.Context) TrafficTargetArrayOutput
}

type TrafficTargetArray []TrafficTargetInput

func (TrafficTargetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TrafficTarget)(nil)).Elem()
}

func (i TrafficTargetArray) ToTrafficTargetArrayOutput() TrafficTargetArrayOutput {
	return i.ToTrafficTargetArrayOutputWithContext(context.Background())
}

func (i TrafficTargetArray) ToTrafficTargetArrayOutputWithContext(ctx context.Context) TrafficTargetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrafficTargetArrayOutput)
}

// TrafficTarget holds a single entry of the routing table for a Route.
type TrafficTargetOutput struct{ *pulumi.OutputState }

func (TrafficTargetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TrafficTarget)(nil)).Elem()
}

func (o TrafficTargetOutput) ToTrafficTargetOutput() TrafficTargetOutput {
	return o
}

func (o TrafficTargetOutput) ToTrafficTargetOutputWithContext(ctx context.Context) TrafficTargetOutput {
	return o
}

// ConfigurationName of a configuration to whose latest revision we will send this portion of traffic. When the "status.latestReadyRevisionName" of the referenced configuration changes, we will automatically migrate traffic from the prior "latest ready" revision to the new one. This field is never set in Route's status, only its spec. This is mutually exclusive with RevisionName. Cloud Run currently supports a single ConfigurationName.
func (o TrafficTargetOutput) ConfigurationName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TrafficTarget) *string { return v.ConfigurationName }).(pulumi.StringPtrOutput)
}

// LatestRevision may be optionally provided to indicate that the latest ready Revision of the Configuration should be used for this traffic target. When provided LatestRevision must be true if RevisionName is empty; it must be false when RevisionName is non-empty. +optional
func (o TrafficTargetOutput) LatestRevision() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v TrafficTarget) *bool { return v.LatestRevision }).(pulumi.BoolPtrOutput)
}

// Name is optionally used to expose a dedicated hostname for referencing this target exclusively. Not currently supported by Cloud Run. +optional
func (o TrafficTargetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TrafficTarget) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Percent specifies percent of the traffic to this Revision or Configuration. This defaults to zero if unspecified. Cloud Run currently requires 100 percent for a single ConfigurationName TrafficTarget entry.
func (o TrafficTargetOutput) Percent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TrafficTarget) *int { return v.Percent }).(pulumi.IntPtrOutput)
}

// RevisionName of a specific revision to which to send this portion of traffic. This is mutually exclusive with ConfigurationName. Providing RevisionName in spec is not currently supported by Cloud Run.
func (o TrafficTargetOutput) RevisionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TrafficTarget) *string { return v.RevisionName }).(pulumi.StringPtrOutput)
}

// Tag is optionally used to expose a dedicated url for referencing this target exclusively. Not currently supported in Cloud Run. +optional
func (o TrafficTargetOutput) Tag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TrafficTarget) *string { return v.Tag }).(pulumi.StringPtrOutput)
}

// Output only. URL displays the URL for accessing named traffic targets. URL is displayed in status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and a hostname, but may not contain anything else (e.g. basic auth, url path, etc. Not currently supported in Cloud Run.
func (o TrafficTargetOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TrafficTarget) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type TrafficTargetArrayOutput struct{ *pulumi.OutputState }

func (TrafficTargetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TrafficTarget)(nil)).Elem()
}

func (o TrafficTargetArrayOutput) ToTrafficTargetArrayOutput() TrafficTargetArrayOutput {
	return o
}

func (o TrafficTargetArrayOutput) ToTrafficTargetArrayOutputWithContext(ctx context.Context) TrafficTargetArrayOutput {
	return o
}

func (o TrafficTargetArrayOutput) Index(i pulumi.IntInput) TrafficTargetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TrafficTarget {
		return vs[0].([]TrafficTarget)[vs[1].(int)]
	}).(TrafficTargetOutput)
}

// Volume represents a named volume in a container.
type Volume struct {
	ConfigMap *ConfigMapVolumeSource `pulumi:"configMap"`
	// Volume's name.
	Name   *string             `pulumi:"name"`
	Secret *SecretVolumeSource `pulumi:"secret"`
}

// VolumeInput is an input type that accepts VolumeArgs and VolumeOutput values.
// You can construct a concrete instance of `VolumeInput` via:
//
//          VolumeArgs{...}
type VolumeInput interface {
	pulumi.Input

	ToVolumeOutput() VolumeOutput
	ToVolumeOutputWithContext(context.Context) VolumeOutput
}

// Volume represents a named volume in a container.
type VolumeArgs struct {
	ConfigMap ConfigMapVolumeSourcePtrInput `pulumi:"configMap"`
	// Volume's name.
	Name   pulumi.StringPtrInput      `pulumi:"name"`
	Secret SecretVolumeSourcePtrInput `pulumi:"secret"`
}

func (VolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Volume)(nil)).Elem()
}

func (i VolumeArgs) ToVolumeOutput() VolumeOutput {
	return i.ToVolumeOutputWithContext(context.Background())
}

func (i VolumeArgs) ToVolumeOutputWithContext(ctx context.Context) VolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeOutput)
}

// VolumeArrayInput is an input type that accepts VolumeArray and VolumeArrayOutput values.
// You can construct a concrete instance of `VolumeArrayInput` via:
//
//          VolumeArray{ VolumeArgs{...} }
type VolumeArrayInput interface {
	pulumi.Input

	ToVolumeArrayOutput() VolumeArrayOutput
	ToVolumeArrayOutputWithContext(context.Context) VolumeArrayOutput
}

type VolumeArray []VolumeInput

func (VolumeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Volume)(nil)).Elem()
}

func (i VolumeArray) ToVolumeArrayOutput() VolumeArrayOutput {
	return i.ToVolumeArrayOutputWithContext(context.Background())
}

func (i VolumeArray) ToVolumeArrayOutputWithContext(ctx context.Context) VolumeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeArrayOutput)
}

// Volume represents a named volume in a container.
type VolumeOutput struct{ *pulumi.OutputState }

func (VolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Volume)(nil)).Elem()
}

func (o VolumeOutput) ToVolumeOutput() VolumeOutput {
	return o
}

func (o VolumeOutput) ToVolumeOutputWithContext(ctx context.Context) VolumeOutput {
	return o
}

func (o VolumeOutput) ConfigMap() ConfigMapVolumeSourcePtrOutput {
	return o.ApplyT(func(v Volume) *ConfigMapVolumeSource { return v.ConfigMap }).(ConfigMapVolumeSourcePtrOutput)
}

// Volume's name.
func (o VolumeOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Volume) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o VolumeOutput) Secret() SecretVolumeSourcePtrOutput {
	return o.ApplyT(func(v Volume) *SecretVolumeSource { return v.Secret }).(SecretVolumeSourcePtrOutput)
}

type VolumeArrayOutput struct{ *pulumi.OutputState }

func (VolumeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Volume)(nil)).Elem()
}

func (o VolumeArrayOutput) ToVolumeArrayOutput() VolumeArrayOutput {
	return o
}

func (o VolumeArrayOutput) ToVolumeArrayOutputWithContext(ctx context.Context) VolumeArrayOutput {
	return o
}

func (o VolumeArrayOutput) Index(i pulumi.IntInput) VolumeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Volume {
		return vs[0].([]Volume)[vs[1].(int)]
	}).(VolumeOutput)
}

// volumeDevice describes a mapping of a raw block device within a container.
type VolumeDevice struct {
	// devicePath is the path inside of the container that the device will be mapped to.
	DevicePath *string `pulumi:"devicePath"`
	// name must match the name of a persistentVolumeClaim in the pod
	Name *string `pulumi:"name"`
}

// VolumeDeviceInput is an input type that accepts VolumeDeviceArgs and VolumeDeviceOutput values.
// You can construct a concrete instance of `VolumeDeviceInput` via:
//
//          VolumeDeviceArgs{...}
type VolumeDeviceInput interface {
	pulumi.Input

	ToVolumeDeviceOutput() VolumeDeviceOutput
	ToVolumeDeviceOutputWithContext(context.Context) VolumeDeviceOutput
}

// volumeDevice describes a mapping of a raw block device within a container.
type VolumeDeviceArgs struct {
	// devicePath is the path inside of the container that the device will be mapped to.
	DevicePath pulumi.StringPtrInput `pulumi:"devicePath"`
	// name must match the name of a persistentVolumeClaim in the pod
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (VolumeDeviceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VolumeDevice)(nil)).Elem()
}

func (i VolumeDeviceArgs) ToVolumeDeviceOutput() VolumeDeviceOutput {
	return i.ToVolumeDeviceOutputWithContext(context.Background())
}

func (i VolumeDeviceArgs) ToVolumeDeviceOutputWithContext(ctx context.Context) VolumeDeviceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeDeviceOutput)
}

// VolumeDeviceArrayInput is an input type that accepts VolumeDeviceArray and VolumeDeviceArrayOutput values.
// You can construct a concrete instance of `VolumeDeviceArrayInput` via:
//
//          VolumeDeviceArray{ VolumeDeviceArgs{...} }
type VolumeDeviceArrayInput interface {
	pulumi.Input

	ToVolumeDeviceArrayOutput() VolumeDeviceArrayOutput
	ToVolumeDeviceArrayOutputWithContext(context.Context) VolumeDeviceArrayOutput
}

type VolumeDeviceArray []VolumeDeviceInput

func (VolumeDeviceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VolumeDevice)(nil)).Elem()
}

func (i VolumeDeviceArray) ToVolumeDeviceArrayOutput() VolumeDeviceArrayOutput {
	return i.ToVolumeDeviceArrayOutputWithContext(context.Background())
}

func (i VolumeDeviceArray) ToVolumeDeviceArrayOutputWithContext(ctx context.Context) VolumeDeviceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeDeviceArrayOutput)
}

// volumeDevice describes a mapping of a raw block device within a container.
type VolumeDeviceOutput struct{ *pulumi.OutputState }

func (VolumeDeviceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VolumeDevice)(nil)).Elem()
}

func (o VolumeDeviceOutput) ToVolumeDeviceOutput() VolumeDeviceOutput {
	return o
}

func (o VolumeDeviceOutput) ToVolumeDeviceOutputWithContext(ctx context.Context) VolumeDeviceOutput {
	return o
}

// devicePath is the path inside of the container that the device will be mapped to.
func (o VolumeDeviceOutput) DevicePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VolumeDevice) *string { return v.DevicePath }).(pulumi.StringPtrOutput)
}

// name must match the name of a persistentVolumeClaim in the pod
func (o VolumeDeviceOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VolumeDevice) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type VolumeDeviceArrayOutput struct{ *pulumi.OutputState }

func (VolumeDeviceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VolumeDevice)(nil)).Elem()
}

func (o VolumeDeviceArrayOutput) ToVolumeDeviceArrayOutput() VolumeDeviceArrayOutput {
	return o
}

func (o VolumeDeviceArrayOutput) ToVolumeDeviceArrayOutputWithContext(ctx context.Context) VolumeDeviceArrayOutput {
	return o
}

func (o VolumeDeviceArrayOutput) Index(i pulumi.IntInput) VolumeDeviceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VolumeDevice {
		return vs[0].([]VolumeDevice)[vs[1].(int)]
	}).(VolumeDeviceOutput)
}

// VolumeMount describes a mounting of a Volume within a container.
type VolumeMount struct {
	// Path within the container at which the volume should be mounted. Must not contain ':'.
	MountPath *string `pulumi:"mountPath"`
	// mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationHostToContainer is used. This field is beta in 1.10. +optional
	MountPropagation *string `pulumi:"mountPropagation"`
	// This must match the Name of a Volume.
	Name *string `pulumi:"name"`
	// Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. +optional
	ReadOnly *bool `pulumi:"readOnly"`
	// Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root). +optional
	SubPath *string `pulumi:"subPath"`
}

// VolumeMountInput is an input type that accepts VolumeMountArgs and VolumeMountOutput values.
// You can construct a concrete instance of `VolumeMountInput` via:
//
//          VolumeMountArgs{...}
type VolumeMountInput interface {
	pulumi.Input

	ToVolumeMountOutput() VolumeMountOutput
	ToVolumeMountOutputWithContext(context.Context) VolumeMountOutput
}

// VolumeMount describes a mounting of a Volume within a container.
type VolumeMountArgs struct {
	// Path within the container at which the volume should be mounted. Must not contain ':'.
	MountPath pulumi.StringPtrInput `pulumi:"mountPath"`
	// mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationHostToContainer is used. This field is beta in 1.10. +optional
	MountPropagation pulumi.StringPtrInput `pulumi:"mountPropagation"`
	// This must match the Name of a Volume.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. +optional
	ReadOnly pulumi.BoolPtrInput `pulumi:"readOnly"`
	// Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root). +optional
	SubPath pulumi.StringPtrInput `pulumi:"subPath"`
}

func (VolumeMountArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VolumeMount)(nil)).Elem()
}

func (i VolumeMountArgs) ToVolumeMountOutput() VolumeMountOutput {
	return i.ToVolumeMountOutputWithContext(context.Background())
}

func (i VolumeMountArgs) ToVolumeMountOutputWithContext(ctx context.Context) VolumeMountOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeMountOutput)
}

// VolumeMountArrayInput is an input type that accepts VolumeMountArray and VolumeMountArrayOutput values.
// You can construct a concrete instance of `VolumeMountArrayInput` via:
//
//          VolumeMountArray{ VolumeMountArgs{...} }
type VolumeMountArrayInput interface {
	pulumi.Input

	ToVolumeMountArrayOutput() VolumeMountArrayOutput
	ToVolumeMountArrayOutputWithContext(context.Context) VolumeMountArrayOutput
}

type VolumeMountArray []VolumeMountInput

func (VolumeMountArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VolumeMount)(nil)).Elem()
}

func (i VolumeMountArray) ToVolumeMountArrayOutput() VolumeMountArrayOutput {
	return i.ToVolumeMountArrayOutputWithContext(context.Background())
}

func (i VolumeMountArray) ToVolumeMountArrayOutputWithContext(ctx context.Context) VolumeMountArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeMountArrayOutput)
}

// VolumeMount describes a mounting of a Volume within a container.
type VolumeMountOutput struct{ *pulumi.OutputState }

func (VolumeMountOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VolumeMount)(nil)).Elem()
}

func (o VolumeMountOutput) ToVolumeMountOutput() VolumeMountOutput {
	return o
}

func (o VolumeMountOutput) ToVolumeMountOutputWithContext(ctx context.Context) VolumeMountOutput {
	return o
}

// Path within the container at which the volume should be mounted. Must not contain ':'.
func (o VolumeMountOutput) MountPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VolumeMount) *string { return v.MountPath }).(pulumi.StringPtrOutput)
}

// mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationHostToContainer is used. This field is beta in 1.10. +optional
func (o VolumeMountOutput) MountPropagation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VolumeMount) *string { return v.MountPropagation }).(pulumi.StringPtrOutput)
}

// This must match the Name of a Volume.
func (o VolumeMountOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VolumeMount) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. +optional
func (o VolumeMountOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VolumeMount) *bool { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root). +optional
func (o VolumeMountOutput) SubPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VolumeMount) *string { return v.SubPath }).(pulumi.StringPtrOutput)
}

type VolumeMountArrayOutput struct{ *pulumi.OutputState }

func (VolumeMountArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VolumeMount)(nil)).Elem()
}

func (o VolumeMountArrayOutput) ToVolumeMountArrayOutput() VolumeMountArrayOutput {
	return o
}

func (o VolumeMountArrayOutput) ToVolumeMountArrayOutputWithContext(ctx context.Context) VolumeMountArrayOutput {
	return o
}

func (o VolumeMountArrayOutput) Index(i pulumi.IntInput) VolumeMountOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VolumeMount {
		return vs[0].([]VolumeMount)[vs[1].(int)]
	}).(VolumeMountOutput)
}

func init() {
	pulumi.RegisterOutputType(AddressableOutput{})
	pulumi.RegisterOutputType(AddressablePtrOutput{})
	pulumi.RegisterOutputType(AuditConfigOutput{})
	pulumi.RegisterOutputType(AuditConfigArrayOutput{})
	pulumi.RegisterOutputType(AuditLogConfigOutput{})
	pulumi.RegisterOutputType(AuditLogConfigArrayOutput{})
	pulumi.RegisterOutputType(BindingOutput{})
	pulumi.RegisterOutputType(BindingArrayOutput{})
	pulumi.RegisterOutputType(CapabilitiesOutput{})
	pulumi.RegisterOutputType(CapabilitiesPtrOutput{})
	pulumi.RegisterOutputType(ConfigMapEnvSourceOutput{})
	pulumi.RegisterOutputType(ConfigMapEnvSourcePtrOutput{})
	pulumi.RegisterOutputType(ConfigMapKeySelectorOutput{})
	pulumi.RegisterOutputType(ConfigMapKeySelectorPtrOutput{})
	pulumi.RegisterOutputType(ConfigMapVolumeSourceOutput{})
	pulumi.RegisterOutputType(ConfigMapVolumeSourcePtrOutput{})
	pulumi.RegisterOutputType(ConfigurationSpecOutput{})
	pulumi.RegisterOutputType(ConfigurationSpecPtrOutput{})
	pulumi.RegisterOutputType(ContainerOutput{})
	pulumi.RegisterOutputType(ContainerPtrOutput{})
	pulumi.RegisterOutputType(ContainerArrayOutput{})
	pulumi.RegisterOutputType(ContainerPortOutput{})
	pulumi.RegisterOutputType(ContainerPortArrayOutput{})
	pulumi.RegisterOutputType(DomainMappingConditionOutput{})
	pulumi.RegisterOutputType(DomainMappingConditionArrayOutput{})
	pulumi.RegisterOutputType(DomainMappingSpecOutput{})
	pulumi.RegisterOutputType(DomainMappingSpecPtrOutput{})
	pulumi.RegisterOutputType(DomainMappingStatusOutput{})
	pulumi.RegisterOutputType(DomainMappingStatusPtrOutput{})
	pulumi.RegisterOutputType(EnvFromSourceOutput{})
	pulumi.RegisterOutputType(EnvFromSourceArrayOutput{})
	pulumi.RegisterOutputType(EnvVarOutput{})
	pulumi.RegisterOutputType(EnvVarArrayOutput{})
	pulumi.RegisterOutputType(EnvVarSourceOutput{})
	pulumi.RegisterOutputType(EnvVarSourcePtrOutput{})
	pulumi.RegisterOutputType(ExecActionOutput{})
	pulumi.RegisterOutputType(ExecActionPtrOutput{})
	pulumi.RegisterOutputType(ExprOutput{})
	pulumi.RegisterOutputType(ExprPtrOutput{})
	pulumi.RegisterOutputType(HTTPGetActionOutput{})
	pulumi.RegisterOutputType(HTTPGetActionPtrOutput{})
	pulumi.RegisterOutputType(HTTPHeaderOutput{})
	pulumi.RegisterOutputType(HTTPHeaderArrayOutput{})
	pulumi.RegisterOutputType(HandlerOutput{})
	pulumi.RegisterOutputType(HandlerPtrOutput{})
	pulumi.RegisterOutputType(InstanceSpecOutput{})
	pulumi.RegisterOutputType(InstanceSpecPtrOutput{})
	pulumi.RegisterOutputType(InstanceStatusOutput{})
	pulumi.RegisterOutputType(InstanceStatusArrayOutput{})
	pulumi.RegisterOutputType(InstanceTemplateSpecOutput{})
	pulumi.RegisterOutputType(InstanceTemplateSpecPtrOutput{})
	pulumi.RegisterOutputType(IntOrStringOutput{})
	pulumi.RegisterOutputType(IntOrStringPtrOutput{})
	pulumi.RegisterOutputType(JobConditionOutput{})
	pulumi.RegisterOutputType(JobConditionArrayOutput{})
	pulumi.RegisterOutputType(JobSpecOutput{})
	pulumi.RegisterOutputType(JobSpecPtrOutput{})
	pulumi.RegisterOutputType(JobStatusOutput{})
	pulumi.RegisterOutputType(JobStatusPtrOutput{})
	pulumi.RegisterOutputType(KeyToPathOutput{})
	pulumi.RegisterOutputType(KeyToPathArrayOutput{})
	pulumi.RegisterOutputType(LifecycleOutput{})
	pulumi.RegisterOutputType(LifecyclePtrOutput{})
	pulumi.RegisterOutputType(LocalObjectReferenceOutput{})
	pulumi.RegisterOutputType(LocalObjectReferencePtrOutput{})
	pulumi.RegisterOutputType(ObjectMetaOutput{})
	pulumi.RegisterOutputType(ObjectMetaPtrOutput{})
	pulumi.RegisterOutputType(OwnerReferenceOutput{})
	pulumi.RegisterOutputType(OwnerReferenceArrayOutput{})
	pulumi.RegisterOutputType(PolicyTypeOutput{})
	pulumi.RegisterOutputType(PolicyTypePtrOutput{})
	pulumi.RegisterOutputType(ProbeOutput{})
	pulumi.RegisterOutputType(ProbePtrOutput{})
	pulumi.RegisterOutputType(ResourceRecordOutput{})
	pulumi.RegisterOutputType(ResourceRecordArrayOutput{})
	pulumi.RegisterOutputType(ResourceRequirementsOutput{})
	pulumi.RegisterOutputType(ResourceRequirementsPtrOutput{})
	pulumi.RegisterOutputType(RevisionSpecOutput{})
	pulumi.RegisterOutputType(RevisionSpecPtrOutput{})
	pulumi.RegisterOutputType(RevisionTemplateOutput{})
	pulumi.RegisterOutputType(RevisionTemplatePtrOutput{})
	pulumi.RegisterOutputType(SELinuxOptionsOutput{})
	pulumi.RegisterOutputType(SELinuxOptionsPtrOutput{})
	pulumi.RegisterOutputType(SecretEnvSourceOutput{})
	pulumi.RegisterOutputType(SecretEnvSourcePtrOutput{})
	pulumi.RegisterOutputType(SecretKeySelectorOutput{})
	pulumi.RegisterOutputType(SecretKeySelectorPtrOutput{})
	pulumi.RegisterOutputType(SecretVolumeSourceOutput{})
	pulumi.RegisterOutputType(SecretVolumeSourcePtrOutput{})
	pulumi.RegisterOutputType(SecurityContextOutput{})
	pulumi.RegisterOutputType(SecurityContextPtrOutput{})
	pulumi.RegisterOutputType(ServiceConditionOutput{})
	pulumi.RegisterOutputType(ServiceConditionArrayOutput{})
	pulumi.RegisterOutputType(ServiceSpecOutput{})
	pulumi.RegisterOutputType(ServiceSpecPtrOutput{})
	pulumi.RegisterOutputType(ServiceSpecManualTypeOutput{})
	pulumi.RegisterOutputType(ServiceSpecManualTypePtrOutput{})
	pulumi.RegisterOutputType(ServiceSpecPinnedTypeOutput{})
	pulumi.RegisterOutputType(ServiceSpecPinnedTypePtrOutput{})
	pulumi.RegisterOutputType(ServiceSpecReleaseTypeOutput{})
	pulumi.RegisterOutputType(ServiceSpecReleaseTypePtrOutput{})
	pulumi.RegisterOutputType(ServiceSpecRunLatestOutput{})
	pulumi.RegisterOutputType(ServiceSpecRunLatestPtrOutput{})
	pulumi.RegisterOutputType(ServiceStatusOutput{})
	pulumi.RegisterOutputType(ServiceStatusPtrOutput{})
	pulumi.RegisterOutputType(TCPSocketActionOutput{})
	pulumi.RegisterOutputType(TCPSocketActionPtrOutput{})
	pulumi.RegisterOutputType(TrafficTargetOutput{})
	pulumi.RegisterOutputType(TrafficTargetArrayOutput{})
	pulumi.RegisterOutputType(VolumeOutput{})
	pulumi.RegisterOutputType(VolumeArrayOutput{})
	pulumi.RegisterOutputType(VolumeDeviceOutput{})
	pulumi.RegisterOutputType(VolumeDeviceArrayOutput{})
	pulumi.RegisterOutputType(VolumeMountOutput{})
	pulumi.RegisterOutputType(VolumeMountArrayOutput{})
}

// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// AnnotationSource holds the source information of the annotation.
type AnnotationSource struct {
	// Cloud Healthcare API resource.
	CloudHealthcareSource *CloudHealthcareSource `pulumi:"cloudHealthcareSource"`
}

// AnnotationSourceInput is an input type that accepts AnnotationSourceArgs and AnnotationSourceOutput values.
// You can construct a concrete instance of `AnnotationSourceInput` via:
//
//          AnnotationSourceArgs{...}
type AnnotationSourceInput interface {
	pulumi.Input

	ToAnnotationSourceOutput() AnnotationSourceOutput
	ToAnnotationSourceOutputWithContext(context.Context) AnnotationSourceOutput
}

// AnnotationSource holds the source information of the annotation.
type AnnotationSourceArgs struct {
	// Cloud Healthcare API resource.
	CloudHealthcareSource CloudHealthcareSourcePtrInput `pulumi:"cloudHealthcareSource"`
}

func (AnnotationSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AnnotationSource)(nil)).Elem()
}

func (i AnnotationSourceArgs) ToAnnotationSourceOutput() AnnotationSourceOutput {
	return i.ToAnnotationSourceOutputWithContext(context.Background())
}

func (i AnnotationSourceArgs) ToAnnotationSourceOutputWithContext(ctx context.Context) AnnotationSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnnotationSourceOutput)
}

func (i AnnotationSourceArgs) ToAnnotationSourcePtrOutput() AnnotationSourcePtrOutput {
	return i.ToAnnotationSourcePtrOutputWithContext(context.Background())
}

func (i AnnotationSourceArgs) ToAnnotationSourcePtrOutputWithContext(ctx context.Context) AnnotationSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnnotationSourceOutput).ToAnnotationSourcePtrOutputWithContext(ctx)
}

// AnnotationSourcePtrInput is an input type that accepts AnnotationSourceArgs, AnnotationSourcePtr and AnnotationSourcePtrOutput values.
// You can construct a concrete instance of `AnnotationSourcePtrInput` via:
//
//          AnnotationSourceArgs{...}
//
//  or:
//
//          nil
type AnnotationSourcePtrInput interface {
	pulumi.Input

	ToAnnotationSourcePtrOutput() AnnotationSourcePtrOutput
	ToAnnotationSourcePtrOutputWithContext(context.Context) AnnotationSourcePtrOutput
}

type annotationSourcePtrType AnnotationSourceArgs

func AnnotationSourcePtr(v *AnnotationSourceArgs) AnnotationSourcePtrInput {
	return (*annotationSourcePtrType)(v)
}

func (*annotationSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AnnotationSource)(nil)).Elem()
}

func (i *annotationSourcePtrType) ToAnnotationSourcePtrOutput() AnnotationSourcePtrOutput {
	return i.ToAnnotationSourcePtrOutputWithContext(context.Background())
}

func (i *annotationSourcePtrType) ToAnnotationSourcePtrOutputWithContext(ctx context.Context) AnnotationSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnnotationSourcePtrOutput)
}

// AnnotationSource holds the source information of the annotation.
type AnnotationSourceOutput struct{ *pulumi.OutputState }

func (AnnotationSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AnnotationSource)(nil)).Elem()
}

func (o AnnotationSourceOutput) ToAnnotationSourceOutput() AnnotationSourceOutput {
	return o
}

func (o AnnotationSourceOutput) ToAnnotationSourceOutputWithContext(ctx context.Context) AnnotationSourceOutput {
	return o
}

func (o AnnotationSourceOutput) ToAnnotationSourcePtrOutput() AnnotationSourcePtrOutput {
	return o.ToAnnotationSourcePtrOutputWithContext(context.Background())
}

func (o AnnotationSourceOutput) ToAnnotationSourcePtrOutputWithContext(ctx context.Context) AnnotationSourcePtrOutput {
	return o.ApplyT(func(v AnnotationSource) *AnnotationSource {
		return &v
	}).(AnnotationSourcePtrOutput)
}

// Cloud Healthcare API resource.
func (o AnnotationSourceOutput) CloudHealthcareSource() CloudHealthcareSourcePtrOutput {
	return o.ApplyT(func(v AnnotationSource) *CloudHealthcareSource { return v.CloudHealthcareSource }).(CloudHealthcareSourcePtrOutput)
}

type AnnotationSourcePtrOutput struct{ *pulumi.OutputState }

func (AnnotationSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AnnotationSource)(nil)).Elem()
}

func (o AnnotationSourcePtrOutput) ToAnnotationSourcePtrOutput() AnnotationSourcePtrOutput {
	return o
}

func (o AnnotationSourcePtrOutput) ToAnnotationSourcePtrOutputWithContext(ctx context.Context) AnnotationSourcePtrOutput {
	return o
}

func (o AnnotationSourcePtrOutput) Elem() AnnotationSourceOutput {
	return o.ApplyT(func(v *AnnotationSource) AnnotationSource { return *v }).(AnnotationSourceOutput)
}

// Cloud Healthcare API resource.
func (o AnnotationSourcePtrOutput) CloudHealthcareSource() CloudHealthcareSourcePtrOutput {
	return o.ApplyT(func(v *AnnotationSource) *CloudHealthcareSource {
		if v == nil {
			return nil
		}
		return v.CloudHealthcareSource
	}).(CloudHealthcareSourcePtrOutput)
}

// AnnotationSource holds the source information of the annotation.
type AnnotationSourceResponse struct {
	// Cloud Healthcare API resource.
	CloudHealthcareSource CloudHealthcareSourceResponse `pulumi:"cloudHealthcareSource"`
}

// AnnotationSourceResponseInput is an input type that accepts AnnotationSourceResponseArgs and AnnotationSourceResponseOutput values.
// You can construct a concrete instance of `AnnotationSourceResponseInput` via:
//
//          AnnotationSourceResponseArgs{...}
type AnnotationSourceResponseInput interface {
	pulumi.Input

	ToAnnotationSourceResponseOutput() AnnotationSourceResponseOutput
	ToAnnotationSourceResponseOutputWithContext(context.Context) AnnotationSourceResponseOutput
}

// AnnotationSource holds the source information of the annotation.
type AnnotationSourceResponseArgs struct {
	// Cloud Healthcare API resource.
	CloudHealthcareSource CloudHealthcareSourceResponseInput `pulumi:"cloudHealthcareSource"`
}

func (AnnotationSourceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AnnotationSourceResponse)(nil)).Elem()
}

func (i AnnotationSourceResponseArgs) ToAnnotationSourceResponseOutput() AnnotationSourceResponseOutput {
	return i.ToAnnotationSourceResponseOutputWithContext(context.Background())
}

func (i AnnotationSourceResponseArgs) ToAnnotationSourceResponseOutputWithContext(ctx context.Context) AnnotationSourceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnnotationSourceResponseOutput)
}

func (i AnnotationSourceResponseArgs) ToAnnotationSourceResponsePtrOutput() AnnotationSourceResponsePtrOutput {
	return i.ToAnnotationSourceResponsePtrOutputWithContext(context.Background())
}

func (i AnnotationSourceResponseArgs) ToAnnotationSourceResponsePtrOutputWithContext(ctx context.Context) AnnotationSourceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnnotationSourceResponseOutput).ToAnnotationSourceResponsePtrOutputWithContext(ctx)
}

// AnnotationSourceResponsePtrInput is an input type that accepts AnnotationSourceResponseArgs, AnnotationSourceResponsePtr and AnnotationSourceResponsePtrOutput values.
// You can construct a concrete instance of `AnnotationSourceResponsePtrInput` via:
//
//          AnnotationSourceResponseArgs{...}
//
//  or:
//
//          nil
type AnnotationSourceResponsePtrInput interface {
	pulumi.Input

	ToAnnotationSourceResponsePtrOutput() AnnotationSourceResponsePtrOutput
	ToAnnotationSourceResponsePtrOutputWithContext(context.Context) AnnotationSourceResponsePtrOutput
}

type annotationSourceResponsePtrType AnnotationSourceResponseArgs

func AnnotationSourceResponsePtr(v *AnnotationSourceResponseArgs) AnnotationSourceResponsePtrInput {
	return (*annotationSourceResponsePtrType)(v)
}

func (*annotationSourceResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AnnotationSourceResponse)(nil)).Elem()
}

func (i *annotationSourceResponsePtrType) ToAnnotationSourceResponsePtrOutput() AnnotationSourceResponsePtrOutput {
	return i.ToAnnotationSourceResponsePtrOutputWithContext(context.Background())
}

func (i *annotationSourceResponsePtrType) ToAnnotationSourceResponsePtrOutputWithContext(ctx context.Context) AnnotationSourceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnnotationSourceResponsePtrOutput)
}

// AnnotationSource holds the source information of the annotation.
type AnnotationSourceResponseOutput struct{ *pulumi.OutputState }

func (AnnotationSourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AnnotationSourceResponse)(nil)).Elem()
}

func (o AnnotationSourceResponseOutput) ToAnnotationSourceResponseOutput() AnnotationSourceResponseOutput {
	return o
}

func (o AnnotationSourceResponseOutput) ToAnnotationSourceResponseOutputWithContext(ctx context.Context) AnnotationSourceResponseOutput {
	return o
}

func (o AnnotationSourceResponseOutput) ToAnnotationSourceResponsePtrOutput() AnnotationSourceResponsePtrOutput {
	return o.ToAnnotationSourceResponsePtrOutputWithContext(context.Background())
}

func (o AnnotationSourceResponseOutput) ToAnnotationSourceResponsePtrOutputWithContext(ctx context.Context) AnnotationSourceResponsePtrOutput {
	return o.ApplyT(func(v AnnotationSourceResponse) *AnnotationSourceResponse {
		return &v
	}).(AnnotationSourceResponsePtrOutput)
}

// Cloud Healthcare API resource.
func (o AnnotationSourceResponseOutput) CloudHealthcareSource() CloudHealthcareSourceResponseOutput {
	return o.ApplyT(func(v AnnotationSourceResponse) CloudHealthcareSourceResponse { return v.CloudHealthcareSource }).(CloudHealthcareSourceResponseOutput)
}

type AnnotationSourceResponsePtrOutput struct{ *pulumi.OutputState }

func (AnnotationSourceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AnnotationSourceResponse)(nil)).Elem()
}

func (o AnnotationSourceResponsePtrOutput) ToAnnotationSourceResponsePtrOutput() AnnotationSourceResponsePtrOutput {
	return o
}

func (o AnnotationSourceResponsePtrOutput) ToAnnotationSourceResponsePtrOutputWithContext(ctx context.Context) AnnotationSourceResponsePtrOutput {
	return o
}

func (o AnnotationSourceResponsePtrOutput) Elem() AnnotationSourceResponseOutput {
	return o.ApplyT(func(v *AnnotationSourceResponse) AnnotationSourceResponse { return *v }).(AnnotationSourceResponseOutput)
}

// Cloud Healthcare API resource.
func (o AnnotationSourceResponsePtrOutput) CloudHealthcareSource() CloudHealthcareSourceResponsePtrOutput {
	return o.ApplyT(func(v *AnnotationSourceResponse) *CloudHealthcareSourceResponse {
		if v == nil {
			return nil
		}
		return &v.CloudHealthcareSource
	}).(CloudHealthcareSourceResponsePtrOutput)
}

// An attribute value for a Consent or User data mapping. Each Attribute must have a corresponding AttributeDefinition in the consent store that defines the default and allowed values.
type Attribute struct {
	// Indicates the name of an attribute defined in the consent store.
	AttributeDefinitionId *string `pulumi:"attributeDefinitionId"`
	// The value of the attribute. Must be an acceptable value as defined in the consent store. For example, if the consent store defines "data type" with acceptable values "questionnaire" and "step-count", when the attribute name is data type, this field must contain one of those values.
	Values []string `pulumi:"values"`
}

// AttributeInput is an input type that accepts AttributeArgs and AttributeOutput values.
// You can construct a concrete instance of `AttributeInput` via:
//
//          AttributeArgs{...}
type AttributeInput interface {
	pulumi.Input

	ToAttributeOutput() AttributeOutput
	ToAttributeOutputWithContext(context.Context) AttributeOutput
}

// An attribute value for a Consent or User data mapping. Each Attribute must have a corresponding AttributeDefinition in the consent store that defines the default and allowed values.
type AttributeArgs struct {
	// Indicates the name of an attribute defined in the consent store.
	AttributeDefinitionId pulumi.StringPtrInput `pulumi:"attributeDefinitionId"`
	// The value of the attribute. Must be an acceptable value as defined in the consent store. For example, if the consent store defines "data type" with acceptable values "questionnaire" and "step-count", when the attribute name is data type, this field must contain one of those values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (AttributeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Attribute)(nil)).Elem()
}

func (i AttributeArgs) ToAttributeOutput() AttributeOutput {
	return i.ToAttributeOutputWithContext(context.Background())
}

func (i AttributeArgs) ToAttributeOutputWithContext(ctx context.Context) AttributeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttributeOutput)
}

// AttributeArrayInput is an input type that accepts AttributeArray and AttributeArrayOutput values.
// You can construct a concrete instance of `AttributeArrayInput` via:
//
//          AttributeArray{ AttributeArgs{...} }
type AttributeArrayInput interface {
	pulumi.Input

	ToAttributeArrayOutput() AttributeArrayOutput
	ToAttributeArrayOutputWithContext(context.Context) AttributeArrayOutput
}

type AttributeArray []AttributeInput

func (AttributeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Attribute)(nil)).Elem()
}

func (i AttributeArray) ToAttributeArrayOutput() AttributeArrayOutput {
	return i.ToAttributeArrayOutputWithContext(context.Background())
}

func (i AttributeArray) ToAttributeArrayOutputWithContext(ctx context.Context) AttributeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttributeArrayOutput)
}

// An attribute value for a Consent or User data mapping. Each Attribute must have a corresponding AttributeDefinition in the consent store that defines the default and allowed values.
type AttributeOutput struct{ *pulumi.OutputState }

func (AttributeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Attribute)(nil)).Elem()
}

func (o AttributeOutput) ToAttributeOutput() AttributeOutput {
	return o
}

func (o AttributeOutput) ToAttributeOutputWithContext(ctx context.Context) AttributeOutput {
	return o
}

// Indicates the name of an attribute defined in the consent store.
func (o AttributeOutput) AttributeDefinitionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Attribute) *string { return v.AttributeDefinitionId }).(pulumi.StringPtrOutput)
}

// The value of the attribute. Must be an acceptable value as defined in the consent store. For example, if the consent store defines "data type" with acceptable values "questionnaire" and "step-count", when the attribute name is data type, this field must contain one of those values.
func (o AttributeOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Attribute) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type AttributeArrayOutput struct{ *pulumi.OutputState }

func (AttributeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Attribute)(nil)).Elem()
}

func (o AttributeArrayOutput) ToAttributeArrayOutput() AttributeArrayOutput {
	return o
}

func (o AttributeArrayOutput) ToAttributeArrayOutputWithContext(ctx context.Context) AttributeArrayOutput {
	return o
}

func (o AttributeArrayOutput) Index(i pulumi.IntInput) AttributeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Attribute {
		return vs[0].([]Attribute)[vs[1].(int)]
	}).(AttributeOutput)
}

// An attribute value for a Consent or User data mapping. Each Attribute must have a corresponding AttributeDefinition in the consent store that defines the default and allowed values.
type AttributeResponse struct {
	// Indicates the name of an attribute defined in the consent store.
	AttributeDefinitionId string `pulumi:"attributeDefinitionId"`
	// The value of the attribute. Must be an acceptable value as defined in the consent store. For example, if the consent store defines "data type" with acceptable values "questionnaire" and "step-count", when the attribute name is data type, this field must contain one of those values.
	Values []string `pulumi:"values"`
}

// AttributeResponseInput is an input type that accepts AttributeResponseArgs and AttributeResponseOutput values.
// You can construct a concrete instance of `AttributeResponseInput` via:
//
//          AttributeResponseArgs{...}
type AttributeResponseInput interface {
	pulumi.Input

	ToAttributeResponseOutput() AttributeResponseOutput
	ToAttributeResponseOutputWithContext(context.Context) AttributeResponseOutput
}

// An attribute value for a Consent or User data mapping. Each Attribute must have a corresponding AttributeDefinition in the consent store that defines the default and allowed values.
type AttributeResponseArgs struct {
	// Indicates the name of an attribute defined in the consent store.
	AttributeDefinitionId pulumi.StringInput `pulumi:"attributeDefinitionId"`
	// The value of the attribute. Must be an acceptable value as defined in the consent store. For example, if the consent store defines "data type" with acceptable values "questionnaire" and "step-count", when the attribute name is data type, this field must contain one of those values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (AttributeResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AttributeResponse)(nil)).Elem()
}

func (i AttributeResponseArgs) ToAttributeResponseOutput() AttributeResponseOutput {
	return i.ToAttributeResponseOutputWithContext(context.Background())
}

func (i AttributeResponseArgs) ToAttributeResponseOutputWithContext(ctx context.Context) AttributeResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttributeResponseOutput)
}

// AttributeResponseArrayInput is an input type that accepts AttributeResponseArray and AttributeResponseArrayOutput values.
// You can construct a concrete instance of `AttributeResponseArrayInput` via:
//
//          AttributeResponseArray{ AttributeResponseArgs{...} }
type AttributeResponseArrayInput interface {
	pulumi.Input

	ToAttributeResponseArrayOutput() AttributeResponseArrayOutput
	ToAttributeResponseArrayOutputWithContext(context.Context) AttributeResponseArrayOutput
}

type AttributeResponseArray []AttributeResponseInput

func (AttributeResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AttributeResponse)(nil)).Elem()
}

func (i AttributeResponseArray) ToAttributeResponseArrayOutput() AttributeResponseArrayOutput {
	return i.ToAttributeResponseArrayOutputWithContext(context.Background())
}

func (i AttributeResponseArray) ToAttributeResponseArrayOutputWithContext(ctx context.Context) AttributeResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttributeResponseArrayOutput)
}

// An attribute value for a Consent or User data mapping. Each Attribute must have a corresponding AttributeDefinition in the consent store that defines the default and allowed values.
type AttributeResponseOutput struct{ *pulumi.OutputState }

func (AttributeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AttributeResponse)(nil)).Elem()
}

func (o AttributeResponseOutput) ToAttributeResponseOutput() AttributeResponseOutput {
	return o
}

func (o AttributeResponseOutput) ToAttributeResponseOutputWithContext(ctx context.Context) AttributeResponseOutput {
	return o
}

// Indicates the name of an attribute defined in the consent store.
func (o AttributeResponseOutput) AttributeDefinitionId() pulumi.StringOutput {
	return o.ApplyT(func(v AttributeResponse) string { return v.AttributeDefinitionId }).(pulumi.StringOutput)
}

// The value of the attribute. Must be an acceptable value as defined in the consent store. For example, if the consent store defines "data type" with acceptable values "questionnaire" and "step-count", when the attribute name is data type, this field must contain one of those values.
func (o AttributeResponseOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AttributeResponse) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type AttributeResponseArrayOutput struct{ *pulumi.OutputState }

func (AttributeResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AttributeResponse)(nil)).Elem()
}

func (o AttributeResponseArrayOutput) ToAttributeResponseArrayOutput() AttributeResponseArrayOutput {
	return o
}

func (o AttributeResponseArrayOutput) ToAttributeResponseArrayOutputWithContext(ctx context.Context) AttributeResponseArrayOutput {
	return o
}

func (o AttributeResponseArrayOutput) Index(i pulumi.IntInput) AttributeResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AttributeResponse {
		return vs[0].([]AttributeResponse)[vs[1].(int)]
	}).(AttributeResponseOutput)
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts jose@example.com from DATA_READ logging, and aliya@example.com from DATA_WRITE logging.
type AuditConfig struct {
	// The configuration for logging of each type of permission.
	AuditLogConfigs []AuditLogConfig `pulumi:"auditLogConfigs"`
	// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
	Service *string `pulumi:"service"`
}

// AuditConfigInput is an input type that accepts AuditConfigArgs and AuditConfigOutput values.
// You can construct a concrete instance of `AuditConfigInput` via:
//
//          AuditConfigArgs{...}
type AuditConfigInput interface {
	pulumi.Input

	ToAuditConfigOutput() AuditConfigOutput
	ToAuditConfigOutputWithContext(context.Context) AuditConfigOutput
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts jose@example.com from DATA_READ logging, and aliya@example.com from DATA_WRITE logging.
type AuditConfigArgs struct {
	// The configuration for logging of each type of permission.
	AuditLogConfigs AuditLogConfigArrayInput `pulumi:"auditLogConfigs"`
	// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
	Service pulumi.StringPtrInput `pulumi:"service"`
}

func (AuditConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditConfig)(nil)).Elem()
}

func (i AuditConfigArgs) ToAuditConfigOutput() AuditConfigOutput {
	return i.ToAuditConfigOutputWithContext(context.Background())
}

func (i AuditConfigArgs) ToAuditConfigOutputWithContext(ctx context.Context) AuditConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditConfigOutput)
}

// AuditConfigArrayInput is an input type that accepts AuditConfigArray and AuditConfigArrayOutput values.
// You can construct a concrete instance of `AuditConfigArrayInput` via:
//
//          AuditConfigArray{ AuditConfigArgs{...} }
type AuditConfigArrayInput interface {
	pulumi.Input

	ToAuditConfigArrayOutput() AuditConfigArrayOutput
	ToAuditConfigArrayOutputWithContext(context.Context) AuditConfigArrayOutput
}

type AuditConfigArray []AuditConfigInput

func (AuditConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditConfig)(nil)).Elem()
}

func (i AuditConfigArray) ToAuditConfigArrayOutput() AuditConfigArrayOutput {
	return i.ToAuditConfigArrayOutputWithContext(context.Background())
}

func (i AuditConfigArray) ToAuditConfigArrayOutputWithContext(ctx context.Context) AuditConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditConfigArrayOutput)
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts jose@example.com from DATA_READ logging, and aliya@example.com from DATA_WRITE logging.
type AuditConfigOutput struct{ *pulumi.OutputState }

func (AuditConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditConfig)(nil)).Elem()
}

func (o AuditConfigOutput) ToAuditConfigOutput() AuditConfigOutput {
	return o
}

func (o AuditConfigOutput) ToAuditConfigOutputWithContext(ctx context.Context) AuditConfigOutput {
	return o
}

// The configuration for logging of each type of permission.
func (o AuditConfigOutput) AuditLogConfigs() AuditLogConfigArrayOutput {
	return o.ApplyT(func(v AuditConfig) []AuditLogConfig { return v.AuditLogConfigs }).(AuditLogConfigArrayOutput)
}

// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
func (o AuditConfigOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AuditConfig) *string { return v.Service }).(pulumi.StringPtrOutput)
}

type AuditConfigArrayOutput struct{ *pulumi.OutputState }

func (AuditConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditConfig)(nil)).Elem()
}

func (o AuditConfigArrayOutput) ToAuditConfigArrayOutput() AuditConfigArrayOutput {
	return o
}

func (o AuditConfigArrayOutput) ToAuditConfigArrayOutputWithContext(ctx context.Context) AuditConfigArrayOutput {
	return o
}

func (o AuditConfigArrayOutput) Index(i pulumi.IntInput) AuditConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AuditConfig {
		return vs[0].([]AuditConfig)[vs[1].(int)]
	}).(AuditConfigOutput)
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts jose@example.com from DATA_READ logging, and aliya@example.com from DATA_WRITE logging.
type AuditConfigResponse struct {
	// The configuration for logging of each type of permission.
	AuditLogConfigs []AuditLogConfigResponse `pulumi:"auditLogConfigs"`
	// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
	Service string `pulumi:"service"`
}

// AuditConfigResponseInput is an input type that accepts AuditConfigResponseArgs and AuditConfigResponseOutput values.
// You can construct a concrete instance of `AuditConfigResponseInput` via:
//
//          AuditConfigResponseArgs{...}
type AuditConfigResponseInput interface {
	pulumi.Input

	ToAuditConfigResponseOutput() AuditConfigResponseOutput
	ToAuditConfigResponseOutputWithContext(context.Context) AuditConfigResponseOutput
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts jose@example.com from DATA_READ logging, and aliya@example.com from DATA_WRITE logging.
type AuditConfigResponseArgs struct {
	// The configuration for logging of each type of permission.
	AuditLogConfigs AuditLogConfigResponseArrayInput `pulumi:"auditLogConfigs"`
	// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
	Service pulumi.StringInput `pulumi:"service"`
}

func (AuditConfigResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditConfigResponse)(nil)).Elem()
}

func (i AuditConfigResponseArgs) ToAuditConfigResponseOutput() AuditConfigResponseOutput {
	return i.ToAuditConfigResponseOutputWithContext(context.Background())
}

func (i AuditConfigResponseArgs) ToAuditConfigResponseOutputWithContext(ctx context.Context) AuditConfigResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditConfigResponseOutput)
}

// AuditConfigResponseArrayInput is an input type that accepts AuditConfigResponseArray and AuditConfigResponseArrayOutput values.
// You can construct a concrete instance of `AuditConfigResponseArrayInput` via:
//
//          AuditConfigResponseArray{ AuditConfigResponseArgs{...} }
type AuditConfigResponseArrayInput interface {
	pulumi.Input

	ToAuditConfigResponseArrayOutput() AuditConfigResponseArrayOutput
	ToAuditConfigResponseArrayOutputWithContext(context.Context) AuditConfigResponseArrayOutput
}

type AuditConfigResponseArray []AuditConfigResponseInput

func (AuditConfigResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditConfigResponse)(nil)).Elem()
}

func (i AuditConfigResponseArray) ToAuditConfigResponseArrayOutput() AuditConfigResponseArrayOutput {
	return i.ToAuditConfigResponseArrayOutputWithContext(context.Background())
}

func (i AuditConfigResponseArray) ToAuditConfigResponseArrayOutputWithContext(ctx context.Context) AuditConfigResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditConfigResponseArrayOutput)
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts jose@example.com from DATA_READ logging, and aliya@example.com from DATA_WRITE logging.
type AuditConfigResponseOutput struct{ *pulumi.OutputState }

func (AuditConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditConfigResponse)(nil)).Elem()
}

func (o AuditConfigResponseOutput) ToAuditConfigResponseOutput() AuditConfigResponseOutput {
	return o
}

func (o AuditConfigResponseOutput) ToAuditConfigResponseOutputWithContext(ctx context.Context) AuditConfigResponseOutput {
	return o
}

// The configuration for logging of each type of permission.
func (o AuditConfigResponseOutput) AuditLogConfigs() AuditLogConfigResponseArrayOutput {
	return o.ApplyT(func(v AuditConfigResponse) []AuditLogConfigResponse { return v.AuditLogConfigs }).(AuditLogConfigResponseArrayOutput)
}

// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
func (o AuditConfigResponseOutput) Service() pulumi.StringOutput {
	return o.ApplyT(func(v AuditConfigResponse) string { return v.Service }).(pulumi.StringOutput)
}

type AuditConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (AuditConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditConfigResponse)(nil)).Elem()
}

func (o AuditConfigResponseArrayOutput) ToAuditConfigResponseArrayOutput() AuditConfigResponseArrayOutput {
	return o
}

func (o AuditConfigResponseArrayOutput) ToAuditConfigResponseArrayOutputWithContext(ctx context.Context) AuditConfigResponseArrayOutput {
	return o
}

func (o AuditConfigResponseArrayOutput) Index(i pulumi.IntInput) AuditConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AuditConfigResponse {
		return vs[0].([]AuditConfigResponse)[vs[1].(int)]
	}).(AuditConfigResponseOutput)
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfig struct {
	// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
	ExemptedMembers []string `pulumi:"exemptedMembers"`
	// The log type that this config enables.
	LogType *string `pulumi:"logType"`
}

// AuditLogConfigInput is an input type that accepts AuditLogConfigArgs and AuditLogConfigOutput values.
// You can construct a concrete instance of `AuditLogConfigInput` via:
//
//          AuditLogConfigArgs{...}
type AuditLogConfigInput interface {
	pulumi.Input

	ToAuditLogConfigOutput() AuditLogConfigOutput
	ToAuditLogConfigOutputWithContext(context.Context) AuditLogConfigOutput
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfigArgs struct {
	// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
	ExemptedMembers pulumi.StringArrayInput `pulumi:"exemptedMembers"`
	// The log type that this config enables.
	LogType pulumi.StringPtrInput `pulumi:"logType"`
}

func (AuditLogConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditLogConfig)(nil)).Elem()
}

func (i AuditLogConfigArgs) ToAuditLogConfigOutput() AuditLogConfigOutput {
	return i.ToAuditLogConfigOutputWithContext(context.Background())
}

func (i AuditLogConfigArgs) ToAuditLogConfigOutputWithContext(ctx context.Context) AuditLogConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditLogConfigOutput)
}

// AuditLogConfigArrayInput is an input type that accepts AuditLogConfigArray and AuditLogConfigArrayOutput values.
// You can construct a concrete instance of `AuditLogConfigArrayInput` via:
//
//          AuditLogConfigArray{ AuditLogConfigArgs{...} }
type AuditLogConfigArrayInput interface {
	pulumi.Input

	ToAuditLogConfigArrayOutput() AuditLogConfigArrayOutput
	ToAuditLogConfigArrayOutputWithContext(context.Context) AuditLogConfigArrayOutput
}

type AuditLogConfigArray []AuditLogConfigInput

func (AuditLogConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditLogConfig)(nil)).Elem()
}

func (i AuditLogConfigArray) ToAuditLogConfigArrayOutput() AuditLogConfigArrayOutput {
	return i.ToAuditLogConfigArrayOutputWithContext(context.Background())
}

func (i AuditLogConfigArray) ToAuditLogConfigArrayOutputWithContext(ctx context.Context) AuditLogConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditLogConfigArrayOutput)
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfigOutput struct{ *pulumi.OutputState }

func (AuditLogConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditLogConfig)(nil)).Elem()
}

func (o AuditLogConfigOutput) ToAuditLogConfigOutput() AuditLogConfigOutput {
	return o
}

func (o AuditLogConfigOutput) ToAuditLogConfigOutputWithContext(ctx context.Context) AuditLogConfigOutput {
	return o
}

// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
func (o AuditLogConfigOutput) ExemptedMembers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AuditLogConfig) []string { return v.ExemptedMembers }).(pulumi.StringArrayOutput)
}

// The log type that this config enables.
func (o AuditLogConfigOutput) LogType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AuditLogConfig) *string { return v.LogType }).(pulumi.StringPtrOutput)
}

type AuditLogConfigArrayOutput struct{ *pulumi.OutputState }

func (AuditLogConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditLogConfig)(nil)).Elem()
}

func (o AuditLogConfigArrayOutput) ToAuditLogConfigArrayOutput() AuditLogConfigArrayOutput {
	return o
}

func (o AuditLogConfigArrayOutput) ToAuditLogConfigArrayOutputWithContext(ctx context.Context) AuditLogConfigArrayOutput {
	return o
}

func (o AuditLogConfigArrayOutput) Index(i pulumi.IntInput) AuditLogConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AuditLogConfig {
		return vs[0].([]AuditLogConfig)[vs[1].(int)]
	}).(AuditLogConfigOutput)
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfigResponse struct {
	// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
	ExemptedMembers []string `pulumi:"exemptedMembers"`
	// The log type that this config enables.
	LogType string `pulumi:"logType"`
}

// AuditLogConfigResponseInput is an input type that accepts AuditLogConfigResponseArgs and AuditLogConfigResponseOutput values.
// You can construct a concrete instance of `AuditLogConfigResponseInput` via:
//
//          AuditLogConfigResponseArgs{...}
type AuditLogConfigResponseInput interface {
	pulumi.Input

	ToAuditLogConfigResponseOutput() AuditLogConfigResponseOutput
	ToAuditLogConfigResponseOutputWithContext(context.Context) AuditLogConfigResponseOutput
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfigResponseArgs struct {
	// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
	ExemptedMembers pulumi.StringArrayInput `pulumi:"exemptedMembers"`
	// The log type that this config enables.
	LogType pulumi.StringInput `pulumi:"logType"`
}

func (AuditLogConfigResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditLogConfigResponse)(nil)).Elem()
}

func (i AuditLogConfigResponseArgs) ToAuditLogConfigResponseOutput() AuditLogConfigResponseOutput {
	return i.ToAuditLogConfigResponseOutputWithContext(context.Background())
}

func (i AuditLogConfigResponseArgs) ToAuditLogConfigResponseOutputWithContext(ctx context.Context) AuditLogConfigResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditLogConfigResponseOutput)
}

// AuditLogConfigResponseArrayInput is an input type that accepts AuditLogConfigResponseArray and AuditLogConfigResponseArrayOutput values.
// You can construct a concrete instance of `AuditLogConfigResponseArrayInput` via:
//
//          AuditLogConfigResponseArray{ AuditLogConfigResponseArgs{...} }
type AuditLogConfigResponseArrayInput interface {
	pulumi.Input

	ToAuditLogConfigResponseArrayOutput() AuditLogConfigResponseArrayOutput
	ToAuditLogConfigResponseArrayOutputWithContext(context.Context) AuditLogConfigResponseArrayOutput
}

type AuditLogConfigResponseArray []AuditLogConfigResponseInput

func (AuditLogConfigResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditLogConfigResponse)(nil)).Elem()
}

func (i AuditLogConfigResponseArray) ToAuditLogConfigResponseArrayOutput() AuditLogConfigResponseArrayOutput {
	return i.ToAuditLogConfigResponseArrayOutputWithContext(context.Background())
}

func (i AuditLogConfigResponseArray) ToAuditLogConfigResponseArrayOutputWithContext(ctx context.Context) AuditLogConfigResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditLogConfigResponseArrayOutput)
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfigResponseOutput struct{ *pulumi.OutputState }

func (AuditLogConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditLogConfigResponse)(nil)).Elem()
}

func (o AuditLogConfigResponseOutput) ToAuditLogConfigResponseOutput() AuditLogConfigResponseOutput {
	return o
}

func (o AuditLogConfigResponseOutput) ToAuditLogConfigResponseOutputWithContext(ctx context.Context) AuditLogConfigResponseOutput {
	return o
}

// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
func (o AuditLogConfigResponseOutput) ExemptedMembers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AuditLogConfigResponse) []string { return v.ExemptedMembers }).(pulumi.StringArrayOutput)
}

// The log type that this config enables.
func (o AuditLogConfigResponseOutput) LogType() pulumi.StringOutput {
	return o.ApplyT(func(v AuditLogConfigResponse) string { return v.LogType }).(pulumi.StringOutput)
}

type AuditLogConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (AuditLogConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditLogConfigResponse)(nil)).Elem()
}

func (o AuditLogConfigResponseArrayOutput) ToAuditLogConfigResponseArrayOutput() AuditLogConfigResponseArrayOutput {
	return o
}

func (o AuditLogConfigResponseArrayOutput) ToAuditLogConfigResponseArrayOutputWithContext(ctx context.Context) AuditLogConfigResponseArrayOutput {
	return o
}

func (o AuditLogConfigResponseArrayOutput) Index(i pulumi.IntInput) AuditLogConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AuditLogConfigResponse {
		return vs[0].([]AuditLogConfigResponse)[vs[1].(int)]
	}).(AuditLogConfigResponseOutput)
}

// Associates `members` with a `role`.
type Binding struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition *Expr `pulumi:"condition"`
	// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
	Members []string `pulumi:"members"`
	// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role *string `pulumi:"role"`
}

// BindingInput is an input type that accepts BindingArgs and BindingOutput values.
// You can construct a concrete instance of `BindingInput` via:
//
//          BindingArgs{...}
type BindingInput interface {
	pulumi.Input

	ToBindingOutput() BindingOutput
	ToBindingOutputWithContext(context.Context) BindingOutput
}

// Associates `members` with a `role`.
type BindingArgs struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition ExprPtrInput `pulumi:"condition"`
	// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
	Members pulumi.StringArrayInput `pulumi:"members"`
	// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role pulumi.StringPtrInput `pulumi:"role"`
}

func (BindingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Binding)(nil)).Elem()
}

func (i BindingArgs) ToBindingOutput() BindingOutput {
	return i.ToBindingOutputWithContext(context.Background())
}

func (i BindingArgs) ToBindingOutputWithContext(ctx context.Context) BindingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingOutput)
}

// BindingArrayInput is an input type that accepts BindingArray and BindingArrayOutput values.
// You can construct a concrete instance of `BindingArrayInput` via:
//
//          BindingArray{ BindingArgs{...} }
type BindingArrayInput interface {
	pulumi.Input

	ToBindingArrayOutput() BindingArrayOutput
	ToBindingArrayOutputWithContext(context.Context) BindingArrayOutput
}

type BindingArray []BindingInput

func (BindingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Binding)(nil)).Elem()
}

func (i BindingArray) ToBindingArrayOutput() BindingArrayOutput {
	return i.ToBindingArrayOutputWithContext(context.Background())
}

func (i BindingArray) ToBindingArrayOutputWithContext(ctx context.Context) BindingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingArrayOutput)
}

// Associates `members` with a `role`.
type BindingOutput struct{ *pulumi.OutputState }

func (BindingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Binding)(nil)).Elem()
}

func (o BindingOutput) ToBindingOutput() BindingOutput {
	return o
}

func (o BindingOutput) ToBindingOutputWithContext(ctx context.Context) BindingOutput {
	return o
}

// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o BindingOutput) Condition() ExprPtrOutput {
	return o.ApplyT(func(v Binding) *Expr { return v.Condition }).(ExprPtrOutput)
}

// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
func (o BindingOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Binding) []string { return v.Members }).(pulumi.StringArrayOutput)
}

// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
func (o BindingOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Binding) *string { return v.Role }).(pulumi.StringPtrOutput)
}

type BindingArrayOutput struct{ *pulumi.OutputState }

func (BindingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Binding)(nil)).Elem()
}

func (o BindingArrayOutput) ToBindingArrayOutput() BindingArrayOutput {
	return o
}

func (o BindingArrayOutput) ToBindingArrayOutputWithContext(ctx context.Context) BindingArrayOutput {
	return o
}

func (o BindingArrayOutput) Index(i pulumi.IntInput) BindingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Binding {
		return vs[0].([]Binding)[vs[1].(int)]
	}).(BindingOutput)
}

// Associates `members` with a `role`.
type BindingResponse struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition ExprResponse `pulumi:"condition"`
	// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
	Members []string `pulumi:"members"`
	// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role string `pulumi:"role"`
}

// BindingResponseInput is an input type that accepts BindingResponseArgs and BindingResponseOutput values.
// You can construct a concrete instance of `BindingResponseInput` via:
//
//          BindingResponseArgs{...}
type BindingResponseInput interface {
	pulumi.Input

	ToBindingResponseOutput() BindingResponseOutput
	ToBindingResponseOutputWithContext(context.Context) BindingResponseOutput
}

// Associates `members` with a `role`.
type BindingResponseArgs struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition ExprResponseInput `pulumi:"condition"`
	// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
	Members pulumi.StringArrayInput `pulumi:"members"`
	// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role pulumi.StringInput `pulumi:"role"`
}

func (BindingResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BindingResponse)(nil)).Elem()
}

func (i BindingResponseArgs) ToBindingResponseOutput() BindingResponseOutput {
	return i.ToBindingResponseOutputWithContext(context.Background())
}

func (i BindingResponseArgs) ToBindingResponseOutputWithContext(ctx context.Context) BindingResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingResponseOutput)
}

// BindingResponseArrayInput is an input type that accepts BindingResponseArray and BindingResponseArrayOutput values.
// You can construct a concrete instance of `BindingResponseArrayInput` via:
//
//          BindingResponseArray{ BindingResponseArgs{...} }
type BindingResponseArrayInput interface {
	pulumi.Input

	ToBindingResponseArrayOutput() BindingResponseArrayOutput
	ToBindingResponseArrayOutputWithContext(context.Context) BindingResponseArrayOutput
}

type BindingResponseArray []BindingResponseInput

func (BindingResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BindingResponse)(nil)).Elem()
}

func (i BindingResponseArray) ToBindingResponseArrayOutput() BindingResponseArrayOutput {
	return i.ToBindingResponseArrayOutputWithContext(context.Background())
}

func (i BindingResponseArray) ToBindingResponseArrayOutputWithContext(ctx context.Context) BindingResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingResponseArrayOutput)
}

// Associates `members` with a `role`.
type BindingResponseOutput struct{ *pulumi.OutputState }

func (BindingResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BindingResponse)(nil)).Elem()
}

func (o BindingResponseOutput) ToBindingResponseOutput() BindingResponseOutput {
	return o
}

func (o BindingResponseOutput) ToBindingResponseOutputWithContext(ctx context.Context) BindingResponseOutput {
	return o
}

// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o BindingResponseOutput) Condition() ExprResponseOutput {
	return o.ApplyT(func(v BindingResponse) ExprResponse { return v.Condition }).(ExprResponseOutput)
}

// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
func (o BindingResponseOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BindingResponse) []string { return v.Members }).(pulumi.StringArrayOutput)
}

// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
func (o BindingResponseOutput) Role() pulumi.StringOutput {
	return o.ApplyT(func(v BindingResponse) string { return v.Role }).(pulumi.StringOutput)
}

type BindingResponseArrayOutput struct{ *pulumi.OutputState }

func (BindingResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BindingResponse)(nil)).Elem()
}

func (o BindingResponseArrayOutput) ToBindingResponseArrayOutput() BindingResponseArrayOutput {
	return o
}

func (o BindingResponseArrayOutput) ToBindingResponseArrayOutputWithContext(ctx context.Context) BindingResponseArrayOutput {
	return o
}

func (o BindingResponseArrayOutput) Index(i pulumi.IntInput) BindingResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BindingResponse {
		return vs[0].([]BindingResponse)[vs[1].(int)]
	}).(BindingResponseOutput)
}

// A bounding polygon for the detected image annotation.
type BoundingPoly struct {
	// A description of this polygon.
	Label *string `pulumi:"label"`
	// List of the vertices of this polygon.
	Vertices []Vertex `pulumi:"vertices"`
}

// BoundingPolyInput is an input type that accepts BoundingPolyArgs and BoundingPolyOutput values.
// You can construct a concrete instance of `BoundingPolyInput` via:
//
//          BoundingPolyArgs{...}
type BoundingPolyInput interface {
	pulumi.Input

	ToBoundingPolyOutput() BoundingPolyOutput
	ToBoundingPolyOutputWithContext(context.Context) BoundingPolyOutput
}

// A bounding polygon for the detected image annotation.
type BoundingPolyArgs struct {
	// A description of this polygon.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// List of the vertices of this polygon.
	Vertices VertexArrayInput `pulumi:"vertices"`
}

func (BoundingPolyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BoundingPoly)(nil)).Elem()
}

func (i BoundingPolyArgs) ToBoundingPolyOutput() BoundingPolyOutput {
	return i.ToBoundingPolyOutputWithContext(context.Background())
}

func (i BoundingPolyArgs) ToBoundingPolyOutputWithContext(ctx context.Context) BoundingPolyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BoundingPolyOutput)
}

// BoundingPolyArrayInput is an input type that accepts BoundingPolyArray and BoundingPolyArrayOutput values.
// You can construct a concrete instance of `BoundingPolyArrayInput` via:
//
//          BoundingPolyArray{ BoundingPolyArgs{...} }
type BoundingPolyArrayInput interface {
	pulumi.Input

	ToBoundingPolyArrayOutput() BoundingPolyArrayOutput
	ToBoundingPolyArrayOutputWithContext(context.Context) BoundingPolyArrayOutput
}

type BoundingPolyArray []BoundingPolyInput

func (BoundingPolyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BoundingPoly)(nil)).Elem()
}

func (i BoundingPolyArray) ToBoundingPolyArrayOutput() BoundingPolyArrayOutput {
	return i.ToBoundingPolyArrayOutputWithContext(context.Background())
}

func (i BoundingPolyArray) ToBoundingPolyArrayOutputWithContext(ctx context.Context) BoundingPolyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BoundingPolyArrayOutput)
}

// A bounding polygon for the detected image annotation.
type BoundingPolyOutput struct{ *pulumi.OutputState }

func (BoundingPolyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BoundingPoly)(nil)).Elem()
}

func (o BoundingPolyOutput) ToBoundingPolyOutput() BoundingPolyOutput {
	return o
}

func (o BoundingPolyOutput) ToBoundingPolyOutputWithContext(ctx context.Context) BoundingPolyOutput {
	return o
}

// A description of this polygon.
func (o BoundingPolyOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BoundingPoly) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// List of the vertices of this polygon.
func (o BoundingPolyOutput) Vertices() VertexArrayOutput {
	return o.ApplyT(func(v BoundingPoly) []Vertex { return v.Vertices }).(VertexArrayOutput)
}

type BoundingPolyArrayOutput struct{ *pulumi.OutputState }

func (BoundingPolyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BoundingPoly)(nil)).Elem()
}

func (o BoundingPolyArrayOutput) ToBoundingPolyArrayOutput() BoundingPolyArrayOutput {
	return o
}

func (o BoundingPolyArrayOutput) ToBoundingPolyArrayOutputWithContext(ctx context.Context) BoundingPolyArrayOutput {
	return o
}

func (o BoundingPolyArrayOutput) Index(i pulumi.IntInput) BoundingPolyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BoundingPoly {
		return vs[0].([]BoundingPoly)[vs[1].(int)]
	}).(BoundingPolyOutput)
}

// A bounding polygon for the detected image annotation.
type BoundingPolyResponse struct {
	// A description of this polygon.
	Label string `pulumi:"label"`
	// List of the vertices of this polygon.
	Vertices []VertexResponse `pulumi:"vertices"`
}

// BoundingPolyResponseInput is an input type that accepts BoundingPolyResponseArgs and BoundingPolyResponseOutput values.
// You can construct a concrete instance of `BoundingPolyResponseInput` via:
//
//          BoundingPolyResponseArgs{...}
type BoundingPolyResponseInput interface {
	pulumi.Input

	ToBoundingPolyResponseOutput() BoundingPolyResponseOutput
	ToBoundingPolyResponseOutputWithContext(context.Context) BoundingPolyResponseOutput
}

// A bounding polygon for the detected image annotation.
type BoundingPolyResponseArgs struct {
	// A description of this polygon.
	Label pulumi.StringInput `pulumi:"label"`
	// List of the vertices of this polygon.
	Vertices VertexResponseArrayInput `pulumi:"vertices"`
}

func (BoundingPolyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BoundingPolyResponse)(nil)).Elem()
}

func (i BoundingPolyResponseArgs) ToBoundingPolyResponseOutput() BoundingPolyResponseOutput {
	return i.ToBoundingPolyResponseOutputWithContext(context.Background())
}

func (i BoundingPolyResponseArgs) ToBoundingPolyResponseOutputWithContext(ctx context.Context) BoundingPolyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BoundingPolyResponseOutput)
}

// BoundingPolyResponseArrayInput is an input type that accepts BoundingPolyResponseArray and BoundingPolyResponseArrayOutput values.
// You can construct a concrete instance of `BoundingPolyResponseArrayInput` via:
//
//          BoundingPolyResponseArray{ BoundingPolyResponseArgs{...} }
type BoundingPolyResponseArrayInput interface {
	pulumi.Input

	ToBoundingPolyResponseArrayOutput() BoundingPolyResponseArrayOutput
	ToBoundingPolyResponseArrayOutputWithContext(context.Context) BoundingPolyResponseArrayOutput
}

type BoundingPolyResponseArray []BoundingPolyResponseInput

func (BoundingPolyResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BoundingPolyResponse)(nil)).Elem()
}

func (i BoundingPolyResponseArray) ToBoundingPolyResponseArrayOutput() BoundingPolyResponseArrayOutput {
	return i.ToBoundingPolyResponseArrayOutputWithContext(context.Background())
}

func (i BoundingPolyResponseArray) ToBoundingPolyResponseArrayOutputWithContext(ctx context.Context) BoundingPolyResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BoundingPolyResponseArrayOutput)
}

// A bounding polygon for the detected image annotation.
type BoundingPolyResponseOutput struct{ *pulumi.OutputState }

func (BoundingPolyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BoundingPolyResponse)(nil)).Elem()
}

func (o BoundingPolyResponseOutput) ToBoundingPolyResponseOutput() BoundingPolyResponseOutput {
	return o
}

func (o BoundingPolyResponseOutput) ToBoundingPolyResponseOutputWithContext(ctx context.Context) BoundingPolyResponseOutput {
	return o
}

// A description of this polygon.
func (o BoundingPolyResponseOutput) Label() pulumi.StringOutput {
	return o.ApplyT(func(v BoundingPolyResponse) string { return v.Label }).(pulumi.StringOutput)
}

// List of the vertices of this polygon.
func (o BoundingPolyResponseOutput) Vertices() VertexResponseArrayOutput {
	return o.ApplyT(func(v BoundingPolyResponse) []VertexResponse { return v.Vertices }).(VertexResponseArrayOutput)
}

type BoundingPolyResponseArrayOutput struct{ *pulumi.OutputState }

func (BoundingPolyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BoundingPolyResponse)(nil)).Elem()
}

func (o BoundingPolyResponseArrayOutput) ToBoundingPolyResponseArrayOutput() BoundingPolyResponseArrayOutput {
	return o
}

func (o BoundingPolyResponseArrayOutput) ToBoundingPolyResponseArrayOutputWithContext(ctx context.Context) BoundingPolyResponseArrayOutput {
	return o
}

func (o BoundingPolyResponseArrayOutput) Index(i pulumi.IntInput) BoundingPolyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BoundingPolyResponse {
		return vs[0].([]BoundingPolyResponse)[vs[1].(int)]
	}).(BoundingPolyResponseOutput)
}

// Cloud Healthcare API resource.
type CloudHealthcareSource struct {
	// Full path of a Cloud Healthcare API resource.
	Name *string `pulumi:"name"`
}

// CloudHealthcareSourceInput is an input type that accepts CloudHealthcareSourceArgs and CloudHealthcareSourceOutput values.
// You can construct a concrete instance of `CloudHealthcareSourceInput` via:
//
//          CloudHealthcareSourceArgs{...}
type CloudHealthcareSourceInput interface {
	pulumi.Input

	ToCloudHealthcareSourceOutput() CloudHealthcareSourceOutput
	ToCloudHealthcareSourceOutputWithContext(context.Context) CloudHealthcareSourceOutput
}

// Cloud Healthcare API resource.
type CloudHealthcareSourceArgs struct {
	// Full path of a Cloud Healthcare API resource.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (CloudHealthcareSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudHealthcareSource)(nil)).Elem()
}

func (i CloudHealthcareSourceArgs) ToCloudHealthcareSourceOutput() CloudHealthcareSourceOutput {
	return i.ToCloudHealthcareSourceOutputWithContext(context.Background())
}

func (i CloudHealthcareSourceArgs) ToCloudHealthcareSourceOutputWithContext(ctx context.Context) CloudHealthcareSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudHealthcareSourceOutput)
}

func (i CloudHealthcareSourceArgs) ToCloudHealthcareSourcePtrOutput() CloudHealthcareSourcePtrOutput {
	return i.ToCloudHealthcareSourcePtrOutputWithContext(context.Background())
}

func (i CloudHealthcareSourceArgs) ToCloudHealthcareSourcePtrOutputWithContext(ctx context.Context) CloudHealthcareSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudHealthcareSourceOutput).ToCloudHealthcareSourcePtrOutputWithContext(ctx)
}

// CloudHealthcareSourcePtrInput is an input type that accepts CloudHealthcareSourceArgs, CloudHealthcareSourcePtr and CloudHealthcareSourcePtrOutput values.
// You can construct a concrete instance of `CloudHealthcareSourcePtrInput` via:
//
//          CloudHealthcareSourceArgs{...}
//
//  or:
//
//          nil
type CloudHealthcareSourcePtrInput interface {
	pulumi.Input

	ToCloudHealthcareSourcePtrOutput() CloudHealthcareSourcePtrOutput
	ToCloudHealthcareSourcePtrOutputWithContext(context.Context) CloudHealthcareSourcePtrOutput
}

type cloudHealthcareSourcePtrType CloudHealthcareSourceArgs

func CloudHealthcareSourcePtr(v *CloudHealthcareSourceArgs) CloudHealthcareSourcePtrInput {
	return (*cloudHealthcareSourcePtrType)(v)
}

func (*cloudHealthcareSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudHealthcareSource)(nil)).Elem()
}

func (i *cloudHealthcareSourcePtrType) ToCloudHealthcareSourcePtrOutput() CloudHealthcareSourcePtrOutput {
	return i.ToCloudHealthcareSourcePtrOutputWithContext(context.Background())
}

func (i *cloudHealthcareSourcePtrType) ToCloudHealthcareSourcePtrOutputWithContext(ctx context.Context) CloudHealthcareSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudHealthcareSourcePtrOutput)
}

// Cloud Healthcare API resource.
type CloudHealthcareSourceOutput struct{ *pulumi.OutputState }

func (CloudHealthcareSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudHealthcareSource)(nil)).Elem()
}

func (o CloudHealthcareSourceOutput) ToCloudHealthcareSourceOutput() CloudHealthcareSourceOutput {
	return o
}

func (o CloudHealthcareSourceOutput) ToCloudHealthcareSourceOutputWithContext(ctx context.Context) CloudHealthcareSourceOutput {
	return o
}

func (o CloudHealthcareSourceOutput) ToCloudHealthcareSourcePtrOutput() CloudHealthcareSourcePtrOutput {
	return o.ToCloudHealthcareSourcePtrOutputWithContext(context.Background())
}

func (o CloudHealthcareSourceOutput) ToCloudHealthcareSourcePtrOutputWithContext(ctx context.Context) CloudHealthcareSourcePtrOutput {
	return o.ApplyT(func(v CloudHealthcareSource) *CloudHealthcareSource {
		return &v
	}).(CloudHealthcareSourcePtrOutput)
}

// Full path of a Cloud Healthcare API resource.
func (o CloudHealthcareSourceOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CloudHealthcareSource) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type CloudHealthcareSourcePtrOutput struct{ *pulumi.OutputState }

func (CloudHealthcareSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudHealthcareSource)(nil)).Elem()
}

func (o CloudHealthcareSourcePtrOutput) ToCloudHealthcareSourcePtrOutput() CloudHealthcareSourcePtrOutput {
	return o
}

func (o CloudHealthcareSourcePtrOutput) ToCloudHealthcareSourcePtrOutputWithContext(ctx context.Context) CloudHealthcareSourcePtrOutput {
	return o
}

func (o CloudHealthcareSourcePtrOutput) Elem() CloudHealthcareSourceOutput {
	return o.ApplyT(func(v *CloudHealthcareSource) CloudHealthcareSource { return *v }).(CloudHealthcareSourceOutput)
}

// Full path of a Cloud Healthcare API resource.
func (o CloudHealthcareSourcePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CloudHealthcareSource) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Cloud Healthcare API resource.
type CloudHealthcareSourceResponse struct {
	// Full path of a Cloud Healthcare API resource.
	Name string `pulumi:"name"`
}

// CloudHealthcareSourceResponseInput is an input type that accepts CloudHealthcareSourceResponseArgs and CloudHealthcareSourceResponseOutput values.
// You can construct a concrete instance of `CloudHealthcareSourceResponseInput` via:
//
//          CloudHealthcareSourceResponseArgs{...}
type CloudHealthcareSourceResponseInput interface {
	pulumi.Input

	ToCloudHealthcareSourceResponseOutput() CloudHealthcareSourceResponseOutput
	ToCloudHealthcareSourceResponseOutputWithContext(context.Context) CloudHealthcareSourceResponseOutput
}

// Cloud Healthcare API resource.
type CloudHealthcareSourceResponseArgs struct {
	// Full path of a Cloud Healthcare API resource.
	Name pulumi.StringInput `pulumi:"name"`
}

func (CloudHealthcareSourceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudHealthcareSourceResponse)(nil)).Elem()
}

func (i CloudHealthcareSourceResponseArgs) ToCloudHealthcareSourceResponseOutput() CloudHealthcareSourceResponseOutput {
	return i.ToCloudHealthcareSourceResponseOutputWithContext(context.Background())
}

func (i CloudHealthcareSourceResponseArgs) ToCloudHealthcareSourceResponseOutputWithContext(ctx context.Context) CloudHealthcareSourceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudHealthcareSourceResponseOutput)
}

func (i CloudHealthcareSourceResponseArgs) ToCloudHealthcareSourceResponsePtrOutput() CloudHealthcareSourceResponsePtrOutput {
	return i.ToCloudHealthcareSourceResponsePtrOutputWithContext(context.Background())
}

func (i CloudHealthcareSourceResponseArgs) ToCloudHealthcareSourceResponsePtrOutputWithContext(ctx context.Context) CloudHealthcareSourceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudHealthcareSourceResponseOutput).ToCloudHealthcareSourceResponsePtrOutputWithContext(ctx)
}

// CloudHealthcareSourceResponsePtrInput is an input type that accepts CloudHealthcareSourceResponseArgs, CloudHealthcareSourceResponsePtr and CloudHealthcareSourceResponsePtrOutput values.
// You can construct a concrete instance of `CloudHealthcareSourceResponsePtrInput` via:
//
//          CloudHealthcareSourceResponseArgs{...}
//
//  or:
//
//          nil
type CloudHealthcareSourceResponsePtrInput interface {
	pulumi.Input

	ToCloudHealthcareSourceResponsePtrOutput() CloudHealthcareSourceResponsePtrOutput
	ToCloudHealthcareSourceResponsePtrOutputWithContext(context.Context) CloudHealthcareSourceResponsePtrOutput
}

type cloudHealthcareSourceResponsePtrType CloudHealthcareSourceResponseArgs

func CloudHealthcareSourceResponsePtr(v *CloudHealthcareSourceResponseArgs) CloudHealthcareSourceResponsePtrInput {
	return (*cloudHealthcareSourceResponsePtrType)(v)
}

func (*cloudHealthcareSourceResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudHealthcareSourceResponse)(nil)).Elem()
}

func (i *cloudHealthcareSourceResponsePtrType) ToCloudHealthcareSourceResponsePtrOutput() CloudHealthcareSourceResponsePtrOutput {
	return i.ToCloudHealthcareSourceResponsePtrOutputWithContext(context.Background())
}

func (i *cloudHealthcareSourceResponsePtrType) ToCloudHealthcareSourceResponsePtrOutputWithContext(ctx context.Context) CloudHealthcareSourceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudHealthcareSourceResponsePtrOutput)
}

// Cloud Healthcare API resource.
type CloudHealthcareSourceResponseOutput struct{ *pulumi.OutputState }

func (CloudHealthcareSourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudHealthcareSourceResponse)(nil)).Elem()
}

func (o CloudHealthcareSourceResponseOutput) ToCloudHealthcareSourceResponseOutput() CloudHealthcareSourceResponseOutput {
	return o
}

func (o CloudHealthcareSourceResponseOutput) ToCloudHealthcareSourceResponseOutputWithContext(ctx context.Context) CloudHealthcareSourceResponseOutput {
	return o
}

func (o CloudHealthcareSourceResponseOutput) ToCloudHealthcareSourceResponsePtrOutput() CloudHealthcareSourceResponsePtrOutput {
	return o.ToCloudHealthcareSourceResponsePtrOutputWithContext(context.Background())
}

func (o CloudHealthcareSourceResponseOutput) ToCloudHealthcareSourceResponsePtrOutputWithContext(ctx context.Context) CloudHealthcareSourceResponsePtrOutput {
	return o.ApplyT(func(v CloudHealthcareSourceResponse) *CloudHealthcareSourceResponse {
		return &v
	}).(CloudHealthcareSourceResponsePtrOutput)
}

// Full path of a Cloud Healthcare API resource.
func (o CloudHealthcareSourceResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v CloudHealthcareSourceResponse) string { return v.Name }).(pulumi.StringOutput)
}

type CloudHealthcareSourceResponsePtrOutput struct{ *pulumi.OutputState }

func (CloudHealthcareSourceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudHealthcareSourceResponse)(nil)).Elem()
}

func (o CloudHealthcareSourceResponsePtrOutput) ToCloudHealthcareSourceResponsePtrOutput() CloudHealthcareSourceResponsePtrOutput {
	return o
}

func (o CloudHealthcareSourceResponsePtrOutput) ToCloudHealthcareSourceResponsePtrOutputWithContext(ctx context.Context) CloudHealthcareSourceResponsePtrOutput {
	return o
}

func (o CloudHealthcareSourceResponsePtrOutput) Elem() CloudHealthcareSourceResponseOutput {
	return o.ApplyT(func(v *CloudHealthcareSourceResponse) CloudHealthcareSourceResponse { return *v }).(CloudHealthcareSourceResponseOutput)
}

// Full path of a Cloud Healthcare API resource.
func (o CloudHealthcareSourceResponsePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CloudHealthcareSourceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type Expr struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description *string `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression *string `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location *string `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title *string `pulumi:"title"`
}

// ExprInput is an input type that accepts ExprArgs and ExprOutput values.
// You can construct a concrete instance of `ExprInput` via:
//
//          ExprArgs{...}
type ExprInput interface {
	pulumi.Input

	ToExprOutput() ExprOutput
	ToExprOutputWithContext(context.Context) ExprOutput
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprArgs struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression pulumi.StringPtrInput `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title pulumi.StringPtrInput `pulumi:"title"`
}

func (ExprArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (i ExprArgs) ToExprOutput() ExprOutput {
	return i.ToExprOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput)
}

func (i ExprArgs) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput).ToExprPtrOutputWithContext(ctx)
}

// ExprPtrInput is an input type that accepts ExprArgs, ExprPtr and ExprPtrOutput values.
// You can construct a concrete instance of `ExprPtrInput` via:
//
//          ExprArgs{...}
//
//  or:
//
//          nil
type ExprPtrInput interface {
	pulumi.Input

	ToExprPtrOutput() ExprPtrOutput
	ToExprPtrOutputWithContext(context.Context) ExprPtrOutput
}

type exprPtrType ExprArgs

func ExprPtr(v *ExprArgs) ExprPtrInput {
	return (*exprPtrType)(v)
}

func (*exprPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (i *exprPtrType) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i *exprPtrType) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprOutput struct{ *pulumi.OutputState }

func (ExprOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (o ExprOutput) ToExprOutput() ExprOutput {
	return o
}

func (o ExprOutput) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return o
}

func (o ExprOutput) ToExprPtrOutput() ExprPtrOutput {
	return o.ToExprPtrOutputWithContext(context.Background())
}

func (o ExprOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o.ApplyT(func(v Expr) *Expr {
		return &v
	}).(ExprPtrOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Expression }).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Title }).(pulumi.StringPtrOutput)
}

type ExprPtrOutput struct{ *pulumi.OutputState }

func (ExprPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (o ExprPtrOutput) ToExprPtrOutput() ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) Elem() ExprOutput {
	return o.ApplyT(func(v *Expr) Expr { return *v }).(ExprOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprPtrOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Expression
	}).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprPtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprPtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprResponse struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description string `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression string `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location string `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title string `pulumi:"title"`
}

// ExprResponseInput is an input type that accepts ExprResponseArgs and ExprResponseOutput values.
// You can construct a concrete instance of `ExprResponseInput` via:
//
//          ExprResponseArgs{...}
type ExprResponseInput interface {
	pulumi.Input

	ToExprResponseOutput() ExprResponseOutput
	ToExprResponseOutputWithContext(context.Context) ExprResponseOutput
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprResponseArgs struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description pulumi.StringInput `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression pulumi.StringInput `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location pulumi.StringInput `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title pulumi.StringInput `pulumi:"title"`
}

func (ExprResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ExprResponse)(nil)).Elem()
}

func (i ExprResponseArgs) ToExprResponseOutput() ExprResponseOutput {
	return i.ToExprResponseOutputWithContext(context.Background())
}

func (i ExprResponseArgs) ToExprResponseOutputWithContext(ctx context.Context) ExprResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprResponseOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprResponseOutput struct{ *pulumi.OutputState }

func (ExprResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExprResponse)(nil)).Elem()
}

func (o ExprResponseOutput) ToExprResponseOutput() ExprResponseOutput {
	return o
}

func (o ExprResponseOutput) ToExprResponseOutputWithContext(ctx context.Context) ExprResponseOutput {
	return o
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Description }).(pulumi.StringOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprResponseOutput) Expression() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Expression }).(pulumi.StringOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprResponseOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Location }).(pulumi.StringOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprResponseOutput) Title() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Title }).(pulumi.StringOutput)
}

// A (sub) field of a type.
type Field struct {
	// The maximum number of times this field can be repeated. 0 or -1 means unbounded.
	MaxOccurs *int `pulumi:"maxOccurs"`
	// The minimum number of times this field must be present/repeated.
	MinOccurs *int `pulumi:"minOccurs"`
	// The name of the field. For example, "PID-1" or just "1".
	Name *string `pulumi:"name"`
	// The HL7v2 table this field refers to. For example, PID-15 (Patient's Primary Language) usually refers to table "0296".
	Table *string `pulumi:"table"`
	// The type of this field. A Type with this name must be defined in an Hl7TypesConfig.
	Type *string `pulumi:"type"`
}

// FieldInput is an input type that accepts FieldArgs and FieldOutput values.
// You can construct a concrete instance of `FieldInput` via:
//
//          FieldArgs{...}
type FieldInput interface {
	pulumi.Input

	ToFieldOutput() FieldOutput
	ToFieldOutputWithContext(context.Context) FieldOutput
}

// A (sub) field of a type.
type FieldArgs struct {
	// The maximum number of times this field can be repeated. 0 or -1 means unbounded.
	MaxOccurs pulumi.IntPtrInput `pulumi:"maxOccurs"`
	// The minimum number of times this field must be present/repeated.
	MinOccurs pulumi.IntPtrInput `pulumi:"minOccurs"`
	// The name of the field. For example, "PID-1" or just "1".
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The HL7v2 table this field refers to. For example, PID-15 (Patient's Primary Language) usually refers to table "0296".
	Table pulumi.StringPtrInput `pulumi:"table"`
	// The type of this field. A Type with this name must be defined in an Hl7TypesConfig.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (FieldArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Field)(nil)).Elem()
}

func (i FieldArgs) ToFieldOutput() FieldOutput {
	return i.ToFieldOutputWithContext(context.Background())
}

func (i FieldArgs) ToFieldOutputWithContext(ctx context.Context) FieldOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FieldOutput)
}

// FieldArrayInput is an input type that accepts FieldArray and FieldArrayOutput values.
// You can construct a concrete instance of `FieldArrayInput` via:
//
//          FieldArray{ FieldArgs{...} }
type FieldArrayInput interface {
	pulumi.Input

	ToFieldArrayOutput() FieldArrayOutput
	ToFieldArrayOutputWithContext(context.Context) FieldArrayOutput
}

type FieldArray []FieldInput

func (FieldArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Field)(nil)).Elem()
}

func (i FieldArray) ToFieldArrayOutput() FieldArrayOutput {
	return i.ToFieldArrayOutputWithContext(context.Background())
}

func (i FieldArray) ToFieldArrayOutputWithContext(ctx context.Context) FieldArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FieldArrayOutput)
}

// A (sub) field of a type.
type FieldOutput struct{ *pulumi.OutputState }

func (FieldOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Field)(nil)).Elem()
}

func (o FieldOutput) ToFieldOutput() FieldOutput {
	return o
}

func (o FieldOutput) ToFieldOutputWithContext(ctx context.Context) FieldOutput {
	return o
}

// The maximum number of times this field can be repeated. 0 or -1 means unbounded.
func (o FieldOutput) MaxOccurs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Field) *int { return v.MaxOccurs }).(pulumi.IntPtrOutput)
}

// The minimum number of times this field must be present/repeated.
func (o FieldOutput) MinOccurs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Field) *int { return v.MinOccurs }).(pulumi.IntPtrOutput)
}

// The name of the field. For example, "PID-1" or just "1".
func (o FieldOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Field) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The HL7v2 table this field refers to. For example, PID-15 (Patient's Primary Language) usually refers to table "0296".
func (o FieldOutput) Table() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Field) *string { return v.Table }).(pulumi.StringPtrOutput)
}

// The type of this field. A Type with this name must be defined in an Hl7TypesConfig.
func (o FieldOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Field) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type FieldArrayOutput struct{ *pulumi.OutputState }

func (FieldArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Field)(nil)).Elem()
}

func (o FieldArrayOutput) ToFieldArrayOutput() FieldArrayOutput {
	return o
}

func (o FieldArrayOutput) ToFieldArrayOutputWithContext(ctx context.Context) FieldArrayOutput {
	return o
}

func (o FieldArrayOutput) Index(i pulumi.IntInput) FieldOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Field {
		return vs[0].([]Field)[vs[1].(int)]
	}).(FieldOutput)
}

// A (sub) field of a type.
type FieldResponse struct {
	// The maximum number of times this field can be repeated. 0 or -1 means unbounded.
	MaxOccurs int `pulumi:"maxOccurs"`
	// The minimum number of times this field must be present/repeated.
	MinOccurs int `pulumi:"minOccurs"`
	// The name of the field. For example, "PID-1" or just "1".
	Name string `pulumi:"name"`
	// The HL7v2 table this field refers to. For example, PID-15 (Patient's Primary Language) usually refers to table "0296".
	Table string `pulumi:"table"`
	// The type of this field. A Type with this name must be defined in an Hl7TypesConfig.
	Type string `pulumi:"type"`
}

// FieldResponseInput is an input type that accepts FieldResponseArgs and FieldResponseOutput values.
// You can construct a concrete instance of `FieldResponseInput` via:
//
//          FieldResponseArgs{...}
type FieldResponseInput interface {
	pulumi.Input

	ToFieldResponseOutput() FieldResponseOutput
	ToFieldResponseOutputWithContext(context.Context) FieldResponseOutput
}

// A (sub) field of a type.
type FieldResponseArgs struct {
	// The maximum number of times this field can be repeated. 0 or -1 means unbounded.
	MaxOccurs pulumi.IntInput `pulumi:"maxOccurs"`
	// The minimum number of times this field must be present/repeated.
	MinOccurs pulumi.IntInput `pulumi:"minOccurs"`
	// The name of the field. For example, "PID-1" or just "1".
	Name pulumi.StringInput `pulumi:"name"`
	// The HL7v2 table this field refers to. For example, PID-15 (Patient's Primary Language) usually refers to table "0296".
	Table pulumi.StringInput `pulumi:"table"`
	// The type of this field. A Type with this name must be defined in an Hl7TypesConfig.
	Type pulumi.StringInput `pulumi:"type"`
}

func (FieldResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FieldResponse)(nil)).Elem()
}

func (i FieldResponseArgs) ToFieldResponseOutput() FieldResponseOutput {
	return i.ToFieldResponseOutputWithContext(context.Background())
}

func (i FieldResponseArgs) ToFieldResponseOutputWithContext(ctx context.Context) FieldResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FieldResponseOutput)
}

// FieldResponseArrayInput is an input type that accepts FieldResponseArray and FieldResponseArrayOutput values.
// You can construct a concrete instance of `FieldResponseArrayInput` via:
//
//          FieldResponseArray{ FieldResponseArgs{...} }
type FieldResponseArrayInput interface {
	pulumi.Input

	ToFieldResponseArrayOutput() FieldResponseArrayOutput
	ToFieldResponseArrayOutputWithContext(context.Context) FieldResponseArrayOutput
}

type FieldResponseArray []FieldResponseInput

func (FieldResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FieldResponse)(nil)).Elem()
}

func (i FieldResponseArray) ToFieldResponseArrayOutput() FieldResponseArrayOutput {
	return i.ToFieldResponseArrayOutputWithContext(context.Background())
}

func (i FieldResponseArray) ToFieldResponseArrayOutputWithContext(ctx context.Context) FieldResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FieldResponseArrayOutput)
}

// A (sub) field of a type.
type FieldResponseOutput struct{ *pulumi.OutputState }

func (FieldResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FieldResponse)(nil)).Elem()
}

func (o FieldResponseOutput) ToFieldResponseOutput() FieldResponseOutput {
	return o
}

func (o FieldResponseOutput) ToFieldResponseOutputWithContext(ctx context.Context) FieldResponseOutput {
	return o
}

// The maximum number of times this field can be repeated. 0 or -1 means unbounded.
func (o FieldResponseOutput) MaxOccurs() pulumi.IntOutput {
	return o.ApplyT(func(v FieldResponse) int { return v.MaxOccurs }).(pulumi.IntOutput)
}

// The minimum number of times this field must be present/repeated.
func (o FieldResponseOutput) MinOccurs() pulumi.IntOutput {
	return o.ApplyT(func(v FieldResponse) int { return v.MinOccurs }).(pulumi.IntOutput)
}

// The name of the field. For example, "PID-1" or just "1".
func (o FieldResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v FieldResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The HL7v2 table this field refers to. For example, PID-15 (Patient's Primary Language) usually refers to table "0296".
func (o FieldResponseOutput) Table() pulumi.StringOutput {
	return o.ApplyT(func(v FieldResponse) string { return v.Table }).(pulumi.StringOutput)
}

// The type of this field. A Type with this name must be defined in an Hl7TypesConfig.
func (o FieldResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v FieldResponse) string { return v.Type }).(pulumi.StringOutput)
}

type FieldResponseArrayOutput struct{ *pulumi.OutputState }

func (FieldResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FieldResponse)(nil)).Elem()
}

func (o FieldResponseArrayOutput) ToFieldResponseArrayOutput() FieldResponseArrayOutput {
	return o
}

func (o FieldResponseArrayOutput) ToFieldResponseArrayOutputWithContext(ctx context.Context) FieldResponseArrayOutput {
	return o
}

func (o FieldResponseArrayOutput) Index(i pulumi.IntInput) FieldResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FieldResponse {
		return vs[0].([]FieldResponse)[vs[1].(int)]
	}).(FieldResponseOutput)
}

// Represents a user's consent in terms of the resources that can be accessed and under what conditions.
type GoogleCloudHealthcareV1beta1ConsentPolicy struct {
	// Required. The request conditions to meet to grant access. In addition to any supported comparison operators, authorization rules may have `IN` operator as well as at most 10 logical operators that are limited to `AND` (`&&`), `OR` (`||`).
	AuthorizationRule *Expr `pulumi:"authorizationRule"`
	// The resources that this policy applies to. A resource is a match if it matches all the attributes listed here. If empty, this policy applies to all User data mappings for the given user.
	ResourceAttributes []Attribute `pulumi:"resourceAttributes"`
}

// GoogleCloudHealthcareV1beta1ConsentPolicyInput is an input type that accepts GoogleCloudHealthcareV1beta1ConsentPolicyArgs and GoogleCloudHealthcareV1beta1ConsentPolicyOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1ConsentPolicyInput` via:
//
//          GoogleCloudHealthcareV1beta1ConsentPolicyArgs{...}
type GoogleCloudHealthcareV1beta1ConsentPolicyInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1ConsentPolicyOutput() GoogleCloudHealthcareV1beta1ConsentPolicyOutput
	ToGoogleCloudHealthcareV1beta1ConsentPolicyOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyOutput
}

// Represents a user's consent in terms of the resources that can be accessed and under what conditions.
type GoogleCloudHealthcareV1beta1ConsentPolicyArgs struct {
	// Required. The request conditions to meet to grant access. In addition to any supported comparison operators, authorization rules may have `IN` operator as well as at most 10 logical operators that are limited to `AND` (`&&`), `OR` (`||`).
	AuthorizationRule ExprPtrInput `pulumi:"authorizationRule"`
	// The resources that this policy applies to. A resource is a match if it matches all the attributes listed here. If empty, this policy applies to all User data mappings for the given user.
	ResourceAttributes AttributeArrayInput `pulumi:"resourceAttributes"`
}

func (GoogleCloudHealthcareV1beta1ConsentPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1ConsentPolicy)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1ConsentPolicyArgs) ToGoogleCloudHealthcareV1beta1ConsentPolicyOutput() GoogleCloudHealthcareV1beta1ConsentPolicyOutput {
	return i.ToGoogleCloudHealthcareV1beta1ConsentPolicyOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1ConsentPolicyArgs) ToGoogleCloudHealthcareV1beta1ConsentPolicyOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1ConsentPolicyOutput)
}

// GoogleCloudHealthcareV1beta1ConsentPolicyArrayInput is an input type that accepts GoogleCloudHealthcareV1beta1ConsentPolicyArray and GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1ConsentPolicyArrayInput` via:
//
//          GoogleCloudHealthcareV1beta1ConsentPolicyArray{ GoogleCloudHealthcareV1beta1ConsentPolicyArgs{...} }
type GoogleCloudHealthcareV1beta1ConsentPolicyArrayInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput() GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput
	ToGoogleCloudHealthcareV1beta1ConsentPolicyArrayOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput
}

type GoogleCloudHealthcareV1beta1ConsentPolicyArray []GoogleCloudHealthcareV1beta1ConsentPolicyInput

func (GoogleCloudHealthcareV1beta1ConsentPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1ConsentPolicy)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1ConsentPolicyArray) ToGoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput() GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput {
	return i.ToGoogleCloudHealthcareV1beta1ConsentPolicyArrayOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1ConsentPolicyArray) ToGoogleCloudHealthcareV1beta1ConsentPolicyArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput)
}

// Represents a user's consent in terms of the resources that can be accessed and under what conditions.
type GoogleCloudHealthcareV1beta1ConsentPolicyOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1ConsentPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1ConsentPolicy)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyOutput() GoogleCloudHealthcareV1beta1ConsentPolicyOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyOutput {
	return o
}

// Required. The request conditions to meet to grant access. In addition to any supported comparison operators, authorization rules may have `IN` operator as well as at most 10 logical operators that are limited to `AND` (`&&`), `OR` (`||`).
func (o GoogleCloudHealthcareV1beta1ConsentPolicyOutput) AuthorizationRule() ExprPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1ConsentPolicy) *Expr { return v.AuthorizationRule }).(ExprPtrOutput)
}

// The resources that this policy applies to. A resource is a match if it matches all the attributes listed here. If empty, this policy applies to all User data mappings for the given user.
func (o GoogleCloudHealthcareV1beta1ConsentPolicyOutput) ResourceAttributes() AttributeArrayOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1ConsentPolicy) []Attribute { return v.ResourceAttributes }).(AttributeArrayOutput)
}

type GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1ConsentPolicy)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput() GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput) Index(i pulumi.IntInput) GoogleCloudHealthcareV1beta1ConsentPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GoogleCloudHealthcareV1beta1ConsentPolicy {
		return vs[0].([]GoogleCloudHealthcareV1beta1ConsentPolicy)[vs[1].(int)]
	}).(GoogleCloudHealthcareV1beta1ConsentPolicyOutput)
}

// Represents a user's consent in terms of the resources that can be accessed and under what conditions.
type GoogleCloudHealthcareV1beta1ConsentPolicyResponse struct {
	// Required. The request conditions to meet to grant access. In addition to any supported comparison operators, authorization rules may have `IN` operator as well as at most 10 logical operators that are limited to `AND` (`&&`), `OR` (`||`).
	AuthorizationRule ExprResponse `pulumi:"authorizationRule"`
	// The resources that this policy applies to. A resource is a match if it matches all the attributes listed here. If empty, this policy applies to all User data mappings for the given user.
	ResourceAttributes []AttributeResponse `pulumi:"resourceAttributes"`
}

// GoogleCloudHealthcareV1beta1ConsentPolicyResponseInput is an input type that accepts GoogleCloudHealthcareV1beta1ConsentPolicyResponseArgs and GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1ConsentPolicyResponseInput` via:
//
//          GoogleCloudHealthcareV1beta1ConsentPolicyResponseArgs{...}
type GoogleCloudHealthcareV1beta1ConsentPolicyResponseInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput() GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput
	ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput
}

// Represents a user's consent in terms of the resources that can be accessed and under what conditions.
type GoogleCloudHealthcareV1beta1ConsentPolicyResponseArgs struct {
	// Required. The request conditions to meet to grant access. In addition to any supported comparison operators, authorization rules may have `IN` operator as well as at most 10 logical operators that are limited to `AND` (`&&`), `OR` (`||`).
	AuthorizationRule ExprResponseInput `pulumi:"authorizationRule"`
	// The resources that this policy applies to. A resource is a match if it matches all the attributes listed here. If empty, this policy applies to all User data mappings for the given user.
	ResourceAttributes AttributeResponseArrayInput `pulumi:"resourceAttributes"`
}

func (GoogleCloudHealthcareV1beta1ConsentPolicyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1ConsentPolicyResponse)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1ConsentPolicyResponseArgs) ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput() GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput {
	return i.ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1ConsentPolicyResponseArgs) ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput)
}

// GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayInput is an input type that accepts GoogleCloudHealthcareV1beta1ConsentPolicyResponseArray and GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayInput` via:
//
//          GoogleCloudHealthcareV1beta1ConsentPolicyResponseArray{ GoogleCloudHealthcareV1beta1ConsentPolicyResponseArgs{...} }
type GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput() GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput
	ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput
}

type GoogleCloudHealthcareV1beta1ConsentPolicyResponseArray []GoogleCloudHealthcareV1beta1ConsentPolicyResponseInput

func (GoogleCloudHealthcareV1beta1ConsentPolicyResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1ConsentPolicyResponse)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1ConsentPolicyResponseArray) ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput() GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput {
	return i.ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1ConsentPolicyResponseArray) ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput)
}

// Represents a user's consent in terms of the resources that can be accessed and under what conditions.
type GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1ConsentPolicyResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput() GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput {
	return o
}

// Required. The request conditions to meet to grant access. In addition to any supported comparison operators, authorization rules may have `IN` operator as well as at most 10 logical operators that are limited to `AND` (`&&`), `OR` (`||`).
func (o GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput) AuthorizationRule() ExprResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1ConsentPolicyResponse) ExprResponse { return v.AuthorizationRule }).(ExprResponseOutput)
}

// The resources that this policy applies to. A resource is a match if it matches all the attributes listed here. If empty, this policy applies to all User data mappings for the given user.
func (o GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput) ResourceAttributes() AttributeResponseArrayOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1ConsentPolicyResponse) []AttributeResponse {
		return v.ResourceAttributes
	}).(AttributeResponseArrayOutput)
}

type GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1ConsentPolicyResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput() GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput) Index(i pulumi.IntInput) GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GoogleCloudHealthcareV1beta1ConsentPolicyResponse {
		return vs[0].([]GoogleCloudHealthcareV1beta1ConsentPolicyResponse)[vs[1].(int)]
	}).(GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput)
}

// The BigQuery table where the server writes output.
type GoogleCloudHealthcareV1beta1DicomBigQueryDestination struct {
	// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
	Force *bool `pulumi:"force"`
	// BigQuery URI to a table, up to 2000 characters long, in the format `bq://projectId.bqDatasetId.tableId`
	TableUri *string `pulumi:"tableUri"`
	// Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
	WriteDisposition *string `pulumi:"writeDisposition"`
}

// GoogleCloudHealthcareV1beta1DicomBigQueryDestinationInput is an input type that accepts GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs and GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DicomBigQueryDestinationInput` via:
//
//          GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs{...}
type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput
	ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput
}

// The BigQuery table where the server writes output.
type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs struct {
	// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
	Force pulumi.BoolPtrInput `pulumi:"force"`
	// BigQuery URI to a table, up to 2000 characters long, in the format `bq://projectId.bqDatasetId.tableId`
	TableUri pulumi.StringPtrInput `pulumi:"tableUri"`
	// Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
	WriteDisposition pulumi.StringPtrInput `pulumi:"writeDisposition"`
}

func (GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomBigQueryDestination)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput {
	return i.ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput)
}

func (i GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return i.ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput).ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(ctx)
}

// GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrInput is an input type that accepts GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs, GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtr and GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrInput` via:
//
//          GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs{...}
//
//  or:
//
//          nil
type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput
	ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput
}

type googleCloudHealthcareV1beta1DicomBigQueryDestinationPtrType GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs

func GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtr(v *GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrInput {
	return (*googleCloudHealthcareV1beta1DicomBigQueryDestinationPtrType)(v)
}

func (*googleCloudHealthcareV1beta1DicomBigQueryDestinationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleCloudHealthcareV1beta1DicomBigQueryDestination)(nil)).Elem()
}

func (i *googleCloudHealthcareV1beta1DicomBigQueryDestinationPtrType) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return i.ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (i *googleCloudHealthcareV1beta1DicomBigQueryDestinationPtrType) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput)
}

// The BigQuery table where the server writes output.
type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomBigQueryDestination)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return o.ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomBigQueryDestination) *GoogleCloudHealthcareV1beta1DicomBigQueryDestination {
		return &v
	}).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput)
}

// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) Force() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomBigQueryDestination) *bool { return v.Force }).(pulumi.BoolPtrOutput)
}

// BigQuery URI to a table, up to 2000 characters long, in the format `bq://projectId.bqDatasetId.tableId`
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) TableUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomBigQueryDestination) *string { return v.TableUri }).(pulumi.StringPtrOutput)
}

// Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) WriteDisposition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomBigQueryDestination) *string { return v.WriteDisposition }).(pulumi.StringPtrOutput)
}

type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleCloudHealthcareV1beta1DicomBigQueryDestination)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput) Elem() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1DicomBigQueryDestination) GoogleCloudHealthcareV1beta1DicomBigQueryDestination {
		return *v
	}).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput)
}

// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput) Force() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1DicomBigQueryDestination) *bool {
		if v == nil {
			return nil
		}
		return v.Force
	}).(pulumi.BoolPtrOutput)
}

// BigQuery URI to a table, up to 2000 characters long, in the format `bq://projectId.bqDatasetId.tableId`
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput) TableUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1DicomBigQueryDestination) *string {
		if v == nil {
			return nil
		}
		return v.TableUri
	}).(pulumi.StringPtrOutput)
}

// Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput) WriteDisposition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1DicomBigQueryDestination) *string {
		if v == nil {
			return nil
		}
		return v.WriteDisposition
	}).(pulumi.StringPtrOutput)
}

// The BigQuery table where the server writes output.
type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse struct {
	// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
	Force bool `pulumi:"force"`
	// BigQuery URI to a table, up to 2000 characters long, in the format `bq://projectId.bqDatasetId.tableId`
	TableUri string `pulumi:"tableUri"`
	// Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
	WriteDisposition string `pulumi:"writeDisposition"`
}

// GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseInput is an input type that accepts GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseArgs and GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseInput` via:
//
//          GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseArgs{...}
type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput
	ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput
}

// The BigQuery table where the server writes output.
type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseArgs struct {
	// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
	Force pulumi.BoolInput `pulumi:"force"`
	// BigQuery URI to a table, up to 2000 characters long, in the format `bq://projectId.bqDatasetId.tableId`
	TableUri pulumi.StringInput `pulumi:"tableUri"`
	// Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
	WriteDisposition pulumi.StringInput `pulumi:"writeDisposition"`
}

func (GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseArgs) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput {
	return i.ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseArgs) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput)
}

// The BigQuery table where the server writes output.
type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput {
	return o
}

// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput) Force() pulumi.BoolOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse) bool { return v.Force }).(pulumi.BoolOutput)
}

// BigQuery URI to a table, up to 2000 characters long, in the format `bq://projectId.bqDatasetId.tableId`
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput) TableUri() pulumi.StringOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse) string { return v.TableUri }).(pulumi.StringOutput)
}

// Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput) WriteDisposition() pulumi.StringOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse) string { return v.WriteDisposition }).(pulumi.StringOutput)
}

// StreamConfig specifies configuration for a streaming DICOM export.
type GoogleCloudHealthcareV1beta1DicomStreamConfig struct {
	// Results are appended to this table. The server creates a new table in the given BigQuery dataset if the specified table does not exist. To enable the Cloud Healthcare API to write to your BigQuery table, you must give the Cloud Healthcare API service account the bigquery.dataEditor role. The service account is: `service-{PROJECT_NUMBER}@gcp-sa-healthcare.iam.gserviceaccount.com`. The PROJECT_NUMBER identifies the project that the DICOM store resides in. To get the project number, go to the Cloud Console Dashboard. It is recommended to not have a custom schema in the destination table which could conflict with the schema created by the Cloud Healthcare API. Instance deletions are not applied to the destination table. The destination's table schema will be automatically updated in case a new instance's data is incompatible with the current schema. The schema should not be updated manually as this can cause incompatibilies that cannot be resolved automatically. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any instance that generates more than 1 MB of BigQuery data will not be streamed. If an instance cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	BigqueryDestination *GoogleCloudHealthcareV1beta1DicomBigQueryDestination `pulumi:"bigqueryDestination"`
}

// GoogleCloudHealthcareV1beta1DicomStreamConfigInput is an input type that accepts GoogleCloudHealthcareV1beta1DicomStreamConfigArgs and GoogleCloudHealthcareV1beta1DicomStreamConfigOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DicomStreamConfigInput` via:
//
//          GoogleCloudHealthcareV1beta1DicomStreamConfigArgs{...}
type GoogleCloudHealthcareV1beta1DicomStreamConfigInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DicomStreamConfigOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigOutput
	ToGoogleCloudHealthcareV1beta1DicomStreamConfigOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigOutput
}

// StreamConfig specifies configuration for a streaming DICOM export.
type GoogleCloudHealthcareV1beta1DicomStreamConfigArgs struct {
	// Results are appended to this table. The server creates a new table in the given BigQuery dataset if the specified table does not exist. To enable the Cloud Healthcare API to write to your BigQuery table, you must give the Cloud Healthcare API service account the bigquery.dataEditor role. The service account is: `service-{PROJECT_NUMBER}@gcp-sa-healthcare.iam.gserviceaccount.com`. The PROJECT_NUMBER identifies the project that the DICOM store resides in. To get the project number, go to the Cloud Console Dashboard. It is recommended to not have a custom schema in the destination table which could conflict with the schema created by the Cloud Healthcare API. Instance deletions are not applied to the destination table. The destination's table schema will be automatically updated in case a new instance's data is incompatible with the current schema. The schema should not be updated manually as this can cause incompatibilies that cannot be resolved automatically. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any instance that generates more than 1 MB of BigQuery data will not be streamed. If an instance cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	BigqueryDestination GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrInput `pulumi:"bigqueryDestination"`
}

func (GoogleCloudHealthcareV1beta1DicomStreamConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomStreamConfig)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1DicomStreamConfigArgs) ToGoogleCloudHealthcareV1beta1DicomStreamConfigOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigOutput {
	return i.ToGoogleCloudHealthcareV1beta1DicomStreamConfigOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DicomStreamConfigArgs) ToGoogleCloudHealthcareV1beta1DicomStreamConfigOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DicomStreamConfigOutput)
}

// GoogleCloudHealthcareV1beta1DicomStreamConfigArrayInput is an input type that accepts GoogleCloudHealthcareV1beta1DicomStreamConfigArray and GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DicomStreamConfigArrayInput` via:
//
//          GoogleCloudHealthcareV1beta1DicomStreamConfigArray{ GoogleCloudHealthcareV1beta1DicomStreamConfigArgs{...} }
type GoogleCloudHealthcareV1beta1DicomStreamConfigArrayInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput
	ToGoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput
}

type GoogleCloudHealthcareV1beta1DicomStreamConfigArray []GoogleCloudHealthcareV1beta1DicomStreamConfigInput

func (GoogleCloudHealthcareV1beta1DicomStreamConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1DicomStreamConfig)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1DicomStreamConfigArray) ToGoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput {
	return i.ToGoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DicomStreamConfigArray) ToGoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput)
}

// StreamConfig specifies configuration for a streaming DICOM export.
type GoogleCloudHealthcareV1beta1DicomStreamConfigOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DicomStreamConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomStreamConfig)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigOutput {
	return o
}

// Results are appended to this table. The server creates a new table in the given BigQuery dataset if the specified table does not exist. To enable the Cloud Healthcare API to write to your BigQuery table, you must give the Cloud Healthcare API service account the bigquery.dataEditor role. The service account is: `service-{PROJECT_NUMBER}@gcp-sa-healthcare.iam.gserviceaccount.com`. The PROJECT_NUMBER identifies the project that the DICOM store resides in. To get the project number, go to the Cloud Console Dashboard. It is recommended to not have a custom schema in the destination table which could conflict with the schema created by the Cloud Healthcare API. Instance deletions are not applied to the destination table. The destination's table schema will be automatically updated in case a new instance's data is incompatible with the current schema. The schema should not be updated manually as this can cause incompatibilies that cannot be resolved automatically. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any instance that generates more than 1 MB of BigQuery data will not be streamed. If an instance cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
func (o GoogleCloudHealthcareV1beta1DicomStreamConfigOutput) BigqueryDestination() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomStreamConfig) *GoogleCloudHealthcareV1beta1DicomBigQueryDestination {
		return v.BigqueryDestination
	}).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput)
}

type GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1DicomStreamConfig)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput) Index(i pulumi.IntInput) GoogleCloudHealthcareV1beta1DicomStreamConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GoogleCloudHealthcareV1beta1DicomStreamConfig {
		return vs[0].([]GoogleCloudHealthcareV1beta1DicomStreamConfig)[vs[1].(int)]
	}).(GoogleCloudHealthcareV1beta1DicomStreamConfigOutput)
}

// StreamConfig specifies configuration for a streaming DICOM export.
type GoogleCloudHealthcareV1beta1DicomStreamConfigResponse struct {
	// Results are appended to this table. The server creates a new table in the given BigQuery dataset if the specified table does not exist. To enable the Cloud Healthcare API to write to your BigQuery table, you must give the Cloud Healthcare API service account the bigquery.dataEditor role. The service account is: `service-{PROJECT_NUMBER}@gcp-sa-healthcare.iam.gserviceaccount.com`. The PROJECT_NUMBER identifies the project that the DICOM store resides in. To get the project number, go to the Cloud Console Dashboard. It is recommended to not have a custom schema in the destination table which could conflict with the schema created by the Cloud Healthcare API. Instance deletions are not applied to the destination table. The destination's table schema will be automatically updated in case a new instance's data is incompatible with the current schema. The schema should not be updated manually as this can cause incompatibilies that cannot be resolved automatically. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any instance that generates more than 1 MB of BigQuery data will not be streamed. If an instance cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	BigqueryDestination GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse `pulumi:"bigqueryDestination"`
}

// GoogleCloudHealthcareV1beta1DicomStreamConfigResponseInput is an input type that accepts GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArgs and GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DicomStreamConfigResponseInput` via:
//
//          GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArgs{...}
type GoogleCloudHealthcareV1beta1DicomStreamConfigResponseInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput
	ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput
}

// StreamConfig specifies configuration for a streaming DICOM export.
type GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArgs struct {
	// Results are appended to this table. The server creates a new table in the given BigQuery dataset if the specified table does not exist. To enable the Cloud Healthcare API to write to your BigQuery table, you must give the Cloud Healthcare API service account the bigquery.dataEditor role. The service account is: `service-{PROJECT_NUMBER}@gcp-sa-healthcare.iam.gserviceaccount.com`. The PROJECT_NUMBER identifies the project that the DICOM store resides in. To get the project number, go to the Cloud Console Dashboard. It is recommended to not have a custom schema in the destination table which could conflict with the schema created by the Cloud Healthcare API. Instance deletions are not applied to the destination table. The destination's table schema will be automatically updated in case a new instance's data is incompatible with the current schema. The schema should not be updated manually as this can cause incompatibilies that cannot be resolved automatically. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any instance that generates more than 1 MB of BigQuery data will not be streamed. If an instance cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	BigqueryDestination GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseInput `pulumi:"bigqueryDestination"`
}

func (GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomStreamConfigResponse)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArgs) ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput {
	return i.ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArgs) ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput)
}

// GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayInput is an input type that accepts GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArray and GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayInput` via:
//
//          GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArray{ GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArgs{...} }
type GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput
	ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput
}

type GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArray []GoogleCloudHealthcareV1beta1DicomStreamConfigResponseInput

func (GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1DicomStreamConfigResponse)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArray) ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput {
	return i.ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArray) ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput)
}

// StreamConfig specifies configuration for a streaming DICOM export.
type GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomStreamConfigResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput {
	return o
}

// Results are appended to this table. The server creates a new table in the given BigQuery dataset if the specified table does not exist. To enable the Cloud Healthcare API to write to your BigQuery table, you must give the Cloud Healthcare API service account the bigquery.dataEditor role. The service account is: `service-{PROJECT_NUMBER}@gcp-sa-healthcare.iam.gserviceaccount.com`. The PROJECT_NUMBER identifies the project that the DICOM store resides in. To get the project number, go to the Cloud Console Dashboard. It is recommended to not have a custom schema in the destination table which could conflict with the schema created by the Cloud Healthcare API. Instance deletions are not applied to the destination table. The destination's table schema will be automatically updated in case a new instance's data is incompatible with the current schema. The schema should not be updated manually as this can cause incompatibilies that cannot be resolved automatically. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any instance that generates more than 1 MB of BigQuery data will not be streamed. If an instance cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
func (o GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput) BigqueryDestination() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomStreamConfigResponse) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse {
		return v.BigqueryDestination
	}).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput)
}

type GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1DicomStreamConfigResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput) Index(i pulumi.IntInput) GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GoogleCloudHealthcareV1beta1DicomStreamConfigResponse {
		return vs[0].([]GoogleCloudHealthcareV1beta1DicomStreamConfigResponse)[vs[1].(int)]
	}).(GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput)
}

// The configuration for exporting to BigQuery.
type GoogleCloudHealthcareV1beta1FhirBigQueryDestination struct {
	// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
	DatasetUri *string `pulumi:"datasetUri"`
	// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
	Force *bool `pulumi:"force"`
	// The configuration for the exported BigQuery schema.
	SchemaConfig *SchemaConfig `pulumi:"schemaConfig"`
	// Determines whether existing tables in the destination dataset are overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
	WriteDisposition *string `pulumi:"writeDisposition"`
}

// GoogleCloudHealthcareV1beta1FhirBigQueryDestinationInput is an input type that accepts GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs and GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1FhirBigQueryDestinationInput` via:
//
//          GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs{...}
type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput
	ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput
}

// The configuration for exporting to BigQuery.
type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs struct {
	// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
	DatasetUri pulumi.StringPtrInput `pulumi:"datasetUri"`
	// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
	Force pulumi.BoolPtrInput `pulumi:"force"`
	// The configuration for the exported BigQuery schema.
	SchemaConfig SchemaConfigPtrInput `pulumi:"schemaConfig"`
	// Determines whether existing tables in the destination dataset are overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
	WriteDisposition pulumi.StringPtrInput `pulumi:"writeDisposition"`
}

func (GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1FhirBigQueryDestination)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput {
	return i.ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput)
}

func (i GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return i.ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput).ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(ctx)
}

// GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrInput is an input type that accepts GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs, GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtr and GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrInput` via:
//
//          GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs{...}
//
//  or:
//
//          nil
type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput
	ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput
}

type googleCloudHealthcareV1beta1FhirBigQueryDestinationPtrType GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs

func GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtr(v *GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrInput {
	return (*googleCloudHealthcareV1beta1FhirBigQueryDestinationPtrType)(v)
}

func (*googleCloudHealthcareV1beta1FhirBigQueryDestinationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleCloudHealthcareV1beta1FhirBigQueryDestination)(nil)).Elem()
}

func (i *googleCloudHealthcareV1beta1FhirBigQueryDestinationPtrType) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return i.ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (i *googleCloudHealthcareV1beta1FhirBigQueryDestinationPtrType) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput)
}

// The configuration for exporting to BigQuery.
type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1FhirBigQueryDestination)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return o.ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *GoogleCloudHealthcareV1beta1FhirBigQueryDestination {
		return &v
	}).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput)
}

// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) DatasetUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *string { return v.DatasetUri }).(pulumi.StringPtrOutput)
}

// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) Force() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *bool { return v.Force }).(pulumi.BoolPtrOutput)
}

// The configuration for the exported BigQuery schema.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) SchemaConfig() SchemaConfigPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *SchemaConfig { return v.SchemaConfig }).(SchemaConfigPtrOutput)
}

// Determines whether existing tables in the destination dataset are overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) WriteDisposition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *string { return v.WriteDisposition }).(pulumi.StringPtrOutput)
}

type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleCloudHealthcareV1beta1FhirBigQueryDestination)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) Elem() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1FhirBigQueryDestination) GoogleCloudHealthcareV1beta1FhirBigQueryDestination {
		return *v
	}).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput)
}

// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) DatasetUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *string {
		if v == nil {
			return nil
		}
		return v.DatasetUri
	}).(pulumi.StringPtrOutput)
}

// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) Force() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *bool {
		if v == nil {
			return nil
		}
		return v.Force
	}).(pulumi.BoolPtrOutput)
}

// The configuration for the exported BigQuery schema.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) SchemaConfig() SchemaConfigPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *SchemaConfig {
		if v == nil {
			return nil
		}
		return v.SchemaConfig
	}).(SchemaConfigPtrOutput)
}

// Determines whether existing tables in the destination dataset are overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) WriteDisposition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *string {
		if v == nil {
			return nil
		}
		return v.WriteDisposition
	}).(pulumi.StringPtrOutput)
}

// The configuration for exporting to BigQuery.
type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse struct {
	// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
	DatasetUri string `pulumi:"datasetUri"`
	// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
	Force bool `pulumi:"force"`
	// The configuration for the exported BigQuery schema.
	SchemaConfig SchemaConfigResponse `pulumi:"schemaConfig"`
	// Determines whether existing tables in the destination dataset are overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
	WriteDisposition string `pulumi:"writeDisposition"`
}

// GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseInput is an input type that accepts GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseArgs and GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseInput` via:
//
//          GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseArgs{...}
type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput
	ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput
}

// The configuration for exporting to BigQuery.
type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseArgs struct {
	// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
	DatasetUri pulumi.StringInput `pulumi:"datasetUri"`
	// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
	Force pulumi.BoolInput `pulumi:"force"`
	// The configuration for the exported BigQuery schema.
	SchemaConfig SchemaConfigResponseInput `pulumi:"schemaConfig"`
	// Determines whether existing tables in the destination dataset are overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
	WriteDisposition pulumi.StringInput `pulumi:"writeDisposition"`
}

func (GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseArgs) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput {
	return i.ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseArgs) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput)
}

// The configuration for exporting to BigQuery.
type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput {
	return o
}

// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput) DatasetUri() pulumi.StringOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse) string { return v.DatasetUri }).(pulumi.StringOutput)
}

// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput) Force() pulumi.BoolOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse) bool { return v.Force }).(pulumi.BoolOutput)
}

// The configuration for the exported BigQuery schema.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput) SchemaConfig() SchemaConfigResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse) SchemaConfigResponse {
		return v.SchemaConfig
	}).(SchemaConfigResponseOutput)
}

// Determines whether existing tables in the destination dataset are overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput) WriteDisposition() pulumi.StringOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse) string { return v.WriteDisposition }).(pulumi.StringOutput)
}

// Root config message for HL7v2 schema. This contains a schema structure of groups and segments, and filters that determine which messages to apply the schema structure to.
type Hl7SchemaConfig struct {
	// Map from each HL7v2 message type and trigger event pair, such as ADT_A04, to its schema configuration root group.
	MessageSchemaConfigs map[string]string `pulumi:"messageSchemaConfigs"`
	// Each VersionSource is tested and only if they all match is the schema used for the message.
	Version []VersionSource `pulumi:"version"`
}

// Hl7SchemaConfigInput is an input type that accepts Hl7SchemaConfigArgs and Hl7SchemaConfigOutput values.
// You can construct a concrete instance of `Hl7SchemaConfigInput` via:
//
//          Hl7SchemaConfigArgs{...}
type Hl7SchemaConfigInput interface {
	pulumi.Input

	ToHl7SchemaConfigOutput() Hl7SchemaConfigOutput
	ToHl7SchemaConfigOutputWithContext(context.Context) Hl7SchemaConfigOutput
}

// Root config message for HL7v2 schema. This contains a schema structure of groups and segments, and filters that determine which messages to apply the schema structure to.
type Hl7SchemaConfigArgs struct {
	// Map from each HL7v2 message type and trigger event pair, such as ADT_A04, to its schema configuration root group.
	MessageSchemaConfigs pulumi.StringMapInput `pulumi:"messageSchemaConfigs"`
	// Each VersionSource is tested and only if they all match is the schema used for the message.
	Version VersionSourceArrayInput `pulumi:"version"`
}

func (Hl7SchemaConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7SchemaConfig)(nil)).Elem()
}

func (i Hl7SchemaConfigArgs) ToHl7SchemaConfigOutput() Hl7SchemaConfigOutput {
	return i.ToHl7SchemaConfigOutputWithContext(context.Background())
}

func (i Hl7SchemaConfigArgs) ToHl7SchemaConfigOutputWithContext(ctx context.Context) Hl7SchemaConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7SchemaConfigOutput)
}

// Hl7SchemaConfigArrayInput is an input type that accepts Hl7SchemaConfigArray and Hl7SchemaConfigArrayOutput values.
// You can construct a concrete instance of `Hl7SchemaConfigArrayInput` via:
//
//          Hl7SchemaConfigArray{ Hl7SchemaConfigArgs{...} }
type Hl7SchemaConfigArrayInput interface {
	pulumi.Input

	ToHl7SchemaConfigArrayOutput() Hl7SchemaConfigArrayOutput
	ToHl7SchemaConfigArrayOutputWithContext(context.Context) Hl7SchemaConfigArrayOutput
}

type Hl7SchemaConfigArray []Hl7SchemaConfigInput

func (Hl7SchemaConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7SchemaConfig)(nil)).Elem()
}

func (i Hl7SchemaConfigArray) ToHl7SchemaConfigArrayOutput() Hl7SchemaConfigArrayOutput {
	return i.ToHl7SchemaConfigArrayOutputWithContext(context.Background())
}

func (i Hl7SchemaConfigArray) ToHl7SchemaConfigArrayOutputWithContext(ctx context.Context) Hl7SchemaConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7SchemaConfigArrayOutput)
}

// Root config message for HL7v2 schema. This contains a schema structure of groups and segments, and filters that determine which messages to apply the schema structure to.
type Hl7SchemaConfigOutput struct{ *pulumi.OutputState }

func (Hl7SchemaConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7SchemaConfig)(nil)).Elem()
}

func (o Hl7SchemaConfigOutput) ToHl7SchemaConfigOutput() Hl7SchemaConfigOutput {
	return o
}

func (o Hl7SchemaConfigOutput) ToHl7SchemaConfigOutputWithContext(ctx context.Context) Hl7SchemaConfigOutput {
	return o
}

// Map from each HL7v2 message type and trigger event pair, such as ADT_A04, to its schema configuration root group.
func (o Hl7SchemaConfigOutput) MessageSchemaConfigs() pulumi.StringMapOutput {
	return o.ApplyT(func(v Hl7SchemaConfig) map[string]string { return v.MessageSchemaConfigs }).(pulumi.StringMapOutput)
}

// Each VersionSource is tested and only if they all match is the schema used for the message.
func (o Hl7SchemaConfigOutput) Version() VersionSourceArrayOutput {
	return o.ApplyT(func(v Hl7SchemaConfig) []VersionSource { return v.Version }).(VersionSourceArrayOutput)
}

type Hl7SchemaConfigArrayOutput struct{ *pulumi.OutputState }

func (Hl7SchemaConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7SchemaConfig)(nil)).Elem()
}

func (o Hl7SchemaConfigArrayOutput) ToHl7SchemaConfigArrayOutput() Hl7SchemaConfigArrayOutput {
	return o
}

func (o Hl7SchemaConfigArrayOutput) ToHl7SchemaConfigArrayOutputWithContext(ctx context.Context) Hl7SchemaConfigArrayOutput {
	return o
}

func (o Hl7SchemaConfigArrayOutput) Index(i pulumi.IntInput) Hl7SchemaConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Hl7SchemaConfig {
		return vs[0].([]Hl7SchemaConfig)[vs[1].(int)]
	}).(Hl7SchemaConfigOutput)
}

// Root config message for HL7v2 schema. This contains a schema structure of groups and segments, and filters that determine which messages to apply the schema structure to.
type Hl7SchemaConfigResponse struct {
	// Map from each HL7v2 message type and trigger event pair, such as ADT_A04, to its schema configuration root group.
	MessageSchemaConfigs map[string]string `pulumi:"messageSchemaConfigs"`
	// Each VersionSource is tested and only if they all match is the schema used for the message.
	Version []VersionSourceResponse `pulumi:"version"`
}

// Hl7SchemaConfigResponseInput is an input type that accepts Hl7SchemaConfigResponseArgs and Hl7SchemaConfigResponseOutput values.
// You can construct a concrete instance of `Hl7SchemaConfigResponseInput` via:
//
//          Hl7SchemaConfigResponseArgs{...}
type Hl7SchemaConfigResponseInput interface {
	pulumi.Input

	ToHl7SchemaConfigResponseOutput() Hl7SchemaConfigResponseOutput
	ToHl7SchemaConfigResponseOutputWithContext(context.Context) Hl7SchemaConfigResponseOutput
}

// Root config message for HL7v2 schema. This contains a schema structure of groups and segments, and filters that determine which messages to apply the schema structure to.
type Hl7SchemaConfigResponseArgs struct {
	// Map from each HL7v2 message type and trigger event pair, such as ADT_A04, to its schema configuration root group.
	MessageSchemaConfigs pulumi.StringMapInput `pulumi:"messageSchemaConfigs"`
	// Each VersionSource is tested and only if they all match is the schema used for the message.
	Version VersionSourceResponseArrayInput `pulumi:"version"`
}

func (Hl7SchemaConfigResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7SchemaConfigResponse)(nil)).Elem()
}

func (i Hl7SchemaConfigResponseArgs) ToHl7SchemaConfigResponseOutput() Hl7SchemaConfigResponseOutput {
	return i.ToHl7SchemaConfigResponseOutputWithContext(context.Background())
}

func (i Hl7SchemaConfigResponseArgs) ToHl7SchemaConfigResponseOutputWithContext(ctx context.Context) Hl7SchemaConfigResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7SchemaConfigResponseOutput)
}

// Hl7SchemaConfigResponseArrayInput is an input type that accepts Hl7SchemaConfigResponseArray and Hl7SchemaConfigResponseArrayOutput values.
// You can construct a concrete instance of `Hl7SchemaConfigResponseArrayInput` via:
//
//          Hl7SchemaConfigResponseArray{ Hl7SchemaConfigResponseArgs{...} }
type Hl7SchemaConfigResponseArrayInput interface {
	pulumi.Input

	ToHl7SchemaConfigResponseArrayOutput() Hl7SchemaConfigResponseArrayOutput
	ToHl7SchemaConfigResponseArrayOutputWithContext(context.Context) Hl7SchemaConfigResponseArrayOutput
}

type Hl7SchemaConfigResponseArray []Hl7SchemaConfigResponseInput

func (Hl7SchemaConfigResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7SchemaConfigResponse)(nil)).Elem()
}

func (i Hl7SchemaConfigResponseArray) ToHl7SchemaConfigResponseArrayOutput() Hl7SchemaConfigResponseArrayOutput {
	return i.ToHl7SchemaConfigResponseArrayOutputWithContext(context.Background())
}

func (i Hl7SchemaConfigResponseArray) ToHl7SchemaConfigResponseArrayOutputWithContext(ctx context.Context) Hl7SchemaConfigResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7SchemaConfigResponseArrayOutput)
}

// Root config message for HL7v2 schema. This contains a schema structure of groups and segments, and filters that determine which messages to apply the schema structure to.
type Hl7SchemaConfigResponseOutput struct{ *pulumi.OutputState }

func (Hl7SchemaConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7SchemaConfigResponse)(nil)).Elem()
}

func (o Hl7SchemaConfigResponseOutput) ToHl7SchemaConfigResponseOutput() Hl7SchemaConfigResponseOutput {
	return o
}

func (o Hl7SchemaConfigResponseOutput) ToHl7SchemaConfigResponseOutputWithContext(ctx context.Context) Hl7SchemaConfigResponseOutput {
	return o
}

// Map from each HL7v2 message type and trigger event pair, such as ADT_A04, to its schema configuration root group.
func (o Hl7SchemaConfigResponseOutput) MessageSchemaConfigs() pulumi.StringMapOutput {
	return o.ApplyT(func(v Hl7SchemaConfigResponse) map[string]string { return v.MessageSchemaConfigs }).(pulumi.StringMapOutput)
}

// Each VersionSource is tested and only if they all match is the schema used for the message.
func (o Hl7SchemaConfigResponseOutput) Version() VersionSourceResponseArrayOutput {
	return o.ApplyT(func(v Hl7SchemaConfigResponse) []VersionSourceResponse { return v.Version }).(VersionSourceResponseArrayOutput)
}

type Hl7SchemaConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (Hl7SchemaConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7SchemaConfigResponse)(nil)).Elem()
}

func (o Hl7SchemaConfigResponseArrayOutput) ToHl7SchemaConfigResponseArrayOutput() Hl7SchemaConfigResponseArrayOutput {
	return o
}

func (o Hl7SchemaConfigResponseArrayOutput) ToHl7SchemaConfigResponseArrayOutputWithContext(ctx context.Context) Hl7SchemaConfigResponseArrayOutput {
	return o
}

func (o Hl7SchemaConfigResponseArrayOutput) Index(i pulumi.IntInput) Hl7SchemaConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Hl7SchemaConfigResponse {
		return vs[0].([]Hl7SchemaConfigResponse)[vs[1].(int)]
	}).(Hl7SchemaConfigResponseOutput)
}

// Root config for HL7v2 datatype definitions for a specific HL7v2 version.
type Hl7TypesConfig struct {
	// The HL7v2 type definitions.
	Type []Type `pulumi:"type"`
	// The version selectors that this config applies to. A message must match ALL version sources to apply.
	Version []VersionSource `pulumi:"version"`
}

// Hl7TypesConfigInput is an input type that accepts Hl7TypesConfigArgs and Hl7TypesConfigOutput values.
// You can construct a concrete instance of `Hl7TypesConfigInput` via:
//
//          Hl7TypesConfigArgs{...}
type Hl7TypesConfigInput interface {
	pulumi.Input

	ToHl7TypesConfigOutput() Hl7TypesConfigOutput
	ToHl7TypesConfigOutputWithContext(context.Context) Hl7TypesConfigOutput
}

// Root config for HL7v2 datatype definitions for a specific HL7v2 version.
type Hl7TypesConfigArgs struct {
	// The HL7v2 type definitions.
	Type TypeArrayInput `pulumi:"type"`
	// The version selectors that this config applies to. A message must match ALL version sources to apply.
	Version VersionSourceArrayInput `pulumi:"version"`
}

func (Hl7TypesConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7TypesConfig)(nil)).Elem()
}

func (i Hl7TypesConfigArgs) ToHl7TypesConfigOutput() Hl7TypesConfigOutput {
	return i.ToHl7TypesConfigOutputWithContext(context.Background())
}

func (i Hl7TypesConfigArgs) ToHl7TypesConfigOutputWithContext(ctx context.Context) Hl7TypesConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7TypesConfigOutput)
}

// Hl7TypesConfigArrayInput is an input type that accepts Hl7TypesConfigArray and Hl7TypesConfigArrayOutput values.
// You can construct a concrete instance of `Hl7TypesConfigArrayInput` via:
//
//          Hl7TypesConfigArray{ Hl7TypesConfigArgs{...} }
type Hl7TypesConfigArrayInput interface {
	pulumi.Input

	ToHl7TypesConfigArrayOutput() Hl7TypesConfigArrayOutput
	ToHl7TypesConfigArrayOutputWithContext(context.Context) Hl7TypesConfigArrayOutput
}

type Hl7TypesConfigArray []Hl7TypesConfigInput

func (Hl7TypesConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7TypesConfig)(nil)).Elem()
}

func (i Hl7TypesConfigArray) ToHl7TypesConfigArrayOutput() Hl7TypesConfigArrayOutput {
	return i.ToHl7TypesConfigArrayOutputWithContext(context.Background())
}

func (i Hl7TypesConfigArray) ToHl7TypesConfigArrayOutputWithContext(ctx context.Context) Hl7TypesConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7TypesConfigArrayOutput)
}

// Root config for HL7v2 datatype definitions for a specific HL7v2 version.
type Hl7TypesConfigOutput struct{ *pulumi.OutputState }

func (Hl7TypesConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7TypesConfig)(nil)).Elem()
}

func (o Hl7TypesConfigOutput) ToHl7TypesConfigOutput() Hl7TypesConfigOutput {
	return o
}

func (o Hl7TypesConfigOutput) ToHl7TypesConfigOutputWithContext(ctx context.Context) Hl7TypesConfigOutput {
	return o
}

// The HL7v2 type definitions.
func (o Hl7TypesConfigOutput) Type() TypeArrayOutput {
	return o.ApplyT(func(v Hl7TypesConfig) []Type { return v.Type }).(TypeArrayOutput)
}

// The version selectors that this config applies to. A message must match ALL version sources to apply.
func (o Hl7TypesConfigOutput) Version() VersionSourceArrayOutput {
	return o.ApplyT(func(v Hl7TypesConfig) []VersionSource { return v.Version }).(VersionSourceArrayOutput)
}

type Hl7TypesConfigArrayOutput struct{ *pulumi.OutputState }

func (Hl7TypesConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7TypesConfig)(nil)).Elem()
}

func (o Hl7TypesConfigArrayOutput) ToHl7TypesConfigArrayOutput() Hl7TypesConfigArrayOutput {
	return o
}

func (o Hl7TypesConfigArrayOutput) ToHl7TypesConfigArrayOutputWithContext(ctx context.Context) Hl7TypesConfigArrayOutput {
	return o
}

func (o Hl7TypesConfigArrayOutput) Index(i pulumi.IntInput) Hl7TypesConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Hl7TypesConfig {
		return vs[0].([]Hl7TypesConfig)[vs[1].(int)]
	}).(Hl7TypesConfigOutput)
}

// Root config for HL7v2 datatype definitions for a specific HL7v2 version.
type Hl7TypesConfigResponse struct {
	// The HL7v2 type definitions.
	Type []TypeResponse `pulumi:"type"`
	// The version selectors that this config applies to. A message must match ALL version sources to apply.
	Version []VersionSourceResponse `pulumi:"version"`
}

// Hl7TypesConfigResponseInput is an input type that accepts Hl7TypesConfigResponseArgs and Hl7TypesConfigResponseOutput values.
// You can construct a concrete instance of `Hl7TypesConfigResponseInput` via:
//
//          Hl7TypesConfigResponseArgs{...}
type Hl7TypesConfigResponseInput interface {
	pulumi.Input

	ToHl7TypesConfigResponseOutput() Hl7TypesConfigResponseOutput
	ToHl7TypesConfigResponseOutputWithContext(context.Context) Hl7TypesConfigResponseOutput
}

// Root config for HL7v2 datatype definitions for a specific HL7v2 version.
type Hl7TypesConfigResponseArgs struct {
	// The HL7v2 type definitions.
	Type TypeResponseArrayInput `pulumi:"type"`
	// The version selectors that this config applies to. A message must match ALL version sources to apply.
	Version VersionSourceResponseArrayInput `pulumi:"version"`
}

func (Hl7TypesConfigResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7TypesConfigResponse)(nil)).Elem()
}

func (i Hl7TypesConfigResponseArgs) ToHl7TypesConfigResponseOutput() Hl7TypesConfigResponseOutput {
	return i.ToHl7TypesConfigResponseOutputWithContext(context.Background())
}

func (i Hl7TypesConfigResponseArgs) ToHl7TypesConfigResponseOutputWithContext(ctx context.Context) Hl7TypesConfigResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7TypesConfigResponseOutput)
}

// Hl7TypesConfigResponseArrayInput is an input type that accepts Hl7TypesConfigResponseArray and Hl7TypesConfigResponseArrayOutput values.
// You can construct a concrete instance of `Hl7TypesConfigResponseArrayInput` via:
//
//          Hl7TypesConfigResponseArray{ Hl7TypesConfigResponseArgs{...} }
type Hl7TypesConfigResponseArrayInput interface {
	pulumi.Input

	ToHl7TypesConfigResponseArrayOutput() Hl7TypesConfigResponseArrayOutput
	ToHl7TypesConfigResponseArrayOutputWithContext(context.Context) Hl7TypesConfigResponseArrayOutput
}

type Hl7TypesConfigResponseArray []Hl7TypesConfigResponseInput

func (Hl7TypesConfigResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7TypesConfigResponse)(nil)).Elem()
}

func (i Hl7TypesConfigResponseArray) ToHl7TypesConfigResponseArrayOutput() Hl7TypesConfigResponseArrayOutput {
	return i.ToHl7TypesConfigResponseArrayOutputWithContext(context.Background())
}

func (i Hl7TypesConfigResponseArray) ToHl7TypesConfigResponseArrayOutputWithContext(ctx context.Context) Hl7TypesConfigResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7TypesConfigResponseArrayOutput)
}

// Root config for HL7v2 datatype definitions for a specific HL7v2 version.
type Hl7TypesConfigResponseOutput struct{ *pulumi.OutputState }

func (Hl7TypesConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7TypesConfigResponse)(nil)).Elem()
}

func (o Hl7TypesConfigResponseOutput) ToHl7TypesConfigResponseOutput() Hl7TypesConfigResponseOutput {
	return o
}

func (o Hl7TypesConfigResponseOutput) ToHl7TypesConfigResponseOutputWithContext(ctx context.Context) Hl7TypesConfigResponseOutput {
	return o
}

// The HL7v2 type definitions.
func (o Hl7TypesConfigResponseOutput) Type() TypeResponseArrayOutput {
	return o.ApplyT(func(v Hl7TypesConfigResponse) []TypeResponse { return v.Type }).(TypeResponseArrayOutput)
}

// The version selectors that this config applies to. A message must match ALL version sources to apply.
func (o Hl7TypesConfigResponseOutput) Version() VersionSourceResponseArrayOutput {
	return o.ApplyT(func(v Hl7TypesConfigResponse) []VersionSourceResponse { return v.Version }).(VersionSourceResponseArrayOutput)
}

type Hl7TypesConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (Hl7TypesConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7TypesConfigResponse)(nil)).Elem()
}

func (o Hl7TypesConfigResponseArrayOutput) ToHl7TypesConfigResponseArrayOutput() Hl7TypesConfigResponseArrayOutput {
	return o
}

func (o Hl7TypesConfigResponseArrayOutput) ToHl7TypesConfigResponseArrayOutputWithContext(ctx context.Context) Hl7TypesConfigResponseArrayOutput {
	return o
}

func (o Hl7TypesConfigResponseArrayOutput) Index(i pulumi.IntInput) Hl7TypesConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Hl7TypesConfigResponse {
		return vs[0].([]Hl7TypesConfigResponse)[vs[1].(int)]
	}).(Hl7TypesConfigResponseOutput)
}

// Specifies where and whether to send notifications upon changes to a data store.
type Hl7V2NotificationConfig struct {
	// Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. The following syntax is available: * A string field value can be written as text inside quotation marks, for example `"query text"`. The only valid relational operation for text fields is equality (`=`), where text is searched within the field, rather than having the field be equal to the text. For example, `"Comment = great"` returns messages with `great` in the comment field. * A number field value can be written as an integer, a decimal, or an exponential. The valid relational operators for number fields are the equality operator (`=`), along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * A date field value must be written in `yyyy-mm-dd` form. Fields with date and time use the RFC3339 time format. Leading zeros are required for one-digit months and days. The valid relational operators for date fields are the equality operator (`=`) , along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * Multiple field query expressions can be combined in one query by adding `AND` or `OR` operators between the expressions. If a boolean operator appears within a quoted string, it is not treated as special, it's just another part of the character string to be matched. You can prepend the `NOT` operator to an expression to negate it. Fields/functions available for filtering are: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `create_time`, the timestamp when the message was created in the HL7v2 store. Use the RFC3339 time format for comparisons. For example, `create_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
	Filter *string `pulumi:"filter"`
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging).
	PubsubTopic *string `pulumi:"pubsubTopic"`
}

// Hl7V2NotificationConfigInput is an input type that accepts Hl7V2NotificationConfigArgs and Hl7V2NotificationConfigOutput values.
// You can construct a concrete instance of `Hl7V2NotificationConfigInput` via:
//
//          Hl7V2NotificationConfigArgs{...}
type Hl7V2NotificationConfigInput interface {
	pulumi.Input

	ToHl7V2NotificationConfigOutput() Hl7V2NotificationConfigOutput
	ToHl7V2NotificationConfigOutputWithContext(context.Context) Hl7V2NotificationConfigOutput
}

// Specifies where and whether to send notifications upon changes to a data store.
type Hl7V2NotificationConfigArgs struct {
	// Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. The following syntax is available: * A string field value can be written as text inside quotation marks, for example `"query text"`. The only valid relational operation for text fields is equality (`=`), where text is searched within the field, rather than having the field be equal to the text. For example, `"Comment = great"` returns messages with `great` in the comment field. * A number field value can be written as an integer, a decimal, or an exponential. The valid relational operators for number fields are the equality operator (`=`), along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * A date field value must be written in `yyyy-mm-dd` form. Fields with date and time use the RFC3339 time format. Leading zeros are required for one-digit months and days. The valid relational operators for date fields are the equality operator (`=`) , along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * Multiple field query expressions can be combined in one query by adding `AND` or `OR` operators between the expressions. If a boolean operator appears within a quoted string, it is not treated as special, it's just another part of the character string to be matched. You can prepend the `NOT` operator to an expression to negate it. Fields/functions available for filtering are: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `create_time`, the timestamp when the message was created in the HL7v2 store. Use the RFC3339 time format for comparisons. For example, `create_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
	Filter pulumi.StringPtrInput `pulumi:"filter"`
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging).
	PubsubTopic pulumi.StringPtrInput `pulumi:"pubsubTopic"`
}

func (Hl7V2NotificationConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7V2NotificationConfig)(nil)).Elem()
}

func (i Hl7V2NotificationConfigArgs) ToHl7V2NotificationConfigOutput() Hl7V2NotificationConfigOutput {
	return i.ToHl7V2NotificationConfigOutputWithContext(context.Background())
}

func (i Hl7V2NotificationConfigArgs) ToHl7V2NotificationConfigOutputWithContext(ctx context.Context) Hl7V2NotificationConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7V2NotificationConfigOutput)
}

// Hl7V2NotificationConfigArrayInput is an input type that accepts Hl7V2NotificationConfigArray and Hl7V2NotificationConfigArrayOutput values.
// You can construct a concrete instance of `Hl7V2NotificationConfigArrayInput` via:
//
//          Hl7V2NotificationConfigArray{ Hl7V2NotificationConfigArgs{...} }
type Hl7V2NotificationConfigArrayInput interface {
	pulumi.Input

	ToHl7V2NotificationConfigArrayOutput() Hl7V2NotificationConfigArrayOutput
	ToHl7V2NotificationConfigArrayOutputWithContext(context.Context) Hl7V2NotificationConfigArrayOutput
}

type Hl7V2NotificationConfigArray []Hl7V2NotificationConfigInput

func (Hl7V2NotificationConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7V2NotificationConfig)(nil)).Elem()
}

func (i Hl7V2NotificationConfigArray) ToHl7V2NotificationConfigArrayOutput() Hl7V2NotificationConfigArrayOutput {
	return i.ToHl7V2NotificationConfigArrayOutputWithContext(context.Background())
}

func (i Hl7V2NotificationConfigArray) ToHl7V2NotificationConfigArrayOutputWithContext(ctx context.Context) Hl7V2NotificationConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7V2NotificationConfigArrayOutput)
}

// Specifies where and whether to send notifications upon changes to a data store.
type Hl7V2NotificationConfigOutput struct{ *pulumi.OutputState }

func (Hl7V2NotificationConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7V2NotificationConfig)(nil)).Elem()
}

func (o Hl7V2NotificationConfigOutput) ToHl7V2NotificationConfigOutput() Hl7V2NotificationConfigOutput {
	return o
}

func (o Hl7V2NotificationConfigOutput) ToHl7V2NotificationConfigOutputWithContext(ctx context.Context) Hl7V2NotificationConfigOutput {
	return o
}

// Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. The following syntax is available: * A string field value can be written as text inside quotation marks, for example `"query text"`. The only valid relational operation for text fields is equality (`=`), where text is searched within the field, rather than having the field be equal to the text. For example, `"Comment = great"` returns messages with `great` in the comment field. * A number field value can be written as an integer, a decimal, or an exponential. The valid relational operators for number fields are the equality operator (`=`), along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * A date field value must be written in `yyyy-mm-dd` form. Fields with date and time use the RFC3339 time format. Leading zeros are required for one-digit months and days. The valid relational operators for date fields are the equality operator (`=`) , along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * Multiple field query expressions can be combined in one query by adding `AND` or `OR` operators between the expressions. If a boolean operator appears within a quoted string, it is not treated as special, it's just another part of the character string to be matched. You can prepend the `NOT` operator to an expression to negate it. Fields/functions available for filtering are: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `create_time`, the timestamp when the message was created in the HL7v2 store. Use the RFC3339 time format for comparisons. For example, `create_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
func (o Hl7V2NotificationConfigOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Hl7V2NotificationConfig) *string { return v.Filter }).(pulumi.StringPtrOutput)
}

// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging).
func (o Hl7V2NotificationConfigOutput) PubsubTopic() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Hl7V2NotificationConfig) *string { return v.PubsubTopic }).(pulumi.StringPtrOutput)
}

type Hl7V2NotificationConfigArrayOutput struct{ *pulumi.OutputState }

func (Hl7V2NotificationConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7V2NotificationConfig)(nil)).Elem()
}

func (o Hl7V2NotificationConfigArrayOutput) ToHl7V2NotificationConfigArrayOutput() Hl7V2NotificationConfigArrayOutput {
	return o
}

func (o Hl7V2NotificationConfigArrayOutput) ToHl7V2NotificationConfigArrayOutputWithContext(ctx context.Context) Hl7V2NotificationConfigArrayOutput {
	return o
}

func (o Hl7V2NotificationConfigArrayOutput) Index(i pulumi.IntInput) Hl7V2NotificationConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Hl7V2NotificationConfig {
		return vs[0].([]Hl7V2NotificationConfig)[vs[1].(int)]
	}).(Hl7V2NotificationConfigOutput)
}

// Specifies where and whether to send notifications upon changes to a data store.
type Hl7V2NotificationConfigResponse struct {
	// Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. The following syntax is available: * A string field value can be written as text inside quotation marks, for example `"query text"`. The only valid relational operation for text fields is equality (`=`), where text is searched within the field, rather than having the field be equal to the text. For example, `"Comment = great"` returns messages with `great` in the comment field. * A number field value can be written as an integer, a decimal, or an exponential. The valid relational operators for number fields are the equality operator (`=`), along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * A date field value must be written in `yyyy-mm-dd` form. Fields with date and time use the RFC3339 time format. Leading zeros are required for one-digit months and days. The valid relational operators for date fields are the equality operator (`=`) , along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * Multiple field query expressions can be combined in one query by adding `AND` or `OR` operators between the expressions. If a boolean operator appears within a quoted string, it is not treated as special, it's just another part of the character string to be matched. You can prepend the `NOT` operator to an expression to negate it. Fields/functions available for filtering are: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `create_time`, the timestamp when the message was created in the HL7v2 store. Use the RFC3339 time format for comparisons. For example, `create_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
	Filter string `pulumi:"filter"`
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging).
	PubsubTopic string `pulumi:"pubsubTopic"`
}

// Hl7V2NotificationConfigResponseInput is an input type that accepts Hl7V2NotificationConfigResponseArgs and Hl7V2NotificationConfigResponseOutput values.
// You can construct a concrete instance of `Hl7V2NotificationConfigResponseInput` via:
//
//          Hl7V2NotificationConfigResponseArgs{...}
type Hl7V2NotificationConfigResponseInput interface {
	pulumi.Input

	ToHl7V2NotificationConfigResponseOutput() Hl7V2NotificationConfigResponseOutput
	ToHl7V2NotificationConfigResponseOutputWithContext(context.Context) Hl7V2NotificationConfigResponseOutput
}

// Specifies where and whether to send notifications upon changes to a data store.
type Hl7V2NotificationConfigResponseArgs struct {
	// Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. The following syntax is available: * A string field value can be written as text inside quotation marks, for example `"query text"`. The only valid relational operation for text fields is equality (`=`), where text is searched within the field, rather than having the field be equal to the text. For example, `"Comment = great"` returns messages with `great` in the comment field. * A number field value can be written as an integer, a decimal, or an exponential. The valid relational operators for number fields are the equality operator (`=`), along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * A date field value must be written in `yyyy-mm-dd` form. Fields with date and time use the RFC3339 time format. Leading zeros are required for one-digit months and days. The valid relational operators for date fields are the equality operator (`=`) , along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * Multiple field query expressions can be combined in one query by adding `AND` or `OR` operators between the expressions. If a boolean operator appears within a quoted string, it is not treated as special, it's just another part of the character string to be matched. You can prepend the `NOT` operator to an expression to negate it. Fields/functions available for filtering are: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `create_time`, the timestamp when the message was created in the HL7v2 store. Use the RFC3339 time format for comparisons. For example, `create_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
	Filter pulumi.StringInput `pulumi:"filter"`
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging).
	PubsubTopic pulumi.StringInput `pulumi:"pubsubTopic"`
}

func (Hl7V2NotificationConfigResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7V2NotificationConfigResponse)(nil)).Elem()
}

func (i Hl7V2NotificationConfigResponseArgs) ToHl7V2NotificationConfigResponseOutput() Hl7V2NotificationConfigResponseOutput {
	return i.ToHl7V2NotificationConfigResponseOutputWithContext(context.Background())
}

func (i Hl7V2NotificationConfigResponseArgs) ToHl7V2NotificationConfigResponseOutputWithContext(ctx context.Context) Hl7V2NotificationConfigResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7V2NotificationConfigResponseOutput)
}

// Hl7V2NotificationConfigResponseArrayInput is an input type that accepts Hl7V2NotificationConfigResponseArray and Hl7V2NotificationConfigResponseArrayOutput values.
// You can construct a concrete instance of `Hl7V2NotificationConfigResponseArrayInput` via:
//
//          Hl7V2NotificationConfigResponseArray{ Hl7V2NotificationConfigResponseArgs{...} }
type Hl7V2NotificationConfigResponseArrayInput interface {
	pulumi.Input

	ToHl7V2NotificationConfigResponseArrayOutput() Hl7V2NotificationConfigResponseArrayOutput
	ToHl7V2NotificationConfigResponseArrayOutputWithContext(context.Context) Hl7V2NotificationConfigResponseArrayOutput
}

type Hl7V2NotificationConfigResponseArray []Hl7V2NotificationConfigResponseInput

func (Hl7V2NotificationConfigResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7V2NotificationConfigResponse)(nil)).Elem()
}

func (i Hl7V2NotificationConfigResponseArray) ToHl7V2NotificationConfigResponseArrayOutput() Hl7V2NotificationConfigResponseArrayOutput {
	return i.ToHl7V2NotificationConfigResponseArrayOutputWithContext(context.Background())
}

func (i Hl7V2NotificationConfigResponseArray) ToHl7V2NotificationConfigResponseArrayOutputWithContext(ctx context.Context) Hl7V2NotificationConfigResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7V2NotificationConfigResponseArrayOutput)
}

// Specifies where and whether to send notifications upon changes to a data store.
type Hl7V2NotificationConfigResponseOutput struct{ *pulumi.OutputState }

func (Hl7V2NotificationConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7V2NotificationConfigResponse)(nil)).Elem()
}

func (o Hl7V2NotificationConfigResponseOutput) ToHl7V2NotificationConfigResponseOutput() Hl7V2NotificationConfigResponseOutput {
	return o
}

func (o Hl7V2NotificationConfigResponseOutput) ToHl7V2NotificationConfigResponseOutputWithContext(ctx context.Context) Hl7V2NotificationConfigResponseOutput {
	return o
}

// Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. The following syntax is available: * A string field value can be written as text inside quotation marks, for example `"query text"`. The only valid relational operation for text fields is equality (`=`), where text is searched within the field, rather than having the field be equal to the text. For example, `"Comment = great"` returns messages with `great` in the comment field. * A number field value can be written as an integer, a decimal, or an exponential. The valid relational operators for number fields are the equality operator (`=`), along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * A date field value must be written in `yyyy-mm-dd` form. Fields with date and time use the RFC3339 time format. Leading zeros are required for one-digit months and days. The valid relational operators for date fields are the equality operator (`=`) , along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * Multiple field query expressions can be combined in one query by adding `AND` or `OR` operators between the expressions. If a boolean operator appears within a quoted string, it is not treated as special, it's just another part of the character string to be matched. You can prepend the `NOT` operator to an expression to negate it. Fields/functions available for filtering are: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `create_time`, the timestamp when the message was created in the HL7v2 store. Use the RFC3339 time format for comparisons. For example, `create_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
func (o Hl7V2NotificationConfigResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v Hl7V2NotificationConfigResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging).
func (o Hl7V2NotificationConfigResponseOutput) PubsubTopic() pulumi.StringOutput {
	return o.ApplyT(func(v Hl7V2NotificationConfigResponse) string { return v.PubsubTopic }).(pulumi.StringOutput)
}

type Hl7V2NotificationConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (Hl7V2NotificationConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7V2NotificationConfigResponse)(nil)).Elem()
}

func (o Hl7V2NotificationConfigResponseArrayOutput) ToHl7V2NotificationConfigResponseArrayOutput() Hl7V2NotificationConfigResponseArrayOutput {
	return o
}

func (o Hl7V2NotificationConfigResponseArrayOutput) ToHl7V2NotificationConfigResponseArrayOutputWithContext(ctx context.Context) Hl7V2NotificationConfigResponseArrayOutput {
	return o
}

func (o Hl7V2NotificationConfigResponseArrayOutput) Index(i pulumi.IntInput) Hl7V2NotificationConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Hl7V2NotificationConfigResponse {
		return vs[0].([]Hl7V2NotificationConfigResponse)[vs[1].(int)]
	}).(Hl7V2NotificationConfigResponseOutput)
}

// Raw bytes representing consent artifact content.
type Image struct {
	// Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
	GcsUri *string `pulumi:"gcsUri"`
	// Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
	RawBytes *string `pulumi:"rawBytes"`
}

// ImageInput is an input type that accepts ImageArgs and ImageOutput values.
// You can construct a concrete instance of `ImageInput` via:
//
//          ImageArgs{...}
type ImageInput interface {
	pulumi.Input

	ToImageOutput() ImageOutput
	ToImageOutputWithContext(context.Context) ImageOutput
}

// Raw bytes representing consent artifact content.
type ImageArgs struct {
	// Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
	GcsUri pulumi.StringPtrInput `pulumi:"gcsUri"`
	// Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
	RawBytes pulumi.StringPtrInput `pulumi:"rawBytes"`
}

func (ImageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Image)(nil)).Elem()
}

func (i ImageArgs) ToImageOutput() ImageOutput {
	return i.ToImageOutputWithContext(context.Background())
}

func (i ImageArgs) ToImageOutputWithContext(ctx context.Context) ImageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageOutput)
}

func (i ImageArgs) ToImagePtrOutput() ImagePtrOutput {
	return i.ToImagePtrOutputWithContext(context.Background())
}

func (i ImageArgs) ToImagePtrOutputWithContext(ctx context.Context) ImagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageOutput).ToImagePtrOutputWithContext(ctx)
}

// ImagePtrInput is an input type that accepts ImageArgs, ImagePtr and ImagePtrOutput values.
// You can construct a concrete instance of `ImagePtrInput` via:
//
//          ImageArgs{...}
//
//  or:
//
//          nil
type ImagePtrInput interface {
	pulumi.Input

	ToImagePtrOutput() ImagePtrOutput
	ToImagePtrOutputWithContext(context.Context) ImagePtrOutput
}

type imagePtrType ImageArgs

func ImagePtr(v *ImageArgs) ImagePtrInput {
	return (*imagePtrType)(v)
}

func (*imagePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Image)(nil)).Elem()
}

func (i *imagePtrType) ToImagePtrOutput() ImagePtrOutput {
	return i.ToImagePtrOutputWithContext(context.Background())
}

func (i *imagePtrType) ToImagePtrOutputWithContext(ctx context.Context) ImagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImagePtrOutput)
}

// ImageArrayInput is an input type that accepts ImageArray and ImageArrayOutput values.
// You can construct a concrete instance of `ImageArrayInput` via:
//
//          ImageArray{ ImageArgs{...} }
type ImageArrayInput interface {
	pulumi.Input

	ToImageArrayOutput() ImageArrayOutput
	ToImageArrayOutputWithContext(context.Context) ImageArrayOutput
}

type ImageArray []ImageInput

func (ImageArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Image)(nil)).Elem()
}

func (i ImageArray) ToImageArrayOutput() ImageArrayOutput {
	return i.ToImageArrayOutputWithContext(context.Background())
}

func (i ImageArray) ToImageArrayOutputWithContext(ctx context.Context) ImageArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageArrayOutput)
}

// Raw bytes representing consent artifact content.
type ImageOutput struct{ *pulumi.OutputState }

func (ImageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Image)(nil)).Elem()
}

func (o ImageOutput) ToImageOutput() ImageOutput {
	return o
}

func (o ImageOutput) ToImageOutputWithContext(ctx context.Context) ImageOutput {
	return o
}

func (o ImageOutput) ToImagePtrOutput() ImagePtrOutput {
	return o.ToImagePtrOutputWithContext(context.Background())
}

func (o ImageOutput) ToImagePtrOutputWithContext(ctx context.Context) ImagePtrOutput {
	return o.ApplyT(func(v Image) *Image {
		return &v
	}).(ImagePtrOutput)
}

// Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
func (o ImageOutput) GcsUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Image) *string { return v.GcsUri }).(pulumi.StringPtrOutput)
}

// Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
func (o ImageOutput) RawBytes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Image) *string { return v.RawBytes }).(pulumi.StringPtrOutput)
}

type ImagePtrOutput struct{ *pulumi.OutputState }

func (ImagePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Image)(nil)).Elem()
}

func (o ImagePtrOutput) ToImagePtrOutput() ImagePtrOutput {
	return o
}

func (o ImagePtrOutput) ToImagePtrOutputWithContext(ctx context.Context) ImagePtrOutput {
	return o
}

func (o ImagePtrOutput) Elem() ImageOutput {
	return o.ApplyT(func(v *Image) Image { return *v }).(ImageOutput)
}

// Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
func (o ImagePtrOutput) GcsUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Image) *string {
		if v == nil {
			return nil
		}
		return v.GcsUri
	}).(pulumi.StringPtrOutput)
}

// Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
func (o ImagePtrOutput) RawBytes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Image) *string {
		if v == nil {
			return nil
		}
		return v.RawBytes
	}).(pulumi.StringPtrOutput)
}

type ImageArrayOutput struct{ *pulumi.OutputState }

func (ImageArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Image)(nil)).Elem()
}

func (o ImageArrayOutput) ToImageArrayOutput() ImageArrayOutput {
	return o
}

func (o ImageArrayOutput) ToImageArrayOutputWithContext(ctx context.Context) ImageArrayOutput {
	return o
}

func (o ImageArrayOutput) Index(i pulumi.IntInput) ImageOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Image {
		return vs[0].([]Image)[vs[1].(int)]
	}).(ImageOutput)
}

// Image annotation.
type ImageAnnotation struct {
	// The list of polygons outlining the sensitive regions in the image.
	BoundingPolys []BoundingPoly `pulumi:"boundingPolys"`
	// 0-based index of the image frame. For example, an image frame in a DICOM instance.
	FrameIndex *int `pulumi:"frameIndex"`
}

// ImageAnnotationInput is an input type that accepts ImageAnnotationArgs and ImageAnnotationOutput values.
// You can construct a concrete instance of `ImageAnnotationInput` via:
//
//          ImageAnnotationArgs{...}
type ImageAnnotationInput interface {
	pulumi.Input

	ToImageAnnotationOutput() ImageAnnotationOutput
	ToImageAnnotationOutputWithContext(context.Context) ImageAnnotationOutput
}

// Image annotation.
type ImageAnnotationArgs struct {
	// The list of polygons outlining the sensitive regions in the image.
	BoundingPolys BoundingPolyArrayInput `pulumi:"boundingPolys"`
	// 0-based index of the image frame. For example, an image frame in a DICOM instance.
	FrameIndex pulumi.IntPtrInput `pulumi:"frameIndex"`
}

func (ImageAnnotationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageAnnotation)(nil)).Elem()
}

func (i ImageAnnotationArgs) ToImageAnnotationOutput() ImageAnnotationOutput {
	return i.ToImageAnnotationOutputWithContext(context.Background())
}

func (i ImageAnnotationArgs) ToImageAnnotationOutputWithContext(ctx context.Context) ImageAnnotationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageAnnotationOutput)
}

func (i ImageAnnotationArgs) ToImageAnnotationPtrOutput() ImageAnnotationPtrOutput {
	return i.ToImageAnnotationPtrOutputWithContext(context.Background())
}

func (i ImageAnnotationArgs) ToImageAnnotationPtrOutputWithContext(ctx context.Context) ImageAnnotationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageAnnotationOutput).ToImageAnnotationPtrOutputWithContext(ctx)
}

// ImageAnnotationPtrInput is an input type that accepts ImageAnnotationArgs, ImageAnnotationPtr and ImageAnnotationPtrOutput values.
// You can construct a concrete instance of `ImageAnnotationPtrInput` via:
//
//          ImageAnnotationArgs{...}
//
//  or:
//
//          nil
type ImageAnnotationPtrInput interface {
	pulumi.Input

	ToImageAnnotationPtrOutput() ImageAnnotationPtrOutput
	ToImageAnnotationPtrOutputWithContext(context.Context) ImageAnnotationPtrOutput
}

type imageAnnotationPtrType ImageAnnotationArgs

func ImageAnnotationPtr(v *ImageAnnotationArgs) ImageAnnotationPtrInput {
	return (*imageAnnotationPtrType)(v)
}

func (*imageAnnotationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ImageAnnotation)(nil)).Elem()
}

func (i *imageAnnotationPtrType) ToImageAnnotationPtrOutput() ImageAnnotationPtrOutput {
	return i.ToImageAnnotationPtrOutputWithContext(context.Background())
}

func (i *imageAnnotationPtrType) ToImageAnnotationPtrOutputWithContext(ctx context.Context) ImageAnnotationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageAnnotationPtrOutput)
}

// Image annotation.
type ImageAnnotationOutput struct{ *pulumi.OutputState }

func (ImageAnnotationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageAnnotation)(nil)).Elem()
}

func (o ImageAnnotationOutput) ToImageAnnotationOutput() ImageAnnotationOutput {
	return o
}

func (o ImageAnnotationOutput) ToImageAnnotationOutputWithContext(ctx context.Context) ImageAnnotationOutput {
	return o
}

func (o ImageAnnotationOutput) ToImageAnnotationPtrOutput() ImageAnnotationPtrOutput {
	return o.ToImageAnnotationPtrOutputWithContext(context.Background())
}

func (o ImageAnnotationOutput) ToImageAnnotationPtrOutputWithContext(ctx context.Context) ImageAnnotationPtrOutput {
	return o.ApplyT(func(v ImageAnnotation) *ImageAnnotation {
		return &v
	}).(ImageAnnotationPtrOutput)
}

// The list of polygons outlining the sensitive regions in the image.
func (o ImageAnnotationOutput) BoundingPolys() BoundingPolyArrayOutput {
	return o.ApplyT(func(v ImageAnnotation) []BoundingPoly { return v.BoundingPolys }).(BoundingPolyArrayOutput)
}

// 0-based index of the image frame. For example, an image frame in a DICOM instance.
func (o ImageAnnotationOutput) FrameIndex() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ImageAnnotation) *int { return v.FrameIndex }).(pulumi.IntPtrOutput)
}

type ImageAnnotationPtrOutput struct{ *pulumi.OutputState }

func (ImageAnnotationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ImageAnnotation)(nil)).Elem()
}

func (o ImageAnnotationPtrOutput) ToImageAnnotationPtrOutput() ImageAnnotationPtrOutput {
	return o
}

func (o ImageAnnotationPtrOutput) ToImageAnnotationPtrOutputWithContext(ctx context.Context) ImageAnnotationPtrOutput {
	return o
}

func (o ImageAnnotationPtrOutput) Elem() ImageAnnotationOutput {
	return o.ApplyT(func(v *ImageAnnotation) ImageAnnotation { return *v }).(ImageAnnotationOutput)
}

// The list of polygons outlining the sensitive regions in the image.
func (o ImageAnnotationPtrOutput) BoundingPolys() BoundingPolyArrayOutput {
	return o.ApplyT(func(v *ImageAnnotation) []BoundingPoly {
		if v == nil {
			return nil
		}
		return v.BoundingPolys
	}).(BoundingPolyArrayOutput)
}

// 0-based index of the image frame. For example, an image frame in a DICOM instance.
func (o ImageAnnotationPtrOutput) FrameIndex() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ImageAnnotation) *int {
		if v == nil {
			return nil
		}
		return v.FrameIndex
	}).(pulumi.IntPtrOutput)
}

// Image annotation.
type ImageAnnotationResponse struct {
	// The list of polygons outlining the sensitive regions in the image.
	BoundingPolys []BoundingPolyResponse `pulumi:"boundingPolys"`
	// 0-based index of the image frame. For example, an image frame in a DICOM instance.
	FrameIndex int `pulumi:"frameIndex"`
}

// ImageAnnotationResponseInput is an input type that accepts ImageAnnotationResponseArgs and ImageAnnotationResponseOutput values.
// You can construct a concrete instance of `ImageAnnotationResponseInput` via:
//
//          ImageAnnotationResponseArgs{...}
type ImageAnnotationResponseInput interface {
	pulumi.Input

	ToImageAnnotationResponseOutput() ImageAnnotationResponseOutput
	ToImageAnnotationResponseOutputWithContext(context.Context) ImageAnnotationResponseOutput
}

// Image annotation.
type ImageAnnotationResponseArgs struct {
	// The list of polygons outlining the sensitive regions in the image.
	BoundingPolys BoundingPolyResponseArrayInput `pulumi:"boundingPolys"`
	// 0-based index of the image frame. For example, an image frame in a DICOM instance.
	FrameIndex pulumi.IntInput `pulumi:"frameIndex"`
}

func (ImageAnnotationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageAnnotationResponse)(nil)).Elem()
}

func (i ImageAnnotationResponseArgs) ToImageAnnotationResponseOutput() ImageAnnotationResponseOutput {
	return i.ToImageAnnotationResponseOutputWithContext(context.Background())
}

func (i ImageAnnotationResponseArgs) ToImageAnnotationResponseOutputWithContext(ctx context.Context) ImageAnnotationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageAnnotationResponseOutput)
}

func (i ImageAnnotationResponseArgs) ToImageAnnotationResponsePtrOutput() ImageAnnotationResponsePtrOutput {
	return i.ToImageAnnotationResponsePtrOutputWithContext(context.Background())
}

func (i ImageAnnotationResponseArgs) ToImageAnnotationResponsePtrOutputWithContext(ctx context.Context) ImageAnnotationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageAnnotationResponseOutput).ToImageAnnotationResponsePtrOutputWithContext(ctx)
}

// ImageAnnotationResponsePtrInput is an input type that accepts ImageAnnotationResponseArgs, ImageAnnotationResponsePtr and ImageAnnotationResponsePtrOutput values.
// You can construct a concrete instance of `ImageAnnotationResponsePtrInput` via:
//
//          ImageAnnotationResponseArgs{...}
//
//  or:
//
//          nil
type ImageAnnotationResponsePtrInput interface {
	pulumi.Input

	ToImageAnnotationResponsePtrOutput() ImageAnnotationResponsePtrOutput
	ToImageAnnotationResponsePtrOutputWithContext(context.Context) ImageAnnotationResponsePtrOutput
}

type imageAnnotationResponsePtrType ImageAnnotationResponseArgs

func ImageAnnotationResponsePtr(v *ImageAnnotationResponseArgs) ImageAnnotationResponsePtrInput {
	return (*imageAnnotationResponsePtrType)(v)
}

func (*imageAnnotationResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ImageAnnotationResponse)(nil)).Elem()
}

func (i *imageAnnotationResponsePtrType) ToImageAnnotationResponsePtrOutput() ImageAnnotationResponsePtrOutput {
	return i.ToImageAnnotationResponsePtrOutputWithContext(context.Background())
}

func (i *imageAnnotationResponsePtrType) ToImageAnnotationResponsePtrOutputWithContext(ctx context.Context) ImageAnnotationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageAnnotationResponsePtrOutput)
}

// Image annotation.
type ImageAnnotationResponseOutput struct{ *pulumi.OutputState }

func (ImageAnnotationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageAnnotationResponse)(nil)).Elem()
}

func (o ImageAnnotationResponseOutput) ToImageAnnotationResponseOutput() ImageAnnotationResponseOutput {
	return o
}

func (o ImageAnnotationResponseOutput) ToImageAnnotationResponseOutputWithContext(ctx context.Context) ImageAnnotationResponseOutput {
	return o
}

func (o ImageAnnotationResponseOutput) ToImageAnnotationResponsePtrOutput() ImageAnnotationResponsePtrOutput {
	return o.ToImageAnnotationResponsePtrOutputWithContext(context.Background())
}

func (o ImageAnnotationResponseOutput) ToImageAnnotationResponsePtrOutputWithContext(ctx context.Context) ImageAnnotationResponsePtrOutput {
	return o.ApplyT(func(v ImageAnnotationResponse) *ImageAnnotationResponse {
		return &v
	}).(ImageAnnotationResponsePtrOutput)
}

// The list of polygons outlining the sensitive regions in the image.
func (o ImageAnnotationResponseOutput) BoundingPolys() BoundingPolyResponseArrayOutput {
	return o.ApplyT(func(v ImageAnnotationResponse) []BoundingPolyResponse { return v.BoundingPolys }).(BoundingPolyResponseArrayOutput)
}

// 0-based index of the image frame. For example, an image frame in a DICOM instance.
func (o ImageAnnotationResponseOutput) FrameIndex() pulumi.IntOutput {
	return o.ApplyT(func(v ImageAnnotationResponse) int { return v.FrameIndex }).(pulumi.IntOutput)
}

type ImageAnnotationResponsePtrOutput struct{ *pulumi.OutputState }

func (ImageAnnotationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ImageAnnotationResponse)(nil)).Elem()
}

func (o ImageAnnotationResponsePtrOutput) ToImageAnnotationResponsePtrOutput() ImageAnnotationResponsePtrOutput {
	return o
}

func (o ImageAnnotationResponsePtrOutput) ToImageAnnotationResponsePtrOutputWithContext(ctx context.Context) ImageAnnotationResponsePtrOutput {
	return o
}

func (o ImageAnnotationResponsePtrOutput) Elem() ImageAnnotationResponseOutput {
	return o.ApplyT(func(v *ImageAnnotationResponse) ImageAnnotationResponse { return *v }).(ImageAnnotationResponseOutput)
}

// The list of polygons outlining the sensitive regions in the image.
func (o ImageAnnotationResponsePtrOutput) BoundingPolys() BoundingPolyResponseArrayOutput {
	return o.ApplyT(func(v *ImageAnnotationResponse) []BoundingPolyResponse {
		if v == nil {
			return nil
		}
		return v.BoundingPolys
	}).(BoundingPolyResponseArrayOutput)
}

// 0-based index of the image frame. For example, an image frame in a DICOM instance.
func (o ImageAnnotationResponsePtrOutput) FrameIndex() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ImageAnnotationResponse) *int {
		if v == nil {
			return nil
		}
		return &v.FrameIndex
	}).(pulumi.IntPtrOutput)
}

// Raw bytes representing consent artifact content.
type ImageResponse struct {
	// Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
	GcsUri string `pulumi:"gcsUri"`
	// Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
	RawBytes string `pulumi:"rawBytes"`
}

// ImageResponseInput is an input type that accepts ImageResponseArgs and ImageResponseOutput values.
// You can construct a concrete instance of `ImageResponseInput` via:
//
//          ImageResponseArgs{...}
type ImageResponseInput interface {
	pulumi.Input

	ToImageResponseOutput() ImageResponseOutput
	ToImageResponseOutputWithContext(context.Context) ImageResponseOutput
}

// Raw bytes representing consent artifact content.
type ImageResponseArgs struct {
	// Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
	GcsUri pulumi.StringInput `pulumi:"gcsUri"`
	// Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
	RawBytes pulumi.StringInput `pulumi:"rawBytes"`
}

func (ImageResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageResponse)(nil)).Elem()
}

func (i ImageResponseArgs) ToImageResponseOutput() ImageResponseOutput {
	return i.ToImageResponseOutputWithContext(context.Background())
}

func (i ImageResponseArgs) ToImageResponseOutputWithContext(ctx context.Context) ImageResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageResponseOutput)
}

func (i ImageResponseArgs) ToImageResponsePtrOutput() ImageResponsePtrOutput {
	return i.ToImageResponsePtrOutputWithContext(context.Background())
}

func (i ImageResponseArgs) ToImageResponsePtrOutputWithContext(ctx context.Context) ImageResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageResponseOutput).ToImageResponsePtrOutputWithContext(ctx)
}

// ImageResponsePtrInput is an input type that accepts ImageResponseArgs, ImageResponsePtr and ImageResponsePtrOutput values.
// You can construct a concrete instance of `ImageResponsePtrInput` via:
//
//          ImageResponseArgs{...}
//
//  or:
//
//          nil
type ImageResponsePtrInput interface {
	pulumi.Input

	ToImageResponsePtrOutput() ImageResponsePtrOutput
	ToImageResponsePtrOutputWithContext(context.Context) ImageResponsePtrOutput
}

type imageResponsePtrType ImageResponseArgs

func ImageResponsePtr(v *ImageResponseArgs) ImageResponsePtrInput {
	return (*imageResponsePtrType)(v)
}

func (*imageResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ImageResponse)(nil)).Elem()
}

func (i *imageResponsePtrType) ToImageResponsePtrOutput() ImageResponsePtrOutput {
	return i.ToImageResponsePtrOutputWithContext(context.Background())
}

func (i *imageResponsePtrType) ToImageResponsePtrOutputWithContext(ctx context.Context) ImageResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageResponsePtrOutput)
}

// ImageResponseArrayInput is an input type that accepts ImageResponseArray and ImageResponseArrayOutput values.
// You can construct a concrete instance of `ImageResponseArrayInput` via:
//
//          ImageResponseArray{ ImageResponseArgs{...} }
type ImageResponseArrayInput interface {
	pulumi.Input

	ToImageResponseArrayOutput() ImageResponseArrayOutput
	ToImageResponseArrayOutputWithContext(context.Context) ImageResponseArrayOutput
}

type ImageResponseArray []ImageResponseInput

func (ImageResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ImageResponse)(nil)).Elem()
}

func (i ImageResponseArray) ToImageResponseArrayOutput() ImageResponseArrayOutput {
	return i.ToImageResponseArrayOutputWithContext(context.Background())
}

func (i ImageResponseArray) ToImageResponseArrayOutputWithContext(ctx context.Context) ImageResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageResponseArrayOutput)
}

// Raw bytes representing consent artifact content.
type ImageResponseOutput struct{ *pulumi.OutputState }

func (ImageResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageResponse)(nil)).Elem()
}

func (o ImageResponseOutput) ToImageResponseOutput() ImageResponseOutput {
	return o
}

func (o ImageResponseOutput) ToImageResponseOutputWithContext(ctx context.Context) ImageResponseOutput {
	return o
}

func (o ImageResponseOutput) ToImageResponsePtrOutput() ImageResponsePtrOutput {
	return o.ToImageResponsePtrOutputWithContext(context.Background())
}

func (o ImageResponseOutput) ToImageResponsePtrOutputWithContext(ctx context.Context) ImageResponsePtrOutput {
	return o.ApplyT(func(v ImageResponse) *ImageResponse {
		return &v
	}).(ImageResponsePtrOutput)
}

// Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
func (o ImageResponseOutput) GcsUri() pulumi.StringOutput {
	return o.ApplyT(func(v ImageResponse) string { return v.GcsUri }).(pulumi.StringOutput)
}

// Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
func (o ImageResponseOutput) RawBytes() pulumi.StringOutput {
	return o.ApplyT(func(v ImageResponse) string { return v.RawBytes }).(pulumi.StringOutput)
}

type ImageResponsePtrOutput struct{ *pulumi.OutputState }

func (ImageResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ImageResponse)(nil)).Elem()
}

func (o ImageResponsePtrOutput) ToImageResponsePtrOutput() ImageResponsePtrOutput {
	return o
}

func (o ImageResponsePtrOutput) ToImageResponsePtrOutputWithContext(ctx context.Context) ImageResponsePtrOutput {
	return o
}

func (o ImageResponsePtrOutput) Elem() ImageResponseOutput {
	return o.ApplyT(func(v *ImageResponse) ImageResponse { return *v }).(ImageResponseOutput)
}

// Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
func (o ImageResponsePtrOutput) GcsUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ImageResponse) *string {
		if v == nil {
			return nil
		}
		return &v.GcsUri
	}).(pulumi.StringPtrOutput)
}

// Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
func (o ImageResponsePtrOutput) RawBytes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ImageResponse) *string {
		if v == nil {
			return nil
		}
		return &v.RawBytes
	}).(pulumi.StringPtrOutput)
}

type ImageResponseArrayOutput struct{ *pulumi.OutputState }

func (ImageResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ImageResponse)(nil)).Elem()
}

func (o ImageResponseArrayOutput) ToImageResponseArrayOutput() ImageResponseArrayOutput {
	return o
}

func (o ImageResponseArrayOutput) ToImageResponseArrayOutputWithContext(ctx context.Context) ImageResponseArrayOutput {
	return o
}

func (o ImageResponseArrayOutput) Index(i pulumi.IntInput) ImageResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ImageResponse {
		return vs[0].([]ImageResponse)[vs[1].(int)]
	}).(ImageResponseOutput)
}

// A complete HL7v2 message. See [Introduction to HL7 Standards] (https://www.hl7.org/implement/standards/index.cfm?ref=common) for details on the standard.
type Message struct {
	// Raw message bytes.
	Data *string `pulumi:"data"`
	// User-supplied key-value pairs used to organize HL7v2 stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \p{Ll}\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.
	Labels map[string]string `pulumi:"labels"`
	// The message type for this message. MSH-9.1.
	MessageType *string `pulumi:"messageType"`
	// Resource name of the Message, of the form `projects/{project_id}/datasets/{dataset_id}/hl7V2Stores/{hl7_v2_store_id}/messages/{message_id}`. Assigned by the server.
	Name *string `pulumi:"name"`
	// All patient IDs listed in the PID-2, PID-3, and PID-4 segments of this message.
	PatientIds []PatientId `pulumi:"patientIds"`
	// The parsed version of the raw message data schematized according to this store's schemas and type definitions.
	SchematizedData *SchematizedData `pulumi:"schematizedData"`
	// The hospital that this message came from. MSH-4.
	SendFacility *string `pulumi:"sendFacility"`
	// The datetime the sending application sent this message. MSH-7.
	SendTime *string `pulumi:"sendTime"`
}

// MessageInput is an input type that accepts MessageArgs and MessageOutput values.
// You can construct a concrete instance of `MessageInput` via:
//
//          MessageArgs{...}
type MessageInput interface {
	pulumi.Input

	ToMessageOutput() MessageOutput
	ToMessageOutputWithContext(context.Context) MessageOutput
}

// A complete HL7v2 message. See [Introduction to HL7 Standards] (https://www.hl7.org/implement/standards/index.cfm?ref=common) for details on the standard.
type MessageArgs struct {
	// Raw message bytes.
	Data pulumi.StringPtrInput `pulumi:"data"`
	// User-supplied key-value pairs used to organize HL7v2 stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \p{Ll}\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// The message type for this message. MSH-9.1.
	MessageType pulumi.StringPtrInput `pulumi:"messageType"`
	// Resource name of the Message, of the form `projects/{project_id}/datasets/{dataset_id}/hl7V2Stores/{hl7_v2_store_id}/messages/{message_id}`. Assigned by the server.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// All patient IDs listed in the PID-2, PID-3, and PID-4 segments of this message.
	PatientIds PatientIdArrayInput `pulumi:"patientIds"`
	// The parsed version of the raw message data schematized according to this store's schemas and type definitions.
	SchematizedData SchematizedDataPtrInput `pulumi:"schematizedData"`
	// The hospital that this message came from. MSH-4.
	SendFacility pulumi.StringPtrInput `pulumi:"sendFacility"`
	// The datetime the sending application sent this message. MSH-7.
	SendTime pulumi.StringPtrInput `pulumi:"sendTime"`
}

func (MessageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Message)(nil)).Elem()
}

func (i MessageArgs) ToMessageOutput() MessageOutput {
	return i.ToMessageOutputWithContext(context.Background())
}

func (i MessageArgs) ToMessageOutputWithContext(ctx context.Context) MessageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MessageOutput)
}

func (i MessageArgs) ToMessagePtrOutput() MessagePtrOutput {
	return i.ToMessagePtrOutputWithContext(context.Background())
}

func (i MessageArgs) ToMessagePtrOutputWithContext(ctx context.Context) MessagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MessageOutput).ToMessagePtrOutputWithContext(ctx)
}

// MessagePtrInput is an input type that accepts MessageArgs, MessagePtr and MessagePtrOutput values.
// You can construct a concrete instance of `MessagePtrInput` via:
//
//          MessageArgs{...}
//
//  or:
//
//          nil
type MessagePtrInput interface {
	pulumi.Input

	ToMessagePtrOutput() MessagePtrOutput
	ToMessagePtrOutputWithContext(context.Context) MessagePtrOutput
}

type messagePtrType MessageArgs

func MessagePtr(v *MessageArgs) MessagePtrInput {
	return (*messagePtrType)(v)
}

func (*messagePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Message)(nil)).Elem()
}

func (i *messagePtrType) ToMessagePtrOutput() MessagePtrOutput {
	return i.ToMessagePtrOutputWithContext(context.Background())
}

func (i *messagePtrType) ToMessagePtrOutputWithContext(ctx context.Context) MessagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MessagePtrOutput)
}

// A complete HL7v2 message. See [Introduction to HL7 Standards] (https://www.hl7.org/implement/standards/index.cfm?ref=common) for details on the standard.
type MessageOutput struct{ *pulumi.OutputState }

func (MessageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Message)(nil)).Elem()
}

func (o MessageOutput) ToMessageOutput() MessageOutput {
	return o
}

func (o MessageOutput) ToMessageOutputWithContext(ctx context.Context) MessageOutput {
	return o
}

func (o MessageOutput) ToMessagePtrOutput() MessagePtrOutput {
	return o.ToMessagePtrOutputWithContext(context.Background())
}

func (o MessageOutput) ToMessagePtrOutputWithContext(ctx context.Context) MessagePtrOutput {
	return o.ApplyT(func(v Message) *Message {
		return &v
	}).(MessagePtrOutput)
}

// Raw message bytes.
func (o MessageOutput) Data() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Message) *string { return v.Data }).(pulumi.StringPtrOutput)
}

// User-supplied key-value pairs used to organize HL7v2 stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \p{Ll}\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.
func (o MessageOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v Message) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// The message type for this message. MSH-9.1.
func (o MessageOutput) MessageType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Message) *string { return v.MessageType }).(pulumi.StringPtrOutput)
}

// Resource name of the Message, of the form `projects/{project_id}/datasets/{dataset_id}/hl7V2Stores/{hl7_v2_store_id}/messages/{message_id}`. Assigned by the server.
func (o MessageOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Message) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// All patient IDs listed in the PID-2, PID-3, and PID-4 segments of this message.
func (o MessageOutput) PatientIds() PatientIdArrayOutput {
	return o.ApplyT(func(v Message) []PatientId { return v.PatientIds }).(PatientIdArrayOutput)
}

// The parsed version of the raw message data schematized according to this store's schemas and type definitions.
func (o MessageOutput) SchematizedData() SchematizedDataPtrOutput {
	return o.ApplyT(func(v Message) *SchematizedData { return v.SchematizedData }).(SchematizedDataPtrOutput)
}

// The hospital that this message came from. MSH-4.
func (o MessageOutput) SendFacility() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Message) *string { return v.SendFacility }).(pulumi.StringPtrOutput)
}

// The datetime the sending application sent this message. MSH-7.
func (o MessageOutput) SendTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Message) *string { return v.SendTime }).(pulumi.StringPtrOutput)
}

type MessagePtrOutput struct{ *pulumi.OutputState }

func (MessagePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Message)(nil)).Elem()
}

func (o MessagePtrOutput) ToMessagePtrOutput() MessagePtrOutput {
	return o
}

func (o MessagePtrOutput) ToMessagePtrOutputWithContext(ctx context.Context) MessagePtrOutput {
	return o
}

func (o MessagePtrOutput) Elem() MessageOutput {
	return o.ApplyT(func(v *Message) Message { return *v }).(MessageOutput)
}

// Raw message bytes.
func (o MessagePtrOutput) Data() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Message) *string {
		if v == nil {
			return nil
		}
		return v.Data
	}).(pulumi.StringPtrOutput)
}

// User-supplied key-value pairs used to organize HL7v2 stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \p{Ll}\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.
func (o MessagePtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Message) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// The message type for this message. MSH-9.1.
func (o MessagePtrOutput) MessageType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Message) *string {
		if v == nil {
			return nil
		}
		return v.MessageType
	}).(pulumi.StringPtrOutput)
}

// Resource name of the Message, of the form `projects/{project_id}/datasets/{dataset_id}/hl7V2Stores/{hl7_v2_store_id}/messages/{message_id}`. Assigned by the server.
func (o MessagePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Message) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// All patient IDs listed in the PID-2, PID-3, and PID-4 segments of this message.
func (o MessagePtrOutput) PatientIds() PatientIdArrayOutput {
	return o.ApplyT(func(v *Message) []PatientId {
		if v == nil {
			return nil
		}
		return v.PatientIds
	}).(PatientIdArrayOutput)
}

// The parsed version of the raw message data schematized according to this store's schemas and type definitions.
func (o MessagePtrOutput) SchematizedData() SchematizedDataPtrOutput {
	return o.ApplyT(func(v *Message) *SchematizedData {
		if v == nil {
			return nil
		}
		return v.SchematizedData
	}).(SchematizedDataPtrOutput)
}

// The hospital that this message came from. MSH-4.
func (o MessagePtrOutput) SendFacility() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Message) *string {
		if v == nil {
			return nil
		}
		return v.SendFacility
	}).(pulumi.StringPtrOutput)
}

// The datetime the sending application sent this message. MSH-7.
func (o MessagePtrOutput) SendTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Message) *string {
		if v == nil {
			return nil
		}
		return v.SendTime
	}).(pulumi.StringPtrOutput)
}

// Specifies where to send notifications upon changes to a data store.
type NotificationConfig struct {
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
	PubsubTopic *string `pulumi:"pubsubTopic"`
}

// NotificationConfigInput is an input type that accepts NotificationConfigArgs and NotificationConfigOutput values.
// You can construct a concrete instance of `NotificationConfigInput` via:
//
//          NotificationConfigArgs{...}
type NotificationConfigInput interface {
	pulumi.Input

	ToNotificationConfigOutput() NotificationConfigOutput
	ToNotificationConfigOutputWithContext(context.Context) NotificationConfigOutput
}

// Specifies where to send notifications upon changes to a data store.
type NotificationConfigArgs struct {
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
	PubsubTopic pulumi.StringPtrInput `pulumi:"pubsubTopic"`
}

func (NotificationConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationConfig)(nil)).Elem()
}

func (i NotificationConfigArgs) ToNotificationConfigOutput() NotificationConfigOutput {
	return i.ToNotificationConfigOutputWithContext(context.Background())
}

func (i NotificationConfigArgs) ToNotificationConfigOutputWithContext(ctx context.Context) NotificationConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationConfigOutput)
}

func (i NotificationConfigArgs) ToNotificationConfigPtrOutput() NotificationConfigPtrOutput {
	return i.ToNotificationConfigPtrOutputWithContext(context.Background())
}

func (i NotificationConfigArgs) ToNotificationConfigPtrOutputWithContext(ctx context.Context) NotificationConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationConfigOutput).ToNotificationConfigPtrOutputWithContext(ctx)
}

// NotificationConfigPtrInput is an input type that accepts NotificationConfigArgs, NotificationConfigPtr and NotificationConfigPtrOutput values.
// You can construct a concrete instance of `NotificationConfigPtrInput` via:
//
//          NotificationConfigArgs{...}
//
//  or:
//
//          nil
type NotificationConfigPtrInput interface {
	pulumi.Input

	ToNotificationConfigPtrOutput() NotificationConfigPtrOutput
	ToNotificationConfigPtrOutputWithContext(context.Context) NotificationConfigPtrOutput
}

type notificationConfigPtrType NotificationConfigArgs

func NotificationConfigPtr(v *NotificationConfigArgs) NotificationConfigPtrInput {
	return (*notificationConfigPtrType)(v)
}

func (*notificationConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationConfig)(nil)).Elem()
}

func (i *notificationConfigPtrType) ToNotificationConfigPtrOutput() NotificationConfigPtrOutput {
	return i.ToNotificationConfigPtrOutputWithContext(context.Background())
}

func (i *notificationConfigPtrType) ToNotificationConfigPtrOutputWithContext(ctx context.Context) NotificationConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationConfigPtrOutput)
}

// Specifies where to send notifications upon changes to a data store.
type NotificationConfigOutput struct{ *pulumi.OutputState }

func (NotificationConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationConfig)(nil)).Elem()
}

func (o NotificationConfigOutput) ToNotificationConfigOutput() NotificationConfigOutput {
	return o
}

func (o NotificationConfigOutput) ToNotificationConfigOutputWithContext(ctx context.Context) NotificationConfigOutput {
	return o
}

func (o NotificationConfigOutput) ToNotificationConfigPtrOutput() NotificationConfigPtrOutput {
	return o.ToNotificationConfigPtrOutputWithContext(context.Background())
}

func (o NotificationConfigOutput) ToNotificationConfigPtrOutputWithContext(ctx context.Context) NotificationConfigPtrOutput {
	return o.ApplyT(func(v NotificationConfig) *NotificationConfig {
		return &v
	}).(NotificationConfigPtrOutput)
}

// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
func (o NotificationConfigOutput) PubsubTopic() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NotificationConfig) *string { return v.PubsubTopic }).(pulumi.StringPtrOutput)
}

type NotificationConfigPtrOutput struct{ *pulumi.OutputState }

func (NotificationConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationConfig)(nil)).Elem()
}

func (o NotificationConfigPtrOutput) ToNotificationConfigPtrOutput() NotificationConfigPtrOutput {
	return o
}

func (o NotificationConfigPtrOutput) ToNotificationConfigPtrOutputWithContext(ctx context.Context) NotificationConfigPtrOutput {
	return o
}

func (o NotificationConfigPtrOutput) Elem() NotificationConfigOutput {
	return o.ApplyT(func(v *NotificationConfig) NotificationConfig { return *v }).(NotificationConfigOutput)
}

// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
func (o NotificationConfigPtrOutput) PubsubTopic() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NotificationConfig) *string {
		if v == nil {
			return nil
		}
		return v.PubsubTopic
	}).(pulumi.StringPtrOutput)
}

// Specifies where to send notifications upon changes to a data store.
type NotificationConfigResponse struct {
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
	PubsubTopic string `pulumi:"pubsubTopic"`
}

// NotificationConfigResponseInput is an input type that accepts NotificationConfigResponseArgs and NotificationConfigResponseOutput values.
// You can construct a concrete instance of `NotificationConfigResponseInput` via:
//
//          NotificationConfigResponseArgs{...}
type NotificationConfigResponseInput interface {
	pulumi.Input

	ToNotificationConfigResponseOutput() NotificationConfigResponseOutput
	ToNotificationConfigResponseOutputWithContext(context.Context) NotificationConfigResponseOutput
}

// Specifies where to send notifications upon changes to a data store.
type NotificationConfigResponseArgs struct {
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
	PubsubTopic pulumi.StringInput `pulumi:"pubsubTopic"`
}

func (NotificationConfigResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationConfigResponse)(nil)).Elem()
}

func (i NotificationConfigResponseArgs) ToNotificationConfigResponseOutput() NotificationConfigResponseOutput {
	return i.ToNotificationConfigResponseOutputWithContext(context.Background())
}

func (i NotificationConfigResponseArgs) ToNotificationConfigResponseOutputWithContext(ctx context.Context) NotificationConfigResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationConfigResponseOutput)
}

func (i NotificationConfigResponseArgs) ToNotificationConfigResponsePtrOutput() NotificationConfigResponsePtrOutput {
	return i.ToNotificationConfigResponsePtrOutputWithContext(context.Background())
}

func (i NotificationConfigResponseArgs) ToNotificationConfigResponsePtrOutputWithContext(ctx context.Context) NotificationConfigResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationConfigResponseOutput).ToNotificationConfigResponsePtrOutputWithContext(ctx)
}

// NotificationConfigResponsePtrInput is an input type that accepts NotificationConfigResponseArgs, NotificationConfigResponsePtr and NotificationConfigResponsePtrOutput values.
// You can construct a concrete instance of `NotificationConfigResponsePtrInput` via:
//
//          NotificationConfigResponseArgs{...}
//
//  or:
//
//          nil
type NotificationConfigResponsePtrInput interface {
	pulumi.Input

	ToNotificationConfigResponsePtrOutput() NotificationConfigResponsePtrOutput
	ToNotificationConfigResponsePtrOutputWithContext(context.Context) NotificationConfigResponsePtrOutput
}

type notificationConfigResponsePtrType NotificationConfigResponseArgs

func NotificationConfigResponsePtr(v *NotificationConfigResponseArgs) NotificationConfigResponsePtrInput {
	return (*notificationConfigResponsePtrType)(v)
}

func (*notificationConfigResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationConfigResponse)(nil)).Elem()
}

func (i *notificationConfigResponsePtrType) ToNotificationConfigResponsePtrOutput() NotificationConfigResponsePtrOutput {
	return i.ToNotificationConfigResponsePtrOutputWithContext(context.Background())
}

func (i *notificationConfigResponsePtrType) ToNotificationConfigResponsePtrOutputWithContext(ctx context.Context) NotificationConfigResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationConfigResponsePtrOutput)
}

// Specifies where to send notifications upon changes to a data store.
type NotificationConfigResponseOutput struct{ *pulumi.OutputState }

func (NotificationConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationConfigResponse)(nil)).Elem()
}

func (o NotificationConfigResponseOutput) ToNotificationConfigResponseOutput() NotificationConfigResponseOutput {
	return o
}

func (o NotificationConfigResponseOutput) ToNotificationConfigResponseOutputWithContext(ctx context.Context) NotificationConfigResponseOutput {
	return o
}

func (o NotificationConfigResponseOutput) ToNotificationConfigResponsePtrOutput() NotificationConfigResponsePtrOutput {
	return o.ToNotificationConfigResponsePtrOutputWithContext(context.Background())
}

func (o NotificationConfigResponseOutput) ToNotificationConfigResponsePtrOutputWithContext(ctx context.Context) NotificationConfigResponsePtrOutput {
	return o.ApplyT(func(v NotificationConfigResponse) *NotificationConfigResponse {
		return &v
	}).(NotificationConfigResponsePtrOutput)
}

// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
func (o NotificationConfigResponseOutput) PubsubTopic() pulumi.StringOutput {
	return o.ApplyT(func(v NotificationConfigResponse) string { return v.PubsubTopic }).(pulumi.StringOutput)
}

type NotificationConfigResponsePtrOutput struct{ *pulumi.OutputState }

func (NotificationConfigResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationConfigResponse)(nil)).Elem()
}

func (o NotificationConfigResponsePtrOutput) ToNotificationConfigResponsePtrOutput() NotificationConfigResponsePtrOutput {
	return o
}

func (o NotificationConfigResponsePtrOutput) ToNotificationConfigResponsePtrOutputWithContext(ctx context.Context) NotificationConfigResponsePtrOutput {
	return o
}

func (o NotificationConfigResponsePtrOutput) Elem() NotificationConfigResponseOutput {
	return o.ApplyT(func(v *NotificationConfigResponse) NotificationConfigResponse { return *v }).(NotificationConfigResponseOutput)
}

// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
func (o NotificationConfigResponsePtrOutput) PubsubTopic() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NotificationConfigResponse) *string {
		if v == nil {
			return nil
		}
		return &v.PubsubTopic
	}).(pulumi.StringPtrOutput)
}

// The content of an HL7v2 message in a structured format.
type ParsedDataResponse struct {
	Segments []SegmentResponse `pulumi:"segments"`
}

// ParsedDataResponseInput is an input type that accepts ParsedDataResponseArgs and ParsedDataResponseOutput values.
// You can construct a concrete instance of `ParsedDataResponseInput` via:
//
//          ParsedDataResponseArgs{...}
type ParsedDataResponseInput interface {
	pulumi.Input

	ToParsedDataResponseOutput() ParsedDataResponseOutput
	ToParsedDataResponseOutputWithContext(context.Context) ParsedDataResponseOutput
}

// The content of an HL7v2 message in a structured format.
type ParsedDataResponseArgs struct {
	Segments SegmentResponseArrayInput `pulumi:"segments"`
}

func (ParsedDataResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ParsedDataResponse)(nil)).Elem()
}

func (i ParsedDataResponseArgs) ToParsedDataResponseOutput() ParsedDataResponseOutput {
	return i.ToParsedDataResponseOutputWithContext(context.Background())
}

func (i ParsedDataResponseArgs) ToParsedDataResponseOutputWithContext(ctx context.Context) ParsedDataResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParsedDataResponseOutput)
}

func (i ParsedDataResponseArgs) ToParsedDataResponsePtrOutput() ParsedDataResponsePtrOutput {
	return i.ToParsedDataResponsePtrOutputWithContext(context.Background())
}

func (i ParsedDataResponseArgs) ToParsedDataResponsePtrOutputWithContext(ctx context.Context) ParsedDataResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParsedDataResponseOutput).ToParsedDataResponsePtrOutputWithContext(ctx)
}

// ParsedDataResponsePtrInput is an input type that accepts ParsedDataResponseArgs, ParsedDataResponsePtr and ParsedDataResponsePtrOutput values.
// You can construct a concrete instance of `ParsedDataResponsePtrInput` via:
//
//          ParsedDataResponseArgs{...}
//
//  or:
//
//          nil
type ParsedDataResponsePtrInput interface {
	pulumi.Input

	ToParsedDataResponsePtrOutput() ParsedDataResponsePtrOutput
	ToParsedDataResponsePtrOutputWithContext(context.Context) ParsedDataResponsePtrOutput
}

type parsedDataResponsePtrType ParsedDataResponseArgs

func ParsedDataResponsePtr(v *ParsedDataResponseArgs) ParsedDataResponsePtrInput {
	return (*parsedDataResponsePtrType)(v)
}

func (*parsedDataResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ParsedDataResponse)(nil)).Elem()
}

func (i *parsedDataResponsePtrType) ToParsedDataResponsePtrOutput() ParsedDataResponsePtrOutput {
	return i.ToParsedDataResponsePtrOutputWithContext(context.Background())
}

func (i *parsedDataResponsePtrType) ToParsedDataResponsePtrOutputWithContext(ctx context.Context) ParsedDataResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParsedDataResponsePtrOutput)
}

// The content of an HL7v2 message in a structured format.
type ParsedDataResponseOutput struct{ *pulumi.OutputState }

func (ParsedDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ParsedDataResponse)(nil)).Elem()
}

func (o ParsedDataResponseOutput) ToParsedDataResponseOutput() ParsedDataResponseOutput {
	return o
}

func (o ParsedDataResponseOutput) ToParsedDataResponseOutputWithContext(ctx context.Context) ParsedDataResponseOutput {
	return o
}

func (o ParsedDataResponseOutput) ToParsedDataResponsePtrOutput() ParsedDataResponsePtrOutput {
	return o.ToParsedDataResponsePtrOutputWithContext(context.Background())
}

func (o ParsedDataResponseOutput) ToParsedDataResponsePtrOutputWithContext(ctx context.Context) ParsedDataResponsePtrOutput {
	return o.ApplyT(func(v ParsedDataResponse) *ParsedDataResponse {
		return &v
	}).(ParsedDataResponsePtrOutput)
}
func (o ParsedDataResponseOutput) Segments() SegmentResponseArrayOutput {
	return o.ApplyT(func(v ParsedDataResponse) []SegmentResponse { return v.Segments }).(SegmentResponseArrayOutput)
}

type ParsedDataResponsePtrOutput struct{ *pulumi.OutputState }

func (ParsedDataResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ParsedDataResponse)(nil)).Elem()
}

func (o ParsedDataResponsePtrOutput) ToParsedDataResponsePtrOutput() ParsedDataResponsePtrOutput {
	return o
}

func (o ParsedDataResponsePtrOutput) ToParsedDataResponsePtrOutputWithContext(ctx context.Context) ParsedDataResponsePtrOutput {
	return o
}

func (o ParsedDataResponsePtrOutput) Elem() ParsedDataResponseOutput {
	return o.ApplyT(func(v *ParsedDataResponse) ParsedDataResponse { return *v }).(ParsedDataResponseOutput)
}

func (o ParsedDataResponsePtrOutput) Segments() SegmentResponseArrayOutput {
	return o.ApplyT(func(v *ParsedDataResponse) []SegmentResponse {
		if v == nil {
			return nil
		}
		return v.Segments
	}).(SegmentResponseArrayOutput)
}

// The configuration for the parser. It determines how the server parses the messages.
type ParserConfig struct {
	// Determines whether messages with no header are allowed.
	AllowNullHeader *bool `pulumi:"allowNullHeader"`
	// Schemas used to parse messages in this store, if schematized parsing is desired.
	Schema *SchemaPackage `pulumi:"schema"`
	// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
	SegmentTerminator *string `pulumi:"segmentTerminator"`
	// Immutable. Determines the version of the unschematized parser to be used when `schema` is not given. This field is immutable after store creation.
	Version *string `pulumi:"version"`
}

// ParserConfigInput is an input type that accepts ParserConfigArgs and ParserConfigOutput values.
// You can construct a concrete instance of `ParserConfigInput` via:
//
//          ParserConfigArgs{...}
type ParserConfigInput interface {
	pulumi.Input

	ToParserConfigOutput() ParserConfigOutput
	ToParserConfigOutputWithContext(context.Context) ParserConfigOutput
}

// The configuration for the parser. It determines how the server parses the messages.
type ParserConfigArgs struct {
	// Determines whether messages with no header are allowed.
	AllowNullHeader pulumi.BoolPtrInput `pulumi:"allowNullHeader"`
	// Schemas used to parse messages in this store, if schematized parsing is desired.
	Schema SchemaPackagePtrInput `pulumi:"schema"`
	// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
	SegmentTerminator pulumi.StringPtrInput `pulumi:"segmentTerminator"`
	// Immutable. Determines the version of the unschematized parser to be used when `schema` is not given. This field is immutable after store creation.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (ParserConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ParserConfig)(nil)).Elem()
}

func (i ParserConfigArgs) ToParserConfigOutput() ParserConfigOutput {
	return i.ToParserConfigOutputWithContext(context.Background())
}

func (i ParserConfigArgs) ToParserConfigOutputWithContext(ctx context.Context) ParserConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParserConfigOutput)
}

func (i ParserConfigArgs) ToParserConfigPtrOutput() ParserConfigPtrOutput {
	return i.ToParserConfigPtrOutputWithContext(context.Background())
}

func (i ParserConfigArgs) ToParserConfigPtrOutputWithContext(ctx context.Context) ParserConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParserConfigOutput).ToParserConfigPtrOutputWithContext(ctx)
}

// ParserConfigPtrInput is an input type that accepts ParserConfigArgs, ParserConfigPtr and ParserConfigPtrOutput values.
// You can construct a concrete instance of `ParserConfigPtrInput` via:
//
//          ParserConfigArgs{...}
//
//  or:
//
//          nil
type ParserConfigPtrInput interface {
	pulumi.Input

	ToParserConfigPtrOutput() ParserConfigPtrOutput
	ToParserConfigPtrOutputWithContext(context.Context) ParserConfigPtrOutput
}

type parserConfigPtrType ParserConfigArgs

func ParserConfigPtr(v *ParserConfigArgs) ParserConfigPtrInput {
	return (*parserConfigPtrType)(v)
}

func (*parserConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ParserConfig)(nil)).Elem()
}

func (i *parserConfigPtrType) ToParserConfigPtrOutput() ParserConfigPtrOutput {
	return i.ToParserConfigPtrOutputWithContext(context.Background())
}

func (i *parserConfigPtrType) ToParserConfigPtrOutputWithContext(ctx context.Context) ParserConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParserConfigPtrOutput)
}

// The configuration for the parser. It determines how the server parses the messages.
type ParserConfigOutput struct{ *pulumi.OutputState }

func (ParserConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ParserConfig)(nil)).Elem()
}

func (o ParserConfigOutput) ToParserConfigOutput() ParserConfigOutput {
	return o
}

func (o ParserConfigOutput) ToParserConfigOutputWithContext(ctx context.Context) ParserConfigOutput {
	return o
}

func (o ParserConfigOutput) ToParserConfigPtrOutput() ParserConfigPtrOutput {
	return o.ToParserConfigPtrOutputWithContext(context.Background())
}

func (o ParserConfigOutput) ToParserConfigPtrOutputWithContext(ctx context.Context) ParserConfigPtrOutput {
	return o.ApplyT(func(v ParserConfig) *ParserConfig {
		return &v
	}).(ParserConfigPtrOutput)
}

// Determines whether messages with no header are allowed.
func (o ParserConfigOutput) AllowNullHeader() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ParserConfig) *bool { return v.AllowNullHeader }).(pulumi.BoolPtrOutput)
}

// Schemas used to parse messages in this store, if schematized parsing is desired.
func (o ParserConfigOutput) Schema() SchemaPackagePtrOutput {
	return o.ApplyT(func(v ParserConfig) *SchemaPackage { return v.Schema }).(SchemaPackagePtrOutput)
}

// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
func (o ParserConfigOutput) SegmentTerminator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ParserConfig) *string { return v.SegmentTerminator }).(pulumi.StringPtrOutput)
}

// Immutable. Determines the version of the unschematized parser to be used when `schema` is not given. This field is immutable after store creation.
func (o ParserConfigOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ParserConfig) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type ParserConfigPtrOutput struct{ *pulumi.OutputState }

func (ParserConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ParserConfig)(nil)).Elem()
}

func (o ParserConfigPtrOutput) ToParserConfigPtrOutput() ParserConfigPtrOutput {
	return o
}

func (o ParserConfigPtrOutput) ToParserConfigPtrOutputWithContext(ctx context.Context) ParserConfigPtrOutput {
	return o
}

func (o ParserConfigPtrOutput) Elem() ParserConfigOutput {
	return o.ApplyT(func(v *ParserConfig) ParserConfig { return *v }).(ParserConfigOutput)
}

// Determines whether messages with no header are allowed.
func (o ParserConfigPtrOutput) AllowNullHeader() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ParserConfig) *bool {
		if v == nil {
			return nil
		}
		return v.AllowNullHeader
	}).(pulumi.BoolPtrOutput)
}

// Schemas used to parse messages in this store, if schematized parsing is desired.
func (o ParserConfigPtrOutput) Schema() SchemaPackagePtrOutput {
	return o.ApplyT(func(v *ParserConfig) *SchemaPackage {
		if v == nil {
			return nil
		}
		return v.Schema
	}).(SchemaPackagePtrOutput)
}

// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
func (o ParserConfigPtrOutput) SegmentTerminator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ParserConfig) *string {
		if v == nil {
			return nil
		}
		return v.SegmentTerminator
	}).(pulumi.StringPtrOutput)
}

// Immutable. Determines the version of the unschematized parser to be used when `schema` is not given. This field is immutable after store creation.
func (o ParserConfigPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ParserConfig) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// The configuration for the parser. It determines how the server parses the messages.
type ParserConfigResponse struct {
	// Determines whether messages with no header are allowed.
	AllowNullHeader bool `pulumi:"allowNullHeader"`
	// Schemas used to parse messages in this store, if schematized parsing is desired.
	Schema SchemaPackageResponse `pulumi:"schema"`
	// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
	SegmentTerminator string `pulumi:"segmentTerminator"`
	// Immutable. Determines the version of the unschematized parser to be used when `schema` is not given. This field is immutable after store creation.
	Version string `pulumi:"version"`
}

// ParserConfigResponseInput is an input type that accepts ParserConfigResponseArgs and ParserConfigResponseOutput values.
// You can construct a concrete instance of `ParserConfigResponseInput` via:
//
//          ParserConfigResponseArgs{...}
type ParserConfigResponseInput interface {
	pulumi.Input

	ToParserConfigResponseOutput() ParserConfigResponseOutput
	ToParserConfigResponseOutputWithContext(context.Context) ParserConfigResponseOutput
}

// The configuration for the parser. It determines how the server parses the messages.
type ParserConfigResponseArgs struct {
	// Determines whether messages with no header are allowed.
	AllowNullHeader pulumi.BoolInput `pulumi:"allowNullHeader"`
	// Schemas used to parse messages in this store, if schematized parsing is desired.
	Schema SchemaPackageResponseInput `pulumi:"schema"`
	// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
	SegmentTerminator pulumi.StringInput `pulumi:"segmentTerminator"`
	// Immutable. Determines the version of the unschematized parser to be used when `schema` is not given. This field is immutable after store creation.
	Version pulumi.StringInput `pulumi:"version"`
}

func (ParserConfigResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ParserConfigResponse)(nil)).Elem()
}

func (i ParserConfigResponseArgs) ToParserConfigResponseOutput() ParserConfigResponseOutput {
	return i.ToParserConfigResponseOutputWithContext(context.Background())
}

func (i ParserConfigResponseArgs) ToParserConfigResponseOutputWithContext(ctx context.Context) ParserConfigResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParserConfigResponseOutput)
}

func (i ParserConfigResponseArgs) ToParserConfigResponsePtrOutput() ParserConfigResponsePtrOutput {
	return i.ToParserConfigResponsePtrOutputWithContext(context.Background())
}

func (i ParserConfigResponseArgs) ToParserConfigResponsePtrOutputWithContext(ctx context.Context) ParserConfigResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParserConfigResponseOutput).ToParserConfigResponsePtrOutputWithContext(ctx)
}

// ParserConfigResponsePtrInput is an input type that accepts ParserConfigResponseArgs, ParserConfigResponsePtr and ParserConfigResponsePtrOutput values.
// You can construct a concrete instance of `ParserConfigResponsePtrInput` via:
//
//          ParserConfigResponseArgs{...}
//
//  or:
//
//          nil
type ParserConfigResponsePtrInput interface {
	pulumi.Input

	ToParserConfigResponsePtrOutput() ParserConfigResponsePtrOutput
	ToParserConfigResponsePtrOutputWithContext(context.Context) ParserConfigResponsePtrOutput
}

type parserConfigResponsePtrType ParserConfigResponseArgs

func ParserConfigResponsePtr(v *ParserConfigResponseArgs) ParserConfigResponsePtrInput {
	return (*parserConfigResponsePtrType)(v)
}

func (*parserConfigResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ParserConfigResponse)(nil)).Elem()
}

func (i *parserConfigResponsePtrType) ToParserConfigResponsePtrOutput() ParserConfigResponsePtrOutput {
	return i.ToParserConfigResponsePtrOutputWithContext(context.Background())
}

func (i *parserConfigResponsePtrType) ToParserConfigResponsePtrOutputWithContext(ctx context.Context) ParserConfigResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParserConfigResponsePtrOutput)
}

// The configuration for the parser. It determines how the server parses the messages.
type ParserConfigResponseOutput struct{ *pulumi.OutputState }

func (ParserConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ParserConfigResponse)(nil)).Elem()
}

func (o ParserConfigResponseOutput) ToParserConfigResponseOutput() ParserConfigResponseOutput {
	return o
}

func (o ParserConfigResponseOutput) ToParserConfigResponseOutputWithContext(ctx context.Context) ParserConfigResponseOutput {
	return o
}

func (o ParserConfigResponseOutput) ToParserConfigResponsePtrOutput() ParserConfigResponsePtrOutput {
	return o.ToParserConfigResponsePtrOutputWithContext(context.Background())
}

func (o ParserConfigResponseOutput) ToParserConfigResponsePtrOutputWithContext(ctx context.Context) ParserConfigResponsePtrOutput {
	return o.ApplyT(func(v ParserConfigResponse) *ParserConfigResponse {
		return &v
	}).(ParserConfigResponsePtrOutput)
}

// Determines whether messages with no header are allowed.
func (o ParserConfigResponseOutput) AllowNullHeader() pulumi.BoolOutput {
	return o.ApplyT(func(v ParserConfigResponse) bool { return v.AllowNullHeader }).(pulumi.BoolOutput)
}

// Schemas used to parse messages in this store, if schematized parsing is desired.
func (o ParserConfigResponseOutput) Schema() SchemaPackageResponseOutput {
	return o.ApplyT(func(v ParserConfigResponse) SchemaPackageResponse { return v.Schema }).(SchemaPackageResponseOutput)
}

// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
func (o ParserConfigResponseOutput) SegmentTerminator() pulumi.StringOutput {
	return o.ApplyT(func(v ParserConfigResponse) string { return v.SegmentTerminator }).(pulumi.StringOutput)
}

// Immutable. Determines the version of the unschematized parser to be used when `schema` is not given. This field is immutable after store creation.
func (o ParserConfigResponseOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v ParserConfigResponse) string { return v.Version }).(pulumi.StringOutput)
}

type ParserConfigResponsePtrOutput struct{ *pulumi.OutputState }

func (ParserConfigResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ParserConfigResponse)(nil)).Elem()
}

func (o ParserConfigResponsePtrOutput) ToParserConfigResponsePtrOutput() ParserConfigResponsePtrOutput {
	return o
}

func (o ParserConfigResponsePtrOutput) ToParserConfigResponsePtrOutputWithContext(ctx context.Context) ParserConfigResponsePtrOutput {
	return o
}

func (o ParserConfigResponsePtrOutput) Elem() ParserConfigResponseOutput {
	return o.ApplyT(func(v *ParserConfigResponse) ParserConfigResponse { return *v }).(ParserConfigResponseOutput)
}

// Determines whether messages with no header are allowed.
func (o ParserConfigResponsePtrOutput) AllowNullHeader() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ParserConfigResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.AllowNullHeader
	}).(pulumi.BoolPtrOutput)
}

// Schemas used to parse messages in this store, if schematized parsing is desired.
func (o ParserConfigResponsePtrOutput) Schema() SchemaPackageResponsePtrOutput {
	return o.ApplyT(func(v *ParserConfigResponse) *SchemaPackageResponse {
		if v == nil {
			return nil
		}
		return &v.Schema
	}).(SchemaPackageResponsePtrOutput)
}

// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
func (o ParserConfigResponsePtrOutput) SegmentTerminator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ParserConfigResponse) *string {
		if v == nil {
			return nil
		}
		return &v.SegmentTerminator
	}).(pulumi.StringPtrOutput)
}

// Immutable. Determines the version of the unschematized parser to be used when `schema` is not given. This field is immutable after store creation.
func (o ParserConfigResponsePtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ParserConfigResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Version
	}).(pulumi.StringPtrOutput)
}

// A patient identifier and associated type.
type PatientId struct {
	// ID type. For example, MRN or NHS.
	Type *string `pulumi:"type"`
	// The patient's unique identifier.
	Value *string `pulumi:"value"`
}

// PatientIdInput is an input type that accepts PatientIdArgs and PatientIdOutput values.
// You can construct a concrete instance of `PatientIdInput` via:
//
//          PatientIdArgs{...}
type PatientIdInput interface {
	pulumi.Input

	ToPatientIdOutput() PatientIdOutput
	ToPatientIdOutputWithContext(context.Context) PatientIdOutput
}

// A patient identifier and associated type.
type PatientIdArgs struct {
	// ID type. For example, MRN or NHS.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// The patient's unique identifier.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (PatientIdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PatientId)(nil)).Elem()
}

func (i PatientIdArgs) ToPatientIdOutput() PatientIdOutput {
	return i.ToPatientIdOutputWithContext(context.Background())
}

func (i PatientIdArgs) ToPatientIdOutputWithContext(ctx context.Context) PatientIdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PatientIdOutput)
}

// PatientIdArrayInput is an input type that accepts PatientIdArray and PatientIdArrayOutput values.
// You can construct a concrete instance of `PatientIdArrayInput` via:
//
//          PatientIdArray{ PatientIdArgs{...} }
type PatientIdArrayInput interface {
	pulumi.Input

	ToPatientIdArrayOutput() PatientIdArrayOutput
	ToPatientIdArrayOutputWithContext(context.Context) PatientIdArrayOutput
}

type PatientIdArray []PatientIdInput

func (PatientIdArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PatientId)(nil)).Elem()
}

func (i PatientIdArray) ToPatientIdArrayOutput() PatientIdArrayOutput {
	return i.ToPatientIdArrayOutputWithContext(context.Background())
}

func (i PatientIdArray) ToPatientIdArrayOutputWithContext(ctx context.Context) PatientIdArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PatientIdArrayOutput)
}

// A patient identifier and associated type.
type PatientIdOutput struct{ *pulumi.OutputState }

func (PatientIdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PatientId)(nil)).Elem()
}

func (o PatientIdOutput) ToPatientIdOutput() PatientIdOutput {
	return o
}

func (o PatientIdOutput) ToPatientIdOutputWithContext(ctx context.Context) PatientIdOutput {
	return o
}

// ID type. For example, MRN or NHS.
func (o PatientIdOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PatientId) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// The patient's unique identifier.
func (o PatientIdOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PatientId) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type PatientIdArrayOutput struct{ *pulumi.OutputState }

func (PatientIdArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PatientId)(nil)).Elem()
}

func (o PatientIdArrayOutput) ToPatientIdArrayOutput() PatientIdArrayOutput {
	return o
}

func (o PatientIdArrayOutput) ToPatientIdArrayOutputWithContext(ctx context.Context) PatientIdArrayOutput {
	return o
}

func (o PatientIdArrayOutput) Index(i pulumi.IntInput) PatientIdOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PatientId {
		return vs[0].([]PatientId)[vs[1].(int)]
	}).(PatientIdOutput)
}

// A patient identifier and associated type.
type PatientIdResponse struct {
	// ID type. For example, MRN or NHS.
	Type string `pulumi:"type"`
	// The patient's unique identifier.
	Value string `pulumi:"value"`
}

// PatientIdResponseInput is an input type that accepts PatientIdResponseArgs and PatientIdResponseOutput values.
// You can construct a concrete instance of `PatientIdResponseInput` via:
//
//          PatientIdResponseArgs{...}
type PatientIdResponseInput interface {
	pulumi.Input

	ToPatientIdResponseOutput() PatientIdResponseOutput
	ToPatientIdResponseOutputWithContext(context.Context) PatientIdResponseOutput
}

// A patient identifier and associated type.
type PatientIdResponseArgs struct {
	// ID type. For example, MRN or NHS.
	Type pulumi.StringInput `pulumi:"type"`
	// The patient's unique identifier.
	Value pulumi.StringInput `pulumi:"value"`
}

func (PatientIdResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PatientIdResponse)(nil)).Elem()
}

func (i PatientIdResponseArgs) ToPatientIdResponseOutput() PatientIdResponseOutput {
	return i.ToPatientIdResponseOutputWithContext(context.Background())
}

func (i PatientIdResponseArgs) ToPatientIdResponseOutputWithContext(ctx context.Context) PatientIdResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PatientIdResponseOutput)
}

// PatientIdResponseArrayInput is an input type that accepts PatientIdResponseArray and PatientIdResponseArrayOutput values.
// You can construct a concrete instance of `PatientIdResponseArrayInput` via:
//
//          PatientIdResponseArray{ PatientIdResponseArgs{...} }
type PatientIdResponseArrayInput interface {
	pulumi.Input

	ToPatientIdResponseArrayOutput() PatientIdResponseArrayOutput
	ToPatientIdResponseArrayOutputWithContext(context.Context) PatientIdResponseArrayOutput
}

type PatientIdResponseArray []PatientIdResponseInput

func (PatientIdResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PatientIdResponse)(nil)).Elem()
}

func (i PatientIdResponseArray) ToPatientIdResponseArrayOutput() PatientIdResponseArrayOutput {
	return i.ToPatientIdResponseArrayOutputWithContext(context.Background())
}

func (i PatientIdResponseArray) ToPatientIdResponseArrayOutputWithContext(ctx context.Context) PatientIdResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PatientIdResponseArrayOutput)
}

// A patient identifier and associated type.
type PatientIdResponseOutput struct{ *pulumi.OutputState }

func (PatientIdResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PatientIdResponse)(nil)).Elem()
}

func (o PatientIdResponseOutput) ToPatientIdResponseOutput() PatientIdResponseOutput {
	return o
}

func (o PatientIdResponseOutput) ToPatientIdResponseOutputWithContext(ctx context.Context) PatientIdResponseOutput {
	return o
}

// ID type. For example, MRN or NHS.
func (o PatientIdResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v PatientIdResponse) string { return v.Type }).(pulumi.StringOutput)
}

// The patient's unique identifier.
func (o PatientIdResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v PatientIdResponse) string { return v.Value }).(pulumi.StringOutput)
}

type PatientIdResponseArrayOutput struct{ *pulumi.OutputState }

func (PatientIdResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PatientIdResponse)(nil)).Elem()
}

func (o PatientIdResponseArrayOutput) ToPatientIdResponseArrayOutput() PatientIdResponseArrayOutput {
	return o
}

func (o PatientIdResponseArrayOutput) ToPatientIdResponseArrayOutputWithContext(ctx context.Context) PatientIdResponseArrayOutput {
	return o
}

func (o PatientIdResponseArrayOutput) Index(i pulumi.IntInput) PatientIdResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PatientIdResponse {
		return vs[0].([]PatientIdResponse)[vs[1].(int)]
	}).(PatientIdResponseOutput)
}

// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members` to a single `role`. Members can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') - etag: BwWWja0YfJA= - version: 3 For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
type Policy struct {
	// Specifies cloud audit logging configuration for this policy.
	AuditConfigs []AuditConfig `pulumi:"auditConfigs"`
	// Associates a list of `members` to a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one member.
	Bindings []Binding `pulumi:"bindings"`
	// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
	Etag *string `pulumi:"etag"`
	// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Version *int `pulumi:"version"`
}

// PolicyInput is an input type that accepts PolicyArgs and PolicyOutput values.
// You can construct a concrete instance of `PolicyInput` via:
//
//          PolicyArgs{...}
type PolicyInput interface {
	pulumi.Input

	ToPolicyOutput() PolicyOutput
	ToPolicyOutputWithContext(context.Context) PolicyOutput
}

// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members` to a single `role`. Members can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') - etag: BwWWja0YfJA= - version: 3 For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
type PolicyArgs struct {
	// Specifies cloud audit logging configuration for this policy.
	AuditConfigs AuditConfigArrayInput `pulumi:"auditConfigs"`
	// Associates a list of `members` to a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one member.
	Bindings BindingArrayInput `pulumi:"bindings"`
	// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
	Etag pulumi.StringPtrInput `pulumi:"etag"`
	// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Version pulumi.IntPtrInput `pulumi:"version"`
}

func (PolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Policy)(nil)).Elem()
}

func (i PolicyArgs) ToPolicyOutput() PolicyOutput {
	return i.ToPolicyOutputWithContext(context.Background())
}

func (i PolicyArgs) ToPolicyOutputWithContext(ctx context.Context) PolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyOutput)
}

func (i PolicyArgs) ToPolicyPtrOutput() PolicyPtrOutput {
	return i.ToPolicyPtrOutputWithContext(context.Background())
}

func (i PolicyArgs) ToPolicyPtrOutputWithContext(ctx context.Context) PolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyOutput).ToPolicyPtrOutputWithContext(ctx)
}

// PolicyPtrInput is an input type that accepts PolicyArgs, PolicyPtr and PolicyPtrOutput values.
// You can construct a concrete instance of `PolicyPtrInput` via:
//
//          PolicyArgs{...}
//
//  or:
//
//          nil
type PolicyPtrInput interface {
	pulumi.Input

	ToPolicyPtrOutput() PolicyPtrOutput
	ToPolicyPtrOutputWithContext(context.Context) PolicyPtrOutput
}

type policyPtrType PolicyArgs

func PolicyPtr(v *PolicyArgs) PolicyPtrInput {
	return (*policyPtrType)(v)
}

func (*policyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Policy)(nil)).Elem()
}

func (i *policyPtrType) ToPolicyPtrOutput() PolicyPtrOutput {
	return i.ToPolicyPtrOutputWithContext(context.Background())
}

func (i *policyPtrType) ToPolicyPtrOutputWithContext(ctx context.Context) PolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyPtrOutput)
}

// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members` to a single `role`. Members can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } **YAML example:** bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') - etag: BwWWja0YfJA= - version: 3 For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
type PolicyOutput struct{ *pulumi.OutputState }

func (PolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Policy)(nil)).Elem()
}

func (o PolicyOutput) ToPolicyOutput() PolicyOutput {
	return o
}

func (o PolicyOutput) ToPolicyOutputWithContext(ctx context.Context) PolicyOutput {
	return o
}

func (o PolicyOutput) ToPolicyPtrOutput() PolicyPtrOutput {
	return o.ToPolicyPtrOutputWithContext(context.Background())
}

func (o PolicyOutput) ToPolicyPtrOutputWithContext(ctx context.Context) PolicyPtrOutput {
	return o.ApplyT(func(v Policy) *Policy {
		return &v
	}).(PolicyPtrOutput)
}

// Specifies cloud audit logging configuration for this policy.
func (o PolicyOutput) AuditConfigs() AuditConfigArrayOutput {
	return o.ApplyT(func(v Policy) []AuditConfig { return v.AuditConfigs }).(AuditConfigArrayOutput)
}

// Associates a list of `members` to a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one member.
func (o PolicyOutput) Bindings() BindingArrayOutput {
	return o.ApplyT(func(v Policy) []Binding { return v.Bindings }).(BindingArrayOutput)
}

// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
func (o PolicyOutput) Etag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Policy) *string { return v.Etag }).(pulumi.StringPtrOutput)
}

// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o PolicyOutput) Version() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Policy) *int { return v.Version }).(pulumi.IntPtrOutput)
}

type PolicyPtrOutput struct{ *pulumi.OutputState }

func (PolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Policy)(nil)).Elem()
}

func (o PolicyPtrOutput) ToPolicyPtrOutput() PolicyPtrOutput {
	return o
}

func (o PolicyPtrOutput) ToPolicyPtrOutputWithContext(ctx context.Context) PolicyPtrOutput {
	return o
}

func (o PolicyPtrOutput) Elem() PolicyOutput {
	return o.ApplyT(func(v *Policy) Policy { return *v }).(PolicyOutput)
}

// Specifies cloud audit logging configuration for this policy.
func (o PolicyPtrOutput) AuditConfigs() AuditConfigArrayOutput {
	return o.ApplyT(func(v *Policy) []AuditConfig {
		if v == nil {
			return nil
		}
		return v.AuditConfigs
	}).(AuditConfigArrayOutput)
}

// Associates a list of `members` to a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one member.
func (o PolicyPtrOutput) Bindings() BindingArrayOutput {
	return o.ApplyT(func(v *Policy) []Binding {
		if v == nil {
			return nil
		}
		return v.Bindings
	}).(BindingArrayOutput)
}

// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
func (o PolicyPtrOutput) Etag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Policy) *string {
		if v == nil {
			return nil
		}
		return v.Etag
	}).(pulumi.StringPtrOutput)
}

// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o PolicyPtrOutput) Version() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Policy) *int {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.IntPtrOutput)
}

// Resource level annotation.
type ResourceAnnotation struct {
	// A description of the annotation record.
	Label *string `pulumi:"label"`
}

// ResourceAnnotationInput is an input type that accepts ResourceAnnotationArgs and ResourceAnnotationOutput values.
// You can construct a concrete instance of `ResourceAnnotationInput` via:
//
//          ResourceAnnotationArgs{...}
type ResourceAnnotationInput interface {
	pulumi.Input

	ToResourceAnnotationOutput() ResourceAnnotationOutput
	ToResourceAnnotationOutputWithContext(context.Context) ResourceAnnotationOutput
}

// Resource level annotation.
type ResourceAnnotationArgs struct {
	// A description of the annotation record.
	Label pulumi.StringPtrInput `pulumi:"label"`
}

func (ResourceAnnotationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceAnnotation)(nil)).Elem()
}

func (i ResourceAnnotationArgs) ToResourceAnnotationOutput() ResourceAnnotationOutput {
	return i.ToResourceAnnotationOutputWithContext(context.Background())
}

func (i ResourceAnnotationArgs) ToResourceAnnotationOutputWithContext(ctx context.Context) ResourceAnnotationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceAnnotationOutput)
}

func (i ResourceAnnotationArgs) ToResourceAnnotationPtrOutput() ResourceAnnotationPtrOutput {
	return i.ToResourceAnnotationPtrOutputWithContext(context.Background())
}

func (i ResourceAnnotationArgs) ToResourceAnnotationPtrOutputWithContext(ctx context.Context) ResourceAnnotationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceAnnotationOutput).ToResourceAnnotationPtrOutputWithContext(ctx)
}

// ResourceAnnotationPtrInput is an input type that accepts ResourceAnnotationArgs, ResourceAnnotationPtr and ResourceAnnotationPtrOutput values.
// You can construct a concrete instance of `ResourceAnnotationPtrInput` via:
//
//          ResourceAnnotationArgs{...}
//
//  or:
//
//          nil
type ResourceAnnotationPtrInput interface {
	pulumi.Input

	ToResourceAnnotationPtrOutput() ResourceAnnotationPtrOutput
	ToResourceAnnotationPtrOutputWithContext(context.Context) ResourceAnnotationPtrOutput
}

type resourceAnnotationPtrType ResourceAnnotationArgs

func ResourceAnnotationPtr(v *ResourceAnnotationArgs) ResourceAnnotationPtrInput {
	return (*resourceAnnotationPtrType)(v)
}

func (*resourceAnnotationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceAnnotation)(nil)).Elem()
}

func (i *resourceAnnotationPtrType) ToResourceAnnotationPtrOutput() ResourceAnnotationPtrOutput {
	return i.ToResourceAnnotationPtrOutputWithContext(context.Background())
}

func (i *resourceAnnotationPtrType) ToResourceAnnotationPtrOutputWithContext(ctx context.Context) ResourceAnnotationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceAnnotationPtrOutput)
}

// Resource level annotation.
type ResourceAnnotationOutput struct{ *pulumi.OutputState }

func (ResourceAnnotationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceAnnotation)(nil)).Elem()
}

func (o ResourceAnnotationOutput) ToResourceAnnotationOutput() ResourceAnnotationOutput {
	return o
}

func (o ResourceAnnotationOutput) ToResourceAnnotationOutputWithContext(ctx context.Context) ResourceAnnotationOutput {
	return o
}

func (o ResourceAnnotationOutput) ToResourceAnnotationPtrOutput() ResourceAnnotationPtrOutput {
	return o.ToResourceAnnotationPtrOutputWithContext(context.Background())
}

func (o ResourceAnnotationOutput) ToResourceAnnotationPtrOutputWithContext(ctx context.Context) ResourceAnnotationPtrOutput {
	return o.ApplyT(func(v ResourceAnnotation) *ResourceAnnotation {
		return &v
	}).(ResourceAnnotationPtrOutput)
}

// A description of the annotation record.
func (o ResourceAnnotationOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceAnnotation) *string { return v.Label }).(pulumi.StringPtrOutput)
}

type ResourceAnnotationPtrOutput struct{ *pulumi.OutputState }

func (ResourceAnnotationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceAnnotation)(nil)).Elem()
}

func (o ResourceAnnotationPtrOutput) ToResourceAnnotationPtrOutput() ResourceAnnotationPtrOutput {
	return o
}

func (o ResourceAnnotationPtrOutput) ToResourceAnnotationPtrOutputWithContext(ctx context.Context) ResourceAnnotationPtrOutput {
	return o
}

func (o ResourceAnnotationPtrOutput) Elem() ResourceAnnotationOutput {
	return o.ApplyT(func(v *ResourceAnnotation) ResourceAnnotation { return *v }).(ResourceAnnotationOutput)
}

// A description of the annotation record.
func (o ResourceAnnotationPtrOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceAnnotation) *string {
		if v == nil {
			return nil
		}
		return v.Label
	}).(pulumi.StringPtrOutput)
}

// Resource level annotation.
type ResourceAnnotationResponse struct {
	// A description of the annotation record.
	Label string `pulumi:"label"`
}

// ResourceAnnotationResponseInput is an input type that accepts ResourceAnnotationResponseArgs and ResourceAnnotationResponseOutput values.
// You can construct a concrete instance of `ResourceAnnotationResponseInput` via:
//
//          ResourceAnnotationResponseArgs{...}
type ResourceAnnotationResponseInput interface {
	pulumi.Input

	ToResourceAnnotationResponseOutput() ResourceAnnotationResponseOutput
	ToResourceAnnotationResponseOutputWithContext(context.Context) ResourceAnnotationResponseOutput
}

// Resource level annotation.
type ResourceAnnotationResponseArgs struct {
	// A description of the annotation record.
	Label pulumi.StringInput `pulumi:"label"`
}

func (ResourceAnnotationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceAnnotationResponse)(nil)).Elem()
}

func (i ResourceAnnotationResponseArgs) ToResourceAnnotationResponseOutput() ResourceAnnotationResponseOutput {
	return i.ToResourceAnnotationResponseOutputWithContext(context.Background())
}

func (i ResourceAnnotationResponseArgs) ToResourceAnnotationResponseOutputWithContext(ctx context.Context) ResourceAnnotationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceAnnotationResponseOutput)
}

func (i ResourceAnnotationResponseArgs) ToResourceAnnotationResponsePtrOutput() ResourceAnnotationResponsePtrOutput {
	return i.ToResourceAnnotationResponsePtrOutputWithContext(context.Background())
}

func (i ResourceAnnotationResponseArgs) ToResourceAnnotationResponsePtrOutputWithContext(ctx context.Context) ResourceAnnotationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceAnnotationResponseOutput).ToResourceAnnotationResponsePtrOutputWithContext(ctx)
}

// ResourceAnnotationResponsePtrInput is an input type that accepts ResourceAnnotationResponseArgs, ResourceAnnotationResponsePtr and ResourceAnnotationResponsePtrOutput values.
// You can construct a concrete instance of `ResourceAnnotationResponsePtrInput` via:
//
//          ResourceAnnotationResponseArgs{...}
//
//  or:
//
//          nil
type ResourceAnnotationResponsePtrInput interface {
	pulumi.Input

	ToResourceAnnotationResponsePtrOutput() ResourceAnnotationResponsePtrOutput
	ToResourceAnnotationResponsePtrOutputWithContext(context.Context) ResourceAnnotationResponsePtrOutput
}

type resourceAnnotationResponsePtrType ResourceAnnotationResponseArgs

func ResourceAnnotationResponsePtr(v *ResourceAnnotationResponseArgs) ResourceAnnotationResponsePtrInput {
	return (*resourceAnnotationResponsePtrType)(v)
}

func (*resourceAnnotationResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceAnnotationResponse)(nil)).Elem()
}

func (i *resourceAnnotationResponsePtrType) ToResourceAnnotationResponsePtrOutput() ResourceAnnotationResponsePtrOutput {
	return i.ToResourceAnnotationResponsePtrOutputWithContext(context.Background())
}

func (i *resourceAnnotationResponsePtrType) ToResourceAnnotationResponsePtrOutputWithContext(ctx context.Context) ResourceAnnotationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceAnnotationResponsePtrOutput)
}

// Resource level annotation.
type ResourceAnnotationResponseOutput struct{ *pulumi.OutputState }

func (ResourceAnnotationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceAnnotationResponse)(nil)).Elem()
}

func (o ResourceAnnotationResponseOutput) ToResourceAnnotationResponseOutput() ResourceAnnotationResponseOutput {
	return o
}

func (o ResourceAnnotationResponseOutput) ToResourceAnnotationResponseOutputWithContext(ctx context.Context) ResourceAnnotationResponseOutput {
	return o
}

func (o ResourceAnnotationResponseOutput) ToResourceAnnotationResponsePtrOutput() ResourceAnnotationResponsePtrOutput {
	return o.ToResourceAnnotationResponsePtrOutputWithContext(context.Background())
}

func (o ResourceAnnotationResponseOutput) ToResourceAnnotationResponsePtrOutputWithContext(ctx context.Context) ResourceAnnotationResponsePtrOutput {
	return o.ApplyT(func(v ResourceAnnotationResponse) *ResourceAnnotationResponse {
		return &v
	}).(ResourceAnnotationResponsePtrOutput)
}

// A description of the annotation record.
func (o ResourceAnnotationResponseOutput) Label() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceAnnotationResponse) string { return v.Label }).(pulumi.StringOutput)
}

type ResourceAnnotationResponsePtrOutput struct{ *pulumi.OutputState }

func (ResourceAnnotationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceAnnotationResponse)(nil)).Elem()
}

func (o ResourceAnnotationResponsePtrOutput) ToResourceAnnotationResponsePtrOutput() ResourceAnnotationResponsePtrOutput {
	return o
}

func (o ResourceAnnotationResponsePtrOutput) ToResourceAnnotationResponsePtrOutputWithContext(ctx context.Context) ResourceAnnotationResponsePtrOutput {
	return o
}

func (o ResourceAnnotationResponsePtrOutput) Elem() ResourceAnnotationResponseOutput {
	return o.ApplyT(func(v *ResourceAnnotationResponse) ResourceAnnotationResponse { return *v }).(ResourceAnnotationResponseOutput)
}

// A description of the annotation record.
func (o ResourceAnnotationResponsePtrOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceAnnotationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Label
	}).(pulumi.StringPtrOutput)
}

// Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
type SchemaConfig struct {
	// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
	RecursiveStructureDepth *string `pulumi:"recursiveStructureDepth"`
	// Specifies the output schema type. Schema type is required.
	SchemaType *string `pulumi:"schemaType"`
}

// SchemaConfigInput is an input type that accepts SchemaConfigArgs and SchemaConfigOutput values.
// You can construct a concrete instance of `SchemaConfigInput` via:
//
//          SchemaConfigArgs{...}
type SchemaConfigInput interface {
	pulumi.Input

	ToSchemaConfigOutput() SchemaConfigOutput
	ToSchemaConfigOutputWithContext(context.Context) SchemaConfigOutput
}

// Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
type SchemaConfigArgs struct {
	// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
	RecursiveStructureDepth pulumi.StringPtrInput `pulumi:"recursiveStructureDepth"`
	// Specifies the output schema type. Schema type is required.
	SchemaType pulumi.StringPtrInput `pulumi:"schemaType"`
}

func (SchemaConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaConfig)(nil)).Elem()
}

func (i SchemaConfigArgs) ToSchemaConfigOutput() SchemaConfigOutput {
	return i.ToSchemaConfigOutputWithContext(context.Background())
}

func (i SchemaConfigArgs) ToSchemaConfigOutputWithContext(ctx context.Context) SchemaConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaConfigOutput)
}

func (i SchemaConfigArgs) ToSchemaConfigPtrOutput() SchemaConfigPtrOutput {
	return i.ToSchemaConfigPtrOutputWithContext(context.Background())
}

func (i SchemaConfigArgs) ToSchemaConfigPtrOutputWithContext(ctx context.Context) SchemaConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaConfigOutput).ToSchemaConfigPtrOutputWithContext(ctx)
}

// SchemaConfigPtrInput is an input type that accepts SchemaConfigArgs, SchemaConfigPtr and SchemaConfigPtrOutput values.
// You can construct a concrete instance of `SchemaConfigPtrInput` via:
//
//          SchemaConfigArgs{...}
//
//  or:
//
//          nil
type SchemaConfigPtrInput interface {
	pulumi.Input

	ToSchemaConfigPtrOutput() SchemaConfigPtrOutput
	ToSchemaConfigPtrOutputWithContext(context.Context) SchemaConfigPtrOutput
}

type schemaConfigPtrType SchemaConfigArgs

func SchemaConfigPtr(v *SchemaConfigArgs) SchemaConfigPtrInput {
	return (*schemaConfigPtrType)(v)
}

func (*schemaConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaConfig)(nil)).Elem()
}

func (i *schemaConfigPtrType) ToSchemaConfigPtrOutput() SchemaConfigPtrOutput {
	return i.ToSchemaConfigPtrOutputWithContext(context.Background())
}

func (i *schemaConfigPtrType) ToSchemaConfigPtrOutputWithContext(ctx context.Context) SchemaConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaConfigPtrOutput)
}

// Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
type SchemaConfigOutput struct{ *pulumi.OutputState }

func (SchemaConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaConfig)(nil)).Elem()
}

func (o SchemaConfigOutput) ToSchemaConfigOutput() SchemaConfigOutput {
	return o
}

func (o SchemaConfigOutput) ToSchemaConfigOutputWithContext(ctx context.Context) SchemaConfigOutput {
	return o
}

func (o SchemaConfigOutput) ToSchemaConfigPtrOutput() SchemaConfigPtrOutput {
	return o.ToSchemaConfigPtrOutputWithContext(context.Background())
}

func (o SchemaConfigOutput) ToSchemaConfigPtrOutputWithContext(ctx context.Context) SchemaConfigPtrOutput {
	return o.ApplyT(func(v SchemaConfig) *SchemaConfig {
		return &v
	}).(SchemaConfigPtrOutput)
}

// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
func (o SchemaConfigOutput) RecursiveStructureDepth() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SchemaConfig) *string { return v.RecursiveStructureDepth }).(pulumi.StringPtrOutput)
}

// Specifies the output schema type. Schema type is required.
func (o SchemaConfigOutput) SchemaType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SchemaConfig) *string { return v.SchemaType }).(pulumi.StringPtrOutput)
}

type SchemaConfigPtrOutput struct{ *pulumi.OutputState }

func (SchemaConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaConfig)(nil)).Elem()
}

func (o SchemaConfigPtrOutput) ToSchemaConfigPtrOutput() SchemaConfigPtrOutput {
	return o
}

func (o SchemaConfigPtrOutput) ToSchemaConfigPtrOutputWithContext(ctx context.Context) SchemaConfigPtrOutput {
	return o
}

func (o SchemaConfigPtrOutput) Elem() SchemaConfigOutput {
	return o.ApplyT(func(v *SchemaConfig) SchemaConfig { return *v }).(SchemaConfigOutput)
}

// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
func (o SchemaConfigPtrOutput) RecursiveStructureDepth() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchemaConfig) *string {
		if v == nil {
			return nil
		}
		return v.RecursiveStructureDepth
	}).(pulumi.StringPtrOutput)
}

// Specifies the output schema type. Schema type is required.
func (o SchemaConfigPtrOutput) SchemaType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchemaConfig) *string {
		if v == nil {
			return nil
		}
		return v.SchemaType
	}).(pulumi.StringPtrOutput)
}

// Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
type SchemaConfigResponse struct {
	// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
	RecursiveStructureDepth string `pulumi:"recursiveStructureDepth"`
	// Specifies the output schema type. Schema type is required.
	SchemaType string `pulumi:"schemaType"`
}

// SchemaConfigResponseInput is an input type that accepts SchemaConfigResponseArgs and SchemaConfigResponseOutput values.
// You can construct a concrete instance of `SchemaConfigResponseInput` via:
//
//          SchemaConfigResponseArgs{...}
type SchemaConfigResponseInput interface {
	pulumi.Input

	ToSchemaConfigResponseOutput() SchemaConfigResponseOutput
	ToSchemaConfigResponseOutputWithContext(context.Context) SchemaConfigResponseOutput
}

// Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
type SchemaConfigResponseArgs struct {
	// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
	RecursiveStructureDepth pulumi.StringInput `pulumi:"recursiveStructureDepth"`
	// Specifies the output schema type. Schema type is required.
	SchemaType pulumi.StringInput `pulumi:"schemaType"`
}

func (SchemaConfigResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaConfigResponse)(nil)).Elem()
}

func (i SchemaConfigResponseArgs) ToSchemaConfigResponseOutput() SchemaConfigResponseOutput {
	return i.ToSchemaConfigResponseOutputWithContext(context.Background())
}

func (i SchemaConfigResponseArgs) ToSchemaConfigResponseOutputWithContext(ctx context.Context) SchemaConfigResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaConfigResponseOutput)
}

// Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
type SchemaConfigResponseOutput struct{ *pulumi.OutputState }

func (SchemaConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaConfigResponse)(nil)).Elem()
}

func (o SchemaConfigResponseOutput) ToSchemaConfigResponseOutput() SchemaConfigResponseOutput {
	return o
}

func (o SchemaConfigResponseOutput) ToSchemaConfigResponseOutputWithContext(ctx context.Context) SchemaConfigResponseOutput {
	return o
}

// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
func (o SchemaConfigResponseOutput) RecursiveStructureDepth() pulumi.StringOutput {
	return o.ApplyT(func(v SchemaConfigResponse) string { return v.RecursiveStructureDepth }).(pulumi.StringOutput)
}

// Specifies the output schema type. Schema type is required.
func (o SchemaConfigResponseOutput) SchemaType() pulumi.StringOutput {
	return o.ApplyT(func(v SchemaConfigResponse) string { return v.SchemaType }).(pulumi.StringOutput)
}

// A schema package contains a set of schemas and type definitions.
type SchemaPackage struct {
	// Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
	IgnoreMinOccurs *bool `pulumi:"ignoreMinOccurs"`
	// Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
	Schemas []Hl7SchemaConfig `pulumi:"schemas"`
	// Determines how messages that fail to parse are handled.
	SchematizedParsingType *string `pulumi:"schematizedParsingType"`
	// Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
	Types []Hl7TypesConfig `pulumi:"types"`
	// Determines how unexpected segments (segments not matched to the schema) are handled.
	UnexpectedSegmentHandling *string `pulumi:"unexpectedSegmentHandling"`
}

// SchemaPackageInput is an input type that accepts SchemaPackageArgs and SchemaPackageOutput values.
// You can construct a concrete instance of `SchemaPackageInput` via:
//
//          SchemaPackageArgs{...}
type SchemaPackageInput interface {
	pulumi.Input

	ToSchemaPackageOutput() SchemaPackageOutput
	ToSchemaPackageOutputWithContext(context.Context) SchemaPackageOutput
}

// A schema package contains a set of schemas and type definitions.
type SchemaPackageArgs struct {
	// Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
	IgnoreMinOccurs pulumi.BoolPtrInput `pulumi:"ignoreMinOccurs"`
	// Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
	Schemas Hl7SchemaConfigArrayInput `pulumi:"schemas"`
	// Determines how messages that fail to parse are handled.
	SchematizedParsingType pulumi.StringPtrInput `pulumi:"schematizedParsingType"`
	// Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
	Types Hl7TypesConfigArrayInput `pulumi:"types"`
	// Determines how unexpected segments (segments not matched to the schema) are handled.
	UnexpectedSegmentHandling pulumi.StringPtrInput `pulumi:"unexpectedSegmentHandling"`
}

func (SchemaPackageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaPackage)(nil)).Elem()
}

func (i SchemaPackageArgs) ToSchemaPackageOutput() SchemaPackageOutput {
	return i.ToSchemaPackageOutputWithContext(context.Background())
}

func (i SchemaPackageArgs) ToSchemaPackageOutputWithContext(ctx context.Context) SchemaPackageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaPackageOutput)
}

func (i SchemaPackageArgs) ToSchemaPackagePtrOutput() SchemaPackagePtrOutput {
	return i.ToSchemaPackagePtrOutputWithContext(context.Background())
}

func (i SchemaPackageArgs) ToSchemaPackagePtrOutputWithContext(ctx context.Context) SchemaPackagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaPackageOutput).ToSchemaPackagePtrOutputWithContext(ctx)
}

// SchemaPackagePtrInput is an input type that accepts SchemaPackageArgs, SchemaPackagePtr and SchemaPackagePtrOutput values.
// You can construct a concrete instance of `SchemaPackagePtrInput` via:
//
//          SchemaPackageArgs{...}
//
//  or:
//
//          nil
type SchemaPackagePtrInput interface {
	pulumi.Input

	ToSchemaPackagePtrOutput() SchemaPackagePtrOutput
	ToSchemaPackagePtrOutputWithContext(context.Context) SchemaPackagePtrOutput
}

type schemaPackagePtrType SchemaPackageArgs

func SchemaPackagePtr(v *SchemaPackageArgs) SchemaPackagePtrInput {
	return (*schemaPackagePtrType)(v)
}

func (*schemaPackagePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaPackage)(nil)).Elem()
}

func (i *schemaPackagePtrType) ToSchemaPackagePtrOutput() SchemaPackagePtrOutput {
	return i.ToSchemaPackagePtrOutputWithContext(context.Background())
}

func (i *schemaPackagePtrType) ToSchemaPackagePtrOutputWithContext(ctx context.Context) SchemaPackagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaPackagePtrOutput)
}

// A schema package contains a set of schemas and type definitions.
type SchemaPackageOutput struct{ *pulumi.OutputState }

func (SchemaPackageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaPackage)(nil)).Elem()
}

func (o SchemaPackageOutput) ToSchemaPackageOutput() SchemaPackageOutput {
	return o
}

func (o SchemaPackageOutput) ToSchemaPackageOutputWithContext(ctx context.Context) SchemaPackageOutput {
	return o
}

func (o SchemaPackageOutput) ToSchemaPackagePtrOutput() SchemaPackagePtrOutput {
	return o.ToSchemaPackagePtrOutputWithContext(context.Background())
}

func (o SchemaPackageOutput) ToSchemaPackagePtrOutputWithContext(ctx context.Context) SchemaPackagePtrOutput {
	return o.ApplyT(func(v SchemaPackage) *SchemaPackage {
		return &v
	}).(SchemaPackagePtrOutput)
}

// Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
func (o SchemaPackageOutput) IgnoreMinOccurs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SchemaPackage) *bool { return v.IgnoreMinOccurs }).(pulumi.BoolPtrOutput)
}

// Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
func (o SchemaPackageOutput) Schemas() Hl7SchemaConfigArrayOutput {
	return o.ApplyT(func(v SchemaPackage) []Hl7SchemaConfig { return v.Schemas }).(Hl7SchemaConfigArrayOutput)
}

// Determines how messages that fail to parse are handled.
func (o SchemaPackageOutput) SchematizedParsingType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SchemaPackage) *string { return v.SchematizedParsingType }).(pulumi.StringPtrOutput)
}

// Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
func (o SchemaPackageOutput) Types() Hl7TypesConfigArrayOutput {
	return o.ApplyT(func(v SchemaPackage) []Hl7TypesConfig { return v.Types }).(Hl7TypesConfigArrayOutput)
}

// Determines how unexpected segments (segments not matched to the schema) are handled.
func (o SchemaPackageOutput) UnexpectedSegmentHandling() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SchemaPackage) *string { return v.UnexpectedSegmentHandling }).(pulumi.StringPtrOutput)
}

type SchemaPackagePtrOutput struct{ *pulumi.OutputState }

func (SchemaPackagePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaPackage)(nil)).Elem()
}

func (o SchemaPackagePtrOutput) ToSchemaPackagePtrOutput() SchemaPackagePtrOutput {
	return o
}

func (o SchemaPackagePtrOutput) ToSchemaPackagePtrOutputWithContext(ctx context.Context) SchemaPackagePtrOutput {
	return o
}

func (o SchemaPackagePtrOutput) Elem() SchemaPackageOutput {
	return o.ApplyT(func(v *SchemaPackage) SchemaPackage { return *v }).(SchemaPackageOutput)
}

// Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
func (o SchemaPackagePtrOutput) IgnoreMinOccurs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SchemaPackage) *bool {
		if v == nil {
			return nil
		}
		return v.IgnoreMinOccurs
	}).(pulumi.BoolPtrOutput)
}

// Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
func (o SchemaPackagePtrOutput) Schemas() Hl7SchemaConfigArrayOutput {
	return o.ApplyT(func(v *SchemaPackage) []Hl7SchemaConfig {
		if v == nil {
			return nil
		}
		return v.Schemas
	}).(Hl7SchemaConfigArrayOutput)
}

// Determines how messages that fail to parse are handled.
func (o SchemaPackagePtrOutput) SchematizedParsingType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchemaPackage) *string {
		if v == nil {
			return nil
		}
		return v.SchematizedParsingType
	}).(pulumi.StringPtrOutput)
}

// Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
func (o SchemaPackagePtrOutput) Types() Hl7TypesConfigArrayOutput {
	return o.ApplyT(func(v *SchemaPackage) []Hl7TypesConfig {
		if v == nil {
			return nil
		}
		return v.Types
	}).(Hl7TypesConfigArrayOutput)
}

// Determines how unexpected segments (segments not matched to the schema) are handled.
func (o SchemaPackagePtrOutput) UnexpectedSegmentHandling() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchemaPackage) *string {
		if v == nil {
			return nil
		}
		return v.UnexpectedSegmentHandling
	}).(pulumi.StringPtrOutput)
}

// A schema package contains a set of schemas and type definitions.
type SchemaPackageResponse struct {
	// Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
	IgnoreMinOccurs bool `pulumi:"ignoreMinOccurs"`
	// Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
	Schemas []Hl7SchemaConfigResponse `pulumi:"schemas"`
	// Determines how messages that fail to parse are handled.
	SchematizedParsingType string `pulumi:"schematizedParsingType"`
	// Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
	Types []Hl7TypesConfigResponse `pulumi:"types"`
	// Determines how unexpected segments (segments not matched to the schema) are handled.
	UnexpectedSegmentHandling string `pulumi:"unexpectedSegmentHandling"`
}

// SchemaPackageResponseInput is an input type that accepts SchemaPackageResponseArgs and SchemaPackageResponseOutput values.
// You can construct a concrete instance of `SchemaPackageResponseInput` via:
//
//          SchemaPackageResponseArgs{...}
type SchemaPackageResponseInput interface {
	pulumi.Input

	ToSchemaPackageResponseOutput() SchemaPackageResponseOutput
	ToSchemaPackageResponseOutputWithContext(context.Context) SchemaPackageResponseOutput
}

// A schema package contains a set of schemas and type definitions.
type SchemaPackageResponseArgs struct {
	// Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
	IgnoreMinOccurs pulumi.BoolInput `pulumi:"ignoreMinOccurs"`
	// Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
	Schemas Hl7SchemaConfigResponseArrayInput `pulumi:"schemas"`
	// Determines how messages that fail to parse are handled.
	SchematizedParsingType pulumi.StringInput `pulumi:"schematizedParsingType"`
	// Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
	Types Hl7TypesConfigResponseArrayInput `pulumi:"types"`
	// Determines how unexpected segments (segments not matched to the schema) are handled.
	UnexpectedSegmentHandling pulumi.StringInput `pulumi:"unexpectedSegmentHandling"`
}

func (SchemaPackageResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaPackageResponse)(nil)).Elem()
}

func (i SchemaPackageResponseArgs) ToSchemaPackageResponseOutput() SchemaPackageResponseOutput {
	return i.ToSchemaPackageResponseOutputWithContext(context.Background())
}

func (i SchemaPackageResponseArgs) ToSchemaPackageResponseOutputWithContext(ctx context.Context) SchemaPackageResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaPackageResponseOutput)
}

func (i SchemaPackageResponseArgs) ToSchemaPackageResponsePtrOutput() SchemaPackageResponsePtrOutput {
	return i.ToSchemaPackageResponsePtrOutputWithContext(context.Background())
}

func (i SchemaPackageResponseArgs) ToSchemaPackageResponsePtrOutputWithContext(ctx context.Context) SchemaPackageResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaPackageResponseOutput).ToSchemaPackageResponsePtrOutputWithContext(ctx)
}

// SchemaPackageResponsePtrInput is an input type that accepts SchemaPackageResponseArgs, SchemaPackageResponsePtr and SchemaPackageResponsePtrOutput values.
// You can construct a concrete instance of `SchemaPackageResponsePtrInput` via:
//
//          SchemaPackageResponseArgs{...}
//
//  or:
//
//          nil
type SchemaPackageResponsePtrInput interface {
	pulumi.Input

	ToSchemaPackageResponsePtrOutput() SchemaPackageResponsePtrOutput
	ToSchemaPackageResponsePtrOutputWithContext(context.Context) SchemaPackageResponsePtrOutput
}

type schemaPackageResponsePtrType SchemaPackageResponseArgs

func SchemaPackageResponsePtr(v *SchemaPackageResponseArgs) SchemaPackageResponsePtrInput {
	return (*schemaPackageResponsePtrType)(v)
}

func (*schemaPackageResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaPackageResponse)(nil)).Elem()
}

func (i *schemaPackageResponsePtrType) ToSchemaPackageResponsePtrOutput() SchemaPackageResponsePtrOutput {
	return i.ToSchemaPackageResponsePtrOutputWithContext(context.Background())
}

func (i *schemaPackageResponsePtrType) ToSchemaPackageResponsePtrOutputWithContext(ctx context.Context) SchemaPackageResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaPackageResponsePtrOutput)
}

// A schema package contains a set of schemas and type definitions.
type SchemaPackageResponseOutput struct{ *pulumi.OutputState }

func (SchemaPackageResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaPackageResponse)(nil)).Elem()
}

func (o SchemaPackageResponseOutput) ToSchemaPackageResponseOutput() SchemaPackageResponseOutput {
	return o
}

func (o SchemaPackageResponseOutput) ToSchemaPackageResponseOutputWithContext(ctx context.Context) SchemaPackageResponseOutput {
	return o
}

func (o SchemaPackageResponseOutput) ToSchemaPackageResponsePtrOutput() SchemaPackageResponsePtrOutput {
	return o.ToSchemaPackageResponsePtrOutputWithContext(context.Background())
}

func (o SchemaPackageResponseOutput) ToSchemaPackageResponsePtrOutputWithContext(ctx context.Context) SchemaPackageResponsePtrOutput {
	return o.ApplyT(func(v SchemaPackageResponse) *SchemaPackageResponse {
		return &v
	}).(SchemaPackageResponsePtrOutput)
}

// Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
func (o SchemaPackageResponseOutput) IgnoreMinOccurs() pulumi.BoolOutput {
	return o.ApplyT(func(v SchemaPackageResponse) bool { return v.IgnoreMinOccurs }).(pulumi.BoolOutput)
}

// Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
func (o SchemaPackageResponseOutput) Schemas() Hl7SchemaConfigResponseArrayOutput {
	return o.ApplyT(func(v SchemaPackageResponse) []Hl7SchemaConfigResponse { return v.Schemas }).(Hl7SchemaConfigResponseArrayOutput)
}

// Determines how messages that fail to parse are handled.
func (o SchemaPackageResponseOutput) SchematizedParsingType() pulumi.StringOutput {
	return o.ApplyT(func(v SchemaPackageResponse) string { return v.SchematizedParsingType }).(pulumi.StringOutput)
}

// Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
func (o SchemaPackageResponseOutput) Types() Hl7TypesConfigResponseArrayOutput {
	return o.ApplyT(func(v SchemaPackageResponse) []Hl7TypesConfigResponse { return v.Types }).(Hl7TypesConfigResponseArrayOutput)
}

// Determines how unexpected segments (segments not matched to the schema) are handled.
func (o SchemaPackageResponseOutput) UnexpectedSegmentHandling() pulumi.StringOutput {
	return o.ApplyT(func(v SchemaPackageResponse) string { return v.UnexpectedSegmentHandling }).(pulumi.StringOutput)
}

type SchemaPackageResponsePtrOutput struct{ *pulumi.OutputState }

func (SchemaPackageResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaPackageResponse)(nil)).Elem()
}

func (o SchemaPackageResponsePtrOutput) ToSchemaPackageResponsePtrOutput() SchemaPackageResponsePtrOutput {
	return o
}

func (o SchemaPackageResponsePtrOutput) ToSchemaPackageResponsePtrOutputWithContext(ctx context.Context) SchemaPackageResponsePtrOutput {
	return o
}

func (o SchemaPackageResponsePtrOutput) Elem() SchemaPackageResponseOutput {
	return o.ApplyT(func(v *SchemaPackageResponse) SchemaPackageResponse { return *v }).(SchemaPackageResponseOutput)
}

// Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
func (o SchemaPackageResponsePtrOutput) IgnoreMinOccurs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SchemaPackageResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.IgnoreMinOccurs
	}).(pulumi.BoolPtrOutput)
}

// Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
func (o SchemaPackageResponsePtrOutput) Schemas() Hl7SchemaConfigResponseArrayOutput {
	return o.ApplyT(func(v *SchemaPackageResponse) []Hl7SchemaConfigResponse {
		if v == nil {
			return nil
		}
		return v.Schemas
	}).(Hl7SchemaConfigResponseArrayOutput)
}

// Determines how messages that fail to parse are handled.
func (o SchemaPackageResponsePtrOutput) SchematizedParsingType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchemaPackageResponse) *string {
		if v == nil {
			return nil
		}
		return &v.SchematizedParsingType
	}).(pulumi.StringPtrOutput)
}

// Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
func (o SchemaPackageResponsePtrOutput) Types() Hl7TypesConfigResponseArrayOutput {
	return o.ApplyT(func(v *SchemaPackageResponse) []Hl7TypesConfigResponse {
		if v == nil {
			return nil
		}
		return v.Types
	}).(Hl7TypesConfigResponseArrayOutput)
}

// Determines how unexpected segments (segments not matched to the schema) are handled.
func (o SchemaPackageResponsePtrOutput) UnexpectedSegmentHandling() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchemaPackageResponse) *string {
		if v == nil {
			return nil
		}
		return &v.UnexpectedSegmentHandling
	}).(pulumi.StringPtrOutput)
}

// The content of an HL7v2 message in a structured format as specified by a schema.
type SchematizedData struct {
	// JSON output of the parser.
	Data *string `pulumi:"data"`
	// The error output of the parser.
	Error *string `pulumi:"error"`
}

// SchematizedDataInput is an input type that accepts SchematizedDataArgs and SchematizedDataOutput values.
// You can construct a concrete instance of `SchematizedDataInput` via:
//
//          SchematizedDataArgs{...}
type SchematizedDataInput interface {
	pulumi.Input

	ToSchematizedDataOutput() SchematizedDataOutput
	ToSchematizedDataOutputWithContext(context.Context) SchematizedDataOutput
}

// The content of an HL7v2 message in a structured format as specified by a schema.
type SchematizedDataArgs struct {
	// JSON output of the parser.
	Data pulumi.StringPtrInput `pulumi:"data"`
	// The error output of the parser.
	Error pulumi.StringPtrInput `pulumi:"error"`
}

func (SchematizedDataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SchematizedData)(nil)).Elem()
}

func (i SchematizedDataArgs) ToSchematizedDataOutput() SchematizedDataOutput {
	return i.ToSchematizedDataOutputWithContext(context.Background())
}

func (i SchematizedDataArgs) ToSchematizedDataOutputWithContext(ctx context.Context) SchematizedDataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchematizedDataOutput)
}

func (i SchematizedDataArgs) ToSchematizedDataPtrOutput() SchematizedDataPtrOutput {
	return i.ToSchematizedDataPtrOutputWithContext(context.Background())
}

func (i SchematizedDataArgs) ToSchematizedDataPtrOutputWithContext(ctx context.Context) SchematizedDataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchematizedDataOutput).ToSchematizedDataPtrOutputWithContext(ctx)
}

// SchematizedDataPtrInput is an input type that accepts SchematizedDataArgs, SchematizedDataPtr and SchematizedDataPtrOutput values.
// You can construct a concrete instance of `SchematizedDataPtrInput` via:
//
//          SchematizedDataArgs{...}
//
//  or:
//
//          nil
type SchematizedDataPtrInput interface {
	pulumi.Input

	ToSchematizedDataPtrOutput() SchematizedDataPtrOutput
	ToSchematizedDataPtrOutputWithContext(context.Context) SchematizedDataPtrOutput
}

type schematizedDataPtrType SchematizedDataArgs

func SchematizedDataPtr(v *SchematizedDataArgs) SchematizedDataPtrInput {
	return (*schematizedDataPtrType)(v)
}

func (*schematizedDataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SchematizedData)(nil)).Elem()
}

func (i *schematizedDataPtrType) ToSchematizedDataPtrOutput() SchematizedDataPtrOutput {
	return i.ToSchematizedDataPtrOutputWithContext(context.Background())
}

func (i *schematizedDataPtrType) ToSchematizedDataPtrOutputWithContext(ctx context.Context) SchematizedDataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchematizedDataPtrOutput)
}

// The content of an HL7v2 message in a structured format as specified by a schema.
type SchematizedDataOutput struct{ *pulumi.OutputState }

func (SchematizedDataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchematizedData)(nil)).Elem()
}

func (o SchematizedDataOutput) ToSchematizedDataOutput() SchematizedDataOutput {
	return o
}

func (o SchematizedDataOutput) ToSchematizedDataOutputWithContext(ctx context.Context) SchematizedDataOutput {
	return o
}

func (o SchematizedDataOutput) ToSchematizedDataPtrOutput() SchematizedDataPtrOutput {
	return o.ToSchematizedDataPtrOutputWithContext(context.Background())
}

func (o SchematizedDataOutput) ToSchematizedDataPtrOutputWithContext(ctx context.Context) SchematizedDataPtrOutput {
	return o.ApplyT(func(v SchematizedData) *SchematizedData {
		return &v
	}).(SchematizedDataPtrOutput)
}

// JSON output of the parser.
func (o SchematizedDataOutput) Data() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SchematizedData) *string { return v.Data }).(pulumi.StringPtrOutput)
}

// The error output of the parser.
func (o SchematizedDataOutput) Error() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SchematizedData) *string { return v.Error }).(pulumi.StringPtrOutput)
}

type SchematizedDataPtrOutput struct{ *pulumi.OutputState }

func (SchematizedDataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SchematizedData)(nil)).Elem()
}

func (o SchematizedDataPtrOutput) ToSchematizedDataPtrOutput() SchematizedDataPtrOutput {
	return o
}

func (o SchematizedDataPtrOutput) ToSchematizedDataPtrOutputWithContext(ctx context.Context) SchematizedDataPtrOutput {
	return o
}

func (o SchematizedDataPtrOutput) Elem() SchematizedDataOutput {
	return o.ApplyT(func(v *SchematizedData) SchematizedData { return *v }).(SchematizedDataOutput)
}

// JSON output of the parser.
func (o SchematizedDataPtrOutput) Data() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchematizedData) *string {
		if v == nil {
			return nil
		}
		return v.Data
	}).(pulumi.StringPtrOutput)
}

// The error output of the parser.
func (o SchematizedDataPtrOutput) Error() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchematizedData) *string {
		if v == nil {
			return nil
		}
		return v.Error
	}).(pulumi.StringPtrOutput)
}

// The content of an HL7v2 message in a structured format as specified by a schema.
type SchematizedDataResponse struct {
	// JSON output of the parser.
	Data string `pulumi:"data"`
	// The error output of the parser.
	Error string `pulumi:"error"`
}

// SchematizedDataResponseInput is an input type that accepts SchematizedDataResponseArgs and SchematizedDataResponseOutput values.
// You can construct a concrete instance of `SchematizedDataResponseInput` via:
//
//          SchematizedDataResponseArgs{...}
type SchematizedDataResponseInput interface {
	pulumi.Input

	ToSchematizedDataResponseOutput() SchematizedDataResponseOutput
	ToSchematizedDataResponseOutputWithContext(context.Context) SchematizedDataResponseOutput
}

// The content of an HL7v2 message in a structured format as specified by a schema.
type SchematizedDataResponseArgs struct {
	// JSON output of the parser.
	Data pulumi.StringInput `pulumi:"data"`
	// The error output of the parser.
	Error pulumi.StringInput `pulumi:"error"`
}

func (SchematizedDataResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SchematizedDataResponse)(nil)).Elem()
}

func (i SchematizedDataResponseArgs) ToSchematizedDataResponseOutput() SchematizedDataResponseOutput {
	return i.ToSchematizedDataResponseOutputWithContext(context.Background())
}

func (i SchematizedDataResponseArgs) ToSchematizedDataResponseOutputWithContext(ctx context.Context) SchematizedDataResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchematizedDataResponseOutput)
}

func (i SchematizedDataResponseArgs) ToSchematizedDataResponsePtrOutput() SchematizedDataResponsePtrOutput {
	return i.ToSchematizedDataResponsePtrOutputWithContext(context.Background())
}

func (i SchematizedDataResponseArgs) ToSchematizedDataResponsePtrOutputWithContext(ctx context.Context) SchematizedDataResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchematizedDataResponseOutput).ToSchematizedDataResponsePtrOutputWithContext(ctx)
}

// SchematizedDataResponsePtrInput is an input type that accepts SchematizedDataResponseArgs, SchematizedDataResponsePtr and SchematizedDataResponsePtrOutput values.
// You can construct a concrete instance of `SchematizedDataResponsePtrInput` via:
//
//          SchematizedDataResponseArgs{...}
//
//  or:
//
//          nil
type SchematizedDataResponsePtrInput interface {
	pulumi.Input

	ToSchematizedDataResponsePtrOutput() SchematizedDataResponsePtrOutput
	ToSchematizedDataResponsePtrOutputWithContext(context.Context) SchematizedDataResponsePtrOutput
}

type schematizedDataResponsePtrType SchematizedDataResponseArgs

func SchematizedDataResponsePtr(v *SchematizedDataResponseArgs) SchematizedDataResponsePtrInput {
	return (*schematizedDataResponsePtrType)(v)
}

func (*schematizedDataResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SchematizedDataResponse)(nil)).Elem()
}

func (i *schematizedDataResponsePtrType) ToSchematizedDataResponsePtrOutput() SchematizedDataResponsePtrOutput {
	return i.ToSchematizedDataResponsePtrOutputWithContext(context.Background())
}

func (i *schematizedDataResponsePtrType) ToSchematizedDataResponsePtrOutputWithContext(ctx context.Context) SchematizedDataResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchematizedDataResponsePtrOutput)
}

// The content of an HL7v2 message in a structured format as specified by a schema.
type SchematizedDataResponseOutput struct{ *pulumi.OutputState }

func (SchematizedDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchematizedDataResponse)(nil)).Elem()
}

func (o SchematizedDataResponseOutput) ToSchematizedDataResponseOutput() SchematizedDataResponseOutput {
	return o
}

func (o SchematizedDataResponseOutput) ToSchematizedDataResponseOutputWithContext(ctx context.Context) SchematizedDataResponseOutput {
	return o
}

func (o SchematizedDataResponseOutput) ToSchematizedDataResponsePtrOutput() SchematizedDataResponsePtrOutput {
	return o.ToSchematizedDataResponsePtrOutputWithContext(context.Background())
}

func (o SchematizedDataResponseOutput) ToSchematizedDataResponsePtrOutputWithContext(ctx context.Context) SchematizedDataResponsePtrOutput {
	return o.ApplyT(func(v SchematizedDataResponse) *SchematizedDataResponse {
		return &v
	}).(SchematizedDataResponsePtrOutput)
}

// JSON output of the parser.
func (o SchematizedDataResponseOutput) Data() pulumi.StringOutput {
	return o.ApplyT(func(v SchematizedDataResponse) string { return v.Data }).(pulumi.StringOutput)
}

// The error output of the parser.
func (o SchematizedDataResponseOutput) Error() pulumi.StringOutput {
	return o.ApplyT(func(v SchematizedDataResponse) string { return v.Error }).(pulumi.StringOutput)
}

type SchematizedDataResponsePtrOutput struct{ *pulumi.OutputState }

func (SchematizedDataResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SchematizedDataResponse)(nil)).Elem()
}

func (o SchematizedDataResponsePtrOutput) ToSchematizedDataResponsePtrOutput() SchematizedDataResponsePtrOutput {
	return o
}

func (o SchematizedDataResponsePtrOutput) ToSchematizedDataResponsePtrOutputWithContext(ctx context.Context) SchematizedDataResponsePtrOutput {
	return o
}

func (o SchematizedDataResponsePtrOutput) Elem() SchematizedDataResponseOutput {
	return o.ApplyT(func(v *SchematizedDataResponse) SchematizedDataResponse { return *v }).(SchematizedDataResponseOutput)
}

// JSON output of the parser.
func (o SchematizedDataResponsePtrOutput) Data() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchematizedDataResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Data
	}).(pulumi.StringPtrOutput)
}

// The error output of the parser.
func (o SchematizedDataResponsePtrOutput) Error() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchematizedDataResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Error
	}).(pulumi.StringPtrOutput)
}

// A segment in a structured format.
type SegmentResponse struct {
	// A mapping from the positional location to the value. The key string uses zero-based indexes separated by dots to identify Fields, components and sub-components. A bracket notation is also used to identify different instances of a repeated field. Regex for key: (\d+)(\[\d+\])?(.\d+)?(.\d+)? Examples of (key, value) pairs: * (0.1, "hemoglobin") denotes that the first component of Field 0 has the value "hemoglobin". * (1.1.2, "CBC") denotes that the second sub-component of the first component of Field 1 has the value "CBC". * (1[0].1, "HbA1c") denotes that the first component of the first Instance of Field 1, which is repeated, has the value "HbA1c".
	Fields map[string]string `pulumi:"fields"`
	// A string that indicates the type of segment. For example, EVN or PID.
	SegmentId string `pulumi:"segmentId"`
	// Set ID for segments that can be in a set. This can be empty if it's missing or isn't applicable.
	SetId string `pulumi:"setId"`
}

// SegmentResponseInput is an input type that accepts SegmentResponseArgs and SegmentResponseOutput values.
// You can construct a concrete instance of `SegmentResponseInput` via:
//
//          SegmentResponseArgs{...}
type SegmentResponseInput interface {
	pulumi.Input

	ToSegmentResponseOutput() SegmentResponseOutput
	ToSegmentResponseOutputWithContext(context.Context) SegmentResponseOutput
}

// A segment in a structured format.
type SegmentResponseArgs struct {
	// A mapping from the positional location to the value. The key string uses zero-based indexes separated by dots to identify Fields, components and sub-components. A bracket notation is also used to identify different instances of a repeated field. Regex for key: (\d+)(\[\d+\])?(.\d+)?(.\d+)? Examples of (key, value) pairs: * (0.1, "hemoglobin") denotes that the first component of Field 0 has the value "hemoglobin". * (1.1.2, "CBC") denotes that the second sub-component of the first component of Field 1 has the value "CBC". * (1[0].1, "HbA1c") denotes that the first component of the first Instance of Field 1, which is repeated, has the value "HbA1c".
	Fields pulumi.StringMapInput `pulumi:"fields"`
	// A string that indicates the type of segment. For example, EVN or PID.
	SegmentId pulumi.StringInput `pulumi:"segmentId"`
	// Set ID for segments that can be in a set. This can be empty if it's missing or isn't applicable.
	SetId pulumi.StringInput `pulumi:"setId"`
}

func (SegmentResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SegmentResponse)(nil)).Elem()
}

func (i SegmentResponseArgs) ToSegmentResponseOutput() SegmentResponseOutput {
	return i.ToSegmentResponseOutputWithContext(context.Background())
}

func (i SegmentResponseArgs) ToSegmentResponseOutputWithContext(ctx context.Context) SegmentResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SegmentResponseOutput)
}

// SegmentResponseArrayInput is an input type that accepts SegmentResponseArray and SegmentResponseArrayOutput values.
// You can construct a concrete instance of `SegmentResponseArrayInput` via:
//
//          SegmentResponseArray{ SegmentResponseArgs{...} }
type SegmentResponseArrayInput interface {
	pulumi.Input

	ToSegmentResponseArrayOutput() SegmentResponseArrayOutput
	ToSegmentResponseArrayOutputWithContext(context.Context) SegmentResponseArrayOutput
}

type SegmentResponseArray []SegmentResponseInput

func (SegmentResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SegmentResponse)(nil)).Elem()
}

func (i SegmentResponseArray) ToSegmentResponseArrayOutput() SegmentResponseArrayOutput {
	return i.ToSegmentResponseArrayOutputWithContext(context.Background())
}

func (i SegmentResponseArray) ToSegmentResponseArrayOutputWithContext(ctx context.Context) SegmentResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SegmentResponseArrayOutput)
}

// A segment in a structured format.
type SegmentResponseOutput struct{ *pulumi.OutputState }

func (SegmentResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SegmentResponse)(nil)).Elem()
}

func (o SegmentResponseOutput) ToSegmentResponseOutput() SegmentResponseOutput {
	return o
}

func (o SegmentResponseOutput) ToSegmentResponseOutputWithContext(ctx context.Context) SegmentResponseOutput {
	return o
}

// A mapping from the positional location to the value. The key string uses zero-based indexes separated by dots to identify Fields, components and sub-components. A bracket notation is also used to identify different instances of a repeated field. Regex for key: (\d+)(\[\d+\])?(.\d+)?(.\d+)? Examples of (key, value) pairs: * (0.1, "hemoglobin") denotes that the first component of Field 0 has the value "hemoglobin". * (1.1.2, "CBC") denotes that the second sub-component of the first component of Field 1 has the value "CBC". * (1[0].1, "HbA1c") denotes that the first component of the first Instance of Field 1, which is repeated, has the value "HbA1c".
func (o SegmentResponseOutput) Fields() pulumi.StringMapOutput {
	return o.ApplyT(func(v SegmentResponse) map[string]string { return v.Fields }).(pulumi.StringMapOutput)
}

// A string that indicates the type of segment. For example, EVN or PID.
func (o SegmentResponseOutput) SegmentId() pulumi.StringOutput {
	return o.ApplyT(func(v SegmentResponse) string { return v.SegmentId }).(pulumi.StringOutput)
}

// Set ID for segments that can be in a set. This can be empty if it's missing or isn't applicable.
func (o SegmentResponseOutput) SetId() pulumi.StringOutput {
	return o.ApplyT(func(v SegmentResponse) string { return v.SetId }).(pulumi.StringOutput)
}

type SegmentResponseArrayOutput struct{ *pulumi.OutputState }

func (SegmentResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SegmentResponse)(nil)).Elem()
}

func (o SegmentResponseArrayOutput) ToSegmentResponseArrayOutput() SegmentResponseArrayOutput {
	return o
}

func (o SegmentResponseArrayOutput) ToSegmentResponseArrayOutputWithContext(ctx context.Context) SegmentResponseArrayOutput {
	return o
}

func (o SegmentResponseArrayOutput) Index(i pulumi.IntInput) SegmentResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SegmentResponse {
		return vs[0].([]SegmentResponse)[vs[1].(int)]
	}).(SegmentResponseOutput)
}

// A TextAnnotation specifies a text range that includes sensitive information.
type SensitiveTextAnnotation struct {
	// Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
	Details map[string]string `pulumi:"details"`
}

// SensitiveTextAnnotationInput is an input type that accepts SensitiveTextAnnotationArgs and SensitiveTextAnnotationOutput values.
// You can construct a concrete instance of `SensitiveTextAnnotationInput` via:
//
//          SensitiveTextAnnotationArgs{...}
type SensitiveTextAnnotationInput interface {
	pulumi.Input

	ToSensitiveTextAnnotationOutput() SensitiveTextAnnotationOutput
	ToSensitiveTextAnnotationOutputWithContext(context.Context) SensitiveTextAnnotationOutput
}

// A TextAnnotation specifies a text range that includes sensitive information.
type SensitiveTextAnnotationArgs struct {
	// Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
	Details pulumi.StringMapInput `pulumi:"details"`
}

func (SensitiveTextAnnotationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SensitiveTextAnnotation)(nil)).Elem()
}

func (i SensitiveTextAnnotationArgs) ToSensitiveTextAnnotationOutput() SensitiveTextAnnotationOutput {
	return i.ToSensitiveTextAnnotationOutputWithContext(context.Background())
}

func (i SensitiveTextAnnotationArgs) ToSensitiveTextAnnotationOutputWithContext(ctx context.Context) SensitiveTextAnnotationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SensitiveTextAnnotationOutput)
}

func (i SensitiveTextAnnotationArgs) ToSensitiveTextAnnotationPtrOutput() SensitiveTextAnnotationPtrOutput {
	return i.ToSensitiveTextAnnotationPtrOutputWithContext(context.Background())
}

func (i SensitiveTextAnnotationArgs) ToSensitiveTextAnnotationPtrOutputWithContext(ctx context.Context) SensitiveTextAnnotationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SensitiveTextAnnotationOutput).ToSensitiveTextAnnotationPtrOutputWithContext(ctx)
}

// SensitiveTextAnnotationPtrInput is an input type that accepts SensitiveTextAnnotationArgs, SensitiveTextAnnotationPtr and SensitiveTextAnnotationPtrOutput values.
// You can construct a concrete instance of `SensitiveTextAnnotationPtrInput` via:
//
//          SensitiveTextAnnotationArgs{...}
//
//  or:
//
//          nil
type SensitiveTextAnnotationPtrInput interface {
	pulumi.Input

	ToSensitiveTextAnnotationPtrOutput() SensitiveTextAnnotationPtrOutput
	ToSensitiveTextAnnotationPtrOutputWithContext(context.Context) SensitiveTextAnnotationPtrOutput
}

type sensitiveTextAnnotationPtrType SensitiveTextAnnotationArgs

func SensitiveTextAnnotationPtr(v *SensitiveTextAnnotationArgs) SensitiveTextAnnotationPtrInput {
	return (*sensitiveTextAnnotationPtrType)(v)
}

func (*sensitiveTextAnnotationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SensitiveTextAnnotation)(nil)).Elem()
}

func (i *sensitiveTextAnnotationPtrType) ToSensitiveTextAnnotationPtrOutput() SensitiveTextAnnotationPtrOutput {
	return i.ToSensitiveTextAnnotationPtrOutputWithContext(context.Background())
}

func (i *sensitiveTextAnnotationPtrType) ToSensitiveTextAnnotationPtrOutputWithContext(ctx context.Context) SensitiveTextAnnotationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SensitiveTextAnnotationPtrOutput)
}

// A TextAnnotation specifies a text range that includes sensitive information.
type SensitiveTextAnnotationOutput struct{ *pulumi.OutputState }

func (SensitiveTextAnnotationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SensitiveTextAnnotation)(nil)).Elem()
}

func (o SensitiveTextAnnotationOutput) ToSensitiveTextAnnotationOutput() SensitiveTextAnnotationOutput {
	return o
}

func (o SensitiveTextAnnotationOutput) ToSensitiveTextAnnotationOutputWithContext(ctx context.Context) SensitiveTextAnnotationOutput {
	return o
}

func (o SensitiveTextAnnotationOutput) ToSensitiveTextAnnotationPtrOutput() SensitiveTextAnnotationPtrOutput {
	return o.ToSensitiveTextAnnotationPtrOutputWithContext(context.Background())
}

func (o SensitiveTextAnnotationOutput) ToSensitiveTextAnnotationPtrOutputWithContext(ctx context.Context) SensitiveTextAnnotationPtrOutput {
	return o.ApplyT(func(v SensitiveTextAnnotation) *SensitiveTextAnnotation {
		return &v
	}).(SensitiveTextAnnotationPtrOutput)
}

// Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
func (o SensitiveTextAnnotationOutput) Details() pulumi.StringMapOutput {
	return o.ApplyT(func(v SensitiveTextAnnotation) map[string]string { return v.Details }).(pulumi.StringMapOutput)
}

type SensitiveTextAnnotationPtrOutput struct{ *pulumi.OutputState }

func (SensitiveTextAnnotationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SensitiveTextAnnotation)(nil)).Elem()
}

func (o SensitiveTextAnnotationPtrOutput) ToSensitiveTextAnnotationPtrOutput() SensitiveTextAnnotationPtrOutput {
	return o
}

func (o SensitiveTextAnnotationPtrOutput) ToSensitiveTextAnnotationPtrOutputWithContext(ctx context.Context) SensitiveTextAnnotationPtrOutput {
	return o
}

func (o SensitiveTextAnnotationPtrOutput) Elem() SensitiveTextAnnotationOutput {
	return o.ApplyT(func(v *SensitiveTextAnnotation) SensitiveTextAnnotation { return *v }).(SensitiveTextAnnotationOutput)
}

// Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
func (o SensitiveTextAnnotationPtrOutput) Details() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SensitiveTextAnnotation) map[string]string {
		if v == nil {
			return nil
		}
		return v.Details
	}).(pulumi.StringMapOutput)
}

// A TextAnnotation specifies a text range that includes sensitive information.
type SensitiveTextAnnotationResponse struct {
	// Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
	Details map[string]string `pulumi:"details"`
}

// SensitiveTextAnnotationResponseInput is an input type that accepts SensitiveTextAnnotationResponseArgs and SensitiveTextAnnotationResponseOutput values.
// You can construct a concrete instance of `SensitiveTextAnnotationResponseInput` via:
//
//          SensitiveTextAnnotationResponseArgs{...}
type SensitiveTextAnnotationResponseInput interface {
	pulumi.Input

	ToSensitiveTextAnnotationResponseOutput() SensitiveTextAnnotationResponseOutput
	ToSensitiveTextAnnotationResponseOutputWithContext(context.Context) SensitiveTextAnnotationResponseOutput
}

// A TextAnnotation specifies a text range that includes sensitive information.
type SensitiveTextAnnotationResponseArgs struct {
	// Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
	Details pulumi.StringMapInput `pulumi:"details"`
}

func (SensitiveTextAnnotationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SensitiveTextAnnotationResponse)(nil)).Elem()
}

func (i SensitiveTextAnnotationResponseArgs) ToSensitiveTextAnnotationResponseOutput() SensitiveTextAnnotationResponseOutput {
	return i.ToSensitiveTextAnnotationResponseOutputWithContext(context.Background())
}

func (i SensitiveTextAnnotationResponseArgs) ToSensitiveTextAnnotationResponseOutputWithContext(ctx context.Context) SensitiveTextAnnotationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SensitiveTextAnnotationResponseOutput)
}

func (i SensitiveTextAnnotationResponseArgs) ToSensitiveTextAnnotationResponsePtrOutput() SensitiveTextAnnotationResponsePtrOutput {
	return i.ToSensitiveTextAnnotationResponsePtrOutputWithContext(context.Background())
}

func (i SensitiveTextAnnotationResponseArgs) ToSensitiveTextAnnotationResponsePtrOutputWithContext(ctx context.Context) SensitiveTextAnnotationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SensitiveTextAnnotationResponseOutput).ToSensitiveTextAnnotationResponsePtrOutputWithContext(ctx)
}

// SensitiveTextAnnotationResponsePtrInput is an input type that accepts SensitiveTextAnnotationResponseArgs, SensitiveTextAnnotationResponsePtr and SensitiveTextAnnotationResponsePtrOutput values.
// You can construct a concrete instance of `SensitiveTextAnnotationResponsePtrInput` via:
//
//          SensitiveTextAnnotationResponseArgs{...}
//
//  or:
//
//          nil
type SensitiveTextAnnotationResponsePtrInput interface {
	pulumi.Input

	ToSensitiveTextAnnotationResponsePtrOutput() SensitiveTextAnnotationResponsePtrOutput
	ToSensitiveTextAnnotationResponsePtrOutputWithContext(context.Context) SensitiveTextAnnotationResponsePtrOutput
}

type sensitiveTextAnnotationResponsePtrType SensitiveTextAnnotationResponseArgs

func SensitiveTextAnnotationResponsePtr(v *SensitiveTextAnnotationResponseArgs) SensitiveTextAnnotationResponsePtrInput {
	return (*sensitiveTextAnnotationResponsePtrType)(v)
}

func (*sensitiveTextAnnotationResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SensitiveTextAnnotationResponse)(nil)).Elem()
}

func (i *sensitiveTextAnnotationResponsePtrType) ToSensitiveTextAnnotationResponsePtrOutput() SensitiveTextAnnotationResponsePtrOutput {
	return i.ToSensitiveTextAnnotationResponsePtrOutputWithContext(context.Background())
}

func (i *sensitiveTextAnnotationResponsePtrType) ToSensitiveTextAnnotationResponsePtrOutputWithContext(ctx context.Context) SensitiveTextAnnotationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SensitiveTextAnnotationResponsePtrOutput)
}

// A TextAnnotation specifies a text range that includes sensitive information.
type SensitiveTextAnnotationResponseOutput struct{ *pulumi.OutputState }

func (SensitiveTextAnnotationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SensitiveTextAnnotationResponse)(nil)).Elem()
}

func (o SensitiveTextAnnotationResponseOutput) ToSensitiveTextAnnotationResponseOutput() SensitiveTextAnnotationResponseOutput {
	return o
}

func (o SensitiveTextAnnotationResponseOutput) ToSensitiveTextAnnotationResponseOutputWithContext(ctx context.Context) SensitiveTextAnnotationResponseOutput {
	return o
}

func (o SensitiveTextAnnotationResponseOutput) ToSensitiveTextAnnotationResponsePtrOutput() SensitiveTextAnnotationResponsePtrOutput {
	return o.ToSensitiveTextAnnotationResponsePtrOutputWithContext(context.Background())
}

func (o SensitiveTextAnnotationResponseOutput) ToSensitiveTextAnnotationResponsePtrOutputWithContext(ctx context.Context) SensitiveTextAnnotationResponsePtrOutput {
	return o.ApplyT(func(v SensitiveTextAnnotationResponse) *SensitiveTextAnnotationResponse {
		return &v
	}).(SensitiveTextAnnotationResponsePtrOutput)
}

// Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
func (o SensitiveTextAnnotationResponseOutput) Details() pulumi.StringMapOutput {
	return o.ApplyT(func(v SensitiveTextAnnotationResponse) map[string]string { return v.Details }).(pulumi.StringMapOutput)
}

type SensitiveTextAnnotationResponsePtrOutput struct{ *pulumi.OutputState }

func (SensitiveTextAnnotationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SensitiveTextAnnotationResponse)(nil)).Elem()
}

func (o SensitiveTextAnnotationResponsePtrOutput) ToSensitiveTextAnnotationResponsePtrOutput() SensitiveTextAnnotationResponsePtrOutput {
	return o
}

func (o SensitiveTextAnnotationResponsePtrOutput) ToSensitiveTextAnnotationResponsePtrOutputWithContext(ctx context.Context) SensitiveTextAnnotationResponsePtrOutput {
	return o
}

func (o SensitiveTextAnnotationResponsePtrOutput) Elem() SensitiveTextAnnotationResponseOutput {
	return o.ApplyT(func(v *SensitiveTextAnnotationResponse) SensitiveTextAnnotationResponse { return *v }).(SensitiveTextAnnotationResponseOutput)
}

// Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
func (o SensitiveTextAnnotationResponsePtrOutput) Details() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SensitiveTextAnnotationResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.Details
	}).(pulumi.StringMapOutput)
}

// User signature.
type Signature struct {
	// Optional. An image of the user's signature.
	Image *Image `pulumi:"image"`
	// Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
	Metadata map[string]string `pulumi:"metadata"`
	// Optional. Timestamp of the signature.
	SignatureTime *string `pulumi:"signatureTime"`
	// Required. User's UUID provided by the client.
	UserId *string `pulumi:"userId"`
}

// SignatureInput is an input type that accepts SignatureArgs and SignatureOutput values.
// You can construct a concrete instance of `SignatureInput` via:
//
//          SignatureArgs{...}
type SignatureInput interface {
	pulumi.Input

	ToSignatureOutput() SignatureOutput
	ToSignatureOutputWithContext(context.Context) SignatureOutput
}

// User signature.
type SignatureArgs struct {
	// Optional. An image of the user's signature.
	Image ImagePtrInput `pulumi:"image"`
	// Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
	Metadata pulumi.StringMapInput `pulumi:"metadata"`
	// Optional. Timestamp of the signature.
	SignatureTime pulumi.StringPtrInput `pulumi:"signatureTime"`
	// Required. User's UUID provided by the client.
	UserId pulumi.StringPtrInput `pulumi:"userId"`
}

func (SignatureArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Signature)(nil)).Elem()
}

func (i SignatureArgs) ToSignatureOutput() SignatureOutput {
	return i.ToSignatureOutputWithContext(context.Background())
}

func (i SignatureArgs) ToSignatureOutputWithContext(ctx context.Context) SignatureOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignatureOutput)
}

func (i SignatureArgs) ToSignaturePtrOutput() SignaturePtrOutput {
	return i.ToSignaturePtrOutputWithContext(context.Background())
}

func (i SignatureArgs) ToSignaturePtrOutputWithContext(ctx context.Context) SignaturePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignatureOutput).ToSignaturePtrOutputWithContext(ctx)
}

// SignaturePtrInput is an input type that accepts SignatureArgs, SignaturePtr and SignaturePtrOutput values.
// You can construct a concrete instance of `SignaturePtrInput` via:
//
//          SignatureArgs{...}
//
//  or:
//
//          nil
type SignaturePtrInput interface {
	pulumi.Input

	ToSignaturePtrOutput() SignaturePtrOutput
	ToSignaturePtrOutputWithContext(context.Context) SignaturePtrOutput
}

type signaturePtrType SignatureArgs

func SignaturePtr(v *SignatureArgs) SignaturePtrInput {
	return (*signaturePtrType)(v)
}

func (*signaturePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Signature)(nil)).Elem()
}

func (i *signaturePtrType) ToSignaturePtrOutput() SignaturePtrOutput {
	return i.ToSignaturePtrOutputWithContext(context.Background())
}

func (i *signaturePtrType) ToSignaturePtrOutputWithContext(ctx context.Context) SignaturePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignaturePtrOutput)
}

// User signature.
type SignatureOutput struct{ *pulumi.OutputState }

func (SignatureOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Signature)(nil)).Elem()
}

func (o SignatureOutput) ToSignatureOutput() SignatureOutput {
	return o
}

func (o SignatureOutput) ToSignatureOutputWithContext(ctx context.Context) SignatureOutput {
	return o
}

func (o SignatureOutput) ToSignaturePtrOutput() SignaturePtrOutput {
	return o.ToSignaturePtrOutputWithContext(context.Background())
}

func (o SignatureOutput) ToSignaturePtrOutputWithContext(ctx context.Context) SignaturePtrOutput {
	return o.ApplyT(func(v Signature) *Signature {
		return &v
	}).(SignaturePtrOutput)
}

// Optional. An image of the user's signature.
func (o SignatureOutput) Image() ImagePtrOutput {
	return o.ApplyT(func(v Signature) *Image { return v.Image }).(ImagePtrOutput)
}

// Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
func (o SignatureOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v Signature) map[string]string { return v.Metadata }).(pulumi.StringMapOutput)
}

// Optional. Timestamp of the signature.
func (o SignatureOutput) SignatureTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Signature) *string { return v.SignatureTime }).(pulumi.StringPtrOutput)
}

// Required. User's UUID provided by the client.
func (o SignatureOutput) UserId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Signature) *string { return v.UserId }).(pulumi.StringPtrOutput)
}

type SignaturePtrOutput struct{ *pulumi.OutputState }

func (SignaturePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Signature)(nil)).Elem()
}

func (o SignaturePtrOutput) ToSignaturePtrOutput() SignaturePtrOutput {
	return o
}

func (o SignaturePtrOutput) ToSignaturePtrOutputWithContext(ctx context.Context) SignaturePtrOutput {
	return o
}

func (o SignaturePtrOutput) Elem() SignatureOutput {
	return o.ApplyT(func(v *Signature) Signature { return *v }).(SignatureOutput)
}

// Optional. An image of the user's signature.
func (o SignaturePtrOutput) Image() ImagePtrOutput {
	return o.ApplyT(func(v *Signature) *Image {
		if v == nil {
			return nil
		}
		return v.Image
	}).(ImagePtrOutput)
}

// Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
func (o SignaturePtrOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Signature) map[string]string {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(pulumi.StringMapOutput)
}

// Optional. Timestamp of the signature.
func (o SignaturePtrOutput) SignatureTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Signature) *string {
		if v == nil {
			return nil
		}
		return v.SignatureTime
	}).(pulumi.StringPtrOutput)
}

// Required. User's UUID provided by the client.
func (o SignaturePtrOutput) UserId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Signature) *string {
		if v == nil {
			return nil
		}
		return v.UserId
	}).(pulumi.StringPtrOutput)
}

// User signature.
type SignatureResponse struct {
	// Optional. An image of the user's signature.
	Image ImageResponse `pulumi:"image"`
	// Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
	Metadata map[string]string `pulumi:"metadata"`
	// Optional. Timestamp of the signature.
	SignatureTime string `pulumi:"signatureTime"`
	// Required. User's UUID provided by the client.
	UserId string `pulumi:"userId"`
}

// SignatureResponseInput is an input type that accepts SignatureResponseArgs and SignatureResponseOutput values.
// You can construct a concrete instance of `SignatureResponseInput` via:
//
//          SignatureResponseArgs{...}
type SignatureResponseInput interface {
	pulumi.Input

	ToSignatureResponseOutput() SignatureResponseOutput
	ToSignatureResponseOutputWithContext(context.Context) SignatureResponseOutput
}

// User signature.
type SignatureResponseArgs struct {
	// Optional. An image of the user's signature.
	Image ImageResponseInput `pulumi:"image"`
	// Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
	Metadata pulumi.StringMapInput `pulumi:"metadata"`
	// Optional. Timestamp of the signature.
	SignatureTime pulumi.StringInput `pulumi:"signatureTime"`
	// Required. User's UUID provided by the client.
	UserId pulumi.StringInput `pulumi:"userId"`
}

func (SignatureResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SignatureResponse)(nil)).Elem()
}

func (i SignatureResponseArgs) ToSignatureResponseOutput() SignatureResponseOutput {
	return i.ToSignatureResponseOutputWithContext(context.Background())
}

func (i SignatureResponseArgs) ToSignatureResponseOutputWithContext(ctx context.Context) SignatureResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignatureResponseOutput)
}

func (i SignatureResponseArgs) ToSignatureResponsePtrOutput() SignatureResponsePtrOutput {
	return i.ToSignatureResponsePtrOutputWithContext(context.Background())
}

func (i SignatureResponseArgs) ToSignatureResponsePtrOutputWithContext(ctx context.Context) SignatureResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignatureResponseOutput).ToSignatureResponsePtrOutputWithContext(ctx)
}

// SignatureResponsePtrInput is an input type that accepts SignatureResponseArgs, SignatureResponsePtr and SignatureResponsePtrOutput values.
// You can construct a concrete instance of `SignatureResponsePtrInput` via:
//
//          SignatureResponseArgs{...}
//
//  or:
//
//          nil
type SignatureResponsePtrInput interface {
	pulumi.Input

	ToSignatureResponsePtrOutput() SignatureResponsePtrOutput
	ToSignatureResponsePtrOutputWithContext(context.Context) SignatureResponsePtrOutput
}

type signatureResponsePtrType SignatureResponseArgs

func SignatureResponsePtr(v *SignatureResponseArgs) SignatureResponsePtrInput {
	return (*signatureResponsePtrType)(v)
}

func (*signatureResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SignatureResponse)(nil)).Elem()
}

func (i *signatureResponsePtrType) ToSignatureResponsePtrOutput() SignatureResponsePtrOutput {
	return i.ToSignatureResponsePtrOutputWithContext(context.Background())
}

func (i *signatureResponsePtrType) ToSignatureResponsePtrOutputWithContext(ctx context.Context) SignatureResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignatureResponsePtrOutput)
}

// User signature.
type SignatureResponseOutput struct{ *pulumi.OutputState }

func (SignatureResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SignatureResponse)(nil)).Elem()
}

func (o SignatureResponseOutput) ToSignatureResponseOutput() SignatureResponseOutput {
	return o
}

func (o SignatureResponseOutput) ToSignatureResponseOutputWithContext(ctx context.Context) SignatureResponseOutput {
	return o
}

func (o SignatureResponseOutput) ToSignatureResponsePtrOutput() SignatureResponsePtrOutput {
	return o.ToSignatureResponsePtrOutputWithContext(context.Background())
}

func (o SignatureResponseOutput) ToSignatureResponsePtrOutputWithContext(ctx context.Context) SignatureResponsePtrOutput {
	return o.ApplyT(func(v SignatureResponse) *SignatureResponse {
		return &v
	}).(SignatureResponsePtrOutput)
}

// Optional. An image of the user's signature.
func (o SignatureResponseOutput) Image() ImageResponseOutput {
	return o.ApplyT(func(v SignatureResponse) ImageResponse { return v.Image }).(ImageResponseOutput)
}

// Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
func (o SignatureResponseOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v SignatureResponse) map[string]string { return v.Metadata }).(pulumi.StringMapOutput)
}

// Optional. Timestamp of the signature.
func (o SignatureResponseOutput) SignatureTime() pulumi.StringOutput {
	return o.ApplyT(func(v SignatureResponse) string { return v.SignatureTime }).(pulumi.StringOutput)
}

// Required. User's UUID provided by the client.
func (o SignatureResponseOutput) UserId() pulumi.StringOutput {
	return o.ApplyT(func(v SignatureResponse) string { return v.UserId }).(pulumi.StringOutput)
}

type SignatureResponsePtrOutput struct{ *pulumi.OutputState }

func (SignatureResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SignatureResponse)(nil)).Elem()
}

func (o SignatureResponsePtrOutput) ToSignatureResponsePtrOutput() SignatureResponsePtrOutput {
	return o
}

func (o SignatureResponsePtrOutput) ToSignatureResponsePtrOutputWithContext(ctx context.Context) SignatureResponsePtrOutput {
	return o
}

func (o SignatureResponsePtrOutput) Elem() SignatureResponseOutput {
	return o.ApplyT(func(v *SignatureResponse) SignatureResponse { return *v }).(SignatureResponseOutput)
}

// Optional. An image of the user's signature.
func (o SignatureResponsePtrOutput) Image() ImageResponsePtrOutput {
	return o.ApplyT(func(v *SignatureResponse) *ImageResponse {
		if v == nil {
			return nil
		}
		return &v.Image
	}).(ImageResponsePtrOutput)
}

// Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
func (o SignatureResponsePtrOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SignatureResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(pulumi.StringMapOutput)
}

// Optional. Timestamp of the signature.
func (o SignatureResponsePtrOutput) SignatureTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SignatureResponse) *string {
		if v == nil {
			return nil
		}
		return &v.SignatureTime
	}).(pulumi.StringPtrOutput)
}

// Required. User's UUID provided by the client.
func (o SignatureResponsePtrOutput) UserId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SignatureResponse) *string {
		if v == nil {
			return nil
		}
		return &v.UserId
	}).(pulumi.StringPtrOutput)
}

// Contains configuration for streaming FHIR export.
type StreamConfig struct {
	// The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types, e.g. "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data will not be streamed. Results are appended to the corresponding BigQuery tables. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	BigqueryDestination *GoogleCloudHealthcareV1beta1FhirBigQueryDestination `pulumi:"bigqueryDestination"`
	// Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
	ResourceTypes []string `pulumi:"resourceTypes"`
}

// StreamConfigInput is an input type that accepts StreamConfigArgs and StreamConfigOutput values.
// You can construct a concrete instance of `StreamConfigInput` via:
//
//          StreamConfigArgs{...}
type StreamConfigInput interface {
	pulumi.Input

	ToStreamConfigOutput() StreamConfigOutput
	ToStreamConfigOutputWithContext(context.Context) StreamConfigOutput
}

// Contains configuration for streaming FHIR export.
type StreamConfigArgs struct {
	// The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types, e.g. "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data will not be streamed. Results are appended to the corresponding BigQuery tables. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	BigqueryDestination GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrInput `pulumi:"bigqueryDestination"`
	// Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
	ResourceTypes pulumi.StringArrayInput `pulumi:"resourceTypes"`
}

func (StreamConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamConfig)(nil)).Elem()
}

func (i StreamConfigArgs) ToStreamConfigOutput() StreamConfigOutput {
	return i.ToStreamConfigOutputWithContext(context.Background())
}

func (i StreamConfigArgs) ToStreamConfigOutputWithContext(ctx context.Context) StreamConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamConfigOutput)
}

// StreamConfigArrayInput is an input type that accepts StreamConfigArray and StreamConfigArrayOutput values.
// You can construct a concrete instance of `StreamConfigArrayInput` via:
//
//          StreamConfigArray{ StreamConfigArgs{...} }
type StreamConfigArrayInput interface {
	pulumi.Input

	ToStreamConfigArrayOutput() StreamConfigArrayOutput
	ToStreamConfigArrayOutputWithContext(context.Context) StreamConfigArrayOutput
}

type StreamConfigArray []StreamConfigInput

func (StreamConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamConfig)(nil)).Elem()
}

func (i StreamConfigArray) ToStreamConfigArrayOutput() StreamConfigArrayOutput {
	return i.ToStreamConfigArrayOutputWithContext(context.Background())
}

func (i StreamConfigArray) ToStreamConfigArrayOutputWithContext(ctx context.Context) StreamConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamConfigArrayOutput)
}

// Contains configuration for streaming FHIR export.
type StreamConfigOutput struct{ *pulumi.OutputState }

func (StreamConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamConfig)(nil)).Elem()
}

func (o StreamConfigOutput) ToStreamConfigOutput() StreamConfigOutput {
	return o
}

func (o StreamConfigOutput) ToStreamConfigOutputWithContext(ctx context.Context) StreamConfigOutput {
	return o
}

// The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types, e.g. "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data will not be streamed. Results are appended to the corresponding BigQuery tables. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
func (o StreamConfigOutput) BigqueryDestination() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return o.ApplyT(func(v StreamConfig) *GoogleCloudHealthcareV1beta1FhirBigQueryDestination {
		return v.BigqueryDestination
	}).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput)
}

// Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
func (o StreamConfigOutput) ResourceTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v StreamConfig) []string { return v.ResourceTypes }).(pulumi.StringArrayOutput)
}

type StreamConfigArrayOutput struct{ *pulumi.OutputState }

func (StreamConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamConfig)(nil)).Elem()
}

func (o StreamConfigArrayOutput) ToStreamConfigArrayOutput() StreamConfigArrayOutput {
	return o
}

func (o StreamConfigArrayOutput) ToStreamConfigArrayOutputWithContext(ctx context.Context) StreamConfigArrayOutput {
	return o
}

func (o StreamConfigArrayOutput) Index(i pulumi.IntInput) StreamConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamConfig {
		return vs[0].([]StreamConfig)[vs[1].(int)]
	}).(StreamConfigOutput)
}

// Contains configuration for streaming FHIR export.
type StreamConfigResponse struct {
	// The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types, e.g. "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data will not be streamed. Results are appended to the corresponding BigQuery tables. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	BigqueryDestination GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse `pulumi:"bigqueryDestination"`
	// Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
	ResourceTypes []string `pulumi:"resourceTypes"`
}

// StreamConfigResponseInput is an input type that accepts StreamConfigResponseArgs and StreamConfigResponseOutput values.
// You can construct a concrete instance of `StreamConfigResponseInput` via:
//
//          StreamConfigResponseArgs{...}
type StreamConfigResponseInput interface {
	pulumi.Input

	ToStreamConfigResponseOutput() StreamConfigResponseOutput
	ToStreamConfigResponseOutputWithContext(context.Context) StreamConfigResponseOutput
}

// Contains configuration for streaming FHIR export.
type StreamConfigResponseArgs struct {
	// The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types, e.g. "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data will not be streamed. Results are appended to the corresponding BigQuery tables. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	BigqueryDestination GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseInput `pulumi:"bigqueryDestination"`
	// Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
	ResourceTypes pulumi.StringArrayInput `pulumi:"resourceTypes"`
}

func (StreamConfigResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamConfigResponse)(nil)).Elem()
}

func (i StreamConfigResponseArgs) ToStreamConfigResponseOutput() StreamConfigResponseOutput {
	return i.ToStreamConfigResponseOutputWithContext(context.Background())
}

func (i StreamConfigResponseArgs) ToStreamConfigResponseOutputWithContext(ctx context.Context) StreamConfigResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamConfigResponseOutput)
}

// StreamConfigResponseArrayInput is an input type that accepts StreamConfigResponseArray and StreamConfigResponseArrayOutput values.
// You can construct a concrete instance of `StreamConfigResponseArrayInput` via:
//
//          StreamConfigResponseArray{ StreamConfigResponseArgs{...} }
type StreamConfigResponseArrayInput interface {
	pulumi.Input

	ToStreamConfigResponseArrayOutput() StreamConfigResponseArrayOutput
	ToStreamConfigResponseArrayOutputWithContext(context.Context) StreamConfigResponseArrayOutput
}

type StreamConfigResponseArray []StreamConfigResponseInput

func (StreamConfigResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamConfigResponse)(nil)).Elem()
}

func (i StreamConfigResponseArray) ToStreamConfigResponseArrayOutput() StreamConfigResponseArrayOutput {
	return i.ToStreamConfigResponseArrayOutputWithContext(context.Background())
}

func (i StreamConfigResponseArray) ToStreamConfigResponseArrayOutputWithContext(ctx context.Context) StreamConfigResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamConfigResponseArrayOutput)
}

// Contains configuration for streaming FHIR export.
type StreamConfigResponseOutput struct{ *pulumi.OutputState }

func (StreamConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamConfigResponse)(nil)).Elem()
}

func (o StreamConfigResponseOutput) ToStreamConfigResponseOutput() StreamConfigResponseOutput {
	return o
}

func (o StreamConfigResponseOutput) ToStreamConfigResponseOutputWithContext(ctx context.Context) StreamConfigResponseOutput {
	return o
}

// The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types, e.g. "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data will not be streamed. Results are appended to the corresponding BigQuery tables. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
func (o StreamConfigResponseOutput) BigqueryDestination() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput {
	return o.ApplyT(func(v StreamConfigResponse) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse {
		return v.BigqueryDestination
	}).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput)
}

// Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
func (o StreamConfigResponseOutput) ResourceTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v StreamConfigResponse) []string { return v.ResourceTypes }).(pulumi.StringArrayOutput)
}

type StreamConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (StreamConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamConfigResponse)(nil)).Elem()
}

func (o StreamConfigResponseArrayOutput) ToStreamConfigResponseArrayOutput() StreamConfigResponseArrayOutput {
	return o
}

func (o StreamConfigResponseArrayOutput) ToStreamConfigResponseArrayOutputWithContext(ctx context.Context) StreamConfigResponseArrayOutput {
	return o
}

func (o StreamConfigResponseArrayOutput) Index(i pulumi.IntInput) StreamConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamConfigResponse {
		return vs[0].([]StreamConfigResponse)[vs[1].(int)]
	}).(StreamConfigResponseOutput)
}

// A type definition for some HL7v2 type (incl. Segments and Datatypes).
type Type struct {
	// The (sub) fields this type has (if not primitive).
	Fields []Field `pulumi:"fields"`
	// The name of this type. This would be the segment or datatype name. For example, "PID" or "XPN".
	Name *string `pulumi:"name"`
	// If this is a primitive type then this field is the type of the primitive For example, STRING. Leave unspecified for composite types.
	Primitive *string `pulumi:"primitive"`
}

// TypeInput is an input type that accepts TypeArgs and TypeOutput values.
// You can construct a concrete instance of `TypeInput` via:
//
//          TypeArgs{...}
type TypeInput interface {
	pulumi.Input

	ToTypeOutput() TypeOutput
	ToTypeOutputWithContext(context.Context) TypeOutput
}

// A type definition for some HL7v2 type (incl. Segments and Datatypes).
type TypeArgs struct {
	// The (sub) fields this type has (if not primitive).
	Fields FieldArrayInput `pulumi:"fields"`
	// The name of this type. This would be the segment or datatype name. For example, "PID" or "XPN".
	Name pulumi.StringPtrInput `pulumi:"name"`
	// If this is a primitive type then this field is the type of the primitive For example, STRING. Leave unspecified for composite types.
	Primitive pulumi.StringPtrInput `pulumi:"primitive"`
}

func (TypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Type)(nil)).Elem()
}

func (i TypeArgs) ToTypeOutput() TypeOutput {
	return i.ToTypeOutputWithContext(context.Background())
}

func (i TypeArgs) ToTypeOutputWithContext(ctx context.Context) TypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TypeOutput)
}

// TypeArrayInput is an input type that accepts TypeArray and TypeArrayOutput values.
// You can construct a concrete instance of `TypeArrayInput` via:
//
//          TypeArray{ TypeArgs{...} }
type TypeArrayInput interface {
	pulumi.Input

	ToTypeArrayOutput() TypeArrayOutput
	ToTypeArrayOutputWithContext(context.Context) TypeArrayOutput
}

type TypeArray []TypeInput

func (TypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Type)(nil)).Elem()
}

func (i TypeArray) ToTypeArrayOutput() TypeArrayOutput {
	return i.ToTypeArrayOutputWithContext(context.Background())
}

func (i TypeArray) ToTypeArrayOutputWithContext(ctx context.Context) TypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TypeArrayOutput)
}

// A type definition for some HL7v2 type (incl. Segments and Datatypes).
type TypeOutput struct{ *pulumi.OutputState }

func (TypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Type)(nil)).Elem()
}

func (o TypeOutput) ToTypeOutput() TypeOutput {
	return o
}

func (o TypeOutput) ToTypeOutputWithContext(ctx context.Context) TypeOutput {
	return o
}

// The (sub) fields this type has (if not primitive).
func (o TypeOutput) Fields() FieldArrayOutput {
	return o.ApplyT(func(v Type) []Field { return v.Fields }).(FieldArrayOutput)
}

// The name of this type. This would be the segment or datatype name. For example, "PID" or "XPN".
func (o TypeOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Type) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// If this is a primitive type then this field is the type of the primitive For example, STRING. Leave unspecified for composite types.
func (o TypeOutput) Primitive() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Type) *string { return v.Primitive }).(pulumi.StringPtrOutput)
}

type TypeArrayOutput struct{ *pulumi.OutputState }

func (TypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Type)(nil)).Elem()
}

func (o TypeArrayOutput) ToTypeArrayOutput() TypeArrayOutput {
	return o
}

func (o TypeArrayOutput) ToTypeArrayOutputWithContext(ctx context.Context) TypeArrayOutput {
	return o
}

func (o TypeArrayOutput) Index(i pulumi.IntInput) TypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Type {
		return vs[0].([]Type)[vs[1].(int)]
	}).(TypeOutput)
}

// A type definition for some HL7v2 type (incl. Segments and Datatypes).
type TypeResponse struct {
	// The (sub) fields this type has (if not primitive).
	Fields []FieldResponse `pulumi:"fields"`
	// The name of this type. This would be the segment or datatype name. For example, "PID" or "XPN".
	Name string `pulumi:"name"`
	// If this is a primitive type then this field is the type of the primitive For example, STRING. Leave unspecified for composite types.
	Primitive string `pulumi:"primitive"`
}

// TypeResponseInput is an input type that accepts TypeResponseArgs and TypeResponseOutput values.
// You can construct a concrete instance of `TypeResponseInput` via:
//
//          TypeResponseArgs{...}
type TypeResponseInput interface {
	pulumi.Input

	ToTypeResponseOutput() TypeResponseOutput
	ToTypeResponseOutputWithContext(context.Context) TypeResponseOutput
}

// A type definition for some HL7v2 type (incl. Segments and Datatypes).
type TypeResponseArgs struct {
	// The (sub) fields this type has (if not primitive).
	Fields FieldResponseArrayInput `pulumi:"fields"`
	// The name of this type. This would be the segment or datatype name. For example, "PID" or "XPN".
	Name pulumi.StringInput `pulumi:"name"`
	// If this is a primitive type then this field is the type of the primitive For example, STRING. Leave unspecified for composite types.
	Primitive pulumi.StringInput `pulumi:"primitive"`
}

func (TypeResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TypeResponse)(nil)).Elem()
}

func (i TypeResponseArgs) ToTypeResponseOutput() TypeResponseOutput {
	return i.ToTypeResponseOutputWithContext(context.Background())
}

func (i TypeResponseArgs) ToTypeResponseOutputWithContext(ctx context.Context) TypeResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TypeResponseOutput)
}

// TypeResponseArrayInput is an input type that accepts TypeResponseArray and TypeResponseArrayOutput values.
// You can construct a concrete instance of `TypeResponseArrayInput` via:
//
//          TypeResponseArray{ TypeResponseArgs{...} }
type TypeResponseArrayInput interface {
	pulumi.Input

	ToTypeResponseArrayOutput() TypeResponseArrayOutput
	ToTypeResponseArrayOutputWithContext(context.Context) TypeResponseArrayOutput
}

type TypeResponseArray []TypeResponseInput

func (TypeResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TypeResponse)(nil)).Elem()
}

func (i TypeResponseArray) ToTypeResponseArrayOutput() TypeResponseArrayOutput {
	return i.ToTypeResponseArrayOutputWithContext(context.Background())
}

func (i TypeResponseArray) ToTypeResponseArrayOutputWithContext(ctx context.Context) TypeResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TypeResponseArrayOutput)
}

// A type definition for some HL7v2 type (incl. Segments and Datatypes).
type TypeResponseOutput struct{ *pulumi.OutputState }

func (TypeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TypeResponse)(nil)).Elem()
}

func (o TypeResponseOutput) ToTypeResponseOutput() TypeResponseOutput {
	return o
}

func (o TypeResponseOutput) ToTypeResponseOutputWithContext(ctx context.Context) TypeResponseOutput {
	return o
}

// The (sub) fields this type has (if not primitive).
func (o TypeResponseOutput) Fields() FieldResponseArrayOutput {
	return o.ApplyT(func(v TypeResponse) []FieldResponse { return v.Fields }).(FieldResponseArrayOutput)
}

// The name of this type. This would be the segment or datatype name. For example, "PID" or "XPN".
func (o TypeResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v TypeResponse) string { return v.Name }).(pulumi.StringOutput)
}

// If this is a primitive type then this field is the type of the primitive For example, STRING. Leave unspecified for composite types.
func (o TypeResponseOutput) Primitive() pulumi.StringOutput {
	return o.ApplyT(func(v TypeResponse) string { return v.Primitive }).(pulumi.StringOutput)
}

type TypeResponseArrayOutput struct{ *pulumi.OutputState }

func (TypeResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TypeResponse)(nil)).Elem()
}

func (o TypeResponseArrayOutput) ToTypeResponseArrayOutput() TypeResponseArrayOutput {
	return o
}

func (o TypeResponseArrayOutput) ToTypeResponseArrayOutputWithContext(ctx context.Context) TypeResponseArrayOutput {
	return o
}

func (o TypeResponseArrayOutput) Index(i pulumi.IntInput) TypeResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TypeResponse {
		return vs[0].([]TypeResponse)[vs[1].(int)]
	}).(TypeResponseOutput)
}

// Contains the configuration for FHIR profiles and validation.
type ValidationConfig struct {
	// Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
	DisableProfileValidation *bool `pulumi:"disableProfileValidation"`
	// A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
	EnabledImplementationGuides []string `pulumi:"enabledImplementationGuides"`
}

// ValidationConfigInput is an input type that accepts ValidationConfigArgs and ValidationConfigOutput values.
// You can construct a concrete instance of `ValidationConfigInput` via:
//
//          ValidationConfigArgs{...}
type ValidationConfigInput interface {
	pulumi.Input

	ToValidationConfigOutput() ValidationConfigOutput
	ToValidationConfigOutputWithContext(context.Context) ValidationConfigOutput
}

// Contains the configuration for FHIR profiles and validation.
type ValidationConfigArgs struct {
	// Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
	DisableProfileValidation pulumi.BoolPtrInput `pulumi:"disableProfileValidation"`
	// A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
	EnabledImplementationGuides pulumi.StringArrayInput `pulumi:"enabledImplementationGuides"`
}

func (ValidationConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ValidationConfig)(nil)).Elem()
}

func (i ValidationConfigArgs) ToValidationConfigOutput() ValidationConfigOutput {
	return i.ToValidationConfigOutputWithContext(context.Background())
}

func (i ValidationConfigArgs) ToValidationConfigOutputWithContext(ctx context.Context) ValidationConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValidationConfigOutput)
}

func (i ValidationConfigArgs) ToValidationConfigPtrOutput() ValidationConfigPtrOutput {
	return i.ToValidationConfigPtrOutputWithContext(context.Background())
}

func (i ValidationConfigArgs) ToValidationConfigPtrOutputWithContext(ctx context.Context) ValidationConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValidationConfigOutput).ToValidationConfigPtrOutputWithContext(ctx)
}

// ValidationConfigPtrInput is an input type that accepts ValidationConfigArgs, ValidationConfigPtr and ValidationConfigPtrOutput values.
// You can construct a concrete instance of `ValidationConfigPtrInput` via:
//
//          ValidationConfigArgs{...}
//
//  or:
//
//          nil
type ValidationConfigPtrInput interface {
	pulumi.Input

	ToValidationConfigPtrOutput() ValidationConfigPtrOutput
	ToValidationConfigPtrOutputWithContext(context.Context) ValidationConfigPtrOutput
}

type validationConfigPtrType ValidationConfigArgs

func ValidationConfigPtr(v *ValidationConfigArgs) ValidationConfigPtrInput {
	return (*validationConfigPtrType)(v)
}

func (*validationConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ValidationConfig)(nil)).Elem()
}

func (i *validationConfigPtrType) ToValidationConfigPtrOutput() ValidationConfigPtrOutput {
	return i.ToValidationConfigPtrOutputWithContext(context.Background())
}

func (i *validationConfigPtrType) ToValidationConfigPtrOutputWithContext(ctx context.Context) ValidationConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValidationConfigPtrOutput)
}

// Contains the configuration for FHIR profiles and validation.
type ValidationConfigOutput struct{ *pulumi.OutputState }

func (ValidationConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ValidationConfig)(nil)).Elem()
}

func (o ValidationConfigOutput) ToValidationConfigOutput() ValidationConfigOutput {
	return o
}

func (o ValidationConfigOutput) ToValidationConfigOutputWithContext(ctx context.Context) ValidationConfigOutput {
	return o
}

func (o ValidationConfigOutput) ToValidationConfigPtrOutput() ValidationConfigPtrOutput {
	return o.ToValidationConfigPtrOutputWithContext(context.Background())
}

func (o ValidationConfigOutput) ToValidationConfigPtrOutputWithContext(ctx context.Context) ValidationConfigPtrOutput {
	return o.ApplyT(func(v ValidationConfig) *ValidationConfig {
		return &v
	}).(ValidationConfigPtrOutput)
}

// Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
func (o ValidationConfigOutput) DisableProfileValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ValidationConfig) *bool { return v.DisableProfileValidation }).(pulumi.BoolPtrOutput)
}

// A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
func (o ValidationConfigOutput) EnabledImplementationGuides() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ValidationConfig) []string { return v.EnabledImplementationGuides }).(pulumi.StringArrayOutput)
}

type ValidationConfigPtrOutput struct{ *pulumi.OutputState }

func (ValidationConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ValidationConfig)(nil)).Elem()
}

func (o ValidationConfigPtrOutput) ToValidationConfigPtrOutput() ValidationConfigPtrOutput {
	return o
}

func (o ValidationConfigPtrOutput) ToValidationConfigPtrOutputWithContext(ctx context.Context) ValidationConfigPtrOutput {
	return o
}

func (o ValidationConfigPtrOutput) Elem() ValidationConfigOutput {
	return o.ApplyT(func(v *ValidationConfig) ValidationConfig { return *v }).(ValidationConfigOutput)
}

// Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
func (o ValidationConfigPtrOutput) DisableProfileValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ValidationConfig) *bool {
		if v == nil {
			return nil
		}
		return v.DisableProfileValidation
	}).(pulumi.BoolPtrOutput)
}

// A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
func (o ValidationConfigPtrOutput) EnabledImplementationGuides() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ValidationConfig) []string {
		if v == nil {
			return nil
		}
		return v.EnabledImplementationGuides
	}).(pulumi.StringArrayOutput)
}

// Contains the configuration for FHIR profiles and validation.
type ValidationConfigResponse struct {
	// Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
	DisableProfileValidation bool `pulumi:"disableProfileValidation"`
	// A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
	EnabledImplementationGuides []string `pulumi:"enabledImplementationGuides"`
}

// ValidationConfigResponseInput is an input type that accepts ValidationConfigResponseArgs and ValidationConfigResponseOutput values.
// You can construct a concrete instance of `ValidationConfigResponseInput` via:
//
//          ValidationConfigResponseArgs{...}
type ValidationConfigResponseInput interface {
	pulumi.Input

	ToValidationConfigResponseOutput() ValidationConfigResponseOutput
	ToValidationConfigResponseOutputWithContext(context.Context) ValidationConfigResponseOutput
}

// Contains the configuration for FHIR profiles and validation.
type ValidationConfigResponseArgs struct {
	// Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
	DisableProfileValidation pulumi.BoolInput `pulumi:"disableProfileValidation"`
	// A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
	EnabledImplementationGuides pulumi.StringArrayInput `pulumi:"enabledImplementationGuides"`
}

func (ValidationConfigResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ValidationConfigResponse)(nil)).Elem()
}

func (i ValidationConfigResponseArgs) ToValidationConfigResponseOutput() ValidationConfigResponseOutput {
	return i.ToValidationConfigResponseOutputWithContext(context.Background())
}

func (i ValidationConfigResponseArgs) ToValidationConfigResponseOutputWithContext(ctx context.Context) ValidationConfigResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValidationConfigResponseOutput)
}

func (i ValidationConfigResponseArgs) ToValidationConfigResponsePtrOutput() ValidationConfigResponsePtrOutput {
	return i.ToValidationConfigResponsePtrOutputWithContext(context.Background())
}

func (i ValidationConfigResponseArgs) ToValidationConfigResponsePtrOutputWithContext(ctx context.Context) ValidationConfigResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValidationConfigResponseOutput).ToValidationConfigResponsePtrOutputWithContext(ctx)
}

// ValidationConfigResponsePtrInput is an input type that accepts ValidationConfigResponseArgs, ValidationConfigResponsePtr and ValidationConfigResponsePtrOutput values.
// You can construct a concrete instance of `ValidationConfigResponsePtrInput` via:
//
//          ValidationConfigResponseArgs{...}
//
//  or:
//
//          nil
type ValidationConfigResponsePtrInput interface {
	pulumi.Input

	ToValidationConfigResponsePtrOutput() ValidationConfigResponsePtrOutput
	ToValidationConfigResponsePtrOutputWithContext(context.Context) ValidationConfigResponsePtrOutput
}

type validationConfigResponsePtrType ValidationConfigResponseArgs

func ValidationConfigResponsePtr(v *ValidationConfigResponseArgs) ValidationConfigResponsePtrInput {
	return (*validationConfigResponsePtrType)(v)
}

func (*validationConfigResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ValidationConfigResponse)(nil)).Elem()
}

func (i *validationConfigResponsePtrType) ToValidationConfigResponsePtrOutput() ValidationConfigResponsePtrOutput {
	return i.ToValidationConfigResponsePtrOutputWithContext(context.Background())
}

func (i *validationConfigResponsePtrType) ToValidationConfigResponsePtrOutputWithContext(ctx context.Context) ValidationConfigResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValidationConfigResponsePtrOutput)
}

// Contains the configuration for FHIR profiles and validation.
type ValidationConfigResponseOutput struct{ *pulumi.OutputState }

func (ValidationConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ValidationConfigResponse)(nil)).Elem()
}

func (o ValidationConfigResponseOutput) ToValidationConfigResponseOutput() ValidationConfigResponseOutput {
	return o
}

func (o ValidationConfigResponseOutput) ToValidationConfigResponseOutputWithContext(ctx context.Context) ValidationConfigResponseOutput {
	return o
}

func (o ValidationConfigResponseOutput) ToValidationConfigResponsePtrOutput() ValidationConfigResponsePtrOutput {
	return o.ToValidationConfigResponsePtrOutputWithContext(context.Background())
}

func (o ValidationConfigResponseOutput) ToValidationConfigResponsePtrOutputWithContext(ctx context.Context) ValidationConfigResponsePtrOutput {
	return o.ApplyT(func(v ValidationConfigResponse) *ValidationConfigResponse {
		return &v
	}).(ValidationConfigResponsePtrOutput)
}

// Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
func (o ValidationConfigResponseOutput) DisableProfileValidation() pulumi.BoolOutput {
	return o.ApplyT(func(v ValidationConfigResponse) bool { return v.DisableProfileValidation }).(pulumi.BoolOutput)
}

// A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
func (o ValidationConfigResponseOutput) EnabledImplementationGuides() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ValidationConfigResponse) []string { return v.EnabledImplementationGuides }).(pulumi.StringArrayOutput)
}

type ValidationConfigResponsePtrOutput struct{ *pulumi.OutputState }

func (ValidationConfigResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ValidationConfigResponse)(nil)).Elem()
}

func (o ValidationConfigResponsePtrOutput) ToValidationConfigResponsePtrOutput() ValidationConfigResponsePtrOutput {
	return o
}

func (o ValidationConfigResponsePtrOutput) ToValidationConfigResponsePtrOutputWithContext(ctx context.Context) ValidationConfigResponsePtrOutput {
	return o
}

func (o ValidationConfigResponsePtrOutput) Elem() ValidationConfigResponseOutput {
	return o.ApplyT(func(v *ValidationConfigResponse) ValidationConfigResponse { return *v }).(ValidationConfigResponseOutput)
}

// Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
func (o ValidationConfigResponsePtrOutput) DisableProfileValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ValidationConfigResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.DisableProfileValidation
	}).(pulumi.BoolPtrOutput)
}

// A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
func (o ValidationConfigResponsePtrOutput) EnabledImplementationGuides() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ValidationConfigResponse) []string {
		if v == nil {
			return nil
		}
		return v.EnabledImplementationGuides
	}).(pulumi.StringArrayOutput)
}

// Describes a selector for extracting and matching an MSH field to a value.
type VersionSource struct {
	// The field to extract from the MSH segment. For example, "3.1" or "18[1].1".
	MshField *string `pulumi:"mshField"`
	// The value to match with the field. For example, "My Application Name" or "2.3".
	Value *string `pulumi:"value"`
}

// VersionSourceInput is an input type that accepts VersionSourceArgs and VersionSourceOutput values.
// You can construct a concrete instance of `VersionSourceInput` via:
//
//          VersionSourceArgs{...}
type VersionSourceInput interface {
	pulumi.Input

	ToVersionSourceOutput() VersionSourceOutput
	ToVersionSourceOutputWithContext(context.Context) VersionSourceOutput
}

// Describes a selector for extracting and matching an MSH field to a value.
type VersionSourceArgs struct {
	// The field to extract from the MSH segment. For example, "3.1" or "18[1].1".
	MshField pulumi.StringPtrInput `pulumi:"mshField"`
	// The value to match with the field. For example, "My Application Name" or "2.3".
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (VersionSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VersionSource)(nil)).Elem()
}

func (i VersionSourceArgs) ToVersionSourceOutput() VersionSourceOutput {
	return i.ToVersionSourceOutputWithContext(context.Background())
}

func (i VersionSourceArgs) ToVersionSourceOutputWithContext(ctx context.Context) VersionSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VersionSourceOutput)
}

// VersionSourceArrayInput is an input type that accepts VersionSourceArray and VersionSourceArrayOutput values.
// You can construct a concrete instance of `VersionSourceArrayInput` via:
//
//          VersionSourceArray{ VersionSourceArgs{...} }
type VersionSourceArrayInput interface {
	pulumi.Input

	ToVersionSourceArrayOutput() VersionSourceArrayOutput
	ToVersionSourceArrayOutputWithContext(context.Context) VersionSourceArrayOutput
}

type VersionSourceArray []VersionSourceInput

func (VersionSourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VersionSource)(nil)).Elem()
}

func (i VersionSourceArray) ToVersionSourceArrayOutput() VersionSourceArrayOutput {
	return i.ToVersionSourceArrayOutputWithContext(context.Background())
}

func (i VersionSourceArray) ToVersionSourceArrayOutputWithContext(ctx context.Context) VersionSourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VersionSourceArrayOutput)
}

// Describes a selector for extracting and matching an MSH field to a value.
type VersionSourceOutput struct{ *pulumi.OutputState }

func (VersionSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VersionSource)(nil)).Elem()
}

func (o VersionSourceOutput) ToVersionSourceOutput() VersionSourceOutput {
	return o
}

func (o VersionSourceOutput) ToVersionSourceOutputWithContext(ctx context.Context) VersionSourceOutput {
	return o
}

// The field to extract from the MSH segment. For example, "3.1" or "18[1].1".
func (o VersionSourceOutput) MshField() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VersionSource) *string { return v.MshField }).(pulumi.StringPtrOutput)
}

// The value to match with the field. For example, "My Application Name" or "2.3".
func (o VersionSourceOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VersionSource) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type VersionSourceArrayOutput struct{ *pulumi.OutputState }

func (VersionSourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VersionSource)(nil)).Elem()
}

func (o VersionSourceArrayOutput) ToVersionSourceArrayOutput() VersionSourceArrayOutput {
	return o
}

func (o VersionSourceArrayOutput) ToVersionSourceArrayOutputWithContext(ctx context.Context) VersionSourceArrayOutput {
	return o
}

func (o VersionSourceArrayOutput) Index(i pulumi.IntInput) VersionSourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VersionSource {
		return vs[0].([]VersionSource)[vs[1].(int)]
	}).(VersionSourceOutput)
}

// Describes a selector for extracting and matching an MSH field to a value.
type VersionSourceResponse struct {
	// The field to extract from the MSH segment. For example, "3.1" or "18[1].1".
	MshField string `pulumi:"mshField"`
	// The value to match with the field. For example, "My Application Name" or "2.3".
	Value string `pulumi:"value"`
}

// VersionSourceResponseInput is an input type that accepts VersionSourceResponseArgs and VersionSourceResponseOutput values.
// You can construct a concrete instance of `VersionSourceResponseInput` via:
//
//          VersionSourceResponseArgs{...}
type VersionSourceResponseInput interface {
	pulumi.Input

	ToVersionSourceResponseOutput() VersionSourceResponseOutput
	ToVersionSourceResponseOutputWithContext(context.Context) VersionSourceResponseOutput
}

// Describes a selector for extracting and matching an MSH field to a value.
type VersionSourceResponseArgs struct {
	// The field to extract from the MSH segment. For example, "3.1" or "18[1].1".
	MshField pulumi.StringInput `pulumi:"mshField"`
	// The value to match with the field. For example, "My Application Name" or "2.3".
	Value pulumi.StringInput `pulumi:"value"`
}

func (VersionSourceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VersionSourceResponse)(nil)).Elem()
}

func (i VersionSourceResponseArgs) ToVersionSourceResponseOutput() VersionSourceResponseOutput {
	return i.ToVersionSourceResponseOutputWithContext(context.Background())
}

func (i VersionSourceResponseArgs) ToVersionSourceResponseOutputWithContext(ctx context.Context) VersionSourceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VersionSourceResponseOutput)
}

// VersionSourceResponseArrayInput is an input type that accepts VersionSourceResponseArray and VersionSourceResponseArrayOutput values.
// You can construct a concrete instance of `VersionSourceResponseArrayInput` via:
//
//          VersionSourceResponseArray{ VersionSourceResponseArgs{...} }
type VersionSourceResponseArrayInput interface {
	pulumi.Input

	ToVersionSourceResponseArrayOutput() VersionSourceResponseArrayOutput
	ToVersionSourceResponseArrayOutputWithContext(context.Context) VersionSourceResponseArrayOutput
}

type VersionSourceResponseArray []VersionSourceResponseInput

func (VersionSourceResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VersionSourceResponse)(nil)).Elem()
}

func (i VersionSourceResponseArray) ToVersionSourceResponseArrayOutput() VersionSourceResponseArrayOutput {
	return i.ToVersionSourceResponseArrayOutputWithContext(context.Background())
}

func (i VersionSourceResponseArray) ToVersionSourceResponseArrayOutputWithContext(ctx context.Context) VersionSourceResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VersionSourceResponseArrayOutput)
}

// Describes a selector for extracting and matching an MSH field to a value.
type VersionSourceResponseOutput struct{ *pulumi.OutputState }

func (VersionSourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VersionSourceResponse)(nil)).Elem()
}

func (o VersionSourceResponseOutput) ToVersionSourceResponseOutput() VersionSourceResponseOutput {
	return o
}

func (o VersionSourceResponseOutput) ToVersionSourceResponseOutputWithContext(ctx context.Context) VersionSourceResponseOutput {
	return o
}

// The field to extract from the MSH segment. For example, "3.1" or "18[1].1".
func (o VersionSourceResponseOutput) MshField() pulumi.StringOutput {
	return o.ApplyT(func(v VersionSourceResponse) string { return v.MshField }).(pulumi.StringOutput)
}

// The value to match with the field. For example, "My Application Name" or "2.3".
func (o VersionSourceResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v VersionSourceResponse) string { return v.Value }).(pulumi.StringOutput)
}

type VersionSourceResponseArrayOutput struct{ *pulumi.OutputState }

func (VersionSourceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VersionSourceResponse)(nil)).Elem()
}

func (o VersionSourceResponseArrayOutput) ToVersionSourceResponseArrayOutput() VersionSourceResponseArrayOutput {
	return o
}

func (o VersionSourceResponseArrayOutput) ToVersionSourceResponseArrayOutputWithContext(ctx context.Context) VersionSourceResponseArrayOutput {
	return o
}

func (o VersionSourceResponseArrayOutput) Index(i pulumi.IntInput) VersionSourceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VersionSourceResponse {
		return vs[0].([]VersionSourceResponse)[vs[1].(int)]
	}).(VersionSourceResponseOutput)
}

// A 2D coordinate in an image. The origin is the top-left.
type Vertex struct {
	// X coordinate.
	X *float64 `pulumi:"x"`
	// Y coordinate.
	Y *float64 `pulumi:"y"`
}

// VertexInput is an input type that accepts VertexArgs and VertexOutput values.
// You can construct a concrete instance of `VertexInput` via:
//
//          VertexArgs{...}
type VertexInput interface {
	pulumi.Input

	ToVertexOutput() VertexOutput
	ToVertexOutputWithContext(context.Context) VertexOutput
}

// A 2D coordinate in an image. The origin is the top-left.
type VertexArgs struct {
	// X coordinate.
	X pulumi.Float64PtrInput `pulumi:"x"`
	// Y coordinate.
	Y pulumi.Float64PtrInput `pulumi:"y"`
}

func (VertexArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Vertex)(nil)).Elem()
}

func (i VertexArgs) ToVertexOutput() VertexOutput {
	return i.ToVertexOutputWithContext(context.Background())
}

func (i VertexArgs) ToVertexOutputWithContext(ctx context.Context) VertexOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VertexOutput)
}

// VertexArrayInput is an input type that accepts VertexArray and VertexArrayOutput values.
// You can construct a concrete instance of `VertexArrayInput` via:
//
//          VertexArray{ VertexArgs{...} }
type VertexArrayInput interface {
	pulumi.Input

	ToVertexArrayOutput() VertexArrayOutput
	ToVertexArrayOutputWithContext(context.Context) VertexArrayOutput
}

type VertexArray []VertexInput

func (VertexArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Vertex)(nil)).Elem()
}

func (i VertexArray) ToVertexArrayOutput() VertexArrayOutput {
	return i.ToVertexArrayOutputWithContext(context.Background())
}

func (i VertexArray) ToVertexArrayOutputWithContext(ctx context.Context) VertexArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VertexArrayOutput)
}

// A 2D coordinate in an image. The origin is the top-left.
type VertexOutput struct{ *pulumi.OutputState }

func (VertexOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Vertex)(nil)).Elem()
}

func (o VertexOutput) ToVertexOutput() VertexOutput {
	return o
}

func (o VertexOutput) ToVertexOutputWithContext(ctx context.Context) VertexOutput {
	return o
}

// X coordinate.
func (o VertexOutput) X() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Vertex) *float64 { return v.X }).(pulumi.Float64PtrOutput)
}

// Y coordinate.
func (o VertexOutput) Y() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Vertex) *float64 { return v.Y }).(pulumi.Float64PtrOutput)
}

type VertexArrayOutput struct{ *pulumi.OutputState }

func (VertexArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Vertex)(nil)).Elem()
}

func (o VertexArrayOutput) ToVertexArrayOutput() VertexArrayOutput {
	return o
}

func (o VertexArrayOutput) ToVertexArrayOutputWithContext(ctx context.Context) VertexArrayOutput {
	return o
}

func (o VertexArrayOutput) Index(i pulumi.IntInput) VertexOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Vertex {
		return vs[0].([]Vertex)[vs[1].(int)]
	}).(VertexOutput)
}

// A 2D coordinate in an image. The origin is the top-left.
type VertexResponse struct {
	// X coordinate.
	X float64 `pulumi:"x"`
	// Y coordinate.
	Y float64 `pulumi:"y"`
}

// VertexResponseInput is an input type that accepts VertexResponseArgs and VertexResponseOutput values.
// You can construct a concrete instance of `VertexResponseInput` via:
//
//          VertexResponseArgs{...}
type VertexResponseInput interface {
	pulumi.Input

	ToVertexResponseOutput() VertexResponseOutput
	ToVertexResponseOutputWithContext(context.Context) VertexResponseOutput
}

// A 2D coordinate in an image. The origin is the top-left.
type VertexResponseArgs struct {
	// X coordinate.
	X pulumi.Float64Input `pulumi:"x"`
	// Y coordinate.
	Y pulumi.Float64Input `pulumi:"y"`
}

func (VertexResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VertexResponse)(nil)).Elem()
}

func (i VertexResponseArgs) ToVertexResponseOutput() VertexResponseOutput {
	return i.ToVertexResponseOutputWithContext(context.Background())
}

func (i VertexResponseArgs) ToVertexResponseOutputWithContext(ctx context.Context) VertexResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VertexResponseOutput)
}

// VertexResponseArrayInput is an input type that accepts VertexResponseArray and VertexResponseArrayOutput values.
// You can construct a concrete instance of `VertexResponseArrayInput` via:
//
//          VertexResponseArray{ VertexResponseArgs{...} }
type VertexResponseArrayInput interface {
	pulumi.Input

	ToVertexResponseArrayOutput() VertexResponseArrayOutput
	ToVertexResponseArrayOutputWithContext(context.Context) VertexResponseArrayOutput
}

type VertexResponseArray []VertexResponseInput

func (VertexResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VertexResponse)(nil)).Elem()
}

func (i VertexResponseArray) ToVertexResponseArrayOutput() VertexResponseArrayOutput {
	return i.ToVertexResponseArrayOutputWithContext(context.Background())
}

func (i VertexResponseArray) ToVertexResponseArrayOutputWithContext(ctx context.Context) VertexResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VertexResponseArrayOutput)
}

// A 2D coordinate in an image. The origin is the top-left.
type VertexResponseOutput struct{ *pulumi.OutputState }

func (VertexResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VertexResponse)(nil)).Elem()
}

func (o VertexResponseOutput) ToVertexResponseOutput() VertexResponseOutput {
	return o
}

func (o VertexResponseOutput) ToVertexResponseOutputWithContext(ctx context.Context) VertexResponseOutput {
	return o
}

// X coordinate.
func (o VertexResponseOutput) X() pulumi.Float64Output {
	return o.ApplyT(func(v VertexResponse) float64 { return v.X }).(pulumi.Float64Output)
}

// Y coordinate.
func (o VertexResponseOutput) Y() pulumi.Float64Output {
	return o.ApplyT(func(v VertexResponse) float64 { return v.Y }).(pulumi.Float64Output)
}

type VertexResponseArrayOutput struct{ *pulumi.OutputState }

func (VertexResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VertexResponse)(nil)).Elem()
}

func (o VertexResponseArrayOutput) ToVertexResponseArrayOutput() VertexResponseArrayOutput {
	return o
}

func (o VertexResponseArrayOutput) ToVertexResponseArrayOutputWithContext(ctx context.Context) VertexResponseArrayOutput {
	return o
}

func (o VertexResponseArrayOutput) Index(i pulumi.IntInput) VertexResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VertexResponse {
		return vs[0].([]VertexResponse)[vs[1].(int)]
	}).(VertexResponseOutput)
}

func init() {
	pulumi.RegisterOutputType(AnnotationSourceOutput{})
	pulumi.RegisterOutputType(AnnotationSourcePtrOutput{})
	pulumi.RegisterOutputType(AnnotationSourceResponseOutput{})
	pulumi.RegisterOutputType(AnnotationSourceResponsePtrOutput{})
	pulumi.RegisterOutputType(AttributeOutput{})
	pulumi.RegisterOutputType(AttributeArrayOutput{})
	pulumi.RegisterOutputType(AttributeResponseOutput{})
	pulumi.RegisterOutputType(AttributeResponseArrayOutput{})
	pulumi.RegisterOutputType(AuditConfigOutput{})
	pulumi.RegisterOutputType(AuditConfigArrayOutput{})
	pulumi.RegisterOutputType(AuditConfigResponseOutput{})
	pulumi.RegisterOutputType(AuditConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(AuditLogConfigOutput{})
	pulumi.RegisterOutputType(AuditLogConfigArrayOutput{})
	pulumi.RegisterOutputType(AuditLogConfigResponseOutput{})
	pulumi.RegisterOutputType(AuditLogConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(BindingOutput{})
	pulumi.RegisterOutputType(BindingArrayOutput{})
	pulumi.RegisterOutputType(BindingResponseOutput{})
	pulumi.RegisterOutputType(BindingResponseArrayOutput{})
	pulumi.RegisterOutputType(BoundingPolyOutput{})
	pulumi.RegisterOutputType(BoundingPolyArrayOutput{})
	pulumi.RegisterOutputType(BoundingPolyResponseOutput{})
	pulumi.RegisterOutputType(BoundingPolyResponseArrayOutput{})
	pulumi.RegisterOutputType(CloudHealthcareSourceOutput{})
	pulumi.RegisterOutputType(CloudHealthcareSourcePtrOutput{})
	pulumi.RegisterOutputType(CloudHealthcareSourceResponseOutput{})
	pulumi.RegisterOutputType(CloudHealthcareSourceResponsePtrOutput{})
	pulumi.RegisterOutputType(ExprOutput{})
	pulumi.RegisterOutputType(ExprPtrOutput{})
	pulumi.RegisterOutputType(ExprResponseOutput{})
	pulumi.RegisterOutputType(FieldOutput{})
	pulumi.RegisterOutputType(FieldArrayOutput{})
	pulumi.RegisterOutputType(FieldResponseOutput{})
	pulumi.RegisterOutputType(FieldResponseArrayOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1ConsentPolicyOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DicomStreamConfigOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput{})
	pulumi.RegisterOutputType(Hl7SchemaConfigOutput{})
	pulumi.RegisterOutputType(Hl7SchemaConfigArrayOutput{})
	pulumi.RegisterOutputType(Hl7SchemaConfigResponseOutput{})
	pulumi.RegisterOutputType(Hl7SchemaConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(Hl7TypesConfigOutput{})
	pulumi.RegisterOutputType(Hl7TypesConfigArrayOutput{})
	pulumi.RegisterOutputType(Hl7TypesConfigResponseOutput{})
	pulumi.RegisterOutputType(Hl7TypesConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(Hl7V2NotificationConfigOutput{})
	pulumi.RegisterOutputType(Hl7V2NotificationConfigArrayOutput{})
	pulumi.RegisterOutputType(Hl7V2NotificationConfigResponseOutput{})
	pulumi.RegisterOutputType(Hl7V2NotificationConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(ImageOutput{})
	pulumi.RegisterOutputType(ImagePtrOutput{})
	pulumi.RegisterOutputType(ImageArrayOutput{})
	pulumi.RegisterOutputType(ImageAnnotationOutput{})
	pulumi.RegisterOutputType(ImageAnnotationPtrOutput{})
	pulumi.RegisterOutputType(ImageAnnotationResponseOutput{})
	pulumi.RegisterOutputType(ImageAnnotationResponsePtrOutput{})
	pulumi.RegisterOutputType(ImageResponseOutput{})
	pulumi.RegisterOutputType(ImageResponsePtrOutput{})
	pulumi.RegisterOutputType(ImageResponseArrayOutput{})
	pulumi.RegisterOutputType(MessageOutput{})
	pulumi.RegisterOutputType(MessagePtrOutput{})
	pulumi.RegisterOutputType(NotificationConfigOutput{})
	pulumi.RegisterOutputType(NotificationConfigPtrOutput{})
	pulumi.RegisterOutputType(NotificationConfigResponseOutput{})
	pulumi.RegisterOutputType(NotificationConfigResponsePtrOutput{})
	pulumi.RegisterOutputType(ParsedDataResponseOutput{})
	pulumi.RegisterOutputType(ParsedDataResponsePtrOutput{})
	pulumi.RegisterOutputType(ParserConfigOutput{})
	pulumi.RegisterOutputType(ParserConfigPtrOutput{})
	pulumi.RegisterOutputType(ParserConfigResponseOutput{})
	pulumi.RegisterOutputType(ParserConfigResponsePtrOutput{})
	pulumi.RegisterOutputType(PatientIdOutput{})
	pulumi.RegisterOutputType(PatientIdArrayOutput{})
	pulumi.RegisterOutputType(PatientIdResponseOutput{})
	pulumi.RegisterOutputType(PatientIdResponseArrayOutput{})
	pulumi.RegisterOutputType(PolicyOutput{})
	pulumi.RegisterOutputType(PolicyPtrOutput{})
	pulumi.RegisterOutputType(ResourceAnnotationOutput{})
	pulumi.RegisterOutputType(ResourceAnnotationPtrOutput{})
	pulumi.RegisterOutputType(ResourceAnnotationResponseOutput{})
	pulumi.RegisterOutputType(ResourceAnnotationResponsePtrOutput{})
	pulumi.RegisterOutputType(SchemaConfigOutput{})
	pulumi.RegisterOutputType(SchemaConfigPtrOutput{})
	pulumi.RegisterOutputType(SchemaConfigResponseOutput{})
	pulumi.RegisterOutputType(SchemaPackageOutput{})
	pulumi.RegisterOutputType(SchemaPackagePtrOutput{})
	pulumi.RegisterOutputType(SchemaPackageResponseOutput{})
	pulumi.RegisterOutputType(SchemaPackageResponsePtrOutput{})
	pulumi.RegisterOutputType(SchematizedDataOutput{})
	pulumi.RegisterOutputType(SchematizedDataPtrOutput{})
	pulumi.RegisterOutputType(SchematizedDataResponseOutput{})
	pulumi.RegisterOutputType(SchematizedDataResponsePtrOutput{})
	pulumi.RegisterOutputType(SegmentResponseOutput{})
	pulumi.RegisterOutputType(SegmentResponseArrayOutput{})
	pulumi.RegisterOutputType(SensitiveTextAnnotationOutput{})
	pulumi.RegisterOutputType(SensitiveTextAnnotationPtrOutput{})
	pulumi.RegisterOutputType(SensitiveTextAnnotationResponseOutput{})
	pulumi.RegisterOutputType(SensitiveTextAnnotationResponsePtrOutput{})
	pulumi.RegisterOutputType(SignatureOutput{})
	pulumi.RegisterOutputType(SignaturePtrOutput{})
	pulumi.RegisterOutputType(SignatureResponseOutput{})
	pulumi.RegisterOutputType(SignatureResponsePtrOutput{})
	pulumi.RegisterOutputType(StreamConfigOutput{})
	pulumi.RegisterOutputType(StreamConfigArrayOutput{})
	pulumi.RegisterOutputType(StreamConfigResponseOutput{})
	pulumi.RegisterOutputType(StreamConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(TypeOutput{})
	pulumi.RegisterOutputType(TypeArrayOutput{})
	pulumi.RegisterOutputType(TypeResponseOutput{})
	pulumi.RegisterOutputType(TypeResponseArrayOutput{})
	pulumi.RegisterOutputType(ValidationConfigOutput{})
	pulumi.RegisterOutputType(ValidationConfigPtrOutput{})
	pulumi.RegisterOutputType(ValidationConfigResponseOutput{})
	pulumi.RegisterOutputType(ValidationConfigResponsePtrOutput{})
	pulumi.RegisterOutputType(VersionSourceOutput{})
	pulumi.RegisterOutputType(VersionSourceArrayOutput{})
	pulumi.RegisterOutputType(VersionSourceResponseOutput{})
	pulumi.RegisterOutputType(VersionSourceResponseArrayOutput{})
	pulumi.RegisterOutputType(VertexOutput{})
	pulumi.RegisterOutputType(VertexArrayOutput{})
	pulumi.RegisterOutputType(VertexResponseOutput{})
	pulumi.RegisterOutputType(VertexResponseArrayOutput{})
}

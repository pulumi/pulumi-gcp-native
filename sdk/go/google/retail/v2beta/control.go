// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v2beta

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates a Control. If the Control to create already exists, an ALREADY_EXISTS error is returned.
// Auto-naming is currently not supported for this resource.
type Control struct {
	pulumi.CustomResourceState

	// List of serving configuration ids that that are associated with this control. Note the association is managed via the ServingConfig, this is an output only denormalizeed view. Assumed to be in the same catalog.
	AssociatedServingConfigIds pulumi.StringArrayOutput `pulumi:"associatedServingConfigIds"`
	// The human readable control display name. Used in Retail UI. This field must be a UTF-8 encoded string with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error is thrown.
	DisplayName pulumi.StringOutput `pulumi:"displayName"`
	// A facet specification to perform faceted search.
	FacetSpec GoogleCloudRetailV2betaSearchRequestFacetSpecResponseOutput `pulumi:"facetSpec"`
	// Immutable. Fully qualified name projects/*/locations/global/catalogs/*/controls/*
	Name pulumi.StringOutput `pulumi:"name"`
	// A rule control - a condition-action pair. Enacts a set action when the condition is triggered. For example: Boost "gShoe" when query full matches "Running Shoes".
	Rule GoogleCloudRetailV2betaRuleResponseOutput `pulumi:"rule"`
	// Immutable. The solution types that the serving config is used for. Currently we support setting only one type of solution at creation time. Only `SOLUTION_TYPE_SEARCH` value is supported at the moment. If no solution type is provided at creation time, will default to SOLUTION_TYPE_SEARCH.
	SolutionTypes pulumi.StringArrayOutput `pulumi:"solutionTypes"`
}

// NewControl registers a new resource with the given unique name, arguments, and options.
func NewControl(ctx *pulumi.Context,
	name string, args *ControlArgs, opts ...pulumi.ResourceOption) (*Control, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CatalogId == nil {
		return nil, errors.New("invalid value for required argument 'CatalogId'")
	}
	if args.ControlId == nil {
		return nil, errors.New("invalid value for required argument 'ControlId'")
	}
	if args.DisplayName == nil {
		return nil, errors.New("invalid value for required argument 'DisplayName'")
	}
	if args.SolutionTypes == nil {
		return nil, errors.New("invalid value for required argument 'SolutionTypes'")
	}
	var resource Control
	err := ctx.RegisterResource("google-native:retail/v2beta:Control", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetControl gets an existing Control resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetControl(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ControlState, opts ...pulumi.ResourceOption) (*Control, error) {
	var resource Control
	err := ctx.ReadResource("google-native:retail/v2beta:Control", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Control resources.
type controlState struct {
}

type ControlState struct {
}

func (ControlState) ElementType() reflect.Type {
	return reflect.TypeOf((*controlState)(nil)).Elem()
}

type controlArgs struct {
	CatalogId string `pulumi:"catalogId"`
	// Required. The ID to use for the Control, which will become the final component of the Control's resource name. This value should be 4-63 characters, and valid characters are /a-z-_/.
	ControlId string `pulumi:"controlId"`
	// The human readable control display name. Used in Retail UI. This field must be a UTF-8 encoded string with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error is thrown.
	DisplayName string `pulumi:"displayName"`
	// A facet specification to perform faceted search.
	FacetSpec *GoogleCloudRetailV2betaSearchRequestFacetSpec `pulumi:"facetSpec"`
	Location  *string                                        `pulumi:"location"`
	// Immutable. Fully qualified name projects/*/locations/global/catalogs/*/controls/*
	Name    *string `pulumi:"name"`
	Project *string `pulumi:"project"`
	// A rule control - a condition-action pair. Enacts a set action when the condition is triggered. For example: Boost "gShoe" when query full matches "Running Shoes".
	Rule *GoogleCloudRetailV2betaRule `pulumi:"rule"`
	// Immutable. The solution types that the serving config is used for. Currently we support setting only one type of solution at creation time. Only `SOLUTION_TYPE_SEARCH` value is supported at the moment. If no solution type is provided at creation time, will default to SOLUTION_TYPE_SEARCH.
	SolutionTypes []ControlSolutionTypesItem `pulumi:"solutionTypes"`
}

// The set of arguments for constructing a Control resource.
type ControlArgs struct {
	CatalogId pulumi.StringInput
	// Required. The ID to use for the Control, which will become the final component of the Control's resource name. This value should be 4-63 characters, and valid characters are /a-z-_/.
	ControlId pulumi.StringInput
	// The human readable control display name. Used in Retail UI. This field must be a UTF-8 encoded string with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error is thrown.
	DisplayName pulumi.StringInput
	// A facet specification to perform faceted search.
	FacetSpec GoogleCloudRetailV2betaSearchRequestFacetSpecPtrInput
	Location  pulumi.StringPtrInput
	// Immutable. Fully qualified name projects/*/locations/global/catalogs/*/controls/*
	Name    pulumi.StringPtrInput
	Project pulumi.StringPtrInput
	// A rule control - a condition-action pair. Enacts a set action when the condition is triggered. For example: Boost "gShoe" when query full matches "Running Shoes".
	Rule GoogleCloudRetailV2betaRulePtrInput
	// Immutable. The solution types that the serving config is used for. Currently we support setting only one type of solution at creation time. Only `SOLUTION_TYPE_SEARCH` value is supported at the moment. If no solution type is provided at creation time, will default to SOLUTION_TYPE_SEARCH.
	SolutionTypes ControlSolutionTypesItemArrayInput
}

func (ControlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*controlArgs)(nil)).Elem()
}

type ControlInput interface {
	pulumi.Input

	ToControlOutput() ControlOutput
	ToControlOutputWithContext(ctx context.Context) ControlOutput
}

func (*Control) ElementType() reflect.Type {
	return reflect.TypeOf((**Control)(nil)).Elem()
}

func (i *Control) ToControlOutput() ControlOutput {
	return i.ToControlOutputWithContext(context.Background())
}

func (i *Control) ToControlOutputWithContext(ctx context.Context) ControlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ControlOutput)
}

type ControlOutput struct{ *pulumi.OutputState }

func (ControlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Control)(nil)).Elem()
}

func (o ControlOutput) ToControlOutput() ControlOutput {
	return o
}

func (o ControlOutput) ToControlOutputWithContext(ctx context.Context) ControlOutput {
	return o
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ControlInput)(nil)).Elem(), &Control{})
	pulumi.RegisterOutputType(ControlOutput{})
}

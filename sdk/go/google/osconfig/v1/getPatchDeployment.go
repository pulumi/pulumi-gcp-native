// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Get an OS Config patch deployment.
func LookupPatchDeployment(ctx *pulumi.Context, args *LookupPatchDeploymentArgs, opts ...pulumi.InvokeOption) (*LookupPatchDeploymentResult, error) {
	var rv LookupPatchDeploymentResult
	err := ctx.Invoke("google-native:osconfig/v1:getPatchDeployment", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

type LookupPatchDeploymentArgs struct {
	PatchDeploymentId string  `pulumi:"patchDeploymentId"`
	Project           *string `pulumi:"project"`
}

type LookupPatchDeploymentResult struct {
	// Time the patch deployment was created. Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
	CreateTime string `pulumi:"createTime"`
	// Optional. Description of the patch deployment. Length of the description is limited to 1024 characters.
	Description string `pulumi:"description"`
	// Optional. Duration of the patch. After the duration ends, the patch times out.
	Duration string `pulumi:"duration"`
	// VM instances to patch.
	InstanceFilter PatchInstanceFilterResponse `pulumi:"instanceFilter"`
	// The last time a patch job was started by this deployment. Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
	LastExecuteTime string `pulumi:"lastExecuteTime"`
	// Unique name for the patch deployment resource in a project. The patch deployment name is in the form: `projects/{project_id}/patchDeployments/{patch_deployment_id}`. This field is ignored when you create a new patch deployment.
	Name string `pulumi:"name"`
	// Schedule a one-time execution.
	OneTimeSchedule OneTimeScheduleResponse `pulumi:"oneTimeSchedule"`
	// Optional. Patch configuration that is applied.
	PatchConfig PatchConfigResponse `pulumi:"patchConfig"`
	// Schedule recurring executions.
	RecurringSchedule RecurringScheduleResponse `pulumi:"recurringSchedule"`
	// Optional. Rollout strategy of the patch job.
	Rollout PatchRolloutResponse `pulumi:"rollout"`
	// Current state of the patch deployment.
	State string `pulumi:"state"`
	// Time the patch deployment was last updated. Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
	UpdateTime string `pulumi:"updateTime"`
}

func LookupPatchDeploymentOutput(ctx *pulumi.Context, args LookupPatchDeploymentOutputArgs, opts ...pulumi.InvokeOption) LookupPatchDeploymentResultOutput {
	return pulumi.ToOutputWithContext(context.Background(), args).
		ApplyT(func(v interface{}) (LookupPatchDeploymentResult, error) {
			args := v.(LookupPatchDeploymentArgs)
			r, err := LookupPatchDeployment(ctx, &args, opts...)
			var s LookupPatchDeploymentResult
			if r != nil {
				s = *r
			}
			return s, err
		}).(LookupPatchDeploymentResultOutput)
}

type LookupPatchDeploymentOutputArgs struct {
	PatchDeploymentId pulumi.StringInput    `pulumi:"patchDeploymentId"`
	Project           pulumi.StringPtrInput `pulumi:"project"`
}

func (LookupPatchDeploymentOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupPatchDeploymentArgs)(nil)).Elem()
}

type LookupPatchDeploymentResultOutput struct{ *pulumi.OutputState }

func (LookupPatchDeploymentResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupPatchDeploymentResult)(nil)).Elem()
}

func (o LookupPatchDeploymentResultOutput) ToLookupPatchDeploymentResultOutput() LookupPatchDeploymentResultOutput {
	return o
}

func (o LookupPatchDeploymentResultOutput) ToLookupPatchDeploymentResultOutputWithContext(ctx context.Context) LookupPatchDeploymentResultOutput {
	return o
}

// Time the patch deployment was created. Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
func (o LookupPatchDeploymentResultOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v LookupPatchDeploymentResult) string { return v.CreateTime }).(pulumi.StringOutput)
}

// Optional. Description of the patch deployment. Length of the description is limited to 1024 characters.
func (o LookupPatchDeploymentResultOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v LookupPatchDeploymentResult) string { return v.Description }).(pulumi.StringOutput)
}

// Optional. Duration of the patch. After the duration ends, the patch times out.
func (o LookupPatchDeploymentResultOutput) Duration() pulumi.StringOutput {
	return o.ApplyT(func(v LookupPatchDeploymentResult) string { return v.Duration }).(pulumi.StringOutput)
}

// VM instances to patch.
func (o LookupPatchDeploymentResultOutput) InstanceFilter() PatchInstanceFilterResponseOutput {
	return o.ApplyT(func(v LookupPatchDeploymentResult) PatchInstanceFilterResponse { return v.InstanceFilter }).(PatchInstanceFilterResponseOutput)
}

// The last time a patch job was started by this deployment. Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
func (o LookupPatchDeploymentResultOutput) LastExecuteTime() pulumi.StringOutput {
	return o.ApplyT(func(v LookupPatchDeploymentResult) string { return v.LastExecuteTime }).(pulumi.StringOutput)
}

// Unique name for the patch deployment resource in a project. The patch deployment name is in the form: `projects/{project_id}/patchDeployments/{patch_deployment_id}`. This field is ignored when you create a new patch deployment.
func (o LookupPatchDeploymentResultOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v LookupPatchDeploymentResult) string { return v.Name }).(pulumi.StringOutput)
}

// Schedule a one-time execution.
func (o LookupPatchDeploymentResultOutput) OneTimeSchedule() OneTimeScheduleResponseOutput {
	return o.ApplyT(func(v LookupPatchDeploymentResult) OneTimeScheduleResponse { return v.OneTimeSchedule }).(OneTimeScheduleResponseOutput)
}

// Optional. Patch configuration that is applied.
func (o LookupPatchDeploymentResultOutput) PatchConfig() PatchConfigResponseOutput {
	return o.ApplyT(func(v LookupPatchDeploymentResult) PatchConfigResponse { return v.PatchConfig }).(PatchConfigResponseOutput)
}

// Schedule recurring executions.
func (o LookupPatchDeploymentResultOutput) RecurringSchedule() RecurringScheduleResponseOutput {
	return o.ApplyT(func(v LookupPatchDeploymentResult) RecurringScheduleResponse { return v.RecurringSchedule }).(RecurringScheduleResponseOutput)
}

// Optional. Rollout strategy of the patch job.
func (o LookupPatchDeploymentResultOutput) Rollout() PatchRolloutResponseOutput {
	return o.ApplyT(func(v LookupPatchDeploymentResult) PatchRolloutResponse { return v.Rollout }).(PatchRolloutResponseOutput)
}

// Current state of the patch deployment.
func (o LookupPatchDeploymentResultOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v LookupPatchDeploymentResult) string { return v.State }).(pulumi.StringOutput)
}

// Time the patch deployment was last updated. Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
func (o LookupPatchDeploymentResultOutput) UpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v LookupPatchDeploymentResult) string { return v.UpdateTime }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterOutputType(LookupPatchDeploymentResultOutput{})
}

// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Gets the details of a mapping rule.
func LookupMappingRule(ctx *pulumi.Context, args *LookupMappingRuleArgs, opts ...pulumi.InvokeOption) (*LookupMappingRuleResult, error) {
	opts = internal.PkgInvokeDefaultOpts(opts)
	var rv LookupMappingRuleResult
	err := ctx.Invoke("google-native:datamigration/v1:getMappingRule", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

type LookupMappingRuleArgs struct {
	ConversionWorkspaceId string  `pulumi:"conversionWorkspaceId"`
	Location              string  `pulumi:"location"`
	MappingRuleId         string  `pulumi:"mappingRuleId"`
	Project               *string `pulumi:"project"`
}

type LookupMappingRuleResult struct {
	// Optional. Rule to specify how the data contained in a column should be transformed (such as trimmed, rounded, etc) provided that the data meets certain criteria.
	ConditionalColumnSetValue ConditionalColumnSetValueResponse `pulumi:"conditionalColumnSetValue"`
	// Optional. Rule to specify how multiple tables should be converted with an additional rowid column.
	ConvertRowidColumn ConvertRowIdToColumnResponse `pulumi:"convertRowidColumn"`
	// Optional. A human readable name
	DisplayName string `pulumi:"displayName"`
	// Optional. Rule to specify how multiple entities should be relocated into a different schema.
	EntityMove EntityMoveResponse `pulumi:"entityMove"`
	// The rule filter
	Filter MappingRuleFilterResponse `pulumi:"filter"`
	// Optional. Rule to specify the list of columns to include or exclude from a table.
	FilterTableColumns FilterTableColumnsResponse `pulumi:"filterTableColumns"`
	// Optional. Rule to specify how multiple columns should be converted to a different data type.
	MultiColumnDataTypeChange MultiColumnDatatypeChangeResponse `pulumi:"multiColumnDataTypeChange"`
	// Optional. Rule to specify how multiple entities should be renamed.
	MultiEntityRename MultiEntityRenameResponse `pulumi:"multiEntityRename"`
	// Full name of the mapping rule resource, in the form of: projects/{project}/locations/{location}/conversionWorkspaces/{set}/mappingRule/{rule}.
	Name string `pulumi:"name"`
	// The timestamp that the revision was created.
	RevisionCreateTime string `pulumi:"revisionCreateTime"`
	// The revision ID of the mapping rule. A new revision is committed whenever the mapping rule is changed in any way. The format is an 8-character hexadecimal string.
	RevisionId string `pulumi:"revisionId"`
	// The order in which the rule is applied. Lower order rules are applied before higher value rules so they may end up being overridden.
	RuleOrder string `pulumi:"ruleOrder"`
	// The rule scope
	RuleScope string `pulumi:"ruleScope"`
	// Optional. Rule to specify the primary key for a table
	SetTablePrimaryKey SetTablePrimaryKeyResponse `pulumi:"setTablePrimaryKey"`
	// Optional. Rule to specify how a single column is converted.
	SingleColumnChange SingleColumnChangeResponse `pulumi:"singleColumnChange"`
	// Optional. Rule to specify how a single entity should be renamed.
	SingleEntityRename SingleEntityRenameResponse `pulumi:"singleEntityRename"`
	// Optional. Rule to specify how a single package is converted.
	SinglePackageChange SinglePackageChangeResponse `pulumi:"singlePackageChange"`
	// Optional. Rule to change the sql code for an entity, for example, function, procedure.
	SourceSqlChange SourceSqlChangeResponse `pulumi:"sourceSqlChange"`
	// Optional. The mapping rule state
	State string `pulumi:"state"`
}

func LookupMappingRuleOutput(ctx *pulumi.Context, args LookupMappingRuleOutputArgs, opts ...pulumi.InvokeOption) LookupMappingRuleResultOutput {
	return pulumi.ToOutputWithContext(context.Background(), args).
		ApplyT(func(v interface{}) (LookupMappingRuleResult, error) {
			args := v.(LookupMappingRuleArgs)
			r, err := LookupMappingRule(ctx, &args, opts...)
			var s LookupMappingRuleResult
			if r != nil {
				s = *r
			}
			return s, err
		}).(LookupMappingRuleResultOutput)
}

type LookupMappingRuleOutputArgs struct {
	ConversionWorkspaceId pulumi.StringInput    `pulumi:"conversionWorkspaceId"`
	Location              pulumi.StringInput    `pulumi:"location"`
	MappingRuleId         pulumi.StringInput    `pulumi:"mappingRuleId"`
	Project               pulumi.StringPtrInput `pulumi:"project"`
}

func (LookupMappingRuleOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupMappingRuleArgs)(nil)).Elem()
}

type LookupMappingRuleResultOutput struct{ *pulumi.OutputState }

func (LookupMappingRuleResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupMappingRuleResult)(nil)).Elem()
}

func (o LookupMappingRuleResultOutput) ToLookupMappingRuleResultOutput() LookupMappingRuleResultOutput {
	return o
}

func (o LookupMappingRuleResultOutput) ToLookupMappingRuleResultOutputWithContext(ctx context.Context) LookupMappingRuleResultOutput {
	return o
}

func (o LookupMappingRuleResultOutput) ToOutput(ctx context.Context) pulumix.Output[LookupMappingRuleResult] {
	return pulumix.Output[LookupMappingRuleResult]{
		OutputState: o.OutputState,
	}
}

// Optional. Rule to specify how the data contained in a column should be transformed (such as trimmed, rounded, etc) provided that the data meets certain criteria.
func (o LookupMappingRuleResultOutput) ConditionalColumnSetValue() ConditionalColumnSetValueResponseOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) ConditionalColumnSetValueResponse { return v.ConditionalColumnSetValue }).(ConditionalColumnSetValueResponseOutput)
}

// Optional. Rule to specify how multiple tables should be converted with an additional rowid column.
func (o LookupMappingRuleResultOutput) ConvertRowidColumn() ConvertRowIdToColumnResponseOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) ConvertRowIdToColumnResponse { return v.ConvertRowidColumn }).(ConvertRowIdToColumnResponseOutput)
}

// Optional. A human readable name
func (o LookupMappingRuleResultOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) string { return v.DisplayName }).(pulumi.StringOutput)
}

// Optional. Rule to specify how multiple entities should be relocated into a different schema.
func (o LookupMappingRuleResultOutput) EntityMove() EntityMoveResponseOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) EntityMoveResponse { return v.EntityMove }).(EntityMoveResponseOutput)
}

// The rule filter
func (o LookupMappingRuleResultOutput) Filter() MappingRuleFilterResponseOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) MappingRuleFilterResponse { return v.Filter }).(MappingRuleFilterResponseOutput)
}

// Optional. Rule to specify the list of columns to include or exclude from a table.
func (o LookupMappingRuleResultOutput) FilterTableColumns() FilterTableColumnsResponseOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) FilterTableColumnsResponse { return v.FilterTableColumns }).(FilterTableColumnsResponseOutput)
}

// Optional. Rule to specify how multiple columns should be converted to a different data type.
func (o LookupMappingRuleResultOutput) MultiColumnDataTypeChange() MultiColumnDatatypeChangeResponseOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) MultiColumnDatatypeChangeResponse { return v.MultiColumnDataTypeChange }).(MultiColumnDatatypeChangeResponseOutput)
}

// Optional. Rule to specify how multiple entities should be renamed.
func (o LookupMappingRuleResultOutput) MultiEntityRename() MultiEntityRenameResponseOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) MultiEntityRenameResponse { return v.MultiEntityRename }).(MultiEntityRenameResponseOutput)
}

// Full name of the mapping rule resource, in the form of: projects/{project}/locations/{location}/conversionWorkspaces/{set}/mappingRule/{rule}.
func (o LookupMappingRuleResultOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) string { return v.Name }).(pulumi.StringOutput)
}

// The timestamp that the revision was created.
func (o LookupMappingRuleResultOutput) RevisionCreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) string { return v.RevisionCreateTime }).(pulumi.StringOutput)
}

// The revision ID of the mapping rule. A new revision is committed whenever the mapping rule is changed in any way. The format is an 8-character hexadecimal string.
func (o LookupMappingRuleResultOutput) RevisionId() pulumi.StringOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) string { return v.RevisionId }).(pulumi.StringOutput)
}

// The order in which the rule is applied. Lower order rules are applied before higher value rules so they may end up being overridden.
func (o LookupMappingRuleResultOutput) RuleOrder() pulumi.StringOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) string { return v.RuleOrder }).(pulumi.StringOutput)
}

// The rule scope
func (o LookupMappingRuleResultOutput) RuleScope() pulumi.StringOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) string { return v.RuleScope }).(pulumi.StringOutput)
}

// Optional. Rule to specify the primary key for a table
func (o LookupMappingRuleResultOutput) SetTablePrimaryKey() SetTablePrimaryKeyResponseOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) SetTablePrimaryKeyResponse { return v.SetTablePrimaryKey }).(SetTablePrimaryKeyResponseOutput)
}

// Optional. Rule to specify how a single column is converted.
func (o LookupMappingRuleResultOutput) SingleColumnChange() SingleColumnChangeResponseOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) SingleColumnChangeResponse { return v.SingleColumnChange }).(SingleColumnChangeResponseOutput)
}

// Optional. Rule to specify how a single entity should be renamed.
func (o LookupMappingRuleResultOutput) SingleEntityRename() SingleEntityRenameResponseOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) SingleEntityRenameResponse { return v.SingleEntityRename }).(SingleEntityRenameResponseOutput)
}

// Optional. Rule to specify how a single package is converted.
func (o LookupMappingRuleResultOutput) SinglePackageChange() SinglePackageChangeResponseOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) SinglePackageChangeResponse { return v.SinglePackageChange }).(SinglePackageChangeResponseOutput)
}

// Optional. Rule to change the sql code for an entity, for example, function, procedure.
func (o LookupMappingRuleResultOutput) SourceSqlChange() SourceSqlChangeResponseOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) SourceSqlChangeResponse { return v.SourceSqlChange }).(SourceSqlChangeResponseOutput)
}

// Optional. The mapping rule state
func (o LookupMappingRuleResultOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v LookupMappingRuleResult) string { return v.State }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterOutputType(LookupMappingRuleResultOutput{})
}

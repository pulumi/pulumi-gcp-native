// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates a new BeyondCorp Enterprise Subscription in a given organization. Location will always be global as BeyondCorp subscriptions are per organization.
// Note - this resource's API doesn't support deletion. When deleted, the resource will persist
// on Google Cloud even though it will be deleted from Pulumi state.
type Subscription struct {
	pulumi.CustomResourceState

	// Represents that, if subscription will renew or end when the term ends.
	AutoRenewEnabled pulumi.BoolOutput `pulumi:"autoRenewEnabled"`
	// Create time of the subscription.
	CreateTime pulumi.StringOutput `pulumi:"createTime"`
	// End time of the subscription.
	EndTime  pulumi.StringOutput `pulumi:"endTime"`
	Location pulumi.StringOutput `pulumi:"location"`
	// Unique resource name of the Subscription. The name is ignored when creating a subscription.
	Name           pulumi.StringOutput `pulumi:"name"`
	OrganizationId pulumi.StringOutput `pulumi:"organizationId"`
	// Number of seats in the subscription.
	SeatCount pulumi.StringOutput `pulumi:"seatCount"`
	// SKU of subscription.
	Sku pulumi.StringOutput `pulumi:"sku"`
	// Start time of the subscription.
	StartTime pulumi.StringOutput `pulumi:"startTime"`
	// The current state of the subscription.
	State pulumi.StringOutput `pulumi:"state"`
	// Type of subscription.
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewSubscription registers a new resource with the given unique name, arguments, and options.
func NewSubscription(ctx *pulumi.Context,
	name string, args *SubscriptionArgs, opts ...pulumi.ResourceOption) (*Subscription, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.OrganizationId == nil {
		return nil, errors.New("invalid value for required argument 'OrganizationId'")
	}
	if args.Sku == nil {
		return nil, errors.New("invalid value for required argument 'Sku'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	replaceOnChanges := pulumi.ReplaceOnChanges([]string{
		"location",
		"organizationId",
	})
	opts = append(opts, replaceOnChanges)
	var resource Subscription
	err := ctx.RegisterResource("google-native:beyondcorp/v1alpha:Subscription", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSubscription gets an existing Subscription resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSubscription(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SubscriptionState, opts ...pulumi.ResourceOption) (*Subscription, error) {
	var resource Subscription
	err := ctx.ReadResource("google-native:beyondcorp/v1alpha:Subscription", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Subscription resources.
type subscriptionState struct {
}

type SubscriptionState struct {
}

func (SubscriptionState) ElementType() reflect.Type {
	return reflect.TypeOf((*subscriptionState)(nil)).Elem()
}

type subscriptionArgs struct {
	Location *string `pulumi:"location"`
	// Unique resource name of the Subscription. The name is ignored when creating a subscription.
	Name           *string `pulumi:"name"`
	OrganizationId string  `pulumi:"organizationId"`
	// SKU of subscription.
	Sku SubscriptionSku `pulumi:"sku"`
	// Type of subscription.
	Type SubscriptionType `pulumi:"type"`
}

// The set of arguments for constructing a Subscription resource.
type SubscriptionArgs struct {
	Location pulumi.StringPtrInput
	// Unique resource name of the Subscription. The name is ignored when creating a subscription.
	Name           pulumi.StringPtrInput
	OrganizationId pulumi.StringInput
	// SKU of subscription.
	Sku SubscriptionSkuInput
	// Type of subscription.
	Type SubscriptionTypeInput
}

func (SubscriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*subscriptionArgs)(nil)).Elem()
}

type SubscriptionInput interface {
	pulumi.Input

	ToSubscriptionOutput() SubscriptionOutput
	ToSubscriptionOutputWithContext(ctx context.Context) SubscriptionOutput
}

func (*Subscription) ElementType() reflect.Type {
	return reflect.TypeOf((**Subscription)(nil)).Elem()
}

func (i *Subscription) ToSubscriptionOutput() SubscriptionOutput {
	return i.ToSubscriptionOutputWithContext(context.Background())
}

func (i *Subscription) ToSubscriptionOutputWithContext(ctx context.Context) SubscriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionOutput)
}

type SubscriptionOutput struct{ *pulumi.OutputState }

func (SubscriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Subscription)(nil)).Elem()
}

func (o SubscriptionOutput) ToSubscriptionOutput() SubscriptionOutput {
	return o
}

func (o SubscriptionOutput) ToSubscriptionOutputWithContext(ctx context.Context) SubscriptionOutput {
	return o
}

// Represents that, if subscription will renew or end when the term ends.
func (o SubscriptionOutput) AutoRenewEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *Subscription) pulumi.BoolOutput { return v.AutoRenewEnabled }).(pulumi.BoolOutput)
}

// Create time of the subscription.
func (o SubscriptionOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.CreateTime }).(pulumi.StringOutput)
}

// End time of the subscription.
func (o SubscriptionOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.EndTime }).(pulumi.StringOutput)
}

func (o SubscriptionOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// Unique resource name of the Subscription. The name is ignored when creating a subscription.
func (o SubscriptionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o SubscriptionOutput) OrganizationId() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.OrganizationId }).(pulumi.StringOutput)
}

// Number of seats in the subscription.
func (o SubscriptionOutput) SeatCount() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.SeatCount }).(pulumi.StringOutput)
}

// SKU of subscription.
func (o SubscriptionOutput) Sku() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.Sku }).(pulumi.StringOutput)
}

// Start time of the subscription.
func (o SubscriptionOutput) StartTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.StartTime }).(pulumi.StringOutput)
}

// The current state of the subscription.
func (o SubscriptionOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// Type of subscription.
func (o SubscriptionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SubscriptionInput)(nil)).Elem(), &Subscription{})
	pulumi.RegisterOutputType(SubscriptionOutput{})
}

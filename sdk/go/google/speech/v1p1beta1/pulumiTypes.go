// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1p1beta1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// An item of the class.
type ClassItem struct {
	// The class item's value.
	Value *string `pulumi:"value"`
}

// ClassItemInput is an input type that accepts ClassItemArgs and ClassItemOutput values.
// You can construct a concrete instance of `ClassItemInput` via:
//
//          ClassItemArgs{...}
type ClassItemInput interface {
	pulumi.Input

	ToClassItemOutput() ClassItemOutput
	ToClassItemOutputWithContext(context.Context) ClassItemOutput
}

// An item of the class.
type ClassItemArgs struct {
	// The class item's value.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (ClassItemArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClassItem)(nil)).Elem()
}

func (i ClassItemArgs) ToClassItemOutput() ClassItemOutput {
	return i.ToClassItemOutputWithContext(context.Background())
}

func (i ClassItemArgs) ToClassItemOutputWithContext(ctx context.Context) ClassItemOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClassItemOutput)
}

// ClassItemArrayInput is an input type that accepts ClassItemArray and ClassItemArrayOutput values.
// You can construct a concrete instance of `ClassItemArrayInput` via:
//
//          ClassItemArray{ ClassItemArgs{...} }
type ClassItemArrayInput interface {
	pulumi.Input

	ToClassItemArrayOutput() ClassItemArrayOutput
	ToClassItemArrayOutputWithContext(context.Context) ClassItemArrayOutput
}

type ClassItemArray []ClassItemInput

func (ClassItemArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClassItem)(nil)).Elem()
}

func (i ClassItemArray) ToClassItemArrayOutput() ClassItemArrayOutput {
	return i.ToClassItemArrayOutputWithContext(context.Background())
}

func (i ClassItemArray) ToClassItemArrayOutputWithContext(ctx context.Context) ClassItemArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClassItemArrayOutput)
}

// An item of the class.
type ClassItemOutput struct{ *pulumi.OutputState }

func (ClassItemOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClassItem)(nil)).Elem()
}

func (o ClassItemOutput) ToClassItemOutput() ClassItemOutput {
	return o
}

func (o ClassItemOutput) ToClassItemOutputWithContext(ctx context.Context) ClassItemOutput {
	return o
}

// The class item's value.
func (o ClassItemOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClassItem) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type ClassItemArrayOutput struct{ *pulumi.OutputState }

func (ClassItemArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClassItem)(nil)).Elem()
}

func (o ClassItemArrayOutput) ToClassItemArrayOutput() ClassItemArrayOutput {
	return o
}

func (o ClassItemArrayOutput) ToClassItemArrayOutputWithContext(ctx context.Context) ClassItemArrayOutput {
	return o
}

func (o ClassItemArrayOutput) Index(i pulumi.IntInput) ClassItemOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClassItem {
		return vs[0].([]ClassItem)[vs[1].(int)]
	}).(ClassItemOutput)
}

// An item of the class.
type ClassItemResponse struct {
	// The class item's value.
	Value string `pulumi:"value"`
}

// ClassItemResponseInput is an input type that accepts ClassItemResponseArgs and ClassItemResponseOutput values.
// You can construct a concrete instance of `ClassItemResponseInput` via:
//
//          ClassItemResponseArgs{...}
type ClassItemResponseInput interface {
	pulumi.Input

	ToClassItemResponseOutput() ClassItemResponseOutput
	ToClassItemResponseOutputWithContext(context.Context) ClassItemResponseOutput
}

// An item of the class.
type ClassItemResponseArgs struct {
	// The class item's value.
	Value pulumi.StringInput `pulumi:"value"`
}

func (ClassItemResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClassItemResponse)(nil)).Elem()
}

func (i ClassItemResponseArgs) ToClassItemResponseOutput() ClassItemResponseOutput {
	return i.ToClassItemResponseOutputWithContext(context.Background())
}

func (i ClassItemResponseArgs) ToClassItemResponseOutputWithContext(ctx context.Context) ClassItemResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClassItemResponseOutput)
}

// ClassItemResponseArrayInput is an input type that accepts ClassItemResponseArray and ClassItemResponseArrayOutput values.
// You can construct a concrete instance of `ClassItemResponseArrayInput` via:
//
//          ClassItemResponseArray{ ClassItemResponseArgs{...} }
type ClassItemResponseArrayInput interface {
	pulumi.Input

	ToClassItemResponseArrayOutput() ClassItemResponseArrayOutput
	ToClassItemResponseArrayOutputWithContext(context.Context) ClassItemResponseArrayOutput
}

type ClassItemResponseArray []ClassItemResponseInput

func (ClassItemResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClassItemResponse)(nil)).Elem()
}

func (i ClassItemResponseArray) ToClassItemResponseArrayOutput() ClassItemResponseArrayOutput {
	return i.ToClassItemResponseArrayOutputWithContext(context.Background())
}

func (i ClassItemResponseArray) ToClassItemResponseArrayOutputWithContext(ctx context.Context) ClassItemResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClassItemResponseArrayOutput)
}

// An item of the class.
type ClassItemResponseOutput struct{ *pulumi.OutputState }

func (ClassItemResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClassItemResponse)(nil)).Elem()
}

func (o ClassItemResponseOutput) ToClassItemResponseOutput() ClassItemResponseOutput {
	return o
}

func (o ClassItemResponseOutput) ToClassItemResponseOutputWithContext(ctx context.Context) ClassItemResponseOutput {
	return o
}

// The class item's value.
func (o ClassItemResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v ClassItemResponse) string { return v.Value }).(pulumi.StringOutput)
}

type ClassItemResponseArrayOutput struct{ *pulumi.OutputState }

func (ClassItemResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClassItemResponse)(nil)).Elem()
}

func (o ClassItemResponseArrayOutput) ToClassItemResponseArrayOutput() ClassItemResponseArrayOutput {
	return o
}

func (o ClassItemResponseArrayOutput) ToClassItemResponseArrayOutputWithContext(ctx context.Context) ClassItemResponseArrayOutput {
	return o
}

func (o ClassItemResponseArrayOutput) Index(i pulumi.IntInput) ClassItemResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClassItemResponse {
		return vs[0].([]ClassItemResponse)[vs[1].(int)]
	}).(ClassItemResponseOutput)
}

// A set of words or phrases that represents a common concept likely to appear in your audio, for example a list of passenger ship names. CustomClass items can be substituted into placeholders that you set in PhraseSet phrases.
type CustomClassType struct {
	// If this custom class is a resource, the custom_class_id is the resource id of the CustomClass. Case sensitive.
	CustomClassId *string `pulumi:"customClassId"`
	// A collection of class items.
	Items []ClassItem `pulumi:"items"`
	// The resource name of the custom class.
	Name *string `pulumi:"name"`
}

// CustomClassTypeInput is an input type that accepts CustomClassTypeArgs and CustomClassTypeOutput values.
// You can construct a concrete instance of `CustomClassTypeInput` via:
//
//          CustomClassTypeArgs{...}
type CustomClassTypeInput interface {
	pulumi.Input

	ToCustomClassTypeOutput() CustomClassTypeOutput
	ToCustomClassTypeOutputWithContext(context.Context) CustomClassTypeOutput
}

// A set of words or phrases that represents a common concept likely to appear in your audio, for example a list of passenger ship names. CustomClass items can be substituted into placeholders that you set in PhraseSet phrases.
type CustomClassTypeArgs struct {
	// If this custom class is a resource, the custom_class_id is the resource id of the CustomClass. Case sensitive.
	CustomClassId pulumi.StringPtrInput `pulumi:"customClassId"`
	// A collection of class items.
	Items ClassItemArrayInput `pulumi:"items"`
	// The resource name of the custom class.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (CustomClassTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomClassType)(nil)).Elem()
}

func (i CustomClassTypeArgs) ToCustomClassTypeOutput() CustomClassTypeOutput {
	return i.ToCustomClassTypeOutputWithContext(context.Background())
}

func (i CustomClassTypeArgs) ToCustomClassTypeOutputWithContext(ctx context.Context) CustomClassTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomClassTypeOutput)
}

func (i CustomClassTypeArgs) ToCustomClassTypePtrOutput() CustomClassTypePtrOutput {
	return i.ToCustomClassTypePtrOutputWithContext(context.Background())
}

func (i CustomClassTypeArgs) ToCustomClassTypePtrOutputWithContext(ctx context.Context) CustomClassTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomClassTypeOutput).ToCustomClassTypePtrOutputWithContext(ctx)
}

// CustomClassTypePtrInput is an input type that accepts CustomClassTypeArgs, CustomClassTypePtr and CustomClassTypePtrOutput values.
// You can construct a concrete instance of `CustomClassTypePtrInput` via:
//
//          CustomClassTypeArgs{...}
//
//  or:
//
//          nil
type CustomClassTypePtrInput interface {
	pulumi.Input

	ToCustomClassTypePtrOutput() CustomClassTypePtrOutput
	ToCustomClassTypePtrOutputWithContext(context.Context) CustomClassTypePtrOutput
}

type customClassTypePtrType CustomClassTypeArgs

func CustomClassTypePtr(v *CustomClassTypeArgs) CustomClassTypePtrInput {
	return (*customClassTypePtrType)(v)
}

func (*customClassTypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CustomClassType)(nil)).Elem()
}

func (i *customClassTypePtrType) ToCustomClassTypePtrOutput() CustomClassTypePtrOutput {
	return i.ToCustomClassTypePtrOutputWithContext(context.Background())
}

func (i *customClassTypePtrType) ToCustomClassTypePtrOutputWithContext(ctx context.Context) CustomClassTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomClassTypePtrOutput)
}

// A set of words or phrases that represents a common concept likely to appear in your audio, for example a list of passenger ship names. CustomClass items can be substituted into placeholders that you set in PhraseSet phrases.
type CustomClassTypeOutput struct{ *pulumi.OutputState }

func (CustomClassTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomClassType)(nil)).Elem()
}

func (o CustomClassTypeOutput) ToCustomClassTypeOutput() CustomClassTypeOutput {
	return o
}

func (o CustomClassTypeOutput) ToCustomClassTypeOutputWithContext(ctx context.Context) CustomClassTypeOutput {
	return o
}

func (o CustomClassTypeOutput) ToCustomClassTypePtrOutput() CustomClassTypePtrOutput {
	return o.ToCustomClassTypePtrOutputWithContext(context.Background())
}

func (o CustomClassTypeOutput) ToCustomClassTypePtrOutputWithContext(ctx context.Context) CustomClassTypePtrOutput {
	return o.ApplyT(func(v CustomClassType) *CustomClassType {
		return &v
	}).(CustomClassTypePtrOutput)
}

// If this custom class is a resource, the custom_class_id is the resource id of the CustomClass. Case sensitive.
func (o CustomClassTypeOutput) CustomClassId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CustomClassType) *string { return v.CustomClassId }).(pulumi.StringPtrOutput)
}

// A collection of class items.
func (o CustomClassTypeOutput) Items() ClassItemArrayOutput {
	return o.ApplyT(func(v CustomClassType) []ClassItem { return v.Items }).(ClassItemArrayOutput)
}

// The resource name of the custom class.
func (o CustomClassTypeOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CustomClassType) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type CustomClassTypePtrOutput struct{ *pulumi.OutputState }

func (CustomClassTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CustomClassType)(nil)).Elem()
}

func (o CustomClassTypePtrOutput) ToCustomClassTypePtrOutput() CustomClassTypePtrOutput {
	return o
}

func (o CustomClassTypePtrOutput) ToCustomClassTypePtrOutputWithContext(ctx context.Context) CustomClassTypePtrOutput {
	return o
}

func (o CustomClassTypePtrOutput) Elem() CustomClassTypeOutput {
	return o.ApplyT(func(v *CustomClassType) CustomClassType { return *v }).(CustomClassTypeOutput)
}

// If this custom class is a resource, the custom_class_id is the resource id of the CustomClass. Case sensitive.
func (o CustomClassTypePtrOutput) CustomClassId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CustomClassType) *string {
		if v == nil {
			return nil
		}
		return v.CustomClassId
	}).(pulumi.StringPtrOutput)
}

// A collection of class items.
func (o CustomClassTypePtrOutput) Items() ClassItemArrayOutput {
	return o.ApplyT(func(v *CustomClassType) []ClassItem {
		if v == nil {
			return nil
		}
		return v.Items
	}).(ClassItemArrayOutput)
}

// The resource name of the custom class.
func (o CustomClassTypePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CustomClassType) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// A phrases containing words and phrase "hints" so that the speech recognition is more likely to recognize them. This can be used to improve the accuracy for specific words and phrases, for example, if specific commands are typically spoken by the user. This can also be used to add additional words to the vocabulary of the recognizer. See [usage limits](https://cloud.google.com/speech-to-text/quotas#content). List items can also include pre-built or custom classes containing groups of words that represent common concepts that occur in natural language. For example, rather than providing a phrase hint for every month of the year (e.g. "i was born in january", "i was born in febuary", ...), use the pre-built `$MONTH` class improves the likelihood of correctly transcribing audio that includes months (e.g. "i was born in $month"). To refer to pre-built classes, use the class' symbol prepended with `$` e.g. `$MONTH`. To refer to custom classes that were defined inline in the request, set the class's `custom_class_id` to a string unique to all class resources and inline classes. Then use the class' id wrapped in $`{...}` e.g. "${my-months}". To refer to custom classes resources, use the class' id wrapped in `${}` (e.g. `${my-months}`).
type Phrase struct {
	// Hint Boost. Overrides the boost set at the phrase set level. Positive value will increase the probability that a specific phrase will be recognized over other similar sounding phrases. The higher the boost, the higher the chance of false positive recognition as well. Negative boost values would correspond to anti-biasing. Anti-biasing is not enabled, so negative boost will simply be ignored. Though `boost` can accept a wide range of positive values, most use cases are best served with values between 0 and 20. We recommend using a binary search approach to finding the optimal value for your use case. Speech recognition will skip PhraseSets with a boost value of 0.
	Boost *float64 `pulumi:"boost"`
	// The phrase itself.
	Value *string `pulumi:"value"`
}

// PhraseInput is an input type that accepts PhraseArgs and PhraseOutput values.
// You can construct a concrete instance of `PhraseInput` via:
//
//          PhraseArgs{...}
type PhraseInput interface {
	pulumi.Input

	ToPhraseOutput() PhraseOutput
	ToPhraseOutputWithContext(context.Context) PhraseOutput
}

// A phrases containing words and phrase "hints" so that the speech recognition is more likely to recognize them. This can be used to improve the accuracy for specific words and phrases, for example, if specific commands are typically spoken by the user. This can also be used to add additional words to the vocabulary of the recognizer. See [usage limits](https://cloud.google.com/speech-to-text/quotas#content). List items can also include pre-built or custom classes containing groups of words that represent common concepts that occur in natural language. For example, rather than providing a phrase hint for every month of the year (e.g. "i was born in january", "i was born in febuary", ...), use the pre-built `$MONTH` class improves the likelihood of correctly transcribing audio that includes months (e.g. "i was born in $month"). To refer to pre-built classes, use the class' symbol prepended with `$` e.g. `$MONTH`. To refer to custom classes that were defined inline in the request, set the class's `custom_class_id` to a string unique to all class resources and inline classes. Then use the class' id wrapped in $`{...}` e.g. "${my-months}". To refer to custom classes resources, use the class' id wrapped in `${}` (e.g. `${my-months}`).
type PhraseArgs struct {
	// Hint Boost. Overrides the boost set at the phrase set level. Positive value will increase the probability that a specific phrase will be recognized over other similar sounding phrases. The higher the boost, the higher the chance of false positive recognition as well. Negative boost values would correspond to anti-biasing. Anti-biasing is not enabled, so negative boost will simply be ignored. Though `boost` can accept a wide range of positive values, most use cases are best served with values between 0 and 20. We recommend using a binary search approach to finding the optimal value for your use case. Speech recognition will skip PhraseSets with a boost value of 0.
	Boost pulumi.Float64PtrInput `pulumi:"boost"`
	// The phrase itself.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (PhraseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Phrase)(nil)).Elem()
}

func (i PhraseArgs) ToPhraseOutput() PhraseOutput {
	return i.ToPhraseOutputWithContext(context.Background())
}

func (i PhraseArgs) ToPhraseOutputWithContext(ctx context.Context) PhraseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PhraseOutput)
}

// PhraseArrayInput is an input type that accepts PhraseArray and PhraseArrayOutput values.
// You can construct a concrete instance of `PhraseArrayInput` via:
//
//          PhraseArray{ PhraseArgs{...} }
type PhraseArrayInput interface {
	pulumi.Input

	ToPhraseArrayOutput() PhraseArrayOutput
	ToPhraseArrayOutputWithContext(context.Context) PhraseArrayOutput
}

type PhraseArray []PhraseInput

func (PhraseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Phrase)(nil)).Elem()
}

func (i PhraseArray) ToPhraseArrayOutput() PhraseArrayOutput {
	return i.ToPhraseArrayOutputWithContext(context.Background())
}

func (i PhraseArray) ToPhraseArrayOutputWithContext(ctx context.Context) PhraseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PhraseArrayOutput)
}

// A phrases containing words and phrase "hints" so that the speech recognition is more likely to recognize them. This can be used to improve the accuracy for specific words and phrases, for example, if specific commands are typically spoken by the user. This can also be used to add additional words to the vocabulary of the recognizer. See [usage limits](https://cloud.google.com/speech-to-text/quotas#content). List items can also include pre-built or custom classes containing groups of words that represent common concepts that occur in natural language. For example, rather than providing a phrase hint for every month of the year (e.g. "i was born in january", "i was born in febuary", ...), use the pre-built `$MONTH` class improves the likelihood of correctly transcribing audio that includes months (e.g. "i was born in $month"). To refer to pre-built classes, use the class' symbol prepended with `$` e.g. `$MONTH`. To refer to custom classes that were defined inline in the request, set the class's `custom_class_id` to a string unique to all class resources and inline classes. Then use the class' id wrapped in $`{...}` e.g. "${my-months}". To refer to custom classes resources, use the class' id wrapped in `${}` (e.g. `${my-months}`).
type PhraseOutput struct{ *pulumi.OutputState }

func (PhraseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Phrase)(nil)).Elem()
}

func (o PhraseOutput) ToPhraseOutput() PhraseOutput {
	return o
}

func (o PhraseOutput) ToPhraseOutputWithContext(ctx context.Context) PhraseOutput {
	return o
}

// Hint Boost. Overrides the boost set at the phrase set level. Positive value will increase the probability that a specific phrase will be recognized over other similar sounding phrases. The higher the boost, the higher the chance of false positive recognition as well. Negative boost values would correspond to anti-biasing. Anti-biasing is not enabled, so negative boost will simply be ignored. Though `boost` can accept a wide range of positive values, most use cases are best served with values between 0 and 20. We recommend using a binary search approach to finding the optimal value for your use case. Speech recognition will skip PhraseSets with a boost value of 0.
func (o PhraseOutput) Boost() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Phrase) *float64 { return v.Boost }).(pulumi.Float64PtrOutput)
}

// The phrase itself.
func (o PhraseOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Phrase) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type PhraseArrayOutput struct{ *pulumi.OutputState }

func (PhraseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Phrase)(nil)).Elem()
}

func (o PhraseArrayOutput) ToPhraseArrayOutput() PhraseArrayOutput {
	return o
}

func (o PhraseArrayOutput) ToPhraseArrayOutputWithContext(ctx context.Context) PhraseArrayOutput {
	return o
}

func (o PhraseArrayOutput) Index(i pulumi.IntInput) PhraseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Phrase {
		return vs[0].([]Phrase)[vs[1].(int)]
	}).(PhraseOutput)
}

// A phrases containing words and phrase "hints" so that the speech recognition is more likely to recognize them. This can be used to improve the accuracy for specific words and phrases, for example, if specific commands are typically spoken by the user. This can also be used to add additional words to the vocabulary of the recognizer. See [usage limits](https://cloud.google.com/speech-to-text/quotas#content). List items can also include pre-built or custom classes containing groups of words that represent common concepts that occur in natural language. For example, rather than providing a phrase hint for every month of the year (e.g. "i was born in january", "i was born in febuary", ...), use the pre-built `$MONTH` class improves the likelihood of correctly transcribing audio that includes months (e.g. "i was born in $month"). To refer to pre-built classes, use the class' symbol prepended with `$` e.g. `$MONTH`. To refer to custom classes that were defined inline in the request, set the class's `custom_class_id` to a string unique to all class resources and inline classes. Then use the class' id wrapped in $`{...}` e.g. "${my-months}". To refer to custom classes resources, use the class' id wrapped in `${}` (e.g. `${my-months}`).
type PhraseResponse struct {
	// Hint Boost. Overrides the boost set at the phrase set level. Positive value will increase the probability that a specific phrase will be recognized over other similar sounding phrases. The higher the boost, the higher the chance of false positive recognition as well. Negative boost values would correspond to anti-biasing. Anti-biasing is not enabled, so negative boost will simply be ignored. Though `boost` can accept a wide range of positive values, most use cases are best served with values between 0 and 20. We recommend using a binary search approach to finding the optimal value for your use case. Speech recognition will skip PhraseSets with a boost value of 0.
	Boost float64 `pulumi:"boost"`
	// The phrase itself.
	Value string `pulumi:"value"`
}

// PhraseResponseInput is an input type that accepts PhraseResponseArgs and PhraseResponseOutput values.
// You can construct a concrete instance of `PhraseResponseInput` via:
//
//          PhraseResponseArgs{...}
type PhraseResponseInput interface {
	pulumi.Input

	ToPhraseResponseOutput() PhraseResponseOutput
	ToPhraseResponseOutputWithContext(context.Context) PhraseResponseOutput
}

// A phrases containing words and phrase "hints" so that the speech recognition is more likely to recognize them. This can be used to improve the accuracy for specific words and phrases, for example, if specific commands are typically spoken by the user. This can also be used to add additional words to the vocabulary of the recognizer. See [usage limits](https://cloud.google.com/speech-to-text/quotas#content). List items can also include pre-built or custom classes containing groups of words that represent common concepts that occur in natural language. For example, rather than providing a phrase hint for every month of the year (e.g. "i was born in january", "i was born in febuary", ...), use the pre-built `$MONTH` class improves the likelihood of correctly transcribing audio that includes months (e.g. "i was born in $month"). To refer to pre-built classes, use the class' symbol prepended with `$` e.g. `$MONTH`. To refer to custom classes that were defined inline in the request, set the class's `custom_class_id` to a string unique to all class resources and inline classes. Then use the class' id wrapped in $`{...}` e.g. "${my-months}". To refer to custom classes resources, use the class' id wrapped in `${}` (e.g. `${my-months}`).
type PhraseResponseArgs struct {
	// Hint Boost. Overrides the boost set at the phrase set level. Positive value will increase the probability that a specific phrase will be recognized over other similar sounding phrases. The higher the boost, the higher the chance of false positive recognition as well. Negative boost values would correspond to anti-biasing. Anti-biasing is not enabled, so negative boost will simply be ignored. Though `boost` can accept a wide range of positive values, most use cases are best served with values between 0 and 20. We recommend using a binary search approach to finding the optimal value for your use case. Speech recognition will skip PhraseSets with a boost value of 0.
	Boost pulumi.Float64Input `pulumi:"boost"`
	// The phrase itself.
	Value pulumi.StringInput `pulumi:"value"`
}

func (PhraseResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PhraseResponse)(nil)).Elem()
}

func (i PhraseResponseArgs) ToPhraseResponseOutput() PhraseResponseOutput {
	return i.ToPhraseResponseOutputWithContext(context.Background())
}

func (i PhraseResponseArgs) ToPhraseResponseOutputWithContext(ctx context.Context) PhraseResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PhraseResponseOutput)
}

// PhraseResponseArrayInput is an input type that accepts PhraseResponseArray and PhraseResponseArrayOutput values.
// You can construct a concrete instance of `PhraseResponseArrayInput` via:
//
//          PhraseResponseArray{ PhraseResponseArgs{...} }
type PhraseResponseArrayInput interface {
	pulumi.Input

	ToPhraseResponseArrayOutput() PhraseResponseArrayOutput
	ToPhraseResponseArrayOutputWithContext(context.Context) PhraseResponseArrayOutput
}

type PhraseResponseArray []PhraseResponseInput

func (PhraseResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PhraseResponse)(nil)).Elem()
}

func (i PhraseResponseArray) ToPhraseResponseArrayOutput() PhraseResponseArrayOutput {
	return i.ToPhraseResponseArrayOutputWithContext(context.Background())
}

func (i PhraseResponseArray) ToPhraseResponseArrayOutputWithContext(ctx context.Context) PhraseResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PhraseResponseArrayOutput)
}

// A phrases containing words and phrase "hints" so that the speech recognition is more likely to recognize them. This can be used to improve the accuracy for specific words and phrases, for example, if specific commands are typically spoken by the user. This can also be used to add additional words to the vocabulary of the recognizer. See [usage limits](https://cloud.google.com/speech-to-text/quotas#content). List items can also include pre-built or custom classes containing groups of words that represent common concepts that occur in natural language. For example, rather than providing a phrase hint for every month of the year (e.g. "i was born in january", "i was born in febuary", ...), use the pre-built `$MONTH` class improves the likelihood of correctly transcribing audio that includes months (e.g. "i was born in $month"). To refer to pre-built classes, use the class' symbol prepended with `$` e.g. `$MONTH`. To refer to custom classes that were defined inline in the request, set the class's `custom_class_id` to a string unique to all class resources and inline classes. Then use the class' id wrapped in $`{...}` e.g. "${my-months}". To refer to custom classes resources, use the class' id wrapped in `${}` (e.g. `${my-months}`).
type PhraseResponseOutput struct{ *pulumi.OutputState }

func (PhraseResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PhraseResponse)(nil)).Elem()
}

func (o PhraseResponseOutput) ToPhraseResponseOutput() PhraseResponseOutput {
	return o
}

func (o PhraseResponseOutput) ToPhraseResponseOutputWithContext(ctx context.Context) PhraseResponseOutput {
	return o
}

// Hint Boost. Overrides the boost set at the phrase set level. Positive value will increase the probability that a specific phrase will be recognized over other similar sounding phrases. The higher the boost, the higher the chance of false positive recognition as well. Negative boost values would correspond to anti-biasing. Anti-biasing is not enabled, so negative boost will simply be ignored. Though `boost` can accept a wide range of positive values, most use cases are best served with values between 0 and 20. We recommend using a binary search approach to finding the optimal value for your use case. Speech recognition will skip PhraseSets with a boost value of 0.
func (o PhraseResponseOutput) Boost() pulumi.Float64Output {
	return o.ApplyT(func(v PhraseResponse) float64 { return v.Boost }).(pulumi.Float64Output)
}

// The phrase itself.
func (o PhraseResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v PhraseResponse) string { return v.Value }).(pulumi.StringOutput)
}

type PhraseResponseArrayOutput struct{ *pulumi.OutputState }

func (PhraseResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PhraseResponse)(nil)).Elem()
}

func (o PhraseResponseArrayOutput) ToPhraseResponseArrayOutput() PhraseResponseArrayOutput {
	return o
}

func (o PhraseResponseArrayOutput) ToPhraseResponseArrayOutputWithContext(ctx context.Context) PhraseResponseArrayOutput {
	return o
}

func (o PhraseResponseArrayOutput) Index(i pulumi.IntInput) PhraseResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PhraseResponse {
		return vs[0].([]PhraseResponse)[vs[1].(int)]
	}).(PhraseResponseOutput)
}

// Provides "hints" to the speech recognizer to favor specific words and phrases in the results.
type PhraseSetType struct {
	// Hint Boost. Positive value will increase the probability that a specific phrase will be recognized over other similar sounding phrases. The higher the boost, the higher the chance of false positive recognition as well. Negative boost values would correspond to anti-biasing. Anti-biasing is not enabled, so negative boost will simply be ignored. Though `boost` can accept a wide range of positive values, most use cases are best served with values between 0 (exclusive) and 20. We recommend using a binary search approach to finding the optimal value for your use case. Speech recognition will skip PhraseSets with a boost value of 0.
	Boost *float64 `pulumi:"boost"`
	// The resource name of the phrase set.
	Name *string `pulumi:"name"`
	// A list of word and phrases.
	Phrases []Phrase `pulumi:"phrases"`
}

// PhraseSetTypeInput is an input type that accepts PhraseSetTypeArgs and PhraseSetTypeOutput values.
// You can construct a concrete instance of `PhraseSetTypeInput` via:
//
//          PhraseSetTypeArgs{...}
type PhraseSetTypeInput interface {
	pulumi.Input

	ToPhraseSetTypeOutput() PhraseSetTypeOutput
	ToPhraseSetTypeOutputWithContext(context.Context) PhraseSetTypeOutput
}

// Provides "hints" to the speech recognizer to favor specific words and phrases in the results.
type PhraseSetTypeArgs struct {
	// Hint Boost. Positive value will increase the probability that a specific phrase will be recognized over other similar sounding phrases. The higher the boost, the higher the chance of false positive recognition as well. Negative boost values would correspond to anti-biasing. Anti-biasing is not enabled, so negative boost will simply be ignored. Though `boost` can accept a wide range of positive values, most use cases are best served with values between 0 (exclusive) and 20. We recommend using a binary search approach to finding the optimal value for your use case. Speech recognition will skip PhraseSets with a boost value of 0.
	Boost pulumi.Float64PtrInput `pulumi:"boost"`
	// The resource name of the phrase set.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// A list of word and phrases.
	Phrases PhraseArrayInput `pulumi:"phrases"`
}

func (PhraseSetTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PhraseSetType)(nil)).Elem()
}

func (i PhraseSetTypeArgs) ToPhraseSetTypeOutput() PhraseSetTypeOutput {
	return i.ToPhraseSetTypeOutputWithContext(context.Background())
}

func (i PhraseSetTypeArgs) ToPhraseSetTypeOutputWithContext(ctx context.Context) PhraseSetTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PhraseSetTypeOutput)
}

func (i PhraseSetTypeArgs) ToPhraseSetTypePtrOutput() PhraseSetTypePtrOutput {
	return i.ToPhraseSetTypePtrOutputWithContext(context.Background())
}

func (i PhraseSetTypeArgs) ToPhraseSetTypePtrOutputWithContext(ctx context.Context) PhraseSetTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PhraseSetTypeOutput).ToPhraseSetTypePtrOutputWithContext(ctx)
}

// PhraseSetTypePtrInput is an input type that accepts PhraseSetTypeArgs, PhraseSetTypePtr and PhraseSetTypePtrOutput values.
// You can construct a concrete instance of `PhraseSetTypePtrInput` via:
//
//          PhraseSetTypeArgs{...}
//
//  or:
//
//          nil
type PhraseSetTypePtrInput interface {
	pulumi.Input

	ToPhraseSetTypePtrOutput() PhraseSetTypePtrOutput
	ToPhraseSetTypePtrOutputWithContext(context.Context) PhraseSetTypePtrOutput
}

type phraseSetTypePtrType PhraseSetTypeArgs

func PhraseSetTypePtr(v *PhraseSetTypeArgs) PhraseSetTypePtrInput {
	return (*phraseSetTypePtrType)(v)
}

func (*phraseSetTypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PhraseSetType)(nil)).Elem()
}

func (i *phraseSetTypePtrType) ToPhraseSetTypePtrOutput() PhraseSetTypePtrOutput {
	return i.ToPhraseSetTypePtrOutputWithContext(context.Background())
}

func (i *phraseSetTypePtrType) ToPhraseSetTypePtrOutputWithContext(ctx context.Context) PhraseSetTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PhraseSetTypePtrOutput)
}

// Provides "hints" to the speech recognizer to favor specific words and phrases in the results.
type PhraseSetTypeOutput struct{ *pulumi.OutputState }

func (PhraseSetTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PhraseSetType)(nil)).Elem()
}

func (o PhraseSetTypeOutput) ToPhraseSetTypeOutput() PhraseSetTypeOutput {
	return o
}

func (o PhraseSetTypeOutput) ToPhraseSetTypeOutputWithContext(ctx context.Context) PhraseSetTypeOutput {
	return o
}

func (o PhraseSetTypeOutput) ToPhraseSetTypePtrOutput() PhraseSetTypePtrOutput {
	return o.ToPhraseSetTypePtrOutputWithContext(context.Background())
}

func (o PhraseSetTypeOutput) ToPhraseSetTypePtrOutputWithContext(ctx context.Context) PhraseSetTypePtrOutput {
	return o.ApplyT(func(v PhraseSetType) *PhraseSetType {
		return &v
	}).(PhraseSetTypePtrOutput)
}

// Hint Boost. Positive value will increase the probability that a specific phrase will be recognized over other similar sounding phrases. The higher the boost, the higher the chance of false positive recognition as well. Negative boost values would correspond to anti-biasing. Anti-biasing is not enabled, so negative boost will simply be ignored. Though `boost` can accept a wide range of positive values, most use cases are best served with values between 0 (exclusive) and 20. We recommend using a binary search approach to finding the optimal value for your use case. Speech recognition will skip PhraseSets with a boost value of 0.
func (o PhraseSetTypeOutput) Boost() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PhraseSetType) *float64 { return v.Boost }).(pulumi.Float64PtrOutput)
}

// The resource name of the phrase set.
func (o PhraseSetTypeOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PhraseSetType) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// A list of word and phrases.
func (o PhraseSetTypeOutput) Phrases() PhraseArrayOutput {
	return o.ApplyT(func(v PhraseSetType) []Phrase { return v.Phrases }).(PhraseArrayOutput)
}

type PhraseSetTypePtrOutput struct{ *pulumi.OutputState }

func (PhraseSetTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PhraseSetType)(nil)).Elem()
}

func (o PhraseSetTypePtrOutput) ToPhraseSetTypePtrOutput() PhraseSetTypePtrOutput {
	return o
}

func (o PhraseSetTypePtrOutput) ToPhraseSetTypePtrOutputWithContext(ctx context.Context) PhraseSetTypePtrOutput {
	return o
}

func (o PhraseSetTypePtrOutput) Elem() PhraseSetTypeOutput {
	return o.ApplyT(func(v *PhraseSetType) PhraseSetType { return *v }).(PhraseSetTypeOutput)
}

// Hint Boost. Positive value will increase the probability that a specific phrase will be recognized over other similar sounding phrases. The higher the boost, the higher the chance of false positive recognition as well. Negative boost values would correspond to anti-biasing. Anti-biasing is not enabled, so negative boost will simply be ignored. Though `boost` can accept a wide range of positive values, most use cases are best served with values between 0 (exclusive) and 20. We recommend using a binary search approach to finding the optimal value for your use case. Speech recognition will skip PhraseSets with a boost value of 0.
func (o PhraseSetTypePtrOutput) Boost() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PhraseSetType) *float64 {
		if v == nil {
			return nil
		}
		return v.Boost
	}).(pulumi.Float64PtrOutput)
}

// The resource name of the phrase set.
func (o PhraseSetTypePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PhraseSetType) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// A list of word and phrases.
func (o PhraseSetTypePtrOutput) Phrases() PhraseArrayOutput {
	return o.ApplyT(func(v *PhraseSetType) []Phrase {
		if v == nil {
			return nil
		}
		return v.Phrases
	}).(PhraseArrayOutput)
}

func init() {
	pulumi.RegisterOutputType(ClassItemOutput{})
	pulumi.RegisterOutputType(ClassItemArrayOutput{})
	pulumi.RegisterOutputType(ClassItemResponseOutput{})
	pulumi.RegisterOutputType(ClassItemResponseArrayOutput{})
	pulumi.RegisterOutputType(CustomClassTypeOutput{})
	pulumi.RegisterOutputType(CustomClassTypePtrOutput{})
	pulumi.RegisterOutputType(PhraseOutput{})
	pulumi.RegisterOutputType(PhraseArrayOutput{})
	pulumi.RegisterOutputType(PhraseResponseOutput{})
	pulumi.RegisterOutputType(PhraseResponseArrayOutput{})
	pulumi.RegisterOutputType(PhraseSetTypeOutput{})
	pulumi.RegisterOutputType(PhraseSetTypePtrOutput{})
}

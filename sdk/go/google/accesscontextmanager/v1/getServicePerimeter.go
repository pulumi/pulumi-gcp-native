// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Gets a service perimeter based on the resource name.
func LookupServicePerimeter(ctx *pulumi.Context, args *LookupServicePerimeterArgs, opts ...pulumi.InvokeOption) (*LookupServicePerimeterResult, error) {
	opts = internal.PkgInvokeDefaultOpts(opts)
	var rv LookupServicePerimeterResult
	err := ctx.Invoke("google-native:accesscontextmanager/v1:getServicePerimeter", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

type LookupServicePerimeterArgs struct {
	AccessPolicyId     string `pulumi:"accessPolicyId"`
	ServicePerimeterId string `pulumi:"servicePerimeterId"`
}

type LookupServicePerimeterResult struct {
	// Description of the `ServicePerimeter` and its use. Does not affect behavior.
	Description string `pulumi:"description"`
	// Resource name for the `ServicePerimeter`. Format: `accessPolicies/{access_policy}/servicePerimeters/{service_perimeter}`. The `service_perimeter` component must begin with a letter, followed by alphanumeric characters or `_`. After you create a `ServicePerimeter`, you cannot change its `name`.
	Name string `pulumi:"name"`
	// Perimeter type indicator. A single project or VPC network is allowed to be a member of single regular perimeter, but multiple service perimeter bridges. A project cannot be a included in a perimeter bridge without being included in regular perimeter. For perimeter bridges, the restricted service list as well as access level lists must be empty.
	PerimeterType string `pulumi:"perimeterType"`
	// Proposed (or dry run) ServicePerimeter configuration. This configuration allows to specify and test ServicePerimeter configuration without enforcing actual access restrictions. Only allowed to be set when the "use_explicit_dry_run_spec" flag is set.
	Spec ServicePerimeterConfigResponse `pulumi:"spec"`
	// Current ServicePerimeter configuration. Specifies sets of resources, restricted services and access levels that determine perimeter content and boundaries.
	Status ServicePerimeterConfigResponse `pulumi:"status"`
	// Human readable title. Must be unique within the Policy.
	Title string `pulumi:"title"`
	// Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists for all Service Perimeters, and that spec is identical to the status for those Service Perimeters. When this flag is set, it inhibits the generation of the implicit spec, thereby allowing the user to explicitly provide a configuration ("spec") to use in a dry-run version of the Service Perimeter. This allows the user to test changes to the enforced config ("status") without actually enforcing them. This testing is done through analyzing the differences between currently enforced and suggested restrictions. use_explicit_dry_run_spec must bet set to True if any of the fields in the spec are set to non-default values.
	UseExplicitDryRunSpec bool `pulumi:"useExplicitDryRunSpec"`
}

func LookupServicePerimeterOutput(ctx *pulumi.Context, args LookupServicePerimeterOutputArgs, opts ...pulumi.InvokeOption) LookupServicePerimeterResultOutput {
	return pulumi.ToOutputWithContext(context.Background(), args).
		ApplyT(func(v interface{}) (LookupServicePerimeterResult, error) {
			args := v.(LookupServicePerimeterArgs)
			r, err := LookupServicePerimeter(ctx, &args, opts...)
			var s LookupServicePerimeterResult
			if r != nil {
				s = *r
			}
			return s, err
		}).(LookupServicePerimeterResultOutput)
}

type LookupServicePerimeterOutputArgs struct {
	AccessPolicyId     pulumi.StringInput `pulumi:"accessPolicyId"`
	ServicePerimeterId pulumi.StringInput `pulumi:"servicePerimeterId"`
}

func (LookupServicePerimeterOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupServicePerimeterArgs)(nil)).Elem()
}

type LookupServicePerimeterResultOutput struct{ *pulumi.OutputState }

func (LookupServicePerimeterResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupServicePerimeterResult)(nil)).Elem()
}

func (o LookupServicePerimeterResultOutput) ToLookupServicePerimeterResultOutput() LookupServicePerimeterResultOutput {
	return o
}

func (o LookupServicePerimeterResultOutput) ToLookupServicePerimeterResultOutputWithContext(ctx context.Context) LookupServicePerimeterResultOutput {
	return o
}

// Description of the `ServicePerimeter` and its use. Does not affect behavior.
func (o LookupServicePerimeterResultOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v LookupServicePerimeterResult) string { return v.Description }).(pulumi.StringOutput)
}

// Resource name for the `ServicePerimeter`. Format: `accessPolicies/{access_policy}/servicePerimeters/{service_perimeter}`. The `service_perimeter` component must begin with a letter, followed by alphanumeric characters or `_`. After you create a `ServicePerimeter`, you cannot change its `name`.
func (o LookupServicePerimeterResultOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v LookupServicePerimeterResult) string { return v.Name }).(pulumi.StringOutput)
}

// Perimeter type indicator. A single project or VPC network is allowed to be a member of single regular perimeter, but multiple service perimeter bridges. A project cannot be a included in a perimeter bridge without being included in regular perimeter. For perimeter bridges, the restricted service list as well as access level lists must be empty.
func (o LookupServicePerimeterResultOutput) PerimeterType() pulumi.StringOutput {
	return o.ApplyT(func(v LookupServicePerimeterResult) string { return v.PerimeterType }).(pulumi.StringOutput)
}

// Proposed (or dry run) ServicePerimeter configuration. This configuration allows to specify and test ServicePerimeter configuration without enforcing actual access restrictions. Only allowed to be set when the "use_explicit_dry_run_spec" flag is set.
func (o LookupServicePerimeterResultOutput) Spec() ServicePerimeterConfigResponseOutput {
	return o.ApplyT(func(v LookupServicePerimeterResult) ServicePerimeterConfigResponse { return v.Spec }).(ServicePerimeterConfigResponseOutput)
}

// Current ServicePerimeter configuration. Specifies sets of resources, restricted services and access levels that determine perimeter content and boundaries.
func (o LookupServicePerimeterResultOutput) Status() ServicePerimeterConfigResponseOutput {
	return o.ApplyT(func(v LookupServicePerimeterResult) ServicePerimeterConfigResponse { return v.Status }).(ServicePerimeterConfigResponseOutput)
}

// Human readable title. Must be unique within the Policy.
func (o LookupServicePerimeterResultOutput) Title() pulumi.StringOutput {
	return o.ApplyT(func(v LookupServicePerimeterResult) string { return v.Title }).(pulumi.StringOutput)
}

// Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists for all Service Perimeters, and that spec is identical to the status for those Service Perimeters. When this flag is set, it inhibits the generation of the implicit spec, thereby allowing the user to explicitly provide a configuration ("spec") to use in a dry-run version of the Service Perimeter. This allows the user to test changes to the enforced config ("status") without actually enforcing them. This testing is done through analyzing the differences between currently enforced and suggested restrictions. use_explicit_dry_run_spec must bet set to True if any of the fields in the spec are set to non-default values.
func (o LookupServicePerimeterResultOutput) UseExplicitDryRunSpec() pulumi.BoolOutput {
	return o.ApplyT(func(v LookupServicePerimeterResult) bool { return v.UseExplicitDryRunSpec }).(pulumi.BoolOutput)
}

func init() {
	pulumi.RegisterOutputType(LookupServicePerimeterResultOutput{})
}

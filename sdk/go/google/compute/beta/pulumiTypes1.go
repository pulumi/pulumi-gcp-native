// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package beta

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type StatefulPolicyPreservedStateNetworkIpResponse struct {
	// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
	AutoDelete string `pulumi:"autoDelete"`
}

type StatefulPolicyPreservedStateNetworkIpResponseOutput struct{ *pulumi.OutputState }

func (StatefulPolicyPreservedStateNetworkIpResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulPolicyPreservedStateNetworkIpResponse)(nil)).Elem()
}

func (o StatefulPolicyPreservedStateNetworkIpResponseOutput) ToStatefulPolicyPreservedStateNetworkIpResponseOutput() StatefulPolicyPreservedStateNetworkIpResponseOutput {
	return o
}

func (o StatefulPolicyPreservedStateNetworkIpResponseOutput) ToStatefulPolicyPreservedStateNetworkIpResponseOutputWithContext(ctx context.Context) StatefulPolicyPreservedStateNetworkIpResponseOutput {
	return o
}

// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
func (o StatefulPolicyPreservedStateNetworkIpResponseOutput) AutoDelete() pulumi.StringOutput {
	return o.ApplyT(func(v StatefulPolicyPreservedStateNetworkIpResponse) string { return v.AutoDelete }).(pulumi.StringOutput)
}

// Configuration of preserved resources.
type StatefulPolicyPreservedStateResponse struct {
	// Disks created on the instances that will be preserved on instance delete, update, etc. This map is keyed with the device names of the disks.
	Disks StatefulPolicyPreservedStateDiskDeviceResponse `pulumi:"disks"`
	// External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name.
	ExternalIPs StatefulPolicyPreservedStateNetworkIpResponse `pulumi:"externalIPs"`
	// Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name.
	InternalIPs StatefulPolicyPreservedStateNetworkIpResponse `pulumi:"internalIPs"`
}

// Configuration of preserved resources.
type StatefulPolicyPreservedStateResponseOutput struct{ *pulumi.OutputState }

func (StatefulPolicyPreservedStateResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulPolicyPreservedStateResponse)(nil)).Elem()
}

func (o StatefulPolicyPreservedStateResponseOutput) ToStatefulPolicyPreservedStateResponseOutput() StatefulPolicyPreservedStateResponseOutput {
	return o
}

func (o StatefulPolicyPreservedStateResponseOutput) ToStatefulPolicyPreservedStateResponseOutputWithContext(ctx context.Context) StatefulPolicyPreservedStateResponseOutput {
	return o
}

// Disks created on the instances that will be preserved on instance delete, update, etc. This map is keyed with the device names of the disks.
func (o StatefulPolicyPreservedStateResponseOutput) Disks() StatefulPolicyPreservedStateDiskDeviceResponseOutput {
	return o.ApplyT(func(v StatefulPolicyPreservedStateResponse) StatefulPolicyPreservedStateDiskDeviceResponse {
		return v.Disks
	}).(StatefulPolicyPreservedStateDiskDeviceResponseOutput)
}

// External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name.
func (o StatefulPolicyPreservedStateResponseOutput) ExternalIPs() StatefulPolicyPreservedStateNetworkIpResponseOutput {
	return o.ApplyT(func(v StatefulPolicyPreservedStateResponse) StatefulPolicyPreservedStateNetworkIpResponse {
		return v.ExternalIPs
	}).(StatefulPolicyPreservedStateNetworkIpResponseOutput)
}

// Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name.
func (o StatefulPolicyPreservedStateResponseOutput) InternalIPs() StatefulPolicyPreservedStateNetworkIpResponseOutput {
	return o.ApplyT(func(v StatefulPolicyPreservedStateResponse) StatefulPolicyPreservedStateNetworkIpResponse {
		return v.InternalIPs
	}).(StatefulPolicyPreservedStateNetworkIpResponseOutput)
}

type StatefulPolicyResponse struct {
	PreservedState StatefulPolicyPreservedStateResponse `pulumi:"preservedState"`
}

type StatefulPolicyResponseOutput struct{ *pulumi.OutputState }

func (StatefulPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatefulPolicyResponse)(nil)).Elem()
}

func (o StatefulPolicyResponseOutput) ToStatefulPolicyResponseOutput() StatefulPolicyResponseOutput {
	return o
}

func (o StatefulPolicyResponseOutput) ToStatefulPolicyResponseOutputWithContext(ctx context.Context) StatefulPolicyResponseOutput {
	return o
}

func (o StatefulPolicyResponseOutput) PreservedState() StatefulPolicyPreservedStateResponseOutput {
	return o.ApplyT(func(v StatefulPolicyResponse) StatefulPolicyPreservedStateResponse { return v.PreservedState }).(StatefulPolicyPreservedStateResponseOutput)
}

// The available logging options for this subnetwork.
type SubnetworkLogConfig struct {
	// Can only be specified if VPC flow logging for this subnetwork is enabled. Toggles the aggregation interval for collecting flow logs. Increasing the interval time will reduce the amount of generated flow logs for long lasting connections. Default is an interval of 5 seconds per connection.
	AggregationInterval *SubnetworkLogConfigAggregationInterval `pulumi:"aggregationInterval"`
	// Whether to enable flow logging for this subnetwork. If this field is not explicitly set, it will not appear in get listings. If not set the default behavior is determined by the org policy, if there is no org policy specified, then it will default to disabled. Flow logging isn't supported if the subnet purpose field is set to REGIONAL_MANAGED_PROXY.
	Enable *bool `pulumi:"enable"`
	// Can only be specified if VPC flow logs for this subnetwork is enabled. The filter expression is used to define which VPC flow logs should be exported to Cloud Logging.
	FilterExpr *string `pulumi:"filterExpr"`
	// Can only be specified if VPC flow logging for this subnetwork is enabled. The value of the field must be in [0, 1]. Set the sampling rate of VPC flow logs within the subnetwork where 1.0 means all collected logs are reported and 0.0 means no logs are reported. Default is 0.5 unless otherwise specified by the org policy, which means half of all collected logs are reported.
	FlowSampling *float64 `pulumi:"flowSampling"`
	// Can only be specified if VPC flow logs for this subnetwork is enabled. Configures whether all, none or a subset of metadata fields should be added to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
	Metadata *SubnetworkLogConfigMetadata `pulumi:"metadata"`
	// Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" was set to CUSTOM_METADATA.
	MetadataFields []string `pulumi:"metadataFields"`
}

// SubnetworkLogConfigInput is an input type that accepts SubnetworkLogConfigArgs and SubnetworkLogConfigOutput values.
// You can construct a concrete instance of `SubnetworkLogConfigInput` via:
//
//	SubnetworkLogConfigArgs{...}
type SubnetworkLogConfigInput interface {
	pulumi.Input

	ToSubnetworkLogConfigOutput() SubnetworkLogConfigOutput
	ToSubnetworkLogConfigOutputWithContext(context.Context) SubnetworkLogConfigOutput
}

// The available logging options for this subnetwork.
type SubnetworkLogConfigArgs struct {
	// Can only be specified if VPC flow logging for this subnetwork is enabled. Toggles the aggregation interval for collecting flow logs. Increasing the interval time will reduce the amount of generated flow logs for long lasting connections. Default is an interval of 5 seconds per connection.
	AggregationInterval SubnetworkLogConfigAggregationIntervalPtrInput `pulumi:"aggregationInterval"`
	// Whether to enable flow logging for this subnetwork. If this field is not explicitly set, it will not appear in get listings. If not set the default behavior is determined by the org policy, if there is no org policy specified, then it will default to disabled. Flow logging isn't supported if the subnet purpose field is set to REGIONAL_MANAGED_PROXY.
	Enable pulumi.BoolPtrInput `pulumi:"enable"`
	// Can only be specified if VPC flow logs for this subnetwork is enabled. The filter expression is used to define which VPC flow logs should be exported to Cloud Logging.
	FilterExpr pulumi.StringPtrInput `pulumi:"filterExpr"`
	// Can only be specified if VPC flow logging for this subnetwork is enabled. The value of the field must be in [0, 1]. Set the sampling rate of VPC flow logs within the subnetwork where 1.0 means all collected logs are reported and 0.0 means no logs are reported. Default is 0.5 unless otherwise specified by the org policy, which means half of all collected logs are reported.
	FlowSampling pulumi.Float64PtrInput `pulumi:"flowSampling"`
	// Can only be specified if VPC flow logs for this subnetwork is enabled. Configures whether all, none or a subset of metadata fields should be added to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
	Metadata SubnetworkLogConfigMetadataPtrInput `pulumi:"metadata"`
	// Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" was set to CUSTOM_METADATA.
	MetadataFields pulumi.StringArrayInput `pulumi:"metadataFields"`
}

func (SubnetworkLogConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubnetworkLogConfig)(nil)).Elem()
}

func (i SubnetworkLogConfigArgs) ToSubnetworkLogConfigOutput() SubnetworkLogConfigOutput {
	return i.ToSubnetworkLogConfigOutputWithContext(context.Background())
}

func (i SubnetworkLogConfigArgs) ToSubnetworkLogConfigOutputWithContext(ctx context.Context) SubnetworkLogConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubnetworkLogConfigOutput)
}

func (i SubnetworkLogConfigArgs) ToSubnetworkLogConfigPtrOutput() SubnetworkLogConfigPtrOutput {
	return i.ToSubnetworkLogConfigPtrOutputWithContext(context.Background())
}

func (i SubnetworkLogConfigArgs) ToSubnetworkLogConfigPtrOutputWithContext(ctx context.Context) SubnetworkLogConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubnetworkLogConfigOutput).ToSubnetworkLogConfigPtrOutputWithContext(ctx)
}

// SubnetworkLogConfigPtrInput is an input type that accepts SubnetworkLogConfigArgs, SubnetworkLogConfigPtr and SubnetworkLogConfigPtrOutput values.
// You can construct a concrete instance of `SubnetworkLogConfigPtrInput` via:
//
//	        SubnetworkLogConfigArgs{...}
//
//	or:
//
//	        nil
type SubnetworkLogConfigPtrInput interface {
	pulumi.Input

	ToSubnetworkLogConfigPtrOutput() SubnetworkLogConfigPtrOutput
	ToSubnetworkLogConfigPtrOutputWithContext(context.Context) SubnetworkLogConfigPtrOutput
}

type subnetworkLogConfigPtrType SubnetworkLogConfigArgs

func SubnetworkLogConfigPtr(v *SubnetworkLogConfigArgs) SubnetworkLogConfigPtrInput {
	return (*subnetworkLogConfigPtrType)(v)
}

func (*subnetworkLogConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubnetworkLogConfig)(nil)).Elem()
}

func (i *subnetworkLogConfigPtrType) ToSubnetworkLogConfigPtrOutput() SubnetworkLogConfigPtrOutput {
	return i.ToSubnetworkLogConfigPtrOutputWithContext(context.Background())
}

func (i *subnetworkLogConfigPtrType) ToSubnetworkLogConfigPtrOutputWithContext(ctx context.Context) SubnetworkLogConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubnetworkLogConfigPtrOutput)
}

// The available logging options for this subnetwork.
type SubnetworkLogConfigOutput struct{ *pulumi.OutputState }

func (SubnetworkLogConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubnetworkLogConfig)(nil)).Elem()
}

func (o SubnetworkLogConfigOutput) ToSubnetworkLogConfigOutput() SubnetworkLogConfigOutput {
	return o
}

func (o SubnetworkLogConfigOutput) ToSubnetworkLogConfigOutputWithContext(ctx context.Context) SubnetworkLogConfigOutput {
	return o
}

func (o SubnetworkLogConfigOutput) ToSubnetworkLogConfigPtrOutput() SubnetworkLogConfigPtrOutput {
	return o.ToSubnetworkLogConfigPtrOutputWithContext(context.Background())
}

func (o SubnetworkLogConfigOutput) ToSubnetworkLogConfigPtrOutputWithContext(ctx context.Context) SubnetworkLogConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SubnetworkLogConfig) *SubnetworkLogConfig {
		return &v
	}).(SubnetworkLogConfigPtrOutput)
}

// Can only be specified if VPC flow logging for this subnetwork is enabled. Toggles the aggregation interval for collecting flow logs. Increasing the interval time will reduce the amount of generated flow logs for long lasting connections. Default is an interval of 5 seconds per connection.
func (o SubnetworkLogConfigOutput) AggregationInterval() SubnetworkLogConfigAggregationIntervalPtrOutput {
	return o.ApplyT(func(v SubnetworkLogConfig) *SubnetworkLogConfigAggregationInterval { return v.AggregationInterval }).(SubnetworkLogConfigAggregationIntervalPtrOutput)
}

// Whether to enable flow logging for this subnetwork. If this field is not explicitly set, it will not appear in get listings. If not set the default behavior is determined by the org policy, if there is no org policy specified, then it will default to disabled. Flow logging isn't supported if the subnet purpose field is set to REGIONAL_MANAGED_PROXY.
func (o SubnetworkLogConfigOutput) Enable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SubnetworkLogConfig) *bool { return v.Enable }).(pulumi.BoolPtrOutput)
}

// Can only be specified if VPC flow logs for this subnetwork is enabled. The filter expression is used to define which VPC flow logs should be exported to Cloud Logging.
func (o SubnetworkLogConfigOutput) FilterExpr() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubnetworkLogConfig) *string { return v.FilterExpr }).(pulumi.StringPtrOutput)
}

// Can only be specified if VPC flow logging for this subnetwork is enabled. The value of the field must be in [0, 1]. Set the sampling rate of VPC flow logs within the subnetwork where 1.0 means all collected logs are reported and 0.0 means no logs are reported. Default is 0.5 unless otherwise specified by the org policy, which means half of all collected logs are reported.
func (o SubnetworkLogConfigOutput) FlowSampling() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v SubnetworkLogConfig) *float64 { return v.FlowSampling }).(pulumi.Float64PtrOutput)
}

// Can only be specified if VPC flow logs for this subnetwork is enabled. Configures whether all, none or a subset of metadata fields should be added to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
func (o SubnetworkLogConfigOutput) Metadata() SubnetworkLogConfigMetadataPtrOutput {
	return o.ApplyT(func(v SubnetworkLogConfig) *SubnetworkLogConfigMetadata { return v.Metadata }).(SubnetworkLogConfigMetadataPtrOutput)
}

// Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" was set to CUSTOM_METADATA.
func (o SubnetworkLogConfigOutput) MetadataFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v SubnetworkLogConfig) []string { return v.MetadataFields }).(pulumi.StringArrayOutput)
}

type SubnetworkLogConfigPtrOutput struct{ *pulumi.OutputState }

func (SubnetworkLogConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubnetworkLogConfig)(nil)).Elem()
}

func (o SubnetworkLogConfigPtrOutput) ToSubnetworkLogConfigPtrOutput() SubnetworkLogConfigPtrOutput {
	return o
}

func (o SubnetworkLogConfigPtrOutput) ToSubnetworkLogConfigPtrOutputWithContext(ctx context.Context) SubnetworkLogConfigPtrOutput {
	return o
}

func (o SubnetworkLogConfigPtrOutput) Elem() SubnetworkLogConfigOutput {
	return o.ApplyT(func(v *SubnetworkLogConfig) SubnetworkLogConfig {
		if v != nil {
			return *v
		}
		var ret SubnetworkLogConfig
		return ret
	}).(SubnetworkLogConfigOutput)
}

// Can only be specified if VPC flow logging for this subnetwork is enabled. Toggles the aggregation interval for collecting flow logs. Increasing the interval time will reduce the amount of generated flow logs for long lasting connections. Default is an interval of 5 seconds per connection.
func (o SubnetworkLogConfigPtrOutput) AggregationInterval() SubnetworkLogConfigAggregationIntervalPtrOutput {
	return o.ApplyT(func(v *SubnetworkLogConfig) *SubnetworkLogConfigAggregationInterval {
		if v == nil {
			return nil
		}
		return v.AggregationInterval
	}).(SubnetworkLogConfigAggregationIntervalPtrOutput)
}

// Whether to enable flow logging for this subnetwork. If this field is not explicitly set, it will not appear in get listings. If not set the default behavior is determined by the org policy, if there is no org policy specified, then it will default to disabled. Flow logging isn't supported if the subnet purpose field is set to REGIONAL_MANAGED_PROXY.
func (o SubnetworkLogConfigPtrOutput) Enable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SubnetworkLogConfig) *bool {
		if v == nil {
			return nil
		}
		return v.Enable
	}).(pulumi.BoolPtrOutput)
}

// Can only be specified if VPC flow logs for this subnetwork is enabled. The filter expression is used to define which VPC flow logs should be exported to Cloud Logging.
func (o SubnetworkLogConfigPtrOutput) FilterExpr() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubnetworkLogConfig) *string {
		if v == nil {
			return nil
		}
		return v.FilterExpr
	}).(pulumi.StringPtrOutput)
}

// Can only be specified if VPC flow logging for this subnetwork is enabled. The value of the field must be in [0, 1]. Set the sampling rate of VPC flow logs within the subnetwork where 1.0 means all collected logs are reported and 0.0 means no logs are reported. Default is 0.5 unless otherwise specified by the org policy, which means half of all collected logs are reported.
func (o SubnetworkLogConfigPtrOutput) FlowSampling() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *SubnetworkLogConfig) *float64 {
		if v == nil {
			return nil
		}
		return v.FlowSampling
	}).(pulumi.Float64PtrOutput)
}

// Can only be specified if VPC flow logs for this subnetwork is enabled. Configures whether all, none or a subset of metadata fields should be added to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
func (o SubnetworkLogConfigPtrOutput) Metadata() SubnetworkLogConfigMetadataPtrOutput {
	return o.ApplyT(func(v *SubnetworkLogConfig) *SubnetworkLogConfigMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(SubnetworkLogConfigMetadataPtrOutput)
}

// Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" was set to CUSTOM_METADATA.
func (o SubnetworkLogConfigPtrOutput) MetadataFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SubnetworkLogConfig) []string {
		if v == nil {
			return nil
		}
		return v.MetadataFields
	}).(pulumi.StringArrayOutput)
}

// The available logging options for this subnetwork.
type SubnetworkLogConfigResponse struct {
	// Can only be specified if VPC flow logging for this subnetwork is enabled. Toggles the aggregation interval for collecting flow logs. Increasing the interval time will reduce the amount of generated flow logs for long lasting connections. Default is an interval of 5 seconds per connection.
	AggregationInterval string `pulumi:"aggregationInterval"`
	// Whether to enable flow logging for this subnetwork. If this field is not explicitly set, it will not appear in get listings. If not set the default behavior is determined by the org policy, if there is no org policy specified, then it will default to disabled. Flow logging isn't supported if the subnet purpose field is set to REGIONAL_MANAGED_PROXY.
	Enable bool `pulumi:"enable"`
	// Can only be specified if VPC flow logs for this subnetwork is enabled. The filter expression is used to define which VPC flow logs should be exported to Cloud Logging.
	FilterExpr string `pulumi:"filterExpr"`
	// Can only be specified if VPC flow logging for this subnetwork is enabled. The value of the field must be in [0, 1]. Set the sampling rate of VPC flow logs within the subnetwork where 1.0 means all collected logs are reported and 0.0 means no logs are reported. Default is 0.5 unless otherwise specified by the org policy, which means half of all collected logs are reported.
	FlowSampling float64 `pulumi:"flowSampling"`
	// Can only be specified if VPC flow logs for this subnetwork is enabled. Configures whether all, none or a subset of metadata fields should be added to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
	Metadata string `pulumi:"metadata"`
	// Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" was set to CUSTOM_METADATA.
	MetadataFields []string `pulumi:"metadataFields"`
}

// The available logging options for this subnetwork.
type SubnetworkLogConfigResponseOutput struct{ *pulumi.OutputState }

func (SubnetworkLogConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubnetworkLogConfigResponse)(nil)).Elem()
}

func (o SubnetworkLogConfigResponseOutput) ToSubnetworkLogConfigResponseOutput() SubnetworkLogConfigResponseOutput {
	return o
}

func (o SubnetworkLogConfigResponseOutput) ToSubnetworkLogConfigResponseOutputWithContext(ctx context.Context) SubnetworkLogConfigResponseOutput {
	return o
}

// Can only be specified if VPC flow logging for this subnetwork is enabled. Toggles the aggregation interval for collecting flow logs. Increasing the interval time will reduce the amount of generated flow logs for long lasting connections. Default is an interval of 5 seconds per connection.
func (o SubnetworkLogConfigResponseOutput) AggregationInterval() pulumi.StringOutput {
	return o.ApplyT(func(v SubnetworkLogConfigResponse) string { return v.AggregationInterval }).(pulumi.StringOutput)
}

// Whether to enable flow logging for this subnetwork. If this field is not explicitly set, it will not appear in get listings. If not set the default behavior is determined by the org policy, if there is no org policy specified, then it will default to disabled. Flow logging isn't supported if the subnet purpose field is set to REGIONAL_MANAGED_PROXY.
func (o SubnetworkLogConfigResponseOutput) Enable() pulumi.BoolOutput {
	return o.ApplyT(func(v SubnetworkLogConfigResponse) bool { return v.Enable }).(pulumi.BoolOutput)
}

// Can only be specified if VPC flow logs for this subnetwork is enabled. The filter expression is used to define which VPC flow logs should be exported to Cloud Logging.
func (o SubnetworkLogConfigResponseOutput) FilterExpr() pulumi.StringOutput {
	return o.ApplyT(func(v SubnetworkLogConfigResponse) string { return v.FilterExpr }).(pulumi.StringOutput)
}

// Can only be specified if VPC flow logging for this subnetwork is enabled. The value of the field must be in [0, 1]. Set the sampling rate of VPC flow logs within the subnetwork where 1.0 means all collected logs are reported and 0.0 means no logs are reported. Default is 0.5 unless otherwise specified by the org policy, which means half of all collected logs are reported.
func (o SubnetworkLogConfigResponseOutput) FlowSampling() pulumi.Float64Output {
	return o.ApplyT(func(v SubnetworkLogConfigResponse) float64 { return v.FlowSampling }).(pulumi.Float64Output)
}

// Can only be specified if VPC flow logs for this subnetwork is enabled. Configures whether all, none or a subset of metadata fields should be added to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
func (o SubnetworkLogConfigResponseOutput) Metadata() pulumi.StringOutput {
	return o.ApplyT(func(v SubnetworkLogConfigResponse) string { return v.Metadata }).(pulumi.StringOutput)
}

// Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" was set to CUSTOM_METADATA.
func (o SubnetworkLogConfigResponseOutput) MetadataFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v SubnetworkLogConfigResponse) []string { return v.MetadataFields }).(pulumi.StringArrayOutput)
}

// Represents a secondary IP range of a subnetwork.
type SubnetworkSecondaryRange struct {
	// The range of IP addresses belonging to this subnetwork secondary range. Provide this property when you create the subnetwork. Ranges must be unique and non-overlapping with all primary and secondary IP ranges within a network. Only IPv4 is supported. The range can be any range listed in the Valid ranges list.
	IpCidrRange *string `pulumi:"ipCidrRange"`
	// The name associated with this subnetwork secondary range, used when adding an alias IP range to a VM instance. The name must be 1-63 characters long, and comply with RFC1035. The name must be unique within the subnetwork.
	RangeName *string `pulumi:"rangeName"`
	// The URL of the reserved internal range.
	ReservedInternalRange *string `pulumi:"reservedInternalRange"`
}

// SubnetworkSecondaryRangeInput is an input type that accepts SubnetworkSecondaryRangeArgs and SubnetworkSecondaryRangeOutput values.
// You can construct a concrete instance of `SubnetworkSecondaryRangeInput` via:
//
//	SubnetworkSecondaryRangeArgs{...}
type SubnetworkSecondaryRangeInput interface {
	pulumi.Input

	ToSubnetworkSecondaryRangeOutput() SubnetworkSecondaryRangeOutput
	ToSubnetworkSecondaryRangeOutputWithContext(context.Context) SubnetworkSecondaryRangeOutput
}

// Represents a secondary IP range of a subnetwork.
type SubnetworkSecondaryRangeArgs struct {
	// The range of IP addresses belonging to this subnetwork secondary range. Provide this property when you create the subnetwork. Ranges must be unique and non-overlapping with all primary and secondary IP ranges within a network. Only IPv4 is supported. The range can be any range listed in the Valid ranges list.
	IpCidrRange pulumi.StringPtrInput `pulumi:"ipCidrRange"`
	// The name associated with this subnetwork secondary range, used when adding an alias IP range to a VM instance. The name must be 1-63 characters long, and comply with RFC1035. The name must be unique within the subnetwork.
	RangeName pulumi.StringPtrInput `pulumi:"rangeName"`
	// The URL of the reserved internal range.
	ReservedInternalRange pulumi.StringPtrInput `pulumi:"reservedInternalRange"`
}

func (SubnetworkSecondaryRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubnetworkSecondaryRange)(nil)).Elem()
}

func (i SubnetworkSecondaryRangeArgs) ToSubnetworkSecondaryRangeOutput() SubnetworkSecondaryRangeOutput {
	return i.ToSubnetworkSecondaryRangeOutputWithContext(context.Background())
}

func (i SubnetworkSecondaryRangeArgs) ToSubnetworkSecondaryRangeOutputWithContext(ctx context.Context) SubnetworkSecondaryRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubnetworkSecondaryRangeOutput)
}

// SubnetworkSecondaryRangeArrayInput is an input type that accepts SubnetworkSecondaryRangeArray and SubnetworkSecondaryRangeArrayOutput values.
// You can construct a concrete instance of `SubnetworkSecondaryRangeArrayInput` via:
//
//	SubnetworkSecondaryRangeArray{ SubnetworkSecondaryRangeArgs{...} }
type SubnetworkSecondaryRangeArrayInput interface {
	pulumi.Input

	ToSubnetworkSecondaryRangeArrayOutput() SubnetworkSecondaryRangeArrayOutput
	ToSubnetworkSecondaryRangeArrayOutputWithContext(context.Context) SubnetworkSecondaryRangeArrayOutput
}

type SubnetworkSecondaryRangeArray []SubnetworkSecondaryRangeInput

func (SubnetworkSecondaryRangeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubnetworkSecondaryRange)(nil)).Elem()
}

func (i SubnetworkSecondaryRangeArray) ToSubnetworkSecondaryRangeArrayOutput() SubnetworkSecondaryRangeArrayOutput {
	return i.ToSubnetworkSecondaryRangeArrayOutputWithContext(context.Background())
}

func (i SubnetworkSecondaryRangeArray) ToSubnetworkSecondaryRangeArrayOutputWithContext(ctx context.Context) SubnetworkSecondaryRangeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubnetworkSecondaryRangeArrayOutput)
}

// Represents a secondary IP range of a subnetwork.
type SubnetworkSecondaryRangeOutput struct{ *pulumi.OutputState }

func (SubnetworkSecondaryRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubnetworkSecondaryRange)(nil)).Elem()
}

func (o SubnetworkSecondaryRangeOutput) ToSubnetworkSecondaryRangeOutput() SubnetworkSecondaryRangeOutput {
	return o
}

func (o SubnetworkSecondaryRangeOutput) ToSubnetworkSecondaryRangeOutputWithContext(ctx context.Context) SubnetworkSecondaryRangeOutput {
	return o
}

// The range of IP addresses belonging to this subnetwork secondary range. Provide this property when you create the subnetwork. Ranges must be unique and non-overlapping with all primary and secondary IP ranges within a network. Only IPv4 is supported. The range can be any range listed in the Valid ranges list.
func (o SubnetworkSecondaryRangeOutput) IpCidrRange() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubnetworkSecondaryRange) *string { return v.IpCidrRange }).(pulumi.StringPtrOutput)
}

// The name associated with this subnetwork secondary range, used when adding an alias IP range to a VM instance. The name must be 1-63 characters long, and comply with RFC1035. The name must be unique within the subnetwork.
func (o SubnetworkSecondaryRangeOutput) RangeName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubnetworkSecondaryRange) *string { return v.RangeName }).(pulumi.StringPtrOutput)
}

// The URL of the reserved internal range.
func (o SubnetworkSecondaryRangeOutput) ReservedInternalRange() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubnetworkSecondaryRange) *string { return v.ReservedInternalRange }).(pulumi.StringPtrOutput)
}

type SubnetworkSecondaryRangeArrayOutput struct{ *pulumi.OutputState }

func (SubnetworkSecondaryRangeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubnetworkSecondaryRange)(nil)).Elem()
}

func (o SubnetworkSecondaryRangeArrayOutput) ToSubnetworkSecondaryRangeArrayOutput() SubnetworkSecondaryRangeArrayOutput {
	return o
}

func (o SubnetworkSecondaryRangeArrayOutput) ToSubnetworkSecondaryRangeArrayOutputWithContext(ctx context.Context) SubnetworkSecondaryRangeArrayOutput {
	return o
}

func (o SubnetworkSecondaryRangeArrayOutput) Index(i pulumi.IntInput) SubnetworkSecondaryRangeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SubnetworkSecondaryRange {
		return vs[0].([]SubnetworkSecondaryRange)[vs[1].(int)]
	}).(SubnetworkSecondaryRangeOutput)
}

// Represents a secondary IP range of a subnetwork.
type SubnetworkSecondaryRangeResponse struct {
	// The range of IP addresses belonging to this subnetwork secondary range. Provide this property when you create the subnetwork. Ranges must be unique and non-overlapping with all primary and secondary IP ranges within a network. Only IPv4 is supported. The range can be any range listed in the Valid ranges list.
	IpCidrRange string `pulumi:"ipCidrRange"`
	// The name associated with this subnetwork secondary range, used when adding an alias IP range to a VM instance. The name must be 1-63 characters long, and comply with RFC1035. The name must be unique within the subnetwork.
	RangeName string `pulumi:"rangeName"`
	// The URL of the reserved internal range.
	ReservedInternalRange string `pulumi:"reservedInternalRange"`
}

// Represents a secondary IP range of a subnetwork.
type SubnetworkSecondaryRangeResponseOutput struct{ *pulumi.OutputState }

func (SubnetworkSecondaryRangeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubnetworkSecondaryRangeResponse)(nil)).Elem()
}

func (o SubnetworkSecondaryRangeResponseOutput) ToSubnetworkSecondaryRangeResponseOutput() SubnetworkSecondaryRangeResponseOutput {
	return o
}

func (o SubnetworkSecondaryRangeResponseOutput) ToSubnetworkSecondaryRangeResponseOutputWithContext(ctx context.Context) SubnetworkSecondaryRangeResponseOutput {
	return o
}

// The range of IP addresses belonging to this subnetwork secondary range. Provide this property when you create the subnetwork. Ranges must be unique and non-overlapping with all primary and secondary IP ranges within a network. Only IPv4 is supported. The range can be any range listed in the Valid ranges list.
func (o SubnetworkSecondaryRangeResponseOutput) IpCidrRange() pulumi.StringOutput {
	return o.ApplyT(func(v SubnetworkSecondaryRangeResponse) string { return v.IpCidrRange }).(pulumi.StringOutput)
}

// The name associated with this subnetwork secondary range, used when adding an alias IP range to a VM instance. The name must be 1-63 characters long, and comply with RFC1035. The name must be unique within the subnetwork.
func (o SubnetworkSecondaryRangeResponseOutput) RangeName() pulumi.StringOutput {
	return o.ApplyT(func(v SubnetworkSecondaryRangeResponse) string { return v.RangeName }).(pulumi.StringOutput)
}

// The URL of the reserved internal range.
func (o SubnetworkSecondaryRangeResponseOutput) ReservedInternalRange() pulumi.StringOutput {
	return o.ApplyT(func(v SubnetworkSecondaryRangeResponse) string { return v.ReservedInternalRange }).(pulumi.StringOutput)
}

type SubnetworkSecondaryRangeResponseArrayOutput struct{ *pulumi.OutputState }

func (SubnetworkSecondaryRangeResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubnetworkSecondaryRangeResponse)(nil)).Elem()
}

func (o SubnetworkSecondaryRangeResponseArrayOutput) ToSubnetworkSecondaryRangeResponseArrayOutput() SubnetworkSecondaryRangeResponseArrayOutput {
	return o
}

func (o SubnetworkSecondaryRangeResponseArrayOutput) ToSubnetworkSecondaryRangeResponseArrayOutputWithContext(ctx context.Context) SubnetworkSecondaryRangeResponseArrayOutput {
	return o
}

func (o SubnetworkSecondaryRangeResponseArrayOutput) Index(i pulumi.IntInput) SubnetworkSecondaryRangeResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SubnetworkSecondaryRangeResponse {
		return vs[0].([]SubnetworkSecondaryRangeResponse)[vs[1].(int)]
	}).(SubnetworkSecondaryRangeResponseOutput)
}

// Subsetting configuration for this BackendService. Currently this is applicable only for Internal TCP/UDP load balancing, Internal HTTP(S) load balancing and Traffic Director.
type Subsetting struct {
	Policy *SubsettingPolicy `pulumi:"policy"`
	// The number of backends per backend group assigned to each proxy instance or each service mesh client. An input parameter to the `CONSISTENT_HASH_SUBSETTING` algorithm. Can only be set if `policy` is set to `CONSISTENT_HASH_SUBSETTING`. Can only be set if load balancing scheme is `INTERNAL_MANAGED` or `INTERNAL_SELF_MANAGED`. `subset_size` is optional for Internal HTTP(S) load balancing and required for Traffic Director. If you do not provide this value, Cloud Load Balancing will calculate it dynamically to optimize the number of proxies/clients visible to each backend and vice versa. Must be greater than 0. If `subset_size` is larger than the number of backends/endpoints, then subsetting is disabled.
	SubsetSize *int `pulumi:"subsetSize"`
}

// SubsettingInput is an input type that accepts SubsettingArgs and SubsettingOutput values.
// You can construct a concrete instance of `SubsettingInput` via:
//
//	SubsettingArgs{...}
type SubsettingInput interface {
	pulumi.Input

	ToSubsettingOutput() SubsettingOutput
	ToSubsettingOutputWithContext(context.Context) SubsettingOutput
}

// Subsetting configuration for this BackendService. Currently this is applicable only for Internal TCP/UDP load balancing, Internal HTTP(S) load balancing and Traffic Director.
type SubsettingArgs struct {
	Policy SubsettingPolicyPtrInput `pulumi:"policy"`
	// The number of backends per backend group assigned to each proxy instance or each service mesh client. An input parameter to the `CONSISTENT_HASH_SUBSETTING` algorithm. Can only be set if `policy` is set to `CONSISTENT_HASH_SUBSETTING`. Can only be set if load balancing scheme is `INTERNAL_MANAGED` or `INTERNAL_SELF_MANAGED`. `subset_size` is optional for Internal HTTP(S) load balancing and required for Traffic Director. If you do not provide this value, Cloud Load Balancing will calculate it dynamically to optimize the number of proxies/clients visible to each backend and vice versa. Must be greater than 0. If `subset_size` is larger than the number of backends/endpoints, then subsetting is disabled.
	SubsetSize pulumi.IntPtrInput `pulumi:"subsetSize"`
}

func (SubsettingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Subsetting)(nil)).Elem()
}

func (i SubsettingArgs) ToSubsettingOutput() SubsettingOutput {
	return i.ToSubsettingOutputWithContext(context.Background())
}

func (i SubsettingArgs) ToSubsettingOutputWithContext(ctx context.Context) SubsettingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubsettingOutput)
}

func (i SubsettingArgs) ToSubsettingPtrOutput() SubsettingPtrOutput {
	return i.ToSubsettingPtrOutputWithContext(context.Background())
}

func (i SubsettingArgs) ToSubsettingPtrOutputWithContext(ctx context.Context) SubsettingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubsettingOutput).ToSubsettingPtrOutputWithContext(ctx)
}

// SubsettingPtrInput is an input type that accepts SubsettingArgs, SubsettingPtr and SubsettingPtrOutput values.
// You can construct a concrete instance of `SubsettingPtrInput` via:
//
//	        SubsettingArgs{...}
//
//	or:
//
//	        nil
type SubsettingPtrInput interface {
	pulumi.Input

	ToSubsettingPtrOutput() SubsettingPtrOutput
	ToSubsettingPtrOutputWithContext(context.Context) SubsettingPtrOutput
}

type subsettingPtrType SubsettingArgs

func SubsettingPtr(v *SubsettingArgs) SubsettingPtrInput {
	return (*subsettingPtrType)(v)
}

func (*subsettingPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Subsetting)(nil)).Elem()
}

func (i *subsettingPtrType) ToSubsettingPtrOutput() SubsettingPtrOutput {
	return i.ToSubsettingPtrOutputWithContext(context.Background())
}

func (i *subsettingPtrType) ToSubsettingPtrOutputWithContext(ctx context.Context) SubsettingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubsettingPtrOutput)
}

// Subsetting configuration for this BackendService. Currently this is applicable only for Internal TCP/UDP load balancing, Internal HTTP(S) load balancing and Traffic Director.
type SubsettingOutput struct{ *pulumi.OutputState }

func (SubsettingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Subsetting)(nil)).Elem()
}

func (o SubsettingOutput) ToSubsettingOutput() SubsettingOutput {
	return o
}

func (o SubsettingOutput) ToSubsettingOutputWithContext(ctx context.Context) SubsettingOutput {
	return o
}

func (o SubsettingOutput) ToSubsettingPtrOutput() SubsettingPtrOutput {
	return o.ToSubsettingPtrOutputWithContext(context.Background())
}

func (o SubsettingOutput) ToSubsettingPtrOutputWithContext(ctx context.Context) SubsettingPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Subsetting) *Subsetting {
		return &v
	}).(SubsettingPtrOutput)
}

func (o SubsettingOutput) Policy() SubsettingPolicyPtrOutput {
	return o.ApplyT(func(v Subsetting) *SubsettingPolicy { return v.Policy }).(SubsettingPolicyPtrOutput)
}

// The number of backends per backend group assigned to each proxy instance or each service mesh client. An input parameter to the `CONSISTENT_HASH_SUBSETTING` algorithm. Can only be set if `policy` is set to `CONSISTENT_HASH_SUBSETTING`. Can only be set if load balancing scheme is `INTERNAL_MANAGED` or `INTERNAL_SELF_MANAGED`. `subset_size` is optional for Internal HTTP(S) load balancing and required for Traffic Director. If you do not provide this value, Cloud Load Balancing will calculate it dynamically to optimize the number of proxies/clients visible to each backend and vice versa. Must be greater than 0. If `subset_size` is larger than the number of backends/endpoints, then subsetting is disabled.
func (o SubsettingOutput) SubsetSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Subsetting) *int { return v.SubsetSize }).(pulumi.IntPtrOutput)
}

type SubsettingPtrOutput struct{ *pulumi.OutputState }

func (SubsettingPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Subsetting)(nil)).Elem()
}

func (o SubsettingPtrOutput) ToSubsettingPtrOutput() SubsettingPtrOutput {
	return o
}

func (o SubsettingPtrOutput) ToSubsettingPtrOutputWithContext(ctx context.Context) SubsettingPtrOutput {
	return o
}

func (o SubsettingPtrOutput) Elem() SubsettingOutput {
	return o.ApplyT(func(v *Subsetting) Subsetting {
		if v != nil {
			return *v
		}
		var ret Subsetting
		return ret
	}).(SubsettingOutput)
}

func (o SubsettingPtrOutput) Policy() SubsettingPolicyPtrOutput {
	return o.ApplyT(func(v *Subsetting) *SubsettingPolicy {
		if v == nil {
			return nil
		}
		return v.Policy
	}).(SubsettingPolicyPtrOutput)
}

// The number of backends per backend group assigned to each proxy instance or each service mesh client. An input parameter to the `CONSISTENT_HASH_SUBSETTING` algorithm. Can only be set if `policy` is set to `CONSISTENT_HASH_SUBSETTING`. Can only be set if load balancing scheme is `INTERNAL_MANAGED` or `INTERNAL_SELF_MANAGED`. `subset_size` is optional for Internal HTTP(S) load balancing and required for Traffic Director. If you do not provide this value, Cloud Load Balancing will calculate it dynamically to optimize the number of proxies/clients visible to each backend and vice versa. Must be greater than 0. If `subset_size` is larger than the number of backends/endpoints, then subsetting is disabled.
func (o SubsettingPtrOutput) SubsetSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Subsetting) *int {
		if v == nil {
			return nil
		}
		return v.SubsetSize
	}).(pulumi.IntPtrOutput)
}

// Subsetting configuration for this BackendService. Currently this is applicable only for Internal TCP/UDP load balancing, Internal HTTP(S) load balancing and Traffic Director.
type SubsettingResponse struct {
	Policy string `pulumi:"policy"`
	// The number of backends per backend group assigned to each proxy instance or each service mesh client. An input parameter to the `CONSISTENT_HASH_SUBSETTING` algorithm. Can only be set if `policy` is set to `CONSISTENT_HASH_SUBSETTING`. Can only be set if load balancing scheme is `INTERNAL_MANAGED` or `INTERNAL_SELF_MANAGED`. `subset_size` is optional for Internal HTTP(S) load balancing and required for Traffic Director. If you do not provide this value, Cloud Load Balancing will calculate it dynamically to optimize the number of proxies/clients visible to each backend and vice versa. Must be greater than 0. If `subset_size` is larger than the number of backends/endpoints, then subsetting is disabled.
	SubsetSize int `pulumi:"subsetSize"`
}

// Subsetting configuration for this BackendService. Currently this is applicable only for Internal TCP/UDP load balancing, Internal HTTP(S) load balancing and Traffic Director.
type SubsettingResponseOutput struct{ *pulumi.OutputState }

func (SubsettingResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubsettingResponse)(nil)).Elem()
}

func (o SubsettingResponseOutput) ToSubsettingResponseOutput() SubsettingResponseOutput {
	return o
}

func (o SubsettingResponseOutput) ToSubsettingResponseOutputWithContext(ctx context.Context) SubsettingResponseOutput {
	return o
}

func (o SubsettingResponseOutput) Policy() pulumi.StringOutput {
	return o.ApplyT(func(v SubsettingResponse) string { return v.Policy }).(pulumi.StringOutput)
}

// The number of backends per backend group assigned to each proxy instance or each service mesh client. An input parameter to the `CONSISTENT_HASH_SUBSETTING` algorithm. Can only be set if `policy` is set to `CONSISTENT_HASH_SUBSETTING`. Can only be set if load balancing scheme is `INTERNAL_MANAGED` or `INTERNAL_SELF_MANAGED`. `subset_size` is optional for Internal HTTP(S) load balancing and required for Traffic Director. If you do not provide this value, Cloud Load Balancing will calculate it dynamically to optimize the number of proxies/clients visible to each backend and vice versa. Must be greater than 0. If `subset_size` is larger than the number of backends/endpoints, then subsetting is disabled.
func (o SubsettingResponseOutput) SubsetSize() pulumi.IntOutput {
	return o.ApplyT(func(v SubsettingResponse) int { return v.SubsetSize }).(pulumi.IntOutput)
}

type TCPHealthCheck struct {
	// The TCP port number to which the health check prober sends packets. The default value is 80. Valid values are 1 through 65535.
	Port *int `pulumi:"port"`
	// Not supported.
	PortName *string `pulumi:"portName"`
	// Specifies how a port is selected for health checking. Can be one of the following values: USE_FIXED_PORT: Specifies a port number explicitly using the port field in the health check. Supported by backend services for pass-through load balancers and backend services for proxy load balancers. Not supported by target pools. The health check supports all backends supported by the backend service provided the backend can be health checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an indirect method of specifying the health check port by referring to the backend service. Only supported by backend services for proxy load balancers. Not supported by target pools. Not supported by backend services for pass-through load balancers. Supports all backends that can be health checked; for example, GCE_VM_IP_PORT network endpoint groups and instance group backends. For GCE_VM_IP_PORT network endpoint group backends, the health check uses the port number specified for each endpoint in the network endpoint group. For instance group backends, the health check uses the port number determined by looking up the backend service's named port in the instance group's list of named ports.
	PortSpecification *TCPHealthCheckPortSpecification `pulumi:"portSpecification"`
	// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader *TCPHealthCheckProxyHeader `pulumi:"proxyHeader"`
	// Instructs the health check prober to send this exact ASCII string, up to 1024 bytes in length, after establishing the TCP connection.
	Request *string `pulumi:"request"`
	// Creates a content-based TCP health check. In addition to establishing a TCP connection, you can configure the health check to pass only when the backend sends this exact response ASCII string, up to 1024 bytes in length. For details, see: https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-ssl-tcp
	Response *string `pulumi:"response"`
}

// TCPHealthCheckInput is an input type that accepts TCPHealthCheckArgs and TCPHealthCheckOutput values.
// You can construct a concrete instance of `TCPHealthCheckInput` via:
//
//	TCPHealthCheckArgs{...}
type TCPHealthCheckInput interface {
	pulumi.Input

	ToTCPHealthCheckOutput() TCPHealthCheckOutput
	ToTCPHealthCheckOutputWithContext(context.Context) TCPHealthCheckOutput
}

type TCPHealthCheckArgs struct {
	// The TCP port number to which the health check prober sends packets. The default value is 80. Valid values are 1 through 65535.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Not supported.
	PortName pulumi.StringPtrInput `pulumi:"portName"`
	// Specifies how a port is selected for health checking. Can be one of the following values: USE_FIXED_PORT: Specifies a port number explicitly using the port field in the health check. Supported by backend services for pass-through load balancers and backend services for proxy load balancers. Not supported by target pools. The health check supports all backends supported by the backend service provided the backend can be health checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an indirect method of specifying the health check port by referring to the backend service. Only supported by backend services for proxy load balancers. Not supported by target pools. Not supported by backend services for pass-through load balancers. Supports all backends that can be health checked; for example, GCE_VM_IP_PORT network endpoint groups and instance group backends. For GCE_VM_IP_PORT network endpoint group backends, the health check uses the port number specified for each endpoint in the network endpoint group. For instance group backends, the health check uses the port number determined by looking up the backend service's named port in the instance group's list of named ports.
	PortSpecification TCPHealthCheckPortSpecificationPtrInput `pulumi:"portSpecification"`
	// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader TCPHealthCheckProxyHeaderPtrInput `pulumi:"proxyHeader"`
	// Instructs the health check prober to send this exact ASCII string, up to 1024 bytes in length, after establishing the TCP connection.
	Request pulumi.StringPtrInput `pulumi:"request"`
	// Creates a content-based TCP health check. In addition to establishing a TCP connection, you can configure the health check to pass only when the backend sends this exact response ASCII string, up to 1024 bytes in length. For details, see: https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-ssl-tcp
	Response pulumi.StringPtrInput `pulumi:"response"`
}

func (TCPHealthCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPHealthCheck)(nil)).Elem()
}

func (i TCPHealthCheckArgs) ToTCPHealthCheckOutput() TCPHealthCheckOutput {
	return i.ToTCPHealthCheckOutputWithContext(context.Background())
}

func (i TCPHealthCheckArgs) ToTCPHealthCheckOutputWithContext(ctx context.Context) TCPHealthCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPHealthCheckOutput)
}

func (i TCPHealthCheckArgs) ToTCPHealthCheckPtrOutput() TCPHealthCheckPtrOutput {
	return i.ToTCPHealthCheckPtrOutputWithContext(context.Background())
}

func (i TCPHealthCheckArgs) ToTCPHealthCheckPtrOutputWithContext(ctx context.Context) TCPHealthCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPHealthCheckOutput).ToTCPHealthCheckPtrOutputWithContext(ctx)
}

// TCPHealthCheckPtrInput is an input type that accepts TCPHealthCheckArgs, TCPHealthCheckPtr and TCPHealthCheckPtrOutput values.
// You can construct a concrete instance of `TCPHealthCheckPtrInput` via:
//
//	        TCPHealthCheckArgs{...}
//
//	or:
//
//	        nil
type TCPHealthCheckPtrInput interface {
	pulumi.Input

	ToTCPHealthCheckPtrOutput() TCPHealthCheckPtrOutput
	ToTCPHealthCheckPtrOutputWithContext(context.Context) TCPHealthCheckPtrOutput
}

type tcphealthCheckPtrType TCPHealthCheckArgs

func TCPHealthCheckPtr(v *TCPHealthCheckArgs) TCPHealthCheckPtrInput {
	return (*tcphealthCheckPtrType)(v)
}

func (*tcphealthCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPHealthCheck)(nil)).Elem()
}

func (i *tcphealthCheckPtrType) ToTCPHealthCheckPtrOutput() TCPHealthCheckPtrOutput {
	return i.ToTCPHealthCheckPtrOutputWithContext(context.Background())
}

func (i *tcphealthCheckPtrType) ToTCPHealthCheckPtrOutputWithContext(ctx context.Context) TCPHealthCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPHealthCheckPtrOutput)
}

type TCPHealthCheckOutput struct{ *pulumi.OutputState }

func (TCPHealthCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPHealthCheck)(nil)).Elem()
}

func (o TCPHealthCheckOutput) ToTCPHealthCheckOutput() TCPHealthCheckOutput {
	return o
}

func (o TCPHealthCheckOutput) ToTCPHealthCheckOutputWithContext(ctx context.Context) TCPHealthCheckOutput {
	return o
}

func (o TCPHealthCheckOutput) ToTCPHealthCheckPtrOutput() TCPHealthCheckPtrOutput {
	return o.ToTCPHealthCheckPtrOutputWithContext(context.Background())
}

func (o TCPHealthCheckOutput) ToTCPHealthCheckPtrOutputWithContext(ctx context.Context) TCPHealthCheckPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TCPHealthCheck) *TCPHealthCheck {
		return &v
	}).(TCPHealthCheckPtrOutput)
}

// The TCP port number to which the health check prober sends packets. The default value is 80. Valid values are 1 through 65535.
func (o TCPHealthCheckOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPHealthCheck) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Not supported.
func (o TCPHealthCheckOutput) PortName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPHealthCheck) *string { return v.PortName }).(pulumi.StringPtrOutput)
}

// Specifies how a port is selected for health checking. Can be one of the following values: USE_FIXED_PORT: Specifies a port number explicitly using the port field in the health check. Supported by backend services for pass-through load balancers and backend services for proxy load balancers. Not supported by target pools. The health check supports all backends supported by the backend service provided the backend can be health checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an indirect method of specifying the health check port by referring to the backend service. Only supported by backend services for proxy load balancers. Not supported by target pools. Not supported by backend services for pass-through load balancers. Supports all backends that can be health checked; for example, GCE_VM_IP_PORT network endpoint groups and instance group backends. For GCE_VM_IP_PORT network endpoint group backends, the health check uses the port number specified for each endpoint in the network endpoint group. For instance group backends, the health check uses the port number determined by looking up the backend service's named port in the instance group's list of named ports.
func (o TCPHealthCheckOutput) PortSpecification() TCPHealthCheckPortSpecificationPtrOutput {
	return o.ApplyT(func(v TCPHealthCheck) *TCPHealthCheckPortSpecification { return v.PortSpecification }).(TCPHealthCheckPortSpecificationPtrOutput)
}

// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
func (o TCPHealthCheckOutput) ProxyHeader() TCPHealthCheckProxyHeaderPtrOutput {
	return o.ApplyT(func(v TCPHealthCheck) *TCPHealthCheckProxyHeader { return v.ProxyHeader }).(TCPHealthCheckProxyHeaderPtrOutput)
}

// Instructs the health check prober to send this exact ASCII string, up to 1024 bytes in length, after establishing the TCP connection.
func (o TCPHealthCheckOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPHealthCheck) *string { return v.Request }).(pulumi.StringPtrOutput)
}

// Creates a content-based TCP health check. In addition to establishing a TCP connection, you can configure the health check to pass only when the backend sends this exact response ASCII string, up to 1024 bytes in length. For details, see: https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-ssl-tcp
func (o TCPHealthCheckOutput) Response() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPHealthCheck) *string { return v.Response }).(pulumi.StringPtrOutput)
}

type TCPHealthCheckPtrOutput struct{ *pulumi.OutputState }

func (TCPHealthCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPHealthCheck)(nil)).Elem()
}

func (o TCPHealthCheckPtrOutput) ToTCPHealthCheckPtrOutput() TCPHealthCheckPtrOutput {
	return o
}

func (o TCPHealthCheckPtrOutput) ToTCPHealthCheckPtrOutputWithContext(ctx context.Context) TCPHealthCheckPtrOutput {
	return o
}

func (o TCPHealthCheckPtrOutput) Elem() TCPHealthCheckOutput {
	return o.ApplyT(func(v *TCPHealthCheck) TCPHealthCheck {
		if v != nil {
			return *v
		}
		var ret TCPHealthCheck
		return ret
	}).(TCPHealthCheckOutput)
}

// The TCP port number to which the health check prober sends packets. The default value is 80. Valid values are 1 through 65535.
func (o TCPHealthCheckPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TCPHealthCheck) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// Not supported.
func (o TCPHealthCheckPtrOutput) PortName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TCPHealthCheck) *string {
		if v == nil {
			return nil
		}
		return v.PortName
	}).(pulumi.StringPtrOutput)
}

// Specifies how a port is selected for health checking. Can be one of the following values: USE_FIXED_PORT: Specifies a port number explicitly using the port field in the health check. Supported by backend services for pass-through load balancers and backend services for proxy load balancers. Not supported by target pools. The health check supports all backends supported by the backend service provided the backend can be health checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an indirect method of specifying the health check port by referring to the backend service. Only supported by backend services for proxy load balancers. Not supported by target pools. Not supported by backend services for pass-through load balancers. Supports all backends that can be health checked; for example, GCE_VM_IP_PORT network endpoint groups and instance group backends. For GCE_VM_IP_PORT network endpoint group backends, the health check uses the port number specified for each endpoint in the network endpoint group. For instance group backends, the health check uses the port number determined by looking up the backend service's named port in the instance group's list of named ports.
func (o TCPHealthCheckPtrOutput) PortSpecification() TCPHealthCheckPortSpecificationPtrOutput {
	return o.ApplyT(func(v *TCPHealthCheck) *TCPHealthCheckPortSpecification {
		if v == nil {
			return nil
		}
		return v.PortSpecification
	}).(TCPHealthCheckPortSpecificationPtrOutput)
}

// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
func (o TCPHealthCheckPtrOutput) ProxyHeader() TCPHealthCheckProxyHeaderPtrOutput {
	return o.ApplyT(func(v *TCPHealthCheck) *TCPHealthCheckProxyHeader {
		if v == nil {
			return nil
		}
		return v.ProxyHeader
	}).(TCPHealthCheckProxyHeaderPtrOutput)
}

// Instructs the health check prober to send this exact ASCII string, up to 1024 bytes in length, after establishing the TCP connection.
func (o TCPHealthCheckPtrOutput) Request() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TCPHealthCheck) *string {
		if v == nil {
			return nil
		}
		return v.Request
	}).(pulumi.StringPtrOutput)
}

// Creates a content-based TCP health check. In addition to establishing a TCP connection, you can configure the health check to pass only when the backend sends this exact response ASCII string, up to 1024 bytes in length. For details, see: https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-ssl-tcp
func (o TCPHealthCheckPtrOutput) Response() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TCPHealthCheck) *string {
		if v == nil {
			return nil
		}
		return v.Response
	}).(pulumi.StringPtrOutput)
}

type TCPHealthCheckResponse struct {
	// The TCP port number to which the health check prober sends packets. The default value is 80. Valid values are 1 through 65535.
	Port int `pulumi:"port"`
	// Not supported.
	PortName string `pulumi:"portName"`
	// Specifies how a port is selected for health checking. Can be one of the following values: USE_FIXED_PORT: Specifies a port number explicitly using the port field in the health check. Supported by backend services for pass-through load balancers and backend services for proxy load balancers. Not supported by target pools. The health check supports all backends supported by the backend service provided the backend can be health checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an indirect method of specifying the health check port by referring to the backend service. Only supported by backend services for proxy load balancers. Not supported by target pools. Not supported by backend services for pass-through load balancers. Supports all backends that can be health checked; for example, GCE_VM_IP_PORT network endpoint groups and instance group backends. For GCE_VM_IP_PORT network endpoint group backends, the health check uses the port number specified for each endpoint in the network endpoint group. For instance group backends, the health check uses the port number determined by looking up the backend service's named port in the instance group's list of named ports.
	PortSpecification string `pulumi:"portSpecification"`
	// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `pulumi:"proxyHeader"`
	// Instructs the health check prober to send this exact ASCII string, up to 1024 bytes in length, after establishing the TCP connection.
	Request string `pulumi:"request"`
	// Creates a content-based TCP health check. In addition to establishing a TCP connection, you can configure the health check to pass only when the backend sends this exact response ASCII string, up to 1024 bytes in length. For details, see: https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-ssl-tcp
	Response string `pulumi:"response"`
}

type TCPHealthCheckResponseOutput struct{ *pulumi.OutputState }

func (TCPHealthCheckResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPHealthCheckResponse)(nil)).Elem()
}

func (o TCPHealthCheckResponseOutput) ToTCPHealthCheckResponseOutput() TCPHealthCheckResponseOutput {
	return o
}

func (o TCPHealthCheckResponseOutput) ToTCPHealthCheckResponseOutputWithContext(ctx context.Context) TCPHealthCheckResponseOutput {
	return o
}

// The TCP port number to which the health check prober sends packets. The default value is 80. Valid values are 1 through 65535.
func (o TCPHealthCheckResponseOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v TCPHealthCheckResponse) int { return v.Port }).(pulumi.IntOutput)
}

// Not supported.
func (o TCPHealthCheckResponseOutput) PortName() pulumi.StringOutput {
	return o.ApplyT(func(v TCPHealthCheckResponse) string { return v.PortName }).(pulumi.StringOutput)
}

// Specifies how a port is selected for health checking. Can be one of the following values: USE_FIXED_PORT: Specifies a port number explicitly using the port field in the health check. Supported by backend services for pass-through load balancers and backend services for proxy load balancers. Not supported by target pools. The health check supports all backends supported by the backend service provided the backend can be health checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an indirect method of specifying the health check port by referring to the backend service. Only supported by backend services for proxy load balancers. Not supported by target pools. Not supported by backend services for pass-through load balancers. Supports all backends that can be health checked; for example, GCE_VM_IP_PORT network endpoint groups and instance group backends. For GCE_VM_IP_PORT network endpoint group backends, the health check uses the port number specified for each endpoint in the network endpoint group. For instance group backends, the health check uses the port number determined by looking up the backend service's named port in the instance group's list of named ports.
func (o TCPHealthCheckResponseOutput) PortSpecification() pulumi.StringOutput {
	return o.ApplyT(func(v TCPHealthCheckResponse) string { return v.PortSpecification }).(pulumi.StringOutput)
}

// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
func (o TCPHealthCheckResponseOutput) ProxyHeader() pulumi.StringOutput {
	return o.ApplyT(func(v TCPHealthCheckResponse) string { return v.ProxyHeader }).(pulumi.StringOutput)
}

// Instructs the health check prober to send this exact ASCII string, up to 1024 bytes in length, after establishing the TCP connection.
func (o TCPHealthCheckResponseOutput) Request() pulumi.StringOutput {
	return o.ApplyT(func(v TCPHealthCheckResponse) string { return v.Request }).(pulumi.StringOutput)
}

// Creates a content-based TCP health check. In addition to establishing a TCP connection, you can configure the health check to pass only when the backend sends this exact response ASCII string, up to 1024 bytes in length. For details, see: https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-ssl-tcp
func (o TCPHealthCheckResponseOutput) Response() pulumi.StringOutput {
	return o.ApplyT(func(v TCPHealthCheckResponse) string { return v.Response }).(pulumi.StringOutput)
}

// A set of instance tags.
type Tags struct {
	// An array of tags. Each tag must be 1-63 characters long, and comply with RFC1035.
	Items []string `pulumi:"items"`
}

// TagsInput is an input type that accepts TagsArgs and TagsOutput values.
// You can construct a concrete instance of `TagsInput` via:
//
//	TagsArgs{...}
type TagsInput interface {
	pulumi.Input

	ToTagsOutput() TagsOutput
	ToTagsOutputWithContext(context.Context) TagsOutput
}

// A set of instance tags.
type TagsArgs struct {
	// An array of tags. Each tag must be 1-63 characters long, and comply with RFC1035.
	Items pulumi.StringArrayInput `pulumi:"items"`
}

func (TagsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Tags)(nil)).Elem()
}

func (i TagsArgs) ToTagsOutput() TagsOutput {
	return i.ToTagsOutputWithContext(context.Background())
}

func (i TagsArgs) ToTagsOutputWithContext(ctx context.Context) TagsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsOutput)
}

func (i TagsArgs) ToTagsPtrOutput() TagsPtrOutput {
	return i.ToTagsPtrOutputWithContext(context.Background())
}

func (i TagsArgs) ToTagsPtrOutputWithContext(ctx context.Context) TagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsOutput).ToTagsPtrOutputWithContext(ctx)
}

// TagsPtrInput is an input type that accepts TagsArgs, TagsPtr and TagsPtrOutput values.
// You can construct a concrete instance of `TagsPtrInput` via:
//
//	        TagsArgs{...}
//
//	or:
//
//	        nil
type TagsPtrInput interface {
	pulumi.Input

	ToTagsPtrOutput() TagsPtrOutput
	ToTagsPtrOutputWithContext(context.Context) TagsPtrOutput
}

type tagsPtrType TagsArgs

func TagsPtr(v *TagsArgs) TagsPtrInput {
	return (*tagsPtrType)(v)
}

func (*tagsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Tags)(nil)).Elem()
}

func (i *tagsPtrType) ToTagsPtrOutput() TagsPtrOutput {
	return i.ToTagsPtrOutputWithContext(context.Background())
}

func (i *tagsPtrType) ToTagsPtrOutputWithContext(ctx context.Context) TagsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagsPtrOutput)
}

// A set of instance tags.
type TagsOutput struct{ *pulumi.OutputState }

func (TagsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Tags)(nil)).Elem()
}

func (o TagsOutput) ToTagsOutput() TagsOutput {
	return o
}

func (o TagsOutput) ToTagsOutputWithContext(ctx context.Context) TagsOutput {
	return o
}

func (o TagsOutput) ToTagsPtrOutput() TagsPtrOutput {
	return o.ToTagsPtrOutputWithContext(context.Background())
}

func (o TagsOutput) ToTagsPtrOutputWithContext(ctx context.Context) TagsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Tags) *Tags {
		return &v
	}).(TagsPtrOutput)
}

// An array of tags. Each tag must be 1-63 characters long, and comply with RFC1035.
func (o TagsOutput) Items() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Tags) []string { return v.Items }).(pulumi.StringArrayOutput)
}

type TagsPtrOutput struct{ *pulumi.OutputState }

func (TagsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Tags)(nil)).Elem()
}

func (o TagsPtrOutput) ToTagsPtrOutput() TagsPtrOutput {
	return o
}

func (o TagsPtrOutput) ToTagsPtrOutputWithContext(ctx context.Context) TagsPtrOutput {
	return o
}

func (o TagsPtrOutput) Elem() TagsOutput {
	return o.ApplyT(func(v *Tags) Tags {
		if v != nil {
			return *v
		}
		var ret Tags
		return ret
	}).(TagsOutput)
}

// An array of tags. Each tag must be 1-63 characters long, and comply with RFC1035.
func (o TagsPtrOutput) Items() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Tags) []string {
		if v == nil {
			return nil
		}
		return v.Items
	}).(pulumi.StringArrayOutput)
}

// A set of instance tags.
type TagsResponse struct {
	// Specifies a fingerprint for this request, which is essentially a hash of the tags' contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update tags. You must always provide an up-to-date fingerprint hash in order to update or change tags. To see the latest fingerprint, make get() request to the instance.
	Fingerprint string `pulumi:"fingerprint"`
	// An array of tags. Each tag must be 1-63 characters long, and comply with RFC1035.
	Items []string `pulumi:"items"`
}

// A set of instance tags.
type TagsResponseOutput struct{ *pulumi.OutputState }

func (TagsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsResponse)(nil)).Elem()
}

func (o TagsResponseOutput) ToTagsResponseOutput() TagsResponseOutput {
	return o
}

func (o TagsResponseOutput) ToTagsResponseOutputWithContext(ctx context.Context) TagsResponseOutput {
	return o
}

// Specifies a fingerprint for this request, which is essentially a hash of the tags' contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update tags. You must always provide an up-to-date fingerprint hash in order to update or change tags. To see the latest fingerprint, make get() request to the instance.
func (o TagsResponseOutput) Fingerprint() pulumi.StringOutput {
	return o.ApplyT(func(v TagsResponse) string { return v.Fingerprint }).(pulumi.StringOutput)
}

// An array of tags. Each tag must be 1-63 characters long, and comply with RFC1035.
func (o TagsResponseOutput) Items() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsResponse) []string { return v.Items }).(pulumi.StringArrayOutput)
}

type Uint128Response struct {
	High string `pulumi:"high"`
	Low  string `pulumi:"low"`
}

type Uint128ResponseOutput struct{ *pulumi.OutputState }

func (Uint128ResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Uint128Response)(nil)).Elem()
}

func (o Uint128ResponseOutput) ToUint128ResponseOutput() Uint128ResponseOutput {
	return o
}

func (o Uint128ResponseOutput) ToUint128ResponseOutputWithContext(ctx context.Context) Uint128ResponseOutput {
	return o
}

func (o Uint128ResponseOutput) High() pulumi.StringOutput {
	return o.ApplyT(func(v Uint128Response) string { return v.High }).(pulumi.StringOutput)
}

func (o Uint128ResponseOutput) Low() pulumi.StringOutput {
	return o.ApplyT(func(v Uint128Response) string { return v.Low }).(pulumi.StringOutput)
}

// Upcoming Maintenance notification information.
type UpcomingMaintenanceResponse struct {
	// Indicates if the maintenance can be customer triggered.
	CanReschedule bool `pulumi:"canReschedule"`
	// The latest time for the planned maintenance window to start. This timestamp value is in RFC3339 text format.
	LatestWindowStartTime string `pulumi:"latestWindowStartTime"`
	MaintenanceStatus     string `pulumi:"maintenanceStatus"`
	// Defines the type of maintenance.
	Type string `pulumi:"type"`
	// The time by which the maintenance disruption will be completed. This timestamp value is in RFC3339 text format.
	WindowEndTime string `pulumi:"windowEndTime"`
	// The current start time of the maintenance window. This timestamp value is in RFC3339 text format.
	WindowStartTime string `pulumi:"windowStartTime"`
}

// Upcoming Maintenance notification information.
type UpcomingMaintenanceResponseOutput struct{ *pulumi.OutputState }

func (UpcomingMaintenanceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UpcomingMaintenanceResponse)(nil)).Elem()
}

func (o UpcomingMaintenanceResponseOutput) ToUpcomingMaintenanceResponseOutput() UpcomingMaintenanceResponseOutput {
	return o
}

func (o UpcomingMaintenanceResponseOutput) ToUpcomingMaintenanceResponseOutputWithContext(ctx context.Context) UpcomingMaintenanceResponseOutput {
	return o
}

// Indicates if the maintenance can be customer triggered.
func (o UpcomingMaintenanceResponseOutput) CanReschedule() pulumi.BoolOutput {
	return o.ApplyT(func(v UpcomingMaintenanceResponse) bool { return v.CanReschedule }).(pulumi.BoolOutput)
}

// The latest time for the planned maintenance window to start. This timestamp value is in RFC3339 text format.
func (o UpcomingMaintenanceResponseOutput) LatestWindowStartTime() pulumi.StringOutput {
	return o.ApplyT(func(v UpcomingMaintenanceResponse) string { return v.LatestWindowStartTime }).(pulumi.StringOutput)
}

func (o UpcomingMaintenanceResponseOutput) MaintenanceStatus() pulumi.StringOutput {
	return o.ApplyT(func(v UpcomingMaintenanceResponse) string { return v.MaintenanceStatus }).(pulumi.StringOutput)
}

// Defines the type of maintenance.
func (o UpcomingMaintenanceResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v UpcomingMaintenanceResponse) string { return v.Type }).(pulumi.StringOutput)
}

// The time by which the maintenance disruption will be completed. This timestamp value is in RFC3339 text format.
func (o UpcomingMaintenanceResponseOutput) WindowEndTime() pulumi.StringOutput {
	return o.ApplyT(func(v UpcomingMaintenanceResponse) string { return v.WindowEndTime }).(pulumi.StringOutput)
}

// The current start time of the maintenance window. This timestamp value is in RFC3339 text format.
func (o UpcomingMaintenanceResponseOutput) WindowStartTime() pulumi.StringOutput {
	return o.ApplyT(func(v UpcomingMaintenanceResponse) string { return v.WindowStartTime }).(pulumi.StringOutput)
}

// Message for the expected URL mappings.
type UrlMapTest struct {
	// Description of this test case.
	Description *string `pulumi:"description"`
	// The expected output URL evaluated by the load balancer containing the scheme, host, path and query parameters. For rules that forward requests to backends, the test passes only when expectedOutputUrl matches the request forwarded by the load balancer to backends. For rules with urlRewrite, the test verifies that the forwarded request matches hostRewrite and pathPrefixRewrite in the urlRewrite action. When service is specified, expectedOutputUrl`s scheme is ignored. For rules with urlRedirect, the test passes only if expectedOutputUrl matches the URL in the load balancer's redirect response. If urlRedirect specifies https_redirect, the test passes only if the scheme in expectedOutputUrl is also set to HTTPS. If urlRedirect specifies strip_query, the test passes only if expectedOutputUrl does not contain any query parameters. expectedOutputUrl is optional when service is specified.
	ExpectedOutputUrl *string `pulumi:"expectedOutputUrl"`
	// For rules with urlRedirect, the test passes only if expectedRedirectResponseCode matches the HTTP status code in load balancer's redirect response. expectedRedirectResponseCode cannot be set when service is set.
	ExpectedRedirectResponseCode *int `pulumi:"expectedRedirectResponseCode"`
	// HTTP headers for this request. If headers contains a host header, then host must also match the header value.
	Headers []UrlMapTestHeader `pulumi:"headers"`
	// Host portion of the URL. If headers contains a host header, then host must also match the header value.
	Host *string `pulumi:"host"`
	// Path portion of the URL.
	Path *string `pulumi:"path"`
	// Expected BackendService or BackendBucket resource the given URL should be mapped to. The service field cannot be set if expectedRedirectResponseCode is set.
	Service *string `pulumi:"service"`
}

// UrlMapTestInput is an input type that accepts UrlMapTestArgs and UrlMapTestOutput values.
// You can construct a concrete instance of `UrlMapTestInput` via:
//
//	UrlMapTestArgs{...}
type UrlMapTestInput interface {
	pulumi.Input

	ToUrlMapTestOutput() UrlMapTestOutput
	ToUrlMapTestOutputWithContext(context.Context) UrlMapTestOutput
}

// Message for the expected URL mappings.
type UrlMapTestArgs struct {
	// Description of this test case.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// The expected output URL evaluated by the load balancer containing the scheme, host, path and query parameters. For rules that forward requests to backends, the test passes only when expectedOutputUrl matches the request forwarded by the load balancer to backends. For rules with urlRewrite, the test verifies that the forwarded request matches hostRewrite and pathPrefixRewrite in the urlRewrite action. When service is specified, expectedOutputUrl`s scheme is ignored. For rules with urlRedirect, the test passes only if expectedOutputUrl matches the URL in the load balancer's redirect response. If urlRedirect specifies https_redirect, the test passes only if the scheme in expectedOutputUrl is also set to HTTPS. If urlRedirect specifies strip_query, the test passes only if expectedOutputUrl does not contain any query parameters. expectedOutputUrl is optional when service is specified.
	ExpectedOutputUrl pulumi.StringPtrInput `pulumi:"expectedOutputUrl"`
	// For rules with urlRedirect, the test passes only if expectedRedirectResponseCode matches the HTTP status code in load balancer's redirect response. expectedRedirectResponseCode cannot be set when service is set.
	ExpectedRedirectResponseCode pulumi.IntPtrInput `pulumi:"expectedRedirectResponseCode"`
	// HTTP headers for this request. If headers contains a host header, then host must also match the header value.
	Headers UrlMapTestHeaderArrayInput `pulumi:"headers"`
	// Host portion of the URL. If headers contains a host header, then host must also match the header value.
	Host pulumi.StringPtrInput `pulumi:"host"`
	// Path portion of the URL.
	Path pulumi.StringPtrInput `pulumi:"path"`
	// Expected BackendService or BackendBucket resource the given URL should be mapped to. The service field cannot be set if expectedRedirectResponseCode is set.
	Service pulumi.StringPtrInput `pulumi:"service"`
}

func (UrlMapTestArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlMapTest)(nil)).Elem()
}

func (i UrlMapTestArgs) ToUrlMapTestOutput() UrlMapTestOutput {
	return i.ToUrlMapTestOutputWithContext(context.Background())
}

func (i UrlMapTestArgs) ToUrlMapTestOutputWithContext(ctx context.Context) UrlMapTestOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UrlMapTestOutput)
}

// UrlMapTestArrayInput is an input type that accepts UrlMapTestArray and UrlMapTestArrayOutput values.
// You can construct a concrete instance of `UrlMapTestArrayInput` via:
//
//	UrlMapTestArray{ UrlMapTestArgs{...} }
type UrlMapTestArrayInput interface {
	pulumi.Input

	ToUrlMapTestArrayOutput() UrlMapTestArrayOutput
	ToUrlMapTestArrayOutputWithContext(context.Context) UrlMapTestArrayOutput
}

type UrlMapTestArray []UrlMapTestInput

func (UrlMapTestArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UrlMapTest)(nil)).Elem()
}

func (i UrlMapTestArray) ToUrlMapTestArrayOutput() UrlMapTestArrayOutput {
	return i.ToUrlMapTestArrayOutputWithContext(context.Background())
}

func (i UrlMapTestArray) ToUrlMapTestArrayOutputWithContext(ctx context.Context) UrlMapTestArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UrlMapTestArrayOutput)
}

// Message for the expected URL mappings.
type UrlMapTestOutput struct{ *pulumi.OutputState }

func (UrlMapTestOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlMapTest)(nil)).Elem()
}

func (o UrlMapTestOutput) ToUrlMapTestOutput() UrlMapTestOutput {
	return o
}

func (o UrlMapTestOutput) ToUrlMapTestOutputWithContext(ctx context.Context) UrlMapTestOutput {
	return o
}

// Description of this test case.
func (o UrlMapTestOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlMapTest) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The expected output URL evaluated by the load balancer containing the scheme, host, path and query parameters. For rules that forward requests to backends, the test passes only when expectedOutputUrl matches the request forwarded by the load balancer to backends. For rules with urlRewrite, the test verifies that the forwarded request matches hostRewrite and pathPrefixRewrite in the urlRewrite action. When service is specified, expectedOutputUrl`s scheme is ignored. For rules with urlRedirect, the test passes only if expectedOutputUrl matches the URL in the load balancer's redirect response. If urlRedirect specifies https_redirect, the test passes only if the scheme in expectedOutputUrl is also set to HTTPS. If urlRedirect specifies strip_query, the test passes only if expectedOutputUrl does not contain any query parameters. expectedOutputUrl is optional when service is specified.
func (o UrlMapTestOutput) ExpectedOutputUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlMapTest) *string { return v.ExpectedOutputUrl }).(pulumi.StringPtrOutput)
}

// For rules with urlRedirect, the test passes only if expectedRedirectResponseCode matches the HTTP status code in load balancer's redirect response. expectedRedirectResponseCode cannot be set when service is set.
func (o UrlMapTestOutput) ExpectedRedirectResponseCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UrlMapTest) *int { return v.ExpectedRedirectResponseCode }).(pulumi.IntPtrOutput)
}

// HTTP headers for this request. If headers contains a host header, then host must also match the header value.
func (o UrlMapTestOutput) Headers() UrlMapTestHeaderArrayOutput {
	return o.ApplyT(func(v UrlMapTest) []UrlMapTestHeader { return v.Headers }).(UrlMapTestHeaderArrayOutput)
}

// Host portion of the URL. If headers contains a host header, then host must also match the header value.
func (o UrlMapTestOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlMapTest) *string { return v.Host }).(pulumi.StringPtrOutput)
}

// Path portion of the URL.
func (o UrlMapTestOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlMapTest) *string { return v.Path }).(pulumi.StringPtrOutput)
}

// Expected BackendService or BackendBucket resource the given URL should be mapped to. The service field cannot be set if expectedRedirectResponseCode is set.
func (o UrlMapTestOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlMapTest) *string { return v.Service }).(pulumi.StringPtrOutput)
}

type UrlMapTestArrayOutput struct{ *pulumi.OutputState }

func (UrlMapTestArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UrlMapTest)(nil)).Elem()
}

func (o UrlMapTestArrayOutput) ToUrlMapTestArrayOutput() UrlMapTestArrayOutput {
	return o
}

func (o UrlMapTestArrayOutput) ToUrlMapTestArrayOutputWithContext(ctx context.Context) UrlMapTestArrayOutput {
	return o
}

func (o UrlMapTestArrayOutput) Index(i pulumi.IntInput) UrlMapTestOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UrlMapTest {
		return vs[0].([]UrlMapTest)[vs[1].(int)]
	}).(UrlMapTestOutput)
}

// HTTP headers used in UrlMapTests.
type UrlMapTestHeader struct {
	// Header name.
	Name *string `pulumi:"name"`
	// Header value.
	Value *string `pulumi:"value"`
}

// UrlMapTestHeaderInput is an input type that accepts UrlMapTestHeaderArgs and UrlMapTestHeaderOutput values.
// You can construct a concrete instance of `UrlMapTestHeaderInput` via:
//
//	UrlMapTestHeaderArgs{...}
type UrlMapTestHeaderInput interface {
	pulumi.Input

	ToUrlMapTestHeaderOutput() UrlMapTestHeaderOutput
	ToUrlMapTestHeaderOutputWithContext(context.Context) UrlMapTestHeaderOutput
}

// HTTP headers used in UrlMapTests.
type UrlMapTestHeaderArgs struct {
	// Header name.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Header value.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (UrlMapTestHeaderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlMapTestHeader)(nil)).Elem()
}

func (i UrlMapTestHeaderArgs) ToUrlMapTestHeaderOutput() UrlMapTestHeaderOutput {
	return i.ToUrlMapTestHeaderOutputWithContext(context.Background())
}

func (i UrlMapTestHeaderArgs) ToUrlMapTestHeaderOutputWithContext(ctx context.Context) UrlMapTestHeaderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UrlMapTestHeaderOutput)
}

// UrlMapTestHeaderArrayInput is an input type that accepts UrlMapTestHeaderArray and UrlMapTestHeaderArrayOutput values.
// You can construct a concrete instance of `UrlMapTestHeaderArrayInput` via:
//
//	UrlMapTestHeaderArray{ UrlMapTestHeaderArgs{...} }
type UrlMapTestHeaderArrayInput interface {
	pulumi.Input

	ToUrlMapTestHeaderArrayOutput() UrlMapTestHeaderArrayOutput
	ToUrlMapTestHeaderArrayOutputWithContext(context.Context) UrlMapTestHeaderArrayOutput
}

type UrlMapTestHeaderArray []UrlMapTestHeaderInput

func (UrlMapTestHeaderArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UrlMapTestHeader)(nil)).Elem()
}

func (i UrlMapTestHeaderArray) ToUrlMapTestHeaderArrayOutput() UrlMapTestHeaderArrayOutput {
	return i.ToUrlMapTestHeaderArrayOutputWithContext(context.Background())
}

func (i UrlMapTestHeaderArray) ToUrlMapTestHeaderArrayOutputWithContext(ctx context.Context) UrlMapTestHeaderArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UrlMapTestHeaderArrayOutput)
}

// HTTP headers used in UrlMapTests.
type UrlMapTestHeaderOutput struct{ *pulumi.OutputState }

func (UrlMapTestHeaderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlMapTestHeader)(nil)).Elem()
}

func (o UrlMapTestHeaderOutput) ToUrlMapTestHeaderOutput() UrlMapTestHeaderOutput {
	return o
}

func (o UrlMapTestHeaderOutput) ToUrlMapTestHeaderOutputWithContext(ctx context.Context) UrlMapTestHeaderOutput {
	return o
}

// Header name.
func (o UrlMapTestHeaderOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlMapTestHeader) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Header value.
func (o UrlMapTestHeaderOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlMapTestHeader) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type UrlMapTestHeaderArrayOutput struct{ *pulumi.OutputState }

func (UrlMapTestHeaderArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UrlMapTestHeader)(nil)).Elem()
}

func (o UrlMapTestHeaderArrayOutput) ToUrlMapTestHeaderArrayOutput() UrlMapTestHeaderArrayOutput {
	return o
}

func (o UrlMapTestHeaderArrayOutput) ToUrlMapTestHeaderArrayOutputWithContext(ctx context.Context) UrlMapTestHeaderArrayOutput {
	return o
}

func (o UrlMapTestHeaderArrayOutput) Index(i pulumi.IntInput) UrlMapTestHeaderOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UrlMapTestHeader {
		return vs[0].([]UrlMapTestHeader)[vs[1].(int)]
	}).(UrlMapTestHeaderOutput)
}

// HTTP headers used in UrlMapTests.
type UrlMapTestHeaderResponse struct {
	// Header name.
	Name string `pulumi:"name"`
	// Header value.
	Value string `pulumi:"value"`
}

// HTTP headers used in UrlMapTests.
type UrlMapTestHeaderResponseOutput struct{ *pulumi.OutputState }

func (UrlMapTestHeaderResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlMapTestHeaderResponse)(nil)).Elem()
}

func (o UrlMapTestHeaderResponseOutput) ToUrlMapTestHeaderResponseOutput() UrlMapTestHeaderResponseOutput {
	return o
}

func (o UrlMapTestHeaderResponseOutput) ToUrlMapTestHeaderResponseOutputWithContext(ctx context.Context) UrlMapTestHeaderResponseOutput {
	return o
}

// Header name.
func (o UrlMapTestHeaderResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v UrlMapTestHeaderResponse) string { return v.Name }).(pulumi.StringOutput)
}

// Header value.
func (o UrlMapTestHeaderResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v UrlMapTestHeaderResponse) string { return v.Value }).(pulumi.StringOutput)
}

type UrlMapTestHeaderResponseArrayOutput struct{ *pulumi.OutputState }

func (UrlMapTestHeaderResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UrlMapTestHeaderResponse)(nil)).Elem()
}

func (o UrlMapTestHeaderResponseArrayOutput) ToUrlMapTestHeaderResponseArrayOutput() UrlMapTestHeaderResponseArrayOutput {
	return o
}

func (o UrlMapTestHeaderResponseArrayOutput) ToUrlMapTestHeaderResponseArrayOutputWithContext(ctx context.Context) UrlMapTestHeaderResponseArrayOutput {
	return o
}

func (o UrlMapTestHeaderResponseArrayOutput) Index(i pulumi.IntInput) UrlMapTestHeaderResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UrlMapTestHeaderResponse {
		return vs[0].([]UrlMapTestHeaderResponse)[vs[1].(int)]
	}).(UrlMapTestHeaderResponseOutput)
}

// Message for the expected URL mappings.
type UrlMapTestResponse struct {
	// Description of this test case.
	Description string `pulumi:"description"`
	// The expected output URL evaluated by the load balancer containing the scheme, host, path and query parameters. For rules that forward requests to backends, the test passes only when expectedOutputUrl matches the request forwarded by the load balancer to backends. For rules with urlRewrite, the test verifies that the forwarded request matches hostRewrite and pathPrefixRewrite in the urlRewrite action. When service is specified, expectedOutputUrl`s scheme is ignored. For rules with urlRedirect, the test passes only if expectedOutputUrl matches the URL in the load balancer's redirect response. If urlRedirect specifies https_redirect, the test passes only if the scheme in expectedOutputUrl is also set to HTTPS. If urlRedirect specifies strip_query, the test passes only if expectedOutputUrl does not contain any query parameters. expectedOutputUrl is optional when service is specified.
	ExpectedOutputUrl string `pulumi:"expectedOutputUrl"`
	// For rules with urlRedirect, the test passes only if expectedRedirectResponseCode matches the HTTP status code in load balancer's redirect response. expectedRedirectResponseCode cannot be set when service is set.
	ExpectedRedirectResponseCode int `pulumi:"expectedRedirectResponseCode"`
	// HTTP headers for this request. If headers contains a host header, then host must also match the header value.
	Headers []UrlMapTestHeaderResponse `pulumi:"headers"`
	// Host portion of the URL. If headers contains a host header, then host must also match the header value.
	Host string `pulumi:"host"`
	// Path portion of the URL.
	Path string `pulumi:"path"`
	// Expected BackendService or BackendBucket resource the given URL should be mapped to. The service field cannot be set if expectedRedirectResponseCode is set.
	Service string `pulumi:"service"`
}

// Message for the expected URL mappings.
type UrlMapTestResponseOutput struct{ *pulumi.OutputState }

func (UrlMapTestResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlMapTestResponse)(nil)).Elem()
}

func (o UrlMapTestResponseOutput) ToUrlMapTestResponseOutput() UrlMapTestResponseOutput {
	return o
}

func (o UrlMapTestResponseOutput) ToUrlMapTestResponseOutputWithContext(ctx context.Context) UrlMapTestResponseOutput {
	return o
}

// Description of this test case.
func (o UrlMapTestResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v UrlMapTestResponse) string { return v.Description }).(pulumi.StringOutput)
}

// The expected output URL evaluated by the load balancer containing the scheme, host, path and query parameters. For rules that forward requests to backends, the test passes only when expectedOutputUrl matches the request forwarded by the load balancer to backends. For rules with urlRewrite, the test verifies that the forwarded request matches hostRewrite and pathPrefixRewrite in the urlRewrite action. When service is specified, expectedOutputUrl`s scheme is ignored. For rules with urlRedirect, the test passes only if expectedOutputUrl matches the URL in the load balancer's redirect response. If urlRedirect specifies https_redirect, the test passes only if the scheme in expectedOutputUrl is also set to HTTPS. If urlRedirect specifies strip_query, the test passes only if expectedOutputUrl does not contain any query parameters. expectedOutputUrl is optional when service is specified.
func (o UrlMapTestResponseOutput) ExpectedOutputUrl() pulumi.StringOutput {
	return o.ApplyT(func(v UrlMapTestResponse) string { return v.ExpectedOutputUrl }).(pulumi.StringOutput)
}

// For rules with urlRedirect, the test passes only if expectedRedirectResponseCode matches the HTTP status code in load balancer's redirect response. expectedRedirectResponseCode cannot be set when service is set.
func (o UrlMapTestResponseOutput) ExpectedRedirectResponseCode() pulumi.IntOutput {
	return o.ApplyT(func(v UrlMapTestResponse) int { return v.ExpectedRedirectResponseCode }).(pulumi.IntOutput)
}

// HTTP headers for this request. If headers contains a host header, then host must also match the header value.
func (o UrlMapTestResponseOutput) Headers() UrlMapTestHeaderResponseArrayOutput {
	return o.ApplyT(func(v UrlMapTestResponse) []UrlMapTestHeaderResponse { return v.Headers }).(UrlMapTestHeaderResponseArrayOutput)
}

// Host portion of the URL. If headers contains a host header, then host must also match the header value.
func (o UrlMapTestResponseOutput) Host() pulumi.StringOutput {
	return o.ApplyT(func(v UrlMapTestResponse) string { return v.Host }).(pulumi.StringOutput)
}

// Path portion of the URL.
func (o UrlMapTestResponseOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v UrlMapTestResponse) string { return v.Path }).(pulumi.StringOutput)
}

// Expected BackendService or BackendBucket resource the given URL should be mapped to. The service field cannot be set if expectedRedirectResponseCode is set.
func (o UrlMapTestResponseOutput) Service() pulumi.StringOutput {
	return o.ApplyT(func(v UrlMapTestResponse) string { return v.Service }).(pulumi.StringOutput)
}

type UrlMapTestResponseArrayOutput struct{ *pulumi.OutputState }

func (UrlMapTestResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UrlMapTestResponse)(nil)).Elem()
}

func (o UrlMapTestResponseArrayOutput) ToUrlMapTestResponseArrayOutput() UrlMapTestResponseArrayOutput {
	return o
}

func (o UrlMapTestResponseArrayOutput) ToUrlMapTestResponseArrayOutputWithContext(ctx context.Context) UrlMapTestResponseArrayOutput {
	return o
}

func (o UrlMapTestResponseArrayOutput) Index(i pulumi.IntInput) UrlMapTestResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UrlMapTestResponse {
		return vs[0].([]UrlMapTestResponse)[vs[1].(int)]
	}).(UrlMapTestResponseOutput)
}

// The spec for modifying the path before sending the request to the matched backend service.
type UrlRewrite struct {
	// Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite. The value must be from 1 to 255 characters.
	HostRewrite *string `pulumi:"hostRewrite"`
	// Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite. The value must be from 1 to 1024 characters.
	PathPrefixRewrite *string `pulumi:"pathPrefixRewrite"`
	//  If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax. A corresponding path_template_match must be specified. Any template variables must exist in the path_template_match field. - -At least one variable must be specified in the path_template_match field - You can omit variables from the rewritten URL - The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}. For example, a path_template_match of /static/{format=**} could be rewritten as /static/content/{format} to prefix /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be rewritten as /content/{format}/{country}/{suffix}. At least one non-empty routeRules[].matchRules[].path_template_match is required. Only one of path_prefix_rewrite or path_template_rewrite may be specified.
	PathTemplateRewrite *string `pulumi:"pathTemplateRewrite"`
}

// UrlRewriteInput is an input type that accepts UrlRewriteArgs and UrlRewriteOutput values.
// You can construct a concrete instance of `UrlRewriteInput` via:
//
//	UrlRewriteArgs{...}
type UrlRewriteInput interface {
	pulumi.Input

	ToUrlRewriteOutput() UrlRewriteOutput
	ToUrlRewriteOutputWithContext(context.Context) UrlRewriteOutput
}

// The spec for modifying the path before sending the request to the matched backend service.
type UrlRewriteArgs struct {
	// Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite. The value must be from 1 to 255 characters.
	HostRewrite pulumi.StringPtrInput `pulumi:"hostRewrite"`
	// Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite. The value must be from 1 to 1024 characters.
	PathPrefixRewrite pulumi.StringPtrInput `pulumi:"pathPrefixRewrite"`
	//  If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax. A corresponding path_template_match must be specified. Any template variables must exist in the path_template_match field. - -At least one variable must be specified in the path_template_match field - You can omit variables from the rewritten URL - The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}. For example, a path_template_match of /static/{format=**} could be rewritten as /static/content/{format} to prefix /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be rewritten as /content/{format}/{country}/{suffix}. At least one non-empty routeRules[].matchRules[].path_template_match is required. Only one of path_prefix_rewrite or path_template_rewrite may be specified.
	PathTemplateRewrite pulumi.StringPtrInput `pulumi:"pathTemplateRewrite"`
}

func (UrlRewriteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlRewrite)(nil)).Elem()
}

func (i UrlRewriteArgs) ToUrlRewriteOutput() UrlRewriteOutput {
	return i.ToUrlRewriteOutputWithContext(context.Background())
}

func (i UrlRewriteArgs) ToUrlRewriteOutputWithContext(ctx context.Context) UrlRewriteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UrlRewriteOutput)
}

func (i UrlRewriteArgs) ToUrlRewritePtrOutput() UrlRewritePtrOutput {
	return i.ToUrlRewritePtrOutputWithContext(context.Background())
}

func (i UrlRewriteArgs) ToUrlRewritePtrOutputWithContext(ctx context.Context) UrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UrlRewriteOutput).ToUrlRewritePtrOutputWithContext(ctx)
}

// UrlRewritePtrInput is an input type that accepts UrlRewriteArgs, UrlRewritePtr and UrlRewritePtrOutput values.
// You can construct a concrete instance of `UrlRewritePtrInput` via:
//
//	        UrlRewriteArgs{...}
//
//	or:
//
//	        nil
type UrlRewritePtrInput interface {
	pulumi.Input

	ToUrlRewritePtrOutput() UrlRewritePtrOutput
	ToUrlRewritePtrOutputWithContext(context.Context) UrlRewritePtrOutput
}

type urlRewritePtrType UrlRewriteArgs

func UrlRewritePtr(v *UrlRewriteArgs) UrlRewritePtrInput {
	return (*urlRewritePtrType)(v)
}

func (*urlRewritePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UrlRewrite)(nil)).Elem()
}

func (i *urlRewritePtrType) ToUrlRewritePtrOutput() UrlRewritePtrOutput {
	return i.ToUrlRewritePtrOutputWithContext(context.Background())
}

func (i *urlRewritePtrType) ToUrlRewritePtrOutputWithContext(ctx context.Context) UrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UrlRewritePtrOutput)
}

// The spec for modifying the path before sending the request to the matched backend service.
type UrlRewriteOutput struct{ *pulumi.OutputState }

func (UrlRewriteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlRewrite)(nil)).Elem()
}

func (o UrlRewriteOutput) ToUrlRewriteOutput() UrlRewriteOutput {
	return o
}

func (o UrlRewriteOutput) ToUrlRewriteOutputWithContext(ctx context.Context) UrlRewriteOutput {
	return o
}

func (o UrlRewriteOutput) ToUrlRewritePtrOutput() UrlRewritePtrOutput {
	return o.ToUrlRewritePtrOutputWithContext(context.Background())
}

func (o UrlRewriteOutput) ToUrlRewritePtrOutputWithContext(ctx context.Context) UrlRewritePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UrlRewrite) *UrlRewrite {
		return &v
	}).(UrlRewritePtrOutput)
}

// Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite. The value must be from 1 to 255 characters.
func (o UrlRewriteOutput) HostRewrite() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlRewrite) *string { return v.HostRewrite }).(pulumi.StringPtrOutput)
}

// Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite. The value must be from 1 to 1024 characters.
func (o UrlRewriteOutput) PathPrefixRewrite() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlRewrite) *string { return v.PathPrefixRewrite }).(pulumi.StringPtrOutput)
}

// If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax. A corresponding path_template_match must be specified. Any template variables must exist in the path_template_match field. - -At least one variable must be specified in the path_template_match field - You can omit variables from the rewritten URL - The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}. For example, a path_template_match of /static/{format=**} could be rewritten as /static/content/{format} to prefix /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be rewritten as /content/{format}/{country}/{suffix}. At least one non-empty routeRules[].matchRules[].path_template_match is required. Only one of path_prefix_rewrite or path_template_rewrite may be specified.
func (o UrlRewriteOutput) PathTemplateRewrite() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlRewrite) *string { return v.PathTemplateRewrite }).(pulumi.StringPtrOutput)
}

type UrlRewritePtrOutput struct{ *pulumi.OutputState }

func (UrlRewritePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UrlRewrite)(nil)).Elem()
}

func (o UrlRewritePtrOutput) ToUrlRewritePtrOutput() UrlRewritePtrOutput {
	return o
}

func (o UrlRewritePtrOutput) ToUrlRewritePtrOutputWithContext(ctx context.Context) UrlRewritePtrOutput {
	return o
}

func (o UrlRewritePtrOutput) Elem() UrlRewriteOutput {
	return o.ApplyT(func(v *UrlRewrite) UrlRewrite {
		if v != nil {
			return *v
		}
		var ret UrlRewrite
		return ret
	}).(UrlRewriteOutput)
}

// Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite. The value must be from 1 to 255 characters.
func (o UrlRewritePtrOutput) HostRewrite() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UrlRewrite) *string {
		if v == nil {
			return nil
		}
		return v.HostRewrite
	}).(pulumi.StringPtrOutput)
}

// Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite. The value must be from 1 to 1024 characters.
func (o UrlRewritePtrOutput) PathPrefixRewrite() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UrlRewrite) *string {
		if v == nil {
			return nil
		}
		return v.PathPrefixRewrite
	}).(pulumi.StringPtrOutput)
}

// If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax. A corresponding path_template_match must be specified. Any template variables must exist in the path_template_match field. - -At least one variable must be specified in the path_template_match field - You can omit variables from the rewritten URL - The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}. For example, a path_template_match of /static/{format=**} could be rewritten as /static/content/{format} to prefix /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be rewritten as /content/{format}/{country}/{suffix}. At least one non-empty routeRules[].matchRules[].path_template_match is required. Only one of path_prefix_rewrite or path_template_rewrite may be specified.
func (o UrlRewritePtrOutput) PathTemplateRewrite() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UrlRewrite) *string {
		if v == nil {
			return nil
		}
		return v.PathTemplateRewrite
	}).(pulumi.StringPtrOutput)
}

// The spec for modifying the path before sending the request to the matched backend service.
type UrlRewriteResponse struct {
	// Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite. The value must be from 1 to 255 characters.
	HostRewrite string `pulumi:"hostRewrite"`
	// Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite. The value must be from 1 to 1024 characters.
	PathPrefixRewrite string `pulumi:"pathPrefixRewrite"`
	//  If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax. A corresponding path_template_match must be specified. Any template variables must exist in the path_template_match field. - -At least one variable must be specified in the path_template_match field - You can omit variables from the rewritten URL - The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}. For example, a path_template_match of /static/{format=**} could be rewritten as /static/content/{format} to prefix /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be rewritten as /content/{format}/{country}/{suffix}. At least one non-empty routeRules[].matchRules[].path_template_match is required. Only one of path_prefix_rewrite or path_template_rewrite may be specified.
	PathTemplateRewrite string `pulumi:"pathTemplateRewrite"`
}

// The spec for modifying the path before sending the request to the matched backend service.
type UrlRewriteResponseOutput struct{ *pulumi.OutputState }

func (UrlRewriteResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlRewriteResponse)(nil)).Elem()
}

func (o UrlRewriteResponseOutput) ToUrlRewriteResponseOutput() UrlRewriteResponseOutput {
	return o
}

func (o UrlRewriteResponseOutput) ToUrlRewriteResponseOutputWithContext(ctx context.Context) UrlRewriteResponseOutput {
	return o
}

// Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite. The value must be from 1 to 255 characters.
func (o UrlRewriteResponseOutput) HostRewrite() pulumi.StringOutput {
	return o.ApplyT(func(v UrlRewriteResponse) string { return v.HostRewrite }).(pulumi.StringOutput)
}

// Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite. The value must be from 1 to 1024 characters.
func (o UrlRewriteResponseOutput) PathPrefixRewrite() pulumi.StringOutput {
	return o.ApplyT(func(v UrlRewriteResponse) string { return v.PathPrefixRewrite }).(pulumi.StringOutput)
}

// If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax. A corresponding path_template_match must be specified. Any template variables must exist in the path_template_match field. - -At least one variable must be specified in the path_template_match field - You can omit variables from the rewritten URL - The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}. For example, a path_template_match of /static/{format=**} could be rewritten as /static/content/{format} to prefix /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be rewritten as /content/{format}/{country}/{suffix}. At least one non-empty routeRules[].matchRules[].path_template_match is required. Only one of path_prefix_rewrite or path_template_rewrite may be specified.
func (o UrlRewriteResponseOutput) PathTemplateRewrite() pulumi.StringOutput {
	return o.ApplyT(func(v UrlRewriteResponse) string { return v.PathTemplateRewrite }).(pulumi.StringOutput)
}

// A VPN gateway interface.
type VpnGatewayVpnGatewayInterface struct {
	// URL of the VLAN attachment (interconnectAttachment) resource for this VPN gateway interface. When the value of this field is present, the VPN gateway is used for HA VPN over Cloud Interconnect; all egress or ingress traffic for this VPN gateway interface goes through the specified VLAN attachment resource.
	InterconnectAttachment *string `pulumi:"interconnectAttachment"`
}

// VpnGatewayVpnGatewayInterfaceInput is an input type that accepts VpnGatewayVpnGatewayInterfaceArgs and VpnGatewayVpnGatewayInterfaceOutput values.
// You can construct a concrete instance of `VpnGatewayVpnGatewayInterfaceInput` via:
//
//	VpnGatewayVpnGatewayInterfaceArgs{...}
type VpnGatewayVpnGatewayInterfaceInput interface {
	pulumi.Input

	ToVpnGatewayVpnGatewayInterfaceOutput() VpnGatewayVpnGatewayInterfaceOutput
	ToVpnGatewayVpnGatewayInterfaceOutputWithContext(context.Context) VpnGatewayVpnGatewayInterfaceOutput
}

// A VPN gateway interface.
type VpnGatewayVpnGatewayInterfaceArgs struct {
	// URL of the VLAN attachment (interconnectAttachment) resource for this VPN gateway interface. When the value of this field is present, the VPN gateway is used for HA VPN over Cloud Interconnect; all egress or ingress traffic for this VPN gateway interface goes through the specified VLAN attachment resource.
	InterconnectAttachment pulumi.StringPtrInput `pulumi:"interconnectAttachment"`
}

func (VpnGatewayVpnGatewayInterfaceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VpnGatewayVpnGatewayInterface)(nil)).Elem()
}

func (i VpnGatewayVpnGatewayInterfaceArgs) ToVpnGatewayVpnGatewayInterfaceOutput() VpnGatewayVpnGatewayInterfaceOutput {
	return i.ToVpnGatewayVpnGatewayInterfaceOutputWithContext(context.Background())
}

func (i VpnGatewayVpnGatewayInterfaceArgs) ToVpnGatewayVpnGatewayInterfaceOutputWithContext(ctx context.Context) VpnGatewayVpnGatewayInterfaceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpnGatewayVpnGatewayInterfaceOutput)
}

// VpnGatewayVpnGatewayInterfaceArrayInput is an input type that accepts VpnGatewayVpnGatewayInterfaceArray and VpnGatewayVpnGatewayInterfaceArrayOutput values.
// You can construct a concrete instance of `VpnGatewayVpnGatewayInterfaceArrayInput` via:
//
//	VpnGatewayVpnGatewayInterfaceArray{ VpnGatewayVpnGatewayInterfaceArgs{...} }
type VpnGatewayVpnGatewayInterfaceArrayInput interface {
	pulumi.Input

	ToVpnGatewayVpnGatewayInterfaceArrayOutput() VpnGatewayVpnGatewayInterfaceArrayOutput
	ToVpnGatewayVpnGatewayInterfaceArrayOutputWithContext(context.Context) VpnGatewayVpnGatewayInterfaceArrayOutput
}

type VpnGatewayVpnGatewayInterfaceArray []VpnGatewayVpnGatewayInterfaceInput

func (VpnGatewayVpnGatewayInterfaceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VpnGatewayVpnGatewayInterface)(nil)).Elem()
}

func (i VpnGatewayVpnGatewayInterfaceArray) ToVpnGatewayVpnGatewayInterfaceArrayOutput() VpnGatewayVpnGatewayInterfaceArrayOutput {
	return i.ToVpnGatewayVpnGatewayInterfaceArrayOutputWithContext(context.Background())
}

func (i VpnGatewayVpnGatewayInterfaceArray) ToVpnGatewayVpnGatewayInterfaceArrayOutputWithContext(ctx context.Context) VpnGatewayVpnGatewayInterfaceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpnGatewayVpnGatewayInterfaceArrayOutput)
}

// A VPN gateway interface.
type VpnGatewayVpnGatewayInterfaceOutput struct{ *pulumi.OutputState }

func (VpnGatewayVpnGatewayInterfaceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VpnGatewayVpnGatewayInterface)(nil)).Elem()
}

func (o VpnGatewayVpnGatewayInterfaceOutput) ToVpnGatewayVpnGatewayInterfaceOutput() VpnGatewayVpnGatewayInterfaceOutput {
	return o
}

func (o VpnGatewayVpnGatewayInterfaceOutput) ToVpnGatewayVpnGatewayInterfaceOutputWithContext(ctx context.Context) VpnGatewayVpnGatewayInterfaceOutput {
	return o
}

// URL of the VLAN attachment (interconnectAttachment) resource for this VPN gateway interface. When the value of this field is present, the VPN gateway is used for HA VPN over Cloud Interconnect; all egress or ingress traffic for this VPN gateway interface goes through the specified VLAN attachment resource.
func (o VpnGatewayVpnGatewayInterfaceOutput) InterconnectAttachment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpnGatewayVpnGatewayInterface) *string { return v.InterconnectAttachment }).(pulumi.StringPtrOutput)
}

type VpnGatewayVpnGatewayInterfaceArrayOutput struct{ *pulumi.OutputState }

func (VpnGatewayVpnGatewayInterfaceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VpnGatewayVpnGatewayInterface)(nil)).Elem()
}

func (o VpnGatewayVpnGatewayInterfaceArrayOutput) ToVpnGatewayVpnGatewayInterfaceArrayOutput() VpnGatewayVpnGatewayInterfaceArrayOutput {
	return o
}

func (o VpnGatewayVpnGatewayInterfaceArrayOutput) ToVpnGatewayVpnGatewayInterfaceArrayOutputWithContext(ctx context.Context) VpnGatewayVpnGatewayInterfaceArrayOutput {
	return o
}

func (o VpnGatewayVpnGatewayInterfaceArrayOutput) Index(i pulumi.IntInput) VpnGatewayVpnGatewayInterfaceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VpnGatewayVpnGatewayInterface {
		return vs[0].([]VpnGatewayVpnGatewayInterface)[vs[1].(int)]
	}).(VpnGatewayVpnGatewayInterfaceOutput)
}

// A VPN gateway interface.
type VpnGatewayVpnGatewayInterfaceResponse struct {
	// URL of the VLAN attachment (interconnectAttachment) resource for this VPN gateway interface. When the value of this field is present, the VPN gateway is used for HA VPN over Cloud Interconnect; all egress or ingress traffic for this VPN gateway interface goes through the specified VLAN attachment resource.
	InterconnectAttachment string `pulumi:"interconnectAttachment"`
	// IP address for this VPN interface associated with the VPN gateway. The IP address could be either a regional external IP address or a regional internal IP address. The two IP addresses for a VPN gateway must be all regional external or regional internal IP addresses. There cannot be a mix of regional external IP addresses and regional internal IP addresses. For HA VPN over Cloud Interconnect, the IP addresses for both interfaces could either be regional internal IP addresses or regional external IP addresses. For regular (non HA VPN over Cloud Interconnect) HA VPN tunnels, the IP address must be a regional external IP address.
	IpAddress string `pulumi:"ipAddress"`
	// IPv6 address for this VPN interface associated with the VPN gateway. The IPv6 address must be a regional external IPv6 address. The format is RFC 5952 format (e.g. 2001:db8::2d9:51:0:0).
	Ipv6Address string `pulumi:"ipv6Address"`
}

// A VPN gateway interface.
type VpnGatewayVpnGatewayInterfaceResponseOutput struct{ *pulumi.OutputState }

func (VpnGatewayVpnGatewayInterfaceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VpnGatewayVpnGatewayInterfaceResponse)(nil)).Elem()
}

func (o VpnGatewayVpnGatewayInterfaceResponseOutput) ToVpnGatewayVpnGatewayInterfaceResponseOutput() VpnGatewayVpnGatewayInterfaceResponseOutput {
	return o
}

func (o VpnGatewayVpnGatewayInterfaceResponseOutput) ToVpnGatewayVpnGatewayInterfaceResponseOutputWithContext(ctx context.Context) VpnGatewayVpnGatewayInterfaceResponseOutput {
	return o
}

// URL of the VLAN attachment (interconnectAttachment) resource for this VPN gateway interface. When the value of this field is present, the VPN gateway is used for HA VPN over Cloud Interconnect; all egress or ingress traffic for this VPN gateway interface goes through the specified VLAN attachment resource.
func (o VpnGatewayVpnGatewayInterfaceResponseOutput) InterconnectAttachment() pulumi.StringOutput {
	return o.ApplyT(func(v VpnGatewayVpnGatewayInterfaceResponse) string { return v.InterconnectAttachment }).(pulumi.StringOutput)
}

// IP address for this VPN interface associated with the VPN gateway. The IP address could be either a regional external IP address or a regional internal IP address. The two IP addresses for a VPN gateway must be all regional external or regional internal IP addresses. There cannot be a mix of regional external IP addresses and regional internal IP addresses. For HA VPN over Cloud Interconnect, the IP addresses for both interfaces could either be regional internal IP addresses or regional external IP addresses. For regular (non HA VPN over Cloud Interconnect) HA VPN tunnels, the IP address must be a regional external IP address.
func (o VpnGatewayVpnGatewayInterfaceResponseOutput) IpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v VpnGatewayVpnGatewayInterfaceResponse) string { return v.IpAddress }).(pulumi.StringOutput)
}

// IPv6 address for this VPN interface associated with the VPN gateway. The IPv6 address must be a regional external IPv6 address. The format is RFC 5952 format (e.g. 2001:db8::2d9:51:0:0).
func (o VpnGatewayVpnGatewayInterfaceResponseOutput) Ipv6Address() pulumi.StringOutput {
	return o.ApplyT(func(v VpnGatewayVpnGatewayInterfaceResponse) string { return v.Ipv6Address }).(pulumi.StringOutput)
}

type VpnGatewayVpnGatewayInterfaceResponseArrayOutput struct{ *pulumi.OutputState }

func (VpnGatewayVpnGatewayInterfaceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VpnGatewayVpnGatewayInterfaceResponse)(nil)).Elem()
}

func (o VpnGatewayVpnGatewayInterfaceResponseArrayOutput) ToVpnGatewayVpnGatewayInterfaceResponseArrayOutput() VpnGatewayVpnGatewayInterfaceResponseArrayOutput {
	return o
}

func (o VpnGatewayVpnGatewayInterfaceResponseArrayOutput) ToVpnGatewayVpnGatewayInterfaceResponseArrayOutputWithContext(ctx context.Context) VpnGatewayVpnGatewayInterfaceResponseArrayOutput {
	return o
}

func (o VpnGatewayVpnGatewayInterfaceResponseArrayOutput) Index(i pulumi.IntInput) VpnGatewayVpnGatewayInterfaceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VpnGatewayVpnGatewayInterfaceResponse {
		return vs[0].([]VpnGatewayVpnGatewayInterfaceResponse)[vs[1].(int)]
	}).(VpnGatewayVpnGatewayInterfaceResponseOutput)
}

// In contrast to a single BackendService in HttpRouteAction to which all matching traffic is directed to, WeightedBackendService allows traffic to be split across multiple backend services. The volume of traffic for each backend service is proportional to the weight specified in each WeightedBackendService
type WeightedBackendService struct {
	// The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
	BackendService *string `pulumi:"backendService"`
	// Specifies changes to request and response headers that need to take effect for the selected backendService. headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap. headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL. Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
	HeaderAction *HttpHeaderAction `pulumi:"headerAction"`
	// Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) . The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy. The value must be from 0 to 1000.
	Weight *int `pulumi:"weight"`
}

// WeightedBackendServiceInput is an input type that accepts WeightedBackendServiceArgs and WeightedBackendServiceOutput values.
// You can construct a concrete instance of `WeightedBackendServiceInput` via:
//
//	WeightedBackendServiceArgs{...}
type WeightedBackendServiceInput interface {
	pulumi.Input

	ToWeightedBackendServiceOutput() WeightedBackendServiceOutput
	ToWeightedBackendServiceOutputWithContext(context.Context) WeightedBackendServiceOutput
}

// In contrast to a single BackendService in HttpRouteAction to which all matching traffic is directed to, WeightedBackendService allows traffic to be split across multiple backend services. The volume of traffic for each backend service is proportional to the weight specified in each WeightedBackendService
type WeightedBackendServiceArgs struct {
	// The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
	BackendService pulumi.StringPtrInput `pulumi:"backendService"`
	// Specifies changes to request and response headers that need to take effect for the selected backendService. headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap. headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL. Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
	HeaderAction HttpHeaderActionPtrInput `pulumi:"headerAction"`
	// Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) . The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy. The value must be from 0 to 1000.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (WeightedBackendServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WeightedBackendService)(nil)).Elem()
}

func (i WeightedBackendServiceArgs) ToWeightedBackendServiceOutput() WeightedBackendServiceOutput {
	return i.ToWeightedBackendServiceOutputWithContext(context.Background())
}

func (i WeightedBackendServiceArgs) ToWeightedBackendServiceOutputWithContext(ctx context.Context) WeightedBackendServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WeightedBackendServiceOutput)
}

// WeightedBackendServiceArrayInput is an input type that accepts WeightedBackendServiceArray and WeightedBackendServiceArrayOutput values.
// You can construct a concrete instance of `WeightedBackendServiceArrayInput` via:
//
//	WeightedBackendServiceArray{ WeightedBackendServiceArgs{...} }
type WeightedBackendServiceArrayInput interface {
	pulumi.Input

	ToWeightedBackendServiceArrayOutput() WeightedBackendServiceArrayOutput
	ToWeightedBackendServiceArrayOutputWithContext(context.Context) WeightedBackendServiceArrayOutput
}

type WeightedBackendServiceArray []WeightedBackendServiceInput

func (WeightedBackendServiceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WeightedBackendService)(nil)).Elem()
}

func (i WeightedBackendServiceArray) ToWeightedBackendServiceArrayOutput() WeightedBackendServiceArrayOutput {
	return i.ToWeightedBackendServiceArrayOutputWithContext(context.Background())
}

func (i WeightedBackendServiceArray) ToWeightedBackendServiceArrayOutputWithContext(ctx context.Context) WeightedBackendServiceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WeightedBackendServiceArrayOutput)
}

// In contrast to a single BackendService in HttpRouteAction to which all matching traffic is directed to, WeightedBackendService allows traffic to be split across multiple backend services. The volume of traffic for each backend service is proportional to the weight specified in each WeightedBackendService
type WeightedBackendServiceOutput struct{ *pulumi.OutputState }

func (WeightedBackendServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WeightedBackendService)(nil)).Elem()
}

func (o WeightedBackendServiceOutput) ToWeightedBackendServiceOutput() WeightedBackendServiceOutput {
	return o
}

func (o WeightedBackendServiceOutput) ToWeightedBackendServiceOutputWithContext(ctx context.Context) WeightedBackendServiceOutput {
	return o
}

// The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
func (o WeightedBackendServiceOutput) BackendService() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WeightedBackendService) *string { return v.BackendService }).(pulumi.StringPtrOutput)
}

// Specifies changes to request and response headers that need to take effect for the selected backendService. headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap. headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL. Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
func (o WeightedBackendServiceOutput) HeaderAction() HttpHeaderActionPtrOutput {
	return o.ApplyT(func(v WeightedBackendService) *HttpHeaderAction { return v.HeaderAction }).(HttpHeaderActionPtrOutput)
}

// Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) . The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy. The value must be from 0 to 1000.
func (o WeightedBackendServiceOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v WeightedBackendService) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type WeightedBackendServiceArrayOutput struct{ *pulumi.OutputState }

func (WeightedBackendServiceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WeightedBackendService)(nil)).Elem()
}

func (o WeightedBackendServiceArrayOutput) ToWeightedBackendServiceArrayOutput() WeightedBackendServiceArrayOutput {
	return o
}

func (o WeightedBackendServiceArrayOutput) ToWeightedBackendServiceArrayOutputWithContext(ctx context.Context) WeightedBackendServiceArrayOutput {
	return o
}

func (o WeightedBackendServiceArrayOutput) Index(i pulumi.IntInput) WeightedBackendServiceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WeightedBackendService {
		return vs[0].([]WeightedBackendService)[vs[1].(int)]
	}).(WeightedBackendServiceOutput)
}

// In contrast to a single BackendService in HttpRouteAction to which all matching traffic is directed to, WeightedBackendService allows traffic to be split across multiple backend services. The volume of traffic for each backend service is proportional to the weight specified in each WeightedBackendService
type WeightedBackendServiceResponse struct {
	// The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
	BackendService string `pulumi:"backendService"`
	// Specifies changes to request and response headers that need to take effect for the selected backendService. headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap. headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL. Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
	HeaderAction HttpHeaderActionResponse `pulumi:"headerAction"`
	// Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) . The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy. The value must be from 0 to 1000.
	Weight int `pulumi:"weight"`
}

// In contrast to a single BackendService in HttpRouteAction to which all matching traffic is directed to, WeightedBackendService allows traffic to be split across multiple backend services. The volume of traffic for each backend service is proportional to the weight specified in each WeightedBackendService
type WeightedBackendServiceResponseOutput struct{ *pulumi.OutputState }

func (WeightedBackendServiceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WeightedBackendServiceResponse)(nil)).Elem()
}

func (o WeightedBackendServiceResponseOutput) ToWeightedBackendServiceResponseOutput() WeightedBackendServiceResponseOutput {
	return o
}

func (o WeightedBackendServiceResponseOutput) ToWeightedBackendServiceResponseOutputWithContext(ctx context.Context) WeightedBackendServiceResponseOutput {
	return o
}

// The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
func (o WeightedBackendServiceResponseOutput) BackendService() pulumi.StringOutput {
	return o.ApplyT(func(v WeightedBackendServiceResponse) string { return v.BackendService }).(pulumi.StringOutput)
}

// Specifies changes to request and response headers that need to take effect for the selected backendService. headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap. headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL. Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
func (o WeightedBackendServiceResponseOutput) HeaderAction() HttpHeaderActionResponseOutput {
	return o.ApplyT(func(v WeightedBackendServiceResponse) HttpHeaderActionResponse { return v.HeaderAction }).(HttpHeaderActionResponseOutput)
}

// Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) . The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy. The value must be from 0 to 1000.
func (o WeightedBackendServiceResponseOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v WeightedBackendServiceResponse) int { return v.Weight }).(pulumi.IntOutput)
}

type WeightedBackendServiceResponseArrayOutput struct{ *pulumi.OutputState }

func (WeightedBackendServiceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WeightedBackendServiceResponse)(nil)).Elem()
}

func (o WeightedBackendServiceResponseArrayOutput) ToWeightedBackendServiceResponseArrayOutput() WeightedBackendServiceResponseArrayOutput {
	return o
}

func (o WeightedBackendServiceResponseArrayOutput) ToWeightedBackendServiceResponseArrayOutputWithContext(ctx context.Context) WeightedBackendServiceResponseArrayOutput {
	return o
}

func (o WeightedBackendServiceResponseArrayOutput) Index(i pulumi.IntInput) WeightedBackendServiceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WeightedBackendServiceResponse {
		return vs[0].([]WeightedBackendServiceResponse)[vs[1].(int)]
	}).(WeightedBackendServiceResponseOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SubnetworkLogConfigInput)(nil)).Elem(), SubnetworkLogConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubnetworkLogConfigPtrInput)(nil)).Elem(), SubnetworkLogConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubnetworkSecondaryRangeInput)(nil)).Elem(), SubnetworkSecondaryRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubnetworkSecondaryRangeArrayInput)(nil)).Elem(), SubnetworkSecondaryRangeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubsettingInput)(nil)).Elem(), SubsettingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubsettingPtrInput)(nil)).Elem(), SubsettingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPHealthCheckInput)(nil)).Elem(), TCPHealthCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPHealthCheckPtrInput)(nil)).Elem(), TCPHealthCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsInput)(nil)).Elem(), TagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagsPtrInput)(nil)).Elem(), TagsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UrlMapTestInput)(nil)).Elem(), UrlMapTestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UrlMapTestArrayInput)(nil)).Elem(), UrlMapTestArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UrlMapTestHeaderInput)(nil)).Elem(), UrlMapTestHeaderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UrlMapTestHeaderArrayInput)(nil)).Elem(), UrlMapTestHeaderArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UrlRewriteInput)(nil)).Elem(), UrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UrlRewritePtrInput)(nil)).Elem(), UrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpnGatewayVpnGatewayInterfaceInput)(nil)).Elem(), VpnGatewayVpnGatewayInterfaceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpnGatewayVpnGatewayInterfaceArrayInput)(nil)).Elem(), VpnGatewayVpnGatewayInterfaceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WeightedBackendServiceInput)(nil)).Elem(), WeightedBackendServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WeightedBackendServiceArrayInput)(nil)).Elem(), WeightedBackendServiceArray{})
	pulumi.RegisterOutputType(StatefulPolicyPreservedStateNetworkIpResponseOutput{})
	pulumi.RegisterOutputType(StatefulPolicyPreservedStateResponseOutput{})
	pulumi.RegisterOutputType(StatefulPolicyResponseOutput{})
	pulumi.RegisterOutputType(SubnetworkLogConfigOutput{})
	pulumi.RegisterOutputType(SubnetworkLogConfigPtrOutput{})
	pulumi.RegisterOutputType(SubnetworkLogConfigResponseOutput{})
	pulumi.RegisterOutputType(SubnetworkSecondaryRangeOutput{})
	pulumi.RegisterOutputType(SubnetworkSecondaryRangeArrayOutput{})
	pulumi.RegisterOutputType(SubnetworkSecondaryRangeResponseOutput{})
	pulumi.RegisterOutputType(SubnetworkSecondaryRangeResponseArrayOutput{})
	pulumi.RegisterOutputType(SubsettingOutput{})
	pulumi.RegisterOutputType(SubsettingPtrOutput{})
	pulumi.RegisterOutputType(SubsettingResponseOutput{})
	pulumi.RegisterOutputType(TCPHealthCheckOutput{})
	pulumi.RegisterOutputType(TCPHealthCheckPtrOutput{})
	pulumi.RegisterOutputType(TCPHealthCheckResponseOutput{})
	pulumi.RegisterOutputType(TagsOutput{})
	pulumi.RegisterOutputType(TagsPtrOutput{})
	pulumi.RegisterOutputType(TagsResponseOutput{})
	pulumi.RegisterOutputType(Uint128ResponseOutput{})
	pulumi.RegisterOutputType(UpcomingMaintenanceResponseOutput{})
	pulumi.RegisterOutputType(UrlMapTestOutput{})
	pulumi.RegisterOutputType(UrlMapTestArrayOutput{})
	pulumi.RegisterOutputType(UrlMapTestHeaderOutput{})
	pulumi.RegisterOutputType(UrlMapTestHeaderArrayOutput{})
	pulumi.RegisterOutputType(UrlMapTestHeaderResponseOutput{})
	pulumi.RegisterOutputType(UrlMapTestHeaderResponseArrayOutput{})
	pulumi.RegisterOutputType(UrlMapTestResponseOutput{})
	pulumi.RegisterOutputType(UrlMapTestResponseArrayOutput{})
	pulumi.RegisterOutputType(UrlRewriteOutput{})
	pulumi.RegisterOutputType(UrlRewritePtrOutput{})
	pulumi.RegisterOutputType(UrlRewriteResponseOutput{})
	pulumi.RegisterOutputType(VpnGatewayVpnGatewayInterfaceOutput{})
	pulumi.RegisterOutputType(VpnGatewayVpnGatewayInterfaceArrayOutput{})
	pulumi.RegisterOutputType(VpnGatewayVpnGatewayInterfaceResponseOutput{})
	pulumi.RegisterOutputType(VpnGatewayVpnGatewayInterfaceResponseArrayOutput{})
	pulumi.RegisterOutputType(WeightedBackendServiceOutput{})
	pulumi.RegisterOutputType(WeightedBackendServiceArrayOutput{})
	pulumi.RegisterOutputType(WeightedBackendServiceResponseOutput{})
	pulumi.RegisterOutputType(WeightedBackendServiceResponseArrayOutput{})
}

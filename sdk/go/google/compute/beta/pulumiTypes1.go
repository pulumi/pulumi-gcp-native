// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package beta

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

var _ = internal.GetEnvOrDefault

// A set of instance tags.
type TagsResponse struct {
	// Specifies a fingerprint for this request, which is essentially a hash of the tags' contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update tags. You must always provide an up-to-date fingerprint hash in order to update or change tags. To see the latest fingerprint, make get() request to the instance.
	Fingerprint string `pulumi:"fingerprint"`
	// An array of tags. Each tag must be 1-63 characters long, and comply with RFC1035.
	Items []string `pulumi:"items"`
}

// A set of instance tags.
type TagsResponseOutput struct{ *pulumi.OutputState }

func (TagsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagsResponse)(nil)).Elem()
}

func (o TagsResponseOutput) ToTagsResponseOutput() TagsResponseOutput {
	return o
}

func (o TagsResponseOutput) ToTagsResponseOutputWithContext(ctx context.Context) TagsResponseOutput {
	return o
}

func (o TagsResponseOutput) ToOutput(ctx context.Context) pulumix.Output[TagsResponse] {
	return pulumix.Output[TagsResponse]{
		OutputState: o.OutputState,
	}
}

// Specifies a fingerprint for this request, which is essentially a hash of the tags' contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update tags. You must always provide an up-to-date fingerprint hash in order to update or change tags. To see the latest fingerprint, make get() request to the instance.
func (o TagsResponseOutput) Fingerprint() pulumi.StringOutput {
	return o.ApplyT(func(v TagsResponse) string { return v.Fingerprint }).(pulumi.StringOutput)
}

// An array of tags. Each tag must be 1-63 characters long, and comply with RFC1035.
func (o TagsResponseOutput) Items() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagsResponse) []string { return v.Items }).(pulumi.StringArrayOutput)
}

type Uint128Response struct {
	High string `pulumi:"high"`
	Low  string `pulumi:"low"`
}

type Uint128ResponseOutput struct{ *pulumi.OutputState }

func (Uint128ResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Uint128Response)(nil)).Elem()
}

func (o Uint128ResponseOutput) ToUint128ResponseOutput() Uint128ResponseOutput {
	return o
}

func (o Uint128ResponseOutput) ToUint128ResponseOutputWithContext(ctx context.Context) Uint128ResponseOutput {
	return o
}

func (o Uint128ResponseOutput) ToOutput(ctx context.Context) pulumix.Output[Uint128Response] {
	return pulumix.Output[Uint128Response]{
		OutputState: o.OutputState,
	}
}

func (o Uint128ResponseOutput) High() pulumi.StringOutput {
	return o.ApplyT(func(v Uint128Response) string { return v.High }).(pulumi.StringOutput)
}

func (o Uint128ResponseOutput) Low() pulumi.StringOutput {
	return o.ApplyT(func(v Uint128Response) string { return v.Low }).(pulumi.StringOutput)
}

// Upcoming Maintenance notification information.
type UpcomingMaintenanceResponse struct {
	// Indicates if the maintenance can be customer triggered.
	CanReschedule bool `pulumi:"canReschedule"`
	// The latest time for the planned maintenance window to start. This timestamp value is in RFC3339 text format.
	LatestWindowStartTime string `pulumi:"latestWindowStartTime"`
	MaintenanceStatus     string `pulumi:"maintenanceStatus"`
	// Defines the type of maintenance.
	Type string `pulumi:"type"`
	// The time by which the maintenance disruption will be completed. This timestamp value is in RFC3339 text format.
	WindowEndTime string `pulumi:"windowEndTime"`
	// The current start time of the maintenance window. This timestamp value is in RFC3339 text format.
	WindowStartTime string `pulumi:"windowStartTime"`
}

// Upcoming Maintenance notification information.
type UpcomingMaintenanceResponseOutput struct{ *pulumi.OutputState }

func (UpcomingMaintenanceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UpcomingMaintenanceResponse)(nil)).Elem()
}

func (o UpcomingMaintenanceResponseOutput) ToUpcomingMaintenanceResponseOutput() UpcomingMaintenanceResponseOutput {
	return o
}

func (o UpcomingMaintenanceResponseOutput) ToUpcomingMaintenanceResponseOutputWithContext(ctx context.Context) UpcomingMaintenanceResponseOutput {
	return o
}

func (o UpcomingMaintenanceResponseOutput) ToOutput(ctx context.Context) pulumix.Output[UpcomingMaintenanceResponse] {
	return pulumix.Output[UpcomingMaintenanceResponse]{
		OutputState: o.OutputState,
	}
}

// Indicates if the maintenance can be customer triggered.
func (o UpcomingMaintenanceResponseOutput) CanReschedule() pulumi.BoolOutput {
	return o.ApplyT(func(v UpcomingMaintenanceResponse) bool { return v.CanReschedule }).(pulumi.BoolOutput)
}

// The latest time for the planned maintenance window to start. This timestamp value is in RFC3339 text format.
func (o UpcomingMaintenanceResponseOutput) LatestWindowStartTime() pulumi.StringOutput {
	return o.ApplyT(func(v UpcomingMaintenanceResponse) string { return v.LatestWindowStartTime }).(pulumi.StringOutput)
}

func (o UpcomingMaintenanceResponseOutput) MaintenanceStatus() pulumi.StringOutput {
	return o.ApplyT(func(v UpcomingMaintenanceResponse) string { return v.MaintenanceStatus }).(pulumi.StringOutput)
}

// Defines the type of maintenance.
func (o UpcomingMaintenanceResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v UpcomingMaintenanceResponse) string { return v.Type }).(pulumi.StringOutput)
}

// The time by which the maintenance disruption will be completed. This timestamp value is in RFC3339 text format.
func (o UpcomingMaintenanceResponseOutput) WindowEndTime() pulumi.StringOutput {
	return o.ApplyT(func(v UpcomingMaintenanceResponse) string { return v.WindowEndTime }).(pulumi.StringOutput)
}

// The current start time of the maintenance window. This timestamp value is in RFC3339 text format.
func (o UpcomingMaintenanceResponseOutput) WindowStartTime() pulumi.StringOutput {
	return o.ApplyT(func(v UpcomingMaintenanceResponse) string { return v.WindowStartTime }).(pulumi.StringOutput)
}

// Message for the expected URL mappings.
type UrlMapTest struct {
	// Description of this test case.
	Description *string `pulumi:"description"`
	// The expected output URL evaluated by the load balancer containing the scheme, host, path and query parameters. For rules that forward requests to backends, the test passes only when expectedOutputUrl matches the request forwarded by the load balancer to backends. For rules with urlRewrite, the test verifies that the forwarded request matches hostRewrite and pathPrefixRewrite in the urlRewrite action. When service is specified, expectedOutputUrl`s scheme is ignored. For rules with urlRedirect, the test passes only if expectedOutputUrl matches the URL in the load balancer's redirect response. If urlRedirect specifies https_redirect, the test passes only if the scheme in expectedOutputUrl is also set to HTTPS. If urlRedirect specifies strip_query, the test passes only if expectedOutputUrl does not contain any query parameters. expectedOutputUrl is optional when service is specified.
	ExpectedOutputUrl *string `pulumi:"expectedOutputUrl"`
	// For rules with urlRedirect, the test passes only if expectedRedirectResponseCode matches the HTTP status code in load balancer's redirect response. expectedRedirectResponseCode cannot be set when service is set.
	ExpectedRedirectResponseCode *int `pulumi:"expectedRedirectResponseCode"`
	// HTTP headers for this request. If headers contains a host header, then host must also match the header value.
	Headers []UrlMapTestHeader `pulumi:"headers"`
	// Host portion of the URL. If headers contains a host header, then host must also match the header value.
	Host *string `pulumi:"host"`
	// Path portion of the URL.
	Path *string `pulumi:"path"`
	// Expected BackendService or BackendBucket resource the given URL should be mapped to. The service field cannot be set if expectedRedirectResponseCode is set.
	Service *string `pulumi:"service"`
}

// UrlMapTestInput is an input type that accepts UrlMapTestArgs and UrlMapTestOutput values.
// You can construct a concrete instance of `UrlMapTestInput` via:
//
//	UrlMapTestArgs{...}
type UrlMapTestInput interface {
	pulumi.Input

	ToUrlMapTestOutput() UrlMapTestOutput
	ToUrlMapTestOutputWithContext(context.Context) UrlMapTestOutput
}

// Message for the expected URL mappings.
type UrlMapTestArgs struct {
	// Description of this test case.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// The expected output URL evaluated by the load balancer containing the scheme, host, path and query parameters. For rules that forward requests to backends, the test passes only when expectedOutputUrl matches the request forwarded by the load balancer to backends. For rules with urlRewrite, the test verifies that the forwarded request matches hostRewrite and pathPrefixRewrite in the urlRewrite action. When service is specified, expectedOutputUrl`s scheme is ignored. For rules with urlRedirect, the test passes only if expectedOutputUrl matches the URL in the load balancer's redirect response. If urlRedirect specifies https_redirect, the test passes only if the scheme in expectedOutputUrl is also set to HTTPS. If urlRedirect specifies strip_query, the test passes only if expectedOutputUrl does not contain any query parameters. expectedOutputUrl is optional when service is specified.
	ExpectedOutputUrl pulumi.StringPtrInput `pulumi:"expectedOutputUrl"`
	// For rules with urlRedirect, the test passes only if expectedRedirectResponseCode matches the HTTP status code in load balancer's redirect response. expectedRedirectResponseCode cannot be set when service is set.
	ExpectedRedirectResponseCode pulumi.IntPtrInput `pulumi:"expectedRedirectResponseCode"`
	// HTTP headers for this request. If headers contains a host header, then host must also match the header value.
	Headers UrlMapTestHeaderArrayInput `pulumi:"headers"`
	// Host portion of the URL. If headers contains a host header, then host must also match the header value.
	Host pulumi.StringPtrInput `pulumi:"host"`
	// Path portion of the URL.
	Path pulumi.StringPtrInput `pulumi:"path"`
	// Expected BackendService or BackendBucket resource the given URL should be mapped to. The service field cannot be set if expectedRedirectResponseCode is set.
	Service pulumi.StringPtrInput `pulumi:"service"`
}

func (UrlMapTestArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlMapTest)(nil)).Elem()
}

func (i UrlMapTestArgs) ToUrlMapTestOutput() UrlMapTestOutput {
	return i.ToUrlMapTestOutputWithContext(context.Background())
}

func (i UrlMapTestArgs) ToUrlMapTestOutputWithContext(ctx context.Context) UrlMapTestOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UrlMapTestOutput)
}

func (i UrlMapTestArgs) ToOutput(ctx context.Context) pulumix.Output[UrlMapTest] {
	return pulumix.Output[UrlMapTest]{
		OutputState: i.ToUrlMapTestOutputWithContext(ctx).OutputState,
	}
}

// UrlMapTestArrayInput is an input type that accepts UrlMapTestArray and UrlMapTestArrayOutput values.
// You can construct a concrete instance of `UrlMapTestArrayInput` via:
//
//	UrlMapTestArray{ UrlMapTestArgs{...} }
type UrlMapTestArrayInput interface {
	pulumi.Input

	ToUrlMapTestArrayOutput() UrlMapTestArrayOutput
	ToUrlMapTestArrayOutputWithContext(context.Context) UrlMapTestArrayOutput
}

type UrlMapTestArray []UrlMapTestInput

func (UrlMapTestArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UrlMapTest)(nil)).Elem()
}

func (i UrlMapTestArray) ToUrlMapTestArrayOutput() UrlMapTestArrayOutput {
	return i.ToUrlMapTestArrayOutputWithContext(context.Background())
}

func (i UrlMapTestArray) ToUrlMapTestArrayOutputWithContext(ctx context.Context) UrlMapTestArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UrlMapTestArrayOutput)
}

func (i UrlMapTestArray) ToOutput(ctx context.Context) pulumix.Output[[]UrlMapTest] {
	return pulumix.Output[[]UrlMapTest]{
		OutputState: i.ToUrlMapTestArrayOutputWithContext(ctx).OutputState,
	}
}

// Message for the expected URL mappings.
type UrlMapTestOutput struct{ *pulumi.OutputState }

func (UrlMapTestOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlMapTest)(nil)).Elem()
}

func (o UrlMapTestOutput) ToUrlMapTestOutput() UrlMapTestOutput {
	return o
}

func (o UrlMapTestOutput) ToUrlMapTestOutputWithContext(ctx context.Context) UrlMapTestOutput {
	return o
}

func (o UrlMapTestOutput) ToOutput(ctx context.Context) pulumix.Output[UrlMapTest] {
	return pulumix.Output[UrlMapTest]{
		OutputState: o.OutputState,
	}
}

// Description of this test case.
func (o UrlMapTestOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlMapTest) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The expected output URL evaluated by the load balancer containing the scheme, host, path and query parameters. For rules that forward requests to backends, the test passes only when expectedOutputUrl matches the request forwarded by the load balancer to backends. For rules with urlRewrite, the test verifies that the forwarded request matches hostRewrite and pathPrefixRewrite in the urlRewrite action. When service is specified, expectedOutputUrl`s scheme is ignored. For rules with urlRedirect, the test passes only if expectedOutputUrl matches the URL in the load balancer's redirect response. If urlRedirect specifies https_redirect, the test passes only if the scheme in expectedOutputUrl is also set to HTTPS. If urlRedirect specifies strip_query, the test passes only if expectedOutputUrl does not contain any query parameters. expectedOutputUrl is optional when service is specified.
func (o UrlMapTestOutput) ExpectedOutputUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlMapTest) *string { return v.ExpectedOutputUrl }).(pulumi.StringPtrOutput)
}

// For rules with urlRedirect, the test passes only if expectedRedirectResponseCode matches the HTTP status code in load balancer's redirect response. expectedRedirectResponseCode cannot be set when service is set.
func (o UrlMapTestOutput) ExpectedRedirectResponseCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UrlMapTest) *int { return v.ExpectedRedirectResponseCode }).(pulumi.IntPtrOutput)
}

// HTTP headers for this request. If headers contains a host header, then host must also match the header value.
func (o UrlMapTestOutput) Headers() UrlMapTestHeaderArrayOutput {
	return o.ApplyT(func(v UrlMapTest) []UrlMapTestHeader { return v.Headers }).(UrlMapTestHeaderArrayOutput)
}

// Host portion of the URL. If headers contains a host header, then host must also match the header value.
func (o UrlMapTestOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlMapTest) *string { return v.Host }).(pulumi.StringPtrOutput)
}

// Path portion of the URL.
func (o UrlMapTestOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlMapTest) *string { return v.Path }).(pulumi.StringPtrOutput)
}

// Expected BackendService or BackendBucket resource the given URL should be mapped to. The service field cannot be set if expectedRedirectResponseCode is set.
func (o UrlMapTestOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlMapTest) *string { return v.Service }).(pulumi.StringPtrOutput)
}

type UrlMapTestArrayOutput struct{ *pulumi.OutputState }

func (UrlMapTestArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UrlMapTest)(nil)).Elem()
}

func (o UrlMapTestArrayOutput) ToUrlMapTestArrayOutput() UrlMapTestArrayOutput {
	return o
}

func (o UrlMapTestArrayOutput) ToUrlMapTestArrayOutputWithContext(ctx context.Context) UrlMapTestArrayOutput {
	return o
}

func (o UrlMapTestArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]UrlMapTest] {
	return pulumix.Output[[]UrlMapTest]{
		OutputState: o.OutputState,
	}
}

func (o UrlMapTestArrayOutput) Index(i pulumi.IntInput) UrlMapTestOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UrlMapTest {
		return vs[0].([]UrlMapTest)[vs[1].(int)]
	}).(UrlMapTestOutput)
}

// HTTP headers used in UrlMapTests.
type UrlMapTestHeader struct {
	// Header name.
	Name *string `pulumi:"name"`
	// Header value.
	Value *string `pulumi:"value"`
}

// UrlMapTestHeaderInput is an input type that accepts UrlMapTestHeaderArgs and UrlMapTestHeaderOutput values.
// You can construct a concrete instance of `UrlMapTestHeaderInput` via:
//
//	UrlMapTestHeaderArgs{...}
type UrlMapTestHeaderInput interface {
	pulumi.Input

	ToUrlMapTestHeaderOutput() UrlMapTestHeaderOutput
	ToUrlMapTestHeaderOutputWithContext(context.Context) UrlMapTestHeaderOutput
}

// HTTP headers used in UrlMapTests.
type UrlMapTestHeaderArgs struct {
	// Header name.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Header value.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (UrlMapTestHeaderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlMapTestHeader)(nil)).Elem()
}

func (i UrlMapTestHeaderArgs) ToUrlMapTestHeaderOutput() UrlMapTestHeaderOutput {
	return i.ToUrlMapTestHeaderOutputWithContext(context.Background())
}

func (i UrlMapTestHeaderArgs) ToUrlMapTestHeaderOutputWithContext(ctx context.Context) UrlMapTestHeaderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UrlMapTestHeaderOutput)
}

func (i UrlMapTestHeaderArgs) ToOutput(ctx context.Context) pulumix.Output[UrlMapTestHeader] {
	return pulumix.Output[UrlMapTestHeader]{
		OutputState: i.ToUrlMapTestHeaderOutputWithContext(ctx).OutputState,
	}
}

// UrlMapTestHeaderArrayInput is an input type that accepts UrlMapTestHeaderArray and UrlMapTestHeaderArrayOutput values.
// You can construct a concrete instance of `UrlMapTestHeaderArrayInput` via:
//
//	UrlMapTestHeaderArray{ UrlMapTestHeaderArgs{...} }
type UrlMapTestHeaderArrayInput interface {
	pulumi.Input

	ToUrlMapTestHeaderArrayOutput() UrlMapTestHeaderArrayOutput
	ToUrlMapTestHeaderArrayOutputWithContext(context.Context) UrlMapTestHeaderArrayOutput
}

type UrlMapTestHeaderArray []UrlMapTestHeaderInput

func (UrlMapTestHeaderArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UrlMapTestHeader)(nil)).Elem()
}

func (i UrlMapTestHeaderArray) ToUrlMapTestHeaderArrayOutput() UrlMapTestHeaderArrayOutput {
	return i.ToUrlMapTestHeaderArrayOutputWithContext(context.Background())
}

func (i UrlMapTestHeaderArray) ToUrlMapTestHeaderArrayOutputWithContext(ctx context.Context) UrlMapTestHeaderArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UrlMapTestHeaderArrayOutput)
}

func (i UrlMapTestHeaderArray) ToOutput(ctx context.Context) pulumix.Output[[]UrlMapTestHeader] {
	return pulumix.Output[[]UrlMapTestHeader]{
		OutputState: i.ToUrlMapTestHeaderArrayOutputWithContext(ctx).OutputState,
	}
}

// HTTP headers used in UrlMapTests.
type UrlMapTestHeaderOutput struct{ *pulumi.OutputState }

func (UrlMapTestHeaderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlMapTestHeader)(nil)).Elem()
}

func (o UrlMapTestHeaderOutput) ToUrlMapTestHeaderOutput() UrlMapTestHeaderOutput {
	return o
}

func (o UrlMapTestHeaderOutput) ToUrlMapTestHeaderOutputWithContext(ctx context.Context) UrlMapTestHeaderOutput {
	return o
}

func (o UrlMapTestHeaderOutput) ToOutput(ctx context.Context) pulumix.Output[UrlMapTestHeader] {
	return pulumix.Output[UrlMapTestHeader]{
		OutputState: o.OutputState,
	}
}

// Header name.
func (o UrlMapTestHeaderOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlMapTestHeader) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Header value.
func (o UrlMapTestHeaderOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlMapTestHeader) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type UrlMapTestHeaderArrayOutput struct{ *pulumi.OutputState }

func (UrlMapTestHeaderArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UrlMapTestHeader)(nil)).Elem()
}

func (o UrlMapTestHeaderArrayOutput) ToUrlMapTestHeaderArrayOutput() UrlMapTestHeaderArrayOutput {
	return o
}

func (o UrlMapTestHeaderArrayOutput) ToUrlMapTestHeaderArrayOutputWithContext(ctx context.Context) UrlMapTestHeaderArrayOutput {
	return o
}

func (o UrlMapTestHeaderArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]UrlMapTestHeader] {
	return pulumix.Output[[]UrlMapTestHeader]{
		OutputState: o.OutputState,
	}
}

func (o UrlMapTestHeaderArrayOutput) Index(i pulumi.IntInput) UrlMapTestHeaderOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UrlMapTestHeader {
		return vs[0].([]UrlMapTestHeader)[vs[1].(int)]
	}).(UrlMapTestHeaderOutput)
}

// HTTP headers used in UrlMapTests.
type UrlMapTestHeaderResponse struct {
	// Header name.
	Name string `pulumi:"name"`
	// Header value.
	Value string `pulumi:"value"`
}

// HTTP headers used in UrlMapTests.
type UrlMapTestHeaderResponseOutput struct{ *pulumi.OutputState }

func (UrlMapTestHeaderResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlMapTestHeaderResponse)(nil)).Elem()
}

func (o UrlMapTestHeaderResponseOutput) ToUrlMapTestHeaderResponseOutput() UrlMapTestHeaderResponseOutput {
	return o
}

func (o UrlMapTestHeaderResponseOutput) ToUrlMapTestHeaderResponseOutputWithContext(ctx context.Context) UrlMapTestHeaderResponseOutput {
	return o
}

func (o UrlMapTestHeaderResponseOutput) ToOutput(ctx context.Context) pulumix.Output[UrlMapTestHeaderResponse] {
	return pulumix.Output[UrlMapTestHeaderResponse]{
		OutputState: o.OutputState,
	}
}

// Header name.
func (o UrlMapTestHeaderResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v UrlMapTestHeaderResponse) string { return v.Name }).(pulumi.StringOutput)
}

// Header value.
func (o UrlMapTestHeaderResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v UrlMapTestHeaderResponse) string { return v.Value }).(pulumi.StringOutput)
}

type UrlMapTestHeaderResponseArrayOutput struct{ *pulumi.OutputState }

func (UrlMapTestHeaderResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UrlMapTestHeaderResponse)(nil)).Elem()
}

func (o UrlMapTestHeaderResponseArrayOutput) ToUrlMapTestHeaderResponseArrayOutput() UrlMapTestHeaderResponseArrayOutput {
	return o
}

func (o UrlMapTestHeaderResponseArrayOutput) ToUrlMapTestHeaderResponseArrayOutputWithContext(ctx context.Context) UrlMapTestHeaderResponseArrayOutput {
	return o
}

func (o UrlMapTestHeaderResponseArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]UrlMapTestHeaderResponse] {
	return pulumix.Output[[]UrlMapTestHeaderResponse]{
		OutputState: o.OutputState,
	}
}

func (o UrlMapTestHeaderResponseArrayOutput) Index(i pulumi.IntInput) UrlMapTestHeaderResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UrlMapTestHeaderResponse {
		return vs[0].([]UrlMapTestHeaderResponse)[vs[1].(int)]
	}).(UrlMapTestHeaderResponseOutput)
}

// Message for the expected URL mappings.
type UrlMapTestResponse struct {
	// Description of this test case.
	Description string `pulumi:"description"`
	// The expected output URL evaluated by the load balancer containing the scheme, host, path and query parameters. For rules that forward requests to backends, the test passes only when expectedOutputUrl matches the request forwarded by the load balancer to backends. For rules with urlRewrite, the test verifies that the forwarded request matches hostRewrite and pathPrefixRewrite in the urlRewrite action. When service is specified, expectedOutputUrl`s scheme is ignored. For rules with urlRedirect, the test passes only if expectedOutputUrl matches the URL in the load balancer's redirect response. If urlRedirect specifies https_redirect, the test passes only if the scheme in expectedOutputUrl is also set to HTTPS. If urlRedirect specifies strip_query, the test passes only if expectedOutputUrl does not contain any query parameters. expectedOutputUrl is optional when service is specified.
	ExpectedOutputUrl string `pulumi:"expectedOutputUrl"`
	// For rules with urlRedirect, the test passes only if expectedRedirectResponseCode matches the HTTP status code in load balancer's redirect response. expectedRedirectResponseCode cannot be set when service is set.
	ExpectedRedirectResponseCode int `pulumi:"expectedRedirectResponseCode"`
	// HTTP headers for this request. If headers contains a host header, then host must also match the header value.
	Headers []UrlMapTestHeaderResponse `pulumi:"headers"`
	// Host portion of the URL. If headers contains a host header, then host must also match the header value.
	Host string `pulumi:"host"`
	// Path portion of the URL.
	Path string `pulumi:"path"`
	// Expected BackendService or BackendBucket resource the given URL should be mapped to. The service field cannot be set if expectedRedirectResponseCode is set.
	Service string `pulumi:"service"`
}

// Message for the expected URL mappings.
type UrlMapTestResponseOutput struct{ *pulumi.OutputState }

func (UrlMapTestResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlMapTestResponse)(nil)).Elem()
}

func (o UrlMapTestResponseOutput) ToUrlMapTestResponseOutput() UrlMapTestResponseOutput {
	return o
}

func (o UrlMapTestResponseOutput) ToUrlMapTestResponseOutputWithContext(ctx context.Context) UrlMapTestResponseOutput {
	return o
}

func (o UrlMapTestResponseOutput) ToOutput(ctx context.Context) pulumix.Output[UrlMapTestResponse] {
	return pulumix.Output[UrlMapTestResponse]{
		OutputState: o.OutputState,
	}
}

// Description of this test case.
func (o UrlMapTestResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v UrlMapTestResponse) string { return v.Description }).(pulumi.StringOutput)
}

// The expected output URL evaluated by the load balancer containing the scheme, host, path and query parameters. For rules that forward requests to backends, the test passes only when expectedOutputUrl matches the request forwarded by the load balancer to backends. For rules with urlRewrite, the test verifies that the forwarded request matches hostRewrite and pathPrefixRewrite in the urlRewrite action. When service is specified, expectedOutputUrl`s scheme is ignored. For rules with urlRedirect, the test passes only if expectedOutputUrl matches the URL in the load balancer's redirect response. If urlRedirect specifies https_redirect, the test passes only if the scheme in expectedOutputUrl is also set to HTTPS. If urlRedirect specifies strip_query, the test passes only if expectedOutputUrl does not contain any query parameters. expectedOutputUrl is optional when service is specified.
func (o UrlMapTestResponseOutput) ExpectedOutputUrl() pulumi.StringOutput {
	return o.ApplyT(func(v UrlMapTestResponse) string { return v.ExpectedOutputUrl }).(pulumi.StringOutput)
}

// For rules with urlRedirect, the test passes only if expectedRedirectResponseCode matches the HTTP status code in load balancer's redirect response. expectedRedirectResponseCode cannot be set when service is set.
func (o UrlMapTestResponseOutput) ExpectedRedirectResponseCode() pulumi.IntOutput {
	return o.ApplyT(func(v UrlMapTestResponse) int { return v.ExpectedRedirectResponseCode }).(pulumi.IntOutput)
}

// HTTP headers for this request. If headers contains a host header, then host must also match the header value.
func (o UrlMapTestResponseOutput) Headers() UrlMapTestHeaderResponseArrayOutput {
	return o.ApplyT(func(v UrlMapTestResponse) []UrlMapTestHeaderResponse { return v.Headers }).(UrlMapTestHeaderResponseArrayOutput)
}

// Host portion of the URL. If headers contains a host header, then host must also match the header value.
func (o UrlMapTestResponseOutput) Host() pulumi.StringOutput {
	return o.ApplyT(func(v UrlMapTestResponse) string { return v.Host }).(pulumi.StringOutput)
}

// Path portion of the URL.
func (o UrlMapTestResponseOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v UrlMapTestResponse) string { return v.Path }).(pulumi.StringOutput)
}

// Expected BackendService or BackendBucket resource the given URL should be mapped to. The service field cannot be set if expectedRedirectResponseCode is set.
func (o UrlMapTestResponseOutput) Service() pulumi.StringOutput {
	return o.ApplyT(func(v UrlMapTestResponse) string { return v.Service }).(pulumi.StringOutput)
}

type UrlMapTestResponseArrayOutput struct{ *pulumi.OutputState }

func (UrlMapTestResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UrlMapTestResponse)(nil)).Elem()
}

func (o UrlMapTestResponseArrayOutput) ToUrlMapTestResponseArrayOutput() UrlMapTestResponseArrayOutput {
	return o
}

func (o UrlMapTestResponseArrayOutput) ToUrlMapTestResponseArrayOutputWithContext(ctx context.Context) UrlMapTestResponseArrayOutput {
	return o
}

func (o UrlMapTestResponseArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]UrlMapTestResponse] {
	return pulumix.Output[[]UrlMapTestResponse]{
		OutputState: o.OutputState,
	}
}

func (o UrlMapTestResponseArrayOutput) Index(i pulumi.IntInput) UrlMapTestResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UrlMapTestResponse {
		return vs[0].([]UrlMapTestResponse)[vs[1].(int)]
	}).(UrlMapTestResponseOutput)
}

// The spec for modifying the path before sending the request to the matched backend service.
type UrlRewrite struct {
	// Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite. The value must be from 1 to 255 characters.
	HostRewrite *string `pulumi:"hostRewrite"`
	// Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite. The value must be from 1 to 1024 characters.
	PathPrefixRewrite *string `pulumi:"pathPrefixRewrite"`
	//  If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax. A corresponding path_template_match must be specified. Any template variables must exist in the path_template_match field. - -At least one variable must be specified in the path_template_match field - You can omit variables from the rewritten URL - The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}. For example, a path_template_match of /static/{format=**} could be rewritten as /static/content/{format} to prefix /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be rewritten as /content/{format}/{country}/{suffix}. At least one non-empty routeRules[].matchRules[].path_template_match is required. Only one of path_prefix_rewrite or path_template_rewrite may be specified.
	PathTemplateRewrite *string `pulumi:"pathTemplateRewrite"`
}

// UrlRewriteInput is an input type that accepts UrlRewriteArgs and UrlRewriteOutput values.
// You can construct a concrete instance of `UrlRewriteInput` via:
//
//	UrlRewriteArgs{...}
type UrlRewriteInput interface {
	pulumi.Input

	ToUrlRewriteOutput() UrlRewriteOutput
	ToUrlRewriteOutputWithContext(context.Context) UrlRewriteOutput
}

// The spec for modifying the path before sending the request to the matched backend service.
type UrlRewriteArgs struct {
	// Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite. The value must be from 1 to 255 characters.
	HostRewrite pulumi.StringPtrInput `pulumi:"hostRewrite"`
	// Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite. The value must be from 1 to 1024 characters.
	PathPrefixRewrite pulumi.StringPtrInput `pulumi:"pathPrefixRewrite"`
	//  If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax. A corresponding path_template_match must be specified. Any template variables must exist in the path_template_match field. - -At least one variable must be specified in the path_template_match field - You can omit variables from the rewritten URL - The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}. For example, a path_template_match of /static/{format=**} could be rewritten as /static/content/{format} to prefix /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be rewritten as /content/{format}/{country}/{suffix}. At least one non-empty routeRules[].matchRules[].path_template_match is required. Only one of path_prefix_rewrite or path_template_rewrite may be specified.
	PathTemplateRewrite pulumi.StringPtrInput `pulumi:"pathTemplateRewrite"`
}

func (UrlRewriteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlRewrite)(nil)).Elem()
}

func (i UrlRewriteArgs) ToUrlRewriteOutput() UrlRewriteOutput {
	return i.ToUrlRewriteOutputWithContext(context.Background())
}

func (i UrlRewriteArgs) ToUrlRewriteOutputWithContext(ctx context.Context) UrlRewriteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UrlRewriteOutput)
}

func (i UrlRewriteArgs) ToOutput(ctx context.Context) pulumix.Output[UrlRewrite] {
	return pulumix.Output[UrlRewrite]{
		OutputState: i.ToUrlRewriteOutputWithContext(ctx).OutputState,
	}
}

func (i UrlRewriteArgs) ToUrlRewritePtrOutput() UrlRewritePtrOutput {
	return i.ToUrlRewritePtrOutputWithContext(context.Background())
}

func (i UrlRewriteArgs) ToUrlRewritePtrOutputWithContext(ctx context.Context) UrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UrlRewriteOutput).ToUrlRewritePtrOutputWithContext(ctx)
}

// UrlRewritePtrInput is an input type that accepts UrlRewriteArgs, UrlRewritePtr and UrlRewritePtrOutput values.
// You can construct a concrete instance of `UrlRewritePtrInput` via:
//
//	        UrlRewriteArgs{...}
//
//	or:
//
//	        nil
type UrlRewritePtrInput interface {
	pulumi.Input

	ToUrlRewritePtrOutput() UrlRewritePtrOutput
	ToUrlRewritePtrOutputWithContext(context.Context) UrlRewritePtrOutput
}

type urlRewritePtrType UrlRewriteArgs

func UrlRewritePtr(v *UrlRewriteArgs) UrlRewritePtrInput {
	return (*urlRewritePtrType)(v)
}

func (*urlRewritePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UrlRewrite)(nil)).Elem()
}

func (i *urlRewritePtrType) ToUrlRewritePtrOutput() UrlRewritePtrOutput {
	return i.ToUrlRewritePtrOutputWithContext(context.Background())
}

func (i *urlRewritePtrType) ToUrlRewritePtrOutputWithContext(ctx context.Context) UrlRewritePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UrlRewritePtrOutput)
}

func (i *urlRewritePtrType) ToOutput(ctx context.Context) pulumix.Output[*UrlRewrite] {
	return pulumix.Output[*UrlRewrite]{
		OutputState: i.ToUrlRewritePtrOutputWithContext(ctx).OutputState,
	}
}

// The spec for modifying the path before sending the request to the matched backend service.
type UrlRewriteOutput struct{ *pulumi.OutputState }

func (UrlRewriteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlRewrite)(nil)).Elem()
}

func (o UrlRewriteOutput) ToUrlRewriteOutput() UrlRewriteOutput {
	return o
}

func (o UrlRewriteOutput) ToUrlRewriteOutputWithContext(ctx context.Context) UrlRewriteOutput {
	return o
}

func (o UrlRewriteOutput) ToUrlRewritePtrOutput() UrlRewritePtrOutput {
	return o.ToUrlRewritePtrOutputWithContext(context.Background())
}

func (o UrlRewriteOutput) ToUrlRewritePtrOutputWithContext(ctx context.Context) UrlRewritePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UrlRewrite) *UrlRewrite {
		return &v
	}).(UrlRewritePtrOutput)
}

func (o UrlRewriteOutput) ToOutput(ctx context.Context) pulumix.Output[UrlRewrite] {
	return pulumix.Output[UrlRewrite]{
		OutputState: o.OutputState,
	}
}

// Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite. The value must be from 1 to 255 characters.
func (o UrlRewriteOutput) HostRewrite() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlRewrite) *string { return v.HostRewrite }).(pulumi.StringPtrOutput)
}

// Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite. The value must be from 1 to 1024 characters.
func (o UrlRewriteOutput) PathPrefixRewrite() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlRewrite) *string { return v.PathPrefixRewrite }).(pulumi.StringPtrOutput)
}

// If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax. A corresponding path_template_match must be specified. Any template variables must exist in the path_template_match field. - -At least one variable must be specified in the path_template_match field - You can omit variables from the rewritten URL - The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}. For example, a path_template_match of /static/{format=**} could be rewritten as /static/content/{format} to prefix /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be rewritten as /content/{format}/{country}/{suffix}. At least one non-empty routeRules[].matchRules[].path_template_match is required. Only one of path_prefix_rewrite or path_template_rewrite may be specified.
func (o UrlRewriteOutput) PathTemplateRewrite() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UrlRewrite) *string { return v.PathTemplateRewrite }).(pulumi.StringPtrOutput)
}

type UrlRewritePtrOutput struct{ *pulumi.OutputState }

func (UrlRewritePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UrlRewrite)(nil)).Elem()
}

func (o UrlRewritePtrOutput) ToUrlRewritePtrOutput() UrlRewritePtrOutput {
	return o
}

func (o UrlRewritePtrOutput) ToUrlRewritePtrOutputWithContext(ctx context.Context) UrlRewritePtrOutput {
	return o
}

func (o UrlRewritePtrOutput) ToOutput(ctx context.Context) pulumix.Output[*UrlRewrite] {
	return pulumix.Output[*UrlRewrite]{
		OutputState: o.OutputState,
	}
}

func (o UrlRewritePtrOutput) Elem() UrlRewriteOutput {
	return o.ApplyT(func(v *UrlRewrite) UrlRewrite {
		if v != nil {
			return *v
		}
		var ret UrlRewrite
		return ret
	}).(UrlRewriteOutput)
}

// Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite. The value must be from 1 to 255 characters.
func (o UrlRewritePtrOutput) HostRewrite() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UrlRewrite) *string {
		if v == nil {
			return nil
		}
		return v.HostRewrite
	}).(pulumi.StringPtrOutput)
}

// Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite. The value must be from 1 to 1024 characters.
func (o UrlRewritePtrOutput) PathPrefixRewrite() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UrlRewrite) *string {
		if v == nil {
			return nil
		}
		return v.PathPrefixRewrite
	}).(pulumi.StringPtrOutput)
}

// If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax. A corresponding path_template_match must be specified. Any template variables must exist in the path_template_match field. - -At least one variable must be specified in the path_template_match field - You can omit variables from the rewritten URL - The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}. For example, a path_template_match of /static/{format=**} could be rewritten as /static/content/{format} to prefix /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be rewritten as /content/{format}/{country}/{suffix}. At least one non-empty routeRules[].matchRules[].path_template_match is required. Only one of path_prefix_rewrite or path_template_rewrite may be specified.
func (o UrlRewritePtrOutput) PathTemplateRewrite() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UrlRewrite) *string {
		if v == nil {
			return nil
		}
		return v.PathTemplateRewrite
	}).(pulumi.StringPtrOutput)
}

// The spec for modifying the path before sending the request to the matched backend service.
type UrlRewriteResponse struct {
	// Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite. The value must be from 1 to 255 characters.
	HostRewrite string `pulumi:"hostRewrite"`
	// Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite. The value must be from 1 to 1024 characters.
	PathPrefixRewrite string `pulumi:"pathPrefixRewrite"`
	//  If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax. A corresponding path_template_match must be specified. Any template variables must exist in the path_template_match field. - -At least one variable must be specified in the path_template_match field - You can omit variables from the rewritten URL - The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}. For example, a path_template_match of /static/{format=**} could be rewritten as /static/content/{format} to prefix /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be rewritten as /content/{format}/{country}/{suffix}. At least one non-empty routeRules[].matchRules[].path_template_match is required. Only one of path_prefix_rewrite or path_template_rewrite may be specified.
	PathTemplateRewrite string `pulumi:"pathTemplateRewrite"`
}

// The spec for modifying the path before sending the request to the matched backend service.
type UrlRewriteResponseOutput struct{ *pulumi.OutputState }

func (UrlRewriteResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UrlRewriteResponse)(nil)).Elem()
}

func (o UrlRewriteResponseOutput) ToUrlRewriteResponseOutput() UrlRewriteResponseOutput {
	return o
}

func (o UrlRewriteResponseOutput) ToUrlRewriteResponseOutputWithContext(ctx context.Context) UrlRewriteResponseOutput {
	return o
}

func (o UrlRewriteResponseOutput) ToOutput(ctx context.Context) pulumix.Output[UrlRewriteResponse] {
	return pulumix.Output[UrlRewriteResponse]{
		OutputState: o.OutputState,
	}
}

// Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite. The value must be from 1 to 255 characters.
func (o UrlRewriteResponseOutput) HostRewrite() pulumi.StringOutput {
	return o.ApplyT(func(v UrlRewriteResponse) string { return v.HostRewrite }).(pulumi.StringOutput)
}

// Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite. The value must be from 1 to 1024 characters.
func (o UrlRewriteResponseOutput) PathPrefixRewrite() pulumi.StringOutput {
	return o.ApplyT(func(v UrlRewriteResponse) string { return v.PathPrefixRewrite }).(pulumi.StringOutput)
}

// If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax. A corresponding path_template_match must be specified. Any template variables must exist in the path_template_match field. - -At least one variable must be specified in the path_template_match field - You can omit variables from the rewritten URL - The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}. For example, a path_template_match of /static/{format=**} could be rewritten as /static/content/{format} to prefix /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be rewritten as /content/{format}/{country}/{suffix}. At least one non-empty routeRules[].matchRules[].path_template_match is required. Only one of path_prefix_rewrite or path_template_rewrite may be specified.
func (o UrlRewriteResponseOutput) PathTemplateRewrite() pulumi.StringOutput {
	return o.ApplyT(func(v UrlRewriteResponse) string { return v.PathTemplateRewrite }).(pulumi.StringOutput)
}

// A VPN gateway interface.
type VpnGatewayVpnGatewayInterface struct {
	// URL of the VLAN attachment (interconnectAttachment) resource for this VPN gateway interface. When the value of this field is present, the VPN gateway is used for HA VPN over Cloud Interconnect; all egress or ingress traffic for this VPN gateway interface goes through the specified VLAN attachment resource.
	InterconnectAttachment *string `pulumi:"interconnectAttachment"`
}

// VpnGatewayVpnGatewayInterfaceInput is an input type that accepts VpnGatewayVpnGatewayInterfaceArgs and VpnGatewayVpnGatewayInterfaceOutput values.
// You can construct a concrete instance of `VpnGatewayVpnGatewayInterfaceInput` via:
//
//	VpnGatewayVpnGatewayInterfaceArgs{...}
type VpnGatewayVpnGatewayInterfaceInput interface {
	pulumi.Input

	ToVpnGatewayVpnGatewayInterfaceOutput() VpnGatewayVpnGatewayInterfaceOutput
	ToVpnGatewayVpnGatewayInterfaceOutputWithContext(context.Context) VpnGatewayVpnGatewayInterfaceOutput
}

// A VPN gateway interface.
type VpnGatewayVpnGatewayInterfaceArgs struct {
	// URL of the VLAN attachment (interconnectAttachment) resource for this VPN gateway interface. When the value of this field is present, the VPN gateway is used for HA VPN over Cloud Interconnect; all egress or ingress traffic for this VPN gateway interface goes through the specified VLAN attachment resource.
	InterconnectAttachment pulumi.StringPtrInput `pulumi:"interconnectAttachment"`
}

func (VpnGatewayVpnGatewayInterfaceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VpnGatewayVpnGatewayInterface)(nil)).Elem()
}

func (i VpnGatewayVpnGatewayInterfaceArgs) ToVpnGatewayVpnGatewayInterfaceOutput() VpnGatewayVpnGatewayInterfaceOutput {
	return i.ToVpnGatewayVpnGatewayInterfaceOutputWithContext(context.Background())
}

func (i VpnGatewayVpnGatewayInterfaceArgs) ToVpnGatewayVpnGatewayInterfaceOutputWithContext(ctx context.Context) VpnGatewayVpnGatewayInterfaceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpnGatewayVpnGatewayInterfaceOutput)
}

func (i VpnGatewayVpnGatewayInterfaceArgs) ToOutput(ctx context.Context) pulumix.Output[VpnGatewayVpnGatewayInterface] {
	return pulumix.Output[VpnGatewayVpnGatewayInterface]{
		OutputState: i.ToVpnGatewayVpnGatewayInterfaceOutputWithContext(ctx).OutputState,
	}
}

// VpnGatewayVpnGatewayInterfaceArrayInput is an input type that accepts VpnGatewayVpnGatewayInterfaceArray and VpnGatewayVpnGatewayInterfaceArrayOutput values.
// You can construct a concrete instance of `VpnGatewayVpnGatewayInterfaceArrayInput` via:
//
//	VpnGatewayVpnGatewayInterfaceArray{ VpnGatewayVpnGatewayInterfaceArgs{...} }
type VpnGatewayVpnGatewayInterfaceArrayInput interface {
	pulumi.Input

	ToVpnGatewayVpnGatewayInterfaceArrayOutput() VpnGatewayVpnGatewayInterfaceArrayOutput
	ToVpnGatewayVpnGatewayInterfaceArrayOutputWithContext(context.Context) VpnGatewayVpnGatewayInterfaceArrayOutput
}

type VpnGatewayVpnGatewayInterfaceArray []VpnGatewayVpnGatewayInterfaceInput

func (VpnGatewayVpnGatewayInterfaceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VpnGatewayVpnGatewayInterface)(nil)).Elem()
}

func (i VpnGatewayVpnGatewayInterfaceArray) ToVpnGatewayVpnGatewayInterfaceArrayOutput() VpnGatewayVpnGatewayInterfaceArrayOutput {
	return i.ToVpnGatewayVpnGatewayInterfaceArrayOutputWithContext(context.Background())
}

func (i VpnGatewayVpnGatewayInterfaceArray) ToVpnGatewayVpnGatewayInterfaceArrayOutputWithContext(ctx context.Context) VpnGatewayVpnGatewayInterfaceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpnGatewayVpnGatewayInterfaceArrayOutput)
}

func (i VpnGatewayVpnGatewayInterfaceArray) ToOutput(ctx context.Context) pulumix.Output[[]VpnGatewayVpnGatewayInterface] {
	return pulumix.Output[[]VpnGatewayVpnGatewayInterface]{
		OutputState: i.ToVpnGatewayVpnGatewayInterfaceArrayOutputWithContext(ctx).OutputState,
	}
}

// A VPN gateway interface.
type VpnGatewayVpnGatewayInterfaceOutput struct{ *pulumi.OutputState }

func (VpnGatewayVpnGatewayInterfaceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VpnGatewayVpnGatewayInterface)(nil)).Elem()
}

func (o VpnGatewayVpnGatewayInterfaceOutput) ToVpnGatewayVpnGatewayInterfaceOutput() VpnGatewayVpnGatewayInterfaceOutput {
	return o
}

func (o VpnGatewayVpnGatewayInterfaceOutput) ToVpnGatewayVpnGatewayInterfaceOutputWithContext(ctx context.Context) VpnGatewayVpnGatewayInterfaceOutput {
	return o
}

func (o VpnGatewayVpnGatewayInterfaceOutput) ToOutput(ctx context.Context) pulumix.Output[VpnGatewayVpnGatewayInterface] {
	return pulumix.Output[VpnGatewayVpnGatewayInterface]{
		OutputState: o.OutputState,
	}
}

// URL of the VLAN attachment (interconnectAttachment) resource for this VPN gateway interface. When the value of this field is present, the VPN gateway is used for HA VPN over Cloud Interconnect; all egress or ingress traffic for this VPN gateway interface goes through the specified VLAN attachment resource.
func (o VpnGatewayVpnGatewayInterfaceOutput) InterconnectAttachment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpnGatewayVpnGatewayInterface) *string { return v.InterconnectAttachment }).(pulumi.StringPtrOutput)
}

type VpnGatewayVpnGatewayInterfaceArrayOutput struct{ *pulumi.OutputState }

func (VpnGatewayVpnGatewayInterfaceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VpnGatewayVpnGatewayInterface)(nil)).Elem()
}

func (o VpnGatewayVpnGatewayInterfaceArrayOutput) ToVpnGatewayVpnGatewayInterfaceArrayOutput() VpnGatewayVpnGatewayInterfaceArrayOutput {
	return o
}

func (o VpnGatewayVpnGatewayInterfaceArrayOutput) ToVpnGatewayVpnGatewayInterfaceArrayOutputWithContext(ctx context.Context) VpnGatewayVpnGatewayInterfaceArrayOutput {
	return o
}

func (o VpnGatewayVpnGatewayInterfaceArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]VpnGatewayVpnGatewayInterface] {
	return pulumix.Output[[]VpnGatewayVpnGatewayInterface]{
		OutputState: o.OutputState,
	}
}

func (o VpnGatewayVpnGatewayInterfaceArrayOutput) Index(i pulumi.IntInput) VpnGatewayVpnGatewayInterfaceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VpnGatewayVpnGatewayInterface {
		return vs[0].([]VpnGatewayVpnGatewayInterface)[vs[1].(int)]
	}).(VpnGatewayVpnGatewayInterfaceOutput)
}

// A VPN gateway interface.
type VpnGatewayVpnGatewayInterfaceResponse struct {
	// URL of the VLAN attachment (interconnectAttachment) resource for this VPN gateway interface. When the value of this field is present, the VPN gateway is used for HA VPN over Cloud Interconnect; all egress or ingress traffic for this VPN gateway interface goes through the specified VLAN attachment resource.
	InterconnectAttachment string `pulumi:"interconnectAttachment"`
	// IP address for this VPN interface associated with the VPN gateway. The IP address could be either a regional external IP address or a regional internal IP address. The two IP addresses for a VPN gateway must be all regional external or regional internal IP addresses. There cannot be a mix of regional external IP addresses and regional internal IP addresses. For HA VPN over Cloud Interconnect, the IP addresses for both interfaces could either be regional internal IP addresses or regional external IP addresses. For regular (non HA VPN over Cloud Interconnect) HA VPN tunnels, the IP address must be a regional external IP address.
	IpAddress string `pulumi:"ipAddress"`
	// IPv6 address for this VPN interface associated with the VPN gateway. The IPv6 address must be a regional external IPv6 address. The format is RFC 5952 format (e.g. 2001:db8::2d9:51:0:0).
	Ipv6Address string `pulumi:"ipv6Address"`
}

// A VPN gateway interface.
type VpnGatewayVpnGatewayInterfaceResponseOutput struct{ *pulumi.OutputState }

func (VpnGatewayVpnGatewayInterfaceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VpnGatewayVpnGatewayInterfaceResponse)(nil)).Elem()
}

func (o VpnGatewayVpnGatewayInterfaceResponseOutput) ToVpnGatewayVpnGatewayInterfaceResponseOutput() VpnGatewayVpnGatewayInterfaceResponseOutput {
	return o
}

func (o VpnGatewayVpnGatewayInterfaceResponseOutput) ToVpnGatewayVpnGatewayInterfaceResponseOutputWithContext(ctx context.Context) VpnGatewayVpnGatewayInterfaceResponseOutput {
	return o
}

func (o VpnGatewayVpnGatewayInterfaceResponseOutput) ToOutput(ctx context.Context) pulumix.Output[VpnGatewayVpnGatewayInterfaceResponse] {
	return pulumix.Output[VpnGatewayVpnGatewayInterfaceResponse]{
		OutputState: o.OutputState,
	}
}

// URL of the VLAN attachment (interconnectAttachment) resource for this VPN gateway interface. When the value of this field is present, the VPN gateway is used for HA VPN over Cloud Interconnect; all egress or ingress traffic for this VPN gateway interface goes through the specified VLAN attachment resource.
func (o VpnGatewayVpnGatewayInterfaceResponseOutput) InterconnectAttachment() pulumi.StringOutput {
	return o.ApplyT(func(v VpnGatewayVpnGatewayInterfaceResponse) string { return v.InterconnectAttachment }).(pulumi.StringOutput)
}

// IP address for this VPN interface associated with the VPN gateway. The IP address could be either a regional external IP address or a regional internal IP address. The two IP addresses for a VPN gateway must be all regional external or regional internal IP addresses. There cannot be a mix of regional external IP addresses and regional internal IP addresses. For HA VPN over Cloud Interconnect, the IP addresses for both interfaces could either be regional internal IP addresses or regional external IP addresses. For regular (non HA VPN over Cloud Interconnect) HA VPN tunnels, the IP address must be a regional external IP address.
func (o VpnGatewayVpnGatewayInterfaceResponseOutput) IpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v VpnGatewayVpnGatewayInterfaceResponse) string { return v.IpAddress }).(pulumi.StringOutput)
}

// IPv6 address for this VPN interface associated with the VPN gateway. The IPv6 address must be a regional external IPv6 address. The format is RFC 5952 format (e.g. 2001:db8::2d9:51:0:0).
func (o VpnGatewayVpnGatewayInterfaceResponseOutput) Ipv6Address() pulumi.StringOutput {
	return o.ApplyT(func(v VpnGatewayVpnGatewayInterfaceResponse) string { return v.Ipv6Address }).(pulumi.StringOutput)
}

type VpnGatewayVpnGatewayInterfaceResponseArrayOutput struct{ *pulumi.OutputState }

func (VpnGatewayVpnGatewayInterfaceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VpnGatewayVpnGatewayInterfaceResponse)(nil)).Elem()
}

func (o VpnGatewayVpnGatewayInterfaceResponseArrayOutput) ToVpnGatewayVpnGatewayInterfaceResponseArrayOutput() VpnGatewayVpnGatewayInterfaceResponseArrayOutput {
	return o
}

func (o VpnGatewayVpnGatewayInterfaceResponseArrayOutput) ToVpnGatewayVpnGatewayInterfaceResponseArrayOutputWithContext(ctx context.Context) VpnGatewayVpnGatewayInterfaceResponseArrayOutput {
	return o
}

func (o VpnGatewayVpnGatewayInterfaceResponseArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]VpnGatewayVpnGatewayInterfaceResponse] {
	return pulumix.Output[[]VpnGatewayVpnGatewayInterfaceResponse]{
		OutputState: o.OutputState,
	}
}

func (o VpnGatewayVpnGatewayInterfaceResponseArrayOutput) Index(i pulumi.IntInput) VpnGatewayVpnGatewayInterfaceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VpnGatewayVpnGatewayInterfaceResponse {
		return vs[0].([]VpnGatewayVpnGatewayInterfaceResponse)[vs[1].(int)]
	}).(VpnGatewayVpnGatewayInterfaceResponseOutput)
}

// In contrast to a single BackendService in HttpRouteAction to which all matching traffic is directed to, WeightedBackendService allows traffic to be split across multiple backend services. The volume of traffic for each backend service is proportional to the weight specified in each WeightedBackendService
type WeightedBackendService struct {
	// The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
	BackendService *string `pulumi:"backendService"`
	// Specifies changes to request and response headers that need to take effect for the selected backendService. headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap. headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL. Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
	HeaderAction *HttpHeaderAction `pulumi:"headerAction"`
	// Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) . The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy. The value must be from 0 to 1000.
	Weight *int `pulumi:"weight"`
}

// WeightedBackendServiceInput is an input type that accepts WeightedBackendServiceArgs and WeightedBackendServiceOutput values.
// You can construct a concrete instance of `WeightedBackendServiceInput` via:
//
//	WeightedBackendServiceArgs{...}
type WeightedBackendServiceInput interface {
	pulumi.Input

	ToWeightedBackendServiceOutput() WeightedBackendServiceOutput
	ToWeightedBackendServiceOutputWithContext(context.Context) WeightedBackendServiceOutput
}

// In contrast to a single BackendService in HttpRouteAction to which all matching traffic is directed to, WeightedBackendService allows traffic to be split across multiple backend services. The volume of traffic for each backend service is proportional to the weight specified in each WeightedBackendService
type WeightedBackendServiceArgs struct {
	// The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
	BackendService pulumi.StringPtrInput `pulumi:"backendService"`
	// Specifies changes to request and response headers that need to take effect for the selected backendService. headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap. headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL. Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
	HeaderAction HttpHeaderActionPtrInput `pulumi:"headerAction"`
	// Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) . The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy. The value must be from 0 to 1000.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (WeightedBackendServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WeightedBackendService)(nil)).Elem()
}

func (i WeightedBackendServiceArgs) ToWeightedBackendServiceOutput() WeightedBackendServiceOutput {
	return i.ToWeightedBackendServiceOutputWithContext(context.Background())
}

func (i WeightedBackendServiceArgs) ToWeightedBackendServiceOutputWithContext(ctx context.Context) WeightedBackendServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WeightedBackendServiceOutput)
}

func (i WeightedBackendServiceArgs) ToOutput(ctx context.Context) pulumix.Output[WeightedBackendService] {
	return pulumix.Output[WeightedBackendService]{
		OutputState: i.ToWeightedBackendServiceOutputWithContext(ctx).OutputState,
	}
}

// WeightedBackendServiceArrayInput is an input type that accepts WeightedBackendServiceArray and WeightedBackendServiceArrayOutput values.
// You can construct a concrete instance of `WeightedBackendServiceArrayInput` via:
//
//	WeightedBackendServiceArray{ WeightedBackendServiceArgs{...} }
type WeightedBackendServiceArrayInput interface {
	pulumi.Input

	ToWeightedBackendServiceArrayOutput() WeightedBackendServiceArrayOutput
	ToWeightedBackendServiceArrayOutputWithContext(context.Context) WeightedBackendServiceArrayOutput
}

type WeightedBackendServiceArray []WeightedBackendServiceInput

func (WeightedBackendServiceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WeightedBackendService)(nil)).Elem()
}

func (i WeightedBackendServiceArray) ToWeightedBackendServiceArrayOutput() WeightedBackendServiceArrayOutput {
	return i.ToWeightedBackendServiceArrayOutputWithContext(context.Background())
}

func (i WeightedBackendServiceArray) ToWeightedBackendServiceArrayOutputWithContext(ctx context.Context) WeightedBackendServiceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WeightedBackendServiceArrayOutput)
}

func (i WeightedBackendServiceArray) ToOutput(ctx context.Context) pulumix.Output[[]WeightedBackendService] {
	return pulumix.Output[[]WeightedBackendService]{
		OutputState: i.ToWeightedBackendServiceArrayOutputWithContext(ctx).OutputState,
	}
}

// In contrast to a single BackendService in HttpRouteAction to which all matching traffic is directed to, WeightedBackendService allows traffic to be split across multiple backend services. The volume of traffic for each backend service is proportional to the weight specified in each WeightedBackendService
type WeightedBackendServiceOutput struct{ *pulumi.OutputState }

func (WeightedBackendServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WeightedBackendService)(nil)).Elem()
}

func (o WeightedBackendServiceOutput) ToWeightedBackendServiceOutput() WeightedBackendServiceOutput {
	return o
}

func (o WeightedBackendServiceOutput) ToWeightedBackendServiceOutputWithContext(ctx context.Context) WeightedBackendServiceOutput {
	return o
}

func (o WeightedBackendServiceOutput) ToOutput(ctx context.Context) pulumix.Output[WeightedBackendService] {
	return pulumix.Output[WeightedBackendService]{
		OutputState: o.OutputState,
	}
}

// The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
func (o WeightedBackendServiceOutput) BackendService() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WeightedBackendService) *string { return v.BackendService }).(pulumi.StringPtrOutput)
}

// Specifies changes to request and response headers that need to take effect for the selected backendService. headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap. headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL. Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
func (o WeightedBackendServiceOutput) HeaderAction() HttpHeaderActionPtrOutput {
	return o.ApplyT(func(v WeightedBackendService) *HttpHeaderAction { return v.HeaderAction }).(HttpHeaderActionPtrOutput)
}

// Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) . The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy. The value must be from 0 to 1000.
func (o WeightedBackendServiceOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v WeightedBackendService) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type WeightedBackendServiceArrayOutput struct{ *pulumi.OutputState }

func (WeightedBackendServiceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WeightedBackendService)(nil)).Elem()
}

func (o WeightedBackendServiceArrayOutput) ToWeightedBackendServiceArrayOutput() WeightedBackendServiceArrayOutput {
	return o
}

func (o WeightedBackendServiceArrayOutput) ToWeightedBackendServiceArrayOutputWithContext(ctx context.Context) WeightedBackendServiceArrayOutput {
	return o
}

func (o WeightedBackendServiceArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]WeightedBackendService] {
	return pulumix.Output[[]WeightedBackendService]{
		OutputState: o.OutputState,
	}
}

func (o WeightedBackendServiceArrayOutput) Index(i pulumi.IntInput) WeightedBackendServiceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WeightedBackendService {
		return vs[0].([]WeightedBackendService)[vs[1].(int)]
	}).(WeightedBackendServiceOutput)
}

// In contrast to a single BackendService in HttpRouteAction to which all matching traffic is directed to, WeightedBackendService allows traffic to be split across multiple backend services. The volume of traffic for each backend service is proportional to the weight specified in each WeightedBackendService
type WeightedBackendServiceResponse struct {
	// The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
	BackendService string `pulumi:"backendService"`
	// Specifies changes to request and response headers that need to take effect for the selected backendService. headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap. headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL. Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
	HeaderAction HttpHeaderActionResponse `pulumi:"headerAction"`
	// Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) . The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy. The value must be from 0 to 1000.
	Weight int `pulumi:"weight"`
}

// In contrast to a single BackendService in HttpRouteAction to which all matching traffic is directed to, WeightedBackendService allows traffic to be split across multiple backend services. The volume of traffic for each backend service is proportional to the weight specified in each WeightedBackendService
type WeightedBackendServiceResponseOutput struct{ *pulumi.OutputState }

func (WeightedBackendServiceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WeightedBackendServiceResponse)(nil)).Elem()
}

func (o WeightedBackendServiceResponseOutput) ToWeightedBackendServiceResponseOutput() WeightedBackendServiceResponseOutput {
	return o
}

func (o WeightedBackendServiceResponseOutput) ToWeightedBackendServiceResponseOutputWithContext(ctx context.Context) WeightedBackendServiceResponseOutput {
	return o
}

func (o WeightedBackendServiceResponseOutput) ToOutput(ctx context.Context) pulumix.Output[WeightedBackendServiceResponse] {
	return pulumix.Output[WeightedBackendServiceResponse]{
		OutputState: o.OutputState,
	}
}

// The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
func (o WeightedBackendServiceResponseOutput) BackendService() pulumi.StringOutput {
	return o.ApplyT(func(v WeightedBackendServiceResponse) string { return v.BackendService }).(pulumi.StringOutput)
}

// Specifies changes to request and response headers that need to take effect for the selected backendService. headerAction specified here take effect before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap. headerAction is not supported for load balancers that have their loadBalancingScheme set to EXTERNAL. Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
func (o WeightedBackendServiceResponseOutput) HeaderAction() HttpHeaderActionResponseOutput {
	return o.ApplyT(func(v WeightedBackendServiceResponse) HttpHeaderActionResponse { return v.HeaderAction }).(HttpHeaderActionResponseOutput)
}

// Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) . The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy. The value must be from 0 to 1000.
func (o WeightedBackendServiceResponseOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v WeightedBackendServiceResponse) int { return v.Weight }).(pulumi.IntOutput)
}

type WeightedBackendServiceResponseArrayOutput struct{ *pulumi.OutputState }

func (WeightedBackendServiceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WeightedBackendServiceResponse)(nil)).Elem()
}

func (o WeightedBackendServiceResponseArrayOutput) ToWeightedBackendServiceResponseArrayOutput() WeightedBackendServiceResponseArrayOutput {
	return o
}

func (o WeightedBackendServiceResponseArrayOutput) ToWeightedBackendServiceResponseArrayOutputWithContext(ctx context.Context) WeightedBackendServiceResponseArrayOutput {
	return o
}

func (o WeightedBackendServiceResponseArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]WeightedBackendServiceResponse] {
	return pulumix.Output[[]WeightedBackendServiceResponse]{
		OutputState: o.OutputState,
	}
}

func (o WeightedBackendServiceResponseArrayOutput) Index(i pulumi.IntInput) WeightedBackendServiceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WeightedBackendServiceResponse {
		return vs[0].([]WeightedBackendServiceResponse)[vs[1].(int)]
	}).(WeightedBackendServiceResponseOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*UrlMapTestInput)(nil)).Elem(), UrlMapTestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UrlMapTestArrayInput)(nil)).Elem(), UrlMapTestArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UrlMapTestHeaderInput)(nil)).Elem(), UrlMapTestHeaderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UrlMapTestHeaderArrayInput)(nil)).Elem(), UrlMapTestHeaderArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UrlRewriteInput)(nil)).Elem(), UrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UrlRewritePtrInput)(nil)).Elem(), UrlRewriteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpnGatewayVpnGatewayInterfaceInput)(nil)).Elem(), VpnGatewayVpnGatewayInterfaceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpnGatewayVpnGatewayInterfaceArrayInput)(nil)).Elem(), VpnGatewayVpnGatewayInterfaceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WeightedBackendServiceInput)(nil)).Elem(), WeightedBackendServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WeightedBackendServiceArrayInput)(nil)).Elem(), WeightedBackendServiceArray{})
	pulumi.RegisterOutputType(TagsResponseOutput{})
	pulumi.RegisterOutputType(Uint128ResponseOutput{})
	pulumi.RegisterOutputType(UpcomingMaintenanceResponseOutput{})
	pulumi.RegisterOutputType(UrlMapTestOutput{})
	pulumi.RegisterOutputType(UrlMapTestArrayOutput{})
	pulumi.RegisterOutputType(UrlMapTestHeaderOutput{})
	pulumi.RegisterOutputType(UrlMapTestHeaderArrayOutput{})
	pulumi.RegisterOutputType(UrlMapTestHeaderResponseOutput{})
	pulumi.RegisterOutputType(UrlMapTestHeaderResponseArrayOutput{})
	pulumi.RegisterOutputType(UrlMapTestResponseOutput{})
	pulumi.RegisterOutputType(UrlMapTestResponseArrayOutput{})
	pulumi.RegisterOutputType(UrlRewriteOutput{})
	pulumi.RegisterOutputType(UrlRewritePtrOutput{})
	pulumi.RegisterOutputType(UrlRewriteResponseOutput{})
	pulumi.RegisterOutputType(VpnGatewayVpnGatewayInterfaceOutput{})
	pulumi.RegisterOutputType(VpnGatewayVpnGatewayInterfaceArrayOutput{})
	pulumi.RegisterOutputType(VpnGatewayVpnGatewayInterfaceResponseOutput{})
	pulumi.RegisterOutputType(VpnGatewayVpnGatewayInterfaceResponseArrayOutput{})
	pulumi.RegisterOutputType(WeightedBackendServiceOutput{})
	pulumi.RegisterOutputType(WeightedBackendServiceArrayOutput{})
	pulumi.RegisterOutputType(WeightedBackendServiceResponseOutput{})
	pulumi.RegisterOutputType(WeightedBackendServiceResponseArrayOutput{})
}

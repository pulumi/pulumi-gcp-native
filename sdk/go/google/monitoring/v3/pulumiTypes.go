// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v3

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type Aggregation struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
	AlignmentPeriod *string `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer *AggregationCrossSeriesReducer `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields []string `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner *AggregationPerSeriesAligner `pulumi:"perSeriesAligner"`
}

// AggregationInput is an input type that accepts AggregationArgs and AggregationOutput values.
// You can construct a concrete instance of `AggregationInput` via:
//
//	AggregationArgs{...}
type AggregationInput interface {
	pulumi.Input

	ToAggregationOutput() AggregationOutput
	ToAggregationOutputWithContext(context.Context) AggregationOutput
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationArgs struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
	AlignmentPeriod pulumi.StringPtrInput `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer AggregationCrossSeriesReducerPtrInput `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields pulumi.StringArrayInput `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner AggregationPerSeriesAlignerPtrInput `pulumi:"perSeriesAligner"`
}

func (AggregationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Aggregation)(nil)).Elem()
}

func (i AggregationArgs) ToAggregationOutput() AggregationOutput {
	return i.ToAggregationOutputWithContext(context.Background())
}

func (i AggregationArgs) ToAggregationOutputWithContext(ctx context.Context) AggregationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationOutput)
}

// AggregationArrayInput is an input type that accepts AggregationArray and AggregationArrayOutput values.
// You can construct a concrete instance of `AggregationArrayInput` via:
//
//	AggregationArray{ AggregationArgs{...} }
type AggregationArrayInput interface {
	pulumi.Input

	ToAggregationArrayOutput() AggregationArrayOutput
	ToAggregationArrayOutputWithContext(context.Context) AggregationArrayOutput
}

type AggregationArray []AggregationInput

func (AggregationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Aggregation)(nil)).Elem()
}

func (i AggregationArray) ToAggregationArrayOutput() AggregationArrayOutput {
	return i.ToAggregationArrayOutputWithContext(context.Background())
}

func (i AggregationArray) ToAggregationArrayOutputWithContext(ctx context.Context) AggregationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationArrayOutput)
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationOutput struct{ *pulumi.OutputState }

func (AggregationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Aggregation)(nil)).Elem()
}

func (o AggregationOutput) ToAggregationOutput() AggregationOutput {
	return o
}

func (o AggregationOutput) ToAggregationOutputWithContext(ctx context.Context) AggregationOutput {
	return o
}

// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
func (o AggregationOutput) AlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Aggregation) *string { return v.AlignmentPeriod }).(pulumi.StringPtrOutput)
}

// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
func (o AggregationOutput) CrossSeriesReducer() AggregationCrossSeriesReducerPtrOutput {
	return o.ApplyT(func(v Aggregation) *AggregationCrossSeriesReducer { return v.CrossSeriesReducer }).(AggregationCrossSeriesReducerPtrOutput)
}

// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
func (o AggregationOutput) GroupByFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Aggregation) []string { return v.GroupByFields }).(pulumi.StringArrayOutput)
}

// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
func (o AggregationOutput) PerSeriesAligner() AggregationPerSeriesAlignerPtrOutput {
	return o.ApplyT(func(v Aggregation) *AggregationPerSeriesAligner { return v.PerSeriesAligner }).(AggregationPerSeriesAlignerPtrOutput)
}

type AggregationArrayOutput struct{ *pulumi.OutputState }

func (AggregationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Aggregation)(nil)).Elem()
}

func (o AggregationArrayOutput) ToAggregationArrayOutput() AggregationArrayOutput {
	return o
}

func (o AggregationArrayOutput) ToAggregationArrayOutputWithContext(ctx context.Context) AggregationArrayOutput {
	return o
}

func (o AggregationArrayOutput) Index(i pulumi.IntInput) AggregationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Aggregation {
		return vs[0].([]Aggregation)[vs[1].(int)]
	}).(AggregationOutput)
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationResponse struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
	AlignmentPeriod string `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer string `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields []string `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner string `pulumi:"perSeriesAligner"`
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationResponseOutput struct{ *pulumi.OutputState }

func (AggregationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AggregationResponse)(nil)).Elem()
}

func (o AggregationResponseOutput) ToAggregationResponseOutput() AggregationResponseOutput {
	return o
}

func (o AggregationResponseOutput) ToAggregationResponseOutputWithContext(ctx context.Context) AggregationResponseOutput {
	return o
}

// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
func (o AggregationResponseOutput) AlignmentPeriod() pulumi.StringOutput {
	return o.ApplyT(func(v AggregationResponse) string { return v.AlignmentPeriod }).(pulumi.StringOutput)
}

// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
func (o AggregationResponseOutput) CrossSeriesReducer() pulumi.StringOutput {
	return o.ApplyT(func(v AggregationResponse) string { return v.CrossSeriesReducer }).(pulumi.StringOutput)
}

// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
func (o AggregationResponseOutput) GroupByFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AggregationResponse) []string { return v.GroupByFields }).(pulumi.StringArrayOutput)
}

// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
func (o AggregationResponseOutput) PerSeriesAligner() pulumi.StringOutput {
	return o.ApplyT(func(v AggregationResponse) string { return v.PerSeriesAligner }).(pulumi.StringOutput)
}

type AggregationResponseArrayOutput struct{ *pulumi.OutputState }

func (AggregationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AggregationResponse)(nil)).Elem()
}

func (o AggregationResponseArrayOutput) ToAggregationResponseArrayOutput() AggregationResponseArrayOutput {
	return o
}

func (o AggregationResponseArrayOutput) ToAggregationResponseArrayOutputWithContext(ctx context.Context) AggregationResponseArrayOutput {
	return o
}

func (o AggregationResponseArrayOutput) Index(i pulumi.IntInput) AggregationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AggregationResponse {
		return vs[0].([]AggregationResponse)[vs[1].(int)]
	}).(AggregationResponseOutput)
}

// Control over how the notification channels in notification_channels are notified when this alert fires.
type AlertStrategy struct {
	// If an alert policy that was active has no data for this long, any open incidents will close
	AutoClose *string `pulumi:"autoClose"`
	// Control how notifications will be sent out, on a per-channel basis.
	NotificationChannelStrategy []NotificationChannelStrategy `pulumi:"notificationChannelStrategy"`
	// Required for alert policies with a LogMatch condition.This limit is not implemented for alert policies that are not log-based.
	NotificationRateLimit *NotificationRateLimit `pulumi:"notificationRateLimit"`
}

// AlertStrategyInput is an input type that accepts AlertStrategyArgs and AlertStrategyOutput values.
// You can construct a concrete instance of `AlertStrategyInput` via:
//
//	AlertStrategyArgs{...}
type AlertStrategyInput interface {
	pulumi.Input

	ToAlertStrategyOutput() AlertStrategyOutput
	ToAlertStrategyOutputWithContext(context.Context) AlertStrategyOutput
}

// Control over how the notification channels in notification_channels are notified when this alert fires.
type AlertStrategyArgs struct {
	// If an alert policy that was active has no data for this long, any open incidents will close
	AutoClose pulumi.StringPtrInput `pulumi:"autoClose"`
	// Control how notifications will be sent out, on a per-channel basis.
	NotificationChannelStrategy NotificationChannelStrategyArrayInput `pulumi:"notificationChannelStrategy"`
	// Required for alert policies with a LogMatch condition.This limit is not implemented for alert policies that are not log-based.
	NotificationRateLimit NotificationRateLimitPtrInput `pulumi:"notificationRateLimit"`
}

func (AlertStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertStrategy)(nil)).Elem()
}

func (i AlertStrategyArgs) ToAlertStrategyOutput() AlertStrategyOutput {
	return i.ToAlertStrategyOutputWithContext(context.Background())
}

func (i AlertStrategyArgs) ToAlertStrategyOutputWithContext(ctx context.Context) AlertStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertStrategyOutput)
}

func (i AlertStrategyArgs) ToAlertStrategyPtrOutput() AlertStrategyPtrOutput {
	return i.ToAlertStrategyPtrOutputWithContext(context.Background())
}

func (i AlertStrategyArgs) ToAlertStrategyPtrOutputWithContext(ctx context.Context) AlertStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertStrategyOutput).ToAlertStrategyPtrOutputWithContext(ctx)
}

// AlertStrategyPtrInput is an input type that accepts AlertStrategyArgs, AlertStrategyPtr and AlertStrategyPtrOutput values.
// You can construct a concrete instance of `AlertStrategyPtrInput` via:
//
//	        AlertStrategyArgs{...}
//
//	or:
//
//	        nil
type AlertStrategyPtrInput interface {
	pulumi.Input

	ToAlertStrategyPtrOutput() AlertStrategyPtrOutput
	ToAlertStrategyPtrOutputWithContext(context.Context) AlertStrategyPtrOutput
}

type alertStrategyPtrType AlertStrategyArgs

func AlertStrategyPtr(v *AlertStrategyArgs) AlertStrategyPtrInput {
	return (*alertStrategyPtrType)(v)
}

func (*alertStrategyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertStrategy)(nil)).Elem()
}

func (i *alertStrategyPtrType) ToAlertStrategyPtrOutput() AlertStrategyPtrOutput {
	return i.ToAlertStrategyPtrOutputWithContext(context.Background())
}

func (i *alertStrategyPtrType) ToAlertStrategyPtrOutputWithContext(ctx context.Context) AlertStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertStrategyPtrOutput)
}

// Control over how the notification channels in notification_channels are notified when this alert fires.
type AlertStrategyOutput struct{ *pulumi.OutputState }

func (AlertStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertStrategy)(nil)).Elem()
}

func (o AlertStrategyOutput) ToAlertStrategyOutput() AlertStrategyOutput {
	return o
}

func (o AlertStrategyOutput) ToAlertStrategyOutputWithContext(ctx context.Context) AlertStrategyOutput {
	return o
}

func (o AlertStrategyOutput) ToAlertStrategyPtrOutput() AlertStrategyPtrOutput {
	return o.ToAlertStrategyPtrOutputWithContext(context.Background())
}

func (o AlertStrategyOutput) ToAlertStrategyPtrOutputWithContext(ctx context.Context) AlertStrategyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AlertStrategy) *AlertStrategy {
		return &v
	}).(AlertStrategyPtrOutput)
}

// If an alert policy that was active has no data for this long, any open incidents will close
func (o AlertStrategyOutput) AutoClose() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AlertStrategy) *string { return v.AutoClose }).(pulumi.StringPtrOutput)
}

// Control how notifications will be sent out, on a per-channel basis.
func (o AlertStrategyOutput) NotificationChannelStrategy() NotificationChannelStrategyArrayOutput {
	return o.ApplyT(func(v AlertStrategy) []NotificationChannelStrategy { return v.NotificationChannelStrategy }).(NotificationChannelStrategyArrayOutput)
}

// Required for alert policies with a LogMatch condition.This limit is not implemented for alert policies that are not log-based.
func (o AlertStrategyOutput) NotificationRateLimit() NotificationRateLimitPtrOutput {
	return o.ApplyT(func(v AlertStrategy) *NotificationRateLimit { return v.NotificationRateLimit }).(NotificationRateLimitPtrOutput)
}

type AlertStrategyPtrOutput struct{ *pulumi.OutputState }

func (AlertStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertStrategy)(nil)).Elem()
}

func (o AlertStrategyPtrOutput) ToAlertStrategyPtrOutput() AlertStrategyPtrOutput {
	return o
}

func (o AlertStrategyPtrOutput) ToAlertStrategyPtrOutputWithContext(ctx context.Context) AlertStrategyPtrOutput {
	return o
}

func (o AlertStrategyPtrOutput) Elem() AlertStrategyOutput {
	return o.ApplyT(func(v *AlertStrategy) AlertStrategy {
		if v != nil {
			return *v
		}
		var ret AlertStrategy
		return ret
	}).(AlertStrategyOutput)
}

// If an alert policy that was active has no data for this long, any open incidents will close
func (o AlertStrategyPtrOutput) AutoClose() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlertStrategy) *string {
		if v == nil {
			return nil
		}
		return v.AutoClose
	}).(pulumi.StringPtrOutput)
}

// Control how notifications will be sent out, on a per-channel basis.
func (o AlertStrategyPtrOutput) NotificationChannelStrategy() NotificationChannelStrategyArrayOutput {
	return o.ApplyT(func(v *AlertStrategy) []NotificationChannelStrategy {
		if v == nil {
			return nil
		}
		return v.NotificationChannelStrategy
	}).(NotificationChannelStrategyArrayOutput)
}

// Required for alert policies with a LogMatch condition.This limit is not implemented for alert policies that are not log-based.
func (o AlertStrategyPtrOutput) NotificationRateLimit() NotificationRateLimitPtrOutput {
	return o.ApplyT(func(v *AlertStrategy) *NotificationRateLimit {
		if v == nil {
			return nil
		}
		return v.NotificationRateLimit
	}).(NotificationRateLimitPtrOutput)
}

// Control over how the notification channels in notification_channels are notified when this alert fires.
type AlertStrategyResponse struct {
	// If an alert policy that was active has no data for this long, any open incidents will close
	AutoClose string `pulumi:"autoClose"`
	// Control how notifications will be sent out, on a per-channel basis.
	NotificationChannelStrategy []NotificationChannelStrategyResponse `pulumi:"notificationChannelStrategy"`
	// Required for alert policies with a LogMatch condition.This limit is not implemented for alert policies that are not log-based.
	NotificationRateLimit NotificationRateLimitResponse `pulumi:"notificationRateLimit"`
}

// Control over how the notification channels in notification_channels are notified when this alert fires.
type AlertStrategyResponseOutput struct{ *pulumi.OutputState }

func (AlertStrategyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertStrategyResponse)(nil)).Elem()
}

func (o AlertStrategyResponseOutput) ToAlertStrategyResponseOutput() AlertStrategyResponseOutput {
	return o
}

func (o AlertStrategyResponseOutput) ToAlertStrategyResponseOutputWithContext(ctx context.Context) AlertStrategyResponseOutput {
	return o
}

// If an alert policy that was active has no data for this long, any open incidents will close
func (o AlertStrategyResponseOutput) AutoClose() pulumi.StringOutput {
	return o.ApplyT(func(v AlertStrategyResponse) string { return v.AutoClose }).(pulumi.StringOutput)
}

// Control how notifications will be sent out, on a per-channel basis.
func (o AlertStrategyResponseOutput) NotificationChannelStrategy() NotificationChannelStrategyResponseArrayOutput {
	return o.ApplyT(func(v AlertStrategyResponse) []NotificationChannelStrategyResponse {
		return v.NotificationChannelStrategy
	}).(NotificationChannelStrategyResponseArrayOutput)
}

// Required for alert policies with a LogMatch condition.This limit is not implemented for alert policies that are not log-based.
func (o AlertStrategyResponseOutput) NotificationRateLimit() NotificationRateLimitResponseOutput {
	return o.ApplyT(func(v AlertStrategyResponse) NotificationRateLimitResponse { return v.NotificationRateLimit }).(NotificationRateLimitResponseOutput)
}

// App Engine service. Learn more at https://cloud.google.com/appengine.
type AppEngine struct {
	// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource (https://cloud.google.com/monitoring/api/resources#tag_gae_app).
	ModuleId *string `pulumi:"moduleId"`
}

// AppEngineInput is an input type that accepts AppEngineArgs and AppEngineOutput values.
// You can construct a concrete instance of `AppEngineInput` via:
//
//	AppEngineArgs{...}
type AppEngineInput interface {
	pulumi.Input

	ToAppEngineOutput() AppEngineOutput
	ToAppEngineOutputWithContext(context.Context) AppEngineOutput
}

// App Engine service. Learn more at https://cloud.google.com/appengine.
type AppEngineArgs struct {
	// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource (https://cloud.google.com/monitoring/api/resources#tag_gae_app).
	ModuleId pulumi.StringPtrInput `pulumi:"moduleId"`
}

func (AppEngineArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AppEngine)(nil)).Elem()
}

func (i AppEngineArgs) ToAppEngineOutput() AppEngineOutput {
	return i.ToAppEngineOutputWithContext(context.Background())
}

func (i AppEngineArgs) ToAppEngineOutputWithContext(ctx context.Context) AppEngineOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppEngineOutput)
}

func (i AppEngineArgs) ToAppEnginePtrOutput() AppEnginePtrOutput {
	return i.ToAppEnginePtrOutputWithContext(context.Background())
}

func (i AppEngineArgs) ToAppEnginePtrOutputWithContext(ctx context.Context) AppEnginePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppEngineOutput).ToAppEnginePtrOutputWithContext(ctx)
}

// AppEnginePtrInput is an input type that accepts AppEngineArgs, AppEnginePtr and AppEnginePtrOutput values.
// You can construct a concrete instance of `AppEnginePtrInput` via:
//
//	        AppEngineArgs{...}
//
//	or:
//
//	        nil
type AppEnginePtrInput interface {
	pulumi.Input

	ToAppEnginePtrOutput() AppEnginePtrOutput
	ToAppEnginePtrOutputWithContext(context.Context) AppEnginePtrOutput
}

type appEnginePtrType AppEngineArgs

func AppEnginePtr(v *AppEngineArgs) AppEnginePtrInput {
	return (*appEnginePtrType)(v)
}

func (*appEnginePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AppEngine)(nil)).Elem()
}

func (i *appEnginePtrType) ToAppEnginePtrOutput() AppEnginePtrOutput {
	return i.ToAppEnginePtrOutputWithContext(context.Background())
}

func (i *appEnginePtrType) ToAppEnginePtrOutputWithContext(ctx context.Context) AppEnginePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppEnginePtrOutput)
}

// App Engine service. Learn more at https://cloud.google.com/appengine.
type AppEngineOutput struct{ *pulumi.OutputState }

func (AppEngineOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AppEngine)(nil)).Elem()
}

func (o AppEngineOutput) ToAppEngineOutput() AppEngineOutput {
	return o
}

func (o AppEngineOutput) ToAppEngineOutputWithContext(ctx context.Context) AppEngineOutput {
	return o
}

func (o AppEngineOutput) ToAppEnginePtrOutput() AppEnginePtrOutput {
	return o.ToAppEnginePtrOutputWithContext(context.Background())
}

func (o AppEngineOutput) ToAppEnginePtrOutputWithContext(ctx context.Context) AppEnginePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AppEngine) *AppEngine {
		return &v
	}).(AppEnginePtrOutput)
}

// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource (https://cloud.google.com/monitoring/api/resources#tag_gae_app).
func (o AppEngineOutput) ModuleId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AppEngine) *string { return v.ModuleId }).(pulumi.StringPtrOutput)
}

type AppEnginePtrOutput struct{ *pulumi.OutputState }

func (AppEnginePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AppEngine)(nil)).Elem()
}

func (o AppEnginePtrOutput) ToAppEnginePtrOutput() AppEnginePtrOutput {
	return o
}

func (o AppEnginePtrOutput) ToAppEnginePtrOutputWithContext(ctx context.Context) AppEnginePtrOutput {
	return o
}

func (o AppEnginePtrOutput) Elem() AppEngineOutput {
	return o.ApplyT(func(v *AppEngine) AppEngine {
		if v != nil {
			return *v
		}
		var ret AppEngine
		return ret
	}).(AppEngineOutput)
}

// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource (https://cloud.google.com/monitoring/api/resources#tag_gae_app).
func (o AppEnginePtrOutput) ModuleId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AppEngine) *string {
		if v == nil {
			return nil
		}
		return v.ModuleId
	}).(pulumi.StringPtrOutput)
}

// App Engine service. Learn more at https://cloud.google.com/appengine.
type AppEngineResponse struct {
	// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource (https://cloud.google.com/monitoring/api/resources#tag_gae_app).
	ModuleId string `pulumi:"moduleId"`
}

// App Engine service. Learn more at https://cloud.google.com/appengine.
type AppEngineResponseOutput struct{ *pulumi.OutputState }

func (AppEngineResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AppEngineResponse)(nil)).Elem()
}

func (o AppEngineResponseOutput) ToAppEngineResponseOutput() AppEngineResponseOutput {
	return o
}

func (o AppEngineResponseOutput) ToAppEngineResponseOutputWithContext(ctx context.Context) AppEngineResponseOutput {
	return o
}

// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource (https://cloud.google.com/monitoring/api/resources#tag_gae_app).
func (o AppEngineResponseOutput) ModuleId() pulumi.StringOutput {
	return o.ApplyT(func(v AppEngineResponse) string { return v.ModuleId }).(pulumi.StringOutput)
}

// Future parameters for the availability SLI.
type AvailabilityCriteria struct {
}

// AvailabilityCriteriaInput is an input type that accepts AvailabilityCriteriaArgs and AvailabilityCriteriaOutput values.
// You can construct a concrete instance of `AvailabilityCriteriaInput` via:
//
//	AvailabilityCriteriaArgs{...}
type AvailabilityCriteriaInput interface {
	pulumi.Input

	ToAvailabilityCriteriaOutput() AvailabilityCriteriaOutput
	ToAvailabilityCriteriaOutputWithContext(context.Context) AvailabilityCriteriaOutput
}

// Future parameters for the availability SLI.
type AvailabilityCriteriaArgs struct {
}

func (AvailabilityCriteriaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AvailabilityCriteria)(nil)).Elem()
}

func (i AvailabilityCriteriaArgs) ToAvailabilityCriteriaOutput() AvailabilityCriteriaOutput {
	return i.ToAvailabilityCriteriaOutputWithContext(context.Background())
}

func (i AvailabilityCriteriaArgs) ToAvailabilityCriteriaOutputWithContext(ctx context.Context) AvailabilityCriteriaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailabilityCriteriaOutput)
}

func (i AvailabilityCriteriaArgs) ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput {
	return i.ToAvailabilityCriteriaPtrOutputWithContext(context.Background())
}

func (i AvailabilityCriteriaArgs) ToAvailabilityCriteriaPtrOutputWithContext(ctx context.Context) AvailabilityCriteriaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailabilityCriteriaOutput).ToAvailabilityCriteriaPtrOutputWithContext(ctx)
}

// AvailabilityCriteriaPtrInput is an input type that accepts AvailabilityCriteriaArgs, AvailabilityCriteriaPtr and AvailabilityCriteriaPtrOutput values.
// You can construct a concrete instance of `AvailabilityCriteriaPtrInput` via:
//
//	        AvailabilityCriteriaArgs{...}
//
//	or:
//
//	        nil
type AvailabilityCriteriaPtrInput interface {
	pulumi.Input

	ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput
	ToAvailabilityCriteriaPtrOutputWithContext(context.Context) AvailabilityCriteriaPtrOutput
}

type availabilityCriteriaPtrType AvailabilityCriteriaArgs

func AvailabilityCriteriaPtr(v *AvailabilityCriteriaArgs) AvailabilityCriteriaPtrInput {
	return (*availabilityCriteriaPtrType)(v)
}

func (*availabilityCriteriaPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AvailabilityCriteria)(nil)).Elem()
}

func (i *availabilityCriteriaPtrType) ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput {
	return i.ToAvailabilityCriteriaPtrOutputWithContext(context.Background())
}

func (i *availabilityCriteriaPtrType) ToAvailabilityCriteriaPtrOutputWithContext(ctx context.Context) AvailabilityCriteriaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailabilityCriteriaPtrOutput)
}

// Future parameters for the availability SLI.
type AvailabilityCriteriaOutput struct{ *pulumi.OutputState }

func (AvailabilityCriteriaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AvailabilityCriteria)(nil)).Elem()
}

func (o AvailabilityCriteriaOutput) ToAvailabilityCriteriaOutput() AvailabilityCriteriaOutput {
	return o
}

func (o AvailabilityCriteriaOutput) ToAvailabilityCriteriaOutputWithContext(ctx context.Context) AvailabilityCriteriaOutput {
	return o
}

func (o AvailabilityCriteriaOutput) ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput {
	return o.ToAvailabilityCriteriaPtrOutputWithContext(context.Background())
}

func (o AvailabilityCriteriaOutput) ToAvailabilityCriteriaPtrOutputWithContext(ctx context.Context) AvailabilityCriteriaPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AvailabilityCriteria) *AvailabilityCriteria {
		return &v
	}).(AvailabilityCriteriaPtrOutput)
}

type AvailabilityCriteriaPtrOutput struct{ *pulumi.OutputState }

func (AvailabilityCriteriaPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AvailabilityCriteria)(nil)).Elem()
}

func (o AvailabilityCriteriaPtrOutput) ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput {
	return o
}

func (o AvailabilityCriteriaPtrOutput) ToAvailabilityCriteriaPtrOutputWithContext(ctx context.Context) AvailabilityCriteriaPtrOutput {
	return o
}

func (o AvailabilityCriteriaPtrOutput) Elem() AvailabilityCriteriaOutput {
	return o.ApplyT(func(v *AvailabilityCriteria) AvailabilityCriteria {
		if v != nil {
			return *v
		}
		var ret AvailabilityCriteria
		return ret
	}).(AvailabilityCriteriaOutput)
}

// Future parameters for the availability SLI.
type AvailabilityCriteriaResponse struct {
}

// Future parameters for the availability SLI.
type AvailabilityCriteriaResponseOutput struct{ *pulumi.OutputState }

func (AvailabilityCriteriaResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AvailabilityCriteriaResponse)(nil)).Elem()
}

func (o AvailabilityCriteriaResponseOutput) ToAvailabilityCriteriaResponseOutput() AvailabilityCriteriaResponseOutput {
	return o
}

func (o AvailabilityCriteriaResponseOutput) ToAvailabilityCriteriaResponseOutputWithContext(ctx context.Context) AvailabilityCriteriaResponseOutput {
	return o
}

// The authentication parameters to provide to the specified resource or URL that requires a username and password. Currently, only Basic HTTP authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime checks.
type BasicAuthentication struct {
	// The password to use when authenticating with the HTTP server.
	Password *string `pulumi:"password"`
	// The username to use when authenticating with the HTTP server.
	Username *string `pulumi:"username"`
}

// BasicAuthenticationInput is an input type that accepts BasicAuthenticationArgs and BasicAuthenticationOutput values.
// You can construct a concrete instance of `BasicAuthenticationInput` via:
//
//	BasicAuthenticationArgs{...}
type BasicAuthenticationInput interface {
	pulumi.Input

	ToBasicAuthenticationOutput() BasicAuthenticationOutput
	ToBasicAuthenticationOutputWithContext(context.Context) BasicAuthenticationOutput
}

// The authentication parameters to provide to the specified resource or URL that requires a username and password. Currently, only Basic HTTP authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime checks.
type BasicAuthenticationArgs struct {
	// The password to use when authenticating with the HTTP server.
	Password pulumi.StringPtrInput `pulumi:"password"`
	// The username to use when authenticating with the HTTP server.
	Username pulumi.StringPtrInput `pulumi:"username"`
}

func (BasicAuthenticationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicAuthentication)(nil)).Elem()
}

func (i BasicAuthenticationArgs) ToBasicAuthenticationOutput() BasicAuthenticationOutput {
	return i.ToBasicAuthenticationOutputWithContext(context.Background())
}

func (i BasicAuthenticationArgs) ToBasicAuthenticationOutputWithContext(ctx context.Context) BasicAuthenticationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicAuthenticationOutput)
}

func (i BasicAuthenticationArgs) ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput {
	return i.ToBasicAuthenticationPtrOutputWithContext(context.Background())
}

func (i BasicAuthenticationArgs) ToBasicAuthenticationPtrOutputWithContext(ctx context.Context) BasicAuthenticationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicAuthenticationOutput).ToBasicAuthenticationPtrOutputWithContext(ctx)
}

// BasicAuthenticationPtrInput is an input type that accepts BasicAuthenticationArgs, BasicAuthenticationPtr and BasicAuthenticationPtrOutput values.
// You can construct a concrete instance of `BasicAuthenticationPtrInput` via:
//
//	        BasicAuthenticationArgs{...}
//
//	or:
//
//	        nil
type BasicAuthenticationPtrInput interface {
	pulumi.Input

	ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput
	ToBasicAuthenticationPtrOutputWithContext(context.Context) BasicAuthenticationPtrOutput
}

type basicAuthenticationPtrType BasicAuthenticationArgs

func BasicAuthenticationPtr(v *BasicAuthenticationArgs) BasicAuthenticationPtrInput {
	return (*basicAuthenticationPtrType)(v)
}

func (*basicAuthenticationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicAuthentication)(nil)).Elem()
}

func (i *basicAuthenticationPtrType) ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput {
	return i.ToBasicAuthenticationPtrOutputWithContext(context.Background())
}

func (i *basicAuthenticationPtrType) ToBasicAuthenticationPtrOutputWithContext(ctx context.Context) BasicAuthenticationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicAuthenticationPtrOutput)
}

// The authentication parameters to provide to the specified resource or URL that requires a username and password. Currently, only Basic HTTP authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime checks.
type BasicAuthenticationOutput struct{ *pulumi.OutputState }

func (BasicAuthenticationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicAuthentication)(nil)).Elem()
}

func (o BasicAuthenticationOutput) ToBasicAuthenticationOutput() BasicAuthenticationOutput {
	return o
}

func (o BasicAuthenticationOutput) ToBasicAuthenticationOutputWithContext(ctx context.Context) BasicAuthenticationOutput {
	return o
}

func (o BasicAuthenticationOutput) ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput {
	return o.ToBasicAuthenticationPtrOutputWithContext(context.Background())
}

func (o BasicAuthenticationOutput) ToBasicAuthenticationPtrOutputWithContext(ctx context.Context) BasicAuthenticationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BasicAuthentication) *BasicAuthentication {
		return &v
	}).(BasicAuthenticationPtrOutput)
}

// The password to use when authenticating with the HTTP server.
func (o BasicAuthenticationOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BasicAuthentication) *string { return v.Password }).(pulumi.StringPtrOutput)
}

// The username to use when authenticating with the HTTP server.
func (o BasicAuthenticationOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BasicAuthentication) *string { return v.Username }).(pulumi.StringPtrOutput)
}

type BasicAuthenticationPtrOutput struct{ *pulumi.OutputState }

func (BasicAuthenticationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicAuthentication)(nil)).Elem()
}

func (o BasicAuthenticationPtrOutput) ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput {
	return o
}

func (o BasicAuthenticationPtrOutput) ToBasicAuthenticationPtrOutputWithContext(ctx context.Context) BasicAuthenticationPtrOutput {
	return o
}

func (o BasicAuthenticationPtrOutput) Elem() BasicAuthenticationOutput {
	return o.ApplyT(func(v *BasicAuthentication) BasicAuthentication {
		if v != nil {
			return *v
		}
		var ret BasicAuthentication
		return ret
	}).(BasicAuthenticationOutput)
}

// The password to use when authenticating with the HTTP server.
func (o BasicAuthenticationPtrOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BasicAuthentication) *string {
		if v == nil {
			return nil
		}
		return v.Password
	}).(pulumi.StringPtrOutput)
}

// The username to use when authenticating with the HTTP server.
func (o BasicAuthenticationPtrOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BasicAuthentication) *string {
		if v == nil {
			return nil
		}
		return v.Username
	}).(pulumi.StringPtrOutput)
}

// The authentication parameters to provide to the specified resource or URL that requires a username and password. Currently, only Basic HTTP authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime checks.
type BasicAuthenticationResponse struct {
	// The password to use when authenticating with the HTTP server.
	Password string `pulumi:"password"`
	// The username to use when authenticating with the HTTP server.
	Username string `pulumi:"username"`
}

// The authentication parameters to provide to the specified resource or URL that requires a username and password. Currently, only Basic HTTP authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime checks.
type BasicAuthenticationResponseOutput struct{ *pulumi.OutputState }

func (BasicAuthenticationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicAuthenticationResponse)(nil)).Elem()
}

func (o BasicAuthenticationResponseOutput) ToBasicAuthenticationResponseOutput() BasicAuthenticationResponseOutput {
	return o
}

func (o BasicAuthenticationResponseOutput) ToBasicAuthenticationResponseOutputWithContext(ctx context.Context) BasicAuthenticationResponseOutput {
	return o
}

// The password to use when authenticating with the HTTP server.
func (o BasicAuthenticationResponseOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v BasicAuthenticationResponse) string { return v.Password }).(pulumi.StringOutput)
}

// The username to use when authenticating with the HTTP server.
func (o BasicAuthenticationResponseOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v BasicAuthenticationResponse) string { return v.Username }).(pulumi.StringOutput)
}

// A well-known service type, defined by its service type and service labels. Documentation and examples here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
type BasicService struct {
	// Labels that specify the resource that emits the monitoring data which is used for SLO reporting of this Service. Documentation and valid values for given service types here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
	ServiceLabels map[string]string `pulumi:"serviceLabels"`
	// The type of service that this basic service defines, e.g. APP_ENGINE service type. Documentation and valid values here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
	ServiceType *string `pulumi:"serviceType"`
}

// BasicServiceInput is an input type that accepts BasicServiceArgs and BasicServiceOutput values.
// You can construct a concrete instance of `BasicServiceInput` via:
//
//	BasicServiceArgs{...}
type BasicServiceInput interface {
	pulumi.Input

	ToBasicServiceOutput() BasicServiceOutput
	ToBasicServiceOutputWithContext(context.Context) BasicServiceOutput
}

// A well-known service type, defined by its service type and service labels. Documentation and examples here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
type BasicServiceArgs struct {
	// Labels that specify the resource that emits the monitoring data which is used for SLO reporting of this Service. Documentation and valid values for given service types here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
	ServiceLabels pulumi.StringMapInput `pulumi:"serviceLabels"`
	// The type of service that this basic service defines, e.g. APP_ENGINE service type. Documentation and valid values here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
	ServiceType pulumi.StringPtrInput `pulumi:"serviceType"`
}

func (BasicServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicService)(nil)).Elem()
}

func (i BasicServiceArgs) ToBasicServiceOutput() BasicServiceOutput {
	return i.ToBasicServiceOutputWithContext(context.Background())
}

func (i BasicServiceArgs) ToBasicServiceOutputWithContext(ctx context.Context) BasicServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicServiceOutput)
}

func (i BasicServiceArgs) ToBasicServicePtrOutput() BasicServicePtrOutput {
	return i.ToBasicServicePtrOutputWithContext(context.Background())
}

func (i BasicServiceArgs) ToBasicServicePtrOutputWithContext(ctx context.Context) BasicServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicServiceOutput).ToBasicServicePtrOutputWithContext(ctx)
}

// BasicServicePtrInput is an input type that accepts BasicServiceArgs, BasicServicePtr and BasicServicePtrOutput values.
// You can construct a concrete instance of `BasicServicePtrInput` via:
//
//	        BasicServiceArgs{...}
//
//	or:
//
//	        nil
type BasicServicePtrInput interface {
	pulumi.Input

	ToBasicServicePtrOutput() BasicServicePtrOutput
	ToBasicServicePtrOutputWithContext(context.Context) BasicServicePtrOutput
}

type basicServicePtrType BasicServiceArgs

func BasicServicePtr(v *BasicServiceArgs) BasicServicePtrInput {
	return (*basicServicePtrType)(v)
}

func (*basicServicePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicService)(nil)).Elem()
}

func (i *basicServicePtrType) ToBasicServicePtrOutput() BasicServicePtrOutput {
	return i.ToBasicServicePtrOutputWithContext(context.Background())
}

func (i *basicServicePtrType) ToBasicServicePtrOutputWithContext(ctx context.Context) BasicServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicServicePtrOutput)
}

// A well-known service type, defined by its service type and service labels. Documentation and examples here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
type BasicServiceOutput struct{ *pulumi.OutputState }

func (BasicServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicService)(nil)).Elem()
}

func (o BasicServiceOutput) ToBasicServiceOutput() BasicServiceOutput {
	return o
}

func (o BasicServiceOutput) ToBasicServiceOutputWithContext(ctx context.Context) BasicServiceOutput {
	return o
}

func (o BasicServiceOutput) ToBasicServicePtrOutput() BasicServicePtrOutput {
	return o.ToBasicServicePtrOutputWithContext(context.Background())
}

func (o BasicServiceOutput) ToBasicServicePtrOutputWithContext(ctx context.Context) BasicServicePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BasicService) *BasicService {
		return &v
	}).(BasicServicePtrOutput)
}

// Labels that specify the resource that emits the monitoring data which is used for SLO reporting of this Service. Documentation and valid values for given service types here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
func (o BasicServiceOutput) ServiceLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v BasicService) map[string]string { return v.ServiceLabels }).(pulumi.StringMapOutput)
}

// The type of service that this basic service defines, e.g. APP_ENGINE service type. Documentation and valid values here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
func (o BasicServiceOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BasicService) *string { return v.ServiceType }).(pulumi.StringPtrOutput)
}

type BasicServicePtrOutput struct{ *pulumi.OutputState }

func (BasicServicePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicService)(nil)).Elem()
}

func (o BasicServicePtrOutput) ToBasicServicePtrOutput() BasicServicePtrOutput {
	return o
}

func (o BasicServicePtrOutput) ToBasicServicePtrOutputWithContext(ctx context.Context) BasicServicePtrOutput {
	return o
}

func (o BasicServicePtrOutput) Elem() BasicServiceOutput {
	return o.ApplyT(func(v *BasicService) BasicService {
		if v != nil {
			return *v
		}
		var ret BasicService
		return ret
	}).(BasicServiceOutput)
}

// Labels that specify the resource that emits the monitoring data which is used for SLO reporting of this Service. Documentation and valid values for given service types here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
func (o BasicServicePtrOutput) ServiceLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *BasicService) map[string]string {
		if v == nil {
			return nil
		}
		return v.ServiceLabels
	}).(pulumi.StringMapOutput)
}

// The type of service that this basic service defines, e.g. APP_ENGINE service type. Documentation and valid values here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
func (o BasicServicePtrOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BasicService) *string {
		if v == nil {
			return nil
		}
		return v.ServiceType
	}).(pulumi.StringPtrOutput)
}

// A well-known service type, defined by its service type and service labels. Documentation and examples here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
type BasicServiceResponse struct {
	// Labels that specify the resource that emits the monitoring data which is used for SLO reporting of this Service. Documentation and valid values for given service types here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
	ServiceLabels map[string]string `pulumi:"serviceLabels"`
	// The type of service that this basic service defines, e.g. APP_ENGINE service type. Documentation and valid values here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
	ServiceType string `pulumi:"serviceType"`
}

// A well-known service type, defined by its service type and service labels. Documentation and examples here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
type BasicServiceResponseOutput struct{ *pulumi.OutputState }

func (BasicServiceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicServiceResponse)(nil)).Elem()
}

func (o BasicServiceResponseOutput) ToBasicServiceResponseOutput() BasicServiceResponseOutput {
	return o
}

func (o BasicServiceResponseOutput) ToBasicServiceResponseOutputWithContext(ctx context.Context) BasicServiceResponseOutput {
	return o
}

// Labels that specify the resource that emits the monitoring data which is used for SLO reporting of this Service. Documentation and valid values for given service types here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
func (o BasicServiceResponseOutput) ServiceLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v BasicServiceResponse) map[string]string { return v.ServiceLabels }).(pulumi.StringMapOutput)
}

// The type of service that this basic service defines, e.g. APP_ENGINE service type. Documentation and valid values here (https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
func (o BasicServiceResponseOutput) ServiceType() pulumi.StringOutput {
	return o.ApplyT(func(v BasicServiceResponse) string { return v.ServiceType }).(pulumi.StringOutput)
}

// An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.
type BasicSli struct {
	// Good service is defined to be the count of requests made to this service that return successfully.
	Availability *AvailabilityCriteria `pulumi:"availability"`
	// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
	Latency *LatencyCriteria `pulumi:"latency"`
	// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
	Location []string `pulumi:"location"`
	// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
	Method []string `pulumi:"method"`
	// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
	Version []string `pulumi:"version"`
}

// BasicSliInput is an input type that accepts BasicSliArgs and BasicSliOutput values.
// You can construct a concrete instance of `BasicSliInput` via:
//
//	BasicSliArgs{...}
type BasicSliInput interface {
	pulumi.Input

	ToBasicSliOutput() BasicSliOutput
	ToBasicSliOutputWithContext(context.Context) BasicSliOutput
}

// An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.
type BasicSliArgs struct {
	// Good service is defined to be the count of requests made to this service that return successfully.
	Availability AvailabilityCriteriaPtrInput `pulumi:"availability"`
	// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
	Latency LatencyCriteriaPtrInput `pulumi:"latency"`
	// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
	Location pulumi.StringArrayInput `pulumi:"location"`
	// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
	Method pulumi.StringArrayInput `pulumi:"method"`
	// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
	Version pulumi.StringArrayInput `pulumi:"version"`
}

func (BasicSliArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicSli)(nil)).Elem()
}

func (i BasicSliArgs) ToBasicSliOutput() BasicSliOutput {
	return i.ToBasicSliOutputWithContext(context.Background())
}

func (i BasicSliArgs) ToBasicSliOutputWithContext(ctx context.Context) BasicSliOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicSliOutput)
}

func (i BasicSliArgs) ToBasicSliPtrOutput() BasicSliPtrOutput {
	return i.ToBasicSliPtrOutputWithContext(context.Background())
}

func (i BasicSliArgs) ToBasicSliPtrOutputWithContext(ctx context.Context) BasicSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicSliOutput).ToBasicSliPtrOutputWithContext(ctx)
}

// BasicSliPtrInput is an input type that accepts BasicSliArgs, BasicSliPtr and BasicSliPtrOutput values.
// You can construct a concrete instance of `BasicSliPtrInput` via:
//
//	        BasicSliArgs{...}
//
//	or:
//
//	        nil
type BasicSliPtrInput interface {
	pulumi.Input

	ToBasicSliPtrOutput() BasicSliPtrOutput
	ToBasicSliPtrOutputWithContext(context.Context) BasicSliPtrOutput
}

type basicSliPtrType BasicSliArgs

func BasicSliPtr(v *BasicSliArgs) BasicSliPtrInput {
	return (*basicSliPtrType)(v)
}

func (*basicSliPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicSli)(nil)).Elem()
}

func (i *basicSliPtrType) ToBasicSliPtrOutput() BasicSliPtrOutput {
	return i.ToBasicSliPtrOutputWithContext(context.Background())
}

func (i *basicSliPtrType) ToBasicSliPtrOutputWithContext(ctx context.Context) BasicSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicSliPtrOutput)
}

// An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.
type BasicSliOutput struct{ *pulumi.OutputState }

func (BasicSliOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicSli)(nil)).Elem()
}

func (o BasicSliOutput) ToBasicSliOutput() BasicSliOutput {
	return o
}

func (o BasicSliOutput) ToBasicSliOutputWithContext(ctx context.Context) BasicSliOutput {
	return o
}

func (o BasicSliOutput) ToBasicSliPtrOutput() BasicSliPtrOutput {
	return o.ToBasicSliPtrOutputWithContext(context.Background())
}

func (o BasicSliOutput) ToBasicSliPtrOutputWithContext(ctx context.Context) BasicSliPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BasicSli) *BasicSli {
		return &v
	}).(BasicSliPtrOutput)
}

// Good service is defined to be the count of requests made to this service that return successfully.
func (o BasicSliOutput) Availability() AvailabilityCriteriaPtrOutput {
	return o.ApplyT(func(v BasicSli) *AvailabilityCriteria { return v.Availability }).(AvailabilityCriteriaPtrOutput)
}

// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
func (o BasicSliOutput) Latency() LatencyCriteriaPtrOutput {
	return o.ApplyT(func(v BasicSli) *LatencyCriteria { return v.Latency }).(LatencyCriteriaPtrOutput)
}

// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
func (o BasicSliOutput) Location() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSli) []string { return v.Location }).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
func (o BasicSliOutput) Method() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSli) []string { return v.Method }).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
func (o BasicSliOutput) Version() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSli) []string { return v.Version }).(pulumi.StringArrayOutput)
}

type BasicSliPtrOutput struct{ *pulumi.OutputState }

func (BasicSliPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicSli)(nil)).Elem()
}

func (o BasicSliPtrOutput) ToBasicSliPtrOutput() BasicSliPtrOutput {
	return o
}

func (o BasicSliPtrOutput) ToBasicSliPtrOutputWithContext(ctx context.Context) BasicSliPtrOutput {
	return o
}

func (o BasicSliPtrOutput) Elem() BasicSliOutput {
	return o.ApplyT(func(v *BasicSli) BasicSli {
		if v != nil {
			return *v
		}
		var ret BasicSli
		return ret
	}).(BasicSliOutput)
}

// Good service is defined to be the count of requests made to this service that return successfully.
func (o BasicSliPtrOutput) Availability() AvailabilityCriteriaPtrOutput {
	return o.ApplyT(func(v *BasicSli) *AvailabilityCriteria {
		if v == nil {
			return nil
		}
		return v.Availability
	}).(AvailabilityCriteriaPtrOutput)
}

// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
func (o BasicSliPtrOutput) Latency() LatencyCriteriaPtrOutput {
	return o.ApplyT(func(v *BasicSli) *LatencyCriteria {
		if v == nil {
			return nil
		}
		return v.Latency
	}).(LatencyCriteriaPtrOutput)
}

// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
func (o BasicSliPtrOutput) Location() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *BasicSli) []string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
func (o BasicSliPtrOutput) Method() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *BasicSli) []string {
		if v == nil {
			return nil
		}
		return v.Method
	}).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
func (o BasicSliPtrOutput) Version() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *BasicSli) []string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringArrayOutput)
}

// An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.
type BasicSliResponse struct {
	// Good service is defined to be the count of requests made to this service that return successfully.
	Availability AvailabilityCriteriaResponse `pulumi:"availability"`
	// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
	Latency LatencyCriteriaResponse `pulumi:"latency"`
	// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
	Location []string `pulumi:"location"`
	// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
	Method []string `pulumi:"method"`
	// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
	Version []string `pulumi:"version"`
}

// An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.
type BasicSliResponseOutput struct{ *pulumi.OutputState }

func (BasicSliResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicSliResponse)(nil)).Elem()
}

func (o BasicSliResponseOutput) ToBasicSliResponseOutput() BasicSliResponseOutput {
	return o
}

func (o BasicSliResponseOutput) ToBasicSliResponseOutputWithContext(ctx context.Context) BasicSliResponseOutput {
	return o
}

// Good service is defined to be the count of requests made to this service that return successfully.
func (o BasicSliResponseOutput) Availability() AvailabilityCriteriaResponseOutput {
	return o.ApplyT(func(v BasicSliResponse) AvailabilityCriteriaResponse { return v.Availability }).(AvailabilityCriteriaResponseOutput)
}

// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
func (o BasicSliResponseOutput) Latency() LatencyCriteriaResponseOutput {
	return o.ApplyT(func(v BasicSliResponse) LatencyCriteriaResponse { return v.Latency }).(LatencyCriteriaResponseOutput)
}

// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
func (o BasicSliResponseOutput) Location() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSliResponse) []string { return v.Location }).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
func (o BasicSliResponseOutput) Method() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSliResponse) []string { return v.Method }).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
func (o BasicSliResponseOutput) Version() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSliResponse) []string { return v.Version }).(pulumi.StringArrayOutput)
}

// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
type CloudEndpoints struct {
	// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource (https://cloud.google.com/monitoring/api/resources#tag_api).
	Service *string `pulumi:"service"`
}

// CloudEndpointsInput is an input type that accepts CloudEndpointsArgs and CloudEndpointsOutput values.
// You can construct a concrete instance of `CloudEndpointsInput` via:
//
//	CloudEndpointsArgs{...}
type CloudEndpointsInput interface {
	pulumi.Input

	ToCloudEndpointsOutput() CloudEndpointsOutput
	ToCloudEndpointsOutputWithContext(context.Context) CloudEndpointsOutput
}

// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
type CloudEndpointsArgs struct {
	// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource (https://cloud.google.com/monitoring/api/resources#tag_api).
	Service pulumi.StringPtrInput `pulumi:"service"`
}

func (CloudEndpointsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudEndpoints)(nil)).Elem()
}

func (i CloudEndpointsArgs) ToCloudEndpointsOutput() CloudEndpointsOutput {
	return i.ToCloudEndpointsOutputWithContext(context.Background())
}

func (i CloudEndpointsArgs) ToCloudEndpointsOutputWithContext(ctx context.Context) CloudEndpointsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudEndpointsOutput)
}

func (i CloudEndpointsArgs) ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput {
	return i.ToCloudEndpointsPtrOutputWithContext(context.Background())
}

func (i CloudEndpointsArgs) ToCloudEndpointsPtrOutputWithContext(ctx context.Context) CloudEndpointsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudEndpointsOutput).ToCloudEndpointsPtrOutputWithContext(ctx)
}

// CloudEndpointsPtrInput is an input type that accepts CloudEndpointsArgs, CloudEndpointsPtr and CloudEndpointsPtrOutput values.
// You can construct a concrete instance of `CloudEndpointsPtrInput` via:
//
//	        CloudEndpointsArgs{...}
//
//	or:
//
//	        nil
type CloudEndpointsPtrInput interface {
	pulumi.Input

	ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput
	ToCloudEndpointsPtrOutputWithContext(context.Context) CloudEndpointsPtrOutput
}

type cloudEndpointsPtrType CloudEndpointsArgs

func CloudEndpointsPtr(v *CloudEndpointsArgs) CloudEndpointsPtrInput {
	return (*cloudEndpointsPtrType)(v)
}

func (*cloudEndpointsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudEndpoints)(nil)).Elem()
}

func (i *cloudEndpointsPtrType) ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput {
	return i.ToCloudEndpointsPtrOutputWithContext(context.Background())
}

func (i *cloudEndpointsPtrType) ToCloudEndpointsPtrOutputWithContext(ctx context.Context) CloudEndpointsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudEndpointsPtrOutput)
}

// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
type CloudEndpointsOutput struct{ *pulumi.OutputState }

func (CloudEndpointsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudEndpoints)(nil)).Elem()
}

func (o CloudEndpointsOutput) ToCloudEndpointsOutput() CloudEndpointsOutput {
	return o
}

func (o CloudEndpointsOutput) ToCloudEndpointsOutputWithContext(ctx context.Context) CloudEndpointsOutput {
	return o
}

func (o CloudEndpointsOutput) ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput {
	return o.ToCloudEndpointsPtrOutputWithContext(context.Background())
}

func (o CloudEndpointsOutput) ToCloudEndpointsPtrOutputWithContext(ctx context.Context) CloudEndpointsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CloudEndpoints) *CloudEndpoints {
		return &v
	}).(CloudEndpointsPtrOutput)
}

// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource (https://cloud.google.com/monitoring/api/resources#tag_api).
func (o CloudEndpointsOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CloudEndpoints) *string { return v.Service }).(pulumi.StringPtrOutput)
}

type CloudEndpointsPtrOutput struct{ *pulumi.OutputState }

func (CloudEndpointsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudEndpoints)(nil)).Elem()
}

func (o CloudEndpointsPtrOutput) ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput {
	return o
}

func (o CloudEndpointsPtrOutput) ToCloudEndpointsPtrOutputWithContext(ctx context.Context) CloudEndpointsPtrOutput {
	return o
}

func (o CloudEndpointsPtrOutput) Elem() CloudEndpointsOutput {
	return o.ApplyT(func(v *CloudEndpoints) CloudEndpoints {
		if v != nil {
			return *v
		}
		var ret CloudEndpoints
		return ret
	}).(CloudEndpointsOutput)
}

// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource (https://cloud.google.com/monitoring/api/resources#tag_api).
func (o CloudEndpointsPtrOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CloudEndpoints) *string {
		if v == nil {
			return nil
		}
		return v.Service
	}).(pulumi.StringPtrOutput)
}

// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
type CloudEndpointsResponse struct {
	// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource (https://cloud.google.com/monitoring/api/resources#tag_api).
	Service string `pulumi:"service"`
}

// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
type CloudEndpointsResponseOutput struct{ *pulumi.OutputState }

func (CloudEndpointsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudEndpointsResponse)(nil)).Elem()
}

func (o CloudEndpointsResponseOutput) ToCloudEndpointsResponseOutput() CloudEndpointsResponseOutput {
	return o
}

func (o CloudEndpointsResponseOutput) ToCloudEndpointsResponseOutputWithContext(ctx context.Context) CloudEndpointsResponseOutput {
	return o
}

// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource (https://cloud.google.com/monitoring/api/resources#tag_api).
func (o CloudEndpointsResponseOutput) Service() pulumi.StringOutput {
	return o.ApplyT(func(v CloudEndpointsResponse) string { return v.Service }).(pulumi.StringOutput)
}

// A Synthetic Monitor deployed to a Cloud Functions V2 instance.
type CloudFunctionV2Target struct {
	// Fully qualified GCFv2 resource name i.e. projects/{project}/locations/{location}/functions/{function} Required.
	Name string `pulumi:"name"`
}

// CloudFunctionV2TargetInput is an input type that accepts CloudFunctionV2TargetArgs and CloudFunctionV2TargetOutput values.
// You can construct a concrete instance of `CloudFunctionV2TargetInput` via:
//
//	CloudFunctionV2TargetArgs{...}
type CloudFunctionV2TargetInput interface {
	pulumi.Input

	ToCloudFunctionV2TargetOutput() CloudFunctionV2TargetOutput
	ToCloudFunctionV2TargetOutputWithContext(context.Context) CloudFunctionV2TargetOutput
}

// A Synthetic Monitor deployed to a Cloud Functions V2 instance.
type CloudFunctionV2TargetArgs struct {
	// Fully qualified GCFv2 resource name i.e. projects/{project}/locations/{location}/functions/{function} Required.
	Name pulumi.StringInput `pulumi:"name"`
}

func (CloudFunctionV2TargetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudFunctionV2Target)(nil)).Elem()
}

func (i CloudFunctionV2TargetArgs) ToCloudFunctionV2TargetOutput() CloudFunctionV2TargetOutput {
	return i.ToCloudFunctionV2TargetOutputWithContext(context.Background())
}

func (i CloudFunctionV2TargetArgs) ToCloudFunctionV2TargetOutputWithContext(ctx context.Context) CloudFunctionV2TargetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudFunctionV2TargetOutput)
}

func (i CloudFunctionV2TargetArgs) ToCloudFunctionV2TargetPtrOutput() CloudFunctionV2TargetPtrOutput {
	return i.ToCloudFunctionV2TargetPtrOutputWithContext(context.Background())
}

func (i CloudFunctionV2TargetArgs) ToCloudFunctionV2TargetPtrOutputWithContext(ctx context.Context) CloudFunctionV2TargetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudFunctionV2TargetOutput).ToCloudFunctionV2TargetPtrOutputWithContext(ctx)
}

// CloudFunctionV2TargetPtrInput is an input type that accepts CloudFunctionV2TargetArgs, CloudFunctionV2TargetPtr and CloudFunctionV2TargetPtrOutput values.
// You can construct a concrete instance of `CloudFunctionV2TargetPtrInput` via:
//
//	        CloudFunctionV2TargetArgs{...}
//
//	or:
//
//	        nil
type CloudFunctionV2TargetPtrInput interface {
	pulumi.Input

	ToCloudFunctionV2TargetPtrOutput() CloudFunctionV2TargetPtrOutput
	ToCloudFunctionV2TargetPtrOutputWithContext(context.Context) CloudFunctionV2TargetPtrOutput
}

type cloudFunctionV2TargetPtrType CloudFunctionV2TargetArgs

func CloudFunctionV2TargetPtr(v *CloudFunctionV2TargetArgs) CloudFunctionV2TargetPtrInput {
	return (*cloudFunctionV2TargetPtrType)(v)
}

func (*cloudFunctionV2TargetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudFunctionV2Target)(nil)).Elem()
}

func (i *cloudFunctionV2TargetPtrType) ToCloudFunctionV2TargetPtrOutput() CloudFunctionV2TargetPtrOutput {
	return i.ToCloudFunctionV2TargetPtrOutputWithContext(context.Background())
}

func (i *cloudFunctionV2TargetPtrType) ToCloudFunctionV2TargetPtrOutputWithContext(ctx context.Context) CloudFunctionV2TargetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudFunctionV2TargetPtrOutput)
}

// A Synthetic Monitor deployed to a Cloud Functions V2 instance.
type CloudFunctionV2TargetOutput struct{ *pulumi.OutputState }

func (CloudFunctionV2TargetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudFunctionV2Target)(nil)).Elem()
}

func (o CloudFunctionV2TargetOutput) ToCloudFunctionV2TargetOutput() CloudFunctionV2TargetOutput {
	return o
}

func (o CloudFunctionV2TargetOutput) ToCloudFunctionV2TargetOutputWithContext(ctx context.Context) CloudFunctionV2TargetOutput {
	return o
}

func (o CloudFunctionV2TargetOutput) ToCloudFunctionV2TargetPtrOutput() CloudFunctionV2TargetPtrOutput {
	return o.ToCloudFunctionV2TargetPtrOutputWithContext(context.Background())
}

func (o CloudFunctionV2TargetOutput) ToCloudFunctionV2TargetPtrOutputWithContext(ctx context.Context) CloudFunctionV2TargetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CloudFunctionV2Target) *CloudFunctionV2Target {
		return &v
	}).(CloudFunctionV2TargetPtrOutput)
}

// Fully qualified GCFv2 resource name i.e. projects/{project}/locations/{location}/functions/{function} Required.
func (o CloudFunctionV2TargetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v CloudFunctionV2Target) string { return v.Name }).(pulumi.StringOutput)
}

type CloudFunctionV2TargetPtrOutput struct{ *pulumi.OutputState }

func (CloudFunctionV2TargetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudFunctionV2Target)(nil)).Elem()
}

func (o CloudFunctionV2TargetPtrOutput) ToCloudFunctionV2TargetPtrOutput() CloudFunctionV2TargetPtrOutput {
	return o
}

func (o CloudFunctionV2TargetPtrOutput) ToCloudFunctionV2TargetPtrOutputWithContext(ctx context.Context) CloudFunctionV2TargetPtrOutput {
	return o
}

func (o CloudFunctionV2TargetPtrOutput) Elem() CloudFunctionV2TargetOutput {
	return o.ApplyT(func(v *CloudFunctionV2Target) CloudFunctionV2Target {
		if v != nil {
			return *v
		}
		var ret CloudFunctionV2Target
		return ret
	}).(CloudFunctionV2TargetOutput)
}

// Fully qualified GCFv2 resource name i.e. projects/{project}/locations/{location}/functions/{function} Required.
func (o CloudFunctionV2TargetPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CloudFunctionV2Target) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// A Synthetic Monitor deployed to a Cloud Functions V2 instance.
type CloudFunctionV2TargetResponse struct {
	// The cloud_run_revision Monitored Resource associated with the GCFv2. The Synthetic Monitor execution results (metrics, logs, and spans) are reported against this Monitored Resource. This field is output only.
	CloudRunRevision MonitoredResourceResponse `pulumi:"cloudRunRevision"`
	// Fully qualified GCFv2 resource name i.e. projects/{project}/locations/{location}/functions/{function} Required.
	Name string `pulumi:"name"`
}

// A Synthetic Monitor deployed to a Cloud Functions V2 instance.
type CloudFunctionV2TargetResponseOutput struct{ *pulumi.OutputState }

func (CloudFunctionV2TargetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudFunctionV2TargetResponse)(nil)).Elem()
}

func (o CloudFunctionV2TargetResponseOutput) ToCloudFunctionV2TargetResponseOutput() CloudFunctionV2TargetResponseOutput {
	return o
}

func (o CloudFunctionV2TargetResponseOutput) ToCloudFunctionV2TargetResponseOutputWithContext(ctx context.Context) CloudFunctionV2TargetResponseOutput {
	return o
}

// The cloud_run_revision Monitored Resource associated with the GCFv2. The Synthetic Monitor execution results (metrics, logs, and spans) are reported against this Monitored Resource. This field is output only.
func (o CloudFunctionV2TargetResponseOutput) CloudRunRevision() MonitoredResourceResponseOutput {
	return o.ApplyT(func(v CloudFunctionV2TargetResponse) MonitoredResourceResponse { return v.CloudRunRevision }).(MonitoredResourceResponseOutput)
}

// Fully qualified GCFv2 resource name i.e. projects/{project}/locations/{location}/functions/{function} Required.
func (o CloudFunctionV2TargetResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v CloudFunctionV2TargetResponse) string { return v.Name }).(pulumi.StringOutput)
}

// Cloud Run service. Learn more at https://cloud.google.com/run.
type CloudRun struct {
	// The location the service is run. Corresponds to the location resource label in the cloud_run_revision monitored resource (https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
	Location *string `pulumi:"location"`
	// The name of the Cloud Run service. Corresponds to the service_name resource label in the cloud_run_revision monitored resource (https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
	ServiceName *string `pulumi:"serviceName"`
}

// CloudRunInput is an input type that accepts CloudRunArgs and CloudRunOutput values.
// You can construct a concrete instance of `CloudRunInput` via:
//
//	CloudRunArgs{...}
type CloudRunInput interface {
	pulumi.Input

	ToCloudRunOutput() CloudRunOutput
	ToCloudRunOutputWithContext(context.Context) CloudRunOutput
}

// Cloud Run service. Learn more at https://cloud.google.com/run.
type CloudRunArgs struct {
	// The location the service is run. Corresponds to the location resource label in the cloud_run_revision monitored resource (https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
	Location pulumi.StringPtrInput `pulumi:"location"`
	// The name of the Cloud Run service. Corresponds to the service_name resource label in the cloud_run_revision monitored resource (https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (CloudRunArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudRun)(nil)).Elem()
}

func (i CloudRunArgs) ToCloudRunOutput() CloudRunOutput {
	return i.ToCloudRunOutputWithContext(context.Background())
}

func (i CloudRunArgs) ToCloudRunOutputWithContext(ctx context.Context) CloudRunOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudRunOutput)
}

func (i CloudRunArgs) ToCloudRunPtrOutput() CloudRunPtrOutput {
	return i.ToCloudRunPtrOutputWithContext(context.Background())
}

func (i CloudRunArgs) ToCloudRunPtrOutputWithContext(ctx context.Context) CloudRunPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudRunOutput).ToCloudRunPtrOutputWithContext(ctx)
}

// CloudRunPtrInput is an input type that accepts CloudRunArgs, CloudRunPtr and CloudRunPtrOutput values.
// You can construct a concrete instance of `CloudRunPtrInput` via:
//
//	        CloudRunArgs{...}
//
//	or:
//
//	        nil
type CloudRunPtrInput interface {
	pulumi.Input

	ToCloudRunPtrOutput() CloudRunPtrOutput
	ToCloudRunPtrOutputWithContext(context.Context) CloudRunPtrOutput
}

type cloudRunPtrType CloudRunArgs

func CloudRunPtr(v *CloudRunArgs) CloudRunPtrInput {
	return (*cloudRunPtrType)(v)
}

func (*cloudRunPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudRun)(nil)).Elem()
}

func (i *cloudRunPtrType) ToCloudRunPtrOutput() CloudRunPtrOutput {
	return i.ToCloudRunPtrOutputWithContext(context.Background())
}

func (i *cloudRunPtrType) ToCloudRunPtrOutputWithContext(ctx context.Context) CloudRunPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudRunPtrOutput)
}

// Cloud Run service. Learn more at https://cloud.google.com/run.
type CloudRunOutput struct{ *pulumi.OutputState }

func (CloudRunOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudRun)(nil)).Elem()
}

func (o CloudRunOutput) ToCloudRunOutput() CloudRunOutput {
	return o
}

func (o CloudRunOutput) ToCloudRunOutputWithContext(ctx context.Context) CloudRunOutput {
	return o
}

func (o CloudRunOutput) ToCloudRunPtrOutput() CloudRunPtrOutput {
	return o.ToCloudRunPtrOutputWithContext(context.Background())
}

func (o CloudRunOutput) ToCloudRunPtrOutputWithContext(ctx context.Context) CloudRunPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CloudRun) *CloudRun {
		return &v
	}).(CloudRunPtrOutput)
}

// The location the service is run. Corresponds to the location resource label in the cloud_run_revision monitored resource (https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
func (o CloudRunOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CloudRun) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// The name of the Cloud Run service. Corresponds to the service_name resource label in the cloud_run_revision monitored resource (https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
func (o CloudRunOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CloudRun) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type CloudRunPtrOutput struct{ *pulumi.OutputState }

func (CloudRunPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudRun)(nil)).Elem()
}

func (o CloudRunPtrOutput) ToCloudRunPtrOutput() CloudRunPtrOutput {
	return o
}

func (o CloudRunPtrOutput) ToCloudRunPtrOutputWithContext(ctx context.Context) CloudRunPtrOutput {
	return o
}

func (o CloudRunPtrOutput) Elem() CloudRunOutput {
	return o.ApplyT(func(v *CloudRun) CloudRun {
		if v != nil {
			return *v
		}
		var ret CloudRun
		return ret
	}).(CloudRunOutput)
}

// The location the service is run. Corresponds to the location resource label in the cloud_run_revision monitored resource (https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
func (o CloudRunPtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CloudRun) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// The name of the Cloud Run service. Corresponds to the service_name resource label in the cloud_run_revision monitored resource (https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
func (o CloudRunPtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CloudRun) *string {
		if v == nil {
			return nil
		}
		return v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// Cloud Run service. Learn more at https://cloud.google.com/run.
type CloudRunResponse struct {
	// The location the service is run. Corresponds to the location resource label in the cloud_run_revision monitored resource (https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
	Location string `pulumi:"location"`
	// The name of the Cloud Run service. Corresponds to the service_name resource label in the cloud_run_revision monitored resource (https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
	ServiceName string `pulumi:"serviceName"`
}

// Cloud Run service. Learn more at https://cloud.google.com/run.
type CloudRunResponseOutput struct{ *pulumi.OutputState }

func (CloudRunResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudRunResponse)(nil)).Elem()
}

func (o CloudRunResponseOutput) ToCloudRunResponseOutput() CloudRunResponseOutput {
	return o
}

func (o CloudRunResponseOutput) ToCloudRunResponseOutputWithContext(ctx context.Context) CloudRunResponseOutput {
	return o
}

// The location the service is run. Corresponds to the location resource label in the cloud_run_revision monitored resource (https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
func (o CloudRunResponseOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v CloudRunResponse) string { return v.Location }).(pulumi.StringOutput)
}

// The name of the Cloud Run service. Corresponds to the service_name resource label in the cloud_run_revision monitored resource (https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
func (o CloudRunResponseOutput) ServiceName() pulumi.StringOutput {
	return o.ApplyT(func(v CloudRunResponse) string { return v.ServiceName }).(pulumi.StringOutput)
}

// Istio service scoped to a single Kubernetes cluster. Learn more at https://istio.io. Clusters running OSS Istio will have their services ingested as this type.
type ClusterIstio struct {
	// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
	ClusterName *string `pulumi:"clusterName"`
	// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
	Location *string `pulumi:"location"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName *string `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace *string `pulumi:"serviceNamespace"`
}

// ClusterIstioInput is an input type that accepts ClusterIstioArgs and ClusterIstioOutput values.
// You can construct a concrete instance of `ClusterIstioInput` via:
//
//	ClusterIstioArgs{...}
type ClusterIstioInput interface {
	pulumi.Input

	ToClusterIstioOutput() ClusterIstioOutput
	ToClusterIstioOutputWithContext(context.Context) ClusterIstioOutput
}

// Istio service scoped to a single Kubernetes cluster. Learn more at https://istio.io. Clusters running OSS Istio will have their services ingested as this type.
type ClusterIstioArgs struct {
	// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
	ClusterName pulumi.StringPtrInput `pulumi:"clusterName"`
	// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace pulumi.StringPtrInput `pulumi:"serviceNamespace"`
}

func (ClusterIstioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterIstio)(nil)).Elem()
}

func (i ClusterIstioArgs) ToClusterIstioOutput() ClusterIstioOutput {
	return i.ToClusterIstioOutputWithContext(context.Background())
}

func (i ClusterIstioArgs) ToClusterIstioOutputWithContext(ctx context.Context) ClusterIstioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterIstioOutput)
}

func (i ClusterIstioArgs) ToClusterIstioPtrOutput() ClusterIstioPtrOutput {
	return i.ToClusterIstioPtrOutputWithContext(context.Background())
}

func (i ClusterIstioArgs) ToClusterIstioPtrOutputWithContext(ctx context.Context) ClusterIstioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterIstioOutput).ToClusterIstioPtrOutputWithContext(ctx)
}

// ClusterIstioPtrInput is an input type that accepts ClusterIstioArgs, ClusterIstioPtr and ClusterIstioPtrOutput values.
// You can construct a concrete instance of `ClusterIstioPtrInput` via:
//
//	        ClusterIstioArgs{...}
//
//	or:
//
//	        nil
type ClusterIstioPtrInput interface {
	pulumi.Input

	ToClusterIstioPtrOutput() ClusterIstioPtrOutput
	ToClusterIstioPtrOutputWithContext(context.Context) ClusterIstioPtrOutput
}

type clusterIstioPtrType ClusterIstioArgs

func ClusterIstioPtr(v *ClusterIstioArgs) ClusterIstioPtrInput {
	return (*clusterIstioPtrType)(v)
}

func (*clusterIstioPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterIstio)(nil)).Elem()
}

func (i *clusterIstioPtrType) ToClusterIstioPtrOutput() ClusterIstioPtrOutput {
	return i.ToClusterIstioPtrOutputWithContext(context.Background())
}

func (i *clusterIstioPtrType) ToClusterIstioPtrOutputWithContext(ctx context.Context) ClusterIstioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterIstioPtrOutput)
}

// Istio service scoped to a single Kubernetes cluster. Learn more at https://istio.io. Clusters running OSS Istio will have their services ingested as this type.
type ClusterIstioOutput struct{ *pulumi.OutputState }

func (ClusterIstioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterIstio)(nil)).Elem()
}

func (o ClusterIstioOutput) ToClusterIstioOutput() ClusterIstioOutput {
	return o
}

func (o ClusterIstioOutput) ToClusterIstioOutputWithContext(ctx context.Context) ClusterIstioOutput {
	return o
}

func (o ClusterIstioOutput) ToClusterIstioPtrOutput() ClusterIstioPtrOutput {
	return o.ToClusterIstioPtrOutputWithContext(context.Background())
}

func (o ClusterIstioOutput) ToClusterIstioPtrOutputWithContext(ctx context.Context) ClusterIstioPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ClusterIstio) *ClusterIstio {
		return &v
	}).(ClusterIstioPtrOutput)
}

// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
func (o ClusterIstioOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterIstio) *string { return v.ClusterName }).(pulumi.StringPtrOutput)
}

// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
func (o ClusterIstioOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterIstio) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o ClusterIstioOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterIstio) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o ClusterIstioOutput) ServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterIstio) *string { return v.ServiceNamespace }).(pulumi.StringPtrOutput)
}

type ClusterIstioPtrOutput struct{ *pulumi.OutputState }

func (ClusterIstioPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterIstio)(nil)).Elem()
}

func (o ClusterIstioPtrOutput) ToClusterIstioPtrOutput() ClusterIstioPtrOutput {
	return o
}

func (o ClusterIstioPtrOutput) ToClusterIstioPtrOutputWithContext(ctx context.Context) ClusterIstioPtrOutput {
	return o
}

func (o ClusterIstioPtrOutput) Elem() ClusterIstioOutput {
	return o.ApplyT(func(v *ClusterIstio) ClusterIstio {
		if v != nil {
			return *v
		}
		var ret ClusterIstio
		return ret
	}).(ClusterIstioOutput)
}

// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
func (o ClusterIstioPtrOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstio) *string {
		if v == nil {
			return nil
		}
		return v.ClusterName
	}).(pulumi.StringPtrOutput)
}

// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
func (o ClusterIstioPtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstio) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o ClusterIstioPtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstio) *string {
		if v == nil {
			return nil
		}
		return v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o ClusterIstioPtrOutput) ServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstio) *string {
		if v == nil {
			return nil
		}
		return v.ServiceNamespace
	}).(pulumi.StringPtrOutput)
}

// Istio service scoped to a single Kubernetes cluster. Learn more at https://istio.io. Clusters running OSS Istio will have their services ingested as this type.
type ClusterIstioResponse struct {
	// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
	ClusterName string `pulumi:"clusterName"`
	// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
	Location string `pulumi:"location"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName string `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace string `pulumi:"serviceNamespace"`
}

// Istio service scoped to a single Kubernetes cluster. Learn more at https://istio.io. Clusters running OSS Istio will have their services ingested as this type.
type ClusterIstioResponseOutput struct{ *pulumi.OutputState }

func (ClusterIstioResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterIstioResponse)(nil)).Elem()
}

func (o ClusterIstioResponseOutput) ToClusterIstioResponseOutput() ClusterIstioResponseOutput {
	return o
}

func (o ClusterIstioResponseOutput) ToClusterIstioResponseOutputWithContext(ctx context.Context) ClusterIstioResponseOutput {
	return o
}

// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
func (o ClusterIstioResponseOutput) ClusterName() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterIstioResponse) string { return v.ClusterName }).(pulumi.StringOutput)
}

// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
func (o ClusterIstioResponseOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterIstioResponse) string { return v.Location }).(pulumi.StringOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o ClusterIstioResponseOutput) ServiceName() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterIstioResponse) string { return v.ServiceName }).(pulumi.StringOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o ClusterIstioResponseOutput) ServiceNamespace() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterIstioResponse) string { return v.ServiceNamespace }).(pulumi.StringOutput)
}

// A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
type Condition struct {
	// A condition that checks that a time series continues to receive new data points.
	ConditionAbsent *MetricAbsence `pulumi:"conditionAbsent"`
	// A condition that checks for log messages matching given constraints. If set, no other conditions can be present.
	ConditionMatchedLog *LogMatch `pulumi:"conditionMatchedLog"`
	// A condition that uses the Monitoring Query Language to define alerts.
	ConditionMonitoringQueryLanguage *MonitoringQueryLanguageCondition `pulumi:"conditionMonitoringQueryLanguage"`
	// A condition that uses the Prometheus query language to define alerts.
	ConditionPrometheusQueryLanguage *PrometheusQueryLanguageCondition `pulumi:"conditionPrometheusQueryLanguage"`
	// A condition that compares a time series against a threshold.
	ConditionThreshold *MetricThreshold `pulumi:"conditionThreshold"`
	// A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
	DisplayName *string `pulumi:"displayName"`
	// Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Cloud Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Cloud Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
	Name *string `pulumi:"name"`
}

// ConditionInput is an input type that accepts ConditionArgs and ConditionOutput values.
// You can construct a concrete instance of `ConditionInput` via:
//
//	ConditionArgs{...}
type ConditionInput interface {
	pulumi.Input

	ToConditionOutput() ConditionOutput
	ToConditionOutputWithContext(context.Context) ConditionOutput
}

// A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
type ConditionArgs struct {
	// A condition that checks that a time series continues to receive new data points.
	ConditionAbsent MetricAbsencePtrInput `pulumi:"conditionAbsent"`
	// A condition that checks for log messages matching given constraints. If set, no other conditions can be present.
	ConditionMatchedLog LogMatchPtrInput `pulumi:"conditionMatchedLog"`
	// A condition that uses the Monitoring Query Language to define alerts.
	ConditionMonitoringQueryLanguage MonitoringQueryLanguageConditionPtrInput `pulumi:"conditionMonitoringQueryLanguage"`
	// A condition that uses the Prometheus query language to define alerts.
	ConditionPrometheusQueryLanguage PrometheusQueryLanguageConditionPtrInput `pulumi:"conditionPrometheusQueryLanguage"`
	// A condition that compares a time series against a threshold.
	ConditionThreshold MetricThresholdPtrInput `pulumi:"conditionThreshold"`
	// A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Cloud Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Cloud Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Condition)(nil)).Elem()
}

func (i ConditionArgs) ToConditionOutput() ConditionOutput {
	return i.ToConditionOutputWithContext(context.Background())
}

func (i ConditionArgs) ToConditionOutputWithContext(ctx context.Context) ConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionOutput)
}

// ConditionArrayInput is an input type that accepts ConditionArray and ConditionArrayOutput values.
// You can construct a concrete instance of `ConditionArrayInput` via:
//
//	ConditionArray{ ConditionArgs{...} }
type ConditionArrayInput interface {
	pulumi.Input

	ToConditionArrayOutput() ConditionArrayOutput
	ToConditionArrayOutputWithContext(context.Context) ConditionArrayOutput
}

type ConditionArray []ConditionInput

func (ConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Condition)(nil)).Elem()
}

func (i ConditionArray) ToConditionArrayOutput() ConditionArrayOutput {
	return i.ToConditionArrayOutputWithContext(context.Background())
}

func (i ConditionArray) ToConditionArrayOutputWithContext(ctx context.Context) ConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionArrayOutput)
}

// A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
type ConditionOutput struct{ *pulumi.OutputState }

func (ConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Condition)(nil)).Elem()
}

func (o ConditionOutput) ToConditionOutput() ConditionOutput {
	return o
}

func (o ConditionOutput) ToConditionOutputWithContext(ctx context.Context) ConditionOutput {
	return o
}

// A condition that checks that a time series continues to receive new data points.
func (o ConditionOutput) ConditionAbsent() MetricAbsencePtrOutput {
	return o.ApplyT(func(v Condition) *MetricAbsence { return v.ConditionAbsent }).(MetricAbsencePtrOutput)
}

// A condition that checks for log messages matching given constraints. If set, no other conditions can be present.
func (o ConditionOutput) ConditionMatchedLog() LogMatchPtrOutput {
	return o.ApplyT(func(v Condition) *LogMatch { return v.ConditionMatchedLog }).(LogMatchPtrOutput)
}

// A condition that uses the Monitoring Query Language to define alerts.
func (o ConditionOutput) ConditionMonitoringQueryLanguage() MonitoringQueryLanguageConditionPtrOutput {
	return o.ApplyT(func(v Condition) *MonitoringQueryLanguageCondition { return v.ConditionMonitoringQueryLanguage }).(MonitoringQueryLanguageConditionPtrOutput)
}

// A condition that uses the Prometheus query language to define alerts.
func (o ConditionOutput) ConditionPrometheusQueryLanguage() PrometheusQueryLanguageConditionPtrOutput {
	return o.ApplyT(func(v Condition) *PrometheusQueryLanguageCondition { return v.ConditionPrometheusQueryLanguage }).(PrometheusQueryLanguageConditionPtrOutput)
}

// A condition that compares a time series against a threshold.
func (o ConditionOutput) ConditionThreshold() MetricThresholdPtrOutput {
	return o.ApplyT(func(v Condition) *MetricThreshold { return v.ConditionThreshold }).(MetricThresholdPtrOutput)
}

// A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
func (o ConditionOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Condition) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Cloud Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Cloud Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
func (o ConditionOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Condition) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ConditionArrayOutput struct{ *pulumi.OutputState }

func (ConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Condition)(nil)).Elem()
}

func (o ConditionArrayOutput) ToConditionArrayOutput() ConditionArrayOutput {
	return o
}

func (o ConditionArrayOutput) ToConditionArrayOutputWithContext(ctx context.Context) ConditionArrayOutput {
	return o
}

func (o ConditionArrayOutput) Index(i pulumi.IntInput) ConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Condition {
		return vs[0].([]Condition)[vs[1].(int)]
	}).(ConditionOutput)
}

// A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
type ConditionResponse struct {
	// A condition that checks that a time series continues to receive new data points.
	ConditionAbsent MetricAbsenceResponse `pulumi:"conditionAbsent"`
	// A condition that checks for log messages matching given constraints. If set, no other conditions can be present.
	ConditionMatchedLog LogMatchResponse `pulumi:"conditionMatchedLog"`
	// A condition that uses the Monitoring Query Language to define alerts.
	ConditionMonitoringQueryLanguage MonitoringQueryLanguageConditionResponse `pulumi:"conditionMonitoringQueryLanguage"`
	// A condition that uses the Prometheus query language to define alerts.
	ConditionPrometheusQueryLanguage PrometheusQueryLanguageConditionResponse `pulumi:"conditionPrometheusQueryLanguage"`
	// A condition that compares a time series against a threshold.
	ConditionThreshold MetricThresholdResponse `pulumi:"conditionThreshold"`
	// A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
	DisplayName string `pulumi:"displayName"`
	// Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Cloud Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Cloud Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
	Name string `pulumi:"name"`
}

// A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
type ConditionResponseOutput struct{ *pulumi.OutputState }

func (ConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConditionResponse)(nil)).Elem()
}

func (o ConditionResponseOutput) ToConditionResponseOutput() ConditionResponseOutput {
	return o
}

func (o ConditionResponseOutput) ToConditionResponseOutputWithContext(ctx context.Context) ConditionResponseOutput {
	return o
}

// A condition that checks that a time series continues to receive new data points.
func (o ConditionResponseOutput) ConditionAbsent() MetricAbsenceResponseOutput {
	return o.ApplyT(func(v ConditionResponse) MetricAbsenceResponse { return v.ConditionAbsent }).(MetricAbsenceResponseOutput)
}

// A condition that checks for log messages matching given constraints. If set, no other conditions can be present.
func (o ConditionResponseOutput) ConditionMatchedLog() LogMatchResponseOutput {
	return o.ApplyT(func(v ConditionResponse) LogMatchResponse { return v.ConditionMatchedLog }).(LogMatchResponseOutput)
}

// A condition that uses the Monitoring Query Language to define alerts.
func (o ConditionResponseOutput) ConditionMonitoringQueryLanguage() MonitoringQueryLanguageConditionResponseOutput {
	return o.ApplyT(func(v ConditionResponse) MonitoringQueryLanguageConditionResponse {
		return v.ConditionMonitoringQueryLanguage
	}).(MonitoringQueryLanguageConditionResponseOutput)
}

// A condition that uses the Prometheus query language to define alerts.
func (o ConditionResponseOutput) ConditionPrometheusQueryLanguage() PrometheusQueryLanguageConditionResponseOutput {
	return o.ApplyT(func(v ConditionResponse) PrometheusQueryLanguageConditionResponse {
		return v.ConditionPrometheusQueryLanguage
	}).(PrometheusQueryLanguageConditionResponseOutput)
}

// A condition that compares a time series against a threshold.
func (o ConditionResponseOutput) ConditionThreshold() MetricThresholdResponseOutput {
	return o.ApplyT(func(v ConditionResponse) MetricThresholdResponse { return v.ConditionThreshold }).(MetricThresholdResponseOutput)
}

// A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
func (o ConditionResponseOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v ConditionResponse) string { return v.DisplayName }).(pulumi.StringOutput)
}

// Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Cloud Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Cloud Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
func (o ConditionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ConditionResponse) string { return v.Name }).(pulumi.StringOutput)
}

type ConditionResponseArrayOutput struct{ *pulumi.OutputState }

func (ConditionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ConditionResponse)(nil)).Elem()
}

func (o ConditionResponseArrayOutput) ToConditionResponseArrayOutput() ConditionResponseArrayOutput {
	return o
}

func (o ConditionResponseArrayOutput) ToConditionResponseArrayOutputWithContext(ctx context.Context) ConditionResponseArrayOutput {
	return o
}

func (o ConditionResponseArrayOutput) Index(i pulumi.IntInput) ConditionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ConditionResponse {
		return vs[0].([]ConditionResponse)[vs[1].(int)]
	}).(ConditionResponseOutput)
}

// Optional. Used to perform content matching. This allows matching based on substrings and regular expressions, together with their negations. Only the first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP check's response) are examined for purposes of content matching.
type ContentMatcher struct {
	// String, regex or JSON content to match. Maximum 1024 bytes. An empty content string indicates no content matching is to be performed.
	Content *string `pulumi:"content"`
	// Matcher information for MATCHES_JSON_PATH and NOT_MATCHES_JSON_PATH
	JsonPathMatcher *JsonPathMatcher `pulumi:"jsonPathMatcher"`
	// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
	Matcher *ContentMatcherMatcher `pulumi:"matcher"`
}

// ContentMatcherInput is an input type that accepts ContentMatcherArgs and ContentMatcherOutput values.
// You can construct a concrete instance of `ContentMatcherInput` via:
//
//	ContentMatcherArgs{...}
type ContentMatcherInput interface {
	pulumi.Input

	ToContentMatcherOutput() ContentMatcherOutput
	ToContentMatcherOutputWithContext(context.Context) ContentMatcherOutput
}

// Optional. Used to perform content matching. This allows matching based on substrings and regular expressions, together with their negations. Only the first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP check's response) are examined for purposes of content matching.
type ContentMatcherArgs struct {
	// String, regex or JSON content to match. Maximum 1024 bytes. An empty content string indicates no content matching is to be performed.
	Content pulumi.StringPtrInput `pulumi:"content"`
	// Matcher information for MATCHES_JSON_PATH and NOT_MATCHES_JSON_PATH
	JsonPathMatcher JsonPathMatcherPtrInput `pulumi:"jsonPathMatcher"`
	// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
	Matcher ContentMatcherMatcherPtrInput `pulumi:"matcher"`
}

func (ContentMatcherArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentMatcher)(nil)).Elem()
}

func (i ContentMatcherArgs) ToContentMatcherOutput() ContentMatcherOutput {
	return i.ToContentMatcherOutputWithContext(context.Background())
}

func (i ContentMatcherArgs) ToContentMatcherOutputWithContext(ctx context.Context) ContentMatcherOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentMatcherOutput)
}

// ContentMatcherArrayInput is an input type that accepts ContentMatcherArray and ContentMatcherArrayOutput values.
// You can construct a concrete instance of `ContentMatcherArrayInput` via:
//
//	ContentMatcherArray{ ContentMatcherArgs{...} }
type ContentMatcherArrayInput interface {
	pulumi.Input

	ToContentMatcherArrayOutput() ContentMatcherArrayOutput
	ToContentMatcherArrayOutputWithContext(context.Context) ContentMatcherArrayOutput
}

type ContentMatcherArray []ContentMatcherInput

func (ContentMatcherArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentMatcher)(nil)).Elem()
}

func (i ContentMatcherArray) ToContentMatcherArrayOutput() ContentMatcherArrayOutput {
	return i.ToContentMatcherArrayOutputWithContext(context.Background())
}

func (i ContentMatcherArray) ToContentMatcherArrayOutputWithContext(ctx context.Context) ContentMatcherArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentMatcherArrayOutput)
}

// Optional. Used to perform content matching. This allows matching based on substrings and regular expressions, together with their negations. Only the first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP check's response) are examined for purposes of content matching.
type ContentMatcherOutput struct{ *pulumi.OutputState }

func (ContentMatcherOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentMatcher)(nil)).Elem()
}

func (o ContentMatcherOutput) ToContentMatcherOutput() ContentMatcherOutput {
	return o
}

func (o ContentMatcherOutput) ToContentMatcherOutputWithContext(ctx context.Context) ContentMatcherOutput {
	return o
}

// String, regex or JSON content to match. Maximum 1024 bytes. An empty content string indicates no content matching is to be performed.
func (o ContentMatcherOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentMatcher) *string { return v.Content }).(pulumi.StringPtrOutput)
}

// Matcher information for MATCHES_JSON_PATH and NOT_MATCHES_JSON_PATH
func (o ContentMatcherOutput) JsonPathMatcher() JsonPathMatcherPtrOutput {
	return o.ApplyT(func(v ContentMatcher) *JsonPathMatcher { return v.JsonPathMatcher }).(JsonPathMatcherPtrOutput)
}

// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
func (o ContentMatcherOutput) Matcher() ContentMatcherMatcherPtrOutput {
	return o.ApplyT(func(v ContentMatcher) *ContentMatcherMatcher { return v.Matcher }).(ContentMatcherMatcherPtrOutput)
}

type ContentMatcherArrayOutput struct{ *pulumi.OutputState }

func (ContentMatcherArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentMatcher)(nil)).Elem()
}

func (o ContentMatcherArrayOutput) ToContentMatcherArrayOutput() ContentMatcherArrayOutput {
	return o
}

func (o ContentMatcherArrayOutput) ToContentMatcherArrayOutputWithContext(ctx context.Context) ContentMatcherArrayOutput {
	return o
}

func (o ContentMatcherArrayOutput) Index(i pulumi.IntInput) ContentMatcherOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContentMatcher {
		return vs[0].([]ContentMatcher)[vs[1].(int)]
	}).(ContentMatcherOutput)
}

// Optional. Used to perform content matching. This allows matching based on substrings and regular expressions, together with their negations. Only the first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP check's response) are examined for purposes of content matching.
type ContentMatcherResponse struct {
	// String, regex or JSON content to match. Maximum 1024 bytes. An empty content string indicates no content matching is to be performed.
	Content string `pulumi:"content"`
	// Matcher information for MATCHES_JSON_PATH and NOT_MATCHES_JSON_PATH
	JsonPathMatcher JsonPathMatcherResponse `pulumi:"jsonPathMatcher"`
	// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
	Matcher string `pulumi:"matcher"`
}

// Optional. Used to perform content matching. This allows matching based on substrings and regular expressions, together with their negations. Only the first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP check's response) are examined for purposes of content matching.
type ContentMatcherResponseOutput struct{ *pulumi.OutputState }

func (ContentMatcherResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentMatcherResponse)(nil)).Elem()
}

func (o ContentMatcherResponseOutput) ToContentMatcherResponseOutput() ContentMatcherResponseOutput {
	return o
}

func (o ContentMatcherResponseOutput) ToContentMatcherResponseOutputWithContext(ctx context.Context) ContentMatcherResponseOutput {
	return o
}

// String, regex or JSON content to match. Maximum 1024 bytes. An empty content string indicates no content matching is to be performed.
func (o ContentMatcherResponseOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v ContentMatcherResponse) string { return v.Content }).(pulumi.StringOutput)
}

// Matcher information for MATCHES_JSON_PATH and NOT_MATCHES_JSON_PATH
func (o ContentMatcherResponseOutput) JsonPathMatcher() JsonPathMatcherResponseOutput {
	return o.ApplyT(func(v ContentMatcherResponse) JsonPathMatcherResponse { return v.JsonPathMatcher }).(JsonPathMatcherResponseOutput)
}

// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
func (o ContentMatcherResponseOutput) Matcher() pulumi.StringOutput {
	return o.ApplyT(func(v ContentMatcherResponse) string { return v.Matcher }).(pulumi.StringOutput)
}

type ContentMatcherResponseArrayOutput struct{ *pulumi.OutputState }

func (ContentMatcherResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentMatcherResponse)(nil)).Elem()
}

func (o ContentMatcherResponseArrayOutput) ToContentMatcherResponseArrayOutput() ContentMatcherResponseArrayOutput {
	return o
}

func (o ContentMatcherResponseArrayOutput) ToContentMatcherResponseArrayOutputWithContext(ctx context.Context) ContentMatcherResponseArrayOutput {
	return o
}

func (o ContentMatcherResponseArrayOutput) Index(i pulumi.IntInput) ContentMatcherResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContentMatcherResponse {
		return vs[0].([]ContentMatcherResponse)[vs[1].(int)]
	}).(ContentMatcherResponseOutput)
}

// Criteria specific to the AlertPolicys that this Snooze applies to. The Snooze will suppress alerts that come from one of the AlertPolicys whose names are supplied.
type Criteria struct {
	// The specific AlertPolicy names for the alert that should be snoozed. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID] There is a limit of 16 policies per snooze. This limit is checked during snooze creation.
	Policies []string `pulumi:"policies"`
}

// CriteriaInput is an input type that accepts CriteriaArgs and CriteriaOutput values.
// You can construct a concrete instance of `CriteriaInput` via:
//
//	CriteriaArgs{...}
type CriteriaInput interface {
	pulumi.Input

	ToCriteriaOutput() CriteriaOutput
	ToCriteriaOutputWithContext(context.Context) CriteriaOutput
}

// Criteria specific to the AlertPolicys that this Snooze applies to. The Snooze will suppress alerts that come from one of the AlertPolicys whose names are supplied.
type CriteriaArgs struct {
	// The specific AlertPolicy names for the alert that should be snoozed. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID] There is a limit of 16 policies per snooze. This limit is checked during snooze creation.
	Policies pulumi.StringArrayInput `pulumi:"policies"`
}

func (CriteriaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Criteria)(nil)).Elem()
}

func (i CriteriaArgs) ToCriteriaOutput() CriteriaOutput {
	return i.ToCriteriaOutputWithContext(context.Background())
}

func (i CriteriaArgs) ToCriteriaOutputWithContext(ctx context.Context) CriteriaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CriteriaOutput)
}

// Criteria specific to the AlertPolicys that this Snooze applies to. The Snooze will suppress alerts that come from one of the AlertPolicys whose names are supplied.
type CriteriaOutput struct{ *pulumi.OutputState }

func (CriteriaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Criteria)(nil)).Elem()
}

func (o CriteriaOutput) ToCriteriaOutput() CriteriaOutput {
	return o
}

func (o CriteriaOutput) ToCriteriaOutputWithContext(ctx context.Context) CriteriaOutput {
	return o
}

// The specific AlertPolicy names for the alert that should be snoozed. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID] There is a limit of 16 policies per snooze. This limit is checked during snooze creation.
func (o CriteriaOutput) Policies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Criteria) []string { return v.Policies }).(pulumi.StringArrayOutput)
}

// Criteria specific to the AlertPolicys that this Snooze applies to. The Snooze will suppress alerts that come from one of the AlertPolicys whose names are supplied.
type CriteriaResponse struct {
	// The specific AlertPolicy names for the alert that should be snoozed. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID] There is a limit of 16 policies per snooze. This limit is checked during snooze creation.
	Policies []string `pulumi:"policies"`
}

// Criteria specific to the AlertPolicys that this Snooze applies to. The Snooze will suppress alerts that come from one of the AlertPolicys whose names are supplied.
type CriteriaResponseOutput struct{ *pulumi.OutputState }

func (CriteriaResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CriteriaResponse)(nil)).Elem()
}

func (o CriteriaResponseOutput) ToCriteriaResponseOutput() CriteriaResponseOutput {
	return o
}

func (o CriteriaResponseOutput) ToCriteriaResponseOutputWithContext(ctx context.Context) CriteriaResponseOutput {
	return o
}

// The specific AlertPolicy names for the alert that should be snoozed. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID] There is a limit of 16 policies per snooze. This limit is checked during snooze creation.
func (o CriteriaResponseOutput) Policies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CriteriaResponse) []string { return v.Policies }).(pulumi.StringArrayOutput)
}

// Use a custom service to designate a service that you want to monitor when none of the other service types (like App Engine, Cloud Run, or a GKE type) matches your intended service.
type Custom struct {
}

// CustomInput is an input type that accepts CustomArgs and CustomOutput values.
// You can construct a concrete instance of `CustomInput` via:
//
//	CustomArgs{...}
type CustomInput interface {
	pulumi.Input

	ToCustomOutput() CustomOutput
	ToCustomOutputWithContext(context.Context) CustomOutput
}

// Use a custom service to designate a service that you want to monitor when none of the other service types (like App Engine, Cloud Run, or a GKE type) matches your intended service.
type CustomArgs struct {
}

func (CustomArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Custom)(nil)).Elem()
}

func (i CustomArgs) ToCustomOutput() CustomOutput {
	return i.ToCustomOutputWithContext(context.Background())
}

func (i CustomArgs) ToCustomOutputWithContext(ctx context.Context) CustomOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomOutput)
}

func (i CustomArgs) ToCustomPtrOutput() CustomPtrOutput {
	return i.ToCustomPtrOutputWithContext(context.Background())
}

func (i CustomArgs) ToCustomPtrOutputWithContext(ctx context.Context) CustomPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomOutput).ToCustomPtrOutputWithContext(ctx)
}

// CustomPtrInput is an input type that accepts CustomArgs, CustomPtr and CustomPtrOutput values.
// You can construct a concrete instance of `CustomPtrInput` via:
//
//	        CustomArgs{...}
//
//	or:
//
//	        nil
type CustomPtrInput interface {
	pulumi.Input

	ToCustomPtrOutput() CustomPtrOutput
	ToCustomPtrOutputWithContext(context.Context) CustomPtrOutput
}

type customPtrType CustomArgs

func CustomPtr(v *CustomArgs) CustomPtrInput {
	return (*customPtrType)(v)
}

func (*customPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Custom)(nil)).Elem()
}

func (i *customPtrType) ToCustomPtrOutput() CustomPtrOutput {
	return i.ToCustomPtrOutputWithContext(context.Background())
}

func (i *customPtrType) ToCustomPtrOutputWithContext(ctx context.Context) CustomPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomPtrOutput)
}

// Use a custom service to designate a service that you want to monitor when none of the other service types (like App Engine, Cloud Run, or a GKE type) matches your intended service.
type CustomOutput struct{ *pulumi.OutputState }

func (CustomOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Custom)(nil)).Elem()
}

func (o CustomOutput) ToCustomOutput() CustomOutput {
	return o
}

func (o CustomOutput) ToCustomOutputWithContext(ctx context.Context) CustomOutput {
	return o
}

func (o CustomOutput) ToCustomPtrOutput() CustomPtrOutput {
	return o.ToCustomPtrOutputWithContext(context.Background())
}

func (o CustomOutput) ToCustomPtrOutputWithContext(ctx context.Context) CustomPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Custom) *Custom {
		return &v
	}).(CustomPtrOutput)
}

type CustomPtrOutput struct{ *pulumi.OutputState }

func (CustomPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Custom)(nil)).Elem()
}

func (o CustomPtrOutput) ToCustomPtrOutput() CustomPtrOutput {
	return o
}

func (o CustomPtrOutput) ToCustomPtrOutputWithContext(ctx context.Context) CustomPtrOutput {
	return o
}

func (o CustomPtrOutput) Elem() CustomOutput {
	return o.ApplyT(func(v *Custom) Custom {
		if v != nil {
			return *v
		}
		var ret Custom
		return ret
	}).(CustomOutput)
}

// Use a custom service to designate a service that you want to monitor when none of the other service types (like App Engine, Cloud Run, or a GKE type) matches your intended service.
type CustomResponse struct {
}

// Use a custom service to designate a service that you want to monitor when none of the other service types (like App Engine, Cloud Run, or a GKE type) matches your intended service.
type CustomResponseOutput struct{ *pulumi.OutputState }

func (CustomResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomResponse)(nil)).Elem()
}

func (o CustomResponseOutput) ToCustomResponseOutput() CustomResponseOutput {
	return o
}

func (o CustomResponseOutput) ToCustomResponseOutputWithContext(ctx context.Context) CustomResponseOutput {
	return o
}

// A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the estimated count of values in the Distribution that fall within the specified min and max.
type DistributionCut struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter *string `pulumi:"distributionFilter"`
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range *GoogleMonitoringV3Range `pulumi:"range"`
}

// DistributionCutInput is an input type that accepts DistributionCutArgs and DistributionCutOutput values.
// You can construct a concrete instance of `DistributionCutInput` via:
//
//	DistributionCutArgs{...}
type DistributionCutInput interface {
	pulumi.Input

	ToDistributionCutOutput() DistributionCutOutput
	ToDistributionCutOutputWithContext(context.Context) DistributionCutOutput
}

// A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the estimated count of values in the Distribution that fall within the specified min and max.
type DistributionCutArgs struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter pulumi.StringPtrInput `pulumi:"distributionFilter"`
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range GoogleMonitoringV3RangePtrInput `pulumi:"range"`
}

func (DistributionCutArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DistributionCut)(nil)).Elem()
}

func (i DistributionCutArgs) ToDistributionCutOutput() DistributionCutOutput {
	return i.ToDistributionCutOutputWithContext(context.Background())
}

func (i DistributionCutArgs) ToDistributionCutOutputWithContext(ctx context.Context) DistributionCutOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionCutOutput)
}

func (i DistributionCutArgs) ToDistributionCutPtrOutput() DistributionCutPtrOutput {
	return i.ToDistributionCutPtrOutputWithContext(context.Background())
}

func (i DistributionCutArgs) ToDistributionCutPtrOutputWithContext(ctx context.Context) DistributionCutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionCutOutput).ToDistributionCutPtrOutputWithContext(ctx)
}

// DistributionCutPtrInput is an input type that accepts DistributionCutArgs, DistributionCutPtr and DistributionCutPtrOutput values.
// You can construct a concrete instance of `DistributionCutPtrInput` via:
//
//	        DistributionCutArgs{...}
//
//	or:
//
//	        nil
type DistributionCutPtrInput interface {
	pulumi.Input

	ToDistributionCutPtrOutput() DistributionCutPtrOutput
	ToDistributionCutPtrOutputWithContext(context.Context) DistributionCutPtrOutput
}

type distributionCutPtrType DistributionCutArgs

func DistributionCutPtr(v *DistributionCutArgs) DistributionCutPtrInput {
	return (*distributionCutPtrType)(v)
}

func (*distributionCutPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DistributionCut)(nil)).Elem()
}

func (i *distributionCutPtrType) ToDistributionCutPtrOutput() DistributionCutPtrOutput {
	return i.ToDistributionCutPtrOutputWithContext(context.Background())
}

func (i *distributionCutPtrType) ToDistributionCutPtrOutputWithContext(ctx context.Context) DistributionCutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionCutPtrOutput)
}

// A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the estimated count of values in the Distribution that fall within the specified min and max.
type DistributionCutOutput struct{ *pulumi.OutputState }

func (DistributionCutOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DistributionCut)(nil)).Elem()
}

func (o DistributionCutOutput) ToDistributionCutOutput() DistributionCutOutput {
	return o
}

func (o DistributionCutOutput) ToDistributionCutOutputWithContext(ctx context.Context) DistributionCutOutput {
	return o
}

func (o DistributionCutOutput) ToDistributionCutPtrOutput() DistributionCutPtrOutput {
	return o.ToDistributionCutPtrOutputWithContext(context.Background())
}

func (o DistributionCutOutput) ToDistributionCutPtrOutputWithContext(ctx context.Context) DistributionCutPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DistributionCut) *DistributionCut {
		return &v
	}).(DistributionCutPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o DistributionCutOutput) DistributionFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DistributionCut) *string { return v.DistributionFilter }).(pulumi.StringPtrOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o DistributionCutOutput) Range() GoogleMonitoringV3RangePtrOutput {
	return o.ApplyT(func(v DistributionCut) *GoogleMonitoringV3Range { return v.Range }).(GoogleMonitoringV3RangePtrOutput)
}

type DistributionCutPtrOutput struct{ *pulumi.OutputState }

func (DistributionCutPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DistributionCut)(nil)).Elem()
}

func (o DistributionCutPtrOutput) ToDistributionCutPtrOutput() DistributionCutPtrOutput {
	return o
}

func (o DistributionCutPtrOutput) ToDistributionCutPtrOutputWithContext(ctx context.Context) DistributionCutPtrOutput {
	return o
}

func (o DistributionCutPtrOutput) Elem() DistributionCutOutput {
	return o.ApplyT(func(v *DistributionCut) DistributionCut {
		if v != nil {
			return *v
		}
		var ret DistributionCut
		return ret
	}).(DistributionCutOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o DistributionCutPtrOutput) DistributionFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DistributionCut) *string {
		if v == nil {
			return nil
		}
		return v.DistributionFilter
	}).(pulumi.StringPtrOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o DistributionCutPtrOutput) Range() GoogleMonitoringV3RangePtrOutput {
	return o.ApplyT(func(v *DistributionCut) *GoogleMonitoringV3Range {
		if v == nil {
			return nil
		}
		return v.Range
	}).(GoogleMonitoringV3RangePtrOutput)
}

// A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the estimated count of values in the Distribution that fall within the specified min and max.
type DistributionCutResponse struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter string `pulumi:"distributionFilter"`
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range GoogleMonitoringV3RangeResponse `pulumi:"range"`
}

// A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the estimated count of values in the Distribution that fall within the specified min and max.
type DistributionCutResponseOutput struct{ *pulumi.OutputState }

func (DistributionCutResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DistributionCutResponse)(nil)).Elem()
}

func (o DistributionCutResponseOutput) ToDistributionCutResponseOutput() DistributionCutResponseOutput {
	return o
}

func (o DistributionCutResponseOutput) ToDistributionCutResponseOutputWithContext(ctx context.Context) DistributionCutResponseOutput {
	return o
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o DistributionCutResponseOutput) DistributionFilter() pulumi.StringOutput {
	return o.ApplyT(func(v DistributionCutResponse) string { return v.DistributionFilter }).(pulumi.StringOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o DistributionCutResponseOutput) Range() GoogleMonitoringV3RangeResponseOutput {
	return o.ApplyT(func(v DistributionCutResponse) GoogleMonitoringV3RangeResponse { return v.Range }).(GoogleMonitoringV3RangeResponseOutput)
}

// A content string and a MIME type that describes the content string's format.
type Documentation struct {
	// The body of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller. This text can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables).
	Content *string `pulumi:"content"`
	// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
	MimeType *string `pulumi:"mimeType"`
	// Optional. The subject line of the notification. The subject line may not exceed 10,240 bytes. In notifications generated by this policy, the contents of the subject line after variable expansion will be truncated to 255 bytes or shorter at the latest UTF-8 character boundary. The 255-byte limit is recommended by this thread (https://stackoverflow.com/questions/1592291/what-is-the-email-subject-length-limit). It is both the limit imposed by some third-party ticketing products and it is common to define textual fields in databases as VARCHAR(255).The contents of the subject line can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables). If this field is missing or empty, a default subject line will be generated.
	Subject *string `pulumi:"subject"`
}

// DocumentationInput is an input type that accepts DocumentationArgs and DocumentationOutput values.
// You can construct a concrete instance of `DocumentationInput` via:
//
//	DocumentationArgs{...}
type DocumentationInput interface {
	pulumi.Input

	ToDocumentationOutput() DocumentationOutput
	ToDocumentationOutputWithContext(context.Context) DocumentationOutput
}

// A content string and a MIME type that describes the content string's format.
type DocumentationArgs struct {
	// The body of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller. This text can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables).
	Content pulumi.StringPtrInput `pulumi:"content"`
	// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
	MimeType pulumi.StringPtrInput `pulumi:"mimeType"`
	// Optional. The subject line of the notification. The subject line may not exceed 10,240 bytes. In notifications generated by this policy, the contents of the subject line after variable expansion will be truncated to 255 bytes or shorter at the latest UTF-8 character boundary. The 255-byte limit is recommended by this thread (https://stackoverflow.com/questions/1592291/what-is-the-email-subject-length-limit). It is both the limit imposed by some third-party ticketing products and it is common to define textual fields in databases as VARCHAR(255).The contents of the subject line can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables). If this field is missing or empty, a default subject line will be generated.
	Subject pulumi.StringPtrInput `pulumi:"subject"`
}

func (DocumentationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Documentation)(nil)).Elem()
}

func (i DocumentationArgs) ToDocumentationOutput() DocumentationOutput {
	return i.ToDocumentationOutputWithContext(context.Background())
}

func (i DocumentationArgs) ToDocumentationOutputWithContext(ctx context.Context) DocumentationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentationOutput)
}

func (i DocumentationArgs) ToDocumentationPtrOutput() DocumentationPtrOutput {
	return i.ToDocumentationPtrOutputWithContext(context.Background())
}

func (i DocumentationArgs) ToDocumentationPtrOutputWithContext(ctx context.Context) DocumentationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentationOutput).ToDocumentationPtrOutputWithContext(ctx)
}

// DocumentationPtrInput is an input type that accepts DocumentationArgs, DocumentationPtr and DocumentationPtrOutput values.
// You can construct a concrete instance of `DocumentationPtrInput` via:
//
//	        DocumentationArgs{...}
//
//	or:
//
//	        nil
type DocumentationPtrInput interface {
	pulumi.Input

	ToDocumentationPtrOutput() DocumentationPtrOutput
	ToDocumentationPtrOutputWithContext(context.Context) DocumentationPtrOutput
}

type documentationPtrType DocumentationArgs

func DocumentationPtr(v *DocumentationArgs) DocumentationPtrInput {
	return (*documentationPtrType)(v)
}

func (*documentationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Documentation)(nil)).Elem()
}

func (i *documentationPtrType) ToDocumentationPtrOutput() DocumentationPtrOutput {
	return i.ToDocumentationPtrOutputWithContext(context.Background())
}

func (i *documentationPtrType) ToDocumentationPtrOutputWithContext(ctx context.Context) DocumentationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentationPtrOutput)
}

// A content string and a MIME type that describes the content string's format.
type DocumentationOutput struct{ *pulumi.OutputState }

func (DocumentationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Documentation)(nil)).Elem()
}

func (o DocumentationOutput) ToDocumentationOutput() DocumentationOutput {
	return o
}

func (o DocumentationOutput) ToDocumentationOutputWithContext(ctx context.Context) DocumentationOutput {
	return o
}

func (o DocumentationOutput) ToDocumentationPtrOutput() DocumentationPtrOutput {
	return o.ToDocumentationPtrOutputWithContext(context.Background())
}

func (o DocumentationOutput) ToDocumentationPtrOutputWithContext(ctx context.Context) DocumentationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Documentation) *Documentation {
		return &v
	}).(DocumentationPtrOutput)
}

// The body of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller. This text can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables).
func (o DocumentationOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Documentation) *string { return v.Content }).(pulumi.StringPtrOutput)
}

// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
func (o DocumentationOutput) MimeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Documentation) *string { return v.MimeType }).(pulumi.StringPtrOutput)
}

// Optional. The subject line of the notification. The subject line may not exceed 10,240 bytes. In notifications generated by this policy, the contents of the subject line after variable expansion will be truncated to 255 bytes or shorter at the latest UTF-8 character boundary. The 255-byte limit is recommended by this thread (https://stackoverflow.com/questions/1592291/what-is-the-email-subject-length-limit). It is both the limit imposed by some third-party ticketing products and it is common to define textual fields in databases as VARCHAR(255).The contents of the subject line can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables). If this field is missing or empty, a default subject line will be generated.
func (o DocumentationOutput) Subject() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Documentation) *string { return v.Subject }).(pulumi.StringPtrOutput)
}

type DocumentationPtrOutput struct{ *pulumi.OutputState }

func (DocumentationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Documentation)(nil)).Elem()
}

func (o DocumentationPtrOutput) ToDocumentationPtrOutput() DocumentationPtrOutput {
	return o
}

func (o DocumentationPtrOutput) ToDocumentationPtrOutputWithContext(ctx context.Context) DocumentationPtrOutput {
	return o
}

func (o DocumentationPtrOutput) Elem() DocumentationOutput {
	return o.ApplyT(func(v *Documentation) Documentation {
		if v != nil {
			return *v
		}
		var ret Documentation
		return ret
	}).(DocumentationOutput)
}

// The body of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller. This text can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables).
func (o DocumentationPtrOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Documentation) *string {
		if v == nil {
			return nil
		}
		return v.Content
	}).(pulumi.StringPtrOutput)
}

// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
func (o DocumentationPtrOutput) MimeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Documentation) *string {
		if v == nil {
			return nil
		}
		return v.MimeType
	}).(pulumi.StringPtrOutput)
}

// Optional. The subject line of the notification. The subject line may not exceed 10,240 bytes. In notifications generated by this policy, the contents of the subject line after variable expansion will be truncated to 255 bytes or shorter at the latest UTF-8 character boundary. The 255-byte limit is recommended by this thread (https://stackoverflow.com/questions/1592291/what-is-the-email-subject-length-limit). It is both the limit imposed by some third-party ticketing products and it is common to define textual fields in databases as VARCHAR(255).The contents of the subject line can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables). If this field is missing or empty, a default subject line will be generated.
func (o DocumentationPtrOutput) Subject() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Documentation) *string {
		if v == nil {
			return nil
		}
		return v.Subject
	}).(pulumi.StringPtrOutput)
}

// A content string and a MIME type that describes the content string's format.
type DocumentationResponse struct {
	// The body of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller. This text can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables).
	Content string `pulumi:"content"`
	// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
	MimeType string `pulumi:"mimeType"`
	// Optional. The subject line of the notification. The subject line may not exceed 10,240 bytes. In notifications generated by this policy, the contents of the subject line after variable expansion will be truncated to 255 bytes or shorter at the latest UTF-8 character boundary. The 255-byte limit is recommended by this thread (https://stackoverflow.com/questions/1592291/what-is-the-email-subject-length-limit). It is both the limit imposed by some third-party ticketing products and it is common to define textual fields in databases as VARCHAR(255).The contents of the subject line can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables). If this field is missing or empty, a default subject line will be generated.
	Subject string `pulumi:"subject"`
}

// A content string and a MIME type that describes the content string's format.
type DocumentationResponseOutput struct{ *pulumi.OutputState }

func (DocumentationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DocumentationResponse)(nil)).Elem()
}

func (o DocumentationResponseOutput) ToDocumentationResponseOutput() DocumentationResponseOutput {
	return o
}

func (o DocumentationResponseOutput) ToDocumentationResponseOutputWithContext(ctx context.Context) DocumentationResponseOutput {
	return o
}

// The body of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller. This text can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables).
func (o DocumentationResponseOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v DocumentationResponse) string { return v.Content }).(pulumi.StringOutput)
}

// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
func (o DocumentationResponseOutput) MimeType() pulumi.StringOutput {
	return o.ApplyT(func(v DocumentationResponse) string { return v.MimeType }).(pulumi.StringOutput)
}

// Optional. The subject line of the notification. The subject line may not exceed 10,240 bytes. In notifications generated by this policy, the contents of the subject line after variable expansion will be truncated to 255 bytes or shorter at the latest UTF-8 character boundary. The 255-byte limit is recommended by this thread (https://stackoverflow.com/questions/1592291/what-is-the-email-subject-length-limit). It is both the limit imposed by some third-party ticketing products and it is common to define textual fields in databases as VARCHAR(255).The contents of the subject line can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables). If this field is missing or empty, a default subject line will be generated.
func (o DocumentationResponseOutput) Subject() pulumi.StringOutput {
	return o.ApplyT(func(v DocumentationResponse) string { return v.Subject }).(pulumi.StringOutput)
}

// Options used when forecasting the time series and testing the predicted value against the threshold.
type ForecastOptions struct {
	// The length of time into the future to forecast whether a time series will violate the threshold. If the predicted value is found to violate the threshold, and the violation is observed in all forecasts made for the configured duration, then the time series is considered to be failing. The forecast horizon can range from 1 hour to 60 hours.
	ForecastHorizon string `pulumi:"forecastHorizon"`
}

// ForecastOptionsInput is an input type that accepts ForecastOptionsArgs and ForecastOptionsOutput values.
// You can construct a concrete instance of `ForecastOptionsInput` via:
//
//	ForecastOptionsArgs{...}
type ForecastOptionsInput interface {
	pulumi.Input

	ToForecastOptionsOutput() ForecastOptionsOutput
	ToForecastOptionsOutputWithContext(context.Context) ForecastOptionsOutput
}

// Options used when forecasting the time series and testing the predicted value against the threshold.
type ForecastOptionsArgs struct {
	// The length of time into the future to forecast whether a time series will violate the threshold. If the predicted value is found to violate the threshold, and the violation is observed in all forecasts made for the configured duration, then the time series is considered to be failing. The forecast horizon can range from 1 hour to 60 hours.
	ForecastHorizon pulumi.StringInput `pulumi:"forecastHorizon"`
}

func (ForecastOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ForecastOptions)(nil)).Elem()
}

func (i ForecastOptionsArgs) ToForecastOptionsOutput() ForecastOptionsOutput {
	return i.ToForecastOptionsOutputWithContext(context.Background())
}

func (i ForecastOptionsArgs) ToForecastOptionsOutputWithContext(ctx context.Context) ForecastOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ForecastOptionsOutput)
}

func (i ForecastOptionsArgs) ToForecastOptionsPtrOutput() ForecastOptionsPtrOutput {
	return i.ToForecastOptionsPtrOutputWithContext(context.Background())
}

func (i ForecastOptionsArgs) ToForecastOptionsPtrOutputWithContext(ctx context.Context) ForecastOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ForecastOptionsOutput).ToForecastOptionsPtrOutputWithContext(ctx)
}

// ForecastOptionsPtrInput is an input type that accepts ForecastOptionsArgs, ForecastOptionsPtr and ForecastOptionsPtrOutput values.
// You can construct a concrete instance of `ForecastOptionsPtrInput` via:
//
//	        ForecastOptionsArgs{...}
//
//	or:
//
//	        nil
type ForecastOptionsPtrInput interface {
	pulumi.Input

	ToForecastOptionsPtrOutput() ForecastOptionsPtrOutput
	ToForecastOptionsPtrOutputWithContext(context.Context) ForecastOptionsPtrOutput
}

type forecastOptionsPtrType ForecastOptionsArgs

func ForecastOptionsPtr(v *ForecastOptionsArgs) ForecastOptionsPtrInput {
	return (*forecastOptionsPtrType)(v)
}

func (*forecastOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ForecastOptions)(nil)).Elem()
}

func (i *forecastOptionsPtrType) ToForecastOptionsPtrOutput() ForecastOptionsPtrOutput {
	return i.ToForecastOptionsPtrOutputWithContext(context.Background())
}

func (i *forecastOptionsPtrType) ToForecastOptionsPtrOutputWithContext(ctx context.Context) ForecastOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ForecastOptionsPtrOutput)
}

// Options used when forecasting the time series and testing the predicted value against the threshold.
type ForecastOptionsOutput struct{ *pulumi.OutputState }

func (ForecastOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ForecastOptions)(nil)).Elem()
}

func (o ForecastOptionsOutput) ToForecastOptionsOutput() ForecastOptionsOutput {
	return o
}

func (o ForecastOptionsOutput) ToForecastOptionsOutputWithContext(ctx context.Context) ForecastOptionsOutput {
	return o
}

func (o ForecastOptionsOutput) ToForecastOptionsPtrOutput() ForecastOptionsPtrOutput {
	return o.ToForecastOptionsPtrOutputWithContext(context.Background())
}

func (o ForecastOptionsOutput) ToForecastOptionsPtrOutputWithContext(ctx context.Context) ForecastOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ForecastOptions) *ForecastOptions {
		return &v
	}).(ForecastOptionsPtrOutput)
}

// The length of time into the future to forecast whether a time series will violate the threshold. If the predicted value is found to violate the threshold, and the violation is observed in all forecasts made for the configured duration, then the time series is considered to be failing. The forecast horizon can range from 1 hour to 60 hours.
func (o ForecastOptionsOutput) ForecastHorizon() pulumi.StringOutput {
	return o.ApplyT(func(v ForecastOptions) string { return v.ForecastHorizon }).(pulumi.StringOutput)
}

type ForecastOptionsPtrOutput struct{ *pulumi.OutputState }

func (ForecastOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ForecastOptions)(nil)).Elem()
}

func (o ForecastOptionsPtrOutput) ToForecastOptionsPtrOutput() ForecastOptionsPtrOutput {
	return o
}

func (o ForecastOptionsPtrOutput) ToForecastOptionsPtrOutputWithContext(ctx context.Context) ForecastOptionsPtrOutput {
	return o
}

func (o ForecastOptionsPtrOutput) Elem() ForecastOptionsOutput {
	return o.ApplyT(func(v *ForecastOptions) ForecastOptions {
		if v != nil {
			return *v
		}
		var ret ForecastOptions
		return ret
	}).(ForecastOptionsOutput)
}

// The length of time into the future to forecast whether a time series will violate the threshold. If the predicted value is found to violate the threshold, and the violation is observed in all forecasts made for the configured duration, then the time series is considered to be failing. The forecast horizon can range from 1 hour to 60 hours.
func (o ForecastOptionsPtrOutput) ForecastHorizon() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ForecastOptions) *string {
		if v == nil {
			return nil
		}
		return &v.ForecastHorizon
	}).(pulumi.StringPtrOutput)
}

// Options used when forecasting the time series and testing the predicted value against the threshold.
type ForecastOptionsResponse struct {
	// The length of time into the future to forecast whether a time series will violate the threshold. If the predicted value is found to violate the threshold, and the violation is observed in all forecasts made for the configured duration, then the time series is considered to be failing. The forecast horizon can range from 1 hour to 60 hours.
	ForecastHorizon string `pulumi:"forecastHorizon"`
}

// Options used when forecasting the time series and testing the predicted value against the threshold.
type ForecastOptionsResponseOutput struct{ *pulumi.OutputState }

func (ForecastOptionsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ForecastOptionsResponse)(nil)).Elem()
}

func (o ForecastOptionsResponseOutput) ToForecastOptionsResponseOutput() ForecastOptionsResponseOutput {
	return o
}

func (o ForecastOptionsResponseOutput) ToForecastOptionsResponseOutputWithContext(ctx context.Context) ForecastOptionsResponseOutput {
	return o
}

// The length of time into the future to forecast whether a time series will violate the threshold. If the predicted value is found to violate the threshold, and the violation is observed in all forecasts made for the configured duration, then the time series is considered to be failing. The forecast horizon can range from 1 hour to 60 hours.
func (o ForecastOptionsResponseOutput) ForecastHorizon() pulumi.StringOutput {
	return o.ApplyT(func(v ForecastOptionsResponse) string { return v.ForecastHorizon }).(pulumi.StringOutput)
}

// GKE Namespace. The field names correspond to the resource metadata labels on monitored resources that fall under a namespace (for example, k8s_container or k8s_pod).
type GkeNamespace struct {
	// The name of the parent cluster.
	ClusterName *string `pulumi:"clusterName"`
	// The location of the parent cluster. This may be a zone or region.
	Location *string `pulumi:"location"`
	// The name of this namespace.
	NamespaceName *string `pulumi:"namespaceName"`
}

// GkeNamespaceInput is an input type that accepts GkeNamespaceArgs and GkeNamespaceOutput values.
// You can construct a concrete instance of `GkeNamespaceInput` via:
//
//	GkeNamespaceArgs{...}
type GkeNamespaceInput interface {
	pulumi.Input

	ToGkeNamespaceOutput() GkeNamespaceOutput
	ToGkeNamespaceOutputWithContext(context.Context) GkeNamespaceOutput
}

// GKE Namespace. The field names correspond to the resource metadata labels on monitored resources that fall under a namespace (for example, k8s_container or k8s_pod).
type GkeNamespaceArgs struct {
	// The name of the parent cluster.
	ClusterName pulumi.StringPtrInput `pulumi:"clusterName"`
	// The location of the parent cluster. This may be a zone or region.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// The name of this namespace.
	NamespaceName pulumi.StringPtrInput `pulumi:"namespaceName"`
}

func (GkeNamespaceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GkeNamespace)(nil)).Elem()
}

func (i GkeNamespaceArgs) ToGkeNamespaceOutput() GkeNamespaceOutput {
	return i.ToGkeNamespaceOutputWithContext(context.Background())
}

func (i GkeNamespaceArgs) ToGkeNamespaceOutputWithContext(ctx context.Context) GkeNamespaceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GkeNamespaceOutput)
}

func (i GkeNamespaceArgs) ToGkeNamespacePtrOutput() GkeNamespacePtrOutput {
	return i.ToGkeNamespacePtrOutputWithContext(context.Background())
}

func (i GkeNamespaceArgs) ToGkeNamespacePtrOutputWithContext(ctx context.Context) GkeNamespacePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GkeNamespaceOutput).ToGkeNamespacePtrOutputWithContext(ctx)
}

// GkeNamespacePtrInput is an input type that accepts GkeNamespaceArgs, GkeNamespacePtr and GkeNamespacePtrOutput values.
// You can construct a concrete instance of `GkeNamespacePtrInput` via:
//
//	        GkeNamespaceArgs{...}
//
//	or:
//
//	        nil
type GkeNamespacePtrInput interface {
	pulumi.Input

	ToGkeNamespacePtrOutput() GkeNamespacePtrOutput
	ToGkeNamespacePtrOutputWithContext(context.Context) GkeNamespacePtrOutput
}

type gkeNamespacePtrType GkeNamespaceArgs

func GkeNamespacePtr(v *GkeNamespaceArgs) GkeNamespacePtrInput {
	return (*gkeNamespacePtrType)(v)
}

func (*gkeNamespacePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GkeNamespace)(nil)).Elem()
}

func (i *gkeNamespacePtrType) ToGkeNamespacePtrOutput() GkeNamespacePtrOutput {
	return i.ToGkeNamespacePtrOutputWithContext(context.Background())
}

func (i *gkeNamespacePtrType) ToGkeNamespacePtrOutputWithContext(ctx context.Context) GkeNamespacePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GkeNamespacePtrOutput)
}

// GKE Namespace. The field names correspond to the resource metadata labels on monitored resources that fall under a namespace (for example, k8s_container or k8s_pod).
type GkeNamespaceOutput struct{ *pulumi.OutputState }

func (GkeNamespaceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GkeNamespace)(nil)).Elem()
}

func (o GkeNamespaceOutput) ToGkeNamespaceOutput() GkeNamespaceOutput {
	return o
}

func (o GkeNamespaceOutput) ToGkeNamespaceOutputWithContext(ctx context.Context) GkeNamespaceOutput {
	return o
}

func (o GkeNamespaceOutput) ToGkeNamespacePtrOutput() GkeNamespacePtrOutput {
	return o.ToGkeNamespacePtrOutputWithContext(context.Background())
}

func (o GkeNamespaceOutput) ToGkeNamespacePtrOutputWithContext(ctx context.Context) GkeNamespacePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GkeNamespace) *GkeNamespace {
		return &v
	}).(GkeNamespacePtrOutput)
}

// The name of the parent cluster.
func (o GkeNamespaceOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GkeNamespace) *string { return v.ClusterName }).(pulumi.StringPtrOutput)
}

// The location of the parent cluster. This may be a zone or region.
func (o GkeNamespaceOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GkeNamespace) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// The name of this namespace.
func (o GkeNamespaceOutput) NamespaceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GkeNamespace) *string { return v.NamespaceName }).(pulumi.StringPtrOutput)
}

type GkeNamespacePtrOutput struct{ *pulumi.OutputState }

func (GkeNamespacePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GkeNamespace)(nil)).Elem()
}

func (o GkeNamespacePtrOutput) ToGkeNamespacePtrOutput() GkeNamespacePtrOutput {
	return o
}

func (o GkeNamespacePtrOutput) ToGkeNamespacePtrOutputWithContext(ctx context.Context) GkeNamespacePtrOutput {
	return o
}

func (o GkeNamespacePtrOutput) Elem() GkeNamespaceOutput {
	return o.ApplyT(func(v *GkeNamespace) GkeNamespace {
		if v != nil {
			return *v
		}
		var ret GkeNamespace
		return ret
	}).(GkeNamespaceOutput)
}

// The name of the parent cluster.
func (o GkeNamespacePtrOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GkeNamespace) *string {
		if v == nil {
			return nil
		}
		return v.ClusterName
	}).(pulumi.StringPtrOutput)
}

// The location of the parent cluster. This may be a zone or region.
func (o GkeNamespacePtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GkeNamespace) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// The name of this namespace.
func (o GkeNamespacePtrOutput) NamespaceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GkeNamespace) *string {
		if v == nil {
			return nil
		}
		return v.NamespaceName
	}).(pulumi.StringPtrOutput)
}

// GKE Namespace. The field names correspond to the resource metadata labels on monitored resources that fall under a namespace (for example, k8s_container or k8s_pod).
type GkeNamespaceResponse struct {
	// The name of the parent cluster.
	ClusterName string `pulumi:"clusterName"`
	// The location of the parent cluster. This may be a zone or region.
	Location string `pulumi:"location"`
	// The name of this namespace.
	NamespaceName string `pulumi:"namespaceName"`
	// The project this resource lives in. For legacy services migrated from the Custom type, this may be a distinct project from the one parenting the service itself.
	Project string `pulumi:"project"`
}

// GKE Namespace. The field names correspond to the resource metadata labels on monitored resources that fall under a namespace (for example, k8s_container or k8s_pod).
type GkeNamespaceResponseOutput struct{ *pulumi.OutputState }

func (GkeNamespaceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GkeNamespaceResponse)(nil)).Elem()
}

func (o GkeNamespaceResponseOutput) ToGkeNamespaceResponseOutput() GkeNamespaceResponseOutput {
	return o
}

func (o GkeNamespaceResponseOutput) ToGkeNamespaceResponseOutputWithContext(ctx context.Context) GkeNamespaceResponseOutput {
	return o
}

// The name of the parent cluster.
func (o GkeNamespaceResponseOutput) ClusterName() pulumi.StringOutput {
	return o.ApplyT(func(v GkeNamespaceResponse) string { return v.ClusterName }).(pulumi.StringOutput)
}

// The location of the parent cluster. This may be a zone or region.
func (o GkeNamespaceResponseOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v GkeNamespaceResponse) string { return v.Location }).(pulumi.StringOutput)
}

// The name of this namespace.
func (o GkeNamespaceResponseOutput) NamespaceName() pulumi.StringOutput {
	return o.ApplyT(func(v GkeNamespaceResponse) string { return v.NamespaceName }).(pulumi.StringOutput)
}

// The project this resource lives in. For legacy services migrated from the Custom type, this may be a distinct project from the one parenting the service itself.
func (o GkeNamespaceResponseOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v GkeNamespaceResponse) string { return v.Project }).(pulumi.StringOutput)
}

// GKE Service. The "service" here represents a Kubernetes service object (https://kubernetes.io/docs/concepts/services-networking/service). The field names correspond to the resource labels on k8s_service monitored resources (https://cloud.google.com/monitoring/api/resources#tag_k8s_service).
type GkeService struct {
	// The name of the parent cluster.
	ClusterName *string `pulumi:"clusterName"`
	// The location of the parent cluster. This may be a zone or region.
	Location *string `pulumi:"location"`
	// The name of the parent namespace.
	NamespaceName *string `pulumi:"namespaceName"`
	// The name of this service.
	ServiceName *string `pulumi:"serviceName"`
}

// GkeServiceInput is an input type that accepts GkeServiceArgs and GkeServiceOutput values.
// You can construct a concrete instance of `GkeServiceInput` via:
//
//	GkeServiceArgs{...}
type GkeServiceInput interface {
	pulumi.Input

	ToGkeServiceOutput() GkeServiceOutput
	ToGkeServiceOutputWithContext(context.Context) GkeServiceOutput
}

// GKE Service. The "service" here represents a Kubernetes service object (https://kubernetes.io/docs/concepts/services-networking/service). The field names correspond to the resource labels on k8s_service monitored resources (https://cloud.google.com/monitoring/api/resources#tag_k8s_service).
type GkeServiceArgs struct {
	// The name of the parent cluster.
	ClusterName pulumi.StringPtrInput `pulumi:"clusterName"`
	// The location of the parent cluster. This may be a zone or region.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// The name of the parent namespace.
	NamespaceName pulumi.StringPtrInput `pulumi:"namespaceName"`
	// The name of this service.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (GkeServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GkeService)(nil)).Elem()
}

func (i GkeServiceArgs) ToGkeServiceOutput() GkeServiceOutput {
	return i.ToGkeServiceOutputWithContext(context.Background())
}

func (i GkeServiceArgs) ToGkeServiceOutputWithContext(ctx context.Context) GkeServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GkeServiceOutput)
}

func (i GkeServiceArgs) ToGkeServicePtrOutput() GkeServicePtrOutput {
	return i.ToGkeServicePtrOutputWithContext(context.Background())
}

func (i GkeServiceArgs) ToGkeServicePtrOutputWithContext(ctx context.Context) GkeServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GkeServiceOutput).ToGkeServicePtrOutputWithContext(ctx)
}

// GkeServicePtrInput is an input type that accepts GkeServiceArgs, GkeServicePtr and GkeServicePtrOutput values.
// You can construct a concrete instance of `GkeServicePtrInput` via:
//
//	        GkeServiceArgs{...}
//
//	or:
//
//	        nil
type GkeServicePtrInput interface {
	pulumi.Input

	ToGkeServicePtrOutput() GkeServicePtrOutput
	ToGkeServicePtrOutputWithContext(context.Context) GkeServicePtrOutput
}

type gkeServicePtrType GkeServiceArgs

func GkeServicePtr(v *GkeServiceArgs) GkeServicePtrInput {
	return (*gkeServicePtrType)(v)
}

func (*gkeServicePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GkeService)(nil)).Elem()
}

func (i *gkeServicePtrType) ToGkeServicePtrOutput() GkeServicePtrOutput {
	return i.ToGkeServicePtrOutputWithContext(context.Background())
}

func (i *gkeServicePtrType) ToGkeServicePtrOutputWithContext(ctx context.Context) GkeServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GkeServicePtrOutput)
}

// GKE Service. The "service" here represents a Kubernetes service object (https://kubernetes.io/docs/concepts/services-networking/service). The field names correspond to the resource labels on k8s_service monitored resources (https://cloud.google.com/monitoring/api/resources#tag_k8s_service).
type GkeServiceOutput struct{ *pulumi.OutputState }

func (GkeServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GkeService)(nil)).Elem()
}

func (o GkeServiceOutput) ToGkeServiceOutput() GkeServiceOutput {
	return o
}

func (o GkeServiceOutput) ToGkeServiceOutputWithContext(ctx context.Context) GkeServiceOutput {
	return o
}

func (o GkeServiceOutput) ToGkeServicePtrOutput() GkeServicePtrOutput {
	return o.ToGkeServicePtrOutputWithContext(context.Background())
}

func (o GkeServiceOutput) ToGkeServicePtrOutputWithContext(ctx context.Context) GkeServicePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GkeService) *GkeService {
		return &v
	}).(GkeServicePtrOutput)
}

// The name of the parent cluster.
func (o GkeServiceOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GkeService) *string { return v.ClusterName }).(pulumi.StringPtrOutput)
}

// The location of the parent cluster. This may be a zone or region.
func (o GkeServiceOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GkeService) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// The name of the parent namespace.
func (o GkeServiceOutput) NamespaceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GkeService) *string { return v.NamespaceName }).(pulumi.StringPtrOutput)
}

// The name of this service.
func (o GkeServiceOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GkeService) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type GkeServicePtrOutput struct{ *pulumi.OutputState }

func (GkeServicePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GkeService)(nil)).Elem()
}

func (o GkeServicePtrOutput) ToGkeServicePtrOutput() GkeServicePtrOutput {
	return o
}

func (o GkeServicePtrOutput) ToGkeServicePtrOutputWithContext(ctx context.Context) GkeServicePtrOutput {
	return o
}

func (o GkeServicePtrOutput) Elem() GkeServiceOutput {
	return o.ApplyT(func(v *GkeService) GkeService {
		if v != nil {
			return *v
		}
		var ret GkeService
		return ret
	}).(GkeServiceOutput)
}

// The name of the parent cluster.
func (o GkeServicePtrOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GkeService) *string {
		if v == nil {
			return nil
		}
		return v.ClusterName
	}).(pulumi.StringPtrOutput)
}

// The location of the parent cluster. This may be a zone or region.
func (o GkeServicePtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GkeService) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// The name of the parent namespace.
func (o GkeServicePtrOutput) NamespaceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GkeService) *string {
		if v == nil {
			return nil
		}
		return v.NamespaceName
	}).(pulumi.StringPtrOutput)
}

// The name of this service.
func (o GkeServicePtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GkeService) *string {
		if v == nil {
			return nil
		}
		return v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// GKE Service. The "service" here represents a Kubernetes service object (https://kubernetes.io/docs/concepts/services-networking/service). The field names correspond to the resource labels on k8s_service monitored resources (https://cloud.google.com/monitoring/api/resources#tag_k8s_service).
type GkeServiceResponse struct {
	// The name of the parent cluster.
	ClusterName string `pulumi:"clusterName"`
	// The location of the parent cluster. This may be a zone or region.
	Location string `pulumi:"location"`
	// The name of the parent namespace.
	NamespaceName string `pulumi:"namespaceName"`
	// The project this resource lives in. For legacy services migrated from the Custom type, this may be a distinct project from the one parenting the service itself.
	Project string `pulumi:"project"`
	// The name of this service.
	ServiceName string `pulumi:"serviceName"`
}

// GKE Service. The "service" here represents a Kubernetes service object (https://kubernetes.io/docs/concepts/services-networking/service). The field names correspond to the resource labels on k8s_service monitored resources (https://cloud.google.com/monitoring/api/resources#tag_k8s_service).
type GkeServiceResponseOutput struct{ *pulumi.OutputState }

func (GkeServiceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GkeServiceResponse)(nil)).Elem()
}

func (o GkeServiceResponseOutput) ToGkeServiceResponseOutput() GkeServiceResponseOutput {
	return o
}

func (o GkeServiceResponseOutput) ToGkeServiceResponseOutputWithContext(ctx context.Context) GkeServiceResponseOutput {
	return o
}

// The name of the parent cluster.
func (o GkeServiceResponseOutput) ClusterName() pulumi.StringOutput {
	return o.ApplyT(func(v GkeServiceResponse) string { return v.ClusterName }).(pulumi.StringOutput)
}

// The location of the parent cluster. This may be a zone or region.
func (o GkeServiceResponseOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v GkeServiceResponse) string { return v.Location }).(pulumi.StringOutput)
}

// The name of the parent namespace.
func (o GkeServiceResponseOutput) NamespaceName() pulumi.StringOutput {
	return o.ApplyT(func(v GkeServiceResponse) string { return v.NamespaceName }).(pulumi.StringOutput)
}

// The project this resource lives in. For legacy services migrated from the Custom type, this may be a distinct project from the one parenting the service itself.
func (o GkeServiceResponseOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v GkeServiceResponse) string { return v.Project }).(pulumi.StringOutput)
}

// The name of this service.
func (o GkeServiceResponseOutput) ServiceName() pulumi.StringOutput {
	return o.ApplyT(func(v GkeServiceResponse) string { return v.ServiceName }).(pulumi.StringOutput)
}

// A GKE Workload (Deployment, StatefulSet, etc). The field names correspond to the metadata labels on monitored resources that fall under a workload (for example, k8s_container or k8s_pod).
type GkeWorkload struct {
	// The name of the parent cluster.
	ClusterName *string `pulumi:"clusterName"`
	// The location of the parent cluster. This may be a zone or region.
	Location *string `pulumi:"location"`
	// The name of the parent namespace.
	NamespaceName *string `pulumi:"namespaceName"`
	// The name of this workload.
	TopLevelControllerName *string `pulumi:"topLevelControllerName"`
	// The type of this workload (for example, "Deployment" or "DaemonSet")
	TopLevelControllerType *string `pulumi:"topLevelControllerType"`
}

// GkeWorkloadInput is an input type that accepts GkeWorkloadArgs and GkeWorkloadOutput values.
// You can construct a concrete instance of `GkeWorkloadInput` via:
//
//	GkeWorkloadArgs{...}
type GkeWorkloadInput interface {
	pulumi.Input

	ToGkeWorkloadOutput() GkeWorkloadOutput
	ToGkeWorkloadOutputWithContext(context.Context) GkeWorkloadOutput
}

// A GKE Workload (Deployment, StatefulSet, etc). The field names correspond to the metadata labels on monitored resources that fall under a workload (for example, k8s_container or k8s_pod).
type GkeWorkloadArgs struct {
	// The name of the parent cluster.
	ClusterName pulumi.StringPtrInput `pulumi:"clusterName"`
	// The location of the parent cluster. This may be a zone or region.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// The name of the parent namespace.
	NamespaceName pulumi.StringPtrInput `pulumi:"namespaceName"`
	// The name of this workload.
	TopLevelControllerName pulumi.StringPtrInput `pulumi:"topLevelControllerName"`
	// The type of this workload (for example, "Deployment" or "DaemonSet")
	TopLevelControllerType pulumi.StringPtrInput `pulumi:"topLevelControllerType"`
}

func (GkeWorkloadArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GkeWorkload)(nil)).Elem()
}

func (i GkeWorkloadArgs) ToGkeWorkloadOutput() GkeWorkloadOutput {
	return i.ToGkeWorkloadOutputWithContext(context.Background())
}

func (i GkeWorkloadArgs) ToGkeWorkloadOutputWithContext(ctx context.Context) GkeWorkloadOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GkeWorkloadOutput)
}

func (i GkeWorkloadArgs) ToGkeWorkloadPtrOutput() GkeWorkloadPtrOutput {
	return i.ToGkeWorkloadPtrOutputWithContext(context.Background())
}

func (i GkeWorkloadArgs) ToGkeWorkloadPtrOutputWithContext(ctx context.Context) GkeWorkloadPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GkeWorkloadOutput).ToGkeWorkloadPtrOutputWithContext(ctx)
}

// GkeWorkloadPtrInput is an input type that accepts GkeWorkloadArgs, GkeWorkloadPtr and GkeWorkloadPtrOutput values.
// You can construct a concrete instance of `GkeWorkloadPtrInput` via:
//
//	        GkeWorkloadArgs{...}
//
//	or:
//
//	        nil
type GkeWorkloadPtrInput interface {
	pulumi.Input

	ToGkeWorkloadPtrOutput() GkeWorkloadPtrOutput
	ToGkeWorkloadPtrOutputWithContext(context.Context) GkeWorkloadPtrOutput
}

type gkeWorkloadPtrType GkeWorkloadArgs

func GkeWorkloadPtr(v *GkeWorkloadArgs) GkeWorkloadPtrInput {
	return (*gkeWorkloadPtrType)(v)
}

func (*gkeWorkloadPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GkeWorkload)(nil)).Elem()
}

func (i *gkeWorkloadPtrType) ToGkeWorkloadPtrOutput() GkeWorkloadPtrOutput {
	return i.ToGkeWorkloadPtrOutputWithContext(context.Background())
}

func (i *gkeWorkloadPtrType) ToGkeWorkloadPtrOutputWithContext(ctx context.Context) GkeWorkloadPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GkeWorkloadPtrOutput)
}

// A GKE Workload (Deployment, StatefulSet, etc). The field names correspond to the metadata labels on monitored resources that fall under a workload (for example, k8s_container or k8s_pod).
type GkeWorkloadOutput struct{ *pulumi.OutputState }

func (GkeWorkloadOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GkeWorkload)(nil)).Elem()
}

func (o GkeWorkloadOutput) ToGkeWorkloadOutput() GkeWorkloadOutput {
	return o
}

func (o GkeWorkloadOutput) ToGkeWorkloadOutputWithContext(ctx context.Context) GkeWorkloadOutput {
	return o
}

func (o GkeWorkloadOutput) ToGkeWorkloadPtrOutput() GkeWorkloadPtrOutput {
	return o.ToGkeWorkloadPtrOutputWithContext(context.Background())
}

func (o GkeWorkloadOutput) ToGkeWorkloadPtrOutputWithContext(ctx context.Context) GkeWorkloadPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GkeWorkload) *GkeWorkload {
		return &v
	}).(GkeWorkloadPtrOutput)
}

// The name of the parent cluster.
func (o GkeWorkloadOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GkeWorkload) *string { return v.ClusterName }).(pulumi.StringPtrOutput)
}

// The location of the parent cluster. This may be a zone or region.
func (o GkeWorkloadOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GkeWorkload) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// The name of the parent namespace.
func (o GkeWorkloadOutput) NamespaceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GkeWorkload) *string { return v.NamespaceName }).(pulumi.StringPtrOutput)
}

// The name of this workload.
func (o GkeWorkloadOutput) TopLevelControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GkeWorkload) *string { return v.TopLevelControllerName }).(pulumi.StringPtrOutput)
}

// The type of this workload (for example, "Deployment" or "DaemonSet")
func (o GkeWorkloadOutput) TopLevelControllerType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GkeWorkload) *string { return v.TopLevelControllerType }).(pulumi.StringPtrOutput)
}

type GkeWorkloadPtrOutput struct{ *pulumi.OutputState }

func (GkeWorkloadPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GkeWorkload)(nil)).Elem()
}

func (o GkeWorkloadPtrOutput) ToGkeWorkloadPtrOutput() GkeWorkloadPtrOutput {
	return o
}

func (o GkeWorkloadPtrOutput) ToGkeWorkloadPtrOutputWithContext(ctx context.Context) GkeWorkloadPtrOutput {
	return o
}

func (o GkeWorkloadPtrOutput) Elem() GkeWorkloadOutput {
	return o.ApplyT(func(v *GkeWorkload) GkeWorkload {
		if v != nil {
			return *v
		}
		var ret GkeWorkload
		return ret
	}).(GkeWorkloadOutput)
}

// The name of the parent cluster.
func (o GkeWorkloadPtrOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GkeWorkload) *string {
		if v == nil {
			return nil
		}
		return v.ClusterName
	}).(pulumi.StringPtrOutput)
}

// The location of the parent cluster. This may be a zone or region.
func (o GkeWorkloadPtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GkeWorkload) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// The name of the parent namespace.
func (o GkeWorkloadPtrOutput) NamespaceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GkeWorkload) *string {
		if v == nil {
			return nil
		}
		return v.NamespaceName
	}).(pulumi.StringPtrOutput)
}

// The name of this workload.
func (o GkeWorkloadPtrOutput) TopLevelControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GkeWorkload) *string {
		if v == nil {
			return nil
		}
		return v.TopLevelControllerName
	}).(pulumi.StringPtrOutput)
}

// The type of this workload (for example, "Deployment" or "DaemonSet")
func (o GkeWorkloadPtrOutput) TopLevelControllerType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GkeWorkload) *string {
		if v == nil {
			return nil
		}
		return v.TopLevelControllerType
	}).(pulumi.StringPtrOutput)
}

// A GKE Workload (Deployment, StatefulSet, etc). The field names correspond to the metadata labels on monitored resources that fall under a workload (for example, k8s_container or k8s_pod).
type GkeWorkloadResponse struct {
	// The name of the parent cluster.
	ClusterName string `pulumi:"clusterName"`
	// The location of the parent cluster. This may be a zone or region.
	Location string `pulumi:"location"`
	// The name of the parent namespace.
	NamespaceName string `pulumi:"namespaceName"`
	// The project this resource lives in. For legacy services migrated from the Custom type, this may be a distinct project from the one parenting the service itself.
	Project string `pulumi:"project"`
	// The name of this workload.
	TopLevelControllerName string `pulumi:"topLevelControllerName"`
	// The type of this workload (for example, "Deployment" or "DaemonSet")
	TopLevelControllerType string `pulumi:"topLevelControllerType"`
}

// A GKE Workload (Deployment, StatefulSet, etc). The field names correspond to the metadata labels on monitored resources that fall under a workload (for example, k8s_container or k8s_pod).
type GkeWorkloadResponseOutput struct{ *pulumi.OutputState }

func (GkeWorkloadResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GkeWorkloadResponse)(nil)).Elem()
}

func (o GkeWorkloadResponseOutput) ToGkeWorkloadResponseOutput() GkeWorkloadResponseOutput {
	return o
}

func (o GkeWorkloadResponseOutput) ToGkeWorkloadResponseOutputWithContext(ctx context.Context) GkeWorkloadResponseOutput {
	return o
}

// The name of the parent cluster.
func (o GkeWorkloadResponseOutput) ClusterName() pulumi.StringOutput {
	return o.ApplyT(func(v GkeWorkloadResponse) string { return v.ClusterName }).(pulumi.StringOutput)
}

// The location of the parent cluster. This may be a zone or region.
func (o GkeWorkloadResponseOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v GkeWorkloadResponse) string { return v.Location }).(pulumi.StringOutput)
}

// The name of the parent namespace.
func (o GkeWorkloadResponseOutput) NamespaceName() pulumi.StringOutput {
	return o.ApplyT(func(v GkeWorkloadResponse) string { return v.NamespaceName }).(pulumi.StringOutput)
}

// The project this resource lives in. For legacy services migrated from the Custom type, this may be a distinct project from the one parenting the service itself.
func (o GkeWorkloadResponseOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v GkeWorkloadResponse) string { return v.Project }).(pulumi.StringOutput)
}

// The name of this workload.
func (o GkeWorkloadResponseOutput) TopLevelControllerName() pulumi.StringOutput {
	return o.ApplyT(func(v GkeWorkloadResponse) string { return v.TopLevelControllerName }).(pulumi.StringOutput)
}

// The type of this workload (for example, "Deployment" or "DaemonSet")
func (o GkeWorkloadResponseOutput) TopLevelControllerType() pulumi.StringOutput {
	return o.ApplyT(func(v GkeWorkloadResponse) string { return v.TopLevelControllerType }).(pulumi.StringOutput)
}

// Range of numerical values within min and max.
type GoogleMonitoringV3Range struct {
	// Range maximum.
	Max *float64 `pulumi:"max"`
	// Range minimum.
	Min *float64 `pulumi:"min"`
}

// GoogleMonitoringV3RangeInput is an input type that accepts GoogleMonitoringV3RangeArgs and GoogleMonitoringV3RangeOutput values.
// You can construct a concrete instance of `GoogleMonitoringV3RangeInput` via:
//
//	GoogleMonitoringV3RangeArgs{...}
type GoogleMonitoringV3RangeInput interface {
	pulumi.Input

	ToGoogleMonitoringV3RangeOutput() GoogleMonitoringV3RangeOutput
	ToGoogleMonitoringV3RangeOutputWithContext(context.Context) GoogleMonitoringV3RangeOutput
}

// Range of numerical values within min and max.
type GoogleMonitoringV3RangeArgs struct {
	// Range maximum.
	Max pulumi.Float64PtrInput `pulumi:"max"`
	// Range minimum.
	Min pulumi.Float64PtrInput `pulumi:"min"`
}

func (GoogleMonitoringV3RangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleMonitoringV3Range)(nil)).Elem()
}

func (i GoogleMonitoringV3RangeArgs) ToGoogleMonitoringV3RangeOutput() GoogleMonitoringV3RangeOutput {
	return i.ToGoogleMonitoringV3RangeOutputWithContext(context.Background())
}

func (i GoogleMonitoringV3RangeArgs) ToGoogleMonitoringV3RangeOutputWithContext(ctx context.Context) GoogleMonitoringV3RangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleMonitoringV3RangeOutput)
}

func (i GoogleMonitoringV3RangeArgs) ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput {
	return i.ToGoogleMonitoringV3RangePtrOutputWithContext(context.Background())
}

func (i GoogleMonitoringV3RangeArgs) ToGoogleMonitoringV3RangePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleMonitoringV3RangeOutput).ToGoogleMonitoringV3RangePtrOutputWithContext(ctx)
}

// GoogleMonitoringV3RangePtrInput is an input type that accepts GoogleMonitoringV3RangeArgs, GoogleMonitoringV3RangePtr and GoogleMonitoringV3RangePtrOutput values.
// You can construct a concrete instance of `GoogleMonitoringV3RangePtrInput` via:
//
//	        GoogleMonitoringV3RangeArgs{...}
//
//	or:
//
//	        nil
type GoogleMonitoringV3RangePtrInput interface {
	pulumi.Input

	ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput
	ToGoogleMonitoringV3RangePtrOutputWithContext(context.Context) GoogleMonitoringV3RangePtrOutput
}

type googleMonitoringV3RangePtrType GoogleMonitoringV3RangeArgs

func GoogleMonitoringV3RangePtr(v *GoogleMonitoringV3RangeArgs) GoogleMonitoringV3RangePtrInput {
	return (*googleMonitoringV3RangePtrType)(v)
}

func (*googleMonitoringV3RangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleMonitoringV3Range)(nil)).Elem()
}

func (i *googleMonitoringV3RangePtrType) ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput {
	return i.ToGoogleMonitoringV3RangePtrOutputWithContext(context.Background())
}

func (i *googleMonitoringV3RangePtrType) ToGoogleMonitoringV3RangePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleMonitoringV3RangePtrOutput)
}

// Range of numerical values within min and max.
type GoogleMonitoringV3RangeOutput struct{ *pulumi.OutputState }

func (GoogleMonitoringV3RangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleMonitoringV3Range)(nil)).Elem()
}

func (o GoogleMonitoringV3RangeOutput) ToGoogleMonitoringV3RangeOutput() GoogleMonitoringV3RangeOutput {
	return o
}

func (o GoogleMonitoringV3RangeOutput) ToGoogleMonitoringV3RangeOutputWithContext(ctx context.Context) GoogleMonitoringV3RangeOutput {
	return o
}

func (o GoogleMonitoringV3RangeOutput) ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput {
	return o.ToGoogleMonitoringV3RangePtrOutputWithContext(context.Background())
}

func (o GoogleMonitoringV3RangeOutput) ToGoogleMonitoringV3RangePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GoogleMonitoringV3Range) *GoogleMonitoringV3Range {
		return &v
	}).(GoogleMonitoringV3RangePtrOutput)
}

// Range maximum.
func (o GoogleMonitoringV3RangeOutput) Max() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v GoogleMonitoringV3Range) *float64 { return v.Max }).(pulumi.Float64PtrOutput)
}

// Range minimum.
func (o GoogleMonitoringV3RangeOutput) Min() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v GoogleMonitoringV3Range) *float64 { return v.Min }).(pulumi.Float64PtrOutput)
}

type GoogleMonitoringV3RangePtrOutput struct{ *pulumi.OutputState }

func (GoogleMonitoringV3RangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleMonitoringV3Range)(nil)).Elem()
}

func (o GoogleMonitoringV3RangePtrOutput) ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput {
	return o
}

func (o GoogleMonitoringV3RangePtrOutput) ToGoogleMonitoringV3RangePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangePtrOutput {
	return o
}

func (o GoogleMonitoringV3RangePtrOutput) Elem() GoogleMonitoringV3RangeOutput {
	return o.ApplyT(func(v *GoogleMonitoringV3Range) GoogleMonitoringV3Range {
		if v != nil {
			return *v
		}
		var ret GoogleMonitoringV3Range
		return ret
	}).(GoogleMonitoringV3RangeOutput)
}

// Range maximum.
func (o GoogleMonitoringV3RangePtrOutput) Max() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GoogleMonitoringV3Range) *float64 {
		if v == nil {
			return nil
		}
		return v.Max
	}).(pulumi.Float64PtrOutput)
}

// Range minimum.
func (o GoogleMonitoringV3RangePtrOutput) Min() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GoogleMonitoringV3Range) *float64 {
		if v == nil {
			return nil
		}
		return v.Min
	}).(pulumi.Float64PtrOutput)
}

// Range of numerical values within min and max.
type GoogleMonitoringV3RangeResponse struct {
	// Range maximum.
	Max float64 `pulumi:"max"`
	// Range minimum.
	Min float64 `pulumi:"min"`
}

// Range of numerical values within min and max.
type GoogleMonitoringV3RangeResponseOutput struct{ *pulumi.OutputState }

func (GoogleMonitoringV3RangeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleMonitoringV3RangeResponse)(nil)).Elem()
}

func (o GoogleMonitoringV3RangeResponseOutput) ToGoogleMonitoringV3RangeResponseOutput() GoogleMonitoringV3RangeResponseOutput {
	return o
}

func (o GoogleMonitoringV3RangeResponseOutput) ToGoogleMonitoringV3RangeResponseOutputWithContext(ctx context.Context) GoogleMonitoringV3RangeResponseOutput {
	return o
}

// Range maximum.
func (o GoogleMonitoringV3RangeResponseOutput) Max() pulumi.Float64Output {
	return o.ApplyT(func(v GoogleMonitoringV3RangeResponse) float64 { return v.Max }).(pulumi.Float64Output)
}

// Range minimum.
func (o GoogleMonitoringV3RangeResponseOutput) Min() pulumi.Float64Output {
	return o.ApplyT(func(v GoogleMonitoringV3RangeResponse) float64 { return v.Min }).(pulumi.Float64Output)
}

// Information involved in an HTTP/HTTPS Uptime check request.
type HttpCheck struct {
	// If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299.
	AcceptedResponseStatusCodes []ResponseStatusCode `pulumi:"acceptedResponseStatusCodes"`
	// The authentication information. Optional when creating an HTTP check; defaults to empty.
	AuthInfo *BasicAuthentication `pulumi:"authInfo"`
	// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte.Note: If client libraries aren't used (which performs the conversion automatically) base64 encode your body data since the field is of bytes type.
	Body *string `pulumi:"body"`
	// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
	ContentType *HttpCheckContentType `pulumi:"contentType"`
	// A user provided content type header to use for the check. The invalid configurations outlined in the content_type field apply to custom_content_type, as well as the following: 1. content_type is URL_ENCODED and custom_content_type is set. 2. content_type is USER_PROVIDED and custom_content_type is not set.
	CustomContentType *string `pulumi:"customContentType"`
	// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
	Headers map[string]string `pulumi:"headers"`
	// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
	MaskHeaders *bool `pulumi:"maskHeaders"`
	// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
	Path *string `pulumi:"path"`
	// Contains information needed to add pings to an HTTP check.
	PingConfig *PingConfig `pulumi:"pingConfig"`
	// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
	Port *int `pulumi:"port"`
	// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
	RequestMethod *HttpCheckRequestMethod `pulumi:"requestMethod"`
	// If true, use HTTPS instead of HTTP to run the check.
	UseSsl *bool `pulumi:"useSsl"`
	// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
	ValidateSsl *bool `pulumi:"validateSsl"`
}

// HttpCheckInput is an input type that accepts HttpCheckArgs and HttpCheckOutput values.
// You can construct a concrete instance of `HttpCheckInput` via:
//
//	HttpCheckArgs{...}
type HttpCheckInput interface {
	pulumi.Input

	ToHttpCheckOutput() HttpCheckOutput
	ToHttpCheckOutputWithContext(context.Context) HttpCheckOutput
}

// Information involved in an HTTP/HTTPS Uptime check request.
type HttpCheckArgs struct {
	// If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299.
	AcceptedResponseStatusCodes ResponseStatusCodeArrayInput `pulumi:"acceptedResponseStatusCodes"`
	// The authentication information. Optional when creating an HTTP check; defaults to empty.
	AuthInfo BasicAuthenticationPtrInput `pulumi:"authInfo"`
	// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte.Note: If client libraries aren't used (which performs the conversion automatically) base64 encode your body data since the field is of bytes type.
	Body pulumi.StringPtrInput `pulumi:"body"`
	// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
	ContentType HttpCheckContentTypePtrInput `pulumi:"contentType"`
	// A user provided content type header to use for the check. The invalid configurations outlined in the content_type field apply to custom_content_type, as well as the following: 1. content_type is URL_ENCODED and custom_content_type is set. 2. content_type is USER_PROVIDED and custom_content_type is not set.
	CustomContentType pulumi.StringPtrInput `pulumi:"customContentType"`
	// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
	Headers pulumi.StringMapInput `pulumi:"headers"`
	// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
	MaskHeaders pulumi.BoolPtrInput `pulumi:"maskHeaders"`
	// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
	Path pulumi.StringPtrInput `pulumi:"path"`
	// Contains information needed to add pings to an HTTP check.
	PingConfig PingConfigPtrInput `pulumi:"pingConfig"`
	// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
	RequestMethod HttpCheckRequestMethodPtrInput `pulumi:"requestMethod"`
	// If true, use HTTPS instead of HTTP to run the check.
	UseSsl pulumi.BoolPtrInput `pulumi:"useSsl"`
	// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
	ValidateSsl pulumi.BoolPtrInput `pulumi:"validateSsl"`
}

func (HttpCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HttpCheck)(nil)).Elem()
}

func (i HttpCheckArgs) ToHttpCheckOutput() HttpCheckOutput {
	return i.ToHttpCheckOutputWithContext(context.Background())
}

func (i HttpCheckArgs) ToHttpCheckOutputWithContext(ctx context.Context) HttpCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpCheckOutput)
}

func (i HttpCheckArgs) ToHttpCheckPtrOutput() HttpCheckPtrOutput {
	return i.ToHttpCheckPtrOutputWithContext(context.Background())
}

func (i HttpCheckArgs) ToHttpCheckPtrOutputWithContext(ctx context.Context) HttpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpCheckOutput).ToHttpCheckPtrOutputWithContext(ctx)
}

// HttpCheckPtrInput is an input type that accepts HttpCheckArgs, HttpCheckPtr and HttpCheckPtrOutput values.
// You can construct a concrete instance of `HttpCheckPtrInput` via:
//
//	        HttpCheckArgs{...}
//
//	or:
//
//	        nil
type HttpCheckPtrInput interface {
	pulumi.Input

	ToHttpCheckPtrOutput() HttpCheckPtrOutput
	ToHttpCheckPtrOutputWithContext(context.Context) HttpCheckPtrOutput
}

type httpCheckPtrType HttpCheckArgs

func HttpCheckPtr(v *HttpCheckArgs) HttpCheckPtrInput {
	return (*httpCheckPtrType)(v)
}

func (*httpCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HttpCheck)(nil)).Elem()
}

func (i *httpCheckPtrType) ToHttpCheckPtrOutput() HttpCheckPtrOutput {
	return i.ToHttpCheckPtrOutputWithContext(context.Background())
}

func (i *httpCheckPtrType) ToHttpCheckPtrOutputWithContext(ctx context.Context) HttpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpCheckPtrOutput)
}

// Information involved in an HTTP/HTTPS Uptime check request.
type HttpCheckOutput struct{ *pulumi.OutputState }

func (HttpCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HttpCheck)(nil)).Elem()
}

func (o HttpCheckOutput) ToHttpCheckOutput() HttpCheckOutput {
	return o
}

func (o HttpCheckOutput) ToHttpCheckOutputWithContext(ctx context.Context) HttpCheckOutput {
	return o
}

func (o HttpCheckOutput) ToHttpCheckPtrOutput() HttpCheckPtrOutput {
	return o.ToHttpCheckPtrOutputWithContext(context.Background())
}

func (o HttpCheckOutput) ToHttpCheckPtrOutputWithContext(ctx context.Context) HttpCheckPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HttpCheck) *HttpCheck {
		return &v
	}).(HttpCheckPtrOutput)
}

// If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299.
func (o HttpCheckOutput) AcceptedResponseStatusCodes() ResponseStatusCodeArrayOutput {
	return o.ApplyT(func(v HttpCheck) []ResponseStatusCode { return v.AcceptedResponseStatusCodes }).(ResponseStatusCodeArrayOutput)
}

// The authentication information. Optional when creating an HTTP check; defaults to empty.
func (o HttpCheckOutput) AuthInfo() BasicAuthenticationPtrOutput {
	return o.ApplyT(func(v HttpCheck) *BasicAuthentication { return v.AuthInfo }).(BasicAuthenticationPtrOutput)
}

// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte.Note: If client libraries aren't used (which performs the conversion automatically) base64 encode your body data since the field is of bytes type.
func (o HttpCheckOutput) Body() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HttpCheck) *string { return v.Body }).(pulumi.StringPtrOutput)
}

// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
func (o HttpCheckOutput) ContentType() HttpCheckContentTypePtrOutput {
	return o.ApplyT(func(v HttpCheck) *HttpCheckContentType { return v.ContentType }).(HttpCheckContentTypePtrOutput)
}

// A user provided content type header to use for the check. The invalid configurations outlined in the content_type field apply to custom_content_type, as well as the following: 1. content_type is URL_ENCODED and custom_content_type is set. 2. content_type is USER_PROVIDED and custom_content_type is not set.
func (o HttpCheckOutput) CustomContentType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HttpCheck) *string { return v.CustomContentType }).(pulumi.StringPtrOutput)
}

// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
func (o HttpCheckOutput) Headers() pulumi.StringMapOutput {
	return o.ApplyT(func(v HttpCheck) map[string]string { return v.Headers }).(pulumi.StringMapOutput)
}

// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
func (o HttpCheckOutput) MaskHeaders() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HttpCheck) *bool { return v.MaskHeaders }).(pulumi.BoolPtrOutput)
}

// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
func (o HttpCheckOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HttpCheck) *string { return v.Path }).(pulumi.StringPtrOutput)
}

// Contains information needed to add pings to an HTTP check.
func (o HttpCheckOutput) PingConfig() PingConfigPtrOutput {
	return o.ApplyT(func(v HttpCheck) *PingConfig { return v.PingConfig }).(PingConfigPtrOutput)
}

// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
func (o HttpCheckOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HttpCheck) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
func (o HttpCheckOutput) RequestMethod() HttpCheckRequestMethodPtrOutput {
	return o.ApplyT(func(v HttpCheck) *HttpCheckRequestMethod { return v.RequestMethod }).(HttpCheckRequestMethodPtrOutput)
}

// If true, use HTTPS instead of HTTP to run the check.
func (o HttpCheckOutput) UseSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HttpCheck) *bool { return v.UseSsl }).(pulumi.BoolPtrOutput)
}

// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
func (o HttpCheckOutput) ValidateSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HttpCheck) *bool { return v.ValidateSsl }).(pulumi.BoolPtrOutput)
}

type HttpCheckPtrOutput struct{ *pulumi.OutputState }

func (HttpCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HttpCheck)(nil)).Elem()
}

func (o HttpCheckPtrOutput) ToHttpCheckPtrOutput() HttpCheckPtrOutput {
	return o
}

func (o HttpCheckPtrOutput) ToHttpCheckPtrOutputWithContext(ctx context.Context) HttpCheckPtrOutput {
	return o
}

func (o HttpCheckPtrOutput) Elem() HttpCheckOutput {
	return o.ApplyT(func(v *HttpCheck) HttpCheck {
		if v != nil {
			return *v
		}
		var ret HttpCheck
		return ret
	}).(HttpCheckOutput)
}

// If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299.
func (o HttpCheckPtrOutput) AcceptedResponseStatusCodes() ResponseStatusCodeArrayOutput {
	return o.ApplyT(func(v *HttpCheck) []ResponseStatusCode {
		if v == nil {
			return nil
		}
		return v.AcceptedResponseStatusCodes
	}).(ResponseStatusCodeArrayOutput)
}

// The authentication information. Optional when creating an HTTP check; defaults to empty.
func (o HttpCheckPtrOutput) AuthInfo() BasicAuthenticationPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *BasicAuthentication {
		if v == nil {
			return nil
		}
		return v.AuthInfo
	}).(BasicAuthenticationPtrOutput)
}

// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte.Note: If client libraries aren't used (which performs the conversion automatically) base64 encode your body data since the field is of bytes type.
func (o HttpCheckPtrOutput) Body() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *string {
		if v == nil {
			return nil
		}
		return v.Body
	}).(pulumi.StringPtrOutput)
}

// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
func (o HttpCheckPtrOutput) ContentType() HttpCheckContentTypePtrOutput {
	return o.ApplyT(func(v *HttpCheck) *HttpCheckContentType {
		if v == nil {
			return nil
		}
		return v.ContentType
	}).(HttpCheckContentTypePtrOutput)
}

// A user provided content type header to use for the check. The invalid configurations outlined in the content_type field apply to custom_content_type, as well as the following: 1. content_type is URL_ENCODED and custom_content_type is set. 2. content_type is USER_PROVIDED and custom_content_type is not set.
func (o HttpCheckPtrOutput) CustomContentType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *string {
		if v == nil {
			return nil
		}
		return v.CustomContentType
	}).(pulumi.StringPtrOutput)
}

// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
func (o HttpCheckPtrOutput) Headers() pulumi.StringMapOutput {
	return o.ApplyT(func(v *HttpCheck) map[string]string {
		if v == nil {
			return nil
		}
		return v.Headers
	}).(pulumi.StringMapOutput)
}

// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
func (o HttpCheckPtrOutput) MaskHeaders() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *bool {
		if v == nil {
			return nil
		}
		return v.MaskHeaders
	}).(pulumi.BoolPtrOutput)
}

// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
func (o HttpCheckPtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *string {
		if v == nil {
			return nil
		}
		return v.Path
	}).(pulumi.StringPtrOutput)
}

// Contains information needed to add pings to an HTTP check.
func (o HttpCheckPtrOutput) PingConfig() PingConfigPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *PingConfig {
		if v == nil {
			return nil
		}
		return v.PingConfig
	}).(PingConfigPtrOutput)
}

// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
func (o HttpCheckPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
func (o HttpCheckPtrOutput) RequestMethod() HttpCheckRequestMethodPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *HttpCheckRequestMethod {
		if v == nil {
			return nil
		}
		return v.RequestMethod
	}).(HttpCheckRequestMethodPtrOutput)
}

// If true, use HTTPS instead of HTTP to run the check.
func (o HttpCheckPtrOutput) UseSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *bool {
		if v == nil {
			return nil
		}
		return v.UseSsl
	}).(pulumi.BoolPtrOutput)
}

// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
func (o HttpCheckPtrOutput) ValidateSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *bool {
		if v == nil {
			return nil
		}
		return v.ValidateSsl
	}).(pulumi.BoolPtrOutput)
}

// Information involved in an HTTP/HTTPS Uptime check request.
type HttpCheckResponse struct {
	// If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299.
	AcceptedResponseStatusCodes []ResponseStatusCodeResponse `pulumi:"acceptedResponseStatusCodes"`
	// The authentication information. Optional when creating an HTTP check; defaults to empty.
	AuthInfo BasicAuthenticationResponse `pulumi:"authInfo"`
	// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte.Note: If client libraries aren't used (which performs the conversion automatically) base64 encode your body data since the field is of bytes type.
	Body string `pulumi:"body"`
	// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
	ContentType string `pulumi:"contentType"`
	// A user provided content type header to use for the check. The invalid configurations outlined in the content_type field apply to custom_content_type, as well as the following: 1. content_type is URL_ENCODED and custom_content_type is set. 2. content_type is USER_PROVIDED and custom_content_type is not set.
	CustomContentType string `pulumi:"customContentType"`
	// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
	Headers map[string]string `pulumi:"headers"`
	// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
	MaskHeaders bool `pulumi:"maskHeaders"`
	// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
	Path string `pulumi:"path"`
	// Contains information needed to add pings to an HTTP check.
	PingConfig PingConfigResponse `pulumi:"pingConfig"`
	// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
	Port int `pulumi:"port"`
	// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
	RequestMethod string `pulumi:"requestMethod"`
	// If true, use HTTPS instead of HTTP to run the check.
	UseSsl bool `pulumi:"useSsl"`
	// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
	ValidateSsl bool `pulumi:"validateSsl"`
}

// Information involved in an HTTP/HTTPS Uptime check request.
type HttpCheckResponseOutput struct{ *pulumi.OutputState }

func (HttpCheckResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HttpCheckResponse)(nil)).Elem()
}

func (o HttpCheckResponseOutput) ToHttpCheckResponseOutput() HttpCheckResponseOutput {
	return o
}

func (o HttpCheckResponseOutput) ToHttpCheckResponseOutputWithContext(ctx context.Context) HttpCheckResponseOutput {
	return o
}

// If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299.
func (o HttpCheckResponseOutput) AcceptedResponseStatusCodes() ResponseStatusCodeResponseArrayOutput {
	return o.ApplyT(func(v HttpCheckResponse) []ResponseStatusCodeResponse { return v.AcceptedResponseStatusCodes }).(ResponseStatusCodeResponseArrayOutput)
}

// The authentication information. Optional when creating an HTTP check; defaults to empty.
func (o HttpCheckResponseOutput) AuthInfo() BasicAuthenticationResponseOutput {
	return o.ApplyT(func(v HttpCheckResponse) BasicAuthenticationResponse { return v.AuthInfo }).(BasicAuthenticationResponseOutput)
}

// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte.Note: If client libraries aren't used (which performs the conversion automatically) base64 encode your body data since the field is of bytes type.
func (o HttpCheckResponseOutput) Body() pulumi.StringOutput {
	return o.ApplyT(func(v HttpCheckResponse) string { return v.Body }).(pulumi.StringOutput)
}

// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
func (o HttpCheckResponseOutput) ContentType() pulumi.StringOutput {
	return o.ApplyT(func(v HttpCheckResponse) string { return v.ContentType }).(pulumi.StringOutput)
}

// A user provided content type header to use for the check. The invalid configurations outlined in the content_type field apply to custom_content_type, as well as the following: 1. content_type is URL_ENCODED and custom_content_type is set. 2. content_type is USER_PROVIDED and custom_content_type is not set.
func (o HttpCheckResponseOutput) CustomContentType() pulumi.StringOutput {
	return o.ApplyT(func(v HttpCheckResponse) string { return v.CustomContentType }).(pulumi.StringOutput)
}

// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
func (o HttpCheckResponseOutput) Headers() pulumi.StringMapOutput {
	return o.ApplyT(func(v HttpCheckResponse) map[string]string { return v.Headers }).(pulumi.StringMapOutput)
}

// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
func (o HttpCheckResponseOutput) MaskHeaders() pulumi.BoolOutput {
	return o.ApplyT(func(v HttpCheckResponse) bool { return v.MaskHeaders }).(pulumi.BoolOutput)
}

// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
func (o HttpCheckResponseOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v HttpCheckResponse) string { return v.Path }).(pulumi.StringOutput)
}

// Contains information needed to add pings to an HTTP check.
func (o HttpCheckResponseOutput) PingConfig() PingConfigResponseOutput {
	return o.ApplyT(func(v HttpCheckResponse) PingConfigResponse { return v.PingConfig }).(PingConfigResponseOutput)
}

// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
func (o HttpCheckResponseOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v HttpCheckResponse) int { return v.Port }).(pulumi.IntOutput)
}

// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
func (o HttpCheckResponseOutput) RequestMethod() pulumi.StringOutput {
	return o.ApplyT(func(v HttpCheckResponse) string { return v.RequestMethod }).(pulumi.StringOutput)
}

// If true, use HTTPS instead of HTTP to run the check.
func (o HttpCheckResponseOutput) UseSsl() pulumi.BoolOutput {
	return o.ApplyT(func(v HttpCheckResponse) bool { return v.UseSsl }).(pulumi.BoolOutput)
}

// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
func (o HttpCheckResponseOutput) ValidateSsl() pulumi.BoolOutput {
	return o.ApplyT(func(v HttpCheckResponse) bool { return v.ValidateSsl }).(pulumi.BoolOutput)
}

// An internal checker allows Uptime checks to run on private/internal GCP resources.
type InternalChecker struct {
	// The checker's human-readable name. The display name should be unique within a Cloud Monitoring Metrics Scope in order to make it easier to identify; however, uniqueness is not enforced.
	DisplayName *string `pulumi:"displayName"`
	// The GCP zone the Uptime check should egress from. Only respected for internal Uptime checks, where internal_network is specified.
	GcpZone *string `pulumi:"gcpZone"`
	// A unique resource name for this InternalChecker. The format is: projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID] [PROJECT_ID_OR_NUMBER] is the Cloud Monitoring Metrics Scope project for the Uptime check config associated with the internal checker.
	Name *string `pulumi:"name"`
	// The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the internal resource lives (ex: "default").
	Network *string `pulumi:"network"`
	// The GCP project ID where the internal checker lives. Not necessary the same as the Metrics Scope project.
	PeerProjectId *string `pulumi:"peerProjectId"`
	// The current operational state of the internal checker.
	State *InternalCheckerState `pulumi:"state"`
}

// InternalCheckerInput is an input type that accepts InternalCheckerArgs and InternalCheckerOutput values.
// You can construct a concrete instance of `InternalCheckerInput` via:
//
//	InternalCheckerArgs{...}
type InternalCheckerInput interface {
	pulumi.Input

	ToInternalCheckerOutput() InternalCheckerOutput
	ToInternalCheckerOutputWithContext(context.Context) InternalCheckerOutput
}

// An internal checker allows Uptime checks to run on private/internal GCP resources.
type InternalCheckerArgs struct {
	// The checker's human-readable name. The display name should be unique within a Cloud Monitoring Metrics Scope in order to make it easier to identify; however, uniqueness is not enforced.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// The GCP zone the Uptime check should egress from. Only respected for internal Uptime checks, where internal_network is specified.
	GcpZone pulumi.StringPtrInput `pulumi:"gcpZone"`
	// A unique resource name for this InternalChecker. The format is: projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID] [PROJECT_ID_OR_NUMBER] is the Cloud Monitoring Metrics Scope project for the Uptime check config associated with the internal checker.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the internal resource lives (ex: "default").
	Network pulumi.StringPtrInput `pulumi:"network"`
	// The GCP project ID where the internal checker lives. Not necessary the same as the Metrics Scope project.
	PeerProjectId pulumi.StringPtrInput `pulumi:"peerProjectId"`
	// The current operational state of the internal checker.
	State InternalCheckerStatePtrInput `pulumi:"state"`
}

func (InternalCheckerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InternalChecker)(nil)).Elem()
}

func (i InternalCheckerArgs) ToInternalCheckerOutput() InternalCheckerOutput {
	return i.ToInternalCheckerOutputWithContext(context.Background())
}

func (i InternalCheckerArgs) ToInternalCheckerOutputWithContext(ctx context.Context) InternalCheckerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InternalCheckerOutput)
}

// InternalCheckerArrayInput is an input type that accepts InternalCheckerArray and InternalCheckerArrayOutput values.
// You can construct a concrete instance of `InternalCheckerArrayInput` via:
//
//	InternalCheckerArray{ InternalCheckerArgs{...} }
type InternalCheckerArrayInput interface {
	pulumi.Input

	ToInternalCheckerArrayOutput() InternalCheckerArrayOutput
	ToInternalCheckerArrayOutputWithContext(context.Context) InternalCheckerArrayOutput
}

type InternalCheckerArray []InternalCheckerInput

func (InternalCheckerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InternalChecker)(nil)).Elem()
}

func (i InternalCheckerArray) ToInternalCheckerArrayOutput() InternalCheckerArrayOutput {
	return i.ToInternalCheckerArrayOutputWithContext(context.Background())
}

func (i InternalCheckerArray) ToInternalCheckerArrayOutputWithContext(ctx context.Context) InternalCheckerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InternalCheckerArrayOutput)
}

// An internal checker allows Uptime checks to run on private/internal GCP resources.
type InternalCheckerOutput struct{ *pulumi.OutputState }

func (InternalCheckerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InternalChecker)(nil)).Elem()
}

func (o InternalCheckerOutput) ToInternalCheckerOutput() InternalCheckerOutput {
	return o
}

func (o InternalCheckerOutput) ToInternalCheckerOutputWithContext(ctx context.Context) InternalCheckerOutput {
	return o
}

// The checker's human-readable name. The display name should be unique within a Cloud Monitoring Metrics Scope in order to make it easier to identify; however, uniqueness is not enforced.
func (o InternalCheckerOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// The GCP zone the Uptime check should egress from. Only respected for internal Uptime checks, where internal_network is specified.
func (o InternalCheckerOutput) GcpZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.GcpZone }).(pulumi.StringPtrOutput)
}

// A unique resource name for this InternalChecker. The format is: projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID] [PROJECT_ID_OR_NUMBER] is the Cloud Monitoring Metrics Scope project for the Uptime check config associated with the internal checker.
func (o InternalCheckerOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the internal resource lives (ex: "default").
func (o InternalCheckerOutput) Network() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.Network }).(pulumi.StringPtrOutput)
}

// The GCP project ID where the internal checker lives. Not necessary the same as the Metrics Scope project.
func (o InternalCheckerOutput) PeerProjectId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.PeerProjectId }).(pulumi.StringPtrOutput)
}

// The current operational state of the internal checker.
func (o InternalCheckerOutput) State() InternalCheckerStatePtrOutput {
	return o.ApplyT(func(v InternalChecker) *InternalCheckerState { return v.State }).(InternalCheckerStatePtrOutput)
}

type InternalCheckerArrayOutput struct{ *pulumi.OutputState }

func (InternalCheckerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InternalChecker)(nil)).Elem()
}

func (o InternalCheckerArrayOutput) ToInternalCheckerArrayOutput() InternalCheckerArrayOutput {
	return o
}

func (o InternalCheckerArrayOutput) ToInternalCheckerArrayOutputWithContext(ctx context.Context) InternalCheckerArrayOutput {
	return o
}

func (o InternalCheckerArrayOutput) Index(i pulumi.IntInput) InternalCheckerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InternalChecker {
		return vs[0].([]InternalChecker)[vs[1].(int)]
	}).(InternalCheckerOutput)
}

// An internal checker allows Uptime checks to run on private/internal GCP resources.
type InternalCheckerResponse struct {
	// The checker's human-readable name. The display name should be unique within a Cloud Monitoring Metrics Scope in order to make it easier to identify; however, uniqueness is not enforced.
	DisplayName string `pulumi:"displayName"`
	// The GCP zone the Uptime check should egress from. Only respected for internal Uptime checks, where internal_network is specified.
	GcpZone string `pulumi:"gcpZone"`
	// A unique resource name for this InternalChecker. The format is: projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID] [PROJECT_ID_OR_NUMBER] is the Cloud Monitoring Metrics Scope project for the Uptime check config associated with the internal checker.
	Name string `pulumi:"name"`
	// The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the internal resource lives (ex: "default").
	Network string `pulumi:"network"`
	// The GCP project ID where the internal checker lives. Not necessary the same as the Metrics Scope project.
	PeerProjectId string `pulumi:"peerProjectId"`
	// The current operational state of the internal checker.
	State string `pulumi:"state"`
}

// An internal checker allows Uptime checks to run on private/internal GCP resources.
type InternalCheckerResponseOutput struct{ *pulumi.OutputState }

func (InternalCheckerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InternalCheckerResponse)(nil)).Elem()
}

func (o InternalCheckerResponseOutput) ToInternalCheckerResponseOutput() InternalCheckerResponseOutput {
	return o
}

func (o InternalCheckerResponseOutput) ToInternalCheckerResponseOutputWithContext(ctx context.Context) InternalCheckerResponseOutput {
	return o
}

// The checker's human-readable name. The display name should be unique within a Cloud Monitoring Metrics Scope in order to make it easier to identify; however, uniqueness is not enforced.
func (o InternalCheckerResponseOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v InternalCheckerResponse) string { return v.DisplayName }).(pulumi.StringOutput)
}

// The GCP zone the Uptime check should egress from. Only respected for internal Uptime checks, where internal_network is specified.
func (o InternalCheckerResponseOutput) GcpZone() pulumi.StringOutput {
	return o.ApplyT(func(v InternalCheckerResponse) string { return v.GcpZone }).(pulumi.StringOutput)
}

// A unique resource name for this InternalChecker. The format is: projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID] [PROJECT_ID_OR_NUMBER] is the Cloud Monitoring Metrics Scope project for the Uptime check config associated with the internal checker.
func (o InternalCheckerResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v InternalCheckerResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the internal resource lives (ex: "default").
func (o InternalCheckerResponseOutput) Network() pulumi.StringOutput {
	return o.ApplyT(func(v InternalCheckerResponse) string { return v.Network }).(pulumi.StringOutput)
}

// The GCP project ID where the internal checker lives. Not necessary the same as the Metrics Scope project.
func (o InternalCheckerResponseOutput) PeerProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v InternalCheckerResponse) string { return v.PeerProjectId }).(pulumi.StringOutput)
}

// The current operational state of the internal checker.
func (o InternalCheckerResponseOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v InternalCheckerResponse) string { return v.State }).(pulumi.StringOutput)
}

type InternalCheckerResponseArrayOutput struct{ *pulumi.OutputState }

func (InternalCheckerResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InternalCheckerResponse)(nil)).Elem()
}

func (o InternalCheckerResponseArrayOutput) ToInternalCheckerResponseArrayOutput() InternalCheckerResponseArrayOutput {
	return o
}

func (o InternalCheckerResponseArrayOutput) ToInternalCheckerResponseArrayOutputWithContext(ctx context.Context) InternalCheckerResponseArrayOutput {
	return o
}

func (o InternalCheckerResponseArrayOutput) Index(i pulumi.IntInput) InternalCheckerResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InternalCheckerResponse {
		return vs[0].([]InternalCheckerResponse)[vs[1].(int)]
	}).(InternalCheckerResponseOutput)
}

// Canonical service scoped to an Istio mesh. Anthos clusters running ASM >= 1.6.8 will have their services ingested as this type.
type IstioCanonicalService struct {
	// The name of the canonical service underlying this service. Corresponds to the destination_canonical_service_name metric label in label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	CanonicalService *string `pulumi:"canonicalService"`
	// The namespace of the canonical service underlying this service. Corresponds to the destination_canonical_service_namespace metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	CanonicalServiceNamespace *string `pulumi:"canonicalServiceNamespace"`
	// Identifier for the Istio mesh in which this canonical service is defined. Corresponds to the mesh_uid metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	MeshUid *string `pulumi:"meshUid"`
}

// IstioCanonicalServiceInput is an input type that accepts IstioCanonicalServiceArgs and IstioCanonicalServiceOutput values.
// You can construct a concrete instance of `IstioCanonicalServiceInput` via:
//
//	IstioCanonicalServiceArgs{...}
type IstioCanonicalServiceInput interface {
	pulumi.Input

	ToIstioCanonicalServiceOutput() IstioCanonicalServiceOutput
	ToIstioCanonicalServiceOutputWithContext(context.Context) IstioCanonicalServiceOutput
}

// Canonical service scoped to an Istio mesh. Anthos clusters running ASM >= 1.6.8 will have their services ingested as this type.
type IstioCanonicalServiceArgs struct {
	// The name of the canonical service underlying this service. Corresponds to the destination_canonical_service_name metric label in label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	CanonicalService pulumi.StringPtrInput `pulumi:"canonicalService"`
	// The namespace of the canonical service underlying this service. Corresponds to the destination_canonical_service_namespace metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	CanonicalServiceNamespace pulumi.StringPtrInput `pulumi:"canonicalServiceNamespace"`
	// Identifier for the Istio mesh in which this canonical service is defined. Corresponds to the mesh_uid metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	MeshUid pulumi.StringPtrInput `pulumi:"meshUid"`
}

func (IstioCanonicalServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IstioCanonicalService)(nil)).Elem()
}

func (i IstioCanonicalServiceArgs) ToIstioCanonicalServiceOutput() IstioCanonicalServiceOutput {
	return i.ToIstioCanonicalServiceOutputWithContext(context.Background())
}

func (i IstioCanonicalServiceArgs) ToIstioCanonicalServiceOutputWithContext(ctx context.Context) IstioCanonicalServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IstioCanonicalServiceOutput)
}

func (i IstioCanonicalServiceArgs) ToIstioCanonicalServicePtrOutput() IstioCanonicalServicePtrOutput {
	return i.ToIstioCanonicalServicePtrOutputWithContext(context.Background())
}

func (i IstioCanonicalServiceArgs) ToIstioCanonicalServicePtrOutputWithContext(ctx context.Context) IstioCanonicalServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IstioCanonicalServiceOutput).ToIstioCanonicalServicePtrOutputWithContext(ctx)
}

// IstioCanonicalServicePtrInput is an input type that accepts IstioCanonicalServiceArgs, IstioCanonicalServicePtr and IstioCanonicalServicePtrOutput values.
// You can construct a concrete instance of `IstioCanonicalServicePtrInput` via:
//
//	        IstioCanonicalServiceArgs{...}
//
//	or:
//
//	        nil
type IstioCanonicalServicePtrInput interface {
	pulumi.Input

	ToIstioCanonicalServicePtrOutput() IstioCanonicalServicePtrOutput
	ToIstioCanonicalServicePtrOutputWithContext(context.Context) IstioCanonicalServicePtrOutput
}

type istioCanonicalServicePtrType IstioCanonicalServiceArgs

func IstioCanonicalServicePtr(v *IstioCanonicalServiceArgs) IstioCanonicalServicePtrInput {
	return (*istioCanonicalServicePtrType)(v)
}

func (*istioCanonicalServicePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IstioCanonicalService)(nil)).Elem()
}

func (i *istioCanonicalServicePtrType) ToIstioCanonicalServicePtrOutput() IstioCanonicalServicePtrOutput {
	return i.ToIstioCanonicalServicePtrOutputWithContext(context.Background())
}

func (i *istioCanonicalServicePtrType) ToIstioCanonicalServicePtrOutputWithContext(ctx context.Context) IstioCanonicalServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IstioCanonicalServicePtrOutput)
}

// Canonical service scoped to an Istio mesh. Anthos clusters running ASM >= 1.6.8 will have their services ingested as this type.
type IstioCanonicalServiceOutput struct{ *pulumi.OutputState }

func (IstioCanonicalServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IstioCanonicalService)(nil)).Elem()
}

func (o IstioCanonicalServiceOutput) ToIstioCanonicalServiceOutput() IstioCanonicalServiceOutput {
	return o
}

func (o IstioCanonicalServiceOutput) ToIstioCanonicalServiceOutputWithContext(ctx context.Context) IstioCanonicalServiceOutput {
	return o
}

func (o IstioCanonicalServiceOutput) ToIstioCanonicalServicePtrOutput() IstioCanonicalServicePtrOutput {
	return o.ToIstioCanonicalServicePtrOutputWithContext(context.Background())
}

func (o IstioCanonicalServiceOutput) ToIstioCanonicalServicePtrOutputWithContext(ctx context.Context) IstioCanonicalServicePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IstioCanonicalService) *IstioCanonicalService {
		return &v
	}).(IstioCanonicalServicePtrOutput)
}

// The name of the canonical service underlying this service. Corresponds to the destination_canonical_service_name metric label in label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceOutput) CanonicalService() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IstioCanonicalService) *string { return v.CanonicalService }).(pulumi.StringPtrOutput)
}

// The namespace of the canonical service underlying this service. Corresponds to the destination_canonical_service_namespace metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceOutput) CanonicalServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IstioCanonicalService) *string { return v.CanonicalServiceNamespace }).(pulumi.StringPtrOutput)
}

// Identifier for the Istio mesh in which this canonical service is defined. Corresponds to the mesh_uid metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceOutput) MeshUid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IstioCanonicalService) *string { return v.MeshUid }).(pulumi.StringPtrOutput)
}

type IstioCanonicalServicePtrOutput struct{ *pulumi.OutputState }

func (IstioCanonicalServicePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IstioCanonicalService)(nil)).Elem()
}

func (o IstioCanonicalServicePtrOutput) ToIstioCanonicalServicePtrOutput() IstioCanonicalServicePtrOutput {
	return o
}

func (o IstioCanonicalServicePtrOutput) ToIstioCanonicalServicePtrOutputWithContext(ctx context.Context) IstioCanonicalServicePtrOutput {
	return o
}

func (o IstioCanonicalServicePtrOutput) Elem() IstioCanonicalServiceOutput {
	return o.ApplyT(func(v *IstioCanonicalService) IstioCanonicalService {
		if v != nil {
			return *v
		}
		var ret IstioCanonicalService
		return ret
	}).(IstioCanonicalServiceOutput)
}

// The name of the canonical service underlying this service. Corresponds to the destination_canonical_service_name metric label in label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServicePtrOutput) CanonicalService() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IstioCanonicalService) *string {
		if v == nil {
			return nil
		}
		return v.CanonicalService
	}).(pulumi.StringPtrOutput)
}

// The namespace of the canonical service underlying this service. Corresponds to the destination_canonical_service_namespace metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServicePtrOutput) CanonicalServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IstioCanonicalService) *string {
		if v == nil {
			return nil
		}
		return v.CanonicalServiceNamespace
	}).(pulumi.StringPtrOutput)
}

// Identifier for the Istio mesh in which this canonical service is defined. Corresponds to the mesh_uid metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServicePtrOutput) MeshUid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IstioCanonicalService) *string {
		if v == nil {
			return nil
		}
		return v.MeshUid
	}).(pulumi.StringPtrOutput)
}

// Canonical service scoped to an Istio mesh. Anthos clusters running ASM >= 1.6.8 will have their services ingested as this type.
type IstioCanonicalServiceResponse struct {
	// The name of the canonical service underlying this service. Corresponds to the destination_canonical_service_name metric label in label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	CanonicalService string `pulumi:"canonicalService"`
	// The namespace of the canonical service underlying this service. Corresponds to the destination_canonical_service_namespace metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	CanonicalServiceNamespace string `pulumi:"canonicalServiceNamespace"`
	// Identifier for the Istio mesh in which this canonical service is defined. Corresponds to the mesh_uid metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
	MeshUid string `pulumi:"meshUid"`
}

// Canonical service scoped to an Istio mesh. Anthos clusters running ASM >= 1.6.8 will have their services ingested as this type.
type IstioCanonicalServiceResponseOutput struct{ *pulumi.OutputState }

func (IstioCanonicalServiceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IstioCanonicalServiceResponse)(nil)).Elem()
}

func (o IstioCanonicalServiceResponseOutput) ToIstioCanonicalServiceResponseOutput() IstioCanonicalServiceResponseOutput {
	return o
}

func (o IstioCanonicalServiceResponseOutput) ToIstioCanonicalServiceResponseOutputWithContext(ctx context.Context) IstioCanonicalServiceResponseOutput {
	return o
}

// The name of the canonical service underlying this service. Corresponds to the destination_canonical_service_name metric label in label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceResponseOutput) CanonicalService() pulumi.StringOutput {
	return o.ApplyT(func(v IstioCanonicalServiceResponse) string { return v.CanonicalService }).(pulumi.StringOutput)
}

// The namespace of the canonical service underlying this service. Corresponds to the destination_canonical_service_namespace metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceResponseOutput) CanonicalServiceNamespace() pulumi.StringOutput {
	return o.ApplyT(func(v IstioCanonicalServiceResponse) string { return v.CanonicalServiceNamespace }).(pulumi.StringOutput)
}

// Identifier for the Istio mesh in which this canonical service is defined. Corresponds to the mesh_uid metric label in Istio metrics (https://cloud.google.com/monitoring/api/metrics_istio).
func (o IstioCanonicalServiceResponseOutput) MeshUid() pulumi.StringOutput {
	return o.ApplyT(func(v IstioCanonicalServiceResponse) string { return v.MeshUid }).(pulumi.StringOutput)
}

// Information needed to perform a JSONPath content match. Used for ContentMatcherOption::MATCHES_JSON_PATH and ContentMatcherOption::NOT_MATCHES_JSON_PATH.
type JsonPathMatcher struct {
	// The type of JSONPath match that will be applied to the JSON output (ContentMatcher.content)
	JsonMatcher *JsonPathMatcherJsonMatcher `pulumi:"jsonMatcher"`
	// JSONPath within the response output pointing to the expected ContentMatcher::content to match against.
	JsonPath *string `pulumi:"jsonPath"`
}

// JsonPathMatcherInput is an input type that accepts JsonPathMatcherArgs and JsonPathMatcherOutput values.
// You can construct a concrete instance of `JsonPathMatcherInput` via:
//
//	JsonPathMatcherArgs{...}
type JsonPathMatcherInput interface {
	pulumi.Input

	ToJsonPathMatcherOutput() JsonPathMatcherOutput
	ToJsonPathMatcherOutputWithContext(context.Context) JsonPathMatcherOutput
}

// Information needed to perform a JSONPath content match. Used for ContentMatcherOption::MATCHES_JSON_PATH and ContentMatcherOption::NOT_MATCHES_JSON_PATH.
type JsonPathMatcherArgs struct {
	// The type of JSONPath match that will be applied to the JSON output (ContentMatcher.content)
	JsonMatcher JsonPathMatcherJsonMatcherPtrInput `pulumi:"jsonMatcher"`
	// JSONPath within the response output pointing to the expected ContentMatcher::content to match against.
	JsonPath pulumi.StringPtrInput `pulumi:"jsonPath"`
}

func (JsonPathMatcherArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JsonPathMatcher)(nil)).Elem()
}

func (i JsonPathMatcherArgs) ToJsonPathMatcherOutput() JsonPathMatcherOutput {
	return i.ToJsonPathMatcherOutputWithContext(context.Background())
}

func (i JsonPathMatcherArgs) ToJsonPathMatcherOutputWithContext(ctx context.Context) JsonPathMatcherOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JsonPathMatcherOutput)
}

func (i JsonPathMatcherArgs) ToJsonPathMatcherPtrOutput() JsonPathMatcherPtrOutput {
	return i.ToJsonPathMatcherPtrOutputWithContext(context.Background())
}

func (i JsonPathMatcherArgs) ToJsonPathMatcherPtrOutputWithContext(ctx context.Context) JsonPathMatcherPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JsonPathMatcherOutput).ToJsonPathMatcherPtrOutputWithContext(ctx)
}

// JsonPathMatcherPtrInput is an input type that accepts JsonPathMatcherArgs, JsonPathMatcherPtr and JsonPathMatcherPtrOutput values.
// You can construct a concrete instance of `JsonPathMatcherPtrInput` via:
//
//	        JsonPathMatcherArgs{...}
//
//	or:
//
//	        nil
type JsonPathMatcherPtrInput interface {
	pulumi.Input

	ToJsonPathMatcherPtrOutput() JsonPathMatcherPtrOutput
	ToJsonPathMatcherPtrOutputWithContext(context.Context) JsonPathMatcherPtrOutput
}

type jsonPathMatcherPtrType JsonPathMatcherArgs

func JsonPathMatcherPtr(v *JsonPathMatcherArgs) JsonPathMatcherPtrInput {
	return (*jsonPathMatcherPtrType)(v)
}

func (*jsonPathMatcherPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**JsonPathMatcher)(nil)).Elem()
}

func (i *jsonPathMatcherPtrType) ToJsonPathMatcherPtrOutput() JsonPathMatcherPtrOutput {
	return i.ToJsonPathMatcherPtrOutputWithContext(context.Background())
}

func (i *jsonPathMatcherPtrType) ToJsonPathMatcherPtrOutputWithContext(ctx context.Context) JsonPathMatcherPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JsonPathMatcherPtrOutput)
}

// Information needed to perform a JSONPath content match. Used for ContentMatcherOption::MATCHES_JSON_PATH and ContentMatcherOption::NOT_MATCHES_JSON_PATH.
type JsonPathMatcherOutput struct{ *pulumi.OutputState }

func (JsonPathMatcherOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JsonPathMatcher)(nil)).Elem()
}

func (o JsonPathMatcherOutput) ToJsonPathMatcherOutput() JsonPathMatcherOutput {
	return o
}

func (o JsonPathMatcherOutput) ToJsonPathMatcherOutputWithContext(ctx context.Context) JsonPathMatcherOutput {
	return o
}

func (o JsonPathMatcherOutput) ToJsonPathMatcherPtrOutput() JsonPathMatcherPtrOutput {
	return o.ToJsonPathMatcherPtrOutputWithContext(context.Background())
}

func (o JsonPathMatcherOutput) ToJsonPathMatcherPtrOutputWithContext(ctx context.Context) JsonPathMatcherPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v JsonPathMatcher) *JsonPathMatcher {
		return &v
	}).(JsonPathMatcherPtrOutput)
}

// The type of JSONPath match that will be applied to the JSON output (ContentMatcher.content)
func (o JsonPathMatcherOutput) JsonMatcher() JsonPathMatcherJsonMatcherPtrOutput {
	return o.ApplyT(func(v JsonPathMatcher) *JsonPathMatcherJsonMatcher { return v.JsonMatcher }).(JsonPathMatcherJsonMatcherPtrOutput)
}

// JSONPath within the response output pointing to the expected ContentMatcher::content to match against.
func (o JsonPathMatcherOutput) JsonPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JsonPathMatcher) *string { return v.JsonPath }).(pulumi.StringPtrOutput)
}

type JsonPathMatcherPtrOutput struct{ *pulumi.OutputState }

func (JsonPathMatcherPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**JsonPathMatcher)(nil)).Elem()
}

func (o JsonPathMatcherPtrOutput) ToJsonPathMatcherPtrOutput() JsonPathMatcherPtrOutput {
	return o
}

func (o JsonPathMatcherPtrOutput) ToJsonPathMatcherPtrOutputWithContext(ctx context.Context) JsonPathMatcherPtrOutput {
	return o
}

func (o JsonPathMatcherPtrOutput) Elem() JsonPathMatcherOutput {
	return o.ApplyT(func(v *JsonPathMatcher) JsonPathMatcher {
		if v != nil {
			return *v
		}
		var ret JsonPathMatcher
		return ret
	}).(JsonPathMatcherOutput)
}

// The type of JSONPath match that will be applied to the JSON output (ContentMatcher.content)
func (o JsonPathMatcherPtrOutput) JsonMatcher() JsonPathMatcherJsonMatcherPtrOutput {
	return o.ApplyT(func(v *JsonPathMatcher) *JsonPathMatcherJsonMatcher {
		if v == nil {
			return nil
		}
		return v.JsonMatcher
	}).(JsonPathMatcherJsonMatcherPtrOutput)
}

// JSONPath within the response output pointing to the expected ContentMatcher::content to match against.
func (o JsonPathMatcherPtrOutput) JsonPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JsonPathMatcher) *string {
		if v == nil {
			return nil
		}
		return v.JsonPath
	}).(pulumi.StringPtrOutput)
}

// Information needed to perform a JSONPath content match. Used for ContentMatcherOption::MATCHES_JSON_PATH and ContentMatcherOption::NOT_MATCHES_JSON_PATH.
type JsonPathMatcherResponse struct {
	// The type of JSONPath match that will be applied to the JSON output (ContentMatcher.content)
	JsonMatcher string `pulumi:"jsonMatcher"`
	// JSONPath within the response output pointing to the expected ContentMatcher::content to match against.
	JsonPath string `pulumi:"jsonPath"`
}

// Information needed to perform a JSONPath content match. Used for ContentMatcherOption::MATCHES_JSON_PATH and ContentMatcherOption::NOT_MATCHES_JSON_PATH.
type JsonPathMatcherResponseOutput struct{ *pulumi.OutputState }

func (JsonPathMatcherResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JsonPathMatcherResponse)(nil)).Elem()
}

func (o JsonPathMatcherResponseOutput) ToJsonPathMatcherResponseOutput() JsonPathMatcherResponseOutput {
	return o
}

func (o JsonPathMatcherResponseOutput) ToJsonPathMatcherResponseOutputWithContext(ctx context.Context) JsonPathMatcherResponseOutput {
	return o
}

// The type of JSONPath match that will be applied to the JSON output (ContentMatcher.content)
func (o JsonPathMatcherResponseOutput) JsonMatcher() pulumi.StringOutput {
	return o.ApplyT(func(v JsonPathMatcherResponse) string { return v.JsonMatcher }).(pulumi.StringOutput)
}

// JSONPath within the response output pointing to the expected ContentMatcher::content to match against.
func (o JsonPathMatcherResponseOutput) JsonPath() pulumi.StringOutput {
	return o.ApplyT(func(v JsonPathMatcherResponse) string { return v.JsonPath }).(pulumi.StringOutput)
}

// A description of a label.
type LabelDescriptor struct {
	// A human-readable description for the label.
	Description *string `pulumi:"description"`
	// The key for this label. The key must meet the following criteria: Does not exceed 100 characters. Matches the following regular expression: [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case letter. The remaining characters must be letters, digits, or underscores.
	Key *string `pulumi:"key"`
	// The type of data that can be assigned to the label.
	ValueType *LabelDescriptorValueType `pulumi:"valueType"`
}

// LabelDescriptorInput is an input type that accepts LabelDescriptorArgs and LabelDescriptorOutput values.
// You can construct a concrete instance of `LabelDescriptorInput` via:
//
//	LabelDescriptorArgs{...}
type LabelDescriptorInput interface {
	pulumi.Input

	ToLabelDescriptorOutput() LabelDescriptorOutput
	ToLabelDescriptorOutputWithContext(context.Context) LabelDescriptorOutput
}

// A description of a label.
type LabelDescriptorArgs struct {
	// A human-readable description for the label.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// The key for this label. The key must meet the following criteria: Does not exceed 100 characters. Matches the following regular expression: [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case letter. The remaining characters must be letters, digits, or underscores.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// The type of data that can be assigned to the label.
	ValueType LabelDescriptorValueTypePtrInput `pulumi:"valueType"`
}

func (LabelDescriptorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelDescriptor)(nil)).Elem()
}

func (i LabelDescriptorArgs) ToLabelDescriptorOutput() LabelDescriptorOutput {
	return i.ToLabelDescriptorOutputWithContext(context.Background())
}

func (i LabelDescriptorArgs) ToLabelDescriptorOutputWithContext(ctx context.Context) LabelDescriptorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelDescriptorOutput)
}

// LabelDescriptorArrayInput is an input type that accepts LabelDescriptorArray and LabelDescriptorArrayOutput values.
// You can construct a concrete instance of `LabelDescriptorArrayInput` via:
//
//	LabelDescriptorArray{ LabelDescriptorArgs{...} }
type LabelDescriptorArrayInput interface {
	pulumi.Input

	ToLabelDescriptorArrayOutput() LabelDescriptorArrayOutput
	ToLabelDescriptorArrayOutputWithContext(context.Context) LabelDescriptorArrayOutput
}

type LabelDescriptorArray []LabelDescriptorInput

func (LabelDescriptorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LabelDescriptor)(nil)).Elem()
}

func (i LabelDescriptorArray) ToLabelDescriptorArrayOutput() LabelDescriptorArrayOutput {
	return i.ToLabelDescriptorArrayOutputWithContext(context.Background())
}

func (i LabelDescriptorArray) ToLabelDescriptorArrayOutputWithContext(ctx context.Context) LabelDescriptorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelDescriptorArrayOutput)
}

// A description of a label.
type LabelDescriptorOutput struct{ *pulumi.OutputState }

func (LabelDescriptorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelDescriptor)(nil)).Elem()
}

func (o LabelDescriptorOutput) ToLabelDescriptorOutput() LabelDescriptorOutput {
	return o
}

func (o LabelDescriptorOutput) ToLabelDescriptorOutputWithContext(ctx context.Context) LabelDescriptorOutput {
	return o
}

// A human-readable description for the label.
func (o LabelDescriptorOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelDescriptor) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The key for this label. The key must meet the following criteria: Does not exceed 100 characters. Matches the following regular expression: [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case letter. The remaining characters must be letters, digits, or underscores.
func (o LabelDescriptorOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelDescriptor) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// The type of data that can be assigned to the label.
func (o LabelDescriptorOutput) ValueType() LabelDescriptorValueTypePtrOutput {
	return o.ApplyT(func(v LabelDescriptor) *LabelDescriptorValueType { return v.ValueType }).(LabelDescriptorValueTypePtrOutput)
}

type LabelDescriptorArrayOutput struct{ *pulumi.OutputState }

func (LabelDescriptorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LabelDescriptor)(nil)).Elem()
}

func (o LabelDescriptorArrayOutput) ToLabelDescriptorArrayOutput() LabelDescriptorArrayOutput {
	return o
}

func (o LabelDescriptorArrayOutput) ToLabelDescriptorArrayOutputWithContext(ctx context.Context) LabelDescriptorArrayOutput {
	return o
}

func (o LabelDescriptorArrayOutput) Index(i pulumi.IntInput) LabelDescriptorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LabelDescriptor {
		return vs[0].([]LabelDescriptor)[vs[1].(int)]
	}).(LabelDescriptorOutput)
}

// A description of a label.
type LabelDescriptorResponse struct {
	// A human-readable description for the label.
	Description string `pulumi:"description"`
	// The key for this label. The key must meet the following criteria: Does not exceed 100 characters. Matches the following regular expression: [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case letter. The remaining characters must be letters, digits, or underscores.
	Key string `pulumi:"key"`
	// The type of data that can be assigned to the label.
	ValueType string `pulumi:"valueType"`
}

// A description of a label.
type LabelDescriptorResponseOutput struct{ *pulumi.OutputState }

func (LabelDescriptorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelDescriptorResponse)(nil)).Elem()
}

func (o LabelDescriptorResponseOutput) ToLabelDescriptorResponseOutput() LabelDescriptorResponseOutput {
	return o
}

func (o LabelDescriptorResponseOutput) ToLabelDescriptorResponseOutputWithContext(ctx context.Context) LabelDescriptorResponseOutput {
	return o
}

// A human-readable description for the label.
func (o LabelDescriptorResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v LabelDescriptorResponse) string { return v.Description }).(pulumi.StringOutput)
}

// The key for this label. The key must meet the following criteria: Does not exceed 100 characters. Matches the following regular expression: [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case letter. The remaining characters must be letters, digits, or underscores.
func (o LabelDescriptorResponseOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v LabelDescriptorResponse) string { return v.Key }).(pulumi.StringOutput)
}

// The type of data that can be assigned to the label.
func (o LabelDescriptorResponseOutput) ValueType() pulumi.StringOutput {
	return o.ApplyT(func(v LabelDescriptorResponse) string { return v.ValueType }).(pulumi.StringOutput)
}

type LabelDescriptorResponseArrayOutput struct{ *pulumi.OutputState }

func (LabelDescriptorResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LabelDescriptorResponse)(nil)).Elem()
}

func (o LabelDescriptorResponseArrayOutput) ToLabelDescriptorResponseArrayOutput() LabelDescriptorResponseArrayOutput {
	return o
}

func (o LabelDescriptorResponseArrayOutput) ToLabelDescriptorResponseArrayOutputWithContext(ctx context.Context) LabelDescriptorResponseArrayOutput {
	return o
}

func (o LabelDescriptorResponseArrayOutput) Index(i pulumi.IntInput) LabelDescriptorResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LabelDescriptorResponse {
		return vs[0].([]LabelDescriptorResponse)[vs[1].(int)]
	}).(LabelDescriptorResponseOutput)
}

// Parameters for a latency threshold SLI.
type LatencyCriteria struct {
	// Good service is defined to be the count of requests made to this service that return in no more than threshold.
	Threshold *string `pulumi:"threshold"`
}

// LatencyCriteriaInput is an input type that accepts LatencyCriteriaArgs and LatencyCriteriaOutput values.
// You can construct a concrete instance of `LatencyCriteriaInput` via:
//
//	LatencyCriteriaArgs{...}
type LatencyCriteriaInput interface {
	pulumi.Input

	ToLatencyCriteriaOutput() LatencyCriteriaOutput
	ToLatencyCriteriaOutputWithContext(context.Context) LatencyCriteriaOutput
}

// Parameters for a latency threshold SLI.
type LatencyCriteriaArgs struct {
	// Good service is defined to be the count of requests made to this service that return in no more than threshold.
	Threshold pulumi.StringPtrInput `pulumi:"threshold"`
}

func (LatencyCriteriaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LatencyCriteria)(nil)).Elem()
}

func (i LatencyCriteriaArgs) ToLatencyCriteriaOutput() LatencyCriteriaOutput {
	return i.ToLatencyCriteriaOutputWithContext(context.Background())
}

func (i LatencyCriteriaArgs) ToLatencyCriteriaOutputWithContext(ctx context.Context) LatencyCriteriaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatencyCriteriaOutput)
}

func (i LatencyCriteriaArgs) ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput {
	return i.ToLatencyCriteriaPtrOutputWithContext(context.Background())
}

func (i LatencyCriteriaArgs) ToLatencyCriteriaPtrOutputWithContext(ctx context.Context) LatencyCriteriaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatencyCriteriaOutput).ToLatencyCriteriaPtrOutputWithContext(ctx)
}

// LatencyCriteriaPtrInput is an input type that accepts LatencyCriteriaArgs, LatencyCriteriaPtr and LatencyCriteriaPtrOutput values.
// You can construct a concrete instance of `LatencyCriteriaPtrInput` via:
//
//	        LatencyCriteriaArgs{...}
//
//	or:
//
//	        nil
type LatencyCriteriaPtrInput interface {
	pulumi.Input

	ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput
	ToLatencyCriteriaPtrOutputWithContext(context.Context) LatencyCriteriaPtrOutput
}

type latencyCriteriaPtrType LatencyCriteriaArgs

func LatencyCriteriaPtr(v *LatencyCriteriaArgs) LatencyCriteriaPtrInput {
	return (*latencyCriteriaPtrType)(v)
}

func (*latencyCriteriaPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LatencyCriteria)(nil)).Elem()
}

func (i *latencyCriteriaPtrType) ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput {
	return i.ToLatencyCriteriaPtrOutputWithContext(context.Background())
}

func (i *latencyCriteriaPtrType) ToLatencyCriteriaPtrOutputWithContext(ctx context.Context) LatencyCriteriaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatencyCriteriaPtrOutput)
}

// Parameters for a latency threshold SLI.
type LatencyCriteriaOutput struct{ *pulumi.OutputState }

func (LatencyCriteriaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LatencyCriteria)(nil)).Elem()
}

func (o LatencyCriteriaOutput) ToLatencyCriteriaOutput() LatencyCriteriaOutput {
	return o
}

func (o LatencyCriteriaOutput) ToLatencyCriteriaOutputWithContext(ctx context.Context) LatencyCriteriaOutput {
	return o
}

func (o LatencyCriteriaOutput) ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput {
	return o.ToLatencyCriteriaPtrOutputWithContext(context.Background())
}

func (o LatencyCriteriaOutput) ToLatencyCriteriaPtrOutputWithContext(ctx context.Context) LatencyCriteriaPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LatencyCriteria) *LatencyCriteria {
		return &v
	}).(LatencyCriteriaPtrOutput)
}

// Good service is defined to be the count of requests made to this service that return in no more than threshold.
func (o LatencyCriteriaOutput) Threshold() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LatencyCriteria) *string { return v.Threshold }).(pulumi.StringPtrOutput)
}

type LatencyCriteriaPtrOutput struct{ *pulumi.OutputState }

func (LatencyCriteriaPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LatencyCriteria)(nil)).Elem()
}

func (o LatencyCriteriaPtrOutput) ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput {
	return o
}

func (o LatencyCriteriaPtrOutput) ToLatencyCriteriaPtrOutputWithContext(ctx context.Context) LatencyCriteriaPtrOutput {
	return o
}

func (o LatencyCriteriaPtrOutput) Elem() LatencyCriteriaOutput {
	return o.ApplyT(func(v *LatencyCriteria) LatencyCriteria {
		if v != nil {
			return *v
		}
		var ret LatencyCriteria
		return ret
	}).(LatencyCriteriaOutput)
}

// Good service is defined to be the count of requests made to this service that return in no more than threshold.
func (o LatencyCriteriaPtrOutput) Threshold() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LatencyCriteria) *string {
		if v == nil {
			return nil
		}
		return v.Threshold
	}).(pulumi.StringPtrOutput)
}

// Parameters for a latency threshold SLI.
type LatencyCriteriaResponse struct {
	// Good service is defined to be the count of requests made to this service that return in no more than threshold.
	Threshold string `pulumi:"threshold"`
}

// Parameters for a latency threshold SLI.
type LatencyCriteriaResponseOutput struct{ *pulumi.OutputState }

func (LatencyCriteriaResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LatencyCriteriaResponse)(nil)).Elem()
}

func (o LatencyCriteriaResponseOutput) ToLatencyCriteriaResponseOutput() LatencyCriteriaResponseOutput {
	return o
}

func (o LatencyCriteriaResponseOutput) ToLatencyCriteriaResponseOutputWithContext(ctx context.Context) LatencyCriteriaResponseOutput {
	return o
}

// Good service is defined to be the count of requests made to this service that return in no more than threshold.
func (o LatencyCriteriaResponseOutput) Threshold() pulumi.StringOutput {
	return o.ApplyT(func(v LatencyCriteriaResponse) string { return v.Threshold }).(pulumi.StringOutput)
}

// A condition type that checks whether a log message in the scoping project (https://cloud.google.com/monitoring/api/v3#project_name) satisfies the given filter. Logs from other projects in the metrics scope are not evaluated.
type LogMatch struct {
	// A logs-based filter. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries) for how this filter should be constructed.
	Filter string `pulumi:"filter"`
	// Optional. A map from a label key to an extractor expression, which is used to extract the value for this label key. Each entry in this map is a specification for how data should be extracted from log entries that match filter. Each combination of extracted values is treated as a separate rule for the purposes of triggering notifications. Label keys and corresponding values can be used in notifications generated by this condition.Please see the documentation on logs-based metric valueExtractors (https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor) for syntax and examples.
	LabelExtractors map[string]string `pulumi:"labelExtractors"`
}

// LogMatchInput is an input type that accepts LogMatchArgs and LogMatchOutput values.
// You can construct a concrete instance of `LogMatchInput` via:
//
//	LogMatchArgs{...}
type LogMatchInput interface {
	pulumi.Input

	ToLogMatchOutput() LogMatchOutput
	ToLogMatchOutputWithContext(context.Context) LogMatchOutput
}

// A condition type that checks whether a log message in the scoping project (https://cloud.google.com/monitoring/api/v3#project_name) satisfies the given filter. Logs from other projects in the metrics scope are not evaluated.
type LogMatchArgs struct {
	// A logs-based filter. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries) for how this filter should be constructed.
	Filter pulumi.StringInput `pulumi:"filter"`
	// Optional. A map from a label key to an extractor expression, which is used to extract the value for this label key. Each entry in this map is a specification for how data should be extracted from log entries that match filter. Each combination of extracted values is treated as a separate rule for the purposes of triggering notifications. Label keys and corresponding values can be used in notifications generated by this condition.Please see the documentation on logs-based metric valueExtractors (https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor) for syntax and examples.
	LabelExtractors pulumi.StringMapInput `pulumi:"labelExtractors"`
}

func (LogMatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogMatch)(nil)).Elem()
}

func (i LogMatchArgs) ToLogMatchOutput() LogMatchOutput {
	return i.ToLogMatchOutputWithContext(context.Background())
}

func (i LogMatchArgs) ToLogMatchOutputWithContext(ctx context.Context) LogMatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogMatchOutput)
}

func (i LogMatchArgs) ToLogMatchPtrOutput() LogMatchPtrOutput {
	return i.ToLogMatchPtrOutputWithContext(context.Background())
}

func (i LogMatchArgs) ToLogMatchPtrOutputWithContext(ctx context.Context) LogMatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogMatchOutput).ToLogMatchPtrOutputWithContext(ctx)
}

// LogMatchPtrInput is an input type that accepts LogMatchArgs, LogMatchPtr and LogMatchPtrOutput values.
// You can construct a concrete instance of `LogMatchPtrInput` via:
//
//	        LogMatchArgs{...}
//
//	or:
//
//	        nil
type LogMatchPtrInput interface {
	pulumi.Input

	ToLogMatchPtrOutput() LogMatchPtrOutput
	ToLogMatchPtrOutputWithContext(context.Context) LogMatchPtrOutput
}

type logMatchPtrType LogMatchArgs

func LogMatchPtr(v *LogMatchArgs) LogMatchPtrInput {
	return (*logMatchPtrType)(v)
}

func (*logMatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogMatch)(nil)).Elem()
}

func (i *logMatchPtrType) ToLogMatchPtrOutput() LogMatchPtrOutput {
	return i.ToLogMatchPtrOutputWithContext(context.Background())
}

func (i *logMatchPtrType) ToLogMatchPtrOutputWithContext(ctx context.Context) LogMatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogMatchPtrOutput)
}

// A condition type that checks whether a log message in the scoping project (https://cloud.google.com/monitoring/api/v3#project_name) satisfies the given filter. Logs from other projects in the metrics scope are not evaluated.
type LogMatchOutput struct{ *pulumi.OutputState }

func (LogMatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogMatch)(nil)).Elem()
}

func (o LogMatchOutput) ToLogMatchOutput() LogMatchOutput {
	return o
}

func (o LogMatchOutput) ToLogMatchOutputWithContext(ctx context.Context) LogMatchOutput {
	return o
}

func (o LogMatchOutput) ToLogMatchPtrOutput() LogMatchPtrOutput {
	return o.ToLogMatchPtrOutputWithContext(context.Background())
}

func (o LogMatchOutput) ToLogMatchPtrOutputWithContext(ctx context.Context) LogMatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogMatch) *LogMatch {
		return &v
	}).(LogMatchPtrOutput)
}

// A logs-based filter. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries) for how this filter should be constructed.
func (o LogMatchOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v LogMatch) string { return v.Filter }).(pulumi.StringOutput)
}

// Optional. A map from a label key to an extractor expression, which is used to extract the value for this label key. Each entry in this map is a specification for how data should be extracted from log entries that match filter. Each combination of extracted values is treated as a separate rule for the purposes of triggering notifications. Label keys and corresponding values can be used in notifications generated by this condition.Please see the documentation on logs-based metric valueExtractors (https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor) for syntax and examples.
func (o LogMatchOutput) LabelExtractors() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogMatch) map[string]string { return v.LabelExtractors }).(pulumi.StringMapOutput)
}

type LogMatchPtrOutput struct{ *pulumi.OutputState }

func (LogMatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogMatch)(nil)).Elem()
}

func (o LogMatchPtrOutput) ToLogMatchPtrOutput() LogMatchPtrOutput {
	return o
}

func (o LogMatchPtrOutput) ToLogMatchPtrOutputWithContext(ctx context.Context) LogMatchPtrOutput {
	return o
}

func (o LogMatchPtrOutput) Elem() LogMatchOutput {
	return o.ApplyT(func(v *LogMatch) LogMatch {
		if v != nil {
			return *v
		}
		var ret LogMatch
		return ret
	}).(LogMatchOutput)
}

// A logs-based filter. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries) for how this filter should be constructed.
func (o LogMatchPtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogMatch) *string {
		if v == nil {
			return nil
		}
		return &v.Filter
	}).(pulumi.StringPtrOutput)
}

// Optional. A map from a label key to an extractor expression, which is used to extract the value for this label key. Each entry in this map is a specification for how data should be extracted from log entries that match filter. Each combination of extracted values is treated as a separate rule for the purposes of triggering notifications. Label keys and corresponding values can be used in notifications generated by this condition.Please see the documentation on logs-based metric valueExtractors (https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor) for syntax and examples.
func (o LogMatchPtrOutput) LabelExtractors() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogMatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.LabelExtractors
	}).(pulumi.StringMapOutput)
}

// A condition type that checks whether a log message in the scoping project (https://cloud.google.com/monitoring/api/v3#project_name) satisfies the given filter. Logs from other projects in the metrics scope are not evaluated.
type LogMatchResponse struct {
	// A logs-based filter. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries) for how this filter should be constructed.
	Filter string `pulumi:"filter"`
	// Optional. A map from a label key to an extractor expression, which is used to extract the value for this label key. Each entry in this map is a specification for how data should be extracted from log entries that match filter. Each combination of extracted values is treated as a separate rule for the purposes of triggering notifications. Label keys and corresponding values can be used in notifications generated by this condition.Please see the documentation on logs-based metric valueExtractors (https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor) for syntax and examples.
	LabelExtractors map[string]string `pulumi:"labelExtractors"`
}

// A condition type that checks whether a log message in the scoping project (https://cloud.google.com/monitoring/api/v3#project_name) satisfies the given filter. Logs from other projects in the metrics scope are not evaluated.
type LogMatchResponseOutput struct{ *pulumi.OutputState }

func (LogMatchResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogMatchResponse)(nil)).Elem()
}

func (o LogMatchResponseOutput) ToLogMatchResponseOutput() LogMatchResponseOutput {
	return o
}

func (o LogMatchResponseOutput) ToLogMatchResponseOutputWithContext(ctx context.Context) LogMatchResponseOutput {
	return o
}

// A logs-based filter. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries) for how this filter should be constructed.
func (o LogMatchResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v LogMatchResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// Optional. A map from a label key to an extractor expression, which is used to extract the value for this label key. Each entry in this map is a specification for how data should be extracted from log entries that match filter. Each combination of extracted values is treated as a separate rule for the purposes of triggering notifications. Label keys and corresponding values can be used in notifications generated by this condition.Please see the documentation on logs-based metric valueExtractors (https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor) for syntax and examples.
func (o LogMatchResponseOutput) LabelExtractors() pulumi.StringMapOutput {
	return o.ApplyT(func(v LogMatchResponse) map[string]string { return v.LabelExtractors }).(pulumi.StringMapOutput)
}

// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8 will have their services ingested as this type.
type MeshIstio struct {
	// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
	MeshUid *string `pulumi:"meshUid"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName *string `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace *string `pulumi:"serviceNamespace"`
}

// MeshIstioInput is an input type that accepts MeshIstioArgs and MeshIstioOutput values.
// You can construct a concrete instance of `MeshIstioInput` via:
//
//	MeshIstioArgs{...}
type MeshIstioInput interface {
	pulumi.Input

	ToMeshIstioOutput() MeshIstioOutput
	ToMeshIstioOutputWithContext(context.Context) MeshIstioOutput
}

// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8 will have their services ingested as this type.
type MeshIstioArgs struct {
	// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
	MeshUid pulumi.StringPtrInput `pulumi:"meshUid"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace pulumi.StringPtrInput `pulumi:"serviceNamespace"`
}

func (MeshIstioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MeshIstio)(nil)).Elem()
}

func (i MeshIstioArgs) ToMeshIstioOutput() MeshIstioOutput {
	return i.ToMeshIstioOutputWithContext(context.Background())
}

func (i MeshIstioArgs) ToMeshIstioOutputWithContext(ctx context.Context) MeshIstioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeshIstioOutput)
}

func (i MeshIstioArgs) ToMeshIstioPtrOutput() MeshIstioPtrOutput {
	return i.ToMeshIstioPtrOutputWithContext(context.Background())
}

func (i MeshIstioArgs) ToMeshIstioPtrOutputWithContext(ctx context.Context) MeshIstioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeshIstioOutput).ToMeshIstioPtrOutputWithContext(ctx)
}

// MeshIstioPtrInput is an input type that accepts MeshIstioArgs, MeshIstioPtr and MeshIstioPtrOutput values.
// You can construct a concrete instance of `MeshIstioPtrInput` via:
//
//	        MeshIstioArgs{...}
//
//	or:
//
//	        nil
type MeshIstioPtrInput interface {
	pulumi.Input

	ToMeshIstioPtrOutput() MeshIstioPtrOutput
	ToMeshIstioPtrOutputWithContext(context.Context) MeshIstioPtrOutput
}

type meshIstioPtrType MeshIstioArgs

func MeshIstioPtr(v *MeshIstioArgs) MeshIstioPtrInput {
	return (*meshIstioPtrType)(v)
}

func (*meshIstioPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MeshIstio)(nil)).Elem()
}

func (i *meshIstioPtrType) ToMeshIstioPtrOutput() MeshIstioPtrOutput {
	return i.ToMeshIstioPtrOutputWithContext(context.Background())
}

func (i *meshIstioPtrType) ToMeshIstioPtrOutputWithContext(ctx context.Context) MeshIstioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeshIstioPtrOutput)
}

// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8 will have their services ingested as this type.
type MeshIstioOutput struct{ *pulumi.OutputState }

func (MeshIstioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MeshIstio)(nil)).Elem()
}

func (o MeshIstioOutput) ToMeshIstioOutput() MeshIstioOutput {
	return o
}

func (o MeshIstioOutput) ToMeshIstioOutputWithContext(ctx context.Context) MeshIstioOutput {
	return o
}

func (o MeshIstioOutput) ToMeshIstioPtrOutput() MeshIstioPtrOutput {
	return o.ToMeshIstioPtrOutputWithContext(context.Background())
}

func (o MeshIstioOutput) ToMeshIstioPtrOutputWithContext(ctx context.Context) MeshIstioPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MeshIstio) *MeshIstio {
		return &v
	}).(MeshIstioPtrOutput)
}

// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
func (o MeshIstioOutput) MeshUid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MeshIstio) *string { return v.MeshUid }).(pulumi.StringPtrOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o MeshIstioOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MeshIstio) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o MeshIstioOutput) ServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MeshIstio) *string { return v.ServiceNamespace }).(pulumi.StringPtrOutput)
}

type MeshIstioPtrOutput struct{ *pulumi.OutputState }

func (MeshIstioPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MeshIstio)(nil)).Elem()
}

func (o MeshIstioPtrOutput) ToMeshIstioPtrOutput() MeshIstioPtrOutput {
	return o
}

func (o MeshIstioPtrOutput) ToMeshIstioPtrOutputWithContext(ctx context.Context) MeshIstioPtrOutput {
	return o
}

func (o MeshIstioPtrOutput) Elem() MeshIstioOutput {
	return o.ApplyT(func(v *MeshIstio) MeshIstio {
		if v != nil {
			return *v
		}
		var ret MeshIstio
		return ret
	}).(MeshIstioOutput)
}

// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
func (o MeshIstioPtrOutput) MeshUid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MeshIstio) *string {
		if v == nil {
			return nil
		}
		return v.MeshUid
	}).(pulumi.StringPtrOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o MeshIstioPtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MeshIstio) *string {
		if v == nil {
			return nil
		}
		return v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o MeshIstioPtrOutput) ServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MeshIstio) *string {
		if v == nil {
			return nil
		}
		return v.ServiceNamespace
	}).(pulumi.StringPtrOutput)
}

// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8 will have their services ingested as this type.
type MeshIstioResponse struct {
	// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
	MeshUid string `pulumi:"meshUid"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName string `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace string `pulumi:"serviceNamespace"`
}

// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8 will have their services ingested as this type.
type MeshIstioResponseOutput struct{ *pulumi.OutputState }

func (MeshIstioResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MeshIstioResponse)(nil)).Elem()
}

func (o MeshIstioResponseOutput) ToMeshIstioResponseOutput() MeshIstioResponseOutput {
	return o
}

func (o MeshIstioResponseOutput) ToMeshIstioResponseOutputWithContext(ctx context.Context) MeshIstioResponseOutput {
	return o
}

// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
func (o MeshIstioResponseOutput) MeshUid() pulumi.StringOutput {
	return o.ApplyT(func(v MeshIstioResponse) string { return v.MeshUid }).(pulumi.StringOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o MeshIstioResponseOutput) ServiceName() pulumi.StringOutput {
	return o.ApplyT(func(v MeshIstioResponse) string { return v.ServiceName }).(pulumi.StringOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o MeshIstioResponseOutput) ServiceNamespace() pulumi.StringOutput {
	return o.ApplyT(func(v MeshIstioResponse) string { return v.ServiceNamespace }).(pulumi.StringOutput)
}

// A condition type that checks that monitored resources are reporting data. The configuration defines a metric and a set of monitored resources. The predicate is considered in violation when a time series for the specified metric of a monitored resource does not include any data in the specified duration.
type MetricAbsence struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations []Aggregation `pulumi:"aggregations"`
	// The amount of time that a time series must fail to report new data to be considered failing. The minimum value of this field is 120 seconds. Larger values that are a multiple of a minute--for example, 240 or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
	Duration *string `pulumi:"duration"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter string `pulumi:"filter"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
	Trigger *Trigger `pulumi:"trigger"`
}

// MetricAbsenceInput is an input type that accepts MetricAbsenceArgs and MetricAbsenceOutput values.
// You can construct a concrete instance of `MetricAbsenceInput` via:
//
//	MetricAbsenceArgs{...}
type MetricAbsenceInput interface {
	pulumi.Input

	ToMetricAbsenceOutput() MetricAbsenceOutput
	ToMetricAbsenceOutputWithContext(context.Context) MetricAbsenceOutput
}

// A condition type that checks that monitored resources are reporting data. The configuration defines a metric and a set of monitored resources. The predicate is considered in violation when a time series for the specified metric of a monitored resource does not include any data in the specified duration.
type MetricAbsenceArgs struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations AggregationArrayInput `pulumi:"aggregations"`
	// The amount of time that a time series must fail to report new data to be considered failing. The minimum value of this field is 120 seconds. Larger values that are a multiple of a minute--for example, 240 or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
	Duration pulumi.StringPtrInput `pulumi:"duration"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter pulumi.StringInput `pulumi:"filter"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
	Trigger TriggerPtrInput `pulumi:"trigger"`
}

func (MetricAbsenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricAbsence)(nil)).Elem()
}

func (i MetricAbsenceArgs) ToMetricAbsenceOutput() MetricAbsenceOutput {
	return i.ToMetricAbsenceOutputWithContext(context.Background())
}

func (i MetricAbsenceArgs) ToMetricAbsenceOutputWithContext(ctx context.Context) MetricAbsenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricAbsenceOutput)
}

func (i MetricAbsenceArgs) ToMetricAbsencePtrOutput() MetricAbsencePtrOutput {
	return i.ToMetricAbsencePtrOutputWithContext(context.Background())
}

func (i MetricAbsenceArgs) ToMetricAbsencePtrOutputWithContext(ctx context.Context) MetricAbsencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricAbsenceOutput).ToMetricAbsencePtrOutputWithContext(ctx)
}

// MetricAbsencePtrInput is an input type that accepts MetricAbsenceArgs, MetricAbsencePtr and MetricAbsencePtrOutput values.
// You can construct a concrete instance of `MetricAbsencePtrInput` via:
//
//	        MetricAbsenceArgs{...}
//
//	or:
//
//	        nil
type MetricAbsencePtrInput interface {
	pulumi.Input

	ToMetricAbsencePtrOutput() MetricAbsencePtrOutput
	ToMetricAbsencePtrOutputWithContext(context.Context) MetricAbsencePtrOutput
}

type metricAbsencePtrType MetricAbsenceArgs

func MetricAbsencePtr(v *MetricAbsenceArgs) MetricAbsencePtrInput {
	return (*metricAbsencePtrType)(v)
}

func (*metricAbsencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricAbsence)(nil)).Elem()
}

func (i *metricAbsencePtrType) ToMetricAbsencePtrOutput() MetricAbsencePtrOutput {
	return i.ToMetricAbsencePtrOutputWithContext(context.Background())
}

func (i *metricAbsencePtrType) ToMetricAbsencePtrOutputWithContext(ctx context.Context) MetricAbsencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricAbsencePtrOutput)
}

// A condition type that checks that monitored resources are reporting data. The configuration defines a metric and a set of monitored resources. The predicate is considered in violation when a time series for the specified metric of a monitored resource does not include any data in the specified duration.
type MetricAbsenceOutput struct{ *pulumi.OutputState }

func (MetricAbsenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricAbsence)(nil)).Elem()
}

func (o MetricAbsenceOutput) ToMetricAbsenceOutput() MetricAbsenceOutput {
	return o
}

func (o MetricAbsenceOutput) ToMetricAbsenceOutputWithContext(ctx context.Context) MetricAbsenceOutput {
	return o
}

func (o MetricAbsenceOutput) ToMetricAbsencePtrOutput() MetricAbsencePtrOutput {
	return o.ToMetricAbsencePtrOutputWithContext(context.Background())
}

func (o MetricAbsenceOutput) ToMetricAbsencePtrOutputWithContext(ctx context.Context) MetricAbsencePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MetricAbsence) *MetricAbsence {
		return &v
	}).(MetricAbsencePtrOutput)
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricAbsenceOutput) Aggregations() AggregationArrayOutput {
	return o.ApplyT(func(v MetricAbsence) []Aggregation { return v.Aggregations }).(AggregationArrayOutput)
}

// The amount of time that a time series must fail to report new data to be considered failing. The minimum value of this field is 120 seconds. Larger values that are a multiple of a minute--for example, 240 or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
func (o MetricAbsenceOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricAbsence) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricAbsenceOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v MetricAbsence) string { return v.Filter }).(pulumi.StringOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
func (o MetricAbsenceOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v MetricAbsence) *Trigger { return v.Trigger }).(TriggerPtrOutput)
}

type MetricAbsencePtrOutput struct{ *pulumi.OutputState }

func (MetricAbsencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricAbsence)(nil)).Elem()
}

func (o MetricAbsencePtrOutput) ToMetricAbsencePtrOutput() MetricAbsencePtrOutput {
	return o
}

func (o MetricAbsencePtrOutput) ToMetricAbsencePtrOutputWithContext(ctx context.Context) MetricAbsencePtrOutput {
	return o
}

func (o MetricAbsencePtrOutput) Elem() MetricAbsenceOutput {
	return o.ApplyT(func(v *MetricAbsence) MetricAbsence {
		if v != nil {
			return *v
		}
		var ret MetricAbsence
		return ret
	}).(MetricAbsenceOutput)
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricAbsencePtrOutput) Aggregations() AggregationArrayOutput {
	return o.ApplyT(func(v *MetricAbsence) []Aggregation {
		if v == nil {
			return nil
		}
		return v.Aggregations
	}).(AggregationArrayOutput)
}

// The amount of time that a time series must fail to report new data to be considered failing. The minimum value of this field is 120 seconds. Larger values that are a multiple of a minute--for example, 240 or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
func (o MetricAbsencePtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricAbsence) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricAbsencePtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricAbsence) *string {
		if v == nil {
			return nil
		}
		return &v.Filter
	}).(pulumi.StringPtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
func (o MetricAbsencePtrOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v *MetricAbsence) *Trigger {
		if v == nil {
			return nil
		}
		return v.Trigger
	}).(TriggerPtrOutput)
}

// A condition type that checks that monitored resources are reporting data. The configuration defines a metric and a set of monitored resources. The predicate is considered in violation when a time series for the specified metric of a monitored resource does not include any data in the specified duration.
type MetricAbsenceResponse struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations []AggregationResponse `pulumi:"aggregations"`
	// The amount of time that a time series must fail to report new data to be considered failing. The minimum value of this field is 120 seconds. Larger values that are a multiple of a minute--for example, 240 or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
	Duration string `pulumi:"duration"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter string `pulumi:"filter"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
	Trigger TriggerResponse `pulumi:"trigger"`
}

// A condition type that checks that monitored resources are reporting data. The configuration defines a metric and a set of monitored resources. The predicate is considered in violation when a time series for the specified metric of a monitored resource does not include any data in the specified duration.
type MetricAbsenceResponseOutput struct{ *pulumi.OutputState }

func (MetricAbsenceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricAbsenceResponse)(nil)).Elem()
}

func (o MetricAbsenceResponseOutput) ToMetricAbsenceResponseOutput() MetricAbsenceResponseOutput {
	return o
}

func (o MetricAbsenceResponseOutput) ToMetricAbsenceResponseOutputWithContext(ctx context.Context) MetricAbsenceResponseOutput {
	return o
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricAbsenceResponseOutput) Aggregations() AggregationResponseArrayOutput {
	return o.ApplyT(func(v MetricAbsenceResponse) []AggregationResponse { return v.Aggregations }).(AggregationResponseArrayOutput)
}

// The amount of time that a time series must fail to report new data to be considered failing. The minimum value of this field is 120 seconds. Larger values that are a multiple of a minute--for example, 240 or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
func (o MetricAbsenceResponseOutput) Duration() pulumi.StringOutput {
	return o.ApplyT(func(v MetricAbsenceResponse) string { return v.Duration }).(pulumi.StringOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricAbsenceResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v MetricAbsenceResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
func (o MetricAbsenceResponseOutput) Trigger() TriggerResponseOutput {
	return o.ApplyT(func(v MetricAbsenceResponse) TriggerResponse { return v.Trigger }).(TriggerResponseOutput)
}

// Additional annotations that can be used to guide the usage of a metric.
type MetricDescriptorMetadata struct {
	// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
	IngestDelay *string `pulumi:"ingestDelay"`
	// Deprecated. Must use the MetricDescriptor.launch_stage instead.
	//
	// Deprecated: Deprecated. Must use the MetricDescriptor.launch_stage instead.
	LaunchStage *MetricDescriptorMetadataLaunchStage `pulumi:"launchStage"`
	// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
	SamplePeriod *string `pulumi:"samplePeriod"`
}

// MetricDescriptorMetadataInput is an input type that accepts MetricDescriptorMetadataArgs and MetricDescriptorMetadataOutput values.
// You can construct a concrete instance of `MetricDescriptorMetadataInput` via:
//
//	MetricDescriptorMetadataArgs{...}
type MetricDescriptorMetadataInput interface {
	pulumi.Input

	ToMetricDescriptorMetadataOutput() MetricDescriptorMetadataOutput
	ToMetricDescriptorMetadataOutputWithContext(context.Context) MetricDescriptorMetadataOutput
}

// Additional annotations that can be used to guide the usage of a metric.
type MetricDescriptorMetadataArgs struct {
	// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
	IngestDelay pulumi.StringPtrInput `pulumi:"ingestDelay"`
	// Deprecated. Must use the MetricDescriptor.launch_stage instead.
	//
	// Deprecated: Deprecated. Must use the MetricDescriptor.launch_stage instead.
	LaunchStage MetricDescriptorMetadataLaunchStagePtrInput `pulumi:"launchStage"`
	// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
	SamplePeriod pulumi.StringPtrInput `pulumi:"samplePeriod"`
}

func (MetricDescriptorMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricDescriptorMetadata)(nil)).Elem()
}

func (i MetricDescriptorMetadataArgs) ToMetricDescriptorMetadataOutput() MetricDescriptorMetadataOutput {
	return i.ToMetricDescriptorMetadataOutputWithContext(context.Background())
}

func (i MetricDescriptorMetadataArgs) ToMetricDescriptorMetadataOutputWithContext(ctx context.Context) MetricDescriptorMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricDescriptorMetadataOutput)
}

func (i MetricDescriptorMetadataArgs) ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput {
	return i.ToMetricDescriptorMetadataPtrOutputWithContext(context.Background())
}

func (i MetricDescriptorMetadataArgs) ToMetricDescriptorMetadataPtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricDescriptorMetadataOutput).ToMetricDescriptorMetadataPtrOutputWithContext(ctx)
}

// MetricDescriptorMetadataPtrInput is an input type that accepts MetricDescriptorMetadataArgs, MetricDescriptorMetadataPtr and MetricDescriptorMetadataPtrOutput values.
// You can construct a concrete instance of `MetricDescriptorMetadataPtrInput` via:
//
//	        MetricDescriptorMetadataArgs{...}
//
//	or:
//
//	        nil
type MetricDescriptorMetadataPtrInput interface {
	pulumi.Input

	ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput
	ToMetricDescriptorMetadataPtrOutputWithContext(context.Context) MetricDescriptorMetadataPtrOutput
}

type metricDescriptorMetadataPtrType MetricDescriptorMetadataArgs

func MetricDescriptorMetadataPtr(v *MetricDescriptorMetadataArgs) MetricDescriptorMetadataPtrInput {
	return (*metricDescriptorMetadataPtrType)(v)
}

func (*metricDescriptorMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricDescriptorMetadata)(nil)).Elem()
}

func (i *metricDescriptorMetadataPtrType) ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput {
	return i.ToMetricDescriptorMetadataPtrOutputWithContext(context.Background())
}

func (i *metricDescriptorMetadataPtrType) ToMetricDescriptorMetadataPtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricDescriptorMetadataPtrOutput)
}

// Additional annotations that can be used to guide the usage of a metric.
type MetricDescriptorMetadataOutput struct{ *pulumi.OutputState }

func (MetricDescriptorMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricDescriptorMetadata)(nil)).Elem()
}

func (o MetricDescriptorMetadataOutput) ToMetricDescriptorMetadataOutput() MetricDescriptorMetadataOutput {
	return o
}

func (o MetricDescriptorMetadataOutput) ToMetricDescriptorMetadataOutputWithContext(ctx context.Context) MetricDescriptorMetadataOutput {
	return o
}

func (o MetricDescriptorMetadataOutput) ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput {
	return o.ToMetricDescriptorMetadataPtrOutputWithContext(context.Background())
}

func (o MetricDescriptorMetadataOutput) ToMetricDescriptorMetadataPtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MetricDescriptorMetadata) *MetricDescriptorMetadata {
		return &v
	}).(MetricDescriptorMetadataPtrOutput)
}

// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
func (o MetricDescriptorMetadataOutput) IngestDelay() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricDescriptorMetadata) *string { return v.IngestDelay }).(pulumi.StringPtrOutput)
}

// Deprecated. Must use the MetricDescriptor.launch_stage instead.
//
// Deprecated: Deprecated. Must use the MetricDescriptor.launch_stage instead.
func (o MetricDescriptorMetadataOutput) LaunchStage() MetricDescriptorMetadataLaunchStagePtrOutput {
	return o.ApplyT(func(v MetricDescriptorMetadata) *MetricDescriptorMetadataLaunchStage { return v.LaunchStage }).(MetricDescriptorMetadataLaunchStagePtrOutput)
}

// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
func (o MetricDescriptorMetadataOutput) SamplePeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricDescriptorMetadata) *string { return v.SamplePeriod }).(pulumi.StringPtrOutput)
}

type MetricDescriptorMetadataPtrOutput struct{ *pulumi.OutputState }

func (MetricDescriptorMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricDescriptorMetadata)(nil)).Elem()
}

func (o MetricDescriptorMetadataPtrOutput) ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput {
	return o
}

func (o MetricDescriptorMetadataPtrOutput) ToMetricDescriptorMetadataPtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataPtrOutput {
	return o
}

func (o MetricDescriptorMetadataPtrOutput) Elem() MetricDescriptorMetadataOutput {
	return o.ApplyT(func(v *MetricDescriptorMetadata) MetricDescriptorMetadata {
		if v != nil {
			return *v
		}
		var ret MetricDescriptorMetadata
		return ret
	}).(MetricDescriptorMetadataOutput)
}

// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
func (o MetricDescriptorMetadataPtrOutput) IngestDelay() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricDescriptorMetadata) *string {
		if v == nil {
			return nil
		}
		return v.IngestDelay
	}).(pulumi.StringPtrOutput)
}

// Deprecated. Must use the MetricDescriptor.launch_stage instead.
//
// Deprecated: Deprecated. Must use the MetricDescriptor.launch_stage instead.
func (o MetricDescriptorMetadataPtrOutput) LaunchStage() MetricDescriptorMetadataLaunchStagePtrOutput {
	return o.ApplyT(func(v *MetricDescriptorMetadata) *MetricDescriptorMetadataLaunchStage {
		if v == nil {
			return nil
		}
		return v.LaunchStage
	}).(MetricDescriptorMetadataLaunchStagePtrOutput)
}

// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
func (o MetricDescriptorMetadataPtrOutput) SamplePeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricDescriptorMetadata) *string {
		if v == nil {
			return nil
		}
		return v.SamplePeriod
	}).(pulumi.StringPtrOutput)
}

// Additional annotations that can be used to guide the usage of a metric.
type MetricDescriptorMetadataResponse struct {
	// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
	IngestDelay string `pulumi:"ingestDelay"`
	// Deprecated. Must use the MetricDescriptor.launch_stage instead.
	//
	// Deprecated: Deprecated. Must use the MetricDescriptor.launch_stage instead.
	LaunchStage string `pulumi:"launchStage"`
	// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
	SamplePeriod string `pulumi:"samplePeriod"`
}

// Additional annotations that can be used to guide the usage of a metric.
type MetricDescriptorMetadataResponseOutput struct{ *pulumi.OutputState }

func (MetricDescriptorMetadataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricDescriptorMetadataResponse)(nil)).Elem()
}

func (o MetricDescriptorMetadataResponseOutput) ToMetricDescriptorMetadataResponseOutput() MetricDescriptorMetadataResponseOutput {
	return o
}

func (o MetricDescriptorMetadataResponseOutput) ToMetricDescriptorMetadataResponseOutputWithContext(ctx context.Context) MetricDescriptorMetadataResponseOutput {
	return o
}

// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
func (o MetricDescriptorMetadataResponseOutput) IngestDelay() pulumi.StringOutput {
	return o.ApplyT(func(v MetricDescriptorMetadataResponse) string { return v.IngestDelay }).(pulumi.StringOutput)
}

// Deprecated. Must use the MetricDescriptor.launch_stage instead.
//
// Deprecated: Deprecated. Must use the MetricDescriptor.launch_stage instead.
func (o MetricDescriptorMetadataResponseOutput) LaunchStage() pulumi.StringOutput {
	return o.ApplyT(func(v MetricDescriptorMetadataResponse) string { return v.LaunchStage }).(pulumi.StringOutput)
}

// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
func (o MetricDescriptorMetadataResponseOutput) SamplePeriod() pulumi.StringOutput {
	return o.ApplyT(func(v MetricDescriptorMetadataResponse) string { return v.SamplePeriod }).(pulumi.StringOutput)
}

// A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x <= range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
type MetricRange struct {
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range *GoogleMonitoringV3Range `pulumi:"range"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
	TimeSeries *string `pulumi:"timeSeries"`
}

// MetricRangeInput is an input type that accepts MetricRangeArgs and MetricRangeOutput values.
// You can construct a concrete instance of `MetricRangeInput` via:
//
//	MetricRangeArgs{...}
type MetricRangeInput interface {
	pulumi.Input

	ToMetricRangeOutput() MetricRangeOutput
	ToMetricRangeOutputWithContext(context.Context) MetricRangeOutput
}

// A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x <= range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
type MetricRangeArgs struct {
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range GoogleMonitoringV3RangePtrInput `pulumi:"range"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
	TimeSeries pulumi.StringPtrInput `pulumi:"timeSeries"`
}

func (MetricRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricRange)(nil)).Elem()
}

func (i MetricRangeArgs) ToMetricRangeOutput() MetricRangeOutput {
	return i.ToMetricRangeOutputWithContext(context.Background())
}

func (i MetricRangeArgs) ToMetricRangeOutputWithContext(ctx context.Context) MetricRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricRangeOutput)
}

func (i MetricRangeArgs) ToMetricRangePtrOutput() MetricRangePtrOutput {
	return i.ToMetricRangePtrOutputWithContext(context.Background())
}

func (i MetricRangeArgs) ToMetricRangePtrOutputWithContext(ctx context.Context) MetricRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricRangeOutput).ToMetricRangePtrOutputWithContext(ctx)
}

// MetricRangePtrInput is an input type that accepts MetricRangeArgs, MetricRangePtr and MetricRangePtrOutput values.
// You can construct a concrete instance of `MetricRangePtrInput` via:
//
//	        MetricRangeArgs{...}
//
//	or:
//
//	        nil
type MetricRangePtrInput interface {
	pulumi.Input

	ToMetricRangePtrOutput() MetricRangePtrOutput
	ToMetricRangePtrOutputWithContext(context.Context) MetricRangePtrOutput
}

type metricRangePtrType MetricRangeArgs

func MetricRangePtr(v *MetricRangeArgs) MetricRangePtrInput {
	return (*metricRangePtrType)(v)
}

func (*metricRangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricRange)(nil)).Elem()
}

func (i *metricRangePtrType) ToMetricRangePtrOutput() MetricRangePtrOutput {
	return i.ToMetricRangePtrOutputWithContext(context.Background())
}

func (i *metricRangePtrType) ToMetricRangePtrOutputWithContext(ctx context.Context) MetricRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricRangePtrOutput)
}

// A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x <= range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
type MetricRangeOutput struct{ *pulumi.OutputState }

func (MetricRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricRange)(nil)).Elem()
}

func (o MetricRangeOutput) ToMetricRangeOutput() MetricRangeOutput {
	return o
}

func (o MetricRangeOutput) ToMetricRangeOutputWithContext(ctx context.Context) MetricRangeOutput {
	return o
}

func (o MetricRangeOutput) ToMetricRangePtrOutput() MetricRangePtrOutput {
	return o.ToMetricRangePtrOutputWithContext(context.Background())
}

func (o MetricRangeOutput) ToMetricRangePtrOutputWithContext(ctx context.Context) MetricRangePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MetricRange) *MetricRange {
		return &v
	}).(MetricRangePtrOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o MetricRangeOutput) Range() GoogleMonitoringV3RangePtrOutput {
	return o.ApplyT(func(v MetricRange) *GoogleMonitoringV3Range { return v.Range }).(GoogleMonitoringV3RangePtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
func (o MetricRangeOutput) TimeSeries() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricRange) *string { return v.TimeSeries }).(pulumi.StringPtrOutput)
}

type MetricRangePtrOutput struct{ *pulumi.OutputState }

func (MetricRangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricRange)(nil)).Elem()
}

func (o MetricRangePtrOutput) ToMetricRangePtrOutput() MetricRangePtrOutput {
	return o
}

func (o MetricRangePtrOutput) ToMetricRangePtrOutputWithContext(ctx context.Context) MetricRangePtrOutput {
	return o
}

func (o MetricRangePtrOutput) Elem() MetricRangeOutput {
	return o.ApplyT(func(v *MetricRange) MetricRange {
		if v != nil {
			return *v
		}
		var ret MetricRange
		return ret
	}).(MetricRangeOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o MetricRangePtrOutput) Range() GoogleMonitoringV3RangePtrOutput {
	return o.ApplyT(func(v *MetricRange) *GoogleMonitoringV3Range {
		if v == nil {
			return nil
		}
		return v.Range
	}).(GoogleMonitoringV3RangePtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
func (o MetricRangePtrOutput) TimeSeries() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricRange) *string {
		if v == nil {
			return nil
		}
		return v.TimeSeries
	}).(pulumi.StringPtrOutput)
}

// A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x <= range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
type MetricRangeResponse struct {
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range GoogleMonitoringV3RangeResponse `pulumi:"range"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
	TimeSeries string `pulumi:"timeSeries"`
}

// A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x <= range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
type MetricRangeResponseOutput struct{ *pulumi.OutputState }

func (MetricRangeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricRangeResponse)(nil)).Elem()
}

func (o MetricRangeResponseOutput) ToMetricRangeResponseOutput() MetricRangeResponseOutput {
	return o
}

func (o MetricRangeResponseOutput) ToMetricRangeResponseOutputWithContext(ctx context.Context) MetricRangeResponseOutput {
	return o
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o MetricRangeResponseOutput) Range() GoogleMonitoringV3RangeResponseOutput {
	return o.ApplyT(func(v MetricRangeResponse) GoogleMonitoringV3RangeResponse { return v.Range }).(GoogleMonitoringV3RangeResponseOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
func (o MetricRangeResponseOutput) TimeSeries() pulumi.StringOutput {
	return o.ApplyT(func(v MetricRangeResponse) string { return v.TimeSeries }).(pulumi.StringOutput)
}

// A condition type that compares a collection of time series against a threshold.
type MetricThreshold struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations []Aggregation `pulumi:"aggregations"`
	// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
	Comparison *MetricThresholdComparison `pulumi:"comparison"`
	// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
	DenominatorAggregations []Aggregation `pulumi:"denominatorAggregations"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
	DenominatorFilter *string `pulumi:"denominatorFilter"`
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration *string `pulumi:"duration"`
	// A condition control that determines how metric-threshold conditions are evaluated when data stops arriving.
	EvaluationMissingData *MetricThresholdEvaluationMissingData `pulumi:"evaluationMissingData"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter string `pulumi:"filter"`
	// When this field is present, the MetricThreshold condition forecasts whether the time series is predicted to violate the threshold within the forecast_horizon. When this field is not set, the MetricThreshold tests the current value of the timeseries against the threshold.
	ForecastOptions *ForecastOptions `pulumi:"forecastOptions"`
	// A value against which to compare the time series.
	ThresholdValue *float64 `pulumi:"thresholdValue"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger *Trigger `pulumi:"trigger"`
}

// MetricThresholdInput is an input type that accepts MetricThresholdArgs and MetricThresholdOutput values.
// You can construct a concrete instance of `MetricThresholdInput` via:
//
//	MetricThresholdArgs{...}
type MetricThresholdInput interface {
	pulumi.Input

	ToMetricThresholdOutput() MetricThresholdOutput
	ToMetricThresholdOutputWithContext(context.Context) MetricThresholdOutput
}

// A condition type that compares a collection of time series against a threshold.
type MetricThresholdArgs struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations AggregationArrayInput `pulumi:"aggregations"`
	// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
	Comparison MetricThresholdComparisonPtrInput `pulumi:"comparison"`
	// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
	DenominatorAggregations AggregationArrayInput `pulumi:"denominatorAggregations"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
	DenominatorFilter pulumi.StringPtrInput `pulumi:"denominatorFilter"`
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration pulumi.StringPtrInput `pulumi:"duration"`
	// A condition control that determines how metric-threshold conditions are evaluated when data stops arriving.
	EvaluationMissingData MetricThresholdEvaluationMissingDataPtrInput `pulumi:"evaluationMissingData"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter pulumi.StringInput `pulumi:"filter"`
	// When this field is present, the MetricThreshold condition forecasts whether the time series is predicted to violate the threshold within the forecast_horizon. When this field is not set, the MetricThreshold tests the current value of the timeseries against the threshold.
	ForecastOptions ForecastOptionsPtrInput `pulumi:"forecastOptions"`
	// A value against which to compare the time series.
	ThresholdValue pulumi.Float64PtrInput `pulumi:"thresholdValue"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger TriggerPtrInput `pulumi:"trigger"`
}

func (MetricThresholdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricThreshold)(nil)).Elem()
}

func (i MetricThresholdArgs) ToMetricThresholdOutput() MetricThresholdOutput {
	return i.ToMetricThresholdOutputWithContext(context.Background())
}

func (i MetricThresholdArgs) ToMetricThresholdOutputWithContext(ctx context.Context) MetricThresholdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricThresholdOutput)
}

func (i MetricThresholdArgs) ToMetricThresholdPtrOutput() MetricThresholdPtrOutput {
	return i.ToMetricThresholdPtrOutputWithContext(context.Background())
}

func (i MetricThresholdArgs) ToMetricThresholdPtrOutputWithContext(ctx context.Context) MetricThresholdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricThresholdOutput).ToMetricThresholdPtrOutputWithContext(ctx)
}

// MetricThresholdPtrInput is an input type that accepts MetricThresholdArgs, MetricThresholdPtr and MetricThresholdPtrOutput values.
// You can construct a concrete instance of `MetricThresholdPtrInput` via:
//
//	        MetricThresholdArgs{...}
//
//	or:
//
//	        nil
type MetricThresholdPtrInput interface {
	pulumi.Input

	ToMetricThresholdPtrOutput() MetricThresholdPtrOutput
	ToMetricThresholdPtrOutputWithContext(context.Context) MetricThresholdPtrOutput
}

type metricThresholdPtrType MetricThresholdArgs

func MetricThresholdPtr(v *MetricThresholdArgs) MetricThresholdPtrInput {
	return (*metricThresholdPtrType)(v)
}

func (*metricThresholdPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricThreshold)(nil)).Elem()
}

func (i *metricThresholdPtrType) ToMetricThresholdPtrOutput() MetricThresholdPtrOutput {
	return i.ToMetricThresholdPtrOutputWithContext(context.Background())
}

func (i *metricThresholdPtrType) ToMetricThresholdPtrOutputWithContext(ctx context.Context) MetricThresholdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricThresholdPtrOutput)
}

// A condition type that compares a collection of time series against a threshold.
type MetricThresholdOutput struct{ *pulumi.OutputState }

func (MetricThresholdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricThreshold)(nil)).Elem()
}

func (o MetricThresholdOutput) ToMetricThresholdOutput() MetricThresholdOutput {
	return o
}

func (o MetricThresholdOutput) ToMetricThresholdOutputWithContext(ctx context.Context) MetricThresholdOutput {
	return o
}

func (o MetricThresholdOutput) ToMetricThresholdPtrOutput() MetricThresholdPtrOutput {
	return o.ToMetricThresholdPtrOutputWithContext(context.Background())
}

func (o MetricThresholdOutput) ToMetricThresholdPtrOutputWithContext(ctx context.Context) MetricThresholdPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MetricThreshold) *MetricThreshold {
		return &v
	}).(MetricThresholdPtrOutput)
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricThresholdOutput) Aggregations() AggregationArrayOutput {
	return o.ApplyT(func(v MetricThreshold) []Aggregation { return v.Aggregations }).(AggregationArrayOutput)
}

// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
func (o MetricThresholdOutput) Comparison() MetricThresholdComparisonPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *MetricThresholdComparison { return v.Comparison }).(MetricThresholdComparisonPtrOutput)
}

// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
func (o MetricThresholdOutput) DenominatorAggregations() AggregationArrayOutput {
	return o.ApplyT(func(v MetricThreshold) []Aggregation { return v.DenominatorAggregations }).(AggregationArrayOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
func (o MetricThresholdOutput) DenominatorFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *string { return v.DenominatorFilter }).(pulumi.StringPtrOutput)
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MetricThresholdOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// A condition control that determines how metric-threshold conditions are evaluated when data stops arriving.
func (o MetricThresholdOutput) EvaluationMissingData() MetricThresholdEvaluationMissingDataPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *MetricThresholdEvaluationMissingData { return v.EvaluationMissingData }).(MetricThresholdEvaluationMissingDataPtrOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricThresholdOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v MetricThreshold) string { return v.Filter }).(pulumi.StringOutput)
}

// When this field is present, the MetricThreshold condition forecasts whether the time series is predicted to violate the threshold within the forecast_horizon. When this field is not set, the MetricThreshold tests the current value of the timeseries against the threshold.
func (o MetricThresholdOutput) ForecastOptions() ForecastOptionsPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *ForecastOptions { return v.ForecastOptions }).(ForecastOptionsPtrOutput)
}

// A value against which to compare the time series.
func (o MetricThresholdOutput) ThresholdValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v MetricThreshold) *float64 { return v.ThresholdValue }).(pulumi.Float64PtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MetricThresholdOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *Trigger { return v.Trigger }).(TriggerPtrOutput)
}

type MetricThresholdPtrOutput struct{ *pulumi.OutputState }

func (MetricThresholdPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricThreshold)(nil)).Elem()
}

func (o MetricThresholdPtrOutput) ToMetricThresholdPtrOutput() MetricThresholdPtrOutput {
	return o
}

func (o MetricThresholdPtrOutput) ToMetricThresholdPtrOutputWithContext(ctx context.Context) MetricThresholdPtrOutput {
	return o
}

func (o MetricThresholdPtrOutput) Elem() MetricThresholdOutput {
	return o.ApplyT(func(v *MetricThreshold) MetricThreshold {
		if v != nil {
			return *v
		}
		var ret MetricThreshold
		return ret
	}).(MetricThresholdOutput)
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricThresholdPtrOutput) Aggregations() AggregationArrayOutput {
	return o.ApplyT(func(v *MetricThreshold) []Aggregation {
		if v == nil {
			return nil
		}
		return v.Aggregations
	}).(AggregationArrayOutput)
}

// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
func (o MetricThresholdPtrOutput) Comparison() MetricThresholdComparisonPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *MetricThresholdComparison {
		if v == nil {
			return nil
		}
		return v.Comparison
	}).(MetricThresholdComparisonPtrOutput)
}

// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
func (o MetricThresholdPtrOutput) DenominatorAggregations() AggregationArrayOutput {
	return o.ApplyT(func(v *MetricThreshold) []Aggregation {
		if v == nil {
			return nil
		}
		return v.DenominatorAggregations
	}).(AggregationArrayOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
func (o MetricThresholdPtrOutput) DenominatorFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *string {
		if v == nil {
			return nil
		}
		return v.DenominatorFilter
	}).(pulumi.StringPtrOutput)
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MetricThresholdPtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// A condition control that determines how metric-threshold conditions are evaluated when data stops arriving.
func (o MetricThresholdPtrOutput) EvaluationMissingData() MetricThresholdEvaluationMissingDataPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *MetricThresholdEvaluationMissingData {
		if v == nil {
			return nil
		}
		return v.EvaluationMissingData
	}).(MetricThresholdEvaluationMissingDataPtrOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricThresholdPtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *string {
		if v == nil {
			return nil
		}
		return &v.Filter
	}).(pulumi.StringPtrOutput)
}

// When this field is present, the MetricThreshold condition forecasts whether the time series is predicted to violate the threshold within the forecast_horizon. When this field is not set, the MetricThreshold tests the current value of the timeseries against the threshold.
func (o MetricThresholdPtrOutput) ForecastOptions() ForecastOptionsPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *ForecastOptions {
		if v == nil {
			return nil
		}
		return v.ForecastOptions
	}).(ForecastOptionsPtrOutput)
}

// A value against which to compare the time series.
func (o MetricThresholdPtrOutput) ThresholdValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *float64 {
		if v == nil {
			return nil
		}
		return v.ThresholdValue
	}).(pulumi.Float64PtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MetricThresholdPtrOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *Trigger {
		if v == nil {
			return nil
		}
		return v.Trigger
	}).(TriggerPtrOutput)
}

// A condition type that compares a collection of time series against a threshold.
type MetricThresholdResponse struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations []AggregationResponse `pulumi:"aggregations"`
	// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
	Comparison string `pulumi:"comparison"`
	// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
	DenominatorAggregations []AggregationResponse `pulumi:"denominatorAggregations"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
	DenominatorFilter string `pulumi:"denominatorFilter"`
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration string `pulumi:"duration"`
	// A condition control that determines how metric-threshold conditions are evaluated when data stops arriving.
	EvaluationMissingData string `pulumi:"evaluationMissingData"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter string `pulumi:"filter"`
	// When this field is present, the MetricThreshold condition forecasts whether the time series is predicted to violate the threshold within the forecast_horizon. When this field is not set, the MetricThreshold tests the current value of the timeseries against the threshold.
	ForecastOptions ForecastOptionsResponse `pulumi:"forecastOptions"`
	// A value against which to compare the time series.
	ThresholdValue float64 `pulumi:"thresholdValue"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger TriggerResponse `pulumi:"trigger"`
}

// A condition type that compares a collection of time series against a threshold.
type MetricThresholdResponseOutput struct{ *pulumi.OutputState }

func (MetricThresholdResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricThresholdResponse)(nil)).Elem()
}

func (o MetricThresholdResponseOutput) ToMetricThresholdResponseOutput() MetricThresholdResponseOutput {
	return o
}

func (o MetricThresholdResponseOutput) ToMetricThresholdResponseOutputWithContext(ctx context.Context) MetricThresholdResponseOutput {
	return o
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricThresholdResponseOutput) Aggregations() AggregationResponseArrayOutput {
	return o.ApplyT(func(v MetricThresholdResponse) []AggregationResponse { return v.Aggregations }).(AggregationResponseArrayOutput)
}

// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
func (o MetricThresholdResponseOutput) Comparison() pulumi.StringOutput {
	return o.ApplyT(func(v MetricThresholdResponse) string { return v.Comparison }).(pulumi.StringOutput)
}

// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
func (o MetricThresholdResponseOutput) DenominatorAggregations() AggregationResponseArrayOutput {
	return o.ApplyT(func(v MetricThresholdResponse) []AggregationResponse { return v.DenominatorAggregations }).(AggregationResponseArrayOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
func (o MetricThresholdResponseOutput) DenominatorFilter() pulumi.StringOutput {
	return o.ApplyT(func(v MetricThresholdResponse) string { return v.DenominatorFilter }).(pulumi.StringOutput)
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MetricThresholdResponseOutput) Duration() pulumi.StringOutput {
	return o.ApplyT(func(v MetricThresholdResponse) string { return v.Duration }).(pulumi.StringOutput)
}

// A condition control that determines how metric-threshold conditions are evaluated when data stops arriving.
func (o MetricThresholdResponseOutput) EvaluationMissingData() pulumi.StringOutput {
	return o.ApplyT(func(v MetricThresholdResponse) string { return v.EvaluationMissingData }).(pulumi.StringOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricThresholdResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v MetricThresholdResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// When this field is present, the MetricThreshold condition forecasts whether the time series is predicted to violate the threshold within the forecast_horizon. When this field is not set, the MetricThreshold tests the current value of the timeseries against the threshold.
func (o MetricThresholdResponseOutput) ForecastOptions() ForecastOptionsResponseOutput {
	return o.ApplyT(func(v MetricThresholdResponse) ForecastOptionsResponse { return v.ForecastOptions }).(ForecastOptionsResponseOutput)
}

// A value against which to compare the time series.
func (o MetricThresholdResponseOutput) ThresholdValue() pulumi.Float64Output {
	return o.ApplyT(func(v MetricThresholdResponse) float64 { return v.ThresholdValue }).(pulumi.Float64Output)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MetricThresholdResponseOutput) Trigger() TriggerResponseOutput {
	return o.ApplyT(func(v MetricThresholdResponse) TriggerResponse { return v.Trigger }).(TriggerResponseOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResource struct {
	// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels map[string]string `pulumi:"labels"`
	// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
	Type string `pulumi:"type"`
}

// MonitoredResourceInput is an input type that accepts MonitoredResourceArgs and MonitoredResourceOutput values.
// You can construct a concrete instance of `MonitoredResourceInput` via:
//
//	MonitoredResourceArgs{...}
type MonitoredResourceInput interface {
	pulumi.Input

	ToMonitoredResourceOutput() MonitoredResourceOutput
	ToMonitoredResourceOutputWithContext(context.Context) MonitoredResourceOutput
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceArgs struct {
	// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
	Type pulumi.StringInput `pulumi:"type"`
}

func (MonitoredResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResource)(nil)).Elem()
}

func (i MonitoredResourceArgs) ToMonitoredResourceOutput() MonitoredResourceOutput {
	return i.ToMonitoredResourceOutputWithContext(context.Background())
}

func (i MonitoredResourceArgs) ToMonitoredResourceOutputWithContext(ctx context.Context) MonitoredResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceOutput)
}

func (i MonitoredResourceArgs) ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput {
	return i.ToMonitoredResourcePtrOutputWithContext(context.Background())
}

func (i MonitoredResourceArgs) ToMonitoredResourcePtrOutputWithContext(ctx context.Context) MonitoredResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceOutput).ToMonitoredResourcePtrOutputWithContext(ctx)
}

// MonitoredResourcePtrInput is an input type that accepts MonitoredResourceArgs, MonitoredResourcePtr and MonitoredResourcePtrOutput values.
// You can construct a concrete instance of `MonitoredResourcePtrInput` via:
//
//	        MonitoredResourceArgs{...}
//
//	or:
//
//	        nil
type MonitoredResourcePtrInput interface {
	pulumi.Input

	ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput
	ToMonitoredResourcePtrOutputWithContext(context.Context) MonitoredResourcePtrOutput
}

type monitoredResourcePtrType MonitoredResourceArgs

func MonitoredResourcePtr(v *MonitoredResourceArgs) MonitoredResourcePtrInput {
	return (*monitoredResourcePtrType)(v)
}

func (*monitoredResourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoredResource)(nil)).Elem()
}

func (i *monitoredResourcePtrType) ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput {
	return i.ToMonitoredResourcePtrOutputWithContext(context.Background())
}

func (i *monitoredResourcePtrType) ToMonitoredResourcePtrOutputWithContext(ctx context.Context) MonitoredResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourcePtrOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceOutput struct{ *pulumi.OutputState }

func (MonitoredResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResource)(nil)).Elem()
}

func (o MonitoredResourceOutput) ToMonitoredResourceOutput() MonitoredResourceOutput {
	return o
}

func (o MonitoredResourceOutput) ToMonitoredResourceOutputWithContext(ctx context.Context) MonitoredResourceOutput {
	return o
}

func (o MonitoredResourceOutput) ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput {
	return o.ToMonitoredResourcePtrOutputWithContext(context.Background())
}

func (o MonitoredResourceOutput) ToMonitoredResourcePtrOutputWithContext(ctx context.Context) MonitoredResourcePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MonitoredResource) *MonitoredResource {
		return &v
	}).(MonitoredResourcePtrOutput)
}

// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
func (o MonitoredResourceOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v MonitoredResource) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
func (o MonitoredResourceOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v MonitoredResource) string { return v.Type }).(pulumi.StringOutput)
}

type MonitoredResourcePtrOutput struct{ *pulumi.OutputState }

func (MonitoredResourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoredResource)(nil)).Elem()
}

func (o MonitoredResourcePtrOutput) ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput {
	return o
}

func (o MonitoredResourcePtrOutput) ToMonitoredResourcePtrOutputWithContext(ctx context.Context) MonitoredResourcePtrOutput {
	return o
}

func (o MonitoredResourcePtrOutput) Elem() MonitoredResourceOutput {
	return o.ApplyT(func(v *MonitoredResource) MonitoredResource {
		if v != nil {
			return *v
		}
		var ret MonitoredResource
		return ret
	}).(MonitoredResourceOutput)
}

// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
func (o MonitoredResourcePtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *MonitoredResource) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
func (o MonitoredResourcePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MonitoredResource) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceResponse struct {
	// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels map[string]string `pulumi:"labels"`
	// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
	Type string `pulumi:"type"`
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceResponseOutput struct{ *pulumi.OutputState }

func (MonitoredResourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResourceResponse)(nil)).Elem()
}

func (o MonitoredResourceResponseOutput) ToMonitoredResourceResponseOutput() MonitoredResourceResponseOutput {
	return o
}

func (o MonitoredResourceResponseOutput) ToMonitoredResourceResponseOutputWithContext(ctx context.Context) MonitoredResourceResponseOutput {
	return o
}

// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
func (o MonitoredResourceResponseOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v MonitoredResourceResponse) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
func (o MonitoredResourceResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v MonitoredResourceResponse) string { return v.Type }).(pulumi.StringOutput)
}

// A condition type that allows alert policies to be defined using Monitoring Query Language (https://cloud.google.com/monitoring/mql).
type MonitoringQueryLanguageCondition struct {
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration *string `pulumi:"duration"`
	// A condition control that determines how metric-threshold conditions are evaluated when data stops arriving.
	EvaluationMissingData *MonitoringQueryLanguageConditionEvaluationMissingData `pulumi:"evaluationMissingData"`
	// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
	Query *string `pulumi:"query"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger *Trigger `pulumi:"trigger"`
}

// MonitoringQueryLanguageConditionInput is an input type that accepts MonitoringQueryLanguageConditionArgs and MonitoringQueryLanguageConditionOutput values.
// You can construct a concrete instance of `MonitoringQueryLanguageConditionInput` via:
//
//	MonitoringQueryLanguageConditionArgs{...}
type MonitoringQueryLanguageConditionInput interface {
	pulumi.Input

	ToMonitoringQueryLanguageConditionOutput() MonitoringQueryLanguageConditionOutput
	ToMonitoringQueryLanguageConditionOutputWithContext(context.Context) MonitoringQueryLanguageConditionOutput
}

// A condition type that allows alert policies to be defined using Monitoring Query Language (https://cloud.google.com/monitoring/mql).
type MonitoringQueryLanguageConditionArgs struct {
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration pulumi.StringPtrInput `pulumi:"duration"`
	// A condition control that determines how metric-threshold conditions are evaluated when data stops arriving.
	EvaluationMissingData MonitoringQueryLanguageConditionEvaluationMissingDataPtrInput `pulumi:"evaluationMissingData"`
	// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
	Query pulumi.StringPtrInput `pulumi:"query"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger TriggerPtrInput `pulumi:"trigger"`
}

func (MonitoringQueryLanguageConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoringQueryLanguageCondition)(nil)).Elem()
}

func (i MonitoringQueryLanguageConditionArgs) ToMonitoringQueryLanguageConditionOutput() MonitoringQueryLanguageConditionOutput {
	return i.ToMonitoringQueryLanguageConditionOutputWithContext(context.Background())
}

func (i MonitoringQueryLanguageConditionArgs) ToMonitoringQueryLanguageConditionOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoringQueryLanguageConditionOutput)
}

func (i MonitoringQueryLanguageConditionArgs) ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput {
	return i.ToMonitoringQueryLanguageConditionPtrOutputWithContext(context.Background())
}

func (i MonitoringQueryLanguageConditionArgs) ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoringQueryLanguageConditionOutput).ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx)
}

// MonitoringQueryLanguageConditionPtrInput is an input type that accepts MonitoringQueryLanguageConditionArgs, MonitoringQueryLanguageConditionPtr and MonitoringQueryLanguageConditionPtrOutput values.
// You can construct a concrete instance of `MonitoringQueryLanguageConditionPtrInput` via:
//
//	        MonitoringQueryLanguageConditionArgs{...}
//
//	or:
//
//	        nil
type MonitoringQueryLanguageConditionPtrInput interface {
	pulumi.Input

	ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput
	ToMonitoringQueryLanguageConditionPtrOutputWithContext(context.Context) MonitoringQueryLanguageConditionPtrOutput
}

type monitoringQueryLanguageConditionPtrType MonitoringQueryLanguageConditionArgs

func MonitoringQueryLanguageConditionPtr(v *MonitoringQueryLanguageConditionArgs) MonitoringQueryLanguageConditionPtrInput {
	return (*monitoringQueryLanguageConditionPtrType)(v)
}

func (*monitoringQueryLanguageConditionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoringQueryLanguageCondition)(nil)).Elem()
}

func (i *monitoringQueryLanguageConditionPtrType) ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput {
	return i.ToMonitoringQueryLanguageConditionPtrOutputWithContext(context.Background())
}

func (i *monitoringQueryLanguageConditionPtrType) ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoringQueryLanguageConditionPtrOutput)
}

// A condition type that allows alert policies to be defined using Monitoring Query Language (https://cloud.google.com/monitoring/mql).
type MonitoringQueryLanguageConditionOutput struct{ *pulumi.OutputState }

func (MonitoringQueryLanguageConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoringQueryLanguageCondition)(nil)).Elem()
}

func (o MonitoringQueryLanguageConditionOutput) ToMonitoringQueryLanguageConditionOutput() MonitoringQueryLanguageConditionOutput {
	return o
}

func (o MonitoringQueryLanguageConditionOutput) ToMonitoringQueryLanguageConditionOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionOutput {
	return o
}

func (o MonitoringQueryLanguageConditionOutput) ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput {
	return o.ToMonitoringQueryLanguageConditionPtrOutputWithContext(context.Background())
}

func (o MonitoringQueryLanguageConditionOutput) ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MonitoringQueryLanguageCondition) *MonitoringQueryLanguageCondition {
		return &v
	}).(MonitoringQueryLanguageConditionPtrOutput)
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MonitoringQueryLanguageConditionOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageCondition) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// A condition control that determines how metric-threshold conditions are evaluated when data stops arriving.
func (o MonitoringQueryLanguageConditionOutput) EvaluationMissingData() MonitoringQueryLanguageConditionEvaluationMissingDataPtrOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageCondition) *MonitoringQueryLanguageConditionEvaluationMissingData {
		return v.EvaluationMissingData
	}).(MonitoringQueryLanguageConditionEvaluationMissingDataPtrOutput)
}

// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
func (o MonitoringQueryLanguageConditionOutput) Query() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageCondition) *string { return v.Query }).(pulumi.StringPtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MonitoringQueryLanguageConditionOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageCondition) *Trigger { return v.Trigger }).(TriggerPtrOutput)
}

type MonitoringQueryLanguageConditionPtrOutput struct{ *pulumi.OutputState }

func (MonitoringQueryLanguageConditionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoringQueryLanguageCondition)(nil)).Elem()
}

func (o MonitoringQueryLanguageConditionPtrOutput) ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput {
	return o
}

func (o MonitoringQueryLanguageConditionPtrOutput) ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionPtrOutput {
	return o
}

func (o MonitoringQueryLanguageConditionPtrOutput) Elem() MonitoringQueryLanguageConditionOutput {
	return o.ApplyT(func(v *MonitoringQueryLanguageCondition) MonitoringQueryLanguageCondition {
		if v != nil {
			return *v
		}
		var ret MonitoringQueryLanguageCondition
		return ret
	}).(MonitoringQueryLanguageConditionOutput)
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MonitoringQueryLanguageConditionPtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MonitoringQueryLanguageCondition) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// A condition control that determines how metric-threshold conditions are evaluated when data stops arriving.
func (o MonitoringQueryLanguageConditionPtrOutput) EvaluationMissingData() MonitoringQueryLanguageConditionEvaluationMissingDataPtrOutput {
	return o.ApplyT(func(v *MonitoringQueryLanguageCondition) *MonitoringQueryLanguageConditionEvaluationMissingData {
		if v == nil {
			return nil
		}
		return v.EvaluationMissingData
	}).(MonitoringQueryLanguageConditionEvaluationMissingDataPtrOutput)
}

// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
func (o MonitoringQueryLanguageConditionPtrOutput) Query() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MonitoringQueryLanguageCondition) *string {
		if v == nil {
			return nil
		}
		return v.Query
	}).(pulumi.StringPtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MonitoringQueryLanguageConditionPtrOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v *MonitoringQueryLanguageCondition) *Trigger {
		if v == nil {
			return nil
		}
		return v.Trigger
	}).(TriggerPtrOutput)
}

// A condition type that allows alert policies to be defined using Monitoring Query Language (https://cloud.google.com/monitoring/mql).
type MonitoringQueryLanguageConditionResponse struct {
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration string `pulumi:"duration"`
	// A condition control that determines how metric-threshold conditions are evaluated when data stops arriving.
	EvaluationMissingData string `pulumi:"evaluationMissingData"`
	// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
	Query string `pulumi:"query"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger TriggerResponse `pulumi:"trigger"`
}

// A condition type that allows alert policies to be defined using Monitoring Query Language (https://cloud.google.com/monitoring/mql).
type MonitoringQueryLanguageConditionResponseOutput struct{ *pulumi.OutputState }

func (MonitoringQueryLanguageConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoringQueryLanguageConditionResponse)(nil)).Elem()
}

func (o MonitoringQueryLanguageConditionResponseOutput) ToMonitoringQueryLanguageConditionResponseOutput() MonitoringQueryLanguageConditionResponseOutput {
	return o
}

func (o MonitoringQueryLanguageConditionResponseOutput) ToMonitoringQueryLanguageConditionResponseOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionResponseOutput {
	return o
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MonitoringQueryLanguageConditionResponseOutput) Duration() pulumi.StringOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageConditionResponse) string { return v.Duration }).(pulumi.StringOutput)
}

// A condition control that determines how metric-threshold conditions are evaluated when data stops arriving.
func (o MonitoringQueryLanguageConditionResponseOutput) EvaluationMissingData() pulumi.StringOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageConditionResponse) string { return v.EvaluationMissingData }).(pulumi.StringOutput)
}

// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
func (o MonitoringQueryLanguageConditionResponseOutput) Query() pulumi.StringOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageConditionResponse) string { return v.Query }).(pulumi.StringOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MonitoringQueryLanguageConditionResponseOutput) Trigger() TriggerResponseOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageConditionResponse) TriggerResponse { return v.Trigger }).(TriggerResponseOutput)
}

// Describes a change made to a configuration.
type MutationRecord struct {
	// When the change occurred.
	MutateTime *string `pulumi:"mutateTime"`
	// The email address of the user making the change.
	MutatedBy *string `pulumi:"mutatedBy"`
}

// MutationRecordInput is an input type that accepts MutationRecordArgs and MutationRecordOutput values.
// You can construct a concrete instance of `MutationRecordInput` via:
//
//	MutationRecordArgs{...}
type MutationRecordInput interface {
	pulumi.Input

	ToMutationRecordOutput() MutationRecordOutput
	ToMutationRecordOutputWithContext(context.Context) MutationRecordOutput
}

// Describes a change made to a configuration.
type MutationRecordArgs struct {
	// When the change occurred.
	MutateTime pulumi.StringPtrInput `pulumi:"mutateTime"`
	// The email address of the user making the change.
	MutatedBy pulumi.StringPtrInput `pulumi:"mutatedBy"`
}

func (MutationRecordArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MutationRecord)(nil)).Elem()
}

func (i MutationRecordArgs) ToMutationRecordOutput() MutationRecordOutput {
	return i.ToMutationRecordOutputWithContext(context.Background())
}

func (i MutationRecordArgs) ToMutationRecordOutputWithContext(ctx context.Context) MutationRecordOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordOutput)
}

func (i MutationRecordArgs) ToMutationRecordPtrOutput() MutationRecordPtrOutput {
	return i.ToMutationRecordPtrOutputWithContext(context.Background())
}

func (i MutationRecordArgs) ToMutationRecordPtrOutputWithContext(ctx context.Context) MutationRecordPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordOutput).ToMutationRecordPtrOutputWithContext(ctx)
}

// MutationRecordPtrInput is an input type that accepts MutationRecordArgs, MutationRecordPtr and MutationRecordPtrOutput values.
// You can construct a concrete instance of `MutationRecordPtrInput` via:
//
//	        MutationRecordArgs{...}
//
//	or:
//
//	        nil
type MutationRecordPtrInput interface {
	pulumi.Input

	ToMutationRecordPtrOutput() MutationRecordPtrOutput
	ToMutationRecordPtrOutputWithContext(context.Context) MutationRecordPtrOutput
}

type mutationRecordPtrType MutationRecordArgs

func MutationRecordPtr(v *MutationRecordArgs) MutationRecordPtrInput {
	return (*mutationRecordPtrType)(v)
}

func (*mutationRecordPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MutationRecord)(nil)).Elem()
}

func (i *mutationRecordPtrType) ToMutationRecordPtrOutput() MutationRecordPtrOutput {
	return i.ToMutationRecordPtrOutputWithContext(context.Background())
}

func (i *mutationRecordPtrType) ToMutationRecordPtrOutputWithContext(ctx context.Context) MutationRecordPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordPtrOutput)
}

// MutationRecordArrayInput is an input type that accepts MutationRecordArray and MutationRecordArrayOutput values.
// You can construct a concrete instance of `MutationRecordArrayInput` via:
//
//	MutationRecordArray{ MutationRecordArgs{...} }
type MutationRecordArrayInput interface {
	pulumi.Input

	ToMutationRecordArrayOutput() MutationRecordArrayOutput
	ToMutationRecordArrayOutputWithContext(context.Context) MutationRecordArrayOutput
}

type MutationRecordArray []MutationRecordInput

func (MutationRecordArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MutationRecord)(nil)).Elem()
}

func (i MutationRecordArray) ToMutationRecordArrayOutput() MutationRecordArrayOutput {
	return i.ToMutationRecordArrayOutputWithContext(context.Background())
}

func (i MutationRecordArray) ToMutationRecordArrayOutputWithContext(ctx context.Context) MutationRecordArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordArrayOutput)
}

// Describes a change made to a configuration.
type MutationRecordOutput struct{ *pulumi.OutputState }

func (MutationRecordOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MutationRecord)(nil)).Elem()
}

func (o MutationRecordOutput) ToMutationRecordOutput() MutationRecordOutput {
	return o
}

func (o MutationRecordOutput) ToMutationRecordOutputWithContext(ctx context.Context) MutationRecordOutput {
	return o
}

func (o MutationRecordOutput) ToMutationRecordPtrOutput() MutationRecordPtrOutput {
	return o.ToMutationRecordPtrOutputWithContext(context.Background())
}

func (o MutationRecordOutput) ToMutationRecordPtrOutputWithContext(ctx context.Context) MutationRecordPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MutationRecord) *MutationRecord {
		return &v
	}).(MutationRecordPtrOutput)
}

// When the change occurred.
func (o MutationRecordOutput) MutateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MutationRecord) *string { return v.MutateTime }).(pulumi.StringPtrOutput)
}

// The email address of the user making the change.
func (o MutationRecordOutput) MutatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MutationRecord) *string { return v.MutatedBy }).(pulumi.StringPtrOutput)
}

type MutationRecordPtrOutput struct{ *pulumi.OutputState }

func (MutationRecordPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MutationRecord)(nil)).Elem()
}

func (o MutationRecordPtrOutput) ToMutationRecordPtrOutput() MutationRecordPtrOutput {
	return o
}

func (o MutationRecordPtrOutput) ToMutationRecordPtrOutputWithContext(ctx context.Context) MutationRecordPtrOutput {
	return o
}

func (o MutationRecordPtrOutput) Elem() MutationRecordOutput {
	return o.ApplyT(func(v *MutationRecord) MutationRecord {
		if v != nil {
			return *v
		}
		var ret MutationRecord
		return ret
	}).(MutationRecordOutput)
}

// When the change occurred.
func (o MutationRecordPtrOutput) MutateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MutationRecord) *string {
		if v == nil {
			return nil
		}
		return v.MutateTime
	}).(pulumi.StringPtrOutput)
}

// The email address of the user making the change.
func (o MutationRecordPtrOutput) MutatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MutationRecord) *string {
		if v == nil {
			return nil
		}
		return v.MutatedBy
	}).(pulumi.StringPtrOutput)
}

type MutationRecordArrayOutput struct{ *pulumi.OutputState }

func (MutationRecordArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MutationRecord)(nil)).Elem()
}

func (o MutationRecordArrayOutput) ToMutationRecordArrayOutput() MutationRecordArrayOutput {
	return o
}

func (o MutationRecordArrayOutput) ToMutationRecordArrayOutputWithContext(ctx context.Context) MutationRecordArrayOutput {
	return o
}

func (o MutationRecordArrayOutput) Index(i pulumi.IntInput) MutationRecordOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MutationRecord {
		return vs[0].([]MutationRecord)[vs[1].(int)]
	}).(MutationRecordOutput)
}

// Describes a change made to a configuration.
type MutationRecordResponse struct {
	// When the change occurred.
	MutateTime string `pulumi:"mutateTime"`
	// The email address of the user making the change.
	MutatedBy string `pulumi:"mutatedBy"`
}

// Describes a change made to a configuration.
type MutationRecordResponseOutput struct{ *pulumi.OutputState }

func (MutationRecordResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MutationRecordResponse)(nil)).Elem()
}

func (o MutationRecordResponseOutput) ToMutationRecordResponseOutput() MutationRecordResponseOutput {
	return o
}

func (o MutationRecordResponseOutput) ToMutationRecordResponseOutputWithContext(ctx context.Context) MutationRecordResponseOutput {
	return o
}

// When the change occurred.
func (o MutationRecordResponseOutput) MutateTime() pulumi.StringOutput {
	return o.ApplyT(func(v MutationRecordResponse) string { return v.MutateTime }).(pulumi.StringOutput)
}

// The email address of the user making the change.
func (o MutationRecordResponseOutput) MutatedBy() pulumi.StringOutput {
	return o.ApplyT(func(v MutationRecordResponse) string { return v.MutatedBy }).(pulumi.StringOutput)
}

type MutationRecordResponseArrayOutput struct{ *pulumi.OutputState }

func (MutationRecordResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MutationRecordResponse)(nil)).Elem()
}

func (o MutationRecordResponseArrayOutput) ToMutationRecordResponseArrayOutput() MutationRecordResponseArrayOutput {
	return o
}

func (o MutationRecordResponseArrayOutput) ToMutationRecordResponseArrayOutputWithContext(ctx context.Context) MutationRecordResponseArrayOutput {
	return o
}

func (o MutationRecordResponseArrayOutput) Index(i pulumi.IntInput) MutationRecordResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MutationRecordResponse {
		return vs[0].([]MutationRecordResponse)[vs[1].(int)]
	}).(MutationRecordResponseOutput)
}

// Control over how the notification channels in notification_channels are notified when this alert fires, on a per-channel basis.
type NotificationChannelStrategy struct {
	// The full REST resource name for the notification channels that these settings apply to. Each of these correspond to the name field in one of the NotificationChannel objects referenced in the notification_channels field of this AlertPolicy. The format is: projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
	NotificationChannelNames []string `pulumi:"notificationChannelNames"`
	// The frequency at which to send reminder notifications for open incidents.
	RenotifyInterval *string `pulumi:"renotifyInterval"`
}

// NotificationChannelStrategyInput is an input type that accepts NotificationChannelStrategyArgs and NotificationChannelStrategyOutput values.
// You can construct a concrete instance of `NotificationChannelStrategyInput` via:
//
//	NotificationChannelStrategyArgs{...}
type NotificationChannelStrategyInput interface {
	pulumi.Input

	ToNotificationChannelStrategyOutput() NotificationChannelStrategyOutput
	ToNotificationChannelStrategyOutputWithContext(context.Context) NotificationChannelStrategyOutput
}

// Control over how the notification channels in notification_channels are notified when this alert fires, on a per-channel basis.
type NotificationChannelStrategyArgs struct {
	// The full REST resource name for the notification channels that these settings apply to. Each of these correspond to the name field in one of the NotificationChannel objects referenced in the notification_channels field of this AlertPolicy. The format is: projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
	NotificationChannelNames pulumi.StringArrayInput `pulumi:"notificationChannelNames"`
	// The frequency at which to send reminder notifications for open incidents.
	RenotifyInterval pulumi.StringPtrInput `pulumi:"renotifyInterval"`
}

func (NotificationChannelStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationChannelStrategy)(nil)).Elem()
}

func (i NotificationChannelStrategyArgs) ToNotificationChannelStrategyOutput() NotificationChannelStrategyOutput {
	return i.ToNotificationChannelStrategyOutputWithContext(context.Background())
}

func (i NotificationChannelStrategyArgs) ToNotificationChannelStrategyOutputWithContext(ctx context.Context) NotificationChannelStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationChannelStrategyOutput)
}

// NotificationChannelStrategyArrayInput is an input type that accepts NotificationChannelStrategyArray and NotificationChannelStrategyArrayOutput values.
// You can construct a concrete instance of `NotificationChannelStrategyArrayInput` via:
//
//	NotificationChannelStrategyArray{ NotificationChannelStrategyArgs{...} }
type NotificationChannelStrategyArrayInput interface {
	pulumi.Input

	ToNotificationChannelStrategyArrayOutput() NotificationChannelStrategyArrayOutput
	ToNotificationChannelStrategyArrayOutputWithContext(context.Context) NotificationChannelStrategyArrayOutput
}

type NotificationChannelStrategyArray []NotificationChannelStrategyInput

func (NotificationChannelStrategyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NotificationChannelStrategy)(nil)).Elem()
}

func (i NotificationChannelStrategyArray) ToNotificationChannelStrategyArrayOutput() NotificationChannelStrategyArrayOutput {
	return i.ToNotificationChannelStrategyArrayOutputWithContext(context.Background())
}

func (i NotificationChannelStrategyArray) ToNotificationChannelStrategyArrayOutputWithContext(ctx context.Context) NotificationChannelStrategyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationChannelStrategyArrayOutput)
}

// Control over how the notification channels in notification_channels are notified when this alert fires, on a per-channel basis.
type NotificationChannelStrategyOutput struct{ *pulumi.OutputState }

func (NotificationChannelStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationChannelStrategy)(nil)).Elem()
}

func (o NotificationChannelStrategyOutput) ToNotificationChannelStrategyOutput() NotificationChannelStrategyOutput {
	return o
}

func (o NotificationChannelStrategyOutput) ToNotificationChannelStrategyOutputWithContext(ctx context.Context) NotificationChannelStrategyOutput {
	return o
}

// The full REST resource name for the notification channels that these settings apply to. Each of these correspond to the name field in one of the NotificationChannel objects referenced in the notification_channels field of this AlertPolicy. The format is: projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
func (o NotificationChannelStrategyOutput) NotificationChannelNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NotificationChannelStrategy) []string { return v.NotificationChannelNames }).(pulumi.StringArrayOutput)
}

// The frequency at which to send reminder notifications for open incidents.
func (o NotificationChannelStrategyOutput) RenotifyInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NotificationChannelStrategy) *string { return v.RenotifyInterval }).(pulumi.StringPtrOutput)
}

type NotificationChannelStrategyArrayOutput struct{ *pulumi.OutputState }

func (NotificationChannelStrategyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NotificationChannelStrategy)(nil)).Elem()
}

func (o NotificationChannelStrategyArrayOutput) ToNotificationChannelStrategyArrayOutput() NotificationChannelStrategyArrayOutput {
	return o
}

func (o NotificationChannelStrategyArrayOutput) ToNotificationChannelStrategyArrayOutputWithContext(ctx context.Context) NotificationChannelStrategyArrayOutput {
	return o
}

func (o NotificationChannelStrategyArrayOutput) Index(i pulumi.IntInput) NotificationChannelStrategyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NotificationChannelStrategy {
		return vs[0].([]NotificationChannelStrategy)[vs[1].(int)]
	}).(NotificationChannelStrategyOutput)
}

// Control over how the notification channels in notification_channels are notified when this alert fires, on a per-channel basis.
type NotificationChannelStrategyResponse struct {
	// The full REST resource name for the notification channels that these settings apply to. Each of these correspond to the name field in one of the NotificationChannel objects referenced in the notification_channels field of this AlertPolicy. The format is: projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
	NotificationChannelNames []string `pulumi:"notificationChannelNames"`
	// The frequency at which to send reminder notifications for open incidents.
	RenotifyInterval string `pulumi:"renotifyInterval"`
}

// Control over how the notification channels in notification_channels are notified when this alert fires, on a per-channel basis.
type NotificationChannelStrategyResponseOutput struct{ *pulumi.OutputState }

func (NotificationChannelStrategyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationChannelStrategyResponse)(nil)).Elem()
}

func (o NotificationChannelStrategyResponseOutput) ToNotificationChannelStrategyResponseOutput() NotificationChannelStrategyResponseOutput {
	return o
}

func (o NotificationChannelStrategyResponseOutput) ToNotificationChannelStrategyResponseOutputWithContext(ctx context.Context) NotificationChannelStrategyResponseOutput {
	return o
}

// The full REST resource name for the notification channels that these settings apply to. Each of these correspond to the name field in one of the NotificationChannel objects referenced in the notification_channels field of this AlertPolicy. The format is: projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
func (o NotificationChannelStrategyResponseOutput) NotificationChannelNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NotificationChannelStrategyResponse) []string { return v.NotificationChannelNames }).(pulumi.StringArrayOutput)
}

// The frequency at which to send reminder notifications for open incidents.
func (o NotificationChannelStrategyResponseOutput) RenotifyInterval() pulumi.StringOutput {
	return o.ApplyT(func(v NotificationChannelStrategyResponse) string { return v.RenotifyInterval }).(pulumi.StringOutput)
}

type NotificationChannelStrategyResponseArrayOutput struct{ *pulumi.OutputState }

func (NotificationChannelStrategyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NotificationChannelStrategyResponse)(nil)).Elem()
}

func (o NotificationChannelStrategyResponseArrayOutput) ToNotificationChannelStrategyResponseArrayOutput() NotificationChannelStrategyResponseArrayOutput {
	return o
}

func (o NotificationChannelStrategyResponseArrayOutput) ToNotificationChannelStrategyResponseArrayOutputWithContext(ctx context.Context) NotificationChannelStrategyResponseArrayOutput {
	return o
}

func (o NotificationChannelStrategyResponseArrayOutput) Index(i pulumi.IntInput) NotificationChannelStrategyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NotificationChannelStrategyResponse {
		return vs[0].([]NotificationChannelStrategyResponse)[vs[1].(int)]
	}).(NotificationChannelStrategyResponseOutput)
}

// Control over the rate of notifications sent to this alert policy's notification channels.
type NotificationRateLimit struct {
	// Not more than one notification per period.
	Period *string `pulumi:"period"`
}

// NotificationRateLimitInput is an input type that accepts NotificationRateLimitArgs and NotificationRateLimitOutput values.
// You can construct a concrete instance of `NotificationRateLimitInput` via:
//
//	NotificationRateLimitArgs{...}
type NotificationRateLimitInput interface {
	pulumi.Input

	ToNotificationRateLimitOutput() NotificationRateLimitOutput
	ToNotificationRateLimitOutputWithContext(context.Context) NotificationRateLimitOutput
}

// Control over the rate of notifications sent to this alert policy's notification channels.
type NotificationRateLimitArgs struct {
	// Not more than one notification per period.
	Period pulumi.StringPtrInput `pulumi:"period"`
}

func (NotificationRateLimitArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationRateLimit)(nil)).Elem()
}

func (i NotificationRateLimitArgs) ToNotificationRateLimitOutput() NotificationRateLimitOutput {
	return i.ToNotificationRateLimitOutputWithContext(context.Background())
}

func (i NotificationRateLimitArgs) ToNotificationRateLimitOutputWithContext(ctx context.Context) NotificationRateLimitOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationRateLimitOutput)
}

func (i NotificationRateLimitArgs) ToNotificationRateLimitPtrOutput() NotificationRateLimitPtrOutput {
	return i.ToNotificationRateLimitPtrOutputWithContext(context.Background())
}

func (i NotificationRateLimitArgs) ToNotificationRateLimitPtrOutputWithContext(ctx context.Context) NotificationRateLimitPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationRateLimitOutput).ToNotificationRateLimitPtrOutputWithContext(ctx)
}

// NotificationRateLimitPtrInput is an input type that accepts NotificationRateLimitArgs, NotificationRateLimitPtr and NotificationRateLimitPtrOutput values.
// You can construct a concrete instance of `NotificationRateLimitPtrInput` via:
//
//	        NotificationRateLimitArgs{...}
//
//	or:
//
//	        nil
type NotificationRateLimitPtrInput interface {
	pulumi.Input

	ToNotificationRateLimitPtrOutput() NotificationRateLimitPtrOutput
	ToNotificationRateLimitPtrOutputWithContext(context.Context) NotificationRateLimitPtrOutput
}

type notificationRateLimitPtrType NotificationRateLimitArgs

func NotificationRateLimitPtr(v *NotificationRateLimitArgs) NotificationRateLimitPtrInput {
	return (*notificationRateLimitPtrType)(v)
}

func (*notificationRateLimitPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationRateLimit)(nil)).Elem()
}

func (i *notificationRateLimitPtrType) ToNotificationRateLimitPtrOutput() NotificationRateLimitPtrOutput {
	return i.ToNotificationRateLimitPtrOutputWithContext(context.Background())
}

func (i *notificationRateLimitPtrType) ToNotificationRateLimitPtrOutputWithContext(ctx context.Context) NotificationRateLimitPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationRateLimitPtrOutput)
}

// Control over the rate of notifications sent to this alert policy's notification channels.
type NotificationRateLimitOutput struct{ *pulumi.OutputState }

func (NotificationRateLimitOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationRateLimit)(nil)).Elem()
}

func (o NotificationRateLimitOutput) ToNotificationRateLimitOutput() NotificationRateLimitOutput {
	return o
}

func (o NotificationRateLimitOutput) ToNotificationRateLimitOutputWithContext(ctx context.Context) NotificationRateLimitOutput {
	return o
}

func (o NotificationRateLimitOutput) ToNotificationRateLimitPtrOutput() NotificationRateLimitPtrOutput {
	return o.ToNotificationRateLimitPtrOutputWithContext(context.Background())
}

func (o NotificationRateLimitOutput) ToNotificationRateLimitPtrOutputWithContext(ctx context.Context) NotificationRateLimitPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NotificationRateLimit) *NotificationRateLimit {
		return &v
	}).(NotificationRateLimitPtrOutput)
}

// Not more than one notification per period.
func (o NotificationRateLimitOutput) Period() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NotificationRateLimit) *string { return v.Period }).(pulumi.StringPtrOutput)
}

type NotificationRateLimitPtrOutput struct{ *pulumi.OutputState }

func (NotificationRateLimitPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationRateLimit)(nil)).Elem()
}

func (o NotificationRateLimitPtrOutput) ToNotificationRateLimitPtrOutput() NotificationRateLimitPtrOutput {
	return o
}

func (o NotificationRateLimitPtrOutput) ToNotificationRateLimitPtrOutputWithContext(ctx context.Context) NotificationRateLimitPtrOutput {
	return o
}

func (o NotificationRateLimitPtrOutput) Elem() NotificationRateLimitOutput {
	return o.ApplyT(func(v *NotificationRateLimit) NotificationRateLimit {
		if v != nil {
			return *v
		}
		var ret NotificationRateLimit
		return ret
	}).(NotificationRateLimitOutput)
}

// Not more than one notification per period.
func (o NotificationRateLimitPtrOutput) Period() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NotificationRateLimit) *string {
		if v == nil {
			return nil
		}
		return v.Period
	}).(pulumi.StringPtrOutput)
}

// Control over the rate of notifications sent to this alert policy's notification channels.
type NotificationRateLimitResponse struct {
	// Not more than one notification per period.
	Period string `pulumi:"period"`
}

// Control over the rate of notifications sent to this alert policy's notification channels.
type NotificationRateLimitResponseOutput struct{ *pulumi.OutputState }

func (NotificationRateLimitResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationRateLimitResponse)(nil)).Elem()
}

func (o NotificationRateLimitResponseOutput) ToNotificationRateLimitResponseOutput() NotificationRateLimitResponseOutput {
	return o
}

func (o NotificationRateLimitResponseOutput) ToNotificationRateLimitResponseOutputWithContext(ctx context.Context) NotificationRateLimitResponseOutput {
	return o
}

// Not more than one notification per period.
func (o NotificationRateLimitResponseOutput) Period() pulumi.StringOutput {
	return o.ApplyT(func(v NotificationRateLimitResponse) string { return v.Period }).(pulumi.StringOutput)
}

// A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.
type PerformanceThreshold struct {
	// BasicSli to evaluate to judge window quality.
	BasicSliPerformance *BasicSli `pulumi:"basicSliPerformance"`
	// RequestBasedSli to evaluate to judge window quality.
	Performance *RequestBasedSli `pulumi:"performance"`
	// If window performance >= threshold, the window is counted as good.
	Threshold *float64 `pulumi:"threshold"`
}

// PerformanceThresholdInput is an input type that accepts PerformanceThresholdArgs and PerformanceThresholdOutput values.
// You can construct a concrete instance of `PerformanceThresholdInput` via:
//
//	PerformanceThresholdArgs{...}
type PerformanceThresholdInput interface {
	pulumi.Input

	ToPerformanceThresholdOutput() PerformanceThresholdOutput
	ToPerformanceThresholdOutputWithContext(context.Context) PerformanceThresholdOutput
}

// A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.
type PerformanceThresholdArgs struct {
	// BasicSli to evaluate to judge window quality.
	BasicSliPerformance BasicSliPtrInput `pulumi:"basicSliPerformance"`
	// RequestBasedSli to evaluate to judge window quality.
	Performance RequestBasedSliPtrInput `pulumi:"performance"`
	// If window performance >= threshold, the window is counted as good.
	Threshold pulumi.Float64PtrInput `pulumi:"threshold"`
}

func (PerformanceThresholdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PerformanceThreshold)(nil)).Elem()
}

func (i PerformanceThresholdArgs) ToPerformanceThresholdOutput() PerformanceThresholdOutput {
	return i.ToPerformanceThresholdOutputWithContext(context.Background())
}

func (i PerformanceThresholdArgs) ToPerformanceThresholdOutputWithContext(ctx context.Context) PerformanceThresholdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PerformanceThresholdOutput)
}

func (i PerformanceThresholdArgs) ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput {
	return i.ToPerformanceThresholdPtrOutputWithContext(context.Background())
}

func (i PerformanceThresholdArgs) ToPerformanceThresholdPtrOutputWithContext(ctx context.Context) PerformanceThresholdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PerformanceThresholdOutput).ToPerformanceThresholdPtrOutputWithContext(ctx)
}

// PerformanceThresholdPtrInput is an input type that accepts PerformanceThresholdArgs, PerformanceThresholdPtr and PerformanceThresholdPtrOutput values.
// You can construct a concrete instance of `PerformanceThresholdPtrInput` via:
//
//	        PerformanceThresholdArgs{...}
//
//	or:
//
//	        nil
type PerformanceThresholdPtrInput interface {
	pulumi.Input

	ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput
	ToPerformanceThresholdPtrOutputWithContext(context.Context) PerformanceThresholdPtrOutput
}

type performanceThresholdPtrType PerformanceThresholdArgs

func PerformanceThresholdPtr(v *PerformanceThresholdArgs) PerformanceThresholdPtrInput {
	return (*performanceThresholdPtrType)(v)
}

func (*performanceThresholdPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PerformanceThreshold)(nil)).Elem()
}

func (i *performanceThresholdPtrType) ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput {
	return i.ToPerformanceThresholdPtrOutputWithContext(context.Background())
}

func (i *performanceThresholdPtrType) ToPerformanceThresholdPtrOutputWithContext(ctx context.Context) PerformanceThresholdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PerformanceThresholdPtrOutput)
}

// A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.
type PerformanceThresholdOutput struct{ *pulumi.OutputState }

func (PerformanceThresholdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PerformanceThreshold)(nil)).Elem()
}

func (o PerformanceThresholdOutput) ToPerformanceThresholdOutput() PerformanceThresholdOutput {
	return o
}

func (o PerformanceThresholdOutput) ToPerformanceThresholdOutputWithContext(ctx context.Context) PerformanceThresholdOutput {
	return o
}

func (o PerformanceThresholdOutput) ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput {
	return o.ToPerformanceThresholdPtrOutputWithContext(context.Background())
}

func (o PerformanceThresholdOutput) ToPerformanceThresholdPtrOutputWithContext(ctx context.Context) PerformanceThresholdPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PerformanceThreshold) *PerformanceThreshold {
		return &v
	}).(PerformanceThresholdPtrOutput)
}

// BasicSli to evaluate to judge window quality.
func (o PerformanceThresholdOutput) BasicSliPerformance() BasicSliPtrOutput {
	return o.ApplyT(func(v PerformanceThreshold) *BasicSli { return v.BasicSliPerformance }).(BasicSliPtrOutput)
}

// RequestBasedSli to evaluate to judge window quality.
func (o PerformanceThresholdOutput) Performance() RequestBasedSliPtrOutput {
	return o.ApplyT(func(v PerformanceThreshold) *RequestBasedSli { return v.Performance }).(RequestBasedSliPtrOutput)
}

// If window performance >= threshold, the window is counted as good.
func (o PerformanceThresholdOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PerformanceThreshold) *float64 { return v.Threshold }).(pulumi.Float64PtrOutput)
}

type PerformanceThresholdPtrOutput struct{ *pulumi.OutputState }

func (PerformanceThresholdPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PerformanceThreshold)(nil)).Elem()
}

func (o PerformanceThresholdPtrOutput) ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput {
	return o
}

func (o PerformanceThresholdPtrOutput) ToPerformanceThresholdPtrOutputWithContext(ctx context.Context) PerformanceThresholdPtrOutput {
	return o
}

func (o PerformanceThresholdPtrOutput) Elem() PerformanceThresholdOutput {
	return o.ApplyT(func(v *PerformanceThreshold) PerformanceThreshold {
		if v != nil {
			return *v
		}
		var ret PerformanceThreshold
		return ret
	}).(PerformanceThresholdOutput)
}

// BasicSli to evaluate to judge window quality.
func (o PerformanceThresholdPtrOutput) BasicSliPerformance() BasicSliPtrOutput {
	return o.ApplyT(func(v *PerformanceThreshold) *BasicSli {
		if v == nil {
			return nil
		}
		return v.BasicSliPerformance
	}).(BasicSliPtrOutput)
}

// RequestBasedSli to evaluate to judge window quality.
func (o PerformanceThresholdPtrOutput) Performance() RequestBasedSliPtrOutput {
	return o.ApplyT(func(v *PerformanceThreshold) *RequestBasedSli {
		if v == nil {
			return nil
		}
		return v.Performance
	}).(RequestBasedSliPtrOutput)
}

// If window performance >= threshold, the window is counted as good.
func (o PerformanceThresholdPtrOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PerformanceThreshold) *float64 {
		if v == nil {
			return nil
		}
		return v.Threshold
	}).(pulumi.Float64PtrOutput)
}

// A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.
type PerformanceThresholdResponse struct {
	// BasicSli to evaluate to judge window quality.
	BasicSliPerformance BasicSliResponse `pulumi:"basicSliPerformance"`
	// RequestBasedSli to evaluate to judge window quality.
	Performance RequestBasedSliResponse `pulumi:"performance"`
	// If window performance >= threshold, the window is counted as good.
	Threshold float64 `pulumi:"threshold"`
}

// A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.
type PerformanceThresholdResponseOutput struct{ *pulumi.OutputState }

func (PerformanceThresholdResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PerformanceThresholdResponse)(nil)).Elem()
}

func (o PerformanceThresholdResponseOutput) ToPerformanceThresholdResponseOutput() PerformanceThresholdResponseOutput {
	return o
}

func (o PerformanceThresholdResponseOutput) ToPerformanceThresholdResponseOutputWithContext(ctx context.Context) PerformanceThresholdResponseOutput {
	return o
}

// BasicSli to evaluate to judge window quality.
func (o PerformanceThresholdResponseOutput) BasicSliPerformance() BasicSliResponseOutput {
	return o.ApplyT(func(v PerformanceThresholdResponse) BasicSliResponse { return v.BasicSliPerformance }).(BasicSliResponseOutput)
}

// RequestBasedSli to evaluate to judge window quality.
func (o PerformanceThresholdResponseOutput) Performance() RequestBasedSliResponseOutput {
	return o.ApplyT(func(v PerformanceThresholdResponse) RequestBasedSliResponse { return v.Performance }).(RequestBasedSliResponseOutput)
}

// If window performance >= threshold, the window is counted as good.
func (o PerformanceThresholdResponseOutput) Threshold() pulumi.Float64Output {
	return o.ApplyT(func(v PerformanceThresholdResponse) float64 { return v.Threshold }).(pulumi.Float64Output)
}

// Information involved in sending ICMP pings alongside public HTTP/TCP checks. For HTTP, the pings are performed for each part of the redirect chain.
type PingConfig struct {
	// Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
	PingsCount *int `pulumi:"pingsCount"`
}

// PingConfigInput is an input type that accepts PingConfigArgs and PingConfigOutput values.
// You can construct a concrete instance of `PingConfigInput` via:
//
//	PingConfigArgs{...}
type PingConfigInput interface {
	pulumi.Input

	ToPingConfigOutput() PingConfigOutput
	ToPingConfigOutputWithContext(context.Context) PingConfigOutput
}

// Information involved in sending ICMP pings alongside public HTTP/TCP checks. For HTTP, the pings are performed for each part of the redirect chain.
type PingConfigArgs struct {
	// Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
	PingsCount pulumi.IntPtrInput `pulumi:"pingsCount"`
}

func (PingConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PingConfig)(nil)).Elem()
}

func (i PingConfigArgs) ToPingConfigOutput() PingConfigOutput {
	return i.ToPingConfigOutputWithContext(context.Background())
}

func (i PingConfigArgs) ToPingConfigOutputWithContext(ctx context.Context) PingConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PingConfigOutput)
}

func (i PingConfigArgs) ToPingConfigPtrOutput() PingConfigPtrOutput {
	return i.ToPingConfigPtrOutputWithContext(context.Background())
}

func (i PingConfigArgs) ToPingConfigPtrOutputWithContext(ctx context.Context) PingConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PingConfigOutput).ToPingConfigPtrOutputWithContext(ctx)
}

// PingConfigPtrInput is an input type that accepts PingConfigArgs, PingConfigPtr and PingConfigPtrOutput values.
// You can construct a concrete instance of `PingConfigPtrInput` via:
//
//	        PingConfigArgs{...}
//
//	or:
//
//	        nil
type PingConfigPtrInput interface {
	pulumi.Input

	ToPingConfigPtrOutput() PingConfigPtrOutput
	ToPingConfigPtrOutputWithContext(context.Context) PingConfigPtrOutput
}

type pingConfigPtrType PingConfigArgs

func PingConfigPtr(v *PingConfigArgs) PingConfigPtrInput {
	return (*pingConfigPtrType)(v)
}

func (*pingConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PingConfig)(nil)).Elem()
}

func (i *pingConfigPtrType) ToPingConfigPtrOutput() PingConfigPtrOutput {
	return i.ToPingConfigPtrOutputWithContext(context.Background())
}

func (i *pingConfigPtrType) ToPingConfigPtrOutputWithContext(ctx context.Context) PingConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PingConfigPtrOutput)
}

// Information involved in sending ICMP pings alongside public HTTP/TCP checks. For HTTP, the pings are performed for each part of the redirect chain.
type PingConfigOutput struct{ *pulumi.OutputState }

func (PingConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PingConfig)(nil)).Elem()
}

func (o PingConfigOutput) ToPingConfigOutput() PingConfigOutput {
	return o
}

func (o PingConfigOutput) ToPingConfigOutputWithContext(ctx context.Context) PingConfigOutput {
	return o
}

func (o PingConfigOutput) ToPingConfigPtrOutput() PingConfigPtrOutput {
	return o.ToPingConfigPtrOutputWithContext(context.Background())
}

func (o PingConfigOutput) ToPingConfigPtrOutputWithContext(ctx context.Context) PingConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PingConfig) *PingConfig {
		return &v
	}).(PingConfigPtrOutput)
}

// Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
func (o PingConfigOutput) PingsCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PingConfig) *int { return v.PingsCount }).(pulumi.IntPtrOutput)
}

type PingConfigPtrOutput struct{ *pulumi.OutputState }

func (PingConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PingConfig)(nil)).Elem()
}

func (o PingConfigPtrOutput) ToPingConfigPtrOutput() PingConfigPtrOutput {
	return o
}

func (o PingConfigPtrOutput) ToPingConfigPtrOutputWithContext(ctx context.Context) PingConfigPtrOutput {
	return o
}

func (o PingConfigPtrOutput) Elem() PingConfigOutput {
	return o.ApplyT(func(v *PingConfig) PingConfig {
		if v != nil {
			return *v
		}
		var ret PingConfig
		return ret
	}).(PingConfigOutput)
}

// Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
func (o PingConfigPtrOutput) PingsCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PingConfig) *int {
		if v == nil {
			return nil
		}
		return v.PingsCount
	}).(pulumi.IntPtrOutput)
}

// Information involved in sending ICMP pings alongside public HTTP/TCP checks. For HTTP, the pings are performed for each part of the redirect chain.
type PingConfigResponse struct {
	// Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
	PingsCount int `pulumi:"pingsCount"`
}

// Information involved in sending ICMP pings alongside public HTTP/TCP checks. For HTTP, the pings are performed for each part of the redirect chain.
type PingConfigResponseOutput struct{ *pulumi.OutputState }

func (PingConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PingConfigResponse)(nil)).Elem()
}

func (o PingConfigResponseOutput) ToPingConfigResponseOutput() PingConfigResponseOutput {
	return o
}

func (o PingConfigResponseOutput) ToPingConfigResponseOutputWithContext(ctx context.Context) PingConfigResponseOutput {
	return o
}

// Number of ICMP pings. A maximum of 3 ICMP pings is currently supported.
func (o PingConfigResponseOutput) PingsCount() pulumi.IntOutput {
	return o.ApplyT(func(v PingConfigResponse) int { return v.PingsCount }).(pulumi.IntOutput)
}

// A condition type that allows alert policies to be defined using Prometheus Query Language (PromQL) (https://prometheus.io/docs/prometheus/latest/querying/basics/).The PrometheusQueryLanguageCondition message contains information from a Prometheus alerting rule and its associated rule group.A Prometheus alerting rule is described here (https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/). The semantics of a Prometheus alerting rule is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule).A Prometheus rule group is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/). The semantics of a Prometheus rule group is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule_group).Because Cloud Alerting has no representation of a Prometheus rule group resource, we must embed the information of the parent rule group inside each of the conditions that refer to it. We must also update the contents of all Prometheus alerts in case the information of their rule group changes.The PrometheusQueryLanguageCondition protocol buffer combines the information of the corresponding rule group and alerting rule. The structure of the PrometheusQueryLanguageCondition protocol buffer does NOT mimic the structure of the Prometheus rule group and alerting rule YAML declarations. The PrometheusQueryLanguageCondition protocol buffer may change in the future to support future rule group and/or alerting rule features. There are no new such features at the present time (2023-06-26).
type PrometheusQueryLanguageCondition struct {
	// Optional. The alerting rule name of this alert in the corresponding Prometheus configuration file.Some external tools may require this field to be populated correctly in order to refer to the original Prometheus configuration file. The rule group name and the alert name are necessary to update the relevant AlertPolicies in case the definition of the rule group changes in the future.This field is optional. If this field is not empty, then it must be a valid Prometheus label name (https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels). This field may not exceed 2048 Unicode characters in length.
	AlertRule *string `pulumi:"alertRule"`
	// Optional. Alerts are considered firing once their PromQL expression was evaluated to be "true" for this long. Alerts whose PromQL expression was not evaluated to be "true" for long enough are considered pending. Must be a non-negative duration or missing. This field is optional. Its default value is zero.
	Duration *string `pulumi:"duration"`
	// Optional. How often this rule should be evaluated. Must be a positive multiple of 30 seconds or missing. This field is optional. Its default value is 30 seconds. If this PrometheusQueryLanguageCondition was generated from a Prometheus alerting rule, then this value should be taken from the enclosing rule group.
	EvaluationInterval *string `pulumi:"evaluationInterval"`
	// Optional. Labels to add to or overwrite in the PromQL query result. Label names must be valid (https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels). Label values can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables). The only available variable names are the names of the labels in the PromQL result, including "__name__" and "value". "labels" may be empty.
	Labels map[string]string `pulumi:"labels"`
	// The PromQL expression to evaluate. Every evaluation cycle this expression is evaluated at the current time, and all resultant time series become pending/firing alerts. This field must not be empty.
	Query string `pulumi:"query"`
	// Optional. The rule group name of this alert in the corresponding Prometheus configuration file.Some external tools may require this field to be populated correctly in order to refer to the original Prometheus configuration file. The rule group name and the alert name are necessary to update the relevant AlertPolicies in case the definition of the rule group changes in the future.This field is optional. If this field is not empty, then it must contain a valid UTF-8 string. This field may not exceed 2048 Unicode characters in length.
	RuleGroup *string `pulumi:"ruleGroup"`
}

// PrometheusQueryLanguageConditionInput is an input type that accepts PrometheusQueryLanguageConditionArgs and PrometheusQueryLanguageConditionOutput values.
// You can construct a concrete instance of `PrometheusQueryLanguageConditionInput` via:
//
//	PrometheusQueryLanguageConditionArgs{...}
type PrometheusQueryLanguageConditionInput interface {
	pulumi.Input

	ToPrometheusQueryLanguageConditionOutput() PrometheusQueryLanguageConditionOutput
	ToPrometheusQueryLanguageConditionOutputWithContext(context.Context) PrometheusQueryLanguageConditionOutput
}

// A condition type that allows alert policies to be defined using Prometheus Query Language (PromQL) (https://prometheus.io/docs/prometheus/latest/querying/basics/).The PrometheusQueryLanguageCondition message contains information from a Prometheus alerting rule and its associated rule group.A Prometheus alerting rule is described here (https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/). The semantics of a Prometheus alerting rule is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule).A Prometheus rule group is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/). The semantics of a Prometheus rule group is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule_group).Because Cloud Alerting has no representation of a Prometheus rule group resource, we must embed the information of the parent rule group inside each of the conditions that refer to it. We must also update the contents of all Prometheus alerts in case the information of their rule group changes.The PrometheusQueryLanguageCondition protocol buffer combines the information of the corresponding rule group and alerting rule. The structure of the PrometheusQueryLanguageCondition protocol buffer does NOT mimic the structure of the Prometheus rule group and alerting rule YAML declarations. The PrometheusQueryLanguageCondition protocol buffer may change in the future to support future rule group and/or alerting rule features. There are no new such features at the present time (2023-06-26).
type PrometheusQueryLanguageConditionArgs struct {
	// Optional. The alerting rule name of this alert in the corresponding Prometheus configuration file.Some external tools may require this field to be populated correctly in order to refer to the original Prometheus configuration file. The rule group name and the alert name are necessary to update the relevant AlertPolicies in case the definition of the rule group changes in the future.This field is optional. If this field is not empty, then it must be a valid Prometheus label name (https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels). This field may not exceed 2048 Unicode characters in length.
	AlertRule pulumi.StringPtrInput `pulumi:"alertRule"`
	// Optional. Alerts are considered firing once their PromQL expression was evaluated to be "true" for this long. Alerts whose PromQL expression was not evaluated to be "true" for long enough are considered pending. Must be a non-negative duration or missing. This field is optional. Its default value is zero.
	Duration pulumi.StringPtrInput `pulumi:"duration"`
	// Optional. How often this rule should be evaluated. Must be a positive multiple of 30 seconds or missing. This field is optional. Its default value is 30 seconds. If this PrometheusQueryLanguageCondition was generated from a Prometheus alerting rule, then this value should be taken from the enclosing rule group.
	EvaluationInterval pulumi.StringPtrInput `pulumi:"evaluationInterval"`
	// Optional. Labels to add to or overwrite in the PromQL query result. Label names must be valid (https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels). Label values can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables). The only available variable names are the names of the labels in the PromQL result, including "__name__" and "value". "labels" may be empty.
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// The PromQL expression to evaluate. Every evaluation cycle this expression is evaluated at the current time, and all resultant time series become pending/firing alerts. This field must not be empty.
	Query pulumi.StringInput `pulumi:"query"`
	// Optional. The rule group name of this alert in the corresponding Prometheus configuration file.Some external tools may require this field to be populated correctly in order to refer to the original Prometheus configuration file. The rule group name and the alert name are necessary to update the relevant AlertPolicies in case the definition of the rule group changes in the future.This field is optional. If this field is not empty, then it must contain a valid UTF-8 string. This field may not exceed 2048 Unicode characters in length.
	RuleGroup pulumi.StringPtrInput `pulumi:"ruleGroup"`
}

func (PrometheusQueryLanguageConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PrometheusQueryLanguageCondition)(nil)).Elem()
}

func (i PrometheusQueryLanguageConditionArgs) ToPrometheusQueryLanguageConditionOutput() PrometheusQueryLanguageConditionOutput {
	return i.ToPrometheusQueryLanguageConditionOutputWithContext(context.Background())
}

func (i PrometheusQueryLanguageConditionArgs) ToPrometheusQueryLanguageConditionOutputWithContext(ctx context.Context) PrometheusQueryLanguageConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrometheusQueryLanguageConditionOutput)
}

func (i PrometheusQueryLanguageConditionArgs) ToPrometheusQueryLanguageConditionPtrOutput() PrometheusQueryLanguageConditionPtrOutput {
	return i.ToPrometheusQueryLanguageConditionPtrOutputWithContext(context.Background())
}

func (i PrometheusQueryLanguageConditionArgs) ToPrometheusQueryLanguageConditionPtrOutputWithContext(ctx context.Context) PrometheusQueryLanguageConditionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrometheusQueryLanguageConditionOutput).ToPrometheusQueryLanguageConditionPtrOutputWithContext(ctx)
}

// PrometheusQueryLanguageConditionPtrInput is an input type that accepts PrometheusQueryLanguageConditionArgs, PrometheusQueryLanguageConditionPtr and PrometheusQueryLanguageConditionPtrOutput values.
// You can construct a concrete instance of `PrometheusQueryLanguageConditionPtrInput` via:
//
//	        PrometheusQueryLanguageConditionArgs{...}
//
//	or:
//
//	        nil
type PrometheusQueryLanguageConditionPtrInput interface {
	pulumi.Input

	ToPrometheusQueryLanguageConditionPtrOutput() PrometheusQueryLanguageConditionPtrOutput
	ToPrometheusQueryLanguageConditionPtrOutputWithContext(context.Context) PrometheusQueryLanguageConditionPtrOutput
}

type prometheusQueryLanguageConditionPtrType PrometheusQueryLanguageConditionArgs

func PrometheusQueryLanguageConditionPtr(v *PrometheusQueryLanguageConditionArgs) PrometheusQueryLanguageConditionPtrInput {
	return (*prometheusQueryLanguageConditionPtrType)(v)
}

func (*prometheusQueryLanguageConditionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PrometheusQueryLanguageCondition)(nil)).Elem()
}

func (i *prometheusQueryLanguageConditionPtrType) ToPrometheusQueryLanguageConditionPtrOutput() PrometheusQueryLanguageConditionPtrOutput {
	return i.ToPrometheusQueryLanguageConditionPtrOutputWithContext(context.Background())
}

func (i *prometheusQueryLanguageConditionPtrType) ToPrometheusQueryLanguageConditionPtrOutputWithContext(ctx context.Context) PrometheusQueryLanguageConditionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrometheusQueryLanguageConditionPtrOutput)
}

// A condition type that allows alert policies to be defined using Prometheus Query Language (PromQL) (https://prometheus.io/docs/prometheus/latest/querying/basics/).The PrometheusQueryLanguageCondition message contains information from a Prometheus alerting rule and its associated rule group.A Prometheus alerting rule is described here (https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/). The semantics of a Prometheus alerting rule is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule).A Prometheus rule group is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/). The semantics of a Prometheus rule group is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule_group).Because Cloud Alerting has no representation of a Prometheus rule group resource, we must embed the information of the parent rule group inside each of the conditions that refer to it. We must also update the contents of all Prometheus alerts in case the information of their rule group changes.The PrometheusQueryLanguageCondition protocol buffer combines the information of the corresponding rule group and alerting rule. The structure of the PrometheusQueryLanguageCondition protocol buffer does NOT mimic the structure of the Prometheus rule group and alerting rule YAML declarations. The PrometheusQueryLanguageCondition protocol buffer may change in the future to support future rule group and/or alerting rule features. There are no new such features at the present time (2023-06-26).
type PrometheusQueryLanguageConditionOutput struct{ *pulumi.OutputState }

func (PrometheusQueryLanguageConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrometheusQueryLanguageCondition)(nil)).Elem()
}

func (o PrometheusQueryLanguageConditionOutput) ToPrometheusQueryLanguageConditionOutput() PrometheusQueryLanguageConditionOutput {
	return o
}

func (o PrometheusQueryLanguageConditionOutput) ToPrometheusQueryLanguageConditionOutputWithContext(ctx context.Context) PrometheusQueryLanguageConditionOutput {
	return o
}

func (o PrometheusQueryLanguageConditionOutput) ToPrometheusQueryLanguageConditionPtrOutput() PrometheusQueryLanguageConditionPtrOutput {
	return o.ToPrometheusQueryLanguageConditionPtrOutputWithContext(context.Background())
}

func (o PrometheusQueryLanguageConditionOutput) ToPrometheusQueryLanguageConditionPtrOutputWithContext(ctx context.Context) PrometheusQueryLanguageConditionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PrometheusQueryLanguageCondition) *PrometheusQueryLanguageCondition {
		return &v
	}).(PrometheusQueryLanguageConditionPtrOutput)
}

// Optional. The alerting rule name of this alert in the corresponding Prometheus configuration file.Some external tools may require this field to be populated correctly in order to refer to the original Prometheus configuration file. The rule group name and the alert name are necessary to update the relevant AlertPolicies in case the definition of the rule group changes in the future.This field is optional. If this field is not empty, then it must be a valid Prometheus label name (https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels). This field may not exceed 2048 Unicode characters in length.
func (o PrometheusQueryLanguageConditionOutput) AlertRule() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrometheusQueryLanguageCondition) *string { return v.AlertRule }).(pulumi.StringPtrOutput)
}

// Optional. Alerts are considered firing once their PromQL expression was evaluated to be "true" for this long. Alerts whose PromQL expression was not evaluated to be "true" for long enough are considered pending. Must be a non-negative duration or missing. This field is optional. Its default value is zero.
func (o PrometheusQueryLanguageConditionOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrometheusQueryLanguageCondition) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// Optional. How often this rule should be evaluated. Must be a positive multiple of 30 seconds or missing. This field is optional. Its default value is 30 seconds. If this PrometheusQueryLanguageCondition was generated from a Prometheus alerting rule, then this value should be taken from the enclosing rule group.
func (o PrometheusQueryLanguageConditionOutput) EvaluationInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrometheusQueryLanguageCondition) *string { return v.EvaluationInterval }).(pulumi.StringPtrOutput)
}

// Optional. Labels to add to or overwrite in the PromQL query result. Label names must be valid (https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels). Label values can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables). The only available variable names are the names of the labels in the PromQL result, including "__name__" and "value". "labels" may be empty.
func (o PrometheusQueryLanguageConditionOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v PrometheusQueryLanguageCondition) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// The PromQL expression to evaluate. Every evaluation cycle this expression is evaluated at the current time, and all resultant time series become pending/firing alerts. This field must not be empty.
func (o PrometheusQueryLanguageConditionOutput) Query() pulumi.StringOutput {
	return o.ApplyT(func(v PrometheusQueryLanguageCondition) string { return v.Query }).(pulumi.StringOutput)
}

// Optional. The rule group name of this alert in the corresponding Prometheus configuration file.Some external tools may require this field to be populated correctly in order to refer to the original Prometheus configuration file. The rule group name and the alert name are necessary to update the relevant AlertPolicies in case the definition of the rule group changes in the future.This field is optional. If this field is not empty, then it must contain a valid UTF-8 string. This field may not exceed 2048 Unicode characters in length.
func (o PrometheusQueryLanguageConditionOutput) RuleGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PrometheusQueryLanguageCondition) *string { return v.RuleGroup }).(pulumi.StringPtrOutput)
}

type PrometheusQueryLanguageConditionPtrOutput struct{ *pulumi.OutputState }

func (PrometheusQueryLanguageConditionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PrometheusQueryLanguageCondition)(nil)).Elem()
}

func (o PrometheusQueryLanguageConditionPtrOutput) ToPrometheusQueryLanguageConditionPtrOutput() PrometheusQueryLanguageConditionPtrOutput {
	return o
}

func (o PrometheusQueryLanguageConditionPtrOutput) ToPrometheusQueryLanguageConditionPtrOutputWithContext(ctx context.Context) PrometheusQueryLanguageConditionPtrOutput {
	return o
}

func (o PrometheusQueryLanguageConditionPtrOutput) Elem() PrometheusQueryLanguageConditionOutput {
	return o.ApplyT(func(v *PrometheusQueryLanguageCondition) PrometheusQueryLanguageCondition {
		if v != nil {
			return *v
		}
		var ret PrometheusQueryLanguageCondition
		return ret
	}).(PrometheusQueryLanguageConditionOutput)
}

// Optional. The alerting rule name of this alert in the corresponding Prometheus configuration file.Some external tools may require this field to be populated correctly in order to refer to the original Prometheus configuration file. The rule group name and the alert name are necessary to update the relevant AlertPolicies in case the definition of the rule group changes in the future.This field is optional. If this field is not empty, then it must be a valid Prometheus label name (https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels). This field may not exceed 2048 Unicode characters in length.
func (o PrometheusQueryLanguageConditionPtrOutput) AlertRule() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrometheusQueryLanguageCondition) *string {
		if v == nil {
			return nil
		}
		return v.AlertRule
	}).(pulumi.StringPtrOutput)
}

// Optional. Alerts are considered firing once their PromQL expression was evaluated to be "true" for this long. Alerts whose PromQL expression was not evaluated to be "true" for long enough are considered pending. Must be a non-negative duration or missing. This field is optional. Its default value is zero.
func (o PrometheusQueryLanguageConditionPtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrometheusQueryLanguageCondition) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// Optional. How often this rule should be evaluated. Must be a positive multiple of 30 seconds or missing. This field is optional. Its default value is 30 seconds. If this PrometheusQueryLanguageCondition was generated from a Prometheus alerting rule, then this value should be taken from the enclosing rule group.
func (o PrometheusQueryLanguageConditionPtrOutput) EvaluationInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrometheusQueryLanguageCondition) *string {
		if v == nil {
			return nil
		}
		return v.EvaluationInterval
	}).(pulumi.StringPtrOutput)
}

// Optional. Labels to add to or overwrite in the PromQL query result. Label names must be valid (https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels). Label values can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables). The only available variable names are the names of the labels in the PromQL result, including "__name__" and "value". "labels" may be empty.
func (o PrometheusQueryLanguageConditionPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *PrometheusQueryLanguageCondition) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// The PromQL expression to evaluate. Every evaluation cycle this expression is evaluated at the current time, and all resultant time series become pending/firing alerts. This field must not be empty.
func (o PrometheusQueryLanguageConditionPtrOutput) Query() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrometheusQueryLanguageCondition) *string {
		if v == nil {
			return nil
		}
		return &v.Query
	}).(pulumi.StringPtrOutput)
}

// Optional. The rule group name of this alert in the corresponding Prometheus configuration file.Some external tools may require this field to be populated correctly in order to refer to the original Prometheus configuration file. The rule group name and the alert name are necessary to update the relevant AlertPolicies in case the definition of the rule group changes in the future.This field is optional. If this field is not empty, then it must contain a valid UTF-8 string. This field may not exceed 2048 Unicode characters in length.
func (o PrometheusQueryLanguageConditionPtrOutput) RuleGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PrometheusQueryLanguageCondition) *string {
		if v == nil {
			return nil
		}
		return v.RuleGroup
	}).(pulumi.StringPtrOutput)
}

// A condition type that allows alert policies to be defined using Prometheus Query Language (PromQL) (https://prometheus.io/docs/prometheus/latest/querying/basics/).The PrometheusQueryLanguageCondition message contains information from a Prometheus alerting rule and its associated rule group.A Prometheus alerting rule is described here (https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/). The semantics of a Prometheus alerting rule is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule).A Prometheus rule group is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/). The semantics of a Prometheus rule group is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule_group).Because Cloud Alerting has no representation of a Prometheus rule group resource, we must embed the information of the parent rule group inside each of the conditions that refer to it. We must also update the contents of all Prometheus alerts in case the information of their rule group changes.The PrometheusQueryLanguageCondition protocol buffer combines the information of the corresponding rule group and alerting rule. The structure of the PrometheusQueryLanguageCondition protocol buffer does NOT mimic the structure of the Prometheus rule group and alerting rule YAML declarations. The PrometheusQueryLanguageCondition protocol buffer may change in the future to support future rule group and/or alerting rule features. There are no new such features at the present time (2023-06-26).
type PrometheusQueryLanguageConditionResponse struct {
	// Optional. The alerting rule name of this alert in the corresponding Prometheus configuration file.Some external tools may require this field to be populated correctly in order to refer to the original Prometheus configuration file. The rule group name and the alert name are necessary to update the relevant AlertPolicies in case the definition of the rule group changes in the future.This field is optional. If this field is not empty, then it must be a valid Prometheus label name (https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels). This field may not exceed 2048 Unicode characters in length.
	AlertRule string `pulumi:"alertRule"`
	// Optional. Alerts are considered firing once their PromQL expression was evaluated to be "true" for this long. Alerts whose PromQL expression was not evaluated to be "true" for long enough are considered pending. Must be a non-negative duration or missing. This field is optional. Its default value is zero.
	Duration string `pulumi:"duration"`
	// Optional. How often this rule should be evaluated. Must be a positive multiple of 30 seconds or missing. This field is optional. Its default value is 30 seconds. If this PrometheusQueryLanguageCondition was generated from a Prometheus alerting rule, then this value should be taken from the enclosing rule group.
	EvaluationInterval string `pulumi:"evaluationInterval"`
	// Optional. Labels to add to or overwrite in the PromQL query result. Label names must be valid (https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels). Label values can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables). The only available variable names are the names of the labels in the PromQL result, including "__name__" and "value". "labels" may be empty.
	Labels map[string]string `pulumi:"labels"`
	// The PromQL expression to evaluate. Every evaluation cycle this expression is evaluated at the current time, and all resultant time series become pending/firing alerts. This field must not be empty.
	Query string `pulumi:"query"`
	// Optional. The rule group name of this alert in the corresponding Prometheus configuration file.Some external tools may require this field to be populated correctly in order to refer to the original Prometheus configuration file. The rule group name and the alert name are necessary to update the relevant AlertPolicies in case the definition of the rule group changes in the future.This field is optional. If this field is not empty, then it must contain a valid UTF-8 string. This field may not exceed 2048 Unicode characters in length.
	RuleGroup string `pulumi:"ruleGroup"`
}

// A condition type that allows alert policies to be defined using Prometheus Query Language (PromQL) (https://prometheus.io/docs/prometheus/latest/querying/basics/).The PrometheusQueryLanguageCondition message contains information from a Prometheus alerting rule and its associated rule group.A Prometheus alerting rule is described here (https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/). The semantics of a Prometheus alerting rule is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule).A Prometheus rule group is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/). The semantics of a Prometheus rule group is described here (https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule_group).Because Cloud Alerting has no representation of a Prometheus rule group resource, we must embed the information of the parent rule group inside each of the conditions that refer to it. We must also update the contents of all Prometheus alerts in case the information of their rule group changes.The PrometheusQueryLanguageCondition protocol buffer combines the information of the corresponding rule group and alerting rule. The structure of the PrometheusQueryLanguageCondition protocol buffer does NOT mimic the structure of the Prometheus rule group and alerting rule YAML declarations. The PrometheusQueryLanguageCondition protocol buffer may change in the future to support future rule group and/or alerting rule features. There are no new such features at the present time (2023-06-26).
type PrometheusQueryLanguageConditionResponseOutput struct{ *pulumi.OutputState }

func (PrometheusQueryLanguageConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrometheusQueryLanguageConditionResponse)(nil)).Elem()
}

func (o PrometheusQueryLanguageConditionResponseOutput) ToPrometheusQueryLanguageConditionResponseOutput() PrometheusQueryLanguageConditionResponseOutput {
	return o
}

func (o PrometheusQueryLanguageConditionResponseOutput) ToPrometheusQueryLanguageConditionResponseOutputWithContext(ctx context.Context) PrometheusQueryLanguageConditionResponseOutput {
	return o
}

// Optional. The alerting rule name of this alert in the corresponding Prometheus configuration file.Some external tools may require this field to be populated correctly in order to refer to the original Prometheus configuration file. The rule group name and the alert name are necessary to update the relevant AlertPolicies in case the definition of the rule group changes in the future.This field is optional. If this field is not empty, then it must be a valid Prometheus label name (https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels). This field may not exceed 2048 Unicode characters in length.
func (o PrometheusQueryLanguageConditionResponseOutput) AlertRule() pulumi.StringOutput {
	return o.ApplyT(func(v PrometheusQueryLanguageConditionResponse) string { return v.AlertRule }).(pulumi.StringOutput)
}

// Optional. Alerts are considered firing once their PromQL expression was evaluated to be "true" for this long. Alerts whose PromQL expression was not evaluated to be "true" for long enough are considered pending. Must be a non-negative duration or missing. This field is optional. Its default value is zero.
func (o PrometheusQueryLanguageConditionResponseOutput) Duration() pulumi.StringOutput {
	return o.ApplyT(func(v PrometheusQueryLanguageConditionResponse) string { return v.Duration }).(pulumi.StringOutput)
}

// Optional. How often this rule should be evaluated. Must be a positive multiple of 30 seconds or missing. This field is optional. Its default value is 30 seconds. If this PrometheusQueryLanguageCondition was generated from a Prometheus alerting rule, then this value should be taken from the enclosing rule group.
func (o PrometheusQueryLanguageConditionResponseOutput) EvaluationInterval() pulumi.StringOutput {
	return o.ApplyT(func(v PrometheusQueryLanguageConditionResponse) string { return v.EvaluationInterval }).(pulumi.StringOutput)
}

// Optional. Labels to add to or overwrite in the PromQL query result. Label names must be valid (https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels). Label values can be templatized by using variables (https://cloud.google.com/monitoring/alerts/doc-variables). The only available variable names are the names of the labels in the PromQL result, including "__name__" and "value". "labels" may be empty.
func (o PrometheusQueryLanguageConditionResponseOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v PrometheusQueryLanguageConditionResponse) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// The PromQL expression to evaluate. Every evaluation cycle this expression is evaluated at the current time, and all resultant time series become pending/firing alerts. This field must not be empty.
func (o PrometheusQueryLanguageConditionResponseOutput) Query() pulumi.StringOutput {
	return o.ApplyT(func(v PrometheusQueryLanguageConditionResponse) string { return v.Query }).(pulumi.StringOutput)
}

// Optional. The rule group name of this alert in the corresponding Prometheus configuration file.Some external tools may require this field to be populated correctly in order to refer to the original Prometheus configuration file. The rule group name and the alert name are necessary to update the relevant AlertPolicies in case the definition of the rule group changes in the future.This field is optional. If this field is not empty, then it must contain a valid UTF-8 string. This field may not exceed 2048 Unicode characters in length.
func (o PrometheusQueryLanguageConditionResponseOutput) RuleGroup() pulumi.StringOutput {
	return o.ApplyT(func(v PrometheusQueryLanguageConditionResponse) string { return v.RuleGroup }).(pulumi.StringOutput)
}

// Service Level Indicators for which atomic units of service are counted directly.
type RequestBasedSli struct {
	// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
	DistributionCut *DistributionCut `pulumi:"distributionCut"`
	// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
	GoodTotalRatio *TimeSeriesRatio `pulumi:"goodTotalRatio"`
}

// RequestBasedSliInput is an input type that accepts RequestBasedSliArgs and RequestBasedSliOutput values.
// You can construct a concrete instance of `RequestBasedSliInput` via:
//
//	RequestBasedSliArgs{...}
type RequestBasedSliInput interface {
	pulumi.Input

	ToRequestBasedSliOutput() RequestBasedSliOutput
	ToRequestBasedSliOutputWithContext(context.Context) RequestBasedSliOutput
}

// Service Level Indicators for which atomic units of service are counted directly.
type RequestBasedSliArgs struct {
	// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
	DistributionCut DistributionCutPtrInput `pulumi:"distributionCut"`
	// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
	GoodTotalRatio TimeSeriesRatioPtrInput `pulumi:"goodTotalRatio"`
}

func (RequestBasedSliArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RequestBasedSli)(nil)).Elem()
}

func (i RequestBasedSliArgs) ToRequestBasedSliOutput() RequestBasedSliOutput {
	return i.ToRequestBasedSliOutputWithContext(context.Background())
}

func (i RequestBasedSliArgs) ToRequestBasedSliOutputWithContext(ctx context.Context) RequestBasedSliOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequestBasedSliOutput)
}

func (i RequestBasedSliArgs) ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput {
	return i.ToRequestBasedSliPtrOutputWithContext(context.Background())
}

func (i RequestBasedSliArgs) ToRequestBasedSliPtrOutputWithContext(ctx context.Context) RequestBasedSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequestBasedSliOutput).ToRequestBasedSliPtrOutputWithContext(ctx)
}

// RequestBasedSliPtrInput is an input type that accepts RequestBasedSliArgs, RequestBasedSliPtr and RequestBasedSliPtrOutput values.
// You can construct a concrete instance of `RequestBasedSliPtrInput` via:
//
//	        RequestBasedSliArgs{...}
//
//	or:
//
//	        nil
type RequestBasedSliPtrInput interface {
	pulumi.Input

	ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput
	ToRequestBasedSliPtrOutputWithContext(context.Context) RequestBasedSliPtrOutput
}

type requestBasedSliPtrType RequestBasedSliArgs

func RequestBasedSliPtr(v *RequestBasedSliArgs) RequestBasedSliPtrInput {
	return (*requestBasedSliPtrType)(v)
}

func (*requestBasedSliPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RequestBasedSli)(nil)).Elem()
}

func (i *requestBasedSliPtrType) ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput {
	return i.ToRequestBasedSliPtrOutputWithContext(context.Background())
}

func (i *requestBasedSliPtrType) ToRequestBasedSliPtrOutputWithContext(ctx context.Context) RequestBasedSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequestBasedSliPtrOutput)
}

// Service Level Indicators for which atomic units of service are counted directly.
type RequestBasedSliOutput struct{ *pulumi.OutputState }

func (RequestBasedSliOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RequestBasedSli)(nil)).Elem()
}

func (o RequestBasedSliOutput) ToRequestBasedSliOutput() RequestBasedSliOutput {
	return o
}

func (o RequestBasedSliOutput) ToRequestBasedSliOutputWithContext(ctx context.Context) RequestBasedSliOutput {
	return o
}

func (o RequestBasedSliOutput) ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput {
	return o.ToRequestBasedSliPtrOutputWithContext(context.Background())
}

func (o RequestBasedSliOutput) ToRequestBasedSliPtrOutputWithContext(ctx context.Context) RequestBasedSliPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RequestBasedSli) *RequestBasedSli {
		return &v
	}).(RequestBasedSliPtrOutput)
}

// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
func (o RequestBasedSliOutput) DistributionCut() DistributionCutPtrOutput {
	return o.ApplyT(func(v RequestBasedSli) *DistributionCut { return v.DistributionCut }).(DistributionCutPtrOutput)
}

// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
func (o RequestBasedSliOutput) GoodTotalRatio() TimeSeriesRatioPtrOutput {
	return o.ApplyT(func(v RequestBasedSli) *TimeSeriesRatio { return v.GoodTotalRatio }).(TimeSeriesRatioPtrOutput)
}

type RequestBasedSliPtrOutput struct{ *pulumi.OutputState }

func (RequestBasedSliPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RequestBasedSli)(nil)).Elem()
}

func (o RequestBasedSliPtrOutput) ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput {
	return o
}

func (o RequestBasedSliPtrOutput) ToRequestBasedSliPtrOutputWithContext(ctx context.Context) RequestBasedSliPtrOutput {
	return o
}

func (o RequestBasedSliPtrOutput) Elem() RequestBasedSliOutput {
	return o.ApplyT(func(v *RequestBasedSli) RequestBasedSli {
		if v != nil {
			return *v
		}
		var ret RequestBasedSli
		return ret
	}).(RequestBasedSliOutput)
}

// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
func (o RequestBasedSliPtrOutput) DistributionCut() DistributionCutPtrOutput {
	return o.ApplyT(func(v *RequestBasedSli) *DistributionCut {
		if v == nil {
			return nil
		}
		return v.DistributionCut
	}).(DistributionCutPtrOutput)
}

// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
func (o RequestBasedSliPtrOutput) GoodTotalRatio() TimeSeriesRatioPtrOutput {
	return o.ApplyT(func(v *RequestBasedSli) *TimeSeriesRatio {
		if v == nil {
			return nil
		}
		return v.GoodTotalRatio
	}).(TimeSeriesRatioPtrOutput)
}

// Service Level Indicators for which atomic units of service are counted directly.
type RequestBasedSliResponse struct {
	// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
	DistributionCut DistributionCutResponse `pulumi:"distributionCut"`
	// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
	GoodTotalRatio TimeSeriesRatioResponse `pulumi:"goodTotalRatio"`
}

// Service Level Indicators for which atomic units of service are counted directly.
type RequestBasedSliResponseOutput struct{ *pulumi.OutputState }

func (RequestBasedSliResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RequestBasedSliResponse)(nil)).Elem()
}

func (o RequestBasedSliResponseOutput) ToRequestBasedSliResponseOutput() RequestBasedSliResponseOutput {
	return o
}

func (o RequestBasedSliResponseOutput) ToRequestBasedSliResponseOutputWithContext(ctx context.Context) RequestBasedSliResponseOutput {
	return o
}

// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
func (o RequestBasedSliResponseOutput) DistributionCut() DistributionCutResponseOutput {
	return o.ApplyT(func(v RequestBasedSliResponse) DistributionCutResponse { return v.DistributionCut }).(DistributionCutResponseOutput)
}

// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
func (o RequestBasedSliResponseOutput) GoodTotalRatio() TimeSeriesRatioResponseOutput {
	return o.ApplyT(func(v RequestBasedSliResponse) TimeSeriesRatioResponse { return v.GoodTotalRatio }).(TimeSeriesRatioResponseOutput)
}

// The resource submessage for group checks. It can be used instead of a monitored resource, when multiple resources are being monitored.
type ResourceGroup struct {
	// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
	GroupId *string `pulumi:"groupId"`
	// The resource type of the group members.
	ResourceType *ResourceGroupResourceType `pulumi:"resourceType"`
}

// ResourceGroupInput is an input type that accepts ResourceGroupArgs and ResourceGroupOutput values.
// You can construct a concrete instance of `ResourceGroupInput` via:
//
//	ResourceGroupArgs{...}
type ResourceGroupInput interface {
	pulumi.Input

	ToResourceGroupOutput() ResourceGroupOutput
	ToResourceGroupOutputWithContext(context.Context) ResourceGroupOutput
}

// The resource submessage for group checks. It can be used instead of a monitored resource, when multiple resources are being monitored.
type ResourceGroupArgs struct {
	// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
	GroupId pulumi.StringPtrInput `pulumi:"groupId"`
	// The resource type of the group members.
	ResourceType ResourceGroupResourceTypePtrInput `pulumi:"resourceType"`
}

func (ResourceGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceGroup)(nil)).Elem()
}

func (i ResourceGroupArgs) ToResourceGroupOutput() ResourceGroupOutput {
	return i.ToResourceGroupOutputWithContext(context.Background())
}

func (i ResourceGroupArgs) ToResourceGroupOutputWithContext(ctx context.Context) ResourceGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceGroupOutput)
}

func (i ResourceGroupArgs) ToResourceGroupPtrOutput() ResourceGroupPtrOutput {
	return i.ToResourceGroupPtrOutputWithContext(context.Background())
}

func (i ResourceGroupArgs) ToResourceGroupPtrOutputWithContext(ctx context.Context) ResourceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceGroupOutput).ToResourceGroupPtrOutputWithContext(ctx)
}

// ResourceGroupPtrInput is an input type that accepts ResourceGroupArgs, ResourceGroupPtr and ResourceGroupPtrOutput values.
// You can construct a concrete instance of `ResourceGroupPtrInput` via:
//
//	        ResourceGroupArgs{...}
//
//	or:
//
//	        nil
type ResourceGroupPtrInput interface {
	pulumi.Input

	ToResourceGroupPtrOutput() ResourceGroupPtrOutput
	ToResourceGroupPtrOutputWithContext(context.Context) ResourceGroupPtrOutput
}

type resourceGroupPtrType ResourceGroupArgs

func ResourceGroupPtr(v *ResourceGroupArgs) ResourceGroupPtrInput {
	return (*resourceGroupPtrType)(v)
}

func (*resourceGroupPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceGroup)(nil)).Elem()
}

func (i *resourceGroupPtrType) ToResourceGroupPtrOutput() ResourceGroupPtrOutput {
	return i.ToResourceGroupPtrOutputWithContext(context.Background())
}

func (i *resourceGroupPtrType) ToResourceGroupPtrOutputWithContext(ctx context.Context) ResourceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceGroupPtrOutput)
}

// The resource submessage for group checks. It can be used instead of a monitored resource, when multiple resources are being monitored.
type ResourceGroupOutput struct{ *pulumi.OutputState }

func (ResourceGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceGroup)(nil)).Elem()
}

func (o ResourceGroupOutput) ToResourceGroupOutput() ResourceGroupOutput {
	return o
}

func (o ResourceGroupOutput) ToResourceGroupOutputWithContext(ctx context.Context) ResourceGroupOutput {
	return o
}

func (o ResourceGroupOutput) ToResourceGroupPtrOutput() ResourceGroupPtrOutput {
	return o.ToResourceGroupPtrOutputWithContext(context.Background())
}

func (o ResourceGroupOutput) ToResourceGroupPtrOutputWithContext(ctx context.Context) ResourceGroupPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceGroup) *ResourceGroup {
		return &v
	}).(ResourceGroupPtrOutput)
}

// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
func (o ResourceGroupOutput) GroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceGroup) *string { return v.GroupId }).(pulumi.StringPtrOutput)
}

// The resource type of the group members.
func (o ResourceGroupOutput) ResourceType() ResourceGroupResourceTypePtrOutput {
	return o.ApplyT(func(v ResourceGroup) *ResourceGroupResourceType { return v.ResourceType }).(ResourceGroupResourceTypePtrOutput)
}

type ResourceGroupPtrOutput struct{ *pulumi.OutputState }

func (ResourceGroupPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceGroup)(nil)).Elem()
}

func (o ResourceGroupPtrOutput) ToResourceGroupPtrOutput() ResourceGroupPtrOutput {
	return o
}

func (o ResourceGroupPtrOutput) ToResourceGroupPtrOutputWithContext(ctx context.Context) ResourceGroupPtrOutput {
	return o
}

func (o ResourceGroupPtrOutput) Elem() ResourceGroupOutput {
	return o.ApplyT(func(v *ResourceGroup) ResourceGroup {
		if v != nil {
			return *v
		}
		var ret ResourceGroup
		return ret
	}).(ResourceGroupOutput)
}

// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
func (o ResourceGroupPtrOutput) GroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceGroup) *string {
		if v == nil {
			return nil
		}
		return v.GroupId
	}).(pulumi.StringPtrOutput)
}

// The resource type of the group members.
func (o ResourceGroupPtrOutput) ResourceType() ResourceGroupResourceTypePtrOutput {
	return o.ApplyT(func(v *ResourceGroup) *ResourceGroupResourceType {
		if v == nil {
			return nil
		}
		return v.ResourceType
	}).(ResourceGroupResourceTypePtrOutput)
}

// The resource submessage for group checks. It can be used instead of a monitored resource, when multiple resources are being monitored.
type ResourceGroupResponse struct {
	// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
	GroupId string `pulumi:"groupId"`
	// The resource type of the group members.
	ResourceType string `pulumi:"resourceType"`
}

// The resource submessage for group checks. It can be used instead of a monitored resource, when multiple resources are being monitored.
type ResourceGroupResponseOutput struct{ *pulumi.OutputState }

func (ResourceGroupResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceGroupResponse)(nil)).Elem()
}

func (o ResourceGroupResponseOutput) ToResourceGroupResponseOutput() ResourceGroupResponseOutput {
	return o
}

func (o ResourceGroupResponseOutput) ToResourceGroupResponseOutputWithContext(ctx context.Context) ResourceGroupResponseOutput {
	return o
}

// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
func (o ResourceGroupResponseOutput) GroupId() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceGroupResponse) string { return v.GroupId }).(pulumi.StringOutput)
}

// The resource type of the group members.
func (o ResourceGroupResponseOutput) ResourceType() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceGroupResponse) string { return v.ResourceType }).(pulumi.StringOutput)
}

// A status to accept. Either a status code class like "2xx", or an integer status code like "200".
type ResponseStatusCode struct {
	// A class of status codes to accept.
	StatusClass *ResponseStatusCodeStatusClass `pulumi:"statusClass"`
	// A status code to accept.
	StatusValue *int `pulumi:"statusValue"`
}

// ResponseStatusCodeInput is an input type that accepts ResponseStatusCodeArgs and ResponseStatusCodeOutput values.
// You can construct a concrete instance of `ResponseStatusCodeInput` via:
//
//	ResponseStatusCodeArgs{...}
type ResponseStatusCodeInput interface {
	pulumi.Input

	ToResponseStatusCodeOutput() ResponseStatusCodeOutput
	ToResponseStatusCodeOutputWithContext(context.Context) ResponseStatusCodeOutput
}

// A status to accept. Either a status code class like "2xx", or an integer status code like "200".
type ResponseStatusCodeArgs struct {
	// A class of status codes to accept.
	StatusClass ResponseStatusCodeStatusClassPtrInput `pulumi:"statusClass"`
	// A status code to accept.
	StatusValue pulumi.IntPtrInput `pulumi:"statusValue"`
}

func (ResponseStatusCodeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResponseStatusCode)(nil)).Elem()
}

func (i ResponseStatusCodeArgs) ToResponseStatusCodeOutput() ResponseStatusCodeOutput {
	return i.ToResponseStatusCodeOutputWithContext(context.Background())
}

func (i ResponseStatusCodeArgs) ToResponseStatusCodeOutputWithContext(ctx context.Context) ResponseStatusCodeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResponseStatusCodeOutput)
}

// ResponseStatusCodeArrayInput is an input type that accepts ResponseStatusCodeArray and ResponseStatusCodeArrayOutput values.
// You can construct a concrete instance of `ResponseStatusCodeArrayInput` via:
//
//	ResponseStatusCodeArray{ ResponseStatusCodeArgs{...} }
type ResponseStatusCodeArrayInput interface {
	pulumi.Input

	ToResponseStatusCodeArrayOutput() ResponseStatusCodeArrayOutput
	ToResponseStatusCodeArrayOutputWithContext(context.Context) ResponseStatusCodeArrayOutput
}

type ResponseStatusCodeArray []ResponseStatusCodeInput

func (ResponseStatusCodeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResponseStatusCode)(nil)).Elem()
}

func (i ResponseStatusCodeArray) ToResponseStatusCodeArrayOutput() ResponseStatusCodeArrayOutput {
	return i.ToResponseStatusCodeArrayOutputWithContext(context.Background())
}

func (i ResponseStatusCodeArray) ToResponseStatusCodeArrayOutputWithContext(ctx context.Context) ResponseStatusCodeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResponseStatusCodeArrayOutput)
}

// A status to accept. Either a status code class like "2xx", or an integer status code like "200".
type ResponseStatusCodeOutput struct{ *pulumi.OutputState }

func (ResponseStatusCodeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResponseStatusCode)(nil)).Elem()
}

func (o ResponseStatusCodeOutput) ToResponseStatusCodeOutput() ResponseStatusCodeOutput {
	return o
}

func (o ResponseStatusCodeOutput) ToResponseStatusCodeOutputWithContext(ctx context.Context) ResponseStatusCodeOutput {
	return o
}

// A class of status codes to accept.
func (o ResponseStatusCodeOutput) StatusClass() ResponseStatusCodeStatusClassPtrOutput {
	return o.ApplyT(func(v ResponseStatusCode) *ResponseStatusCodeStatusClass { return v.StatusClass }).(ResponseStatusCodeStatusClassPtrOutput)
}

// A status code to accept.
func (o ResponseStatusCodeOutput) StatusValue() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ResponseStatusCode) *int { return v.StatusValue }).(pulumi.IntPtrOutput)
}

type ResponseStatusCodeArrayOutput struct{ *pulumi.OutputState }

func (ResponseStatusCodeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResponseStatusCode)(nil)).Elem()
}

func (o ResponseStatusCodeArrayOutput) ToResponseStatusCodeArrayOutput() ResponseStatusCodeArrayOutput {
	return o
}

func (o ResponseStatusCodeArrayOutput) ToResponseStatusCodeArrayOutputWithContext(ctx context.Context) ResponseStatusCodeArrayOutput {
	return o
}

func (o ResponseStatusCodeArrayOutput) Index(i pulumi.IntInput) ResponseStatusCodeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResponseStatusCode {
		return vs[0].([]ResponseStatusCode)[vs[1].(int)]
	}).(ResponseStatusCodeOutput)
}

// A status to accept. Either a status code class like "2xx", or an integer status code like "200".
type ResponseStatusCodeResponse struct {
	// A class of status codes to accept.
	StatusClass string `pulumi:"statusClass"`
	// A status code to accept.
	StatusValue int `pulumi:"statusValue"`
}

// A status to accept. Either a status code class like "2xx", or an integer status code like "200".
type ResponseStatusCodeResponseOutput struct{ *pulumi.OutputState }

func (ResponseStatusCodeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResponseStatusCodeResponse)(nil)).Elem()
}

func (o ResponseStatusCodeResponseOutput) ToResponseStatusCodeResponseOutput() ResponseStatusCodeResponseOutput {
	return o
}

func (o ResponseStatusCodeResponseOutput) ToResponseStatusCodeResponseOutputWithContext(ctx context.Context) ResponseStatusCodeResponseOutput {
	return o
}

// A class of status codes to accept.
func (o ResponseStatusCodeResponseOutput) StatusClass() pulumi.StringOutput {
	return o.ApplyT(func(v ResponseStatusCodeResponse) string { return v.StatusClass }).(pulumi.StringOutput)
}

// A status code to accept.
func (o ResponseStatusCodeResponseOutput) StatusValue() pulumi.IntOutput {
	return o.ApplyT(func(v ResponseStatusCodeResponse) int { return v.StatusValue }).(pulumi.IntOutput)
}

type ResponseStatusCodeResponseArrayOutput struct{ *pulumi.OutputState }

func (ResponseStatusCodeResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ResponseStatusCodeResponse)(nil)).Elem()
}

func (o ResponseStatusCodeResponseArrayOutput) ToResponseStatusCodeResponseArrayOutput() ResponseStatusCodeResponseArrayOutput {
	return o
}

func (o ResponseStatusCodeResponseArrayOutput) ToResponseStatusCodeResponseArrayOutputWithContext(ctx context.Context) ResponseStatusCodeResponseArrayOutput {
	return o
}

func (o ResponseStatusCodeResponseArrayOutput) Index(i pulumi.IntInput) ResponseStatusCodeResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ResponseStatusCodeResponse {
		return vs[0].([]ResponseStatusCodeResponse)[vs[1].(int)]
	}).(ResponseStatusCodeResponseOutput)
}

// A Service-Level Indicator (SLI) describes the "performance" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a "custom" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.
type ServiceLevelIndicator struct {
	// Basic SLI on a well-known service type.
	BasicSli *BasicSli `pulumi:"basicSli"`
	// Request-based SLIs
	RequestBased *RequestBasedSli `pulumi:"requestBased"`
	// Windows-based SLIs
	WindowsBased *WindowsBasedSli `pulumi:"windowsBased"`
}

// ServiceLevelIndicatorInput is an input type that accepts ServiceLevelIndicatorArgs and ServiceLevelIndicatorOutput values.
// You can construct a concrete instance of `ServiceLevelIndicatorInput` via:
//
//	ServiceLevelIndicatorArgs{...}
type ServiceLevelIndicatorInput interface {
	pulumi.Input

	ToServiceLevelIndicatorOutput() ServiceLevelIndicatorOutput
	ToServiceLevelIndicatorOutputWithContext(context.Context) ServiceLevelIndicatorOutput
}

// A Service-Level Indicator (SLI) describes the "performance" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a "custom" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.
type ServiceLevelIndicatorArgs struct {
	// Basic SLI on a well-known service type.
	BasicSli BasicSliPtrInput `pulumi:"basicSli"`
	// Request-based SLIs
	RequestBased RequestBasedSliPtrInput `pulumi:"requestBased"`
	// Windows-based SLIs
	WindowsBased WindowsBasedSliPtrInput `pulumi:"windowsBased"`
}

func (ServiceLevelIndicatorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLevelIndicator)(nil)).Elem()
}

func (i ServiceLevelIndicatorArgs) ToServiceLevelIndicatorOutput() ServiceLevelIndicatorOutput {
	return i.ToServiceLevelIndicatorOutputWithContext(context.Background())
}

func (i ServiceLevelIndicatorArgs) ToServiceLevelIndicatorOutputWithContext(ctx context.Context) ServiceLevelIndicatorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLevelIndicatorOutput)
}

func (i ServiceLevelIndicatorArgs) ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput {
	return i.ToServiceLevelIndicatorPtrOutputWithContext(context.Background())
}

func (i ServiceLevelIndicatorArgs) ToServiceLevelIndicatorPtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLevelIndicatorOutput).ToServiceLevelIndicatorPtrOutputWithContext(ctx)
}

// ServiceLevelIndicatorPtrInput is an input type that accepts ServiceLevelIndicatorArgs, ServiceLevelIndicatorPtr and ServiceLevelIndicatorPtrOutput values.
// You can construct a concrete instance of `ServiceLevelIndicatorPtrInput` via:
//
//	        ServiceLevelIndicatorArgs{...}
//
//	or:
//
//	        nil
type ServiceLevelIndicatorPtrInput interface {
	pulumi.Input

	ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput
	ToServiceLevelIndicatorPtrOutputWithContext(context.Context) ServiceLevelIndicatorPtrOutput
}

type serviceLevelIndicatorPtrType ServiceLevelIndicatorArgs

func ServiceLevelIndicatorPtr(v *ServiceLevelIndicatorArgs) ServiceLevelIndicatorPtrInput {
	return (*serviceLevelIndicatorPtrType)(v)
}

func (*serviceLevelIndicatorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceLevelIndicator)(nil)).Elem()
}

func (i *serviceLevelIndicatorPtrType) ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput {
	return i.ToServiceLevelIndicatorPtrOutputWithContext(context.Background())
}

func (i *serviceLevelIndicatorPtrType) ToServiceLevelIndicatorPtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLevelIndicatorPtrOutput)
}

// A Service-Level Indicator (SLI) describes the "performance" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a "custom" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.
type ServiceLevelIndicatorOutput struct{ *pulumi.OutputState }

func (ServiceLevelIndicatorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLevelIndicator)(nil)).Elem()
}

func (o ServiceLevelIndicatorOutput) ToServiceLevelIndicatorOutput() ServiceLevelIndicatorOutput {
	return o
}

func (o ServiceLevelIndicatorOutput) ToServiceLevelIndicatorOutputWithContext(ctx context.Context) ServiceLevelIndicatorOutput {
	return o
}

func (o ServiceLevelIndicatorOutput) ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput {
	return o.ToServiceLevelIndicatorPtrOutputWithContext(context.Background())
}

func (o ServiceLevelIndicatorOutput) ToServiceLevelIndicatorPtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ServiceLevelIndicator) *ServiceLevelIndicator {
		return &v
	}).(ServiceLevelIndicatorPtrOutput)
}

// Basic SLI on a well-known service type.
func (o ServiceLevelIndicatorOutput) BasicSli() BasicSliPtrOutput {
	return o.ApplyT(func(v ServiceLevelIndicator) *BasicSli { return v.BasicSli }).(BasicSliPtrOutput)
}

// Request-based SLIs
func (o ServiceLevelIndicatorOutput) RequestBased() RequestBasedSliPtrOutput {
	return o.ApplyT(func(v ServiceLevelIndicator) *RequestBasedSli { return v.RequestBased }).(RequestBasedSliPtrOutput)
}

// Windows-based SLIs
func (o ServiceLevelIndicatorOutput) WindowsBased() WindowsBasedSliPtrOutput {
	return o.ApplyT(func(v ServiceLevelIndicator) *WindowsBasedSli { return v.WindowsBased }).(WindowsBasedSliPtrOutput)
}

type ServiceLevelIndicatorPtrOutput struct{ *pulumi.OutputState }

func (ServiceLevelIndicatorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceLevelIndicator)(nil)).Elem()
}

func (o ServiceLevelIndicatorPtrOutput) ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput {
	return o
}

func (o ServiceLevelIndicatorPtrOutput) ToServiceLevelIndicatorPtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorPtrOutput {
	return o
}

func (o ServiceLevelIndicatorPtrOutput) Elem() ServiceLevelIndicatorOutput {
	return o.ApplyT(func(v *ServiceLevelIndicator) ServiceLevelIndicator {
		if v != nil {
			return *v
		}
		var ret ServiceLevelIndicator
		return ret
	}).(ServiceLevelIndicatorOutput)
}

// Basic SLI on a well-known service type.
func (o ServiceLevelIndicatorPtrOutput) BasicSli() BasicSliPtrOutput {
	return o.ApplyT(func(v *ServiceLevelIndicator) *BasicSli {
		if v == nil {
			return nil
		}
		return v.BasicSli
	}).(BasicSliPtrOutput)
}

// Request-based SLIs
func (o ServiceLevelIndicatorPtrOutput) RequestBased() RequestBasedSliPtrOutput {
	return o.ApplyT(func(v *ServiceLevelIndicator) *RequestBasedSli {
		if v == nil {
			return nil
		}
		return v.RequestBased
	}).(RequestBasedSliPtrOutput)
}

// Windows-based SLIs
func (o ServiceLevelIndicatorPtrOutput) WindowsBased() WindowsBasedSliPtrOutput {
	return o.ApplyT(func(v *ServiceLevelIndicator) *WindowsBasedSli {
		if v == nil {
			return nil
		}
		return v.WindowsBased
	}).(WindowsBasedSliPtrOutput)
}

// A Service-Level Indicator (SLI) describes the "performance" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a "custom" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.
type ServiceLevelIndicatorResponse struct {
	// Basic SLI on a well-known service type.
	BasicSli BasicSliResponse `pulumi:"basicSli"`
	// Request-based SLIs
	RequestBased RequestBasedSliResponse `pulumi:"requestBased"`
	// Windows-based SLIs
	WindowsBased WindowsBasedSliResponse `pulumi:"windowsBased"`
}

// A Service-Level Indicator (SLI) describes the "performance" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a "custom" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.
type ServiceLevelIndicatorResponseOutput struct{ *pulumi.OutputState }

func (ServiceLevelIndicatorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLevelIndicatorResponse)(nil)).Elem()
}

func (o ServiceLevelIndicatorResponseOutput) ToServiceLevelIndicatorResponseOutput() ServiceLevelIndicatorResponseOutput {
	return o
}

func (o ServiceLevelIndicatorResponseOutput) ToServiceLevelIndicatorResponseOutputWithContext(ctx context.Context) ServiceLevelIndicatorResponseOutput {
	return o
}

// Basic SLI on a well-known service type.
func (o ServiceLevelIndicatorResponseOutput) BasicSli() BasicSliResponseOutput {
	return o.ApplyT(func(v ServiceLevelIndicatorResponse) BasicSliResponse { return v.BasicSli }).(BasicSliResponseOutput)
}

// Request-based SLIs
func (o ServiceLevelIndicatorResponseOutput) RequestBased() RequestBasedSliResponseOutput {
	return o.ApplyT(func(v ServiceLevelIndicatorResponse) RequestBasedSliResponse { return v.RequestBased }).(RequestBasedSliResponseOutput)
}

// Windows-based SLIs
func (o ServiceLevelIndicatorResponseOutput) WindowsBased() WindowsBasedSliResponseOutput {
	return o.ApplyT(func(v ServiceLevelIndicatorResponse) WindowsBasedSliResponse { return v.WindowsBased }).(WindowsBasedSliResponseOutput)
}

// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
type Status struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code *int `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details []map[string]interface{} `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message *string `pulumi:"message"`
}

// StatusInput is an input type that accepts StatusArgs and StatusOutput values.
// You can construct a concrete instance of `StatusInput` via:
//
//	StatusArgs{...}
type StatusInput interface {
	pulumi.Input

	ToStatusOutput() StatusOutput
	ToStatusOutputWithContext(context.Context) StatusOutput
}

// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
type StatusArgs struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code pulumi.IntPtrInput `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details pulumi.MapArrayInput `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message pulumi.StringPtrInput `pulumi:"message"`
}

func (StatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Status)(nil)).Elem()
}

func (i StatusArgs) ToStatusOutput() StatusOutput {
	return i.ToStatusOutputWithContext(context.Background())
}

func (i StatusArgs) ToStatusOutputWithContext(ctx context.Context) StatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusOutput)
}

func (i StatusArgs) ToStatusPtrOutput() StatusPtrOutput {
	return i.ToStatusPtrOutputWithContext(context.Background())
}

func (i StatusArgs) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusOutput).ToStatusPtrOutputWithContext(ctx)
}

// StatusPtrInput is an input type that accepts StatusArgs, StatusPtr and StatusPtrOutput values.
// You can construct a concrete instance of `StatusPtrInput` via:
//
//	        StatusArgs{...}
//
//	or:
//
//	        nil
type StatusPtrInput interface {
	pulumi.Input

	ToStatusPtrOutput() StatusPtrOutput
	ToStatusPtrOutputWithContext(context.Context) StatusPtrOutput
}

type statusPtrType StatusArgs

func StatusPtr(v *StatusArgs) StatusPtrInput {
	return (*statusPtrType)(v)
}

func (*statusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Status)(nil)).Elem()
}

func (i *statusPtrType) ToStatusPtrOutput() StatusPtrOutput {
	return i.ToStatusPtrOutputWithContext(context.Background())
}

func (i *statusPtrType) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusPtrOutput)
}

// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
type StatusOutput struct{ *pulumi.OutputState }

func (StatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Status)(nil)).Elem()
}

func (o StatusOutput) ToStatusOutput() StatusOutput {
	return o
}

func (o StatusOutput) ToStatusOutputWithContext(ctx context.Context) StatusOutput {
	return o
}

func (o StatusOutput) ToStatusPtrOutput() StatusPtrOutput {
	return o.ToStatusPtrOutputWithContext(context.Background())
}

func (o StatusOutput) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Status) *Status {
		return &v
	}).(StatusPtrOutput)
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusOutput) Code() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Status) *int { return v.Code }).(pulumi.IntPtrOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusOutput) Details() pulumi.MapArrayOutput {
	return o.ApplyT(func(v Status) []map[string]interface{} { return v.Details }).(pulumi.MapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Status) *string { return v.Message }).(pulumi.StringPtrOutput)
}

type StatusPtrOutput struct{ *pulumi.OutputState }

func (StatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Status)(nil)).Elem()
}

func (o StatusPtrOutput) ToStatusPtrOutput() StatusPtrOutput {
	return o
}

func (o StatusPtrOutput) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return o
}

func (o StatusPtrOutput) Elem() StatusOutput {
	return o.ApplyT(func(v *Status) Status {
		if v != nil {
			return *v
		}
		var ret Status
		return ret
	}).(StatusOutput)
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusPtrOutput) Code() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Status) *int {
		if v == nil {
			return nil
		}
		return v.Code
	}).(pulumi.IntPtrOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusPtrOutput) Details() pulumi.MapArrayOutput {
	return o.ApplyT(func(v *Status) []map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Details
	}).(pulumi.MapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusPtrOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Status) *string {
		if v == nil {
			return nil
		}
		return v.Message
	}).(pulumi.StringPtrOutput)
}

// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
type StatusResponse struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code int `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details []map[string]interface{} `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message string `pulumi:"message"`
}

// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
type StatusResponseOutput struct{ *pulumi.OutputState }

func (StatusResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatusResponse)(nil)).Elem()
}

func (o StatusResponseOutput) ToStatusResponseOutput() StatusResponseOutput {
	return o
}

func (o StatusResponseOutput) ToStatusResponseOutputWithContext(ctx context.Context) StatusResponseOutput {
	return o
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusResponseOutput) Code() pulumi.IntOutput {
	return o.ApplyT(func(v StatusResponse) int { return v.Code }).(pulumi.IntOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusResponseOutput) Details() pulumi.MapArrayOutput {
	return o.ApplyT(func(v StatusResponse) []map[string]interface{} { return v.Details }).(pulumi.MapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusResponseOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v StatusResponse) string { return v.Message }).(pulumi.StringOutput)
}

// Describes a Synthetic Monitor to be invoked by Uptime.
type SyntheticMonitorTarget struct {
	// Target a Synthetic Monitor GCFv2 instance.
	CloudFunctionV2 *CloudFunctionV2Target `pulumi:"cloudFunctionV2"`
}

// SyntheticMonitorTargetInput is an input type that accepts SyntheticMonitorTargetArgs and SyntheticMonitorTargetOutput values.
// You can construct a concrete instance of `SyntheticMonitorTargetInput` via:
//
//	SyntheticMonitorTargetArgs{...}
type SyntheticMonitorTargetInput interface {
	pulumi.Input

	ToSyntheticMonitorTargetOutput() SyntheticMonitorTargetOutput
	ToSyntheticMonitorTargetOutputWithContext(context.Context) SyntheticMonitorTargetOutput
}

// Describes a Synthetic Monitor to be invoked by Uptime.
type SyntheticMonitorTargetArgs struct {
	// Target a Synthetic Monitor GCFv2 instance.
	CloudFunctionV2 CloudFunctionV2TargetPtrInput `pulumi:"cloudFunctionV2"`
}

func (SyntheticMonitorTargetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SyntheticMonitorTarget)(nil)).Elem()
}

func (i SyntheticMonitorTargetArgs) ToSyntheticMonitorTargetOutput() SyntheticMonitorTargetOutput {
	return i.ToSyntheticMonitorTargetOutputWithContext(context.Background())
}

func (i SyntheticMonitorTargetArgs) ToSyntheticMonitorTargetOutputWithContext(ctx context.Context) SyntheticMonitorTargetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SyntheticMonitorTargetOutput)
}

func (i SyntheticMonitorTargetArgs) ToSyntheticMonitorTargetPtrOutput() SyntheticMonitorTargetPtrOutput {
	return i.ToSyntheticMonitorTargetPtrOutputWithContext(context.Background())
}

func (i SyntheticMonitorTargetArgs) ToSyntheticMonitorTargetPtrOutputWithContext(ctx context.Context) SyntheticMonitorTargetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SyntheticMonitorTargetOutput).ToSyntheticMonitorTargetPtrOutputWithContext(ctx)
}

// SyntheticMonitorTargetPtrInput is an input type that accepts SyntheticMonitorTargetArgs, SyntheticMonitorTargetPtr and SyntheticMonitorTargetPtrOutput values.
// You can construct a concrete instance of `SyntheticMonitorTargetPtrInput` via:
//
//	        SyntheticMonitorTargetArgs{...}
//
//	or:
//
//	        nil
type SyntheticMonitorTargetPtrInput interface {
	pulumi.Input

	ToSyntheticMonitorTargetPtrOutput() SyntheticMonitorTargetPtrOutput
	ToSyntheticMonitorTargetPtrOutputWithContext(context.Context) SyntheticMonitorTargetPtrOutput
}

type syntheticMonitorTargetPtrType SyntheticMonitorTargetArgs

func SyntheticMonitorTargetPtr(v *SyntheticMonitorTargetArgs) SyntheticMonitorTargetPtrInput {
	return (*syntheticMonitorTargetPtrType)(v)
}

func (*syntheticMonitorTargetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SyntheticMonitorTarget)(nil)).Elem()
}

func (i *syntheticMonitorTargetPtrType) ToSyntheticMonitorTargetPtrOutput() SyntheticMonitorTargetPtrOutput {
	return i.ToSyntheticMonitorTargetPtrOutputWithContext(context.Background())
}

func (i *syntheticMonitorTargetPtrType) ToSyntheticMonitorTargetPtrOutputWithContext(ctx context.Context) SyntheticMonitorTargetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SyntheticMonitorTargetPtrOutput)
}

// Describes a Synthetic Monitor to be invoked by Uptime.
type SyntheticMonitorTargetOutput struct{ *pulumi.OutputState }

func (SyntheticMonitorTargetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SyntheticMonitorTarget)(nil)).Elem()
}

func (o SyntheticMonitorTargetOutput) ToSyntheticMonitorTargetOutput() SyntheticMonitorTargetOutput {
	return o
}

func (o SyntheticMonitorTargetOutput) ToSyntheticMonitorTargetOutputWithContext(ctx context.Context) SyntheticMonitorTargetOutput {
	return o
}

func (o SyntheticMonitorTargetOutput) ToSyntheticMonitorTargetPtrOutput() SyntheticMonitorTargetPtrOutput {
	return o.ToSyntheticMonitorTargetPtrOutputWithContext(context.Background())
}

func (o SyntheticMonitorTargetOutput) ToSyntheticMonitorTargetPtrOutputWithContext(ctx context.Context) SyntheticMonitorTargetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SyntheticMonitorTarget) *SyntheticMonitorTarget {
		return &v
	}).(SyntheticMonitorTargetPtrOutput)
}

// Target a Synthetic Monitor GCFv2 instance.
func (o SyntheticMonitorTargetOutput) CloudFunctionV2() CloudFunctionV2TargetPtrOutput {
	return o.ApplyT(func(v SyntheticMonitorTarget) *CloudFunctionV2Target { return v.CloudFunctionV2 }).(CloudFunctionV2TargetPtrOutput)
}

type SyntheticMonitorTargetPtrOutput struct{ *pulumi.OutputState }

func (SyntheticMonitorTargetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SyntheticMonitorTarget)(nil)).Elem()
}

func (o SyntheticMonitorTargetPtrOutput) ToSyntheticMonitorTargetPtrOutput() SyntheticMonitorTargetPtrOutput {
	return o
}

func (o SyntheticMonitorTargetPtrOutput) ToSyntheticMonitorTargetPtrOutputWithContext(ctx context.Context) SyntheticMonitorTargetPtrOutput {
	return o
}

func (o SyntheticMonitorTargetPtrOutput) Elem() SyntheticMonitorTargetOutput {
	return o.ApplyT(func(v *SyntheticMonitorTarget) SyntheticMonitorTarget {
		if v != nil {
			return *v
		}
		var ret SyntheticMonitorTarget
		return ret
	}).(SyntheticMonitorTargetOutput)
}

// Target a Synthetic Monitor GCFv2 instance.
func (o SyntheticMonitorTargetPtrOutput) CloudFunctionV2() CloudFunctionV2TargetPtrOutput {
	return o.ApplyT(func(v *SyntheticMonitorTarget) *CloudFunctionV2Target {
		if v == nil {
			return nil
		}
		return v.CloudFunctionV2
	}).(CloudFunctionV2TargetPtrOutput)
}

// Describes a Synthetic Monitor to be invoked by Uptime.
type SyntheticMonitorTargetResponse struct {
	// Target a Synthetic Monitor GCFv2 instance.
	CloudFunctionV2 CloudFunctionV2TargetResponse `pulumi:"cloudFunctionV2"`
}

// Describes a Synthetic Monitor to be invoked by Uptime.
type SyntheticMonitorTargetResponseOutput struct{ *pulumi.OutputState }

func (SyntheticMonitorTargetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SyntheticMonitorTargetResponse)(nil)).Elem()
}

func (o SyntheticMonitorTargetResponseOutput) ToSyntheticMonitorTargetResponseOutput() SyntheticMonitorTargetResponseOutput {
	return o
}

func (o SyntheticMonitorTargetResponseOutput) ToSyntheticMonitorTargetResponseOutputWithContext(ctx context.Context) SyntheticMonitorTargetResponseOutput {
	return o
}

// Target a Synthetic Monitor GCFv2 instance.
func (o SyntheticMonitorTargetResponseOutput) CloudFunctionV2() CloudFunctionV2TargetResponseOutput {
	return o.ApplyT(func(v SyntheticMonitorTargetResponse) CloudFunctionV2TargetResponse { return v.CloudFunctionV2 }).(CloudFunctionV2TargetResponseOutput)
}

// Information required for a TCP Uptime check request.
type TcpCheck struct {
	// Contains information needed to add pings to a TCP check.
	PingConfig *PingConfig `pulumi:"pingConfig"`
	// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
	Port *int `pulumi:"port"`
}

// TcpCheckInput is an input type that accepts TcpCheckArgs and TcpCheckOutput values.
// You can construct a concrete instance of `TcpCheckInput` via:
//
//	TcpCheckArgs{...}
type TcpCheckInput interface {
	pulumi.Input

	ToTcpCheckOutput() TcpCheckOutput
	ToTcpCheckOutputWithContext(context.Context) TcpCheckOutput
}

// Information required for a TCP Uptime check request.
type TcpCheckArgs struct {
	// Contains information needed to add pings to a TCP check.
	PingConfig PingConfigPtrInput `pulumi:"pingConfig"`
	// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (TcpCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TcpCheck)(nil)).Elem()
}

func (i TcpCheckArgs) ToTcpCheckOutput() TcpCheckOutput {
	return i.ToTcpCheckOutputWithContext(context.Background())
}

func (i TcpCheckArgs) ToTcpCheckOutputWithContext(ctx context.Context) TcpCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TcpCheckOutput)
}

func (i TcpCheckArgs) ToTcpCheckPtrOutput() TcpCheckPtrOutput {
	return i.ToTcpCheckPtrOutputWithContext(context.Background())
}

func (i TcpCheckArgs) ToTcpCheckPtrOutputWithContext(ctx context.Context) TcpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TcpCheckOutput).ToTcpCheckPtrOutputWithContext(ctx)
}

// TcpCheckPtrInput is an input type that accepts TcpCheckArgs, TcpCheckPtr and TcpCheckPtrOutput values.
// You can construct a concrete instance of `TcpCheckPtrInput` via:
//
//	        TcpCheckArgs{...}
//
//	or:
//
//	        nil
type TcpCheckPtrInput interface {
	pulumi.Input

	ToTcpCheckPtrOutput() TcpCheckPtrOutput
	ToTcpCheckPtrOutputWithContext(context.Context) TcpCheckPtrOutput
}

type tcpCheckPtrType TcpCheckArgs

func TcpCheckPtr(v *TcpCheckArgs) TcpCheckPtrInput {
	return (*tcpCheckPtrType)(v)
}

func (*tcpCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TcpCheck)(nil)).Elem()
}

func (i *tcpCheckPtrType) ToTcpCheckPtrOutput() TcpCheckPtrOutput {
	return i.ToTcpCheckPtrOutputWithContext(context.Background())
}

func (i *tcpCheckPtrType) ToTcpCheckPtrOutputWithContext(ctx context.Context) TcpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TcpCheckPtrOutput)
}

// Information required for a TCP Uptime check request.
type TcpCheckOutput struct{ *pulumi.OutputState }

func (TcpCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TcpCheck)(nil)).Elem()
}

func (o TcpCheckOutput) ToTcpCheckOutput() TcpCheckOutput {
	return o
}

func (o TcpCheckOutput) ToTcpCheckOutputWithContext(ctx context.Context) TcpCheckOutput {
	return o
}

func (o TcpCheckOutput) ToTcpCheckPtrOutput() TcpCheckPtrOutput {
	return o.ToTcpCheckPtrOutputWithContext(context.Background())
}

func (o TcpCheckOutput) ToTcpCheckPtrOutputWithContext(ctx context.Context) TcpCheckPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TcpCheck) *TcpCheck {
		return &v
	}).(TcpCheckPtrOutput)
}

// Contains information needed to add pings to a TCP check.
func (o TcpCheckOutput) PingConfig() PingConfigPtrOutput {
	return o.ApplyT(func(v TcpCheck) *PingConfig { return v.PingConfig }).(PingConfigPtrOutput)
}

// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
func (o TcpCheckOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TcpCheck) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type TcpCheckPtrOutput struct{ *pulumi.OutputState }

func (TcpCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TcpCheck)(nil)).Elem()
}

func (o TcpCheckPtrOutput) ToTcpCheckPtrOutput() TcpCheckPtrOutput {
	return o
}

func (o TcpCheckPtrOutput) ToTcpCheckPtrOutputWithContext(ctx context.Context) TcpCheckPtrOutput {
	return o
}

func (o TcpCheckPtrOutput) Elem() TcpCheckOutput {
	return o.ApplyT(func(v *TcpCheck) TcpCheck {
		if v != nil {
			return *v
		}
		var ret TcpCheck
		return ret
	}).(TcpCheckOutput)
}

// Contains information needed to add pings to a TCP check.
func (o TcpCheckPtrOutput) PingConfig() PingConfigPtrOutput {
	return o.ApplyT(func(v *TcpCheck) *PingConfig {
		if v == nil {
			return nil
		}
		return v.PingConfig
	}).(PingConfigPtrOutput)
}

// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
func (o TcpCheckPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TcpCheck) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// Information required for a TCP Uptime check request.
type TcpCheckResponse struct {
	// Contains information needed to add pings to a TCP check.
	PingConfig PingConfigResponse `pulumi:"pingConfig"`
	// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
	Port int `pulumi:"port"`
}

// Information required for a TCP Uptime check request.
type TcpCheckResponseOutput struct{ *pulumi.OutputState }

func (TcpCheckResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TcpCheckResponse)(nil)).Elem()
}

func (o TcpCheckResponseOutput) ToTcpCheckResponseOutput() TcpCheckResponseOutput {
	return o
}

func (o TcpCheckResponseOutput) ToTcpCheckResponseOutputWithContext(ctx context.Context) TcpCheckResponseOutput {
	return o
}

// Contains information needed to add pings to a TCP check.
func (o TcpCheckResponseOutput) PingConfig() PingConfigResponseOutput {
	return o.ApplyT(func(v TcpCheckResponse) PingConfigResponse { return v.PingConfig }).(PingConfigResponseOutput)
}

// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
func (o TcpCheckResponseOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v TcpCheckResponse) int { return v.Port }).(pulumi.IntOutput)
}

// Configuration for how to query telemetry on a Service.
type Telemetry struct {
	// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
	ResourceName *string `pulumi:"resourceName"`
}

// TelemetryInput is an input type that accepts TelemetryArgs and TelemetryOutput values.
// You can construct a concrete instance of `TelemetryInput` via:
//
//	TelemetryArgs{...}
type TelemetryInput interface {
	pulumi.Input

	ToTelemetryOutput() TelemetryOutput
	ToTelemetryOutputWithContext(context.Context) TelemetryOutput
}

// Configuration for how to query telemetry on a Service.
type TelemetryArgs struct {
	// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
	ResourceName pulumi.StringPtrInput `pulumi:"resourceName"`
}

func (TelemetryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Telemetry)(nil)).Elem()
}

func (i TelemetryArgs) ToTelemetryOutput() TelemetryOutput {
	return i.ToTelemetryOutputWithContext(context.Background())
}

func (i TelemetryArgs) ToTelemetryOutputWithContext(ctx context.Context) TelemetryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TelemetryOutput)
}

func (i TelemetryArgs) ToTelemetryPtrOutput() TelemetryPtrOutput {
	return i.ToTelemetryPtrOutputWithContext(context.Background())
}

func (i TelemetryArgs) ToTelemetryPtrOutputWithContext(ctx context.Context) TelemetryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TelemetryOutput).ToTelemetryPtrOutputWithContext(ctx)
}

// TelemetryPtrInput is an input type that accepts TelemetryArgs, TelemetryPtr and TelemetryPtrOutput values.
// You can construct a concrete instance of `TelemetryPtrInput` via:
//
//	        TelemetryArgs{...}
//
//	or:
//
//	        nil
type TelemetryPtrInput interface {
	pulumi.Input

	ToTelemetryPtrOutput() TelemetryPtrOutput
	ToTelemetryPtrOutputWithContext(context.Context) TelemetryPtrOutput
}

type telemetryPtrType TelemetryArgs

func TelemetryPtr(v *TelemetryArgs) TelemetryPtrInput {
	return (*telemetryPtrType)(v)
}

func (*telemetryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Telemetry)(nil)).Elem()
}

func (i *telemetryPtrType) ToTelemetryPtrOutput() TelemetryPtrOutput {
	return i.ToTelemetryPtrOutputWithContext(context.Background())
}

func (i *telemetryPtrType) ToTelemetryPtrOutputWithContext(ctx context.Context) TelemetryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TelemetryPtrOutput)
}

// Configuration for how to query telemetry on a Service.
type TelemetryOutput struct{ *pulumi.OutputState }

func (TelemetryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Telemetry)(nil)).Elem()
}

func (o TelemetryOutput) ToTelemetryOutput() TelemetryOutput {
	return o
}

func (o TelemetryOutput) ToTelemetryOutputWithContext(ctx context.Context) TelemetryOutput {
	return o
}

func (o TelemetryOutput) ToTelemetryPtrOutput() TelemetryPtrOutput {
	return o.ToTelemetryPtrOutputWithContext(context.Background())
}

func (o TelemetryOutput) ToTelemetryPtrOutputWithContext(ctx context.Context) TelemetryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Telemetry) *Telemetry {
		return &v
	}).(TelemetryPtrOutput)
}

// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
func (o TelemetryOutput) ResourceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Telemetry) *string { return v.ResourceName }).(pulumi.StringPtrOutput)
}

type TelemetryPtrOutput struct{ *pulumi.OutputState }

func (TelemetryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Telemetry)(nil)).Elem()
}

func (o TelemetryPtrOutput) ToTelemetryPtrOutput() TelemetryPtrOutput {
	return o
}

func (o TelemetryPtrOutput) ToTelemetryPtrOutputWithContext(ctx context.Context) TelemetryPtrOutput {
	return o
}

func (o TelemetryPtrOutput) Elem() TelemetryOutput {
	return o.ApplyT(func(v *Telemetry) Telemetry {
		if v != nil {
			return *v
		}
		var ret Telemetry
		return ret
	}).(TelemetryOutput)
}

// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
func (o TelemetryPtrOutput) ResourceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Telemetry) *string {
		if v == nil {
			return nil
		}
		return v.ResourceName
	}).(pulumi.StringPtrOutput)
}

// Configuration for how to query telemetry on a Service.
type TelemetryResponse struct {
	// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
	ResourceName string `pulumi:"resourceName"`
}

// Configuration for how to query telemetry on a Service.
type TelemetryResponseOutput struct{ *pulumi.OutputState }

func (TelemetryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TelemetryResponse)(nil)).Elem()
}

func (o TelemetryResponseOutput) ToTelemetryResponseOutput() TelemetryResponseOutput {
	return o
}

func (o TelemetryResponseOutput) ToTelemetryResponseOutputWithContext(ctx context.Context) TelemetryResponseOutput {
	return o
}

// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
func (o TelemetryResponseOutput) ResourceName() pulumi.StringOutput {
	return o.ApplyT(func(v TelemetryResponse) string { return v.ResourceName }).(pulumi.StringOutput)
}

// Describes a time interval: Reads: A half-open time interval. It includes the end time but excludes the start time: (startTime, endTime]. The start time must be specified, must be earlier than the end time, and should be no older than the data retention period for the metric. Writes: A closed time interval. It extends from the start time to the end time, and includes both: [startTime, endTime]. Valid time intervals depend on the MetricKind (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors#MetricKind) of the metric value. The end time must not be earlier than the start time, and the end time must not be more than 25 hours in the past or more than five minutes in the future. For GAUGE metrics, the startTime value is technically optional; if no value is specified, the start time defaults to the value of the end time, and the interval represents a single point in time. If both start and end times are specified, they must be identical. Such an interval is valid only for GAUGE metrics, which are point-in-time measurements. The end time of a new interval must be at least a millisecond after the end time of the previous interval. For DELTA metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For DELTA metrics, the start time of the next interval must be at least a millisecond after the end time of the previous interval. For CUMULATIVE metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points. The new start time must be at least a millisecond after the end time of the previous interval. The start time of a new interval must be at least a millisecond after the end time of the previous interval because intervals are closed. If the start time of a new interval is the same as the end time of the previous interval, then data written at the new start time could overwrite data written at the previous end time.
type TimeInterval struct {
	// The end of the time interval.
	EndTime string `pulumi:"endTime"`
	// Optional. The beginning of the time interval. The default value for the start time is the end time. The start time must not be later than the end time.
	StartTime *string `pulumi:"startTime"`
}

// TimeIntervalInput is an input type that accepts TimeIntervalArgs and TimeIntervalOutput values.
// You can construct a concrete instance of `TimeIntervalInput` via:
//
//	TimeIntervalArgs{...}
type TimeIntervalInput interface {
	pulumi.Input

	ToTimeIntervalOutput() TimeIntervalOutput
	ToTimeIntervalOutputWithContext(context.Context) TimeIntervalOutput
}

// Describes a time interval: Reads: A half-open time interval. It includes the end time but excludes the start time: (startTime, endTime]. The start time must be specified, must be earlier than the end time, and should be no older than the data retention period for the metric. Writes: A closed time interval. It extends from the start time to the end time, and includes both: [startTime, endTime]. Valid time intervals depend on the MetricKind (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors#MetricKind) of the metric value. The end time must not be earlier than the start time, and the end time must not be more than 25 hours in the past or more than five minutes in the future. For GAUGE metrics, the startTime value is technically optional; if no value is specified, the start time defaults to the value of the end time, and the interval represents a single point in time. If both start and end times are specified, they must be identical. Such an interval is valid only for GAUGE metrics, which are point-in-time measurements. The end time of a new interval must be at least a millisecond after the end time of the previous interval. For DELTA metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For DELTA metrics, the start time of the next interval must be at least a millisecond after the end time of the previous interval. For CUMULATIVE metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points. The new start time must be at least a millisecond after the end time of the previous interval. The start time of a new interval must be at least a millisecond after the end time of the previous interval because intervals are closed. If the start time of a new interval is the same as the end time of the previous interval, then data written at the new start time could overwrite data written at the previous end time.
type TimeIntervalArgs struct {
	// The end of the time interval.
	EndTime pulumi.StringInput `pulumi:"endTime"`
	// Optional. The beginning of the time interval. The default value for the start time is the end time. The start time must not be later than the end time.
	StartTime pulumi.StringPtrInput `pulumi:"startTime"`
}

func (TimeIntervalArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeInterval)(nil)).Elem()
}

func (i TimeIntervalArgs) ToTimeIntervalOutput() TimeIntervalOutput {
	return i.ToTimeIntervalOutputWithContext(context.Background())
}

func (i TimeIntervalArgs) ToTimeIntervalOutputWithContext(ctx context.Context) TimeIntervalOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeIntervalOutput)
}

// Describes a time interval: Reads: A half-open time interval. It includes the end time but excludes the start time: (startTime, endTime]. The start time must be specified, must be earlier than the end time, and should be no older than the data retention period for the metric. Writes: A closed time interval. It extends from the start time to the end time, and includes both: [startTime, endTime]. Valid time intervals depend on the MetricKind (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors#MetricKind) of the metric value. The end time must not be earlier than the start time, and the end time must not be more than 25 hours in the past or more than five minutes in the future. For GAUGE metrics, the startTime value is technically optional; if no value is specified, the start time defaults to the value of the end time, and the interval represents a single point in time. If both start and end times are specified, they must be identical. Such an interval is valid only for GAUGE metrics, which are point-in-time measurements. The end time of a new interval must be at least a millisecond after the end time of the previous interval. For DELTA metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For DELTA metrics, the start time of the next interval must be at least a millisecond after the end time of the previous interval. For CUMULATIVE metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points. The new start time must be at least a millisecond after the end time of the previous interval. The start time of a new interval must be at least a millisecond after the end time of the previous interval because intervals are closed. If the start time of a new interval is the same as the end time of the previous interval, then data written at the new start time could overwrite data written at the previous end time.
type TimeIntervalOutput struct{ *pulumi.OutputState }

func (TimeIntervalOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeInterval)(nil)).Elem()
}

func (o TimeIntervalOutput) ToTimeIntervalOutput() TimeIntervalOutput {
	return o
}

func (o TimeIntervalOutput) ToTimeIntervalOutputWithContext(ctx context.Context) TimeIntervalOutput {
	return o
}

// The end of the time interval.
func (o TimeIntervalOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v TimeInterval) string { return v.EndTime }).(pulumi.StringOutput)
}

// Optional. The beginning of the time interval. The default value for the start time is the end time. The start time must not be later than the end time.
func (o TimeIntervalOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeInterval) *string { return v.StartTime }).(pulumi.StringPtrOutput)
}

// Describes a time interval: Reads: A half-open time interval. It includes the end time but excludes the start time: (startTime, endTime]. The start time must be specified, must be earlier than the end time, and should be no older than the data retention period for the metric. Writes: A closed time interval. It extends from the start time to the end time, and includes both: [startTime, endTime]. Valid time intervals depend on the MetricKind (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors#MetricKind) of the metric value. The end time must not be earlier than the start time, and the end time must not be more than 25 hours in the past or more than five minutes in the future. For GAUGE metrics, the startTime value is technically optional; if no value is specified, the start time defaults to the value of the end time, and the interval represents a single point in time. If both start and end times are specified, they must be identical. Such an interval is valid only for GAUGE metrics, which are point-in-time measurements. The end time of a new interval must be at least a millisecond after the end time of the previous interval. For DELTA metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For DELTA metrics, the start time of the next interval must be at least a millisecond after the end time of the previous interval. For CUMULATIVE metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points. The new start time must be at least a millisecond after the end time of the previous interval. The start time of a new interval must be at least a millisecond after the end time of the previous interval because intervals are closed. If the start time of a new interval is the same as the end time of the previous interval, then data written at the new start time could overwrite data written at the previous end time.
type TimeIntervalResponse struct {
	// The end of the time interval.
	EndTime string `pulumi:"endTime"`
	// Optional. The beginning of the time interval. The default value for the start time is the end time. The start time must not be later than the end time.
	StartTime string `pulumi:"startTime"`
}

// Describes a time interval: Reads: A half-open time interval. It includes the end time but excludes the start time: (startTime, endTime]. The start time must be specified, must be earlier than the end time, and should be no older than the data retention period for the metric. Writes: A closed time interval. It extends from the start time to the end time, and includes both: [startTime, endTime]. Valid time intervals depend on the MetricKind (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors#MetricKind) of the metric value. The end time must not be earlier than the start time, and the end time must not be more than 25 hours in the past or more than five minutes in the future. For GAUGE metrics, the startTime value is technically optional; if no value is specified, the start time defaults to the value of the end time, and the interval represents a single point in time. If both start and end times are specified, they must be identical. Such an interval is valid only for GAUGE metrics, which are point-in-time measurements. The end time of a new interval must be at least a millisecond after the end time of the previous interval. For DELTA metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For DELTA metrics, the start time of the next interval must be at least a millisecond after the end time of the previous interval. For CUMULATIVE metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points. The new start time must be at least a millisecond after the end time of the previous interval. The start time of a new interval must be at least a millisecond after the end time of the previous interval because intervals are closed. If the start time of a new interval is the same as the end time of the previous interval, then data written at the new start time could overwrite data written at the previous end time.
type TimeIntervalResponseOutput struct{ *pulumi.OutputState }

func (TimeIntervalResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeIntervalResponse)(nil)).Elem()
}

func (o TimeIntervalResponseOutput) ToTimeIntervalResponseOutput() TimeIntervalResponseOutput {
	return o
}

func (o TimeIntervalResponseOutput) ToTimeIntervalResponseOutputWithContext(ctx context.Context) TimeIntervalResponseOutput {
	return o
}

// The end of the time interval.
func (o TimeIntervalResponseOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v TimeIntervalResponse) string { return v.EndTime }).(pulumi.StringOutput)
}

// Optional. The beginning of the time interval. The default value for the start time is the end time. The start time must not be later than the end time.
func (o TimeIntervalResponseOutput) StartTime() pulumi.StringOutput {
	return o.ApplyT(func(v TimeIntervalResponse) string { return v.StartTime }).(pulumi.StringOutput)
}

// A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.
type TimeSeriesRatio struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	BadServiceFilter *string `pulumi:"badServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	GoodServiceFilter *string `pulumi:"goodServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	TotalServiceFilter *string `pulumi:"totalServiceFilter"`
}

// TimeSeriesRatioInput is an input type that accepts TimeSeriesRatioArgs and TimeSeriesRatioOutput values.
// You can construct a concrete instance of `TimeSeriesRatioInput` via:
//
//	TimeSeriesRatioArgs{...}
type TimeSeriesRatioInput interface {
	pulumi.Input

	ToTimeSeriesRatioOutput() TimeSeriesRatioOutput
	ToTimeSeriesRatioOutputWithContext(context.Context) TimeSeriesRatioOutput
}

// A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.
type TimeSeriesRatioArgs struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	BadServiceFilter pulumi.StringPtrInput `pulumi:"badServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	GoodServiceFilter pulumi.StringPtrInput `pulumi:"goodServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	TotalServiceFilter pulumi.StringPtrInput `pulumi:"totalServiceFilter"`
}

func (TimeSeriesRatioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesRatio)(nil)).Elem()
}

func (i TimeSeriesRatioArgs) ToTimeSeriesRatioOutput() TimeSeriesRatioOutput {
	return i.ToTimeSeriesRatioOutputWithContext(context.Background())
}

func (i TimeSeriesRatioArgs) ToTimeSeriesRatioOutputWithContext(ctx context.Context) TimeSeriesRatioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesRatioOutput)
}

func (i TimeSeriesRatioArgs) ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput {
	return i.ToTimeSeriesRatioPtrOutputWithContext(context.Background())
}

func (i TimeSeriesRatioArgs) ToTimeSeriesRatioPtrOutputWithContext(ctx context.Context) TimeSeriesRatioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesRatioOutput).ToTimeSeriesRatioPtrOutputWithContext(ctx)
}

// TimeSeriesRatioPtrInput is an input type that accepts TimeSeriesRatioArgs, TimeSeriesRatioPtr and TimeSeriesRatioPtrOutput values.
// You can construct a concrete instance of `TimeSeriesRatioPtrInput` via:
//
//	        TimeSeriesRatioArgs{...}
//
//	or:
//
//	        nil
type TimeSeriesRatioPtrInput interface {
	pulumi.Input

	ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput
	ToTimeSeriesRatioPtrOutputWithContext(context.Context) TimeSeriesRatioPtrOutput
}

type timeSeriesRatioPtrType TimeSeriesRatioArgs

func TimeSeriesRatioPtr(v *TimeSeriesRatioArgs) TimeSeriesRatioPtrInput {
	return (*timeSeriesRatioPtrType)(v)
}

func (*timeSeriesRatioPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesRatio)(nil)).Elem()
}

func (i *timeSeriesRatioPtrType) ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput {
	return i.ToTimeSeriesRatioPtrOutputWithContext(context.Background())
}

func (i *timeSeriesRatioPtrType) ToTimeSeriesRatioPtrOutputWithContext(ctx context.Context) TimeSeriesRatioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesRatioPtrOutput)
}

// A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.
type TimeSeriesRatioOutput struct{ *pulumi.OutputState }

func (TimeSeriesRatioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesRatio)(nil)).Elem()
}

func (o TimeSeriesRatioOutput) ToTimeSeriesRatioOutput() TimeSeriesRatioOutput {
	return o
}

func (o TimeSeriesRatioOutput) ToTimeSeriesRatioOutputWithContext(ctx context.Context) TimeSeriesRatioOutput {
	return o
}

func (o TimeSeriesRatioOutput) ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput {
	return o.ToTimeSeriesRatioPtrOutputWithContext(context.Background())
}

func (o TimeSeriesRatioOutput) ToTimeSeriesRatioPtrOutputWithContext(ctx context.Context) TimeSeriesRatioPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TimeSeriesRatio) *TimeSeriesRatio {
		return &v
	}).(TimeSeriesRatioPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioOutput) BadServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesRatio) *string { return v.BadServiceFilter }).(pulumi.StringPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioOutput) GoodServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesRatio) *string { return v.GoodServiceFilter }).(pulumi.StringPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioOutput) TotalServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesRatio) *string { return v.TotalServiceFilter }).(pulumi.StringPtrOutput)
}

type TimeSeriesRatioPtrOutput struct{ *pulumi.OutputState }

func (TimeSeriesRatioPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesRatio)(nil)).Elem()
}

func (o TimeSeriesRatioPtrOutput) ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput {
	return o
}

func (o TimeSeriesRatioPtrOutput) ToTimeSeriesRatioPtrOutputWithContext(ctx context.Context) TimeSeriesRatioPtrOutput {
	return o
}

func (o TimeSeriesRatioPtrOutput) Elem() TimeSeriesRatioOutput {
	return o.ApplyT(func(v *TimeSeriesRatio) TimeSeriesRatio {
		if v != nil {
			return *v
		}
		var ret TimeSeriesRatio
		return ret
	}).(TimeSeriesRatioOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioPtrOutput) BadServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesRatio) *string {
		if v == nil {
			return nil
		}
		return v.BadServiceFilter
	}).(pulumi.StringPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioPtrOutput) GoodServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesRatio) *string {
		if v == nil {
			return nil
		}
		return v.GoodServiceFilter
	}).(pulumi.StringPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioPtrOutput) TotalServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesRatio) *string {
		if v == nil {
			return nil
		}
		return v.TotalServiceFilter
	}).(pulumi.StringPtrOutput)
}

// A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.
type TimeSeriesRatioResponse struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	BadServiceFilter string `pulumi:"badServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	GoodServiceFilter string `pulumi:"goodServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	TotalServiceFilter string `pulumi:"totalServiceFilter"`
}

// A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.
type TimeSeriesRatioResponseOutput struct{ *pulumi.OutputState }

func (TimeSeriesRatioResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesRatioResponse)(nil)).Elem()
}

func (o TimeSeriesRatioResponseOutput) ToTimeSeriesRatioResponseOutput() TimeSeriesRatioResponseOutput {
	return o
}

func (o TimeSeriesRatioResponseOutput) ToTimeSeriesRatioResponseOutputWithContext(ctx context.Context) TimeSeriesRatioResponseOutput {
	return o
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioResponseOutput) BadServiceFilter() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesRatioResponse) string { return v.BadServiceFilter }).(pulumi.StringOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioResponseOutput) GoodServiceFilter() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesRatioResponse) string { return v.GoodServiceFilter }).(pulumi.StringOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioResponseOutput) TotalServiceFilter() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesRatioResponse) string { return v.TotalServiceFilter }).(pulumi.StringOutput)
}

// Specifies how many time series must fail a predicate to trigger a condition. If not specified, then a {count: 1} trigger is used.
type Trigger struct {
	// The absolute number of time series that must fail the predicate for the condition to be triggered.
	Count *int `pulumi:"count"`
	// The percentage of time series that must fail the predicate for the condition to be triggered.
	Percent *float64 `pulumi:"percent"`
}

// TriggerInput is an input type that accepts TriggerArgs and TriggerOutput values.
// You can construct a concrete instance of `TriggerInput` via:
//
//	TriggerArgs{...}
type TriggerInput interface {
	pulumi.Input

	ToTriggerOutput() TriggerOutput
	ToTriggerOutputWithContext(context.Context) TriggerOutput
}

// Specifies how many time series must fail a predicate to trigger a condition. If not specified, then a {count: 1} trigger is used.
type TriggerArgs struct {
	// The absolute number of time series that must fail the predicate for the condition to be triggered.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// The percentage of time series that must fail the predicate for the condition to be triggered.
	Percent pulumi.Float64PtrInput `pulumi:"percent"`
}

func (TriggerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Trigger)(nil)).Elem()
}

func (i TriggerArgs) ToTriggerOutput() TriggerOutput {
	return i.ToTriggerOutputWithContext(context.Background())
}

func (i TriggerArgs) ToTriggerOutputWithContext(ctx context.Context) TriggerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TriggerOutput)
}

func (i TriggerArgs) ToTriggerPtrOutput() TriggerPtrOutput {
	return i.ToTriggerPtrOutputWithContext(context.Background())
}

func (i TriggerArgs) ToTriggerPtrOutputWithContext(ctx context.Context) TriggerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TriggerOutput).ToTriggerPtrOutputWithContext(ctx)
}

// TriggerPtrInput is an input type that accepts TriggerArgs, TriggerPtr and TriggerPtrOutput values.
// You can construct a concrete instance of `TriggerPtrInput` via:
//
//	        TriggerArgs{...}
//
//	or:
//
//	        nil
type TriggerPtrInput interface {
	pulumi.Input

	ToTriggerPtrOutput() TriggerPtrOutput
	ToTriggerPtrOutputWithContext(context.Context) TriggerPtrOutput
}

type triggerPtrType TriggerArgs

func TriggerPtr(v *TriggerArgs) TriggerPtrInput {
	return (*triggerPtrType)(v)
}

func (*triggerPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Trigger)(nil)).Elem()
}

func (i *triggerPtrType) ToTriggerPtrOutput() TriggerPtrOutput {
	return i.ToTriggerPtrOutputWithContext(context.Background())
}

func (i *triggerPtrType) ToTriggerPtrOutputWithContext(ctx context.Context) TriggerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TriggerPtrOutput)
}

// Specifies how many time series must fail a predicate to trigger a condition. If not specified, then a {count: 1} trigger is used.
type TriggerOutput struct{ *pulumi.OutputState }

func (TriggerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Trigger)(nil)).Elem()
}

func (o TriggerOutput) ToTriggerOutput() TriggerOutput {
	return o
}

func (o TriggerOutput) ToTriggerOutputWithContext(ctx context.Context) TriggerOutput {
	return o
}

func (o TriggerOutput) ToTriggerPtrOutput() TriggerPtrOutput {
	return o.ToTriggerPtrOutputWithContext(context.Background())
}

func (o TriggerOutput) ToTriggerPtrOutputWithContext(ctx context.Context) TriggerPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Trigger) *Trigger {
		return &v
	}).(TriggerPtrOutput)
}

// The absolute number of time series that must fail the predicate for the condition to be triggered.
func (o TriggerOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Trigger) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// The percentage of time series that must fail the predicate for the condition to be triggered.
func (o TriggerOutput) Percent() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Trigger) *float64 { return v.Percent }).(pulumi.Float64PtrOutput)
}

type TriggerPtrOutput struct{ *pulumi.OutputState }

func (TriggerPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Trigger)(nil)).Elem()
}

func (o TriggerPtrOutput) ToTriggerPtrOutput() TriggerPtrOutput {
	return o
}

func (o TriggerPtrOutput) ToTriggerPtrOutputWithContext(ctx context.Context) TriggerPtrOutput {
	return o
}

func (o TriggerPtrOutput) Elem() TriggerOutput {
	return o.ApplyT(func(v *Trigger) Trigger {
		if v != nil {
			return *v
		}
		var ret Trigger
		return ret
	}).(TriggerOutput)
}

// The absolute number of time series that must fail the predicate for the condition to be triggered.
func (o TriggerPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Trigger) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

// The percentage of time series that must fail the predicate for the condition to be triggered.
func (o TriggerPtrOutput) Percent() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Trigger) *float64 {
		if v == nil {
			return nil
		}
		return v.Percent
	}).(pulumi.Float64PtrOutput)
}

// Specifies how many time series must fail a predicate to trigger a condition. If not specified, then a {count: 1} trigger is used.
type TriggerResponse struct {
	// The absolute number of time series that must fail the predicate for the condition to be triggered.
	Count int `pulumi:"count"`
	// The percentage of time series that must fail the predicate for the condition to be triggered.
	Percent float64 `pulumi:"percent"`
}

// Specifies how many time series must fail a predicate to trigger a condition. If not specified, then a {count: 1} trigger is used.
type TriggerResponseOutput struct{ *pulumi.OutputState }

func (TriggerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TriggerResponse)(nil)).Elem()
}

func (o TriggerResponseOutput) ToTriggerResponseOutput() TriggerResponseOutput {
	return o
}

func (o TriggerResponseOutput) ToTriggerResponseOutputWithContext(ctx context.Context) TriggerResponseOutput {
	return o
}

// The absolute number of time series that must fail the predicate for the condition to be triggered.
func (o TriggerResponseOutput) Count() pulumi.IntOutput {
	return o.ApplyT(func(v TriggerResponse) int { return v.Count }).(pulumi.IntOutput)
}

// The percentage of time series that must fail the predicate for the condition to be triggered.
func (o TriggerResponseOutput) Percent() pulumi.Float64Output {
	return o.ApplyT(func(v TriggerResponse) float64 { return v.Percent }).(pulumi.Float64Output)
}

// A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.
type WindowsBasedSli struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
	GoodBadMetricFilter *string `pulumi:"goodBadMetricFilter"`
	// A window is good if its performance is high enough.
	GoodTotalRatioThreshold *PerformanceThreshold `pulumi:"goodTotalRatioThreshold"`
	// A window is good if the metric's value is in a good range, averaged across returned streams.
	MetricMeanInRange *MetricRange `pulumi:"metricMeanInRange"`
	// A window is good if the metric's value is in a good range, summed across returned streams.
	MetricSumInRange *MetricRange `pulumi:"metricSumInRange"`
	// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
	WindowPeriod *string `pulumi:"windowPeriod"`
}

// WindowsBasedSliInput is an input type that accepts WindowsBasedSliArgs and WindowsBasedSliOutput values.
// You can construct a concrete instance of `WindowsBasedSliInput` via:
//
//	WindowsBasedSliArgs{...}
type WindowsBasedSliInput interface {
	pulumi.Input

	ToWindowsBasedSliOutput() WindowsBasedSliOutput
	ToWindowsBasedSliOutputWithContext(context.Context) WindowsBasedSliOutput
}

// A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.
type WindowsBasedSliArgs struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
	GoodBadMetricFilter pulumi.StringPtrInput `pulumi:"goodBadMetricFilter"`
	// A window is good if its performance is high enough.
	GoodTotalRatioThreshold PerformanceThresholdPtrInput `pulumi:"goodTotalRatioThreshold"`
	// A window is good if the metric's value is in a good range, averaged across returned streams.
	MetricMeanInRange MetricRangePtrInput `pulumi:"metricMeanInRange"`
	// A window is good if the metric's value is in a good range, summed across returned streams.
	MetricSumInRange MetricRangePtrInput `pulumi:"metricSumInRange"`
	// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
	WindowPeriod pulumi.StringPtrInput `pulumi:"windowPeriod"`
}

func (WindowsBasedSliArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsBasedSli)(nil)).Elem()
}

func (i WindowsBasedSliArgs) ToWindowsBasedSliOutput() WindowsBasedSliOutput {
	return i.ToWindowsBasedSliOutputWithContext(context.Background())
}

func (i WindowsBasedSliArgs) ToWindowsBasedSliOutputWithContext(ctx context.Context) WindowsBasedSliOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsBasedSliOutput)
}

func (i WindowsBasedSliArgs) ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput {
	return i.ToWindowsBasedSliPtrOutputWithContext(context.Background())
}

func (i WindowsBasedSliArgs) ToWindowsBasedSliPtrOutputWithContext(ctx context.Context) WindowsBasedSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsBasedSliOutput).ToWindowsBasedSliPtrOutputWithContext(ctx)
}

// WindowsBasedSliPtrInput is an input type that accepts WindowsBasedSliArgs, WindowsBasedSliPtr and WindowsBasedSliPtrOutput values.
// You can construct a concrete instance of `WindowsBasedSliPtrInput` via:
//
//	        WindowsBasedSliArgs{...}
//
//	or:
//
//	        nil
type WindowsBasedSliPtrInput interface {
	pulumi.Input

	ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput
	ToWindowsBasedSliPtrOutputWithContext(context.Context) WindowsBasedSliPtrOutput
}

type windowsBasedSliPtrType WindowsBasedSliArgs

func WindowsBasedSliPtr(v *WindowsBasedSliArgs) WindowsBasedSliPtrInput {
	return (*windowsBasedSliPtrType)(v)
}

func (*windowsBasedSliPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WindowsBasedSli)(nil)).Elem()
}

func (i *windowsBasedSliPtrType) ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput {
	return i.ToWindowsBasedSliPtrOutputWithContext(context.Background())
}

func (i *windowsBasedSliPtrType) ToWindowsBasedSliPtrOutputWithContext(ctx context.Context) WindowsBasedSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsBasedSliPtrOutput)
}

// A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.
type WindowsBasedSliOutput struct{ *pulumi.OutputState }

func (WindowsBasedSliOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsBasedSli)(nil)).Elem()
}

func (o WindowsBasedSliOutput) ToWindowsBasedSliOutput() WindowsBasedSliOutput {
	return o
}

func (o WindowsBasedSliOutput) ToWindowsBasedSliOutputWithContext(ctx context.Context) WindowsBasedSliOutput {
	return o
}

func (o WindowsBasedSliOutput) ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput {
	return o.ToWindowsBasedSliPtrOutputWithContext(context.Background())
}

func (o WindowsBasedSliOutput) ToWindowsBasedSliPtrOutputWithContext(ctx context.Context) WindowsBasedSliPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WindowsBasedSli) *WindowsBasedSli {
		return &v
	}).(WindowsBasedSliPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
func (o WindowsBasedSliOutput) GoodBadMetricFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *string { return v.GoodBadMetricFilter }).(pulumi.StringPtrOutput)
}

// A window is good if its performance is high enough.
func (o WindowsBasedSliOutput) GoodTotalRatioThreshold() PerformanceThresholdPtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *PerformanceThreshold { return v.GoodTotalRatioThreshold }).(PerformanceThresholdPtrOutput)
}

// A window is good if the metric's value is in a good range, averaged across returned streams.
func (o WindowsBasedSliOutput) MetricMeanInRange() MetricRangePtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *MetricRange { return v.MetricMeanInRange }).(MetricRangePtrOutput)
}

// A window is good if the metric's value is in a good range, summed across returned streams.
func (o WindowsBasedSliOutput) MetricSumInRange() MetricRangePtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *MetricRange { return v.MetricSumInRange }).(MetricRangePtrOutput)
}

// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
func (o WindowsBasedSliOutput) WindowPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *string { return v.WindowPeriod }).(pulumi.StringPtrOutput)
}

type WindowsBasedSliPtrOutput struct{ *pulumi.OutputState }

func (WindowsBasedSliPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WindowsBasedSli)(nil)).Elem()
}

func (o WindowsBasedSliPtrOutput) ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput {
	return o
}

func (o WindowsBasedSliPtrOutput) ToWindowsBasedSliPtrOutputWithContext(ctx context.Context) WindowsBasedSliPtrOutput {
	return o
}

func (o WindowsBasedSliPtrOutput) Elem() WindowsBasedSliOutput {
	return o.ApplyT(func(v *WindowsBasedSli) WindowsBasedSli {
		if v != nil {
			return *v
		}
		var ret WindowsBasedSli
		return ret
	}).(WindowsBasedSliOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
func (o WindowsBasedSliPtrOutput) GoodBadMetricFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *string {
		if v == nil {
			return nil
		}
		return v.GoodBadMetricFilter
	}).(pulumi.StringPtrOutput)
}

// A window is good if its performance is high enough.
func (o WindowsBasedSliPtrOutput) GoodTotalRatioThreshold() PerformanceThresholdPtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *PerformanceThreshold {
		if v == nil {
			return nil
		}
		return v.GoodTotalRatioThreshold
	}).(PerformanceThresholdPtrOutput)
}

// A window is good if the metric's value is in a good range, averaged across returned streams.
func (o WindowsBasedSliPtrOutput) MetricMeanInRange() MetricRangePtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *MetricRange {
		if v == nil {
			return nil
		}
		return v.MetricMeanInRange
	}).(MetricRangePtrOutput)
}

// A window is good if the metric's value is in a good range, summed across returned streams.
func (o WindowsBasedSliPtrOutput) MetricSumInRange() MetricRangePtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *MetricRange {
		if v == nil {
			return nil
		}
		return v.MetricSumInRange
	}).(MetricRangePtrOutput)
}

// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
func (o WindowsBasedSliPtrOutput) WindowPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *string {
		if v == nil {
			return nil
		}
		return v.WindowPeriod
	}).(pulumi.StringPtrOutput)
}

// A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.
type WindowsBasedSliResponse struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
	GoodBadMetricFilter string `pulumi:"goodBadMetricFilter"`
	// A window is good if its performance is high enough.
	GoodTotalRatioThreshold PerformanceThresholdResponse `pulumi:"goodTotalRatioThreshold"`
	// A window is good if the metric's value is in a good range, averaged across returned streams.
	MetricMeanInRange MetricRangeResponse `pulumi:"metricMeanInRange"`
	// A window is good if the metric's value is in a good range, summed across returned streams.
	MetricSumInRange MetricRangeResponse `pulumi:"metricSumInRange"`
	// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
	WindowPeriod string `pulumi:"windowPeriod"`
}

// A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.
type WindowsBasedSliResponseOutput struct{ *pulumi.OutputState }

func (WindowsBasedSliResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsBasedSliResponse)(nil)).Elem()
}

func (o WindowsBasedSliResponseOutput) ToWindowsBasedSliResponseOutput() WindowsBasedSliResponseOutput {
	return o
}

func (o WindowsBasedSliResponseOutput) ToWindowsBasedSliResponseOutputWithContext(ctx context.Context) WindowsBasedSliResponseOutput {
	return o
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
func (o WindowsBasedSliResponseOutput) GoodBadMetricFilter() pulumi.StringOutput {
	return o.ApplyT(func(v WindowsBasedSliResponse) string { return v.GoodBadMetricFilter }).(pulumi.StringOutput)
}

// A window is good if its performance is high enough.
func (o WindowsBasedSliResponseOutput) GoodTotalRatioThreshold() PerformanceThresholdResponseOutput {
	return o.ApplyT(func(v WindowsBasedSliResponse) PerformanceThresholdResponse { return v.GoodTotalRatioThreshold }).(PerformanceThresholdResponseOutput)
}

// A window is good if the metric's value is in a good range, averaged across returned streams.
func (o WindowsBasedSliResponseOutput) MetricMeanInRange() MetricRangeResponseOutput {
	return o.ApplyT(func(v WindowsBasedSliResponse) MetricRangeResponse { return v.MetricMeanInRange }).(MetricRangeResponseOutput)
}

// A window is good if the metric's value is in a good range, summed across returned streams.
func (o WindowsBasedSliResponseOutput) MetricSumInRange() MetricRangeResponseOutput {
	return o.ApplyT(func(v WindowsBasedSliResponse) MetricRangeResponse { return v.MetricSumInRange }).(MetricRangeResponseOutput)
}

// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
func (o WindowsBasedSliResponseOutput) WindowPeriod() pulumi.StringOutput {
	return o.ApplyT(func(v WindowsBasedSliResponse) string { return v.WindowPeriod }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AggregationInput)(nil)).Elem(), AggregationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AggregationArrayInput)(nil)).Elem(), AggregationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlertStrategyInput)(nil)).Elem(), AlertStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlertStrategyPtrInput)(nil)).Elem(), AlertStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AppEngineInput)(nil)).Elem(), AppEngineArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AppEnginePtrInput)(nil)).Elem(), AppEngineArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AvailabilityCriteriaInput)(nil)).Elem(), AvailabilityCriteriaArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AvailabilityCriteriaPtrInput)(nil)).Elem(), AvailabilityCriteriaArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicAuthenticationInput)(nil)).Elem(), BasicAuthenticationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicAuthenticationPtrInput)(nil)).Elem(), BasicAuthenticationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicServiceInput)(nil)).Elem(), BasicServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicServicePtrInput)(nil)).Elem(), BasicServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicSliInput)(nil)).Elem(), BasicSliArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicSliPtrInput)(nil)).Elem(), BasicSliArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CloudEndpointsInput)(nil)).Elem(), CloudEndpointsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CloudEndpointsPtrInput)(nil)).Elem(), CloudEndpointsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CloudFunctionV2TargetInput)(nil)).Elem(), CloudFunctionV2TargetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CloudFunctionV2TargetPtrInput)(nil)).Elem(), CloudFunctionV2TargetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CloudRunInput)(nil)).Elem(), CloudRunArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CloudRunPtrInput)(nil)).Elem(), CloudRunArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterIstioInput)(nil)).Elem(), ClusterIstioArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterIstioPtrInput)(nil)).Elem(), ClusterIstioArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConditionInput)(nil)).Elem(), ConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConditionArrayInput)(nil)).Elem(), ConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContentMatcherInput)(nil)).Elem(), ContentMatcherArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContentMatcherArrayInput)(nil)).Elem(), ContentMatcherArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CriteriaInput)(nil)).Elem(), CriteriaArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CustomInput)(nil)).Elem(), CustomArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CustomPtrInput)(nil)).Elem(), CustomArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DistributionCutInput)(nil)).Elem(), DistributionCutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DistributionCutPtrInput)(nil)).Elem(), DistributionCutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DocumentationInput)(nil)).Elem(), DocumentationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DocumentationPtrInput)(nil)).Elem(), DocumentationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ForecastOptionsInput)(nil)).Elem(), ForecastOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ForecastOptionsPtrInput)(nil)).Elem(), ForecastOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GkeNamespaceInput)(nil)).Elem(), GkeNamespaceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GkeNamespacePtrInput)(nil)).Elem(), GkeNamespaceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GkeServiceInput)(nil)).Elem(), GkeServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GkeServicePtrInput)(nil)).Elem(), GkeServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GkeWorkloadInput)(nil)).Elem(), GkeWorkloadArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GkeWorkloadPtrInput)(nil)).Elem(), GkeWorkloadArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GoogleMonitoringV3RangeInput)(nil)).Elem(), GoogleMonitoringV3RangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GoogleMonitoringV3RangePtrInput)(nil)).Elem(), GoogleMonitoringV3RangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HttpCheckInput)(nil)).Elem(), HttpCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HttpCheckPtrInput)(nil)).Elem(), HttpCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InternalCheckerInput)(nil)).Elem(), InternalCheckerArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InternalCheckerArrayInput)(nil)).Elem(), InternalCheckerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IstioCanonicalServiceInput)(nil)).Elem(), IstioCanonicalServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IstioCanonicalServicePtrInput)(nil)).Elem(), IstioCanonicalServiceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*JsonPathMatcherInput)(nil)).Elem(), JsonPathMatcherArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*JsonPathMatcherPtrInput)(nil)).Elem(), JsonPathMatcherArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LabelDescriptorInput)(nil)).Elem(), LabelDescriptorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LabelDescriptorArrayInput)(nil)).Elem(), LabelDescriptorArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LatencyCriteriaInput)(nil)).Elem(), LatencyCriteriaArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LatencyCriteriaPtrInput)(nil)).Elem(), LatencyCriteriaArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogMatchInput)(nil)).Elem(), LogMatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogMatchPtrInput)(nil)).Elem(), LogMatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MeshIstioInput)(nil)).Elem(), MeshIstioArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MeshIstioPtrInput)(nil)).Elem(), MeshIstioArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetricAbsenceInput)(nil)).Elem(), MetricAbsenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetricAbsencePtrInput)(nil)).Elem(), MetricAbsenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetricDescriptorMetadataInput)(nil)).Elem(), MetricDescriptorMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetricDescriptorMetadataPtrInput)(nil)).Elem(), MetricDescriptorMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetricRangeInput)(nil)).Elem(), MetricRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetricRangePtrInput)(nil)).Elem(), MetricRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetricThresholdInput)(nil)).Elem(), MetricThresholdArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetricThresholdPtrInput)(nil)).Elem(), MetricThresholdArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MonitoredResourceInput)(nil)).Elem(), MonitoredResourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MonitoredResourcePtrInput)(nil)).Elem(), MonitoredResourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MonitoringQueryLanguageConditionInput)(nil)).Elem(), MonitoringQueryLanguageConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MonitoringQueryLanguageConditionPtrInput)(nil)).Elem(), MonitoringQueryLanguageConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MutationRecordInput)(nil)).Elem(), MutationRecordArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MutationRecordPtrInput)(nil)).Elem(), MutationRecordArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MutationRecordArrayInput)(nil)).Elem(), MutationRecordArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NotificationChannelStrategyInput)(nil)).Elem(), NotificationChannelStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NotificationChannelStrategyArrayInput)(nil)).Elem(), NotificationChannelStrategyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NotificationRateLimitInput)(nil)).Elem(), NotificationRateLimitArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NotificationRateLimitPtrInput)(nil)).Elem(), NotificationRateLimitArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PerformanceThresholdInput)(nil)).Elem(), PerformanceThresholdArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PerformanceThresholdPtrInput)(nil)).Elem(), PerformanceThresholdArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PingConfigInput)(nil)).Elem(), PingConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PingConfigPtrInput)(nil)).Elem(), PingConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PrometheusQueryLanguageConditionInput)(nil)).Elem(), PrometheusQueryLanguageConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PrometheusQueryLanguageConditionPtrInput)(nil)).Elem(), PrometheusQueryLanguageConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RequestBasedSliInput)(nil)).Elem(), RequestBasedSliArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RequestBasedSliPtrInput)(nil)).Elem(), RequestBasedSliArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceGroupInput)(nil)).Elem(), ResourceGroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceGroupPtrInput)(nil)).Elem(), ResourceGroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResponseStatusCodeInput)(nil)).Elem(), ResponseStatusCodeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResponseStatusCodeArrayInput)(nil)).Elem(), ResponseStatusCodeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceLevelIndicatorInput)(nil)).Elem(), ServiceLevelIndicatorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceLevelIndicatorPtrInput)(nil)).Elem(), ServiceLevelIndicatorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatusInput)(nil)).Elem(), StatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatusPtrInput)(nil)).Elem(), StatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SyntheticMonitorTargetInput)(nil)).Elem(), SyntheticMonitorTargetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SyntheticMonitorTargetPtrInput)(nil)).Elem(), SyntheticMonitorTargetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TcpCheckInput)(nil)).Elem(), TcpCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TcpCheckPtrInput)(nil)).Elem(), TcpCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TelemetryInput)(nil)).Elem(), TelemetryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TelemetryPtrInput)(nil)).Elem(), TelemetryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeIntervalInput)(nil)).Elem(), TimeIntervalArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesRatioInput)(nil)).Elem(), TimeSeriesRatioArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesRatioPtrInput)(nil)).Elem(), TimeSeriesRatioArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TriggerInput)(nil)).Elem(), TriggerArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TriggerPtrInput)(nil)).Elem(), TriggerArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WindowsBasedSliInput)(nil)).Elem(), WindowsBasedSliArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WindowsBasedSliPtrInput)(nil)).Elem(), WindowsBasedSliArgs{})
	pulumi.RegisterOutputType(AggregationOutput{})
	pulumi.RegisterOutputType(AggregationArrayOutput{})
	pulumi.RegisterOutputType(AggregationResponseOutput{})
	pulumi.RegisterOutputType(AggregationResponseArrayOutput{})
	pulumi.RegisterOutputType(AlertStrategyOutput{})
	pulumi.RegisterOutputType(AlertStrategyPtrOutput{})
	pulumi.RegisterOutputType(AlertStrategyResponseOutput{})
	pulumi.RegisterOutputType(AppEngineOutput{})
	pulumi.RegisterOutputType(AppEnginePtrOutput{})
	pulumi.RegisterOutputType(AppEngineResponseOutput{})
	pulumi.RegisterOutputType(AvailabilityCriteriaOutput{})
	pulumi.RegisterOutputType(AvailabilityCriteriaPtrOutput{})
	pulumi.RegisterOutputType(AvailabilityCriteriaResponseOutput{})
	pulumi.RegisterOutputType(BasicAuthenticationOutput{})
	pulumi.RegisterOutputType(BasicAuthenticationPtrOutput{})
	pulumi.RegisterOutputType(BasicAuthenticationResponseOutput{})
	pulumi.RegisterOutputType(BasicServiceOutput{})
	pulumi.RegisterOutputType(BasicServicePtrOutput{})
	pulumi.RegisterOutputType(BasicServiceResponseOutput{})
	pulumi.RegisterOutputType(BasicSliOutput{})
	pulumi.RegisterOutputType(BasicSliPtrOutput{})
	pulumi.RegisterOutputType(BasicSliResponseOutput{})
	pulumi.RegisterOutputType(CloudEndpointsOutput{})
	pulumi.RegisterOutputType(CloudEndpointsPtrOutput{})
	pulumi.RegisterOutputType(CloudEndpointsResponseOutput{})
	pulumi.RegisterOutputType(CloudFunctionV2TargetOutput{})
	pulumi.RegisterOutputType(CloudFunctionV2TargetPtrOutput{})
	pulumi.RegisterOutputType(CloudFunctionV2TargetResponseOutput{})
	pulumi.RegisterOutputType(CloudRunOutput{})
	pulumi.RegisterOutputType(CloudRunPtrOutput{})
	pulumi.RegisterOutputType(CloudRunResponseOutput{})
	pulumi.RegisterOutputType(ClusterIstioOutput{})
	pulumi.RegisterOutputType(ClusterIstioPtrOutput{})
	pulumi.RegisterOutputType(ClusterIstioResponseOutput{})
	pulumi.RegisterOutputType(ConditionOutput{})
	pulumi.RegisterOutputType(ConditionArrayOutput{})
	pulumi.RegisterOutputType(ConditionResponseOutput{})
	pulumi.RegisterOutputType(ConditionResponseArrayOutput{})
	pulumi.RegisterOutputType(ContentMatcherOutput{})
	pulumi.RegisterOutputType(ContentMatcherArrayOutput{})
	pulumi.RegisterOutputType(ContentMatcherResponseOutput{})
	pulumi.RegisterOutputType(ContentMatcherResponseArrayOutput{})
	pulumi.RegisterOutputType(CriteriaOutput{})
	pulumi.RegisterOutputType(CriteriaResponseOutput{})
	pulumi.RegisterOutputType(CustomOutput{})
	pulumi.RegisterOutputType(CustomPtrOutput{})
	pulumi.RegisterOutputType(CustomResponseOutput{})
	pulumi.RegisterOutputType(DistributionCutOutput{})
	pulumi.RegisterOutputType(DistributionCutPtrOutput{})
	pulumi.RegisterOutputType(DistributionCutResponseOutput{})
	pulumi.RegisterOutputType(DocumentationOutput{})
	pulumi.RegisterOutputType(DocumentationPtrOutput{})
	pulumi.RegisterOutputType(DocumentationResponseOutput{})
	pulumi.RegisterOutputType(ForecastOptionsOutput{})
	pulumi.RegisterOutputType(ForecastOptionsPtrOutput{})
	pulumi.RegisterOutputType(ForecastOptionsResponseOutput{})
	pulumi.RegisterOutputType(GkeNamespaceOutput{})
	pulumi.RegisterOutputType(GkeNamespacePtrOutput{})
	pulumi.RegisterOutputType(GkeNamespaceResponseOutput{})
	pulumi.RegisterOutputType(GkeServiceOutput{})
	pulumi.RegisterOutputType(GkeServicePtrOutput{})
	pulumi.RegisterOutputType(GkeServiceResponseOutput{})
	pulumi.RegisterOutputType(GkeWorkloadOutput{})
	pulumi.RegisterOutputType(GkeWorkloadPtrOutput{})
	pulumi.RegisterOutputType(GkeWorkloadResponseOutput{})
	pulumi.RegisterOutputType(GoogleMonitoringV3RangeOutput{})
	pulumi.RegisterOutputType(GoogleMonitoringV3RangePtrOutput{})
	pulumi.RegisterOutputType(GoogleMonitoringV3RangeResponseOutput{})
	pulumi.RegisterOutputType(HttpCheckOutput{})
	pulumi.RegisterOutputType(HttpCheckPtrOutput{})
	pulumi.RegisterOutputType(HttpCheckResponseOutput{})
	pulumi.RegisterOutputType(InternalCheckerOutput{})
	pulumi.RegisterOutputType(InternalCheckerArrayOutput{})
	pulumi.RegisterOutputType(InternalCheckerResponseOutput{})
	pulumi.RegisterOutputType(InternalCheckerResponseArrayOutput{})
	pulumi.RegisterOutputType(IstioCanonicalServiceOutput{})
	pulumi.RegisterOutputType(IstioCanonicalServicePtrOutput{})
	pulumi.RegisterOutputType(IstioCanonicalServiceResponseOutput{})
	pulumi.RegisterOutputType(JsonPathMatcherOutput{})
	pulumi.RegisterOutputType(JsonPathMatcherPtrOutput{})
	pulumi.RegisterOutputType(JsonPathMatcherResponseOutput{})
	pulumi.RegisterOutputType(LabelDescriptorOutput{})
	pulumi.RegisterOutputType(LabelDescriptorArrayOutput{})
	pulumi.RegisterOutputType(LabelDescriptorResponseOutput{})
	pulumi.RegisterOutputType(LabelDescriptorResponseArrayOutput{})
	pulumi.RegisterOutputType(LatencyCriteriaOutput{})
	pulumi.RegisterOutputType(LatencyCriteriaPtrOutput{})
	pulumi.RegisterOutputType(LatencyCriteriaResponseOutput{})
	pulumi.RegisterOutputType(LogMatchOutput{})
	pulumi.RegisterOutputType(LogMatchPtrOutput{})
	pulumi.RegisterOutputType(LogMatchResponseOutput{})
	pulumi.RegisterOutputType(MeshIstioOutput{})
	pulumi.RegisterOutputType(MeshIstioPtrOutput{})
	pulumi.RegisterOutputType(MeshIstioResponseOutput{})
	pulumi.RegisterOutputType(MetricAbsenceOutput{})
	pulumi.RegisterOutputType(MetricAbsencePtrOutput{})
	pulumi.RegisterOutputType(MetricAbsenceResponseOutput{})
	pulumi.RegisterOutputType(MetricDescriptorMetadataOutput{})
	pulumi.RegisterOutputType(MetricDescriptorMetadataPtrOutput{})
	pulumi.RegisterOutputType(MetricDescriptorMetadataResponseOutput{})
	pulumi.RegisterOutputType(MetricRangeOutput{})
	pulumi.RegisterOutputType(MetricRangePtrOutput{})
	pulumi.RegisterOutputType(MetricRangeResponseOutput{})
	pulumi.RegisterOutputType(MetricThresholdOutput{})
	pulumi.RegisterOutputType(MetricThresholdPtrOutput{})
	pulumi.RegisterOutputType(MetricThresholdResponseOutput{})
	pulumi.RegisterOutputType(MonitoredResourceOutput{})
	pulumi.RegisterOutputType(MonitoredResourcePtrOutput{})
	pulumi.RegisterOutputType(MonitoredResourceResponseOutput{})
	pulumi.RegisterOutputType(MonitoringQueryLanguageConditionOutput{})
	pulumi.RegisterOutputType(MonitoringQueryLanguageConditionPtrOutput{})
	pulumi.RegisterOutputType(MonitoringQueryLanguageConditionResponseOutput{})
	pulumi.RegisterOutputType(MutationRecordOutput{})
	pulumi.RegisterOutputType(MutationRecordPtrOutput{})
	pulumi.RegisterOutputType(MutationRecordArrayOutput{})
	pulumi.RegisterOutputType(MutationRecordResponseOutput{})
	pulumi.RegisterOutputType(MutationRecordResponseArrayOutput{})
	pulumi.RegisterOutputType(NotificationChannelStrategyOutput{})
	pulumi.RegisterOutputType(NotificationChannelStrategyArrayOutput{})
	pulumi.RegisterOutputType(NotificationChannelStrategyResponseOutput{})
	pulumi.RegisterOutputType(NotificationChannelStrategyResponseArrayOutput{})
	pulumi.RegisterOutputType(NotificationRateLimitOutput{})
	pulumi.RegisterOutputType(NotificationRateLimitPtrOutput{})
	pulumi.RegisterOutputType(NotificationRateLimitResponseOutput{})
	pulumi.RegisterOutputType(PerformanceThresholdOutput{})
	pulumi.RegisterOutputType(PerformanceThresholdPtrOutput{})
	pulumi.RegisterOutputType(PerformanceThresholdResponseOutput{})
	pulumi.RegisterOutputType(PingConfigOutput{})
	pulumi.RegisterOutputType(PingConfigPtrOutput{})
	pulumi.RegisterOutputType(PingConfigResponseOutput{})
	pulumi.RegisterOutputType(PrometheusQueryLanguageConditionOutput{})
	pulumi.RegisterOutputType(PrometheusQueryLanguageConditionPtrOutput{})
	pulumi.RegisterOutputType(PrometheusQueryLanguageConditionResponseOutput{})
	pulumi.RegisterOutputType(RequestBasedSliOutput{})
	pulumi.RegisterOutputType(RequestBasedSliPtrOutput{})
	pulumi.RegisterOutputType(RequestBasedSliResponseOutput{})
	pulumi.RegisterOutputType(ResourceGroupOutput{})
	pulumi.RegisterOutputType(ResourceGroupPtrOutput{})
	pulumi.RegisterOutputType(ResourceGroupResponseOutput{})
	pulumi.RegisterOutputType(ResponseStatusCodeOutput{})
	pulumi.RegisterOutputType(ResponseStatusCodeArrayOutput{})
	pulumi.RegisterOutputType(ResponseStatusCodeResponseOutput{})
	pulumi.RegisterOutputType(ResponseStatusCodeResponseArrayOutput{})
	pulumi.RegisterOutputType(ServiceLevelIndicatorOutput{})
	pulumi.RegisterOutputType(ServiceLevelIndicatorPtrOutput{})
	pulumi.RegisterOutputType(ServiceLevelIndicatorResponseOutput{})
	pulumi.RegisterOutputType(StatusOutput{})
	pulumi.RegisterOutputType(StatusPtrOutput{})
	pulumi.RegisterOutputType(StatusResponseOutput{})
	pulumi.RegisterOutputType(SyntheticMonitorTargetOutput{})
	pulumi.RegisterOutputType(SyntheticMonitorTargetPtrOutput{})
	pulumi.RegisterOutputType(SyntheticMonitorTargetResponseOutput{})
	pulumi.RegisterOutputType(TcpCheckOutput{})
	pulumi.RegisterOutputType(TcpCheckPtrOutput{})
	pulumi.RegisterOutputType(TcpCheckResponseOutput{})
	pulumi.RegisterOutputType(TelemetryOutput{})
	pulumi.RegisterOutputType(TelemetryPtrOutput{})
	pulumi.RegisterOutputType(TelemetryResponseOutput{})
	pulumi.RegisterOutputType(TimeIntervalOutput{})
	pulumi.RegisterOutputType(TimeIntervalResponseOutput{})
	pulumi.RegisterOutputType(TimeSeriesRatioOutput{})
	pulumi.RegisterOutputType(TimeSeriesRatioPtrOutput{})
	pulumi.RegisterOutputType(TimeSeriesRatioResponseOutput{})
	pulumi.RegisterOutputType(TriggerOutput{})
	pulumi.RegisterOutputType(TriggerPtrOutput{})
	pulumi.RegisterOutputType(TriggerResponseOutput{})
	pulumi.RegisterOutputType(WindowsBasedSliOutput{})
	pulumi.RegisterOutputType(WindowsBasedSliPtrOutput{})
	pulumi.RegisterOutputType(WindowsBasedSliResponseOutput{})
}

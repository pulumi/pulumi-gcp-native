// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type Aggregation struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
	AlignmentPeriod *string `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer *AggregationCrossSeriesReducer `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields []string `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner *AggregationPerSeriesAligner `pulumi:"perSeriesAligner"`
}

// AggregationInput is an input type that accepts AggregationArgs and AggregationOutput values.
// You can construct a concrete instance of `AggregationInput` via:
//
//	AggregationArgs{...}
type AggregationInput interface {
	pulumi.Input

	ToAggregationOutput() AggregationOutput
	ToAggregationOutputWithContext(context.Context) AggregationOutput
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationArgs struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
	AlignmentPeriod pulumi.StringPtrInput `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer AggregationCrossSeriesReducerPtrInput `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields pulumi.StringArrayInput `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner AggregationPerSeriesAlignerPtrInput `pulumi:"perSeriesAligner"`
}

func (AggregationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Aggregation)(nil)).Elem()
}

func (i AggregationArgs) ToAggregationOutput() AggregationOutput {
	return i.ToAggregationOutputWithContext(context.Background())
}

func (i AggregationArgs) ToAggregationOutputWithContext(ctx context.Context) AggregationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationOutput)
}

func (i AggregationArgs) ToAggregationPtrOutput() AggregationPtrOutput {
	return i.ToAggregationPtrOutputWithContext(context.Background())
}

func (i AggregationArgs) ToAggregationPtrOutputWithContext(ctx context.Context) AggregationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationOutput).ToAggregationPtrOutputWithContext(ctx)
}

// AggregationPtrInput is an input type that accepts AggregationArgs, AggregationPtr and AggregationPtrOutput values.
// You can construct a concrete instance of `AggregationPtrInput` via:
//
//	        AggregationArgs{...}
//
//	or:
//
//	        nil
type AggregationPtrInput interface {
	pulumi.Input

	ToAggregationPtrOutput() AggregationPtrOutput
	ToAggregationPtrOutputWithContext(context.Context) AggregationPtrOutput
}

type aggregationPtrType AggregationArgs

func AggregationPtr(v *AggregationArgs) AggregationPtrInput {
	return (*aggregationPtrType)(v)
}

func (*aggregationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Aggregation)(nil)).Elem()
}

func (i *aggregationPtrType) ToAggregationPtrOutput() AggregationPtrOutput {
	return i.ToAggregationPtrOutputWithContext(context.Background())
}

func (i *aggregationPtrType) ToAggregationPtrOutputWithContext(ctx context.Context) AggregationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationPtrOutput)
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationOutput struct{ *pulumi.OutputState }

func (AggregationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Aggregation)(nil)).Elem()
}

func (o AggregationOutput) ToAggregationOutput() AggregationOutput {
	return o
}

func (o AggregationOutput) ToAggregationOutputWithContext(ctx context.Context) AggregationOutput {
	return o
}

func (o AggregationOutput) ToAggregationPtrOutput() AggregationPtrOutput {
	return o.ToAggregationPtrOutputWithContext(context.Background())
}

func (o AggregationOutput) ToAggregationPtrOutputWithContext(ctx context.Context) AggregationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Aggregation) *Aggregation {
		return &v
	}).(AggregationPtrOutput)
}

// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
func (o AggregationOutput) AlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Aggregation) *string { return v.AlignmentPeriod }).(pulumi.StringPtrOutput)
}

// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
func (o AggregationOutput) CrossSeriesReducer() AggregationCrossSeriesReducerPtrOutput {
	return o.ApplyT(func(v Aggregation) *AggregationCrossSeriesReducer { return v.CrossSeriesReducer }).(AggregationCrossSeriesReducerPtrOutput)
}

// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
func (o AggregationOutput) GroupByFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Aggregation) []string { return v.GroupByFields }).(pulumi.StringArrayOutput)
}

// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
func (o AggregationOutput) PerSeriesAligner() AggregationPerSeriesAlignerPtrOutput {
	return o.ApplyT(func(v Aggregation) *AggregationPerSeriesAligner { return v.PerSeriesAligner }).(AggregationPerSeriesAlignerPtrOutput)
}

type AggregationPtrOutput struct{ *pulumi.OutputState }

func (AggregationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Aggregation)(nil)).Elem()
}

func (o AggregationPtrOutput) ToAggregationPtrOutput() AggregationPtrOutput {
	return o
}

func (o AggregationPtrOutput) ToAggregationPtrOutputWithContext(ctx context.Context) AggregationPtrOutput {
	return o
}

func (o AggregationPtrOutput) Elem() AggregationOutput {
	return o.ApplyT(func(v *Aggregation) Aggregation {
		if v != nil {
			return *v
		}
		var ret Aggregation
		return ret
	}).(AggregationOutput)
}

// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
func (o AggregationPtrOutput) AlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Aggregation) *string {
		if v == nil {
			return nil
		}
		return v.AlignmentPeriod
	}).(pulumi.StringPtrOutput)
}

// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
func (o AggregationPtrOutput) CrossSeriesReducer() AggregationCrossSeriesReducerPtrOutput {
	return o.ApplyT(func(v *Aggregation) *AggregationCrossSeriesReducer {
		if v == nil {
			return nil
		}
		return v.CrossSeriesReducer
	}).(AggregationCrossSeriesReducerPtrOutput)
}

// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
func (o AggregationPtrOutput) GroupByFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Aggregation) []string {
		if v == nil {
			return nil
		}
		return v.GroupByFields
	}).(pulumi.StringArrayOutput)
}

// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
func (o AggregationPtrOutput) PerSeriesAligner() AggregationPerSeriesAlignerPtrOutput {
	return o.ApplyT(func(v *Aggregation) *AggregationPerSeriesAligner {
		if v == nil {
			return nil
		}
		return v.PerSeriesAligner
	}).(AggregationPerSeriesAlignerPtrOutput)
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationResponse struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
	AlignmentPeriod string `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer string `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields []string `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner string `pulumi:"perSeriesAligner"`
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationResponseOutput struct{ *pulumi.OutputState }

func (AggregationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AggregationResponse)(nil)).Elem()
}

func (o AggregationResponseOutput) ToAggregationResponseOutput() AggregationResponseOutput {
	return o
}

func (o AggregationResponseOutput) ToAggregationResponseOutputWithContext(ctx context.Context) AggregationResponseOutput {
	return o
}

// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
func (o AggregationResponseOutput) AlignmentPeriod() pulumi.StringOutput {
	return o.ApplyT(func(v AggregationResponse) string { return v.AlignmentPeriod }).(pulumi.StringOutput)
}

// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
func (o AggregationResponseOutput) CrossSeriesReducer() pulumi.StringOutput {
	return o.ApplyT(func(v AggregationResponse) string { return v.CrossSeriesReducer }).(pulumi.StringOutput)
}

// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
func (o AggregationResponseOutput) GroupByFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AggregationResponse) []string { return v.GroupByFields }).(pulumi.StringArrayOutput)
}

// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
func (o AggregationResponseOutput) PerSeriesAligner() pulumi.StringOutput {
	return o.ApplyT(func(v AggregationResponse) string { return v.PerSeriesAligner }).(pulumi.StringOutput)
}

// A chart that displays alert policy data.
type AlertChart struct {
	// The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
	Name string `pulumi:"name"`
}

// AlertChartInput is an input type that accepts AlertChartArgs and AlertChartOutput values.
// You can construct a concrete instance of `AlertChartInput` via:
//
//	AlertChartArgs{...}
type AlertChartInput interface {
	pulumi.Input

	ToAlertChartOutput() AlertChartOutput
	ToAlertChartOutputWithContext(context.Context) AlertChartOutput
}

// A chart that displays alert policy data.
type AlertChartArgs struct {
	// The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
	Name pulumi.StringInput `pulumi:"name"`
}

func (AlertChartArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertChart)(nil)).Elem()
}

func (i AlertChartArgs) ToAlertChartOutput() AlertChartOutput {
	return i.ToAlertChartOutputWithContext(context.Background())
}

func (i AlertChartArgs) ToAlertChartOutputWithContext(ctx context.Context) AlertChartOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertChartOutput)
}

func (i AlertChartArgs) ToAlertChartPtrOutput() AlertChartPtrOutput {
	return i.ToAlertChartPtrOutputWithContext(context.Background())
}

func (i AlertChartArgs) ToAlertChartPtrOutputWithContext(ctx context.Context) AlertChartPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertChartOutput).ToAlertChartPtrOutputWithContext(ctx)
}

// AlertChartPtrInput is an input type that accepts AlertChartArgs, AlertChartPtr and AlertChartPtrOutput values.
// You can construct a concrete instance of `AlertChartPtrInput` via:
//
//	        AlertChartArgs{...}
//
//	or:
//
//	        nil
type AlertChartPtrInput interface {
	pulumi.Input

	ToAlertChartPtrOutput() AlertChartPtrOutput
	ToAlertChartPtrOutputWithContext(context.Context) AlertChartPtrOutput
}

type alertChartPtrType AlertChartArgs

func AlertChartPtr(v *AlertChartArgs) AlertChartPtrInput {
	return (*alertChartPtrType)(v)
}

func (*alertChartPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertChart)(nil)).Elem()
}

func (i *alertChartPtrType) ToAlertChartPtrOutput() AlertChartPtrOutput {
	return i.ToAlertChartPtrOutputWithContext(context.Background())
}

func (i *alertChartPtrType) ToAlertChartPtrOutputWithContext(ctx context.Context) AlertChartPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertChartPtrOutput)
}

// A chart that displays alert policy data.
type AlertChartOutput struct{ *pulumi.OutputState }

func (AlertChartOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertChart)(nil)).Elem()
}

func (o AlertChartOutput) ToAlertChartOutput() AlertChartOutput {
	return o
}

func (o AlertChartOutput) ToAlertChartOutputWithContext(ctx context.Context) AlertChartOutput {
	return o
}

func (o AlertChartOutput) ToAlertChartPtrOutput() AlertChartPtrOutput {
	return o.ToAlertChartPtrOutputWithContext(context.Background())
}

func (o AlertChartOutput) ToAlertChartPtrOutputWithContext(ctx context.Context) AlertChartPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AlertChart) *AlertChart {
		return &v
	}).(AlertChartPtrOutput)
}

// The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
func (o AlertChartOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v AlertChart) string { return v.Name }).(pulumi.StringOutput)
}

type AlertChartPtrOutput struct{ *pulumi.OutputState }

func (AlertChartPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertChart)(nil)).Elem()
}

func (o AlertChartPtrOutput) ToAlertChartPtrOutput() AlertChartPtrOutput {
	return o
}

func (o AlertChartPtrOutput) ToAlertChartPtrOutputWithContext(ctx context.Context) AlertChartPtrOutput {
	return o
}

func (o AlertChartPtrOutput) Elem() AlertChartOutput {
	return o.ApplyT(func(v *AlertChart) AlertChart {
		if v != nil {
			return *v
		}
		var ret AlertChart
		return ret
	}).(AlertChartOutput)
}

// The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
func (o AlertChartPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlertChart) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// A chart that displays alert policy data.
type AlertChartResponse struct {
	// The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
	Name string `pulumi:"name"`
}

// A chart that displays alert policy data.
type AlertChartResponseOutput struct{ *pulumi.OutputState }

func (AlertChartResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertChartResponse)(nil)).Elem()
}

func (o AlertChartResponseOutput) ToAlertChartResponseOutput() AlertChartResponseOutput {
	return o
}

func (o AlertChartResponseOutput) ToAlertChartResponseOutputWithContext(ctx context.Context) AlertChartResponseOutput {
	return o
}

// The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
func (o AlertChartResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v AlertChartResponse) string { return v.Name }).(pulumi.StringOutput)
}

// A chart axis.
type Axis struct {
	// The label of the axis.
	Label *string `pulumi:"label"`
	// The axis scale. By default, a linear scale is used.
	Scale *AxisScale `pulumi:"scale"`
}

// AxisInput is an input type that accepts AxisArgs and AxisOutput values.
// You can construct a concrete instance of `AxisInput` via:
//
//	AxisArgs{...}
type AxisInput interface {
	pulumi.Input

	ToAxisOutput() AxisOutput
	ToAxisOutputWithContext(context.Context) AxisOutput
}

// A chart axis.
type AxisArgs struct {
	// The label of the axis.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The axis scale. By default, a linear scale is used.
	Scale AxisScalePtrInput `pulumi:"scale"`
}

func (AxisArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Axis)(nil)).Elem()
}

func (i AxisArgs) ToAxisOutput() AxisOutput {
	return i.ToAxisOutputWithContext(context.Background())
}

func (i AxisArgs) ToAxisOutputWithContext(ctx context.Context) AxisOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AxisOutput)
}

func (i AxisArgs) ToAxisPtrOutput() AxisPtrOutput {
	return i.ToAxisPtrOutputWithContext(context.Background())
}

func (i AxisArgs) ToAxisPtrOutputWithContext(ctx context.Context) AxisPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AxisOutput).ToAxisPtrOutputWithContext(ctx)
}

// AxisPtrInput is an input type that accepts AxisArgs, AxisPtr and AxisPtrOutput values.
// You can construct a concrete instance of `AxisPtrInput` via:
//
//	        AxisArgs{...}
//
//	or:
//
//	        nil
type AxisPtrInput interface {
	pulumi.Input

	ToAxisPtrOutput() AxisPtrOutput
	ToAxisPtrOutputWithContext(context.Context) AxisPtrOutput
}

type axisPtrType AxisArgs

func AxisPtr(v *AxisArgs) AxisPtrInput {
	return (*axisPtrType)(v)
}

func (*axisPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Axis)(nil)).Elem()
}

func (i *axisPtrType) ToAxisPtrOutput() AxisPtrOutput {
	return i.ToAxisPtrOutputWithContext(context.Background())
}

func (i *axisPtrType) ToAxisPtrOutputWithContext(ctx context.Context) AxisPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AxisPtrOutput)
}

// A chart axis.
type AxisOutput struct{ *pulumi.OutputState }

func (AxisOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Axis)(nil)).Elem()
}

func (o AxisOutput) ToAxisOutput() AxisOutput {
	return o
}

func (o AxisOutput) ToAxisOutputWithContext(ctx context.Context) AxisOutput {
	return o
}

func (o AxisOutput) ToAxisPtrOutput() AxisPtrOutput {
	return o.ToAxisPtrOutputWithContext(context.Background())
}

func (o AxisOutput) ToAxisPtrOutputWithContext(ctx context.Context) AxisPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Axis) *Axis {
		return &v
	}).(AxisPtrOutput)
}

// The label of the axis.
func (o AxisOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Axis) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The axis scale. By default, a linear scale is used.
func (o AxisOutput) Scale() AxisScalePtrOutput {
	return o.ApplyT(func(v Axis) *AxisScale { return v.Scale }).(AxisScalePtrOutput)
}

type AxisPtrOutput struct{ *pulumi.OutputState }

func (AxisPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Axis)(nil)).Elem()
}

func (o AxisPtrOutput) ToAxisPtrOutput() AxisPtrOutput {
	return o
}

func (o AxisPtrOutput) ToAxisPtrOutputWithContext(ctx context.Context) AxisPtrOutput {
	return o
}

func (o AxisPtrOutput) Elem() AxisOutput {
	return o.ApplyT(func(v *Axis) Axis {
		if v != nil {
			return *v
		}
		var ret Axis
		return ret
	}).(AxisOutput)
}

// The label of the axis.
func (o AxisPtrOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Axis) *string {
		if v == nil {
			return nil
		}
		return v.Label
	}).(pulumi.StringPtrOutput)
}

// The axis scale. By default, a linear scale is used.
func (o AxisPtrOutput) Scale() AxisScalePtrOutput {
	return o.ApplyT(func(v *Axis) *AxisScale {
		if v == nil {
			return nil
		}
		return v.Scale
	}).(AxisScalePtrOutput)
}

// A chart axis.
type AxisResponse struct {
	// The label of the axis.
	Label string `pulumi:"label"`
	// The axis scale. By default, a linear scale is used.
	Scale string `pulumi:"scale"`
}

// A chart axis.
type AxisResponseOutput struct{ *pulumi.OutputState }

func (AxisResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AxisResponse)(nil)).Elem()
}

func (o AxisResponseOutput) ToAxisResponseOutput() AxisResponseOutput {
	return o
}

func (o AxisResponseOutput) ToAxisResponseOutputWithContext(ctx context.Context) AxisResponseOutput {
	return o
}

// The label of the axis.
func (o AxisResponseOutput) Label() pulumi.StringOutput {
	return o.ApplyT(func(v AxisResponse) string { return v.Label }).(pulumi.StringOutput)
}

// The axis scale. By default, a linear scale is used.
func (o AxisResponseOutput) Scale() pulumi.StringOutput {
	return o.ApplyT(func(v AxisResponse) string { return v.Scale }).(pulumi.StringOutput)
}

// Options to control visual rendering of a chart.
type ChartOptions struct {
	// The chart mode.
	Mode *ChartOptionsMode `pulumi:"mode"`
}

// ChartOptionsInput is an input type that accepts ChartOptionsArgs and ChartOptionsOutput values.
// You can construct a concrete instance of `ChartOptionsInput` via:
//
//	ChartOptionsArgs{...}
type ChartOptionsInput interface {
	pulumi.Input

	ToChartOptionsOutput() ChartOptionsOutput
	ToChartOptionsOutputWithContext(context.Context) ChartOptionsOutput
}

// Options to control visual rendering of a chart.
type ChartOptionsArgs struct {
	// The chart mode.
	Mode ChartOptionsModePtrInput `pulumi:"mode"`
}

func (ChartOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChartOptions)(nil)).Elem()
}

func (i ChartOptionsArgs) ToChartOptionsOutput() ChartOptionsOutput {
	return i.ToChartOptionsOutputWithContext(context.Background())
}

func (i ChartOptionsArgs) ToChartOptionsOutputWithContext(ctx context.Context) ChartOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChartOptionsOutput)
}

func (i ChartOptionsArgs) ToChartOptionsPtrOutput() ChartOptionsPtrOutput {
	return i.ToChartOptionsPtrOutputWithContext(context.Background())
}

func (i ChartOptionsArgs) ToChartOptionsPtrOutputWithContext(ctx context.Context) ChartOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChartOptionsOutput).ToChartOptionsPtrOutputWithContext(ctx)
}

// ChartOptionsPtrInput is an input type that accepts ChartOptionsArgs, ChartOptionsPtr and ChartOptionsPtrOutput values.
// You can construct a concrete instance of `ChartOptionsPtrInput` via:
//
//	        ChartOptionsArgs{...}
//
//	or:
//
//	        nil
type ChartOptionsPtrInput interface {
	pulumi.Input

	ToChartOptionsPtrOutput() ChartOptionsPtrOutput
	ToChartOptionsPtrOutputWithContext(context.Context) ChartOptionsPtrOutput
}

type chartOptionsPtrType ChartOptionsArgs

func ChartOptionsPtr(v *ChartOptionsArgs) ChartOptionsPtrInput {
	return (*chartOptionsPtrType)(v)
}

func (*chartOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChartOptions)(nil)).Elem()
}

func (i *chartOptionsPtrType) ToChartOptionsPtrOutput() ChartOptionsPtrOutput {
	return i.ToChartOptionsPtrOutputWithContext(context.Background())
}

func (i *chartOptionsPtrType) ToChartOptionsPtrOutputWithContext(ctx context.Context) ChartOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChartOptionsPtrOutput)
}

// Options to control visual rendering of a chart.
type ChartOptionsOutput struct{ *pulumi.OutputState }

func (ChartOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChartOptions)(nil)).Elem()
}

func (o ChartOptionsOutput) ToChartOptionsOutput() ChartOptionsOutput {
	return o
}

func (o ChartOptionsOutput) ToChartOptionsOutputWithContext(ctx context.Context) ChartOptionsOutput {
	return o
}

func (o ChartOptionsOutput) ToChartOptionsPtrOutput() ChartOptionsPtrOutput {
	return o.ToChartOptionsPtrOutputWithContext(context.Background())
}

func (o ChartOptionsOutput) ToChartOptionsPtrOutputWithContext(ctx context.Context) ChartOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChartOptions) *ChartOptions {
		return &v
	}).(ChartOptionsPtrOutput)
}

// The chart mode.
func (o ChartOptionsOutput) Mode() ChartOptionsModePtrOutput {
	return o.ApplyT(func(v ChartOptions) *ChartOptionsMode { return v.Mode }).(ChartOptionsModePtrOutput)
}

type ChartOptionsPtrOutput struct{ *pulumi.OutputState }

func (ChartOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChartOptions)(nil)).Elem()
}

func (o ChartOptionsPtrOutput) ToChartOptionsPtrOutput() ChartOptionsPtrOutput {
	return o
}

func (o ChartOptionsPtrOutput) ToChartOptionsPtrOutputWithContext(ctx context.Context) ChartOptionsPtrOutput {
	return o
}

func (o ChartOptionsPtrOutput) Elem() ChartOptionsOutput {
	return o.ApplyT(func(v *ChartOptions) ChartOptions {
		if v != nil {
			return *v
		}
		var ret ChartOptions
		return ret
	}).(ChartOptionsOutput)
}

// The chart mode.
func (o ChartOptionsPtrOutput) Mode() ChartOptionsModePtrOutput {
	return o.ApplyT(func(v *ChartOptions) *ChartOptionsMode {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(ChartOptionsModePtrOutput)
}

// Options to control visual rendering of a chart.
type ChartOptionsResponse struct {
	// The chart mode.
	Mode string `pulumi:"mode"`
}

// Options to control visual rendering of a chart.
type ChartOptionsResponseOutput struct{ *pulumi.OutputState }

func (ChartOptionsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChartOptionsResponse)(nil)).Elem()
}

func (o ChartOptionsResponseOutput) ToChartOptionsResponseOutput() ChartOptionsResponseOutput {
	return o
}

func (o ChartOptionsResponseOutput) ToChartOptionsResponseOutputWithContext(ctx context.Context) ChartOptionsResponseOutput {
	return o
}

// The chart mode.
func (o ChartOptionsResponseOutput) Mode() pulumi.StringOutput {
	return o.ApplyT(func(v ChartOptionsResponse) string { return v.Mode }).(pulumi.StringOutput)
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type CollapsibleGroup struct {
	// The collapsed state of the widget on first page load.
	Collapsed *bool `pulumi:"collapsed"`
}

// CollapsibleGroupInput is an input type that accepts CollapsibleGroupArgs and CollapsibleGroupOutput values.
// You can construct a concrete instance of `CollapsibleGroupInput` via:
//
//	CollapsibleGroupArgs{...}
type CollapsibleGroupInput interface {
	pulumi.Input

	ToCollapsibleGroupOutput() CollapsibleGroupOutput
	ToCollapsibleGroupOutputWithContext(context.Context) CollapsibleGroupOutput
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type CollapsibleGroupArgs struct {
	// The collapsed state of the widget on first page load.
	Collapsed pulumi.BoolPtrInput `pulumi:"collapsed"`
}

func (CollapsibleGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CollapsibleGroup)(nil)).Elem()
}

func (i CollapsibleGroupArgs) ToCollapsibleGroupOutput() CollapsibleGroupOutput {
	return i.ToCollapsibleGroupOutputWithContext(context.Background())
}

func (i CollapsibleGroupArgs) ToCollapsibleGroupOutputWithContext(ctx context.Context) CollapsibleGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollapsibleGroupOutput)
}

func (i CollapsibleGroupArgs) ToCollapsibleGroupPtrOutput() CollapsibleGroupPtrOutput {
	return i.ToCollapsibleGroupPtrOutputWithContext(context.Background())
}

func (i CollapsibleGroupArgs) ToCollapsibleGroupPtrOutputWithContext(ctx context.Context) CollapsibleGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollapsibleGroupOutput).ToCollapsibleGroupPtrOutputWithContext(ctx)
}

// CollapsibleGroupPtrInput is an input type that accepts CollapsibleGroupArgs, CollapsibleGroupPtr and CollapsibleGroupPtrOutput values.
// You can construct a concrete instance of `CollapsibleGroupPtrInput` via:
//
//	        CollapsibleGroupArgs{...}
//
//	or:
//
//	        nil
type CollapsibleGroupPtrInput interface {
	pulumi.Input

	ToCollapsibleGroupPtrOutput() CollapsibleGroupPtrOutput
	ToCollapsibleGroupPtrOutputWithContext(context.Context) CollapsibleGroupPtrOutput
}

type collapsibleGroupPtrType CollapsibleGroupArgs

func CollapsibleGroupPtr(v *CollapsibleGroupArgs) CollapsibleGroupPtrInput {
	return (*collapsibleGroupPtrType)(v)
}

func (*collapsibleGroupPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CollapsibleGroup)(nil)).Elem()
}

func (i *collapsibleGroupPtrType) ToCollapsibleGroupPtrOutput() CollapsibleGroupPtrOutput {
	return i.ToCollapsibleGroupPtrOutputWithContext(context.Background())
}

func (i *collapsibleGroupPtrType) ToCollapsibleGroupPtrOutputWithContext(ctx context.Context) CollapsibleGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollapsibleGroupPtrOutput)
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type CollapsibleGroupOutput struct{ *pulumi.OutputState }

func (CollapsibleGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CollapsibleGroup)(nil)).Elem()
}

func (o CollapsibleGroupOutput) ToCollapsibleGroupOutput() CollapsibleGroupOutput {
	return o
}

func (o CollapsibleGroupOutput) ToCollapsibleGroupOutputWithContext(ctx context.Context) CollapsibleGroupOutput {
	return o
}

func (o CollapsibleGroupOutput) ToCollapsibleGroupPtrOutput() CollapsibleGroupPtrOutput {
	return o.ToCollapsibleGroupPtrOutputWithContext(context.Background())
}

func (o CollapsibleGroupOutput) ToCollapsibleGroupPtrOutputWithContext(ctx context.Context) CollapsibleGroupPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CollapsibleGroup) *CollapsibleGroup {
		return &v
	}).(CollapsibleGroupPtrOutput)
}

// The collapsed state of the widget on first page load.
func (o CollapsibleGroupOutput) Collapsed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CollapsibleGroup) *bool { return v.Collapsed }).(pulumi.BoolPtrOutput)
}

type CollapsibleGroupPtrOutput struct{ *pulumi.OutputState }

func (CollapsibleGroupPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CollapsibleGroup)(nil)).Elem()
}

func (o CollapsibleGroupPtrOutput) ToCollapsibleGroupPtrOutput() CollapsibleGroupPtrOutput {
	return o
}

func (o CollapsibleGroupPtrOutput) ToCollapsibleGroupPtrOutputWithContext(ctx context.Context) CollapsibleGroupPtrOutput {
	return o
}

func (o CollapsibleGroupPtrOutput) Elem() CollapsibleGroupOutput {
	return o.ApplyT(func(v *CollapsibleGroup) CollapsibleGroup {
		if v != nil {
			return *v
		}
		var ret CollapsibleGroup
		return ret
	}).(CollapsibleGroupOutput)
}

// The collapsed state of the widget on first page load.
func (o CollapsibleGroupPtrOutput) Collapsed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CollapsibleGroup) *bool {
		if v == nil {
			return nil
		}
		return v.Collapsed
	}).(pulumi.BoolPtrOutput)
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type CollapsibleGroupResponse struct {
	// The collapsed state of the widget on first page load.
	Collapsed bool `pulumi:"collapsed"`
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type CollapsibleGroupResponseOutput struct{ *pulumi.OutputState }

func (CollapsibleGroupResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CollapsibleGroupResponse)(nil)).Elem()
}

func (o CollapsibleGroupResponseOutput) ToCollapsibleGroupResponseOutput() CollapsibleGroupResponseOutput {
	return o
}

func (o CollapsibleGroupResponseOutput) ToCollapsibleGroupResponseOutputWithContext(ctx context.Context) CollapsibleGroupResponseOutput {
	return o
}

// The collapsed state of the widget on first page load.
func (o CollapsibleGroupResponseOutput) Collapsed() pulumi.BoolOutput {
	return o.ApplyT(func(v CollapsibleGroupResponse) bool { return v.Collapsed }).(pulumi.BoolOutput)
}

// Defines the layout properties and content for a column.
type Column struct {
	// The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
	Weight *string `pulumi:"weight"`
	// The display widgets arranged vertically in this column.
	Widgets []Widget `pulumi:"widgets"`
}

// ColumnInput is an input type that accepts ColumnArgs and ColumnOutput values.
// You can construct a concrete instance of `ColumnInput` via:
//
//	ColumnArgs{...}
type ColumnInput interface {
	pulumi.Input

	ToColumnOutput() ColumnOutput
	ToColumnOutputWithContext(context.Context) ColumnOutput
}

// Defines the layout properties and content for a column.
type ColumnArgs struct {
	// The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
	Weight pulumi.StringPtrInput `pulumi:"weight"`
	// The display widgets arranged vertically in this column.
	Widgets WidgetArrayInput `pulumi:"widgets"`
}

func (ColumnArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Column)(nil)).Elem()
}

func (i ColumnArgs) ToColumnOutput() ColumnOutput {
	return i.ToColumnOutputWithContext(context.Background())
}

func (i ColumnArgs) ToColumnOutputWithContext(ctx context.Context) ColumnOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ColumnOutput)
}

// ColumnArrayInput is an input type that accepts ColumnArray and ColumnArrayOutput values.
// You can construct a concrete instance of `ColumnArrayInput` via:
//
//	ColumnArray{ ColumnArgs{...} }
type ColumnArrayInput interface {
	pulumi.Input

	ToColumnArrayOutput() ColumnArrayOutput
	ToColumnArrayOutputWithContext(context.Context) ColumnArrayOutput
}

type ColumnArray []ColumnInput

func (ColumnArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Column)(nil)).Elem()
}

func (i ColumnArray) ToColumnArrayOutput() ColumnArrayOutput {
	return i.ToColumnArrayOutputWithContext(context.Background())
}

func (i ColumnArray) ToColumnArrayOutputWithContext(ctx context.Context) ColumnArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ColumnArrayOutput)
}

// Defines the layout properties and content for a column.
type ColumnOutput struct{ *pulumi.OutputState }

func (ColumnOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Column)(nil)).Elem()
}

func (o ColumnOutput) ToColumnOutput() ColumnOutput {
	return o
}

func (o ColumnOutput) ToColumnOutputWithContext(ctx context.Context) ColumnOutput {
	return o
}

// The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
func (o ColumnOutput) Weight() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Column) *string { return v.Weight }).(pulumi.StringPtrOutput)
}

// The display widgets arranged vertically in this column.
func (o ColumnOutput) Widgets() WidgetArrayOutput {
	return o.ApplyT(func(v Column) []Widget { return v.Widgets }).(WidgetArrayOutput)
}

type ColumnArrayOutput struct{ *pulumi.OutputState }

func (ColumnArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Column)(nil)).Elem()
}

func (o ColumnArrayOutput) ToColumnArrayOutput() ColumnArrayOutput {
	return o
}

func (o ColumnArrayOutput) ToColumnArrayOutputWithContext(ctx context.Context) ColumnArrayOutput {
	return o
}

func (o ColumnArrayOutput) Index(i pulumi.IntInput) ColumnOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Column {
		return vs[0].([]Column)[vs[1].(int)]
	}).(ColumnOutput)
}

// A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column.
type ColumnLayout struct {
	// The columns of content to display.
	Columns []Column `pulumi:"columns"`
}

// ColumnLayoutInput is an input type that accepts ColumnLayoutArgs and ColumnLayoutOutput values.
// You can construct a concrete instance of `ColumnLayoutInput` via:
//
//	ColumnLayoutArgs{...}
type ColumnLayoutInput interface {
	pulumi.Input

	ToColumnLayoutOutput() ColumnLayoutOutput
	ToColumnLayoutOutputWithContext(context.Context) ColumnLayoutOutput
}

// A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column.
type ColumnLayoutArgs struct {
	// The columns of content to display.
	Columns ColumnArrayInput `pulumi:"columns"`
}

func (ColumnLayoutArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ColumnLayout)(nil)).Elem()
}

func (i ColumnLayoutArgs) ToColumnLayoutOutput() ColumnLayoutOutput {
	return i.ToColumnLayoutOutputWithContext(context.Background())
}

func (i ColumnLayoutArgs) ToColumnLayoutOutputWithContext(ctx context.Context) ColumnLayoutOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ColumnLayoutOutput)
}

func (i ColumnLayoutArgs) ToColumnLayoutPtrOutput() ColumnLayoutPtrOutput {
	return i.ToColumnLayoutPtrOutputWithContext(context.Background())
}

func (i ColumnLayoutArgs) ToColumnLayoutPtrOutputWithContext(ctx context.Context) ColumnLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ColumnLayoutOutput).ToColumnLayoutPtrOutputWithContext(ctx)
}

// ColumnLayoutPtrInput is an input type that accepts ColumnLayoutArgs, ColumnLayoutPtr and ColumnLayoutPtrOutput values.
// You can construct a concrete instance of `ColumnLayoutPtrInput` via:
//
//	        ColumnLayoutArgs{...}
//
//	or:
//
//	        nil
type ColumnLayoutPtrInput interface {
	pulumi.Input

	ToColumnLayoutPtrOutput() ColumnLayoutPtrOutput
	ToColumnLayoutPtrOutputWithContext(context.Context) ColumnLayoutPtrOutput
}

type columnLayoutPtrType ColumnLayoutArgs

func ColumnLayoutPtr(v *ColumnLayoutArgs) ColumnLayoutPtrInput {
	return (*columnLayoutPtrType)(v)
}

func (*columnLayoutPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ColumnLayout)(nil)).Elem()
}

func (i *columnLayoutPtrType) ToColumnLayoutPtrOutput() ColumnLayoutPtrOutput {
	return i.ToColumnLayoutPtrOutputWithContext(context.Background())
}

func (i *columnLayoutPtrType) ToColumnLayoutPtrOutputWithContext(ctx context.Context) ColumnLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ColumnLayoutPtrOutput)
}

// A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column.
type ColumnLayoutOutput struct{ *pulumi.OutputState }

func (ColumnLayoutOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ColumnLayout)(nil)).Elem()
}

func (o ColumnLayoutOutput) ToColumnLayoutOutput() ColumnLayoutOutput {
	return o
}

func (o ColumnLayoutOutput) ToColumnLayoutOutputWithContext(ctx context.Context) ColumnLayoutOutput {
	return o
}

func (o ColumnLayoutOutput) ToColumnLayoutPtrOutput() ColumnLayoutPtrOutput {
	return o.ToColumnLayoutPtrOutputWithContext(context.Background())
}

func (o ColumnLayoutOutput) ToColumnLayoutPtrOutputWithContext(ctx context.Context) ColumnLayoutPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ColumnLayout) *ColumnLayout {
		return &v
	}).(ColumnLayoutPtrOutput)
}

// The columns of content to display.
func (o ColumnLayoutOutput) Columns() ColumnArrayOutput {
	return o.ApplyT(func(v ColumnLayout) []Column { return v.Columns }).(ColumnArrayOutput)
}

type ColumnLayoutPtrOutput struct{ *pulumi.OutputState }

func (ColumnLayoutPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ColumnLayout)(nil)).Elem()
}

func (o ColumnLayoutPtrOutput) ToColumnLayoutPtrOutput() ColumnLayoutPtrOutput {
	return o
}

func (o ColumnLayoutPtrOutput) ToColumnLayoutPtrOutputWithContext(ctx context.Context) ColumnLayoutPtrOutput {
	return o
}

func (o ColumnLayoutPtrOutput) Elem() ColumnLayoutOutput {
	return o.ApplyT(func(v *ColumnLayout) ColumnLayout {
		if v != nil {
			return *v
		}
		var ret ColumnLayout
		return ret
	}).(ColumnLayoutOutput)
}

// The columns of content to display.
func (o ColumnLayoutPtrOutput) Columns() ColumnArrayOutput {
	return o.ApplyT(func(v *ColumnLayout) []Column {
		if v == nil {
			return nil
		}
		return v.Columns
	}).(ColumnArrayOutput)
}

// A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column.
type ColumnLayoutResponse struct {
	// The columns of content to display.
	Columns []ColumnResponse `pulumi:"columns"`
}

// A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column.
type ColumnLayoutResponseOutput struct{ *pulumi.OutputState }

func (ColumnLayoutResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ColumnLayoutResponse)(nil)).Elem()
}

func (o ColumnLayoutResponseOutput) ToColumnLayoutResponseOutput() ColumnLayoutResponseOutput {
	return o
}

func (o ColumnLayoutResponseOutput) ToColumnLayoutResponseOutputWithContext(ctx context.Context) ColumnLayoutResponseOutput {
	return o
}

// The columns of content to display.
func (o ColumnLayoutResponseOutput) Columns() ColumnResponseArrayOutput {
	return o.ApplyT(func(v ColumnLayoutResponse) []ColumnResponse { return v.Columns }).(ColumnResponseArrayOutput)
}

// Defines the layout properties and content for a column.
type ColumnResponse struct {
	// The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
	Weight string `pulumi:"weight"`
	// The display widgets arranged vertically in this column.
	Widgets []WidgetResponse `pulumi:"widgets"`
}

// Defines the layout properties and content for a column.
type ColumnResponseOutput struct{ *pulumi.OutputState }

func (ColumnResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ColumnResponse)(nil)).Elem()
}

func (o ColumnResponseOutput) ToColumnResponseOutput() ColumnResponseOutput {
	return o
}

func (o ColumnResponseOutput) ToColumnResponseOutputWithContext(ctx context.Context) ColumnResponseOutput {
	return o
}

// The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
func (o ColumnResponseOutput) Weight() pulumi.StringOutput {
	return o.ApplyT(func(v ColumnResponse) string { return v.Weight }).(pulumi.StringOutput)
}

// The display widgets arranged vertically in this column.
func (o ColumnResponseOutput) Widgets() WidgetResponseArrayOutput {
	return o.ApplyT(func(v ColumnResponse) []WidgetResponse { return v.Widgets }).(WidgetResponseArrayOutput)
}

type ColumnResponseArrayOutput struct{ *pulumi.OutputState }

func (ColumnResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ColumnResponse)(nil)).Elem()
}

func (o ColumnResponseArrayOutput) ToColumnResponseArrayOutput() ColumnResponseArrayOutput {
	return o
}

func (o ColumnResponseArrayOutput) ToColumnResponseArrayOutputWithContext(ctx context.Context) ColumnResponseArrayOutput {
	return o
}

func (o ColumnResponseArrayOutput) Index(i pulumi.IntInput) ColumnResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ColumnResponse {
		return vs[0].([]ColumnResponse)[vs[1].(int)]
	}).(ColumnResponseOutput)
}

// The persistent settings for a table's columns.
type ColumnSettings struct {
	// The id of the column.
	Column string `pulumi:"column"`
	// Whether the column should be visible on page load.
	Visible bool `pulumi:"visible"`
}

// ColumnSettingsInput is an input type that accepts ColumnSettingsArgs and ColumnSettingsOutput values.
// You can construct a concrete instance of `ColumnSettingsInput` via:
//
//	ColumnSettingsArgs{...}
type ColumnSettingsInput interface {
	pulumi.Input

	ToColumnSettingsOutput() ColumnSettingsOutput
	ToColumnSettingsOutputWithContext(context.Context) ColumnSettingsOutput
}

// The persistent settings for a table's columns.
type ColumnSettingsArgs struct {
	// The id of the column.
	Column pulumi.StringInput `pulumi:"column"`
	// Whether the column should be visible on page load.
	Visible pulumi.BoolInput `pulumi:"visible"`
}

func (ColumnSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ColumnSettings)(nil)).Elem()
}

func (i ColumnSettingsArgs) ToColumnSettingsOutput() ColumnSettingsOutput {
	return i.ToColumnSettingsOutputWithContext(context.Background())
}

func (i ColumnSettingsArgs) ToColumnSettingsOutputWithContext(ctx context.Context) ColumnSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ColumnSettingsOutput)
}

// ColumnSettingsArrayInput is an input type that accepts ColumnSettingsArray and ColumnSettingsArrayOutput values.
// You can construct a concrete instance of `ColumnSettingsArrayInput` via:
//
//	ColumnSettingsArray{ ColumnSettingsArgs{...} }
type ColumnSettingsArrayInput interface {
	pulumi.Input

	ToColumnSettingsArrayOutput() ColumnSettingsArrayOutput
	ToColumnSettingsArrayOutputWithContext(context.Context) ColumnSettingsArrayOutput
}

type ColumnSettingsArray []ColumnSettingsInput

func (ColumnSettingsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ColumnSettings)(nil)).Elem()
}

func (i ColumnSettingsArray) ToColumnSettingsArrayOutput() ColumnSettingsArrayOutput {
	return i.ToColumnSettingsArrayOutputWithContext(context.Background())
}

func (i ColumnSettingsArray) ToColumnSettingsArrayOutputWithContext(ctx context.Context) ColumnSettingsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ColumnSettingsArrayOutput)
}

// The persistent settings for a table's columns.
type ColumnSettingsOutput struct{ *pulumi.OutputState }

func (ColumnSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ColumnSettings)(nil)).Elem()
}

func (o ColumnSettingsOutput) ToColumnSettingsOutput() ColumnSettingsOutput {
	return o
}

func (o ColumnSettingsOutput) ToColumnSettingsOutputWithContext(ctx context.Context) ColumnSettingsOutput {
	return o
}

// The id of the column.
func (o ColumnSettingsOutput) Column() pulumi.StringOutput {
	return o.ApplyT(func(v ColumnSettings) string { return v.Column }).(pulumi.StringOutput)
}

// Whether the column should be visible on page load.
func (o ColumnSettingsOutput) Visible() pulumi.BoolOutput {
	return o.ApplyT(func(v ColumnSettings) bool { return v.Visible }).(pulumi.BoolOutput)
}

type ColumnSettingsArrayOutput struct{ *pulumi.OutputState }

func (ColumnSettingsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ColumnSettings)(nil)).Elem()
}

func (o ColumnSettingsArrayOutput) ToColumnSettingsArrayOutput() ColumnSettingsArrayOutput {
	return o
}

func (o ColumnSettingsArrayOutput) ToColumnSettingsArrayOutputWithContext(ctx context.Context) ColumnSettingsArrayOutput {
	return o
}

func (o ColumnSettingsArrayOutput) Index(i pulumi.IntInput) ColumnSettingsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ColumnSettings {
		return vs[0].([]ColumnSettings)[vs[1].(int)]
	}).(ColumnSettingsOutput)
}

// The persistent settings for a table's columns.
type ColumnSettingsResponse struct {
	// The id of the column.
	Column string `pulumi:"column"`
	// Whether the column should be visible on page load.
	Visible bool `pulumi:"visible"`
}

// The persistent settings for a table's columns.
type ColumnSettingsResponseOutput struct{ *pulumi.OutputState }

func (ColumnSettingsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ColumnSettingsResponse)(nil)).Elem()
}

func (o ColumnSettingsResponseOutput) ToColumnSettingsResponseOutput() ColumnSettingsResponseOutput {
	return o
}

func (o ColumnSettingsResponseOutput) ToColumnSettingsResponseOutputWithContext(ctx context.Context) ColumnSettingsResponseOutput {
	return o
}

// The id of the column.
func (o ColumnSettingsResponseOutput) Column() pulumi.StringOutput {
	return o.ApplyT(func(v ColumnSettingsResponse) string { return v.Column }).(pulumi.StringOutput)
}

// Whether the column should be visible on page load.
func (o ColumnSettingsResponseOutput) Visible() pulumi.BoolOutput {
	return o.ApplyT(func(v ColumnSettingsResponse) bool { return v.Visible }).(pulumi.BoolOutput)
}

type ColumnSettingsResponseArrayOutput struct{ *pulumi.OutputState }

func (ColumnSettingsResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ColumnSettingsResponse)(nil)).Elem()
}

func (o ColumnSettingsResponseArrayOutput) ToColumnSettingsResponseArrayOutput() ColumnSettingsResponseArrayOutput {
	return o
}

func (o ColumnSettingsResponseArrayOutput) ToColumnSettingsResponseArrayOutputWithContext(ctx context.Context) ColumnSettingsResponseArrayOutput {
	return o
}

func (o ColumnSettingsResponseArrayOutput) Index(i pulumi.IntInput) ColumnSettingsResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ColumnSettingsResponse {
		return vs[0].([]ColumnSettingsResponse)[vs[1].(int)]
	}).(ColumnSettingsResponseOutput)
}

// A filter to reduce the amount of data charted in relevant widgets.
type DashboardFilter struct {
	// The specified filter type
	FilterType *DashboardFilterFilterType `pulumi:"filterType"`
	// The key for the label
	LabelKey string `pulumi:"labelKey"`
	// A variable-length string value.
	StringValue *string `pulumi:"stringValue"`
	// The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
	TemplateVariable *string `pulumi:"templateVariable"`
}

// DashboardFilterInput is an input type that accepts DashboardFilterArgs and DashboardFilterOutput values.
// You can construct a concrete instance of `DashboardFilterInput` via:
//
//	DashboardFilterArgs{...}
type DashboardFilterInput interface {
	pulumi.Input

	ToDashboardFilterOutput() DashboardFilterOutput
	ToDashboardFilterOutputWithContext(context.Context) DashboardFilterOutput
}

// A filter to reduce the amount of data charted in relevant widgets.
type DashboardFilterArgs struct {
	// The specified filter type
	FilterType DashboardFilterFilterTypePtrInput `pulumi:"filterType"`
	// The key for the label
	LabelKey pulumi.StringInput `pulumi:"labelKey"`
	// A variable-length string value.
	StringValue pulumi.StringPtrInput `pulumi:"stringValue"`
	// The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
	TemplateVariable pulumi.StringPtrInput `pulumi:"templateVariable"`
}

func (DashboardFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DashboardFilter)(nil)).Elem()
}

func (i DashboardFilterArgs) ToDashboardFilterOutput() DashboardFilterOutput {
	return i.ToDashboardFilterOutputWithContext(context.Background())
}

func (i DashboardFilterArgs) ToDashboardFilterOutputWithContext(ctx context.Context) DashboardFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DashboardFilterOutput)
}

// DashboardFilterArrayInput is an input type that accepts DashboardFilterArray and DashboardFilterArrayOutput values.
// You can construct a concrete instance of `DashboardFilterArrayInput` via:
//
//	DashboardFilterArray{ DashboardFilterArgs{...} }
type DashboardFilterArrayInput interface {
	pulumi.Input

	ToDashboardFilterArrayOutput() DashboardFilterArrayOutput
	ToDashboardFilterArrayOutputWithContext(context.Context) DashboardFilterArrayOutput
}

type DashboardFilterArray []DashboardFilterInput

func (DashboardFilterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DashboardFilter)(nil)).Elem()
}

func (i DashboardFilterArray) ToDashboardFilterArrayOutput() DashboardFilterArrayOutput {
	return i.ToDashboardFilterArrayOutputWithContext(context.Background())
}

func (i DashboardFilterArray) ToDashboardFilterArrayOutputWithContext(ctx context.Context) DashboardFilterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DashboardFilterArrayOutput)
}

// A filter to reduce the amount of data charted in relevant widgets.
type DashboardFilterOutput struct{ *pulumi.OutputState }

func (DashboardFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DashboardFilter)(nil)).Elem()
}

func (o DashboardFilterOutput) ToDashboardFilterOutput() DashboardFilterOutput {
	return o
}

func (o DashboardFilterOutput) ToDashboardFilterOutputWithContext(ctx context.Context) DashboardFilterOutput {
	return o
}

// The specified filter type
func (o DashboardFilterOutput) FilterType() DashboardFilterFilterTypePtrOutput {
	return o.ApplyT(func(v DashboardFilter) *DashboardFilterFilterType { return v.FilterType }).(DashboardFilterFilterTypePtrOutput)
}

// The key for the label
func (o DashboardFilterOutput) LabelKey() pulumi.StringOutput {
	return o.ApplyT(func(v DashboardFilter) string { return v.LabelKey }).(pulumi.StringOutput)
}

// A variable-length string value.
func (o DashboardFilterOutput) StringValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DashboardFilter) *string { return v.StringValue }).(pulumi.StringPtrOutput)
}

// The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
func (o DashboardFilterOutput) TemplateVariable() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DashboardFilter) *string { return v.TemplateVariable }).(pulumi.StringPtrOutput)
}

type DashboardFilterArrayOutput struct{ *pulumi.OutputState }

func (DashboardFilterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DashboardFilter)(nil)).Elem()
}

func (o DashboardFilterArrayOutput) ToDashboardFilterArrayOutput() DashboardFilterArrayOutput {
	return o
}

func (o DashboardFilterArrayOutput) ToDashboardFilterArrayOutputWithContext(ctx context.Context) DashboardFilterArrayOutput {
	return o
}

func (o DashboardFilterArrayOutput) Index(i pulumi.IntInput) DashboardFilterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DashboardFilter {
		return vs[0].([]DashboardFilter)[vs[1].(int)]
	}).(DashboardFilterOutput)
}

// A filter to reduce the amount of data charted in relevant widgets.
type DashboardFilterResponse struct {
	// The specified filter type
	FilterType string `pulumi:"filterType"`
	// The key for the label
	LabelKey string `pulumi:"labelKey"`
	// A variable-length string value.
	StringValue string `pulumi:"stringValue"`
	// The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
	TemplateVariable string `pulumi:"templateVariable"`
}

// A filter to reduce the amount of data charted in relevant widgets.
type DashboardFilterResponseOutput struct{ *pulumi.OutputState }

func (DashboardFilterResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DashboardFilterResponse)(nil)).Elem()
}

func (o DashboardFilterResponseOutput) ToDashboardFilterResponseOutput() DashboardFilterResponseOutput {
	return o
}

func (o DashboardFilterResponseOutput) ToDashboardFilterResponseOutputWithContext(ctx context.Context) DashboardFilterResponseOutput {
	return o
}

// The specified filter type
func (o DashboardFilterResponseOutput) FilterType() pulumi.StringOutput {
	return o.ApplyT(func(v DashboardFilterResponse) string { return v.FilterType }).(pulumi.StringOutput)
}

// The key for the label
func (o DashboardFilterResponseOutput) LabelKey() pulumi.StringOutput {
	return o.ApplyT(func(v DashboardFilterResponse) string { return v.LabelKey }).(pulumi.StringOutput)
}

// A variable-length string value.
func (o DashboardFilterResponseOutput) StringValue() pulumi.StringOutput {
	return o.ApplyT(func(v DashboardFilterResponse) string { return v.StringValue }).(pulumi.StringOutput)
}

// The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
func (o DashboardFilterResponseOutput) TemplateVariable() pulumi.StringOutput {
	return o.ApplyT(func(v DashboardFilterResponse) string { return v.TemplateVariable }).(pulumi.StringOutput)
}

type DashboardFilterResponseArrayOutput struct{ *pulumi.OutputState }

func (DashboardFilterResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DashboardFilterResponse)(nil)).Elem()
}

func (o DashboardFilterResponseArrayOutput) ToDashboardFilterResponseArrayOutput() DashboardFilterResponseArrayOutput {
	return o
}

func (o DashboardFilterResponseArrayOutput) ToDashboardFilterResponseArrayOutputWithContext(ctx context.Context) DashboardFilterResponseArrayOutput {
	return o
}

func (o DashboardFilterResponseArrayOutput) Index(i pulumi.IntInput) DashboardFilterResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DashboardFilterResponse {
		return vs[0].([]DashboardFilterResponse)[vs[1].(int)]
	}).(DashboardFilterResponseOutput)
}

// Groups a time series query definition with charting options.
type DataSet struct {
	// A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value.
	LegendTemplate *string `pulumi:"legendTemplate"`
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod *string `pulumi:"minAlignmentPeriod"`
	// How this data should be plotted on the chart.
	PlotType *DataSetPlotType `pulumi:"plotType"`
	// Optional. The target axis to use for plotting the metric.
	TargetAxis *DataSetTargetAxis `pulumi:"targetAxis"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQuery `pulumi:"timeSeriesQuery"`
}

// DataSetInput is an input type that accepts DataSetArgs and DataSetOutput values.
// You can construct a concrete instance of `DataSetInput` via:
//
//	DataSetArgs{...}
type DataSetInput interface {
	pulumi.Input

	ToDataSetOutput() DataSetOutput
	ToDataSetOutputWithContext(context.Context) DataSetOutput
}

// Groups a time series query definition with charting options.
type DataSetArgs struct {
	// A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value.
	LegendTemplate pulumi.StringPtrInput `pulumi:"legendTemplate"`
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod pulumi.StringPtrInput `pulumi:"minAlignmentPeriod"`
	// How this data should be plotted on the chart.
	PlotType DataSetPlotTypePtrInput `pulumi:"plotType"`
	// Optional. The target axis to use for plotting the metric.
	TargetAxis DataSetTargetAxisPtrInput `pulumi:"targetAxis"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQueryInput `pulumi:"timeSeriesQuery"`
}

func (DataSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DataSet)(nil)).Elem()
}

func (i DataSetArgs) ToDataSetOutput() DataSetOutput {
	return i.ToDataSetOutputWithContext(context.Background())
}

func (i DataSetArgs) ToDataSetOutputWithContext(ctx context.Context) DataSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataSetOutput)
}

// DataSetArrayInput is an input type that accepts DataSetArray and DataSetArrayOutput values.
// You can construct a concrete instance of `DataSetArrayInput` via:
//
//	DataSetArray{ DataSetArgs{...} }
type DataSetArrayInput interface {
	pulumi.Input

	ToDataSetArrayOutput() DataSetArrayOutput
	ToDataSetArrayOutputWithContext(context.Context) DataSetArrayOutput
}

type DataSetArray []DataSetInput

func (DataSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DataSet)(nil)).Elem()
}

func (i DataSetArray) ToDataSetArrayOutput() DataSetArrayOutput {
	return i.ToDataSetArrayOutputWithContext(context.Background())
}

func (i DataSetArray) ToDataSetArrayOutputWithContext(ctx context.Context) DataSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataSetArrayOutput)
}

// Groups a time series query definition with charting options.
type DataSetOutput struct{ *pulumi.OutputState }

func (DataSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DataSet)(nil)).Elem()
}

func (o DataSetOutput) ToDataSetOutput() DataSetOutput {
	return o
}

func (o DataSetOutput) ToDataSetOutputWithContext(ctx context.Context) DataSetOutput {
	return o
}

// A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value.
func (o DataSetOutput) LegendTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DataSet) *string { return v.LegendTemplate }).(pulumi.StringPtrOutput)
}

// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
func (o DataSetOutput) MinAlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DataSet) *string { return v.MinAlignmentPeriod }).(pulumi.StringPtrOutput)
}

// How this data should be plotted on the chart.
func (o DataSetOutput) PlotType() DataSetPlotTypePtrOutput {
	return o.ApplyT(func(v DataSet) *DataSetPlotType { return v.PlotType }).(DataSetPlotTypePtrOutput)
}

// Optional. The target axis to use for plotting the metric.
func (o DataSetOutput) TargetAxis() DataSetTargetAxisPtrOutput {
	return o.ApplyT(func(v DataSet) *DataSetTargetAxis { return v.TargetAxis }).(DataSetTargetAxisPtrOutput)
}

// Fields for querying time series data from the Stackdriver metrics API.
func (o DataSetOutput) TimeSeriesQuery() TimeSeriesQueryOutput {
	return o.ApplyT(func(v DataSet) TimeSeriesQuery { return v.TimeSeriesQuery }).(TimeSeriesQueryOutput)
}

type DataSetArrayOutput struct{ *pulumi.OutputState }

func (DataSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DataSet)(nil)).Elem()
}

func (o DataSetArrayOutput) ToDataSetArrayOutput() DataSetArrayOutput {
	return o
}

func (o DataSetArrayOutput) ToDataSetArrayOutputWithContext(ctx context.Context) DataSetArrayOutput {
	return o
}

func (o DataSetArrayOutput) Index(i pulumi.IntInput) DataSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DataSet {
		return vs[0].([]DataSet)[vs[1].(int)]
	}).(DataSetOutput)
}

// Groups a time series query definition with charting options.
type DataSetResponse struct {
	// A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value.
	LegendTemplate string `pulumi:"legendTemplate"`
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod string `pulumi:"minAlignmentPeriod"`
	// How this data should be plotted on the chart.
	PlotType string `pulumi:"plotType"`
	// Optional. The target axis to use for plotting the metric.
	TargetAxis string `pulumi:"targetAxis"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQueryResponse `pulumi:"timeSeriesQuery"`
}

// Groups a time series query definition with charting options.
type DataSetResponseOutput struct{ *pulumi.OutputState }

func (DataSetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DataSetResponse)(nil)).Elem()
}

func (o DataSetResponseOutput) ToDataSetResponseOutput() DataSetResponseOutput {
	return o
}

func (o DataSetResponseOutput) ToDataSetResponseOutputWithContext(ctx context.Context) DataSetResponseOutput {
	return o
}

// A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value.
func (o DataSetResponseOutput) LegendTemplate() pulumi.StringOutput {
	return o.ApplyT(func(v DataSetResponse) string { return v.LegendTemplate }).(pulumi.StringOutput)
}

// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
func (o DataSetResponseOutput) MinAlignmentPeriod() pulumi.StringOutput {
	return o.ApplyT(func(v DataSetResponse) string { return v.MinAlignmentPeriod }).(pulumi.StringOutput)
}

// How this data should be plotted on the chart.
func (o DataSetResponseOutput) PlotType() pulumi.StringOutput {
	return o.ApplyT(func(v DataSetResponse) string { return v.PlotType }).(pulumi.StringOutput)
}

// Optional. The target axis to use for plotting the metric.
func (o DataSetResponseOutput) TargetAxis() pulumi.StringOutput {
	return o.ApplyT(func(v DataSetResponse) string { return v.TargetAxis }).(pulumi.StringOutput)
}

// Fields for querying time series data from the Stackdriver metrics API.
func (o DataSetResponseOutput) TimeSeriesQuery() TimeSeriesQueryResponseOutput {
	return o.ApplyT(func(v DataSetResponse) TimeSeriesQueryResponse { return v.TimeSeriesQuery }).(TimeSeriesQueryResponseOutput)
}

type DataSetResponseArrayOutput struct{ *pulumi.OutputState }

func (DataSetResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DataSetResponse)(nil)).Elem()
}

func (o DataSetResponseArrayOutput) ToDataSetResponseArrayOutput() DataSetResponseArrayOutput {
	return o
}

func (o DataSetResponseArrayOutput) ToDataSetResponseArrayOutputWithContext(ctx context.Context) DataSetResponseArrayOutput {
	return o
}

func (o DataSetResponseArrayOutput) Index(i pulumi.IntInput) DataSetResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DataSetResponse {
		return vs[0].([]DataSetResponse)[vs[1].(int)]
	}).(DataSetResponseOutput)
}

// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
type Empty struct {
}

// EmptyInput is an input type that accepts EmptyArgs and EmptyOutput values.
// You can construct a concrete instance of `EmptyInput` via:
//
//	EmptyArgs{...}
type EmptyInput interface {
	pulumi.Input

	ToEmptyOutput() EmptyOutput
	ToEmptyOutputWithContext(context.Context) EmptyOutput
}

// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
type EmptyArgs struct {
}

func (EmptyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Empty)(nil)).Elem()
}

func (i EmptyArgs) ToEmptyOutput() EmptyOutput {
	return i.ToEmptyOutputWithContext(context.Background())
}

func (i EmptyArgs) ToEmptyOutputWithContext(ctx context.Context) EmptyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EmptyOutput)
}

func (i EmptyArgs) ToEmptyPtrOutput() EmptyPtrOutput {
	return i.ToEmptyPtrOutputWithContext(context.Background())
}

func (i EmptyArgs) ToEmptyPtrOutputWithContext(ctx context.Context) EmptyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EmptyOutput).ToEmptyPtrOutputWithContext(ctx)
}

// EmptyPtrInput is an input type that accepts EmptyArgs, EmptyPtr and EmptyPtrOutput values.
// You can construct a concrete instance of `EmptyPtrInput` via:
//
//	        EmptyArgs{...}
//
//	or:
//
//	        nil
type EmptyPtrInput interface {
	pulumi.Input

	ToEmptyPtrOutput() EmptyPtrOutput
	ToEmptyPtrOutputWithContext(context.Context) EmptyPtrOutput
}

type emptyPtrType EmptyArgs

func EmptyPtr(v *EmptyArgs) EmptyPtrInput {
	return (*emptyPtrType)(v)
}

func (*emptyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Empty)(nil)).Elem()
}

func (i *emptyPtrType) ToEmptyPtrOutput() EmptyPtrOutput {
	return i.ToEmptyPtrOutputWithContext(context.Background())
}

func (i *emptyPtrType) ToEmptyPtrOutputWithContext(ctx context.Context) EmptyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EmptyPtrOutput)
}

// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
type EmptyOutput struct{ *pulumi.OutputState }

func (EmptyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Empty)(nil)).Elem()
}

func (o EmptyOutput) ToEmptyOutput() EmptyOutput {
	return o
}

func (o EmptyOutput) ToEmptyOutputWithContext(ctx context.Context) EmptyOutput {
	return o
}

func (o EmptyOutput) ToEmptyPtrOutput() EmptyPtrOutput {
	return o.ToEmptyPtrOutputWithContext(context.Background())
}

func (o EmptyOutput) ToEmptyPtrOutputWithContext(ctx context.Context) EmptyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Empty) *Empty {
		return &v
	}).(EmptyPtrOutput)
}

type EmptyPtrOutput struct{ *pulumi.OutputState }

func (EmptyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Empty)(nil)).Elem()
}

func (o EmptyPtrOutput) ToEmptyPtrOutput() EmptyPtrOutput {
	return o
}

func (o EmptyPtrOutput) ToEmptyPtrOutputWithContext(ctx context.Context) EmptyPtrOutput {
	return o
}

func (o EmptyPtrOutput) Elem() EmptyOutput {
	return o.ApplyT(func(v *Empty) Empty {
		if v != nil {
			return *v
		}
		var ret Empty
		return ret
	}).(EmptyOutput)
}

// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
type EmptyResponse struct {
}

// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
type EmptyResponseOutput struct{ *pulumi.OutputState }

func (EmptyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EmptyResponse)(nil)).Elem()
}

func (o EmptyResponseOutput) ToEmptyResponseOutput() EmptyResponseOutput {
	return o
}

func (o EmptyResponseOutput) ToEmptyResponseOutputWithContext(ctx context.Context) EmptyResponseOutput {
	return o
}

// A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard's query (inclusive).
type GaugeView struct {
	// The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
	LowerBound *float64 `pulumi:"lowerBound"`
	// The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
	UpperBound *float64 `pulumi:"upperBound"`
}

// GaugeViewInput is an input type that accepts GaugeViewArgs and GaugeViewOutput values.
// You can construct a concrete instance of `GaugeViewInput` via:
//
//	GaugeViewArgs{...}
type GaugeViewInput interface {
	pulumi.Input

	ToGaugeViewOutput() GaugeViewOutput
	ToGaugeViewOutputWithContext(context.Context) GaugeViewOutput
}

// A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard's query (inclusive).
type GaugeViewArgs struct {
	// The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
	LowerBound pulumi.Float64PtrInput `pulumi:"lowerBound"`
	// The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
	UpperBound pulumi.Float64PtrInput `pulumi:"upperBound"`
}

func (GaugeViewArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GaugeView)(nil)).Elem()
}

func (i GaugeViewArgs) ToGaugeViewOutput() GaugeViewOutput {
	return i.ToGaugeViewOutputWithContext(context.Background())
}

func (i GaugeViewArgs) ToGaugeViewOutputWithContext(ctx context.Context) GaugeViewOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GaugeViewOutput)
}

func (i GaugeViewArgs) ToGaugeViewPtrOutput() GaugeViewPtrOutput {
	return i.ToGaugeViewPtrOutputWithContext(context.Background())
}

func (i GaugeViewArgs) ToGaugeViewPtrOutputWithContext(ctx context.Context) GaugeViewPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GaugeViewOutput).ToGaugeViewPtrOutputWithContext(ctx)
}

// GaugeViewPtrInput is an input type that accepts GaugeViewArgs, GaugeViewPtr and GaugeViewPtrOutput values.
// You can construct a concrete instance of `GaugeViewPtrInput` via:
//
//	        GaugeViewArgs{...}
//
//	or:
//
//	        nil
type GaugeViewPtrInput interface {
	pulumi.Input

	ToGaugeViewPtrOutput() GaugeViewPtrOutput
	ToGaugeViewPtrOutputWithContext(context.Context) GaugeViewPtrOutput
}

type gaugeViewPtrType GaugeViewArgs

func GaugeViewPtr(v *GaugeViewArgs) GaugeViewPtrInput {
	return (*gaugeViewPtrType)(v)
}

func (*gaugeViewPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GaugeView)(nil)).Elem()
}

func (i *gaugeViewPtrType) ToGaugeViewPtrOutput() GaugeViewPtrOutput {
	return i.ToGaugeViewPtrOutputWithContext(context.Background())
}

func (i *gaugeViewPtrType) ToGaugeViewPtrOutputWithContext(ctx context.Context) GaugeViewPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GaugeViewPtrOutput)
}

// A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard's query (inclusive).
type GaugeViewOutput struct{ *pulumi.OutputState }

func (GaugeViewOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GaugeView)(nil)).Elem()
}

func (o GaugeViewOutput) ToGaugeViewOutput() GaugeViewOutput {
	return o
}

func (o GaugeViewOutput) ToGaugeViewOutputWithContext(ctx context.Context) GaugeViewOutput {
	return o
}

func (o GaugeViewOutput) ToGaugeViewPtrOutput() GaugeViewPtrOutput {
	return o.ToGaugeViewPtrOutputWithContext(context.Background())
}

func (o GaugeViewOutput) ToGaugeViewPtrOutputWithContext(ctx context.Context) GaugeViewPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GaugeView) *GaugeView {
		return &v
	}).(GaugeViewPtrOutput)
}

// The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
func (o GaugeViewOutput) LowerBound() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v GaugeView) *float64 { return v.LowerBound }).(pulumi.Float64PtrOutput)
}

// The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
func (o GaugeViewOutput) UpperBound() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v GaugeView) *float64 { return v.UpperBound }).(pulumi.Float64PtrOutput)
}

type GaugeViewPtrOutput struct{ *pulumi.OutputState }

func (GaugeViewPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GaugeView)(nil)).Elem()
}

func (o GaugeViewPtrOutput) ToGaugeViewPtrOutput() GaugeViewPtrOutput {
	return o
}

func (o GaugeViewPtrOutput) ToGaugeViewPtrOutputWithContext(ctx context.Context) GaugeViewPtrOutput {
	return o
}

func (o GaugeViewPtrOutput) Elem() GaugeViewOutput {
	return o.ApplyT(func(v *GaugeView) GaugeView {
		if v != nil {
			return *v
		}
		var ret GaugeView
		return ret
	}).(GaugeViewOutput)
}

// The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
func (o GaugeViewPtrOutput) LowerBound() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GaugeView) *float64 {
		if v == nil {
			return nil
		}
		return v.LowerBound
	}).(pulumi.Float64PtrOutput)
}

// The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
func (o GaugeViewPtrOutput) UpperBound() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GaugeView) *float64 {
		if v == nil {
			return nil
		}
		return v.UpperBound
	}).(pulumi.Float64PtrOutput)
}

// A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard's query (inclusive).
type GaugeViewResponse struct {
	// The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
	LowerBound float64 `pulumi:"lowerBound"`
	// The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
	UpperBound float64 `pulumi:"upperBound"`
}

// A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard's query (inclusive).
type GaugeViewResponseOutput struct{ *pulumi.OutputState }

func (GaugeViewResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GaugeViewResponse)(nil)).Elem()
}

func (o GaugeViewResponseOutput) ToGaugeViewResponseOutput() GaugeViewResponseOutput {
	return o
}

func (o GaugeViewResponseOutput) ToGaugeViewResponseOutputWithContext(ctx context.Context) GaugeViewResponseOutput {
	return o
}

// The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
func (o GaugeViewResponseOutput) LowerBound() pulumi.Float64Output {
	return o.ApplyT(func(v GaugeViewResponse) float64 { return v.LowerBound }).(pulumi.Float64Output)
}

// The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
func (o GaugeViewResponseOutput) UpperBound() pulumi.Float64Output {
	return o.ApplyT(func(v GaugeViewResponse) float64 { return v.UpperBound }).(pulumi.Float64Output)
}

// A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy.
type GridLayout struct {
	// The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
	Columns *string `pulumi:"columns"`
	// The informational elements that are arranged into the columns row-first.
	Widgets []Widget `pulumi:"widgets"`
}

// GridLayoutInput is an input type that accepts GridLayoutArgs and GridLayoutOutput values.
// You can construct a concrete instance of `GridLayoutInput` via:
//
//	GridLayoutArgs{...}
type GridLayoutInput interface {
	pulumi.Input

	ToGridLayoutOutput() GridLayoutOutput
	ToGridLayoutOutputWithContext(context.Context) GridLayoutOutput
}

// A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy.
type GridLayoutArgs struct {
	// The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
	Columns pulumi.StringPtrInput `pulumi:"columns"`
	// The informational elements that are arranged into the columns row-first.
	Widgets WidgetArrayInput `pulumi:"widgets"`
}

func (GridLayoutArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GridLayout)(nil)).Elem()
}

func (i GridLayoutArgs) ToGridLayoutOutput() GridLayoutOutput {
	return i.ToGridLayoutOutputWithContext(context.Background())
}

func (i GridLayoutArgs) ToGridLayoutOutputWithContext(ctx context.Context) GridLayoutOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GridLayoutOutput)
}

func (i GridLayoutArgs) ToGridLayoutPtrOutput() GridLayoutPtrOutput {
	return i.ToGridLayoutPtrOutputWithContext(context.Background())
}

func (i GridLayoutArgs) ToGridLayoutPtrOutputWithContext(ctx context.Context) GridLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GridLayoutOutput).ToGridLayoutPtrOutputWithContext(ctx)
}

// GridLayoutPtrInput is an input type that accepts GridLayoutArgs, GridLayoutPtr and GridLayoutPtrOutput values.
// You can construct a concrete instance of `GridLayoutPtrInput` via:
//
//	        GridLayoutArgs{...}
//
//	or:
//
//	        nil
type GridLayoutPtrInput interface {
	pulumi.Input

	ToGridLayoutPtrOutput() GridLayoutPtrOutput
	ToGridLayoutPtrOutputWithContext(context.Context) GridLayoutPtrOutput
}

type gridLayoutPtrType GridLayoutArgs

func GridLayoutPtr(v *GridLayoutArgs) GridLayoutPtrInput {
	return (*gridLayoutPtrType)(v)
}

func (*gridLayoutPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GridLayout)(nil)).Elem()
}

func (i *gridLayoutPtrType) ToGridLayoutPtrOutput() GridLayoutPtrOutput {
	return i.ToGridLayoutPtrOutputWithContext(context.Background())
}

func (i *gridLayoutPtrType) ToGridLayoutPtrOutputWithContext(ctx context.Context) GridLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GridLayoutPtrOutput)
}

// A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy.
type GridLayoutOutput struct{ *pulumi.OutputState }

func (GridLayoutOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GridLayout)(nil)).Elem()
}

func (o GridLayoutOutput) ToGridLayoutOutput() GridLayoutOutput {
	return o
}

func (o GridLayoutOutput) ToGridLayoutOutputWithContext(ctx context.Context) GridLayoutOutput {
	return o
}

func (o GridLayoutOutput) ToGridLayoutPtrOutput() GridLayoutPtrOutput {
	return o.ToGridLayoutPtrOutputWithContext(context.Background())
}

func (o GridLayoutOutput) ToGridLayoutPtrOutputWithContext(ctx context.Context) GridLayoutPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GridLayout) *GridLayout {
		return &v
	}).(GridLayoutPtrOutput)
}

// The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
func (o GridLayoutOutput) Columns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GridLayout) *string { return v.Columns }).(pulumi.StringPtrOutput)
}

// The informational elements that are arranged into the columns row-first.
func (o GridLayoutOutput) Widgets() WidgetArrayOutput {
	return o.ApplyT(func(v GridLayout) []Widget { return v.Widgets }).(WidgetArrayOutput)
}

type GridLayoutPtrOutput struct{ *pulumi.OutputState }

func (GridLayoutPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GridLayout)(nil)).Elem()
}

func (o GridLayoutPtrOutput) ToGridLayoutPtrOutput() GridLayoutPtrOutput {
	return o
}

func (o GridLayoutPtrOutput) ToGridLayoutPtrOutputWithContext(ctx context.Context) GridLayoutPtrOutput {
	return o
}

func (o GridLayoutPtrOutput) Elem() GridLayoutOutput {
	return o.ApplyT(func(v *GridLayout) GridLayout {
		if v != nil {
			return *v
		}
		var ret GridLayout
		return ret
	}).(GridLayoutOutput)
}

// The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
func (o GridLayoutPtrOutput) Columns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GridLayout) *string {
		if v == nil {
			return nil
		}
		return v.Columns
	}).(pulumi.StringPtrOutput)
}

// The informational elements that are arranged into the columns row-first.
func (o GridLayoutPtrOutput) Widgets() WidgetArrayOutput {
	return o.ApplyT(func(v *GridLayout) []Widget {
		if v == nil {
			return nil
		}
		return v.Widgets
	}).(WidgetArrayOutput)
}

// A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy.
type GridLayoutResponse struct {
	// The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
	Columns string `pulumi:"columns"`
	// The informational elements that are arranged into the columns row-first.
	Widgets []WidgetResponse `pulumi:"widgets"`
}

// A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy.
type GridLayoutResponseOutput struct{ *pulumi.OutputState }

func (GridLayoutResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GridLayoutResponse)(nil)).Elem()
}

func (o GridLayoutResponseOutput) ToGridLayoutResponseOutput() GridLayoutResponseOutput {
	return o
}

func (o GridLayoutResponseOutput) ToGridLayoutResponseOutputWithContext(ctx context.Context) GridLayoutResponseOutput {
	return o
}

// The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
func (o GridLayoutResponseOutput) Columns() pulumi.StringOutput {
	return o.ApplyT(func(v GridLayoutResponse) string { return v.Columns }).(pulumi.StringOutput)
}

// The informational elements that are arranged into the columns row-first.
func (o GridLayoutResponseOutput) Widgets() WidgetResponseArrayOutput {
	return o.ApplyT(func(v GridLayoutResponse) []WidgetResponse { return v.Widgets }).(WidgetResponseArrayOutput)
}

// A widget that displays a list of incidents
type IncidentList struct {
	// Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
	MonitoredResources []MonitoredResource `pulumi:"monitoredResources"`
	// Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
	PolicyNames []string `pulumi:"policyNames"`
}

// IncidentListInput is an input type that accepts IncidentListArgs and IncidentListOutput values.
// You can construct a concrete instance of `IncidentListInput` via:
//
//	IncidentListArgs{...}
type IncidentListInput interface {
	pulumi.Input

	ToIncidentListOutput() IncidentListOutput
	ToIncidentListOutputWithContext(context.Context) IncidentListOutput
}

// A widget that displays a list of incidents
type IncidentListArgs struct {
	// Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
	MonitoredResources MonitoredResourceArrayInput `pulumi:"monitoredResources"`
	// Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
	PolicyNames pulumi.StringArrayInput `pulumi:"policyNames"`
}

func (IncidentListArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IncidentList)(nil)).Elem()
}

func (i IncidentListArgs) ToIncidentListOutput() IncidentListOutput {
	return i.ToIncidentListOutputWithContext(context.Background())
}

func (i IncidentListArgs) ToIncidentListOutputWithContext(ctx context.Context) IncidentListOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IncidentListOutput)
}

func (i IncidentListArgs) ToIncidentListPtrOutput() IncidentListPtrOutput {
	return i.ToIncidentListPtrOutputWithContext(context.Background())
}

func (i IncidentListArgs) ToIncidentListPtrOutputWithContext(ctx context.Context) IncidentListPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IncidentListOutput).ToIncidentListPtrOutputWithContext(ctx)
}

// IncidentListPtrInput is an input type that accepts IncidentListArgs, IncidentListPtr and IncidentListPtrOutput values.
// You can construct a concrete instance of `IncidentListPtrInput` via:
//
//	        IncidentListArgs{...}
//
//	or:
//
//	        nil
type IncidentListPtrInput interface {
	pulumi.Input

	ToIncidentListPtrOutput() IncidentListPtrOutput
	ToIncidentListPtrOutputWithContext(context.Context) IncidentListPtrOutput
}

type incidentListPtrType IncidentListArgs

func IncidentListPtr(v *IncidentListArgs) IncidentListPtrInput {
	return (*incidentListPtrType)(v)
}

func (*incidentListPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IncidentList)(nil)).Elem()
}

func (i *incidentListPtrType) ToIncidentListPtrOutput() IncidentListPtrOutput {
	return i.ToIncidentListPtrOutputWithContext(context.Background())
}

func (i *incidentListPtrType) ToIncidentListPtrOutputWithContext(ctx context.Context) IncidentListPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IncidentListPtrOutput)
}

// A widget that displays a list of incidents
type IncidentListOutput struct{ *pulumi.OutputState }

func (IncidentListOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IncidentList)(nil)).Elem()
}

func (o IncidentListOutput) ToIncidentListOutput() IncidentListOutput {
	return o
}

func (o IncidentListOutput) ToIncidentListOutputWithContext(ctx context.Context) IncidentListOutput {
	return o
}

func (o IncidentListOutput) ToIncidentListPtrOutput() IncidentListPtrOutput {
	return o.ToIncidentListPtrOutputWithContext(context.Background())
}

func (o IncidentListOutput) ToIncidentListPtrOutputWithContext(ctx context.Context) IncidentListPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IncidentList) *IncidentList {
		return &v
	}).(IncidentListPtrOutput)
}

// Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
func (o IncidentListOutput) MonitoredResources() MonitoredResourceArrayOutput {
	return o.ApplyT(func(v IncidentList) []MonitoredResource { return v.MonitoredResources }).(MonitoredResourceArrayOutput)
}

// Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
func (o IncidentListOutput) PolicyNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IncidentList) []string { return v.PolicyNames }).(pulumi.StringArrayOutput)
}

type IncidentListPtrOutput struct{ *pulumi.OutputState }

func (IncidentListPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IncidentList)(nil)).Elem()
}

func (o IncidentListPtrOutput) ToIncidentListPtrOutput() IncidentListPtrOutput {
	return o
}

func (o IncidentListPtrOutput) ToIncidentListPtrOutputWithContext(ctx context.Context) IncidentListPtrOutput {
	return o
}

func (o IncidentListPtrOutput) Elem() IncidentListOutput {
	return o.ApplyT(func(v *IncidentList) IncidentList {
		if v != nil {
			return *v
		}
		var ret IncidentList
		return ret
	}).(IncidentListOutput)
}

// Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
func (o IncidentListPtrOutput) MonitoredResources() MonitoredResourceArrayOutput {
	return o.ApplyT(func(v *IncidentList) []MonitoredResource {
		if v == nil {
			return nil
		}
		return v.MonitoredResources
	}).(MonitoredResourceArrayOutput)
}

// Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
func (o IncidentListPtrOutput) PolicyNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IncidentList) []string {
		if v == nil {
			return nil
		}
		return v.PolicyNames
	}).(pulumi.StringArrayOutput)
}

// A widget that displays a list of incidents
type IncidentListResponse struct {
	// Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
	MonitoredResources []MonitoredResourceResponse `pulumi:"monitoredResources"`
	// Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
	PolicyNames []string `pulumi:"policyNames"`
}

// A widget that displays a list of incidents
type IncidentListResponseOutput struct{ *pulumi.OutputState }

func (IncidentListResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IncidentListResponse)(nil)).Elem()
}

func (o IncidentListResponseOutput) ToIncidentListResponseOutput() IncidentListResponseOutput {
	return o
}

func (o IncidentListResponseOutput) ToIncidentListResponseOutputWithContext(ctx context.Context) IncidentListResponseOutput {
	return o
}

// Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
func (o IncidentListResponseOutput) MonitoredResources() MonitoredResourceResponseArrayOutput {
	return o.ApplyT(func(v IncidentListResponse) []MonitoredResourceResponse { return v.MonitoredResources }).(MonitoredResourceResponseArrayOutput)
}

// Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
func (o IncidentListResponseOutput) PolicyNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IncidentListResponse) []string { return v.PolicyNames }).(pulumi.StringArrayOutput)
}

// A widget that displays a stream of log.
type LogsPanel struct {
	// A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
	Filter *string `pulumi:"filter"`
	// The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
	ResourceNames []string `pulumi:"resourceNames"`
}

// LogsPanelInput is an input type that accepts LogsPanelArgs and LogsPanelOutput values.
// You can construct a concrete instance of `LogsPanelInput` via:
//
//	LogsPanelArgs{...}
type LogsPanelInput interface {
	pulumi.Input

	ToLogsPanelOutput() LogsPanelOutput
	ToLogsPanelOutputWithContext(context.Context) LogsPanelOutput
}

// A widget that displays a stream of log.
type LogsPanelArgs struct {
	// A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
	Filter pulumi.StringPtrInput `pulumi:"filter"`
	// The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
	ResourceNames pulumi.StringArrayInput `pulumi:"resourceNames"`
}

func (LogsPanelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogsPanel)(nil)).Elem()
}

func (i LogsPanelArgs) ToLogsPanelOutput() LogsPanelOutput {
	return i.ToLogsPanelOutputWithContext(context.Background())
}

func (i LogsPanelArgs) ToLogsPanelOutputWithContext(ctx context.Context) LogsPanelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsPanelOutput)
}

func (i LogsPanelArgs) ToLogsPanelPtrOutput() LogsPanelPtrOutput {
	return i.ToLogsPanelPtrOutputWithContext(context.Background())
}

func (i LogsPanelArgs) ToLogsPanelPtrOutputWithContext(ctx context.Context) LogsPanelPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsPanelOutput).ToLogsPanelPtrOutputWithContext(ctx)
}

// LogsPanelPtrInput is an input type that accepts LogsPanelArgs, LogsPanelPtr and LogsPanelPtrOutput values.
// You can construct a concrete instance of `LogsPanelPtrInput` via:
//
//	        LogsPanelArgs{...}
//
//	or:
//
//	        nil
type LogsPanelPtrInput interface {
	pulumi.Input

	ToLogsPanelPtrOutput() LogsPanelPtrOutput
	ToLogsPanelPtrOutputWithContext(context.Context) LogsPanelPtrOutput
}

type logsPanelPtrType LogsPanelArgs

func LogsPanelPtr(v *LogsPanelArgs) LogsPanelPtrInput {
	return (*logsPanelPtrType)(v)
}

func (*logsPanelPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogsPanel)(nil)).Elem()
}

func (i *logsPanelPtrType) ToLogsPanelPtrOutput() LogsPanelPtrOutput {
	return i.ToLogsPanelPtrOutputWithContext(context.Background())
}

func (i *logsPanelPtrType) ToLogsPanelPtrOutputWithContext(ctx context.Context) LogsPanelPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsPanelPtrOutput)
}

// A widget that displays a stream of log.
type LogsPanelOutput struct{ *pulumi.OutputState }

func (LogsPanelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogsPanel)(nil)).Elem()
}

func (o LogsPanelOutput) ToLogsPanelOutput() LogsPanelOutput {
	return o
}

func (o LogsPanelOutput) ToLogsPanelOutputWithContext(ctx context.Context) LogsPanelOutput {
	return o
}

func (o LogsPanelOutput) ToLogsPanelPtrOutput() LogsPanelPtrOutput {
	return o.ToLogsPanelPtrOutputWithContext(context.Background())
}

func (o LogsPanelOutput) ToLogsPanelPtrOutputWithContext(ctx context.Context) LogsPanelPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogsPanel) *LogsPanel {
		return &v
	}).(LogsPanelPtrOutput)
}

// A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
func (o LogsPanelOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogsPanel) *string { return v.Filter }).(pulumi.StringPtrOutput)
}

// The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
func (o LogsPanelOutput) ResourceNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogsPanel) []string { return v.ResourceNames }).(pulumi.StringArrayOutput)
}

type LogsPanelPtrOutput struct{ *pulumi.OutputState }

func (LogsPanelPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogsPanel)(nil)).Elem()
}

func (o LogsPanelPtrOutput) ToLogsPanelPtrOutput() LogsPanelPtrOutput {
	return o
}

func (o LogsPanelPtrOutput) ToLogsPanelPtrOutputWithContext(ctx context.Context) LogsPanelPtrOutput {
	return o
}

func (o LogsPanelPtrOutput) Elem() LogsPanelOutput {
	return o.ApplyT(func(v *LogsPanel) LogsPanel {
		if v != nil {
			return *v
		}
		var ret LogsPanel
		return ret
	}).(LogsPanelOutput)
}

// A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
func (o LogsPanelPtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogsPanel) *string {
		if v == nil {
			return nil
		}
		return v.Filter
	}).(pulumi.StringPtrOutput)
}

// The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
func (o LogsPanelPtrOutput) ResourceNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogsPanel) []string {
		if v == nil {
			return nil
		}
		return v.ResourceNames
	}).(pulumi.StringArrayOutput)
}

// A widget that displays a stream of log.
type LogsPanelResponse struct {
	// A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
	Filter string `pulumi:"filter"`
	// The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
	ResourceNames []string `pulumi:"resourceNames"`
}

// A widget that displays a stream of log.
type LogsPanelResponseOutput struct{ *pulumi.OutputState }

func (LogsPanelResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogsPanelResponse)(nil)).Elem()
}

func (o LogsPanelResponseOutput) ToLogsPanelResponseOutput() LogsPanelResponseOutput {
	return o
}

func (o LogsPanelResponseOutput) ToLogsPanelResponseOutputWithContext(ctx context.Context) LogsPanelResponseOutput {
	return o
}

// A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
func (o LogsPanelResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v LogsPanelResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
func (o LogsPanelResponseOutput) ResourceNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogsPanelResponse) []string { return v.ResourceNames }).(pulumi.StringArrayOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResource struct {
	// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels map[string]string `pulumi:"labels"`
	// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
	Type string `pulumi:"type"`
}

// MonitoredResourceInput is an input type that accepts MonitoredResourceArgs and MonitoredResourceOutput values.
// You can construct a concrete instance of `MonitoredResourceInput` via:
//
//	MonitoredResourceArgs{...}
type MonitoredResourceInput interface {
	pulumi.Input

	ToMonitoredResourceOutput() MonitoredResourceOutput
	ToMonitoredResourceOutputWithContext(context.Context) MonitoredResourceOutput
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceArgs struct {
	// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
	Type pulumi.StringInput `pulumi:"type"`
}

func (MonitoredResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResource)(nil)).Elem()
}

func (i MonitoredResourceArgs) ToMonitoredResourceOutput() MonitoredResourceOutput {
	return i.ToMonitoredResourceOutputWithContext(context.Background())
}

func (i MonitoredResourceArgs) ToMonitoredResourceOutputWithContext(ctx context.Context) MonitoredResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceOutput)
}

// MonitoredResourceArrayInput is an input type that accepts MonitoredResourceArray and MonitoredResourceArrayOutput values.
// You can construct a concrete instance of `MonitoredResourceArrayInput` via:
//
//	MonitoredResourceArray{ MonitoredResourceArgs{...} }
type MonitoredResourceArrayInput interface {
	pulumi.Input

	ToMonitoredResourceArrayOutput() MonitoredResourceArrayOutput
	ToMonitoredResourceArrayOutputWithContext(context.Context) MonitoredResourceArrayOutput
}

type MonitoredResourceArray []MonitoredResourceInput

func (MonitoredResourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MonitoredResource)(nil)).Elem()
}

func (i MonitoredResourceArray) ToMonitoredResourceArrayOutput() MonitoredResourceArrayOutput {
	return i.ToMonitoredResourceArrayOutputWithContext(context.Background())
}

func (i MonitoredResourceArray) ToMonitoredResourceArrayOutputWithContext(ctx context.Context) MonitoredResourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceArrayOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceOutput struct{ *pulumi.OutputState }

func (MonitoredResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResource)(nil)).Elem()
}

func (o MonitoredResourceOutput) ToMonitoredResourceOutput() MonitoredResourceOutput {
	return o
}

func (o MonitoredResourceOutput) ToMonitoredResourceOutputWithContext(ctx context.Context) MonitoredResourceOutput {
	return o
}

// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
func (o MonitoredResourceOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v MonitoredResource) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
func (o MonitoredResourceOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v MonitoredResource) string { return v.Type }).(pulumi.StringOutput)
}

type MonitoredResourceArrayOutput struct{ *pulumi.OutputState }

func (MonitoredResourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MonitoredResource)(nil)).Elem()
}

func (o MonitoredResourceArrayOutput) ToMonitoredResourceArrayOutput() MonitoredResourceArrayOutput {
	return o
}

func (o MonitoredResourceArrayOutput) ToMonitoredResourceArrayOutputWithContext(ctx context.Context) MonitoredResourceArrayOutput {
	return o
}

func (o MonitoredResourceArrayOutput) Index(i pulumi.IntInput) MonitoredResourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MonitoredResource {
		return vs[0].([]MonitoredResource)[vs[1].(int)]
	}).(MonitoredResourceOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceResponse struct {
	// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels map[string]string `pulumi:"labels"`
	// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
	Type string `pulumi:"type"`
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceResponseOutput struct{ *pulumi.OutputState }

func (MonitoredResourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResourceResponse)(nil)).Elem()
}

func (o MonitoredResourceResponseOutput) ToMonitoredResourceResponseOutput() MonitoredResourceResponseOutput {
	return o
}

func (o MonitoredResourceResponseOutput) ToMonitoredResourceResponseOutputWithContext(ctx context.Context) MonitoredResourceResponseOutput {
	return o
}

// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
func (o MonitoredResourceResponseOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v MonitoredResourceResponse) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
func (o MonitoredResourceResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v MonitoredResourceResponse) string { return v.Type }).(pulumi.StringOutput)
}

type MonitoredResourceResponseArrayOutput struct{ *pulumi.OutputState }

func (MonitoredResourceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MonitoredResourceResponse)(nil)).Elem()
}

func (o MonitoredResourceResponseArrayOutput) ToMonitoredResourceResponseArrayOutput() MonitoredResourceResponseArrayOutput {
	return o
}

func (o MonitoredResourceResponseArrayOutput) ToMonitoredResourceResponseArrayOutputWithContext(ctx context.Context) MonitoredResourceResponseArrayOutput {
	return o
}

func (o MonitoredResourceResponseArrayOutput) Index(i pulumi.IntInput) MonitoredResourceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MonitoredResourceResponse {
		return vs[0].([]MonitoredResourceResponse)[vs[1].(int)]
	}).(MonitoredResourceResponseOutput)
}

// A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid.
type MosaicLayout struct {
	// The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
	Columns *int `pulumi:"columns"`
	// The tiles to display.
	Tiles []Tile `pulumi:"tiles"`
}

// MosaicLayoutInput is an input type that accepts MosaicLayoutArgs and MosaicLayoutOutput values.
// You can construct a concrete instance of `MosaicLayoutInput` via:
//
//	MosaicLayoutArgs{...}
type MosaicLayoutInput interface {
	pulumi.Input

	ToMosaicLayoutOutput() MosaicLayoutOutput
	ToMosaicLayoutOutputWithContext(context.Context) MosaicLayoutOutput
}

// A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid.
type MosaicLayoutArgs struct {
	// The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
	Columns pulumi.IntPtrInput `pulumi:"columns"`
	// The tiles to display.
	Tiles TileArrayInput `pulumi:"tiles"`
}

func (MosaicLayoutArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MosaicLayout)(nil)).Elem()
}

func (i MosaicLayoutArgs) ToMosaicLayoutOutput() MosaicLayoutOutput {
	return i.ToMosaicLayoutOutputWithContext(context.Background())
}

func (i MosaicLayoutArgs) ToMosaicLayoutOutputWithContext(ctx context.Context) MosaicLayoutOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MosaicLayoutOutput)
}

func (i MosaicLayoutArgs) ToMosaicLayoutPtrOutput() MosaicLayoutPtrOutput {
	return i.ToMosaicLayoutPtrOutputWithContext(context.Background())
}

func (i MosaicLayoutArgs) ToMosaicLayoutPtrOutputWithContext(ctx context.Context) MosaicLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MosaicLayoutOutput).ToMosaicLayoutPtrOutputWithContext(ctx)
}

// MosaicLayoutPtrInput is an input type that accepts MosaicLayoutArgs, MosaicLayoutPtr and MosaicLayoutPtrOutput values.
// You can construct a concrete instance of `MosaicLayoutPtrInput` via:
//
//	        MosaicLayoutArgs{...}
//
//	or:
//
//	        nil
type MosaicLayoutPtrInput interface {
	pulumi.Input

	ToMosaicLayoutPtrOutput() MosaicLayoutPtrOutput
	ToMosaicLayoutPtrOutputWithContext(context.Context) MosaicLayoutPtrOutput
}

type mosaicLayoutPtrType MosaicLayoutArgs

func MosaicLayoutPtr(v *MosaicLayoutArgs) MosaicLayoutPtrInput {
	return (*mosaicLayoutPtrType)(v)
}

func (*mosaicLayoutPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MosaicLayout)(nil)).Elem()
}

func (i *mosaicLayoutPtrType) ToMosaicLayoutPtrOutput() MosaicLayoutPtrOutput {
	return i.ToMosaicLayoutPtrOutputWithContext(context.Background())
}

func (i *mosaicLayoutPtrType) ToMosaicLayoutPtrOutputWithContext(ctx context.Context) MosaicLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MosaicLayoutPtrOutput)
}

// A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid.
type MosaicLayoutOutput struct{ *pulumi.OutputState }

func (MosaicLayoutOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MosaicLayout)(nil)).Elem()
}

func (o MosaicLayoutOutput) ToMosaicLayoutOutput() MosaicLayoutOutput {
	return o
}

func (o MosaicLayoutOutput) ToMosaicLayoutOutputWithContext(ctx context.Context) MosaicLayoutOutput {
	return o
}

func (o MosaicLayoutOutput) ToMosaicLayoutPtrOutput() MosaicLayoutPtrOutput {
	return o.ToMosaicLayoutPtrOutputWithContext(context.Background())
}

func (o MosaicLayoutOutput) ToMosaicLayoutPtrOutputWithContext(ctx context.Context) MosaicLayoutPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MosaicLayout) *MosaicLayout {
		return &v
	}).(MosaicLayoutPtrOutput)
}

// The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
func (o MosaicLayoutOutput) Columns() pulumi.IntPtrOutput {
	return o.ApplyT(func(v MosaicLayout) *int { return v.Columns }).(pulumi.IntPtrOutput)
}

// The tiles to display.
func (o MosaicLayoutOutput) Tiles() TileArrayOutput {
	return o.ApplyT(func(v MosaicLayout) []Tile { return v.Tiles }).(TileArrayOutput)
}

type MosaicLayoutPtrOutput struct{ *pulumi.OutputState }

func (MosaicLayoutPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MosaicLayout)(nil)).Elem()
}

func (o MosaicLayoutPtrOutput) ToMosaicLayoutPtrOutput() MosaicLayoutPtrOutput {
	return o
}

func (o MosaicLayoutPtrOutput) ToMosaicLayoutPtrOutputWithContext(ctx context.Context) MosaicLayoutPtrOutput {
	return o
}

func (o MosaicLayoutPtrOutput) Elem() MosaicLayoutOutput {
	return o.ApplyT(func(v *MosaicLayout) MosaicLayout {
		if v != nil {
			return *v
		}
		var ret MosaicLayout
		return ret
	}).(MosaicLayoutOutput)
}

// The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
func (o MosaicLayoutPtrOutput) Columns() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *MosaicLayout) *int {
		if v == nil {
			return nil
		}
		return v.Columns
	}).(pulumi.IntPtrOutput)
}

// The tiles to display.
func (o MosaicLayoutPtrOutput) Tiles() TileArrayOutput {
	return o.ApplyT(func(v *MosaicLayout) []Tile {
		if v == nil {
			return nil
		}
		return v.Tiles
	}).(TileArrayOutput)
}

// A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid.
type MosaicLayoutResponse struct {
	// The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
	Columns int `pulumi:"columns"`
	// The tiles to display.
	Tiles []TileResponse `pulumi:"tiles"`
}

// A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid.
type MosaicLayoutResponseOutput struct{ *pulumi.OutputState }

func (MosaicLayoutResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MosaicLayoutResponse)(nil)).Elem()
}

func (o MosaicLayoutResponseOutput) ToMosaicLayoutResponseOutput() MosaicLayoutResponseOutput {
	return o
}

func (o MosaicLayoutResponseOutput) ToMosaicLayoutResponseOutputWithContext(ctx context.Context) MosaicLayoutResponseOutput {
	return o
}

// The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
func (o MosaicLayoutResponseOutput) Columns() pulumi.IntOutput {
	return o.ApplyT(func(v MosaicLayoutResponse) int { return v.Columns }).(pulumi.IntOutput)
}

// The tiles to display.
func (o MosaicLayoutResponseOutput) Tiles() TileResponseArrayOutput {
	return o.ApplyT(func(v MosaicLayoutResponse) []TileResponse { return v.Tiles }).(TileResponseArrayOutput)
}

// Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter.
type PickTimeSeriesFilter struct {
	// How to use the ranking to select time series that pass through the filter.
	Direction *PickTimeSeriesFilterDirection `pulumi:"direction"`
	// How many time series to allow to pass through the filter.
	NumTimeSeries *int `pulumi:"numTimeSeries"`
	// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
	RankingMethod *PickTimeSeriesFilterRankingMethod `pulumi:"rankingMethod"`
}

// PickTimeSeriesFilterInput is an input type that accepts PickTimeSeriesFilterArgs and PickTimeSeriesFilterOutput values.
// You can construct a concrete instance of `PickTimeSeriesFilterInput` via:
//
//	PickTimeSeriesFilterArgs{...}
type PickTimeSeriesFilterInput interface {
	pulumi.Input

	ToPickTimeSeriesFilterOutput() PickTimeSeriesFilterOutput
	ToPickTimeSeriesFilterOutputWithContext(context.Context) PickTimeSeriesFilterOutput
}

// Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter.
type PickTimeSeriesFilterArgs struct {
	// How to use the ranking to select time series that pass through the filter.
	Direction PickTimeSeriesFilterDirectionPtrInput `pulumi:"direction"`
	// How many time series to allow to pass through the filter.
	NumTimeSeries pulumi.IntPtrInput `pulumi:"numTimeSeries"`
	// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
	RankingMethod PickTimeSeriesFilterRankingMethodPtrInput `pulumi:"rankingMethod"`
}

func (PickTimeSeriesFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PickTimeSeriesFilter)(nil)).Elem()
}

func (i PickTimeSeriesFilterArgs) ToPickTimeSeriesFilterOutput() PickTimeSeriesFilterOutput {
	return i.ToPickTimeSeriesFilterOutputWithContext(context.Background())
}

func (i PickTimeSeriesFilterArgs) ToPickTimeSeriesFilterOutputWithContext(ctx context.Context) PickTimeSeriesFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PickTimeSeriesFilterOutput)
}

func (i PickTimeSeriesFilterArgs) ToPickTimeSeriesFilterPtrOutput() PickTimeSeriesFilterPtrOutput {
	return i.ToPickTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (i PickTimeSeriesFilterArgs) ToPickTimeSeriesFilterPtrOutputWithContext(ctx context.Context) PickTimeSeriesFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PickTimeSeriesFilterOutput).ToPickTimeSeriesFilterPtrOutputWithContext(ctx)
}

// PickTimeSeriesFilterPtrInput is an input type that accepts PickTimeSeriesFilterArgs, PickTimeSeriesFilterPtr and PickTimeSeriesFilterPtrOutput values.
// You can construct a concrete instance of `PickTimeSeriesFilterPtrInput` via:
//
//	        PickTimeSeriesFilterArgs{...}
//
//	or:
//
//	        nil
type PickTimeSeriesFilterPtrInput interface {
	pulumi.Input

	ToPickTimeSeriesFilterPtrOutput() PickTimeSeriesFilterPtrOutput
	ToPickTimeSeriesFilterPtrOutputWithContext(context.Context) PickTimeSeriesFilterPtrOutput
}

type pickTimeSeriesFilterPtrType PickTimeSeriesFilterArgs

func PickTimeSeriesFilterPtr(v *PickTimeSeriesFilterArgs) PickTimeSeriesFilterPtrInput {
	return (*pickTimeSeriesFilterPtrType)(v)
}

func (*pickTimeSeriesFilterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PickTimeSeriesFilter)(nil)).Elem()
}

func (i *pickTimeSeriesFilterPtrType) ToPickTimeSeriesFilterPtrOutput() PickTimeSeriesFilterPtrOutput {
	return i.ToPickTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (i *pickTimeSeriesFilterPtrType) ToPickTimeSeriesFilterPtrOutputWithContext(ctx context.Context) PickTimeSeriesFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PickTimeSeriesFilterPtrOutput)
}

// Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter.
type PickTimeSeriesFilterOutput struct{ *pulumi.OutputState }

func (PickTimeSeriesFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PickTimeSeriesFilter)(nil)).Elem()
}

func (o PickTimeSeriesFilterOutput) ToPickTimeSeriesFilterOutput() PickTimeSeriesFilterOutput {
	return o
}

func (o PickTimeSeriesFilterOutput) ToPickTimeSeriesFilterOutputWithContext(ctx context.Context) PickTimeSeriesFilterOutput {
	return o
}

func (o PickTimeSeriesFilterOutput) ToPickTimeSeriesFilterPtrOutput() PickTimeSeriesFilterPtrOutput {
	return o.ToPickTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (o PickTimeSeriesFilterOutput) ToPickTimeSeriesFilterPtrOutputWithContext(ctx context.Context) PickTimeSeriesFilterPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PickTimeSeriesFilter) *PickTimeSeriesFilter {
		return &v
	}).(PickTimeSeriesFilterPtrOutput)
}

// How to use the ranking to select time series that pass through the filter.
func (o PickTimeSeriesFilterOutput) Direction() PickTimeSeriesFilterDirectionPtrOutput {
	return o.ApplyT(func(v PickTimeSeriesFilter) *PickTimeSeriesFilterDirection { return v.Direction }).(PickTimeSeriesFilterDirectionPtrOutput)
}

// How many time series to allow to pass through the filter.
func (o PickTimeSeriesFilterOutput) NumTimeSeries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PickTimeSeriesFilter) *int { return v.NumTimeSeries }).(pulumi.IntPtrOutput)
}

// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
func (o PickTimeSeriesFilterOutput) RankingMethod() PickTimeSeriesFilterRankingMethodPtrOutput {
	return o.ApplyT(func(v PickTimeSeriesFilter) *PickTimeSeriesFilterRankingMethod { return v.RankingMethod }).(PickTimeSeriesFilterRankingMethodPtrOutput)
}

type PickTimeSeriesFilterPtrOutput struct{ *pulumi.OutputState }

func (PickTimeSeriesFilterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PickTimeSeriesFilter)(nil)).Elem()
}

func (o PickTimeSeriesFilterPtrOutput) ToPickTimeSeriesFilterPtrOutput() PickTimeSeriesFilterPtrOutput {
	return o
}

func (o PickTimeSeriesFilterPtrOutput) ToPickTimeSeriesFilterPtrOutputWithContext(ctx context.Context) PickTimeSeriesFilterPtrOutput {
	return o
}

func (o PickTimeSeriesFilterPtrOutput) Elem() PickTimeSeriesFilterOutput {
	return o.ApplyT(func(v *PickTimeSeriesFilter) PickTimeSeriesFilter {
		if v != nil {
			return *v
		}
		var ret PickTimeSeriesFilter
		return ret
	}).(PickTimeSeriesFilterOutput)
}

// How to use the ranking to select time series that pass through the filter.
func (o PickTimeSeriesFilterPtrOutput) Direction() PickTimeSeriesFilterDirectionPtrOutput {
	return o.ApplyT(func(v *PickTimeSeriesFilter) *PickTimeSeriesFilterDirection {
		if v == nil {
			return nil
		}
		return v.Direction
	}).(PickTimeSeriesFilterDirectionPtrOutput)
}

// How many time series to allow to pass through the filter.
func (o PickTimeSeriesFilterPtrOutput) NumTimeSeries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PickTimeSeriesFilter) *int {
		if v == nil {
			return nil
		}
		return v.NumTimeSeries
	}).(pulumi.IntPtrOutput)
}

// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
func (o PickTimeSeriesFilterPtrOutput) RankingMethod() PickTimeSeriesFilterRankingMethodPtrOutput {
	return o.ApplyT(func(v *PickTimeSeriesFilter) *PickTimeSeriesFilterRankingMethod {
		if v == nil {
			return nil
		}
		return v.RankingMethod
	}).(PickTimeSeriesFilterRankingMethodPtrOutput)
}

// Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter.
type PickTimeSeriesFilterResponse struct {
	// How to use the ranking to select time series that pass through the filter.
	Direction string `pulumi:"direction"`
	// How many time series to allow to pass through the filter.
	NumTimeSeries int `pulumi:"numTimeSeries"`
	// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
	RankingMethod string `pulumi:"rankingMethod"`
}

// Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter.
type PickTimeSeriesFilterResponseOutput struct{ *pulumi.OutputState }

func (PickTimeSeriesFilterResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PickTimeSeriesFilterResponse)(nil)).Elem()
}

func (o PickTimeSeriesFilterResponseOutput) ToPickTimeSeriesFilterResponseOutput() PickTimeSeriesFilterResponseOutput {
	return o
}

func (o PickTimeSeriesFilterResponseOutput) ToPickTimeSeriesFilterResponseOutputWithContext(ctx context.Context) PickTimeSeriesFilterResponseOutput {
	return o
}

// How to use the ranking to select time series that pass through the filter.
func (o PickTimeSeriesFilterResponseOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v PickTimeSeriesFilterResponse) string { return v.Direction }).(pulumi.StringOutput)
}

// How many time series to allow to pass through the filter.
func (o PickTimeSeriesFilterResponseOutput) NumTimeSeries() pulumi.IntOutput {
	return o.ApplyT(func(v PickTimeSeriesFilterResponse) int { return v.NumTimeSeries }).(pulumi.IntOutput)
}

// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
func (o PickTimeSeriesFilterResponseOutput) RankingMethod() pulumi.StringOutput {
	return o.ApplyT(func(v PickTimeSeriesFilterResponse) string { return v.RankingMethod }).(pulumi.StringOutput)
}

// Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio.
type RatioPart struct {
	// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
	Aggregation *Aggregation `pulumi:"aggregation"`
	// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
	Filter string `pulumi:"filter"`
}

// RatioPartInput is an input type that accepts RatioPartArgs and RatioPartOutput values.
// You can construct a concrete instance of `RatioPartInput` via:
//
//	RatioPartArgs{...}
type RatioPartInput interface {
	pulumi.Input

	ToRatioPartOutput() RatioPartOutput
	ToRatioPartOutputWithContext(context.Context) RatioPartOutput
}

// Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio.
type RatioPartArgs struct {
	// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
	Aggregation AggregationPtrInput `pulumi:"aggregation"`
	// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
	Filter pulumi.StringInput `pulumi:"filter"`
}

func (RatioPartArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RatioPart)(nil)).Elem()
}

func (i RatioPartArgs) ToRatioPartOutput() RatioPartOutput {
	return i.ToRatioPartOutputWithContext(context.Background())
}

func (i RatioPartArgs) ToRatioPartOutputWithContext(ctx context.Context) RatioPartOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RatioPartOutput)
}

func (i RatioPartArgs) ToRatioPartPtrOutput() RatioPartPtrOutput {
	return i.ToRatioPartPtrOutputWithContext(context.Background())
}

func (i RatioPartArgs) ToRatioPartPtrOutputWithContext(ctx context.Context) RatioPartPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RatioPartOutput).ToRatioPartPtrOutputWithContext(ctx)
}

// RatioPartPtrInput is an input type that accepts RatioPartArgs, RatioPartPtr and RatioPartPtrOutput values.
// You can construct a concrete instance of `RatioPartPtrInput` via:
//
//	        RatioPartArgs{...}
//
//	or:
//
//	        nil
type RatioPartPtrInput interface {
	pulumi.Input

	ToRatioPartPtrOutput() RatioPartPtrOutput
	ToRatioPartPtrOutputWithContext(context.Context) RatioPartPtrOutput
}

type ratioPartPtrType RatioPartArgs

func RatioPartPtr(v *RatioPartArgs) RatioPartPtrInput {
	return (*ratioPartPtrType)(v)
}

func (*ratioPartPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RatioPart)(nil)).Elem()
}

func (i *ratioPartPtrType) ToRatioPartPtrOutput() RatioPartPtrOutput {
	return i.ToRatioPartPtrOutputWithContext(context.Background())
}

func (i *ratioPartPtrType) ToRatioPartPtrOutputWithContext(ctx context.Context) RatioPartPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RatioPartPtrOutput)
}

// Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio.
type RatioPartOutput struct{ *pulumi.OutputState }

func (RatioPartOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RatioPart)(nil)).Elem()
}

func (o RatioPartOutput) ToRatioPartOutput() RatioPartOutput {
	return o
}

func (o RatioPartOutput) ToRatioPartOutputWithContext(ctx context.Context) RatioPartOutput {
	return o
}

func (o RatioPartOutput) ToRatioPartPtrOutput() RatioPartPtrOutput {
	return o.ToRatioPartPtrOutputWithContext(context.Background())
}

func (o RatioPartOutput) ToRatioPartPtrOutputWithContext(ctx context.Context) RatioPartPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RatioPart) *RatioPart {
		return &v
	}).(RatioPartPtrOutput)
}

// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
func (o RatioPartOutput) Aggregation() AggregationPtrOutput {
	return o.ApplyT(func(v RatioPart) *Aggregation { return v.Aggregation }).(AggregationPtrOutput)
}

// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
func (o RatioPartOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v RatioPart) string { return v.Filter }).(pulumi.StringOutput)
}

type RatioPartPtrOutput struct{ *pulumi.OutputState }

func (RatioPartPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RatioPart)(nil)).Elem()
}

func (o RatioPartPtrOutput) ToRatioPartPtrOutput() RatioPartPtrOutput {
	return o
}

func (o RatioPartPtrOutput) ToRatioPartPtrOutputWithContext(ctx context.Context) RatioPartPtrOutput {
	return o
}

func (o RatioPartPtrOutput) Elem() RatioPartOutput {
	return o.ApplyT(func(v *RatioPart) RatioPart {
		if v != nil {
			return *v
		}
		var ret RatioPart
		return ret
	}).(RatioPartOutput)
}

// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
func (o RatioPartPtrOutput) Aggregation() AggregationPtrOutput {
	return o.ApplyT(func(v *RatioPart) *Aggregation {
		if v == nil {
			return nil
		}
		return v.Aggregation
	}).(AggregationPtrOutput)
}

// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
func (o RatioPartPtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RatioPart) *string {
		if v == nil {
			return nil
		}
		return &v.Filter
	}).(pulumi.StringPtrOutput)
}

// Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio.
type RatioPartResponse struct {
	// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
	Aggregation AggregationResponse `pulumi:"aggregation"`
	// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
	Filter string `pulumi:"filter"`
}

// Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio.
type RatioPartResponseOutput struct{ *pulumi.OutputState }

func (RatioPartResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RatioPartResponse)(nil)).Elem()
}

func (o RatioPartResponseOutput) ToRatioPartResponseOutput() RatioPartResponseOutput {
	return o
}

func (o RatioPartResponseOutput) ToRatioPartResponseOutputWithContext(ctx context.Context) RatioPartResponseOutput {
	return o
}

// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
func (o RatioPartResponseOutput) Aggregation() AggregationResponseOutput {
	return o.ApplyT(func(v RatioPartResponse) AggregationResponse { return v.Aggregation }).(AggregationResponseOutput)
}

// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
func (o RatioPartResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v RatioPartResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// Defines the layout properties and content for a row.
type Row struct {
	// The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
	Weight *string `pulumi:"weight"`
	// The display widgets arranged horizontally in this row.
	Widgets []Widget `pulumi:"widgets"`
}

// RowInput is an input type that accepts RowArgs and RowOutput values.
// You can construct a concrete instance of `RowInput` via:
//
//	RowArgs{...}
type RowInput interface {
	pulumi.Input

	ToRowOutput() RowOutput
	ToRowOutputWithContext(context.Context) RowOutput
}

// Defines the layout properties and content for a row.
type RowArgs struct {
	// The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
	Weight pulumi.StringPtrInput `pulumi:"weight"`
	// The display widgets arranged horizontally in this row.
	Widgets WidgetArrayInput `pulumi:"widgets"`
}

func (RowArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Row)(nil)).Elem()
}

func (i RowArgs) ToRowOutput() RowOutput {
	return i.ToRowOutputWithContext(context.Background())
}

func (i RowArgs) ToRowOutputWithContext(ctx context.Context) RowOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RowOutput)
}

// RowArrayInput is an input type that accepts RowArray and RowArrayOutput values.
// You can construct a concrete instance of `RowArrayInput` via:
//
//	RowArray{ RowArgs{...} }
type RowArrayInput interface {
	pulumi.Input

	ToRowArrayOutput() RowArrayOutput
	ToRowArrayOutputWithContext(context.Context) RowArrayOutput
}

type RowArray []RowInput

func (RowArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Row)(nil)).Elem()
}

func (i RowArray) ToRowArrayOutput() RowArrayOutput {
	return i.ToRowArrayOutputWithContext(context.Background())
}

func (i RowArray) ToRowArrayOutputWithContext(ctx context.Context) RowArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RowArrayOutput)
}

// Defines the layout properties and content for a row.
type RowOutput struct{ *pulumi.OutputState }

func (RowOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Row)(nil)).Elem()
}

func (o RowOutput) ToRowOutput() RowOutput {
	return o
}

func (o RowOutput) ToRowOutputWithContext(ctx context.Context) RowOutput {
	return o
}

// The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
func (o RowOutput) Weight() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Row) *string { return v.Weight }).(pulumi.StringPtrOutput)
}

// The display widgets arranged horizontally in this row.
func (o RowOutput) Widgets() WidgetArrayOutput {
	return o.ApplyT(func(v Row) []Widget { return v.Widgets }).(WidgetArrayOutput)
}

type RowArrayOutput struct{ *pulumi.OutputState }

func (RowArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Row)(nil)).Elem()
}

func (o RowArrayOutput) ToRowArrayOutput() RowArrayOutput {
	return o
}

func (o RowArrayOutput) ToRowArrayOutputWithContext(ctx context.Context) RowArrayOutput {
	return o
}

func (o RowArrayOutput) Index(i pulumi.IntInput) RowOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Row {
		return vs[0].([]Row)[vs[1].(int)]
	}).(RowOutput)
}

// A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row.
type RowLayout struct {
	// The rows of content to display.
	Rows []Row `pulumi:"rows"`
}

// RowLayoutInput is an input type that accepts RowLayoutArgs and RowLayoutOutput values.
// You can construct a concrete instance of `RowLayoutInput` via:
//
//	RowLayoutArgs{...}
type RowLayoutInput interface {
	pulumi.Input

	ToRowLayoutOutput() RowLayoutOutput
	ToRowLayoutOutputWithContext(context.Context) RowLayoutOutput
}

// A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row.
type RowLayoutArgs struct {
	// The rows of content to display.
	Rows RowArrayInput `pulumi:"rows"`
}

func (RowLayoutArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RowLayout)(nil)).Elem()
}

func (i RowLayoutArgs) ToRowLayoutOutput() RowLayoutOutput {
	return i.ToRowLayoutOutputWithContext(context.Background())
}

func (i RowLayoutArgs) ToRowLayoutOutputWithContext(ctx context.Context) RowLayoutOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RowLayoutOutput)
}

func (i RowLayoutArgs) ToRowLayoutPtrOutput() RowLayoutPtrOutput {
	return i.ToRowLayoutPtrOutputWithContext(context.Background())
}

func (i RowLayoutArgs) ToRowLayoutPtrOutputWithContext(ctx context.Context) RowLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RowLayoutOutput).ToRowLayoutPtrOutputWithContext(ctx)
}

// RowLayoutPtrInput is an input type that accepts RowLayoutArgs, RowLayoutPtr and RowLayoutPtrOutput values.
// You can construct a concrete instance of `RowLayoutPtrInput` via:
//
//	        RowLayoutArgs{...}
//
//	or:
//
//	        nil
type RowLayoutPtrInput interface {
	pulumi.Input

	ToRowLayoutPtrOutput() RowLayoutPtrOutput
	ToRowLayoutPtrOutputWithContext(context.Context) RowLayoutPtrOutput
}

type rowLayoutPtrType RowLayoutArgs

func RowLayoutPtr(v *RowLayoutArgs) RowLayoutPtrInput {
	return (*rowLayoutPtrType)(v)
}

func (*rowLayoutPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RowLayout)(nil)).Elem()
}

func (i *rowLayoutPtrType) ToRowLayoutPtrOutput() RowLayoutPtrOutput {
	return i.ToRowLayoutPtrOutputWithContext(context.Background())
}

func (i *rowLayoutPtrType) ToRowLayoutPtrOutputWithContext(ctx context.Context) RowLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RowLayoutPtrOutput)
}

// A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row.
type RowLayoutOutput struct{ *pulumi.OutputState }

func (RowLayoutOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RowLayout)(nil)).Elem()
}

func (o RowLayoutOutput) ToRowLayoutOutput() RowLayoutOutput {
	return o
}

func (o RowLayoutOutput) ToRowLayoutOutputWithContext(ctx context.Context) RowLayoutOutput {
	return o
}

func (o RowLayoutOutput) ToRowLayoutPtrOutput() RowLayoutPtrOutput {
	return o.ToRowLayoutPtrOutputWithContext(context.Background())
}

func (o RowLayoutOutput) ToRowLayoutPtrOutputWithContext(ctx context.Context) RowLayoutPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RowLayout) *RowLayout {
		return &v
	}).(RowLayoutPtrOutput)
}

// The rows of content to display.
func (o RowLayoutOutput) Rows() RowArrayOutput {
	return o.ApplyT(func(v RowLayout) []Row { return v.Rows }).(RowArrayOutput)
}

type RowLayoutPtrOutput struct{ *pulumi.OutputState }

func (RowLayoutPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RowLayout)(nil)).Elem()
}

func (o RowLayoutPtrOutput) ToRowLayoutPtrOutput() RowLayoutPtrOutput {
	return o
}

func (o RowLayoutPtrOutput) ToRowLayoutPtrOutputWithContext(ctx context.Context) RowLayoutPtrOutput {
	return o
}

func (o RowLayoutPtrOutput) Elem() RowLayoutOutput {
	return o.ApplyT(func(v *RowLayout) RowLayout {
		if v != nil {
			return *v
		}
		var ret RowLayout
		return ret
	}).(RowLayoutOutput)
}

// The rows of content to display.
func (o RowLayoutPtrOutput) Rows() RowArrayOutput {
	return o.ApplyT(func(v *RowLayout) []Row {
		if v == nil {
			return nil
		}
		return v.Rows
	}).(RowArrayOutput)
}

// A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row.
type RowLayoutResponse struct {
	// The rows of content to display.
	Rows []RowResponse `pulumi:"rows"`
}

// A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row.
type RowLayoutResponseOutput struct{ *pulumi.OutputState }

func (RowLayoutResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RowLayoutResponse)(nil)).Elem()
}

func (o RowLayoutResponseOutput) ToRowLayoutResponseOutput() RowLayoutResponseOutput {
	return o
}

func (o RowLayoutResponseOutput) ToRowLayoutResponseOutputWithContext(ctx context.Context) RowLayoutResponseOutput {
	return o
}

// The rows of content to display.
func (o RowLayoutResponseOutput) Rows() RowResponseArrayOutput {
	return o.ApplyT(func(v RowLayoutResponse) []RowResponse { return v.Rows }).(RowResponseArrayOutput)
}

// Defines the layout properties and content for a row.
type RowResponse struct {
	// The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
	Weight string `pulumi:"weight"`
	// The display widgets arranged horizontally in this row.
	Widgets []WidgetResponse `pulumi:"widgets"`
}

// Defines the layout properties and content for a row.
type RowResponseOutput struct{ *pulumi.OutputState }

func (RowResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RowResponse)(nil)).Elem()
}

func (o RowResponseOutput) ToRowResponseOutput() RowResponseOutput {
	return o
}

func (o RowResponseOutput) ToRowResponseOutputWithContext(ctx context.Context) RowResponseOutput {
	return o
}

// The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
func (o RowResponseOutput) Weight() pulumi.StringOutput {
	return o.ApplyT(func(v RowResponse) string { return v.Weight }).(pulumi.StringOutput)
}

// The display widgets arranged horizontally in this row.
func (o RowResponseOutput) Widgets() WidgetResponseArrayOutput {
	return o.ApplyT(func(v RowResponse) []WidgetResponse { return v.Widgets }).(WidgetResponseArrayOutput)
}

type RowResponseArrayOutput struct{ *pulumi.OutputState }

func (RowResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RowResponse)(nil)).Elem()
}

func (o RowResponseArrayOutput) ToRowResponseArrayOutput() RowResponseArrayOutput {
	return o
}

func (o RowResponseArrayOutput) ToRowResponseArrayOutputWithContext(ctx context.Context) RowResponseArrayOutput {
	return o
}

func (o RowResponseArrayOutput) Index(i pulumi.IntInput) RowResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RowResponse {
		return vs[0].([]RowResponse)[vs[1].(int)]
	}).(RowResponseOutput)
}

// A widget showing the latest value of a metric, and how this value relates to one or more thresholds.
type Scorecard struct {
	// Will cause the scorecard to show a gauge chart.
	GaugeView *GaugeView `pulumi:"gaugeView"`
	// Will cause the scorecard to show a spark chart.
	SparkChartView *SparkChartView `pulumi:"sparkChartView"`
	// The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
	Thresholds []Threshold `pulumi:"thresholds"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQuery `pulumi:"timeSeriesQuery"`
}

// ScorecardInput is an input type that accepts ScorecardArgs and ScorecardOutput values.
// You can construct a concrete instance of `ScorecardInput` via:
//
//	ScorecardArgs{...}
type ScorecardInput interface {
	pulumi.Input

	ToScorecardOutput() ScorecardOutput
	ToScorecardOutputWithContext(context.Context) ScorecardOutput
}

// A widget showing the latest value of a metric, and how this value relates to one or more thresholds.
type ScorecardArgs struct {
	// Will cause the scorecard to show a gauge chart.
	GaugeView GaugeViewPtrInput `pulumi:"gaugeView"`
	// Will cause the scorecard to show a spark chart.
	SparkChartView SparkChartViewPtrInput `pulumi:"sparkChartView"`
	// The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
	Thresholds ThresholdArrayInput `pulumi:"thresholds"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQueryInput `pulumi:"timeSeriesQuery"`
}

func (ScorecardArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Scorecard)(nil)).Elem()
}

func (i ScorecardArgs) ToScorecardOutput() ScorecardOutput {
	return i.ToScorecardOutputWithContext(context.Background())
}

func (i ScorecardArgs) ToScorecardOutputWithContext(ctx context.Context) ScorecardOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScorecardOutput)
}

func (i ScorecardArgs) ToScorecardPtrOutput() ScorecardPtrOutput {
	return i.ToScorecardPtrOutputWithContext(context.Background())
}

func (i ScorecardArgs) ToScorecardPtrOutputWithContext(ctx context.Context) ScorecardPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScorecardOutput).ToScorecardPtrOutputWithContext(ctx)
}

// ScorecardPtrInput is an input type that accepts ScorecardArgs, ScorecardPtr and ScorecardPtrOutput values.
// You can construct a concrete instance of `ScorecardPtrInput` via:
//
//	        ScorecardArgs{...}
//
//	or:
//
//	        nil
type ScorecardPtrInput interface {
	pulumi.Input

	ToScorecardPtrOutput() ScorecardPtrOutput
	ToScorecardPtrOutputWithContext(context.Context) ScorecardPtrOutput
}

type scorecardPtrType ScorecardArgs

func ScorecardPtr(v *ScorecardArgs) ScorecardPtrInput {
	return (*scorecardPtrType)(v)
}

func (*scorecardPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Scorecard)(nil)).Elem()
}

func (i *scorecardPtrType) ToScorecardPtrOutput() ScorecardPtrOutput {
	return i.ToScorecardPtrOutputWithContext(context.Background())
}

func (i *scorecardPtrType) ToScorecardPtrOutputWithContext(ctx context.Context) ScorecardPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScorecardPtrOutput)
}

// A widget showing the latest value of a metric, and how this value relates to one or more thresholds.
type ScorecardOutput struct{ *pulumi.OutputState }

func (ScorecardOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Scorecard)(nil)).Elem()
}

func (o ScorecardOutput) ToScorecardOutput() ScorecardOutput {
	return o
}

func (o ScorecardOutput) ToScorecardOutputWithContext(ctx context.Context) ScorecardOutput {
	return o
}

func (o ScorecardOutput) ToScorecardPtrOutput() ScorecardPtrOutput {
	return o.ToScorecardPtrOutputWithContext(context.Background())
}

func (o ScorecardOutput) ToScorecardPtrOutputWithContext(ctx context.Context) ScorecardPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Scorecard) *Scorecard {
		return &v
	}).(ScorecardPtrOutput)
}

// Will cause the scorecard to show a gauge chart.
func (o ScorecardOutput) GaugeView() GaugeViewPtrOutput {
	return o.ApplyT(func(v Scorecard) *GaugeView { return v.GaugeView }).(GaugeViewPtrOutput)
}

// Will cause the scorecard to show a spark chart.
func (o ScorecardOutput) SparkChartView() SparkChartViewPtrOutput {
	return o.ApplyT(func(v Scorecard) *SparkChartView { return v.SparkChartView }).(SparkChartViewPtrOutput)
}

// The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
func (o ScorecardOutput) Thresholds() ThresholdArrayOutput {
	return o.ApplyT(func(v Scorecard) []Threshold { return v.Thresholds }).(ThresholdArrayOutput)
}

// Fields for querying time series data from the Stackdriver metrics API.
func (o ScorecardOutput) TimeSeriesQuery() TimeSeriesQueryOutput {
	return o.ApplyT(func(v Scorecard) TimeSeriesQuery { return v.TimeSeriesQuery }).(TimeSeriesQueryOutput)
}

type ScorecardPtrOutput struct{ *pulumi.OutputState }

func (ScorecardPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Scorecard)(nil)).Elem()
}

func (o ScorecardPtrOutput) ToScorecardPtrOutput() ScorecardPtrOutput {
	return o
}

func (o ScorecardPtrOutput) ToScorecardPtrOutputWithContext(ctx context.Context) ScorecardPtrOutput {
	return o
}

func (o ScorecardPtrOutput) Elem() ScorecardOutput {
	return o.ApplyT(func(v *Scorecard) Scorecard {
		if v != nil {
			return *v
		}
		var ret Scorecard
		return ret
	}).(ScorecardOutput)
}

// Will cause the scorecard to show a gauge chart.
func (o ScorecardPtrOutput) GaugeView() GaugeViewPtrOutput {
	return o.ApplyT(func(v *Scorecard) *GaugeView {
		if v == nil {
			return nil
		}
		return v.GaugeView
	}).(GaugeViewPtrOutput)
}

// Will cause the scorecard to show a spark chart.
func (o ScorecardPtrOutput) SparkChartView() SparkChartViewPtrOutput {
	return o.ApplyT(func(v *Scorecard) *SparkChartView {
		if v == nil {
			return nil
		}
		return v.SparkChartView
	}).(SparkChartViewPtrOutput)
}

// The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
func (o ScorecardPtrOutput) Thresholds() ThresholdArrayOutput {
	return o.ApplyT(func(v *Scorecard) []Threshold {
		if v == nil {
			return nil
		}
		return v.Thresholds
	}).(ThresholdArrayOutput)
}

// Fields for querying time series data from the Stackdriver metrics API.
func (o ScorecardPtrOutput) TimeSeriesQuery() TimeSeriesQueryPtrOutput {
	return o.ApplyT(func(v *Scorecard) *TimeSeriesQuery {
		if v == nil {
			return nil
		}
		return &v.TimeSeriesQuery
	}).(TimeSeriesQueryPtrOutput)
}

// A widget showing the latest value of a metric, and how this value relates to one or more thresholds.
type ScorecardResponse struct {
	// Will cause the scorecard to show a gauge chart.
	GaugeView GaugeViewResponse `pulumi:"gaugeView"`
	// Will cause the scorecard to show a spark chart.
	SparkChartView SparkChartViewResponse `pulumi:"sparkChartView"`
	// The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
	Thresholds []ThresholdResponse `pulumi:"thresholds"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQueryResponse `pulumi:"timeSeriesQuery"`
}

// A widget showing the latest value of a metric, and how this value relates to one or more thresholds.
type ScorecardResponseOutput struct{ *pulumi.OutputState }

func (ScorecardResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScorecardResponse)(nil)).Elem()
}

func (o ScorecardResponseOutput) ToScorecardResponseOutput() ScorecardResponseOutput {
	return o
}

func (o ScorecardResponseOutput) ToScorecardResponseOutputWithContext(ctx context.Context) ScorecardResponseOutput {
	return o
}

// Will cause the scorecard to show a gauge chart.
func (o ScorecardResponseOutput) GaugeView() GaugeViewResponseOutput {
	return o.ApplyT(func(v ScorecardResponse) GaugeViewResponse { return v.GaugeView }).(GaugeViewResponseOutput)
}

// Will cause the scorecard to show a spark chart.
func (o ScorecardResponseOutput) SparkChartView() SparkChartViewResponseOutput {
	return o.ApplyT(func(v ScorecardResponse) SparkChartViewResponse { return v.SparkChartView }).(SparkChartViewResponseOutput)
}

// The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
func (o ScorecardResponseOutput) Thresholds() ThresholdResponseArrayOutput {
	return o.ApplyT(func(v ScorecardResponse) []ThresholdResponse { return v.Thresholds }).(ThresholdResponseArrayOutput)
}

// Fields for querying time series data from the Stackdriver metrics API.
func (o ScorecardResponseOutput) TimeSeriesQuery() TimeSeriesQueryResponseOutput {
	return o.ApplyT(func(v ScorecardResponse) TimeSeriesQueryResponse { return v.TimeSeriesQuery }).(TimeSeriesQueryResponseOutput)
}

// A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard's timeseries.
type SparkChartView struct {
	// The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
	MinAlignmentPeriod *string `pulumi:"minAlignmentPeriod"`
	// The type of sparkchart to show in this chartView.
	SparkChartType SparkChartViewSparkChartType `pulumi:"sparkChartType"`
}

// SparkChartViewInput is an input type that accepts SparkChartViewArgs and SparkChartViewOutput values.
// You can construct a concrete instance of `SparkChartViewInput` via:
//
//	SparkChartViewArgs{...}
type SparkChartViewInput interface {
	pulumi.Input

	ToSparkChartViewOutput() SparkChartViewOutput
	ToSparkChartViewOutputWithContext(context.Context) SparkChartViewOutput
}

// A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard's timeseries.
type SparkChartViewArgs struct {
	// The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
	MinAlignmentPeriod pulumi.StringPtrInput `pulumi:"minAlignmentPeriod"`
	// The type of sparkchart to show in this chartView.
	SparkChartType SparkChartViewSparkChartTypeInput `pulumi:"sparkChartType"`
}

func (SparkChartViewArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SparkChartView)(nil)).Elem()
}

func (i SparkChartViewArgs) ToSparkChartViewOutput() SparkChartViewOutput {
	return i.ToSparkChartViewOutputWithContext(context.Background())
}

func (i SparkChartViewArgs) ToSparkChartViewOutputWithContext(ctx context.Context) SparkChartViewOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SparkChartViewOutput)
}

func (i SparkChartViewArgs) ToSparkChartViewPtrOutput() SparkChartViewPtrOutput {
	return i.ToSparkChartViewPtrOutputWithContext(context.Background())
}

func (i SparkChartViewArgs) ToSparkChartViewPtrOutputWithContext(ctx context.Context) SparkChartViewPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SparkChartViewOutput).ToSparkChartViewPtrOutputWithContext(ctx)
}

// SparkChartViewPtrInput is an input type that accepts SparkChartViewArgs, SparkChartViewPtr and SparkChartViewPtrOutput values.
// You can construct a concrete instance of `SparkChartViewPtrInput` via:
//
//	        SparkChartViewArgs{...}
//
//	or:
//
//	        nil
type SparkChartViewPtrInput interface {
	pulumi.Input

	ToSparkChartViewPtrOutput() SparkChartViewPtrOutput
	ToSparkChartViewPtrOutputWithContext(context.Context) SparkChartViewPtrOutput
}

type sparkChartViewPtrType SparkChartViewArgs

func SparkChartViewPtr(v *SparkChartViewArgs) SparkChartViewPtrInput {
	return (*sparkChartViewPtrType)(v)
}

func (*sparkChartViewPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SparkChartView)(nil)).Elem()
}

func (i *sparkChartViewPtrType) ToSparkChartViewPtrOutput() SparkChartViewPtrOutput {
	return i.ToSparkChartViewPtrOutputWithContext(context.Background())
}

func (i *sparkChartViewPtrType) ToSparkChartViewPtrOutputWithContext(ctx context.Context) SparkChartViewPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SparkChartViewPtrOutput)
}

// A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard's timeseries.
type SparkChartViewOutput struct{ *pulumi.OutputState }

func (SparkChartViewOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SparkChartView)(nil)).Elem()
}

func (o SparkChartViewOutput) ToSparkChartViewOutput() SparkChartViewOutput {
	return o
}

func (o SparkChartViewOutput) ToSparkChartViewOutputWithContext(ctx context.Context) SparkChartViewOutput {
	return o
}

func (o SparkChartViewOutput) ToSparkChartViewPtrOutput() SparkChartViewPtrOutput {
	return o.ToSparkChartViewPtrOutputWithContext(context.Background())
}

func (o SparkChartViewOutput) ToSparkChartViewPtrOutputWithContext(ctx context.Context) SparkChartViewPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SparkChartView) *SparkChartView {
		return &v
	}).(SparkChartViewPtrOutput)
}

// The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
func (o SparkChartViewOutput) MinAlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SparkChartView) *string { return v.MinAlignmentPeriod }).(pulumi.StringPtrOutput)
}

// The type of sparkchart to show in this chartView.
func (o SparkChartViewOutput) SparkChartType() SparkChartViewSparkChartTypeOutput {
	return o.ApplyT(func(v SparkChartView) SparkChartViewSparkChartType { return v.SparkChartType }).(SparkChartViewSparkChartTypeOutput)
}

type SparkChartViewPtrOutput struct{ *pulumi.OutputState }

func (SparkChartViewPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SparkChartView)(nil)).Elem()
}

func (o SparkChartViewPtrOutput) ToSparkChartViewPtrOutput() SparkChartViewPtrOutput {
	return o
}

func (o SparkChartViewPtrOutput) ToSparkChartViewPtrOutputWithContext(ctx context.Context) SparkChartViewPtrOutput {
	return o
}

func (o SparkChartViewPtrOutput) Elem() SparkChartViewOutput {
	return o.ApplyT(func(v *SparkChartView) SparkChartView {
		if v != nil {
			return *v
		}
		var ret SparkChartView
		return ret
	}).(SparkChartViewOutput)
}

// The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
func (o SparkChartViewPtrOutput) MinAlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SparkChartView) *string {
		if v == nil {
			return nil
		}
		return v.MinAlignmentPeriod
	}).(pulumi.StringPtrOutput)
}

// The type of sparkchart to show in this chartView.
func (o SparkChartViewPtrOutput) SparkChartType() SparkChartViewSparkChartTypePtrOutput {
	return o.ApplyT(func(v *SparkChartView) *SparkChartViewSparkChartType {
		if v == nil {
			return nil
		}
		return &v.SparkChartType
	}).(SparkChartViewSparkChartTypePtrOutput)
}

// A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard's timeseries.
type SparkChartViewResponse struct {
	// The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
	MinAlignmentPeriod string `pulumi:"minAlignmentPeriod"`
	// The type of sparkchart to show in this chartView.
	SparkChartType string `pulumi:"sparkChartType"`
}

// A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard's timeseries.
type SparkChartViewResponseOutput struct{ *pulumi.OutputState }

func (SparkChartViewResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SparkChartViewResponse)(nil)).Elem()
}

func (o SparkChartViewResponseOutput) ToSparkChartViewResponseOutput() SparkChartViewResponseOutput {
	return o
}

func (o SparkChartViewResponseOutput) ToSparkChartViewResponseOutputWithContext(ctx context.Context) SparkChartViewResponseOutput {
	return o
}

// The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
func (o SparkChartViewResponseOutput) MinAlignmentPeriod() pulumi.StringOutput {
	return o.ApplyT(func(v SparkChartViewResponse) string { return v.MinAlignmentPeriod }).(pulumi.StringOutput)
}

// The type of sparkchart to show in this chartView.
func (o SparkChartViewResponseOutput) SparkChartType() pulumi.StringOutput {
	return o.ApplyT(func(v SparkChartViewResponse) string { return v.SparkChartType }).(pulumi.StringOutput)
}

// A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API.
type StatisticalTimeSeriesFilter struct {
	// How many time series to output.
	NumTimeSeries *int `pulumi:"numTimeSeries"`
	// rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
	RankingMethod *StatisticalTimeSeriesFilterRankingMethod `pulumi:"rankingMethod"`
}

// StatisticalTimeSeriesFilterInput is an input type that accepts StatisticalTimeSeriesFilterArgs and StatisticalTimeSeriesFilterOutput values.
// You can construct a concrete instance of `StatisticalTimeSeriesFilterInput` via:
//
//	StatisticalTimeSeriesFilterArgs{...}
type StatisticalTimeSeriesFilterInput interface {
	pulumi.Input

	ToStatisticalTimeSeriesFilterOutput() StatisticalTimeSeriesFilterOutput
	ToStatisticalTimeSeriesFilterOutputWithContext(context.Context) StatisticalTimeSeriesFilterOutput
}

// A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API.
type StatisticalTimeSeriesFilterArgs struct {
	// How many time series to output.
	NumTimeSeries pulumi.IntPtrInput `pulumi:"numTimeSeries"`
	// rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
	RankingMethod StatisticalTimeSeriesFilterRankingMethodPtrInput `pulumi:"rankingMethod"`
}

func (StatisticalTimeSeriesFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatisticalTimeSeriesFilter)(nil)).Elem()
}

func (i StatisticalTimeSeriesFilterArgs) ToStatisticalTimeSeriesFilterOutput() StatisticalTimeSeriesFilterOutput {
	return i.ToStatisticalTimeSeriesFilterOutputWithContext(context.Background())
}

func (i StatisticalTimeSeriesFilterArgs) ToStatisticalTimeSeriesFilterOutputWithContext(ctx context.Context) StatisticalTimeSeriesFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatisticalTimeSeriesFilterOutput)
}

func (i StatisticalTimeSeriesFilterArgs) ToStatisticalTimeSeriesFilterPtrOutput() StatisticalTimeSeriesFilterPtrOutput {
	return i.ToStatisticalTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (i StatisticalTimeSeriesFilterArgs) ToStatisticalTimeSeriesFilterPtrOutputWithContext(ctx context.Context) StatisticalTimeSeriesFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatisticalTimeSeriesFilterOutput).ToStatisticalTimeSeriesFilterPtrOutputWithContext(ctx)
}

// StatisticalTimeSeriesFilterPtrInput is an input type that accepts StatisticalTimeSeriesFilterArgs, StatisticalTimeSeriesFilterPtr and StatisticalTimeSeriesFilterPtrOutput values.
// You can construct a concrete instance of `StatisticalTimeSeriesFilterPtrInput` via:
//
//	        StatisticalTimeSeriesFilterArgs{...}
//
//	or:
//
//	        nil
type StatisticalTimeSeriesFilterPtrInput interface {
	pulumi.Input

	ToStatisticalTimeSeriesFilterPtrOutput() StatisticalTimeSeriesFilterPtrOutput
	ToStatisticalTimeSeriesFilterPtrOutputWithContext(context.Context) StatisticalTimeSeriesFilterPtrOutput
}

type statisticalTimeSeriesFilterPtrType StatisticalTimeSeriesFilterArgs

func StatisticalTimeSeriesFilterPtr(v *StatisticalTimeSeriesFilterArgs) StatisticalTimeSeriesFilterPtrInput {
	return (*statisticalTimeSeriesFilterPtrType)(v)
}

func (*statisticalTimeSeriesFilterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StatisticalTimeSeriesFilter)(nil)).Elem()
}

func (i *statisticalTimeSeriesFilterPtrType) ToStatisticalTimeSeriesFilterPtrOutput() StatisticalTimeSeriesFilterPtrOutput {
	return i.ToStatisticalTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (i *statisticalTimeSeriesFilterPtrType) ToStatisticalTimeSeriesFilterPtrOutputWithContext(ctx context.Context) StatisticalTimeSeriesFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatisticalTimeSeriesFilterPtrOutput)
}

// A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API.
type StatisticalTimeSeriesFilterOutput struct{ *pulumi.OutputState }

func (StatisticalTimeSeriesFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatisticalTimeSeriesFilter)(nil)).Elem()
}

func (o StatisticalTimeSeriesFilterOutput) ToStatisticalTimeSeriesFilterOutput() StatisticalTimeSeriesFilterOutput {
	return o
}

func (o StatisticalTimeSeriesFilterOutput) ToStatisticalTimeSeriesFilterOutputWithContext(ctx context.Context) StatisticalTimeSeriesFilterOutput {
	return o
}

func (o StatisticalTimeSeriesFilterOutput) ToStatisticalTimeSeriesFilterPtrOutput() StatisticalTimeSeriesFilterPtrOutput {
	return o.ToStatisticalTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (o StatisticalTimeSeriesFilterOutput) ToStatisticalTimeSeriesFilterPtrOutputWithContext(ctx context.Context) StatisticalTimeSeriesFilterPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StatisticalTimeSeriesFilter) *StatisticalTimeSeriesFilter {
		return &v
	}).(StatisticalTimeSeriesFilterPtrOutput)
}

// How many time series to output.
func (o StatisticalTimeSeriesFilterOutput) NumTimeSeries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatisticalTimeSeriesFilter) *int { return v.NumTimeSeries }).(pulumi.IntPtrOutput)
}

// rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
func (o StatisticalTimeSeriesFilterOutput) RankingMethod() StatisticalTimeSeriesFilterRankingMethodPtrOutput {
	return o.ApplyT(func(v StatisticalTimeSeriesFilter) *StatisticalTimeSeriesFilterRankingMethod { return v.RankingMethod }).(StatisticalTimeSeriesFilterRankingMethodPtrOutput)
}

type StatisticalTimeSeriesFilterPtrOutput struct{ *pulumi.OutputState }

func (StatisticalTimeSeriesFilterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StatisticalTimeSeriesFilter)(nil)).Elem()
}

func (o StatisticalTimeSeriesFilterPtrOutput) ToStatisticalTimeSeriesFilterPtrOutput() StatisticalTimeSeriesFilterPtrOutput {
	return o
}

func (o StatisticalTimeSeriesFilterPtrOutput) ToStatisticalTimeSeriesFilterPtrOutputWithContext(ctx context.Context) StatisticalTimeSeriesFilterPtrOutput {
	return o
}

func (o StatisticalTimeSeriesFilterPtrOutput) Elem() StatisticalTimeSeriesFilterOutput {
	return o.ApplyT(func(v *StatisticalTimeSeriesFilter) StatisticalTimeSeriesFilter {
		if v != nil {
			return *v
		}
		var ret StatisticalTimeSeriesFilter
		return ret
	}).(StatisticalTimeSeriesFilterOutput)
}

// How many time series to output.
func (o StatisticalTimeSeriesFilterPtrOutput) NumTimeSeries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatisticalTimeSeriesFilter) *int {
		if v == nil {
			return nil
		}
		return v.NumTimeSeries
	}).(pulumi.IntPtrOutput)
}

// rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
func (o StatisticalTimeSeriesFilterPtrOutput) RankingMethod() StatisticalTimeSeriesFilterRankingMethodPtrOutput {
	return o.ApplyT(func(v *StatisticalTimeSeriesFilter) *StatisticalTimeSeriesFilterRankingMethod {
		if v == nil {
			return nil
		}
		return v.RankingMethod
	}).(StatisticalTimeSeriesFilterRankingMethodPtrOutput)
}

// A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API.
type StatisticalTimeSeriesFilterResponse struct {
	// How many time series to output.
	NumTimeSeries int `pulumi:"numTimeSeries"`
	// rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
	RankingMethod string `pulumi:"rankingMethod"`
}

// A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API.
type StatisticalTimeSeriesFilterResponseOutput struct{ *pulumi.OutputState }

func (StatisticalTimeSeriesFilterResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatisticalTimeSeriesFilterResponse)(nil)).Elem()
}

func (o StatisticalTimeSeriesFilterResponseOutput) ToStatisticalTimeSeriesFilterResponseOutput() StatisticalTimeSeriesFilterResponseOutput {
	return o
}

func (o StatisticalTimeSeriesFilterResponseOutput) ToStatisticalTimeSeriesFilterResponseOutputWithContext(ctx context.Context) StatisticalTimeSeriesFilterResponseOutput {
	return o
}

// How many time series to output.
func (o StatisticalTimeSeriesFilterResponseOutput) NumTimeSeries() pulumi.IntOutput {
	return o.ApplyT(func(v StatisticalTimeSeriesFilterResponse) int { return v.NumTimeSeries }).(pulumi.IntOutput)
}

// rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
func (o StatisticalTimeSeriesFilterResponseOutput) RankingMethod() pulumi.StringOutput {
	return o.ApplyT(func(v StatisticalTimeSeriesFilterResponse) string { return v.RankingMethod }).(pulumi.StringOutput)
}

// Groups a time series query definition with table options.
type TableDataSet struct {
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod *string `pulumi:"minAlignmentPeriod"`
	// Optional. Table display options for configuring how the table is rendered.
	TableDisplayOptions *TableDisplayOptions `pulumi:"tableDisplayOptions"`
	// Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value i.e. "${resource.labels.project_id}."
	TableTemplate *string `pulumi:"tableTemplate"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQuery `pulumi:"timeSeriesQuery"`
}

// TableDataSetInput is an input type that accepts TableDataSetArgs and TableDataSetOutput values.
// You can construct a concrete instance of `TableDataSetInput` via:
//
//	TableDataSetArgs{...}
type TableDataSetInput interface {
	pulumi.Input

	ToTableDataSetOutput() TableDataSetOutput
	ToTableDataSetOutputWithContext(context.Context) TableDataSetOutput
}

// Groups a time series query definition with table options.
type TableDataSetArgs struct {
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod pulumi.StringPtrInput `pulumi:"minAlignmentPeriod"`
	// Optional. Table display options for configuring how the table is rendered.
	TableDisplayOptions TableDisplayOptionsPtrInput `pulumi:"tableDisplayOptions"`
	// Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value i.e. "${resource.labels.project_id}."
	TableTemplate pulumi.StringPtrInput `pulumi:"tableTemplate"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQueryInput `pulumi:"timeSeriesQuery"`
}

func (TableDataSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TableDataSet)(nil)).Elem()
}

func (i TableDataSetArgs) ToTableDataSetOutput() TableDataSetOutput {
	return i.ToTableDataSetOutputWithContext(context.Background())
}

func (i TableDataSetArgs) ToTableDataSetOutputWithContext(ctx context.Context) TableDataSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TableDataSetOutput)
}

// TableDataSetArrayInput is an input type that accepts TableDataSetArray and TableDataSetArrayOutput values.
// You can construct a concrete instance of `TableDataSetArrayInput` via:
//
//	TableDataSetArray{ TableDataSetArgs{...} }
type TableDataSetArrayInput interface {
	pulumi.Input

	ToTableDataSetArrayOutput() TableDataSetArrayOutput
	ToTableDataSetArrayOutputWithContext(context.Context) TableDataSetArrayOutput
}

type TableDataSetArray []TableDataSetInput

func (TableDataSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TableDataSet)(nil)).Elem()
}

func (i TableDataSetArray) ToTableDataSetArrayOutput() TableDataSetArrayOutput {
	return i.ToTableDataSetArrayOutputWithContext(context.Background())
}

func (i TableDataSetArray) ToTableDataSetArrayOutputWithContext(ctx context.Context) TableDataSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TableDataSetArrayOutput)
}

// Groups a time series query definition with table options.
type TableDataSetOutput struct{ *pulumi.OutputState }

func (TableDataSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TableDataSet)(nil)).Elem()
}

func (o TableDataSetOutput) ToTableDataSetOutput() TableDataSetOutput {
	return o
}

func (o TableDataSetOutput) ToTableDataSetOutputWithContext(ctx context.Context) TableDataSetOutput {
	return o
}

// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
func (o TableDataSetOutput) MinAlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TableDataSet) *string { return v.MinAlignmentPeriod }).(pulumi.StringPtrOutput)
}

// Optional. Table display options for configuring how the table is rendered.
func (o TableDataSetOutput) TableDisplayOptions() TableDisplayOptionsPtrOutput {
	return o.ApplyT(func(v TableDataSet) *TableDisplayOptions { return v.TableDisplayOptions }).(TableDisplayOptionsPtrOutput)
}

// Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value i.e. "${resource.labels.project_id}."
func (o TableDataSetOutput) TableTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TableDataSet) *string { return v.TableTemplate }).(pulumi.StringPtrOutput)
}

// Fields for querying time series data from the Stackdriver metrics API.
func (o TableDataSetOutput) TimeSeriesQuery() TimeSeriesQueryOutput {
	return o.ApplyT(func(v TableDataSet) TimeSeriesQuery { return v.TimeSeriesQuery }).(TimeSeriesQueryOutput)
}

type TableDataSetArrayOutput struct{ *pulumi.OutputState }

func (TableDataSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TableDataSet)(nil)).Elem()
}

func (o TableDataSetArrayOutput) ToTableDataSetArrayOutput() TableDataSetArrayOutput {
	return o
}

func (o TableDataSetArrayOutput) ToTableDataSetArrayOutputWithContext(ctx context.Context) TableDataSetArrayOutput {
	return o
}

func (o TableDataSetArrayOutput) Index(i pulumi.IntInput) TableDataSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TableDataSet {
		return vs[0].([]TableDataSet)[vs[1].(int)]
	}).(TableDataSetOutput)
}

// Groups a time series query definition with table options.
type TableDataSetResponse struct {
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod string `pulumi:"minAlignmentPeriod"`
	// Optional. Table display options for configuring how the table is rendered.
	TableDisplayOptions TableDisplayOptionsResponse `pulumi:"tableDisplayOptions"`
	// Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value i.e. "${resource.labels.project_id}."
	TableTemplate string `pulumi:"tableTemplate"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQueryResponse `pulumi:"timeSeriesQuery"`
}

// Groups a time series query definition with table options.
type TableDataSetResponseOutput struct{ *pulumi.OutputState }

func (TableDataSetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TableDataSetResponse)(nil)).Elem()
}

func (o TableDataSetResponseOutput) ToTableDataSetResponseOutput() TableDataSetResponseOutput {
	return o
}

func (o TableDataSetResponseOutput) ToTableDataSetResponseOutputWithContext(ctx context.Context) TableDataSetResponseOutput {
	return o
}

// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
func (o TableDataSetResponseOutput) MinAlignmentPeriod() pulumi.StringOutput {
	return o.ApplyT(func(v TableDataSetResponse) string { return v.MinAlignmentPeriod }).(pulumi.StringOutput)
}

// Optional. Table display options for configuring how the table is rendered.
func (o TableDataSetResponseOutput) TableDisplayOptions() TableDisplayOptionsResponseOutput {
	return o.ApplyT(func(v TableDataSetResponse) TableDisplayOptionsResponse { return v.TableDisplayOptions }).(TableDisplayOptionsResponseOutput)
}

// Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value i.e. "${resource.labels.project_id}."
func (o TableDataSetResponseOutput) TableTemplate() pulumi.StringOutput {
	return o.ApplyT(func(v TableDataSetResponse) string { return v.TableTemplate }).(pulumi.StringOutput)
}

// Fields for querying time series data from the Stackdriver metrics API.
func (o TableDataSetResponseOutput) TimeSeriesQuery() TimeSeriesQueryResponseOutput {
	return o.ApplyT(func(v TableDataSetResponse) TimeSeriesQueryResponse { return v.TimeSeriesQuery }).(TimeSeriesQueryResponseOutput)
}

type TableDataSetResponseArrayOutput struct{ *pulumi.OutputState }

func (TableDataSetResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TableDataSetResponse)(nil)).Elem()
}

func (o TableDataSetResponseArrayOutput) ToTableDataSetResponseArrayOutput() TableDataSetResponseArrayOutput {
	return o
}

func (o TableDataSetResponseArrayOutput) ToTableDataSetResponseArrayOutputWithContext(ctx context.Context) TableDataSetResponseArrayOutput {
	return o
}

func (o TableDataSetResponseArrayOutput) Index(i pulumi.IntInput) TableDataSetResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TableDataSetResponse {
		return vs[0].([]TableDataSetResponse)[vs[1].(int)]
	}).(TableDataSetResponseOutput)
}

// Table display options that can be reused.
type TableDisplayOptions struct {
	// Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
	ShownColumns []string `pulumi:"shownColumns"`
}

// TableDisplayOptionsInput is an input type that accepts TableDisplayOptionsArgs and TableDisplayOptionsOutput values.
// You can construct a concrete instance of `TableDisplayOptionsInput` via:
//
//	TableDisplayOptionsArgs{...}
type TableDisplayOptionsInput interface {
	pulumi.Input

	ToTableDisplayOptionsOutput() TableDisplayOptionsOutput
	ToTableDisplayOptionsOutputWithContext(context.Context) TableDisplayOptionsOutput
}

// Table display options that can be reused.
type TableDisplayOptionsArgs struct {
	// Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
	ShownColumns pulumi.StringArrayInput `pulumi:"shownColumns"`
}

func (TableDisplayOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TableDisplayOptions)(nil)).Elem()
}

func (i TableDisplayOptionsArgs) ToTableDisplayOptionsOutput() TableDisplayOptionsOutput {
	return i.ToTableDisplayOptionsOutputWithContext(context.Background())
}

func (i TableDisplayOptionsArgs) ToTableDisplayOptionsOutputWithContext(ctx context.Context) TableDisplayOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TableDisplayOptionsOutput)
}

func (i TableDisplayOptionsArgs) ToTableDisplayOptionsPtrOutput() TableDisplayOptionsPtrOutput {
	return i.ToTableDisplayOptionsPtrOutputWithContext(context.Background())
}

func (i TableDisplayOptionsArgs) ToTableDisplayOptionsPtrOutputWithContext(ctx context.Context) TableDisplayOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TableDisplayOptionsOutput).ToTableDisplayOptionsPtrOutputWithContext(ctx)
}

// TableDisplayOptionsPtrInput is an input type that accepts TableDisplayOptionsArgs, TableDisplayOptionsPtr and TableDisplayOptionsPtrOutput values.
// You can construct a concrete instance of `TableDisplayOptionsPtrInput` via:
//
//	        TableDisplayOptionsArgs{...}
//
//	or:
//
//	        nil
type TableDisplayOptionsPtrInput interface {
	pulumi.Input

	ToTableDisplayOptionsPtrOutput() TableDisplayOptionsPtrOutput
	ToTableDisplayOptionsPtrOutputWithContext(context.Context) TableDisplayOptionsPtrOutput
}

type tableDisplayOptionsPtrType TableDisplayOptionsArgs

func TableDisplayOptionsPtr(v *TableDisplayOptionsArgs) TableDisplayOptionsPtrInput {
	return (*tableDisplayOptionsPtrType)(v)
}

func (*tableDisplayOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TableDisplayOptions)(nil)).Elem()
}

func (i *tableDisplayOptionsPtrType) ToTableDisplayOptionsPtrOutput() TableDisplayOptionsPtrOutput {
	return i.ToTableDisplayOptionsPtrOutputWithContext(context.Background())
}

func (i *tableDisplayOptionsPtrType) ToTableDisplayOptionsPtrOutputWithContext(ctx context.Context) TableDisplayOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TableDisplayOptionsPtrOutput)
}

// Table display options that can be reused.
type TableDisplayOptionsOutput struct{ *pulumi.OutputState }

func (TableDisplayOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TableDisplayOptions)(nil)).Elem()
}

func (o TableDisplayOptionsOutput) ToTableDisplayOptionsOutput() TableDisplayOptionsOutput {
	return o
}

func (o TableDisplayOptionsOutput) ToTableDisplayOptionsOutputWithContext(ctx context.Context) TableDisplayOptionsOutput {
	return o
}

func (o TableDisplayOptionsOutput) ToTableDisplayOptionsPtrOutput() TableDisplayOptionsPtrOutput {
	return o.ToTableDisplayOptionsPtrOutputWithContext(context.Background())
}

func (o TableDisplayOptionsOutput) ToTableDisplayOptionsPtrOutputWithContext(ctx context.Context) TableDisplayOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TableDisplayOptions) *TableDisplayOptions {
		return &v
	}).(TableDisplayOptionsPtrOutput)
}

// Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
func (o TableDisplayOptionsOutput) ShownColumns() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TableDisplayOptions) []string { return v.ShownColumns }).(pulumi.StringArrayOutput)
}

type TableDisplayOptionsPtrOutput struct{ *pulumi.OutputState }

func (TableDisplayOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TableDisplayOptions)(nil)).Elem()
}

func (o TableDisplayOptionsPtrOutput) ToTableDisplayOptionsPtrOutput() TableDisplayOptionsPtrOutput {
	return o
}

func (o TableDisplayOptionsPtrOutput) ToTableDisplayOptionsPtrOutputWithContext(ctx context.Context) TableDisplayOptionsPtrOutput {
	return o
}

func (o TableDisplayOptionsPtrOutput) Elem() TableDisplayOptionsOutput {
	return o.ApplyT(func(v *TableDisplayOptions) TableDisplayOptions {
		if v != nil {
			return *v
		}
		var ret TableDisplayOptions
		return ret
	}).(TableDisplayOptionsOutput)
}

// Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
func (o TableDisplayOptionsPtrOutput) ShownColumns() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TableDisplayOptions) []string {
		if v == nil {
			return nil
		}
		return v.ShownColumns
	}).(pulumi.StringArrayOutput)
}

// Table display options that can be reused.
type TableDisplayOptionsResponse struct {
	// Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
	ShownColumns []string `pulumi:"shownColumns"`
}

// Table display options that can be reused.
type TableDisplayOptionsResponseOutput struct{ *pulumi.OutputState }

func (TableDisplayOptionsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TableDisplayOptionsResponse)(nil)).Elem()
}

func (o TableDisplayOptionsResponseOutput) ToTableDisplayOptionsResponseOutput() TableDisplayOptionsResponseOutput {
	return o
}

func (o TableDisplayOptionsResponseOutput) ToTableDisplayOptionsResponseOutputWithContext(ctx context.Context) TableDisplayOptionsResponseOutput {
	return o
}

// Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
func (o TableDisplayOptionsResponseOutput) ShownColumns() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TableDisplayOptionsResponse) []string { return v.ShownColumns }).(pulumi.StringArrayOutput)
}

// A widget that displays textual content.
type Text struct {
	// The text content to be displayed.
	Content *string `pulumi:"content"`
	// How the text content is formatted.
	Format *TextFormat `pulumi:"format"`
}

// TextInput is an input type that accepts TextArgs and TextOutput values.
// You can construct a concrete instance of `TextInput` via:
//
//	TextArgs{...}
type TextInput interface {
	pulumi.Input

	ToTextOutput() TextOutput
	ToTextOutputWithContext(context.Context) TextOutput
}

// A widget that displays textual content.
type TextArgs struct {
	// The text content to be displayed.
	Content pulumi.StringPtrInput `pulumi:"content"`
	// How the text content is formatted.
	Format TextFormatPtrInput `pulumi:"format"`
}

func (TextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Text)(nil)).Elem()
}

func (i TextArgs) ToTextOutput() TextOutput {
	return i.ToTextOutputWithContext(context.Background())
}

func (i TextArgs) ToTextOutputWithContext(ctx context.Context) TextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextOutput)
}

func (i TextArgs) ToTextPtrOutput() TextPtrOutput {
	return i.ToTextPtrOutputWithContext(context.Background())
}

func (i TextArgs) ToTextPtrOutputWithContext(ctx context.Context) TextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextOutput).ToTextPtrOutputWithContext(ctx)
}

// TextPtrInput is an input type that accepts TextArgs, TextPtr and TextPtrOutput values.
// You can construct a concrete instance of `TextPtrInput` via:
//
//	        TextArgs{...}
//
//	or:
//
//	        nil
type TextPtrInput interface {
	pulumi.Input

	ToTextPtrOutput() TextPtrOutput
	ToTextPtrOutputWithContext(context.Context) TextPtrOutput
}

type textPtrType TextArgs

func TextPtr(v *TextArgs) TextPtrInput {
	return (*textPtrType)(v)
}

func (*textPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Text)(nil)).Elem()
}

func (i *textPtrType) ToTextPtrOutput() TextPtrOutput {
	return i.ToTextPtrOutputWithContext(context.Background())
}

func (i *textPtrType) ToTextPtrOutputWithContext(ctx context.Context) TextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextPtrOutput)
}

// A widget that displays textual content.
type TextOutput struct{ *pulumi.OutputState }

func (TextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Text)(nil)).Elem()
}

func (o TextOutput) ToTextOutput() TextOutput {
	return o
}

func (o TextOutput) ToTextOutputWithContext(ctx context.Context) TextOutput {
	return o
}

func (o TextOutput) ToTextPtrOutput() TextPtrOutput {
	return o.ToTextPtrOutputWithContext(context.Background())
}

func (o TextOutput) ToTextPtrOutputWithContext(ctx context.Context) TextPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Text) *Text {
		return &v
	}).(TextPtrOutput)
}

// The text content to be displayed.
func (o TextOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Text) *string { return v.Content }).(pulumi.StringPtrOutput)
}

// How the text content is formatted.
func (o TextOutput) Format() TextFormatPtrOutput {
	return o.ApplyT(func(v Text) *TextFormat { return v.Format }).(TextFormatPtrOutput)
}

type TextPtrOutput struct{ *pulumi.OutputState }

func (TextPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Text)(nil)).Elem()
}

func (o TextPtrOutput) ToTextPtrOutput() TextPtrOutput {
	return o
}

func (o TextPtrOutput) ToTextPtrOutputWithContext(ctx context.Context) TextPtrOutput {
	return o
}

func (o TextPtrOutput) Elem() TextOutput {
	return o.ApplyT(func(v *Text) Text {
		if v != nil {
			return *v
		}
		var ret Text
		return ret
	}).(TextOutput)
}

// The text content to be displayed.
func (o TextPtrOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Text) *string {
		if v == nil {
			return nil
		}
		return v.Content
	}).(pulumi.StringPtrOutput)
}

// How the text content is formatted.
func (o TextPtrOutput) Format() TextFormatPtrOutput {
	return o.ApplyT(func(v *Text) *TextFormat {
		if v == nil {
			return nil
		}
		return v.Format
	}).(TextFormatPtrOutput)
}

// A widget that displays textual content.
type TextResponse struct {
	// The text content to be displayed.
	Content string `pulumi:"content"`
	// How the text content is formatted.
	Format string `pulumi:"format"`
}

// A widget that displays textual content.
type TextResponseOutput struct{ *pulumi.OutputState }

func (TextResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TextResponse)(nil)).Elem()
}

func (o TextResponseOutput) ToTextResponseOutput() TextResponseOutput {
	return o
}

func (o TextResponseOutput) ToTextResponseOutputWithContext(ctx context.Context) TextResponseOutput {
	return o
}

// The text content to be displayed.
func (o TextResponseOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v TextResponse) string { return v.Content }).(pulumi.StringOutput)
}

// How the text content is formatted.
func (o TextResponseOutput) Format() pulumi.StringOutput {
	return o.ApplyT(func(v TextResponse) string { return v.Format }).(pulumi.StringOutput)
}

// Defines a threshold for categorizing time series values.
type Threshold struct {
	// The state color for this threshold. Color is not allowed in a XyChart.
	Color *ThresholdColor `pulumi:"color"`
	// The direction for the current threshold. Direction is not allowed in a XyChart.
	Direction *ThresholdDirection `pulumi:"direction"`
	// A label for the threshold.
	Label *string `pulumi:"label"`
	// The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
	TargetAxis *ThresholdTargetAxis `pulumi:"targetAxis"`
	// The value of the threshold. The value should be defined in the native scale of the metric.
	Value *float64 `pulumi:"value"`
}

// ThresholdInput is an input type that accepts ThresholdArgs and ThresholdOutput values.
// You can construct a concrete instance of `ThresholdInput` via:
//
//	ThresholdArgs{...}
type ThresholdInput interface {
	pulumi.Input

	ToThresholdOutput() ThresholdOutput
	ToThresholdOutputWithContext(context.Context) ThresholdOutput
}

// Defines a threshold for categorizing time series values.
type ThresholdArgs struct {
	// The state color for this threshold. Color is not allowed in a XyChart.
	Color ThresholdColorPtrInput `pulumi:"color"`
	// The direction for the current threshold. Direction is not allowed in a XyChart.
	Direction ThresholdDirectionPtrInput `pulumi:"direction"`
	// A label for the threshold.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
	TargetAxis ThresholdTargetAxisPtrInput `pulumi:"targetAxis"`
	// The value of the threshold. The value should be defined in the native scale of the metric.
	Value pulumi.Float64PtrInput `pulumi:"value"`
}

func (ThresholdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Threshold)(nil)).Elem()
}

func (i ThresholdArgs) ToThresholdOutput() ThresholdOutput {
	return i.ToThresholdOutputWithContext(context.Background())
}

func (i ThresholdArgs) ToThresholdOutputWithContext(ctx context.Context) ThresholdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ThresholdOutput)
}

// ThresholdArrayInput is an input type that accepts ThresholdArray and ThresholdArrayOutput values.
// You can construct a concrete instance of `ThresholdArrayInput` via:
//
//	ThresholdArray{ ThresholdArgs{...} }
type ThresholdArrayInput interface {
	pulumi.Input

	ToThresholdArrayOutput() ThresholdArrayOutput
	ToThresholdArrayOutputWithContext(context.Context) ThresholdArrayOutput
}

type ThresholdArray []ThresholdInput

func (ThresholdArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Threshold)(nil)).Elem()
}

func (i ThresholdArray) ToThresholdArrayOutput() ThresholdArrayOutput {
	return i.ToThresholdArrayOutputWithContext(context.Background())
}

func (i ThresholdArray) ToThresholdArrayOutputWithContext(ctx context.Context) ThresholdArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ThresholdArrayOutput)
}

// Defines a threshold for categorizing time series values.
type ThresholdOutput struct{ *pulumi.OutputState }

func (ThresholdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Threshold)(nil)).Elem()
}

func (o ThresholdOutput) ToThresholdOutput() ThresholdOutput {
	return o
}

func (o ThresholdOutput) ToThresholdOutputWithContext(ctx context.Context) ThresholdOutput {
	return o
}

// The state color for this threshold. Color is not allowed in a XyChart.
func (o ThresholdOutput) Color() ThresholdColorPtrOutput {
	return o.ApplyT(func(v Threshold) *ThresholdColor { return v.Color }).(ThresholdColorPtrOutput)
}

// The direction for the current threshold. Direction is not allowed in a XyChart.
func (o ThresholdOutput) Direction() ThresholdDirectionPtrOutput {
	return o.ApplyT(func(v Threshold) *ThresholdDirection { return v.Direction }).(ThresholdDirectionPtrOutput)
}

// A label for the threshold.
func (o ThresholdOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Threshold) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
func (o ThresholdOutput) TargetAxis() ThresholdTargetAxisPtrOutput {
	return o.ApplyT(func(v Threshold) *ThresholdTargetAxis { return v.TargetAxis }).(ThresholdTargetAxisPtrOutput)
}

// The value of the threshold. The value should be defined in the native scale of the metric.
func (o ThresholdOutput) Value() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Threshold) *float64 { return v.Value }).(pulumi.Float64PtrOutput)
}

type ThresholdArrayOutput struct{ *pulumi.OutputState }

func (ThresholdArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Threshold)(nil)).Elem()
}

func (o ThresholdArrayOutput) ToThresholdArrayOutput() ThresholdArrayOutput {
	return o
}

func (o ThresholdArrayOutput) ToThresholdArrayOutputWithContext(ctx context.Context) ThresholdArrayOutput {
	return o
}

func (o ThresholdArrayOutput) Index(i pulumi.IntInput) ThresholdOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Threshold {
		return vs[0].([]Threshold)[vs[1].(int)]
	}).(ThresholdOutput)
}

// Defines a threshold for categorizing time series values.
type ThresholdResponse struct {
	// The state color for this threshold. Color is not allowed in a XyChart.
	Color string `pulumi:"color"`
	// The direction for the current threshold. Direction is not allowed in a XyChart.
	Direction string `pulumi:"direction"`
	// A label for the threshold.
	Label string `pulumi:"label"`
	// The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
	TargetAxis string `pulumi:"targetAxis"`
	// The value of the threshold. The value should be defined in the native scale of the metric.
	Value float64 `pulumi:"value"`
}

// Defines a threshold for categorizing time series values.
type ThresholdResponseOutput struct{ *pulumi.OutputState }

func (ThresholdResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ThresholdResponse)(nil)).Elem()
}

func (o ThresholdResponseOutput) ToThresholdResponseOutput() ThresholdResponseOutput {
	return o
}

func (o ThresholdResponseOutput) ToThresholdResponseOutputWithContext(ctx context.Context) ThresholdResponseOutput {
	return o
}

// The state color for this threshold. Color is not allowed in a XyChart.
func (o ThresholdResponseOutput) Color() pulumi.StringOutput {
	return o.ApplyT(func(v ThresholdResponse) string { return v.Color }).(pulumi.StringOutput)
}

// The direction for the current threshold. Direction is not allowed in a XyChart.
func (o ThresholdResponseOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v ThresholdResponse) string { return v.Direction }).(pulumi.StringOutput)
}

// A label for the threshold.
func (o ThresholdResponseOutput) Label() pulumi.StringOutput {
	return o.ApplyT(func(v ThresholdResponse) string { return v.Label }).(pulumi.StringOutput)
}

// The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
func (o ThresholdResponseOutput) TargetAxis() pulumi.StringOutput {
	return o.ApplyT(func(v ThresholdResponse) string { return v.TargetAxis }).(pulumi.StringOutput)
}

// The value of the threshold. The value should be defined in the native scale of the metric.
func (o ThresholdResponseOutput) Value() pulumi.Float64Output {
	return o.ApplyT(func(v ThresholdResponse) float64 { return v.Value }).(pulumi.Float64Output)
}

type ThresholdResponseArrayOutput struct{ *pulumi.OutputState }

func (ThresholdResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ThresholdResponse)(nil)).Elem()
}

func (o ThresholdResponseArrayOutput) ToThresholdResponseArrayOutput() ThresholdResponseArrayOutput {
	return o
}

func (o ThresholdResponseArrayOutput) ToThresholdResponseArrayOutputWithContext(ctx context.Context) ThresholdResponseArrayOutput {
	return o
}

func (o ThresholdResponseArrayOutput) Index(i pulumi.IntInput) ThresholdResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ThresholdResponse {
		return vs[0].([]ThresholdResponse)[vs[1].(int)]
	}).(ThresholdResponseOutput)
}

// A single tile in the mosaic. The placement and size of the tile are configurable.
type Tile struct {
	// The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
	Height *int `pulumi:"height"`
	// The informational widget contained in the tile. For example an XyChart.
	Widget *Widget `pulumi:"widget"`
	// The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
	Width *int `pulumi:"width"`
	// The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
	XPos *int `pulumi:"xPos"`
	// The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
	YPos *int `pulumi:"yPos"`
}

// TileInput is an input type that accepts TileArgs and TileOutput values.
// You can construct a concrete instance of `TileInput` via:
//
//	TileArgs{...}
type TileInput interface {
	pulumi.Input

	ToTileOutput() TileOutput
	ToTileOutputWithContext(context.Context) TileOutput
}

// A single tile in the mosaic. The placement and size of the tile are configurable.
type TileArgs struct {
	// The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
	Height pulumi.IntPtrInput `pulumi:"height"`
	// The informational widget contained in the tile. For example an XyChart.
	Widget WidgetPtrInput `pulumi:"widget"`
	// The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
	Width pulumi.IntPtrInput `pulumi:"width"`
	// The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
	XPos pulumi.IntPtrInput `pulumi:"xPos"`
	// The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
	YPos pulumi.IntPtrInput `pulumi:"yPos"`
}

func (TileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Tile)(nil)).Elem()
}

func (i TileArgs) ToTileOutput() TileOutput {
	return i.ToTileOutputWithContext(context.Background())
}

func (i TileArgs) ToTileOutputWithContext(ctx context.Context) TileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TileOutput)
}

// TileArrayInput is an input type that accepts TileArray and TileArrayOutput values.
// You can construct a concrete instance of `TileArrayInput` via:
//
//	TileArray{ TileArgs{...} }
type TileArrayInput interface {
	pulumi.Input

	ToTileArrayOutput() TileArrayOutput
	ToTileArrayOutputWithContext(context.Context) TileArrayOutput
}

type TileArray []TileInput

func (TileArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Tile)(nil)).Elem()
}

func (i TileArray) ToTileArrayOutput() TileArrayOutput {
	return i.ToTileArrayOutputWithContext(context.Background())
}

func (i TileArray) ToTileArrayOutputWithContext(ctx context.Context) TileArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TileArrayOutput)
}

// A single tile in the mosaic. The placement and size of the tile are configurable.
type TileOutput struct{ *pulumi.OutputState }

func (TileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Tile)(nil)).Elem()
}

func (o TileOutput) ToTileOutput() TileOutput {
	return o
}

func (o TileOutput) ToTileOutputWithContext(ctx context.Context) TileOutput {
	return o
}

// The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
func (o TileOutput) Height() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Tile) *int { return v.Height }).(pulumi.IntPtrOutput)
}

// The informational widget contained in the tile. For example an XyChart.
func (o TileOutput) Widget() WidgetPtrOutput {
	return o.ApplyT(func(v Tile) *Widget { return v.Widget }).(WidgetPtrOutput)
}

// The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
func (o TileOutput) Width() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Tile) *int { return v.Width }).(pulumi.IntPtrOutput)
}

// The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
func (o TileOutput) XPos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Tile) *int { return v.XPos }).(pulumi.IntPtrOutput)
}

// The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
func (o TileOutput) YPos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Tile) *int { return v.YPos }).(pulumi.IntPtrOutput)
}

type TileArrayOutput struct{ *pulumi.OutputState }

func (TileArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Tile)(nil)).Elem()
}

func (o TileArrayOutput) ToTileArrayOutput() TileArrayOutput {
	return o
}

func (o TileArrayOutput) ToTileArrayOutputWithContext(ctx context.Context) TileArrayOutput {
	return o
}

func (o TileArrayOutput) Index(i pulumi.IntInput) TileOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Tile {
		return vs[0].([]Tile)[vs[1].(int)]
	}).(TileOutput)
}

// A single tile in the mosaic. The placement and size of the tile are configurable.
type TileResponse struct {
	// The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
	Height int `pulumi:"height"`
	// The informational widget contained in the tile. For example an XyChart.
	Widget WidgetResponse `pulumi:"widget"`
	// The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
	Width int `pulumi:"width"`
	// The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
	XPos int `pulumi:"xPos"`
	// The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
	YPos int `pulumi:"yPos"`
}

// A single tile in the mosaic. The placement and size of the tile are configurable.
type TileResponseOutput struct{ *pulumi.OutputState }

func (TileResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TileResponse)(nil)).Elem()
}

func (o TileResponseOutput) ToTileResponseOutput() TileResponseOutput {
	return o
}

func (o TileResponseOutput) ToTileResponseOutputWithContext(ctx context.Context) TileResponseOutput {
	return o
}

// The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
func (o TileResponseOutput) Height() pulumi.IntOutput {
	return o.ApplyT(func(v TileResponse) int { return v.Height }).(pulumi.IntOutput)
}

// The informational widget contained in the tile. For example an XyChart.
func (o TileResponseOutput) Widget() WidgetResponseOutput {
	return o.ApplyT(func(v TileResponse) WidgetResponse { return v.Widget }).(WidgetResponseOutput)
}

// The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
func (o TileResponseOutput) Width() pulumi.IntOutput {
	return o.ApplyT(func(v TileResponse) int { return v.Width }).(pulumi.IntOutput)
}

// The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
func (o TileResponseOutput) XPos() pulumi.IntOutput {
	return o.ApplyT(func(v TileResponse) int { return v.XPos }).(pulumi.IntOutput)
}

// The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
func (o TileResponseOutput) YPos() pulumi.IntOutput {
	return o.ApplyT(func(v TileResponse) int { return v.YPos }).(pulumi.IntOutput)
}

type TileResponseArrayOutput struct{ *pulumi.OutputState }

func (TileResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TileResponse)(nil)).Elem()
}

func (o TileResponseArrayOutput) ToTileResponseArrayOutput() TileResponseArrayOutput {
	return o
}

func (o TileResponseArrayOutput) ToTileResponseArrayOutputWithContext(ctx context.Context) TileResponseArrayOutput {
	return o
}

func (o TileResponseArrayOutput) Index(i pulumi.IntInput) TileResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TileResponse {
		return vs[0].([]TileResponse)[vs[1].(int)]
	}).(TileResponseOutput)
}

// A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method.
type TimeSeriesFilter struct {
	// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
	Aggregation *Aggregation `pulumi:"aggregation"`
	// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
	Filter string `pulumi:"filter"`
	// Ranking based time series filter.
	PickTimeSeriesFilter *PickTimeSeriesFilter `pulumi:"pickTimeSeriesFilter"`
	// Apply a second aggregation after aggregation is applied.
	SecondaryAggregation *Aggregation `pulumi:"secondaryAggregation"`
	// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	//
	// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	StatisticalTimeSeriesFilter *StatisticalTimeSeriesFilter `pulumi:"statisticalTimeSeriesFilter"`
}

// TimeSeriesFilterInput is an input type that accepts TimeSeriesFilterArgs and TimeSeriesFilterOutput values.
// You can construct a concrete instance of `TimeSeriesFilterInput` via:
//
//	TimeSeriesFilterArgs{...}
type TimeSeriesFilterInput interface {
	pulumi.Input

	ToTimeSeriesFilterOutput() TimeSeriesFilterOutput
	ToTimeSeriesFilterOutputWithContext(context.Context) TimeSeriesFilterOutput
}

// A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method.
type TimeSeriesFilterArgs struct {
	// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
	Aggregation AggregationPtrInput `pulumi:"aggregation"`
	// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
	Filter pulumi.StringInput `pulumi:"filter"`
	// Ranking based time series filter.
	PickTimeSeriesFilter PickTimeSeriesFilterPtrInput `pulumi:"pickTimeSeriesFilter"`
	// Apply a second aggregation after aggregation is applied.
	SecondaryAggregation AggregationPtrInput `pulumi:"secondaryAggregation"`
	// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	//
	// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	StatisticalTimeSeriesFilter StatisticalTimeSeriesFilterPtrInput `pulumi:"statisticalTimeSeriesFilter"`
}

func (TimeSeriesFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesFilter)(nil)).Elem()
}

func (i TimeSeriesFilterArgs) ToTimeSeriesFilterOutput() TimeSeriesFilterOutput {
	return i.ToTimeSeriesFilterOutputWithContext(context.Background())
}

func (i TimeSeriesFilterArgs) ToTimeSeriesFilterOutputWithContext(ctx context.Context) TimeSeriesFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesFilterOutput)
}

func (i TimeSeriesFilterArgs) ToTimeSeriesFilterPtrOutput() TimeSeriesFilterPtrOutput {
	return i.ToTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (i TimeSeriesFilterArgs) ToTimeSeriesFilterPtrOutputWithContext(ctx context.Context) TimeSeriesFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesFilterOutput).ToTimeSeriesFilterPtrOutputWithContext(ctx)
}

// TimeSeriesFilterPtrInput is an input type that accepts TimeSeriesFilterArgs, TimeSeriesFilterPtr and TimeSeriesFilterPtrOutput values.
// You can construct a concrete instance of `TimeSeriesFilterPtrInput` via:
//
//	        TimeSeriesFilterArgs{...}
//
//	or:
//
//	        nil
type TimeSeriesFilterPtrInput interface {
	pulumi.Input

	ToTimeSeriesFilterPtrOutput() TimeSeriesFilterPtrOutput
	ToTimeSeriesFilterPtrOutputWithContext(context.Context) TimeSeriesFilterPtrOutput
}

type timeSeriesFilterPtrType TimeSeriesFilterArgs

func TimeSeriesFilterPtr(v *TimeSeriesFilterArgs) TimeSeriesFilterPtrInput {
	return (*timeSeriesFilterPtrType)(v)
}

func (*timeSeriesFilterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesFilter)(nil)).Elem()
}

func (i *timeSeriesFilterPtrType) ToTimeSeriesFilterPtrOutput() TimeSeriesFilterPtrOutput {
	return i.ToTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (i *timeSeriesFilterPtrType) ToTimeSeriesFilterPtrOutputWithContext(ctx context.Context) TimeSeriesFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesFilterPtrOutput)
}

// A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method.
type TimeSeriesFilterOutput struct{ *pulumi.OutputState }

func (TimeSeriesFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesFilter)(nil)).Elem()
}

func (o TimeSeriesFilterOutput) ToTimeSeriesFilterOutput() TimeSeriesFilterOutput {
	return o
}

func (o TimeSeriesFilterOutput) ToTimeSeriesFilterOutputWithContext(ctx context.Context) TimeSeriesFilterOutput {
	return o
}

func (o TimeSeriesFilterOutput) ToTimeSeriesFilterPtrOutput() TimeSeriesFilterPtrOutput {
	return o.ToTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (o TimeSeriesFilterOutput) ToTimeSeriesFilterPtrOutputWithContext(ctx context.Context) TimeSeriesFilterPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TimeSeriesFilter) *TimeSeriesFilter {
		return &v
	}).(TimeSeriesFilterPtrOutput)
}

// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
func (o TimeSeriesFilterOutput) Aggregation() AggregationPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilter) *Aggregation { return v.Aggregation }).(AggregationPtrOutput)
}

// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
func (o TimeSeriesFilterOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesFilter) string { return v.Filter }).(pulumi.StringOutput)
}

// Ranking based time series filter.
func (o TimeSeriesFilterOutput) PickTimeSeriesFilter() PickTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilter) *PickTimeSeriesFilter { return v.PickTimeSeriesFilter }).(PickTimeSeriesFilterPtrOutput)
}

// Apply a second aggregation after aggregation is applied.
func (o TimeSeriesFilterOutput) SecondaryAggregation() AggregationPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilter) *Aggregation { return v.SecondaryAggregation }).(AggregationPtrOutput)
}

// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
//
// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
func (o TimeSeriesFilterOutput) StatisticalTimeSeriesFilter() StatisticalTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilter) *StatisticalTimeSeriesFilter { return v.StatisticalTimeSeriesFilter }).(StatisticalTimeSeriesFilterPtrOutput)
}

type TimeSeriesFilterPtrOutput struct{ *pulumi.OutputState }

func (TimeSeriesFilterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesFilter)(nil)).Elem()
}

func (o TimeSeriesFilterPtrOutput) ToTimeSeriesFilterPtrOutput() TimeSeriesFilterPtrOutput {
	return o
}

func (o TimeSeriesFilterPtrOutput) ToTimeSeriesFilterPtrOutputWithContext(ctx context.Context) TimeSeriesFilterPtrOutput {
	return o
}

func (o TimeSeriesFilterPtrOutput) Elem() TimeSeriesFilterOutput {
	return o.ApplyT(func(v *TimeSeriesFilter) TimeSeriesFilter {
		if v != nil {
			return *v
		}
		var ret TimeSeriesFilter
		return ret
	}).(TimeSeriesFilterOutput)
}

// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
func (o TimeSeriesFilterPtrOutput) Aggregation() AggregationPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilter) *Aggregation {
		if v == nil {
			return nil
		}
		return v.Aggregation
	}).(AggregationPtrOutput)
}

// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
func (o TimeSeriesFilterPtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilter) *string {
		if v == nil {
			return nil
		}
		return &v.Filter
	}).(pulumi.StringPtrOutput)
}

// Ranking based time series filter.
func (o TimeSeriesFilterPtrOutput) PickTimeSeriesFilter() PickTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilter) *PickTimeSeriesFilter {
		if v == nil {
			return nil
		}
		return v.PickTimeSeriesFilter
	}).(PickTimeSeriesFilterPtrOutput)
}

// Apply a second aggregation after aggregation is applied.
func (o TimeSeriesFilterPtrOutput) SecondaryAggregation() AggregationPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilter) *Aggregation {
		if v == nil {
			return nil
		}
		return v.SecondaryAggregation
	}).(AggregationPtrOutput)
}

// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
//
// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
func (o TimeSeriesFilterPtrOutput) StatisticalTimeSeriesFilter() StatisticalTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilter) *StatisticalTimeSeriesFilter {
		if v == nil {
			return nil
		}
		return v.StatisticalTimeSeriesFilter
	}).(StatisticalTimeSeriesFilterPtrOutput)
}

// A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series.
type TimeSeriesFilterRatio struct {
	// The denominator of the ratio.
	Denominator *RatioPart `pulumi:"denominator"`
	// The numerator of the ratio.
	Numerator *RatioPart `pulumi:"numerator"`
	// Ranking based time series filter.
	PickTimeSeriesFilter *PickTimeSeriesFilter `pulumi:"pickTimeSeriesFilter"`
	// Apply a second aggregation after the ratio is computed.
	SecondaryAggregation *Aggregation `pulumi:"secondaryAggregation"`
	// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	//
	// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	StatisticalTimeSeriesFilter *StatisticalTimeSeriesFilter `pulumi:"statisticalTimeSeriesFilter"`
}

// TimeSeriesFilterRatioInput is an input type that accepts TimeSeriesFilterRatioArgs and TimeSeriesFilterRatioOutput values.
// You can construct a concrete instance of `TimeSeriesFilterRatioInput` via:
//
//	TimeSeriesFilterRatioArgs{...}
type TimeSeriesFilterRatioInput interface {
	pulumi.Input

	ToTimeSeriesFilterRatioOutput() TimeSeriesFilterRatioOutput
	ToTimeSeriesFilterRatioOutputWithContext(context.Context) TimeSeriesFilterRatioOutput
}

// A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series.
type TimeSeriesFilterRatioArgs struct {
	// The denominator of the ratio.
	Denominator RatioPartPtrInput `pulumi:"denominator"`
	// The numerator of the ratio.
	Numerator RatioPartPtrInput `pulumi:"numerator"`
	// Ranking based time series filter.
	PickTimeSeriesFilter PickTimeSeriesFilterPtrInput `pulumi:"pickTimeSeriesFilter"`
	// Apply a second aggregation after the ratio is computed.
	SecondaryAggregation AggregationPtrInput `pulumi:"secondaryAggregation"`
	// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	//
	// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	StatisticalTimeSeriesFilter StatisticalTimeSeriesFilterPtrInput `pulumi:"statisticalTimeSeriesFilter"`
}

func (TimeSeriesFilterRatioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesFilterRatio)(nil)).Elem()
}

func (i TimeSeriesFilterRatioArgs) ToTimeSeriesFilterRatioOutput() TimeSeriesFilterRatioOutput {
	return i.ToTimeSeriesFilterRatioOutputWithContext(context.Background())
}

func (i TimeSeriesFilterRatioArgs) ToTimeSeriesFilterRatioOutputWithContext(ctx context.Context) TimeSeriesFilterRatioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesFilterRatioOutput)
}

func (i TimeSeriesFilterRatioArgs) ToTimeSeriesFilterRatioPtrOutput() TimeSeriesFilterRatioPtrOutput {
	return i.ToTimeSeriesFilterRatioPtrOutputWithContext(context.Background())
}

func (i TimeSeriesFilterRatioArgs) ToTimeSeriesFilterRatioPtrOutputWithContext(ctx context.Context) TimeSeriesFilterRatioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesFilterRatioOutput).ToTimeSeriesFilterRatioPtrOutputWithContext(ctx)
}

// TimeSeriesFilterRatioPtrInput is an input type that accepts TimeSeriesFilterRatioArgs, TimeSeriesFilterRatioPtr and TimeSeriesFilterRatioPtrOutput values.
// You can construct a concrete instance of `TimeSeriesFilterRatioPtrInput` via:
//
//	        TimeSeriesFilterRatioArgs{...}
//
//	or:
//
//	        nil
type TimeSeriesFilterRatioPtrInput interface {
	pulumi.Input

	ToTimeSeriesFilterRatioPtrOutput() TimeSeriesFilterRatioPtrOutput
	ToTimeSeriesFilterRatioPtrOutputWithContext(context.Context) TimeSeriesFilterRatioPtrOutput
}

type timeSeriesFilterRatioPtrType TimeSeriesFilterRatioArgs

func TimeSeriesFilterRatioPtr(v *TimeSeriesFilterRatioArgs) TimeSeriesFilterRatioPtrInput {
	return (*timeSeriesFilterRatioPtrType)(v)
}

func (*timeSeriesFilterRatioPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesFilterRatio)(nil)).Elem()
}

func (i *timeSeriesFilterRatioPtrType) ToTimeSeriesFilterRatioPtrOutput() TimeSeriesFilterRatioPtrOutput {
	return i.ToTimeSeriesFilterRatioPtrOutputWithContext(context.Background())
}

func (i *timeSeriesFilterRatioPtrType) ToTimeSeriesFilterRatioPtrOutputWithContext(ctx context.Context) TimeSeriesFilterRatioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesFilterRatioPtrOutput)
}

// A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series.
type TimeSeriesFilterRatioOutput struct{ *pulumi.OutputState }

func (TimeSeriesFilterRatioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesFilterRatio)(nil)).Elem()
}

func (o TimeSeriesFilterRatioOutput) ToTimeSeriesFilterRatioOutput() TimeSeriesFilterRatioOutput {
	return o
}

func (o TimeSeriesFilterRatioOutput) ToTimeSeriesFilterRatioOutputWithContext(ctx context.Context) TimeSeriesFilterRatioOutput {
	return o
}

func (o TimeSeriesFilterRatioOutput) ToTimeSeriesFilterRatioPtrOutput() TimeSeriesFilterRatioPtrOutput {
	return o.ToTimeSeriesFilterRatioPtrOutputWithContext(context.Background())
}

func (o TimeSeriesFilterRatioOutput) ToTimeSeriesFilterRatioPtrOutputWithContext(ctx context.Context) TimeSeriesFilterRatioPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TimeSeriesFilterRatio) *TimeSeriesFilterRatio {
		return &v
	}).(TimeSeriesFilterRatioPtrOutput)
}

// The denominator of the ratio.
func (o TimeSeriesFilterRatioOutput) Denominator() RatioPartPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatio) *RatioPart { return v.Denominator }).(RatioPartPtrOutput)
}

// The numerator of the ratio.
func (o TimeSeriesFilterRatioOutput) Numerator() RatioPartPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatio) *RatioPart { return v.Numerator }).(RatioPartPtrOutput)
}

// Ranking based time series filter.
func (o TimeSeriesFilterRatioOutput) PickTimeSeriesFilter() PickTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatio) *PickTimeSeriesFilter { return v.PickTimeSeriesFilter }).(PickTimeSeriesFilterPtrOutput)
}

// Apply a second aggregation after the ratio is computed.
func (o TimeSeriesFilterRatioOutput) SecondaryAggregation() AggregationPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatio) *Aggregation { return v.SecondaryAggregation }).(AggregationPtrOutput)
}

// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
//
// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
func (o TimeSeriesFilterRatioOutput) StatisticalTimeSeriesFilter() StatisticalTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatio) *StatisticalTimeSeriesFilter { return v.StatisticalTimeSeriesFilter }).(StatisticalTimeSeriesFilterPtrOutput)
}

type TimeSeriesFilterRatioPtrOutput struct{ *pulumi.OutputState }

func (TimeSeriesFilterRatioPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesFilterRatio)(nil)).Elem()
}

func (o TimeSeriesFilterRatioPtrOutput) ToTimeSeriesFilterRatioPtrOutput() TimeSeriesFilterRatioPtrOutput {
	return o
}

func (o TimeSeriesFilterRatioPtrOutput) ToTimeSeriesFilterRatioPtrOutputWithContext(ctx context.Context) TimeSeriesFilterRatioPtrOutput {
	return o
}

func (o TimeSeriesFilterRatioPtrOutput) Elem() TimeSeriesFilterRatioOutput {
	return o.ApplyT(func(v *TimeSeriesFilterRatio) TimeSeriesFilterRatio {
		if v != nil {
			return *v
		}
		var ret TimeSeriesFilterRatio
		return ret
	}).(TimeSeriesFilterRatioOutput)
}

// The denominator of the ratio.
func (o TimeSeriesFilterRatioPtrOutput) Denominator() RatioPartPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilterRatio) *RatioPart {
		if v == nil {
			return nil
		}
		return v.Denominator
	}).(RatioPartPtrOutput)
}

// The numerator of the ratio.
func (o TimeSeriesFilterRatioPtrOutput) Numerator() RatioPartPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilterRatio) *RatioPart {
		if v == nil {
			return nil
		}
		return v.Numerator
	}).(RatioPartPtrOutput)
}

// Ranking based time series filter.
func (o TimeSeriesFilterRatioPtrOutput) PickTimeSeriesFilter() PickTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilterRatio) *PickTimeSeriesFilter {
		if v == nil {
			return nil
		}
		return v.PickTimeSeriesFilter
	}).(PickTimeSeriesFilterPtrOutput)
}

// Apply a second aggregation after the ratio is computed.
func (o TimeSeriesFilterRatioPtrOutput) SecondaryAggregation() AggregationPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilterRatio) *Aggregation {
		if v == nil {
			return nil
		}
		return v.SecondaryAggregation
	}).(AggregationPtrOutput)
}

// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
//
// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
func (o TimeSeriesFilterRatioPtrOutput) StatisticalTimeSeriesFilter() StatisticalTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilterRatio) *StatisticalTimeSeriesFilter {
		if v == nil {
			return nil
		}
		return v.StatisticalTimeSeriesFilter
	}).(StatisticalTimeSeriesFilterPtrOutput)
}

// A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series.
type TimeSeriesFilterRatioResponse struct {
	// The denominator of the ratio.
	Denominator RatioPartResponse `pulumi:"denominator"`
	// The numerator of the ratio.
	Numerator RatioPartResponse `pulumi:"numerator"`
	// Ranking based time series filter.
	PickTimeSeriesFilter PickTimeSeriesFilterResponse `pulumi:"pickTimeSeriesFilter"`
	// Apply a second aggregation after the ratio is computed.
	SecondaryAggregation AggregationResponse `pulumi:"secondaryAggregation"`
	// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	//
	// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	StatisticalTimeSeriesFilter StatisticalTimeSeriesFilterResponse `pulumi:"statisticalTimeSeriesFilter"`
}

// A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series.
type TimeSeriesFilterRatioResponseOutput struct{ *pulumi.OutputState }

func (TimeSeriesFilterRatioResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesFilterRatioResponse)(nil)).Elem()
}

func (o TimeSeriesFilterRatioResponseOutput) ToTimeSeriesFilterRatioResponseOutput() TimeSeriesFilterRatioResponseOutput {
	return o
}

func (o TimeSeriesFilterRatioResponseOutput) ToTimeSeriesFilterRatioResponseOutputWithContext(ctx context.Context) TimeSeriesFilterRatioResponseOutput {
	return o
}

// The denominator of the ratio.
func (o TimeSeriesFilterRatioResponseOutput) Denominator() RatioPartResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatioResponse) RatioPartResponse { return v.Denominator }).(RatioPartResponseOutput)
}

// The numerator of the ratio.
func (o TimeSeriesFilterRatioResponseOutput) Numerator() RatioPartResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatioResponse) RatioPartResponse { return v.Numerator }).(RatioPartResponseOutput)
}

// Ranking based time series filter.
func (o TimeSeriesFilterRatioResponseOutput) PickTimeSeriesFilter() PickTimeSeriesFilterResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatioResponse) PickTimeSeriesFilterResponse { return v.PickTimeSeriesFilter }).(PickTimeSeriesFilterResponseOutput)
}

// Apply a second aggregation after the ratio is computed.
func (o TimeSeriesFilterRatioResponseOutput) SecondaryAggregation() AggregationResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatioResponse) AggregationResponse { return v.SecondaryAggregation }).(AggregationResponseOutput)
}

// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
//
// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
func (o TimeSeriesFilterRatioResponseOutput) StatisticalTimeSeriesFilter() StatisticalTimeSeriesFilterResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatioResponse) StatisticalTimeSeriesFilterResponse {
		return v.StatisticalTimeSeriesFilter
	}).(StatisticalTimeSeriesFilterResponseOutput)
}

// A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method.
type TimeSeriesFilterResponse struct {
	// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
	Aggregation AggregationResponse `pulumi:"aggregation"`
	// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
	Filter string `pulumi:"filter"`
	// Ranking based time series filter.
	PickTimeSeriesFilter PickTimeSeriesFilterResponse `pulumi:"pickTimeSeriesFilter"`
	// Apply a second aggregation after aggregation is applied.
	SecondaryAggregation AggregationResponse `pulumi:"secondaryAggregation"`
	// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	//
	// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	StatisticalTimeSeriesFilter StatisticalTimeSeriesFilterResponse `pulumi:"statisticalTimeSeriesFilter"`
}

// A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method.
type TimeSeriesFilterResponseOutput struct{ *pulumi.OutputState }

func (TimeSeriesFilterResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesFilterResponse)(nil)).Elem()
}

func (o TimeSeriesFilterResponseOutput) ToTimeSeriesFilterResponseOutput() TimeSeriesFilterResponseOutput {
	return o
}

func (o TimeSeriesFilterResponseOutput) ToTimeSeriesFilterResponseOutputWithContext(ctx context.Context) TimeSeriesFilterResponseOutput {
	return o
}

// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
func (o TimeSeriesFilterResponseOutput) Aggregation() AggregationResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterResponse) AggregationResponse { return v.Aggregation }).(AggregationResponseOutput)
}

// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
func (o TimeSeriesFilterResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesFilterResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// Ranking based time series filter.
func (o TimeSeriesFilterResponseOutput) PickTimeSeriesFilter() PickTimeSeriesFilterResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterResponse) PickTimeSeriesFilterResponse { return v.PickTimeSeriesFilter }).(PickTimeSeriesFilterResponseOutput)
}

// Apply a second aggregation after aggregation is applied.
func (o TimeSeriesFilterResponseOutput) SecondaryAggregation() AggregationResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterResponse) AggregationResponse { return v.SecondaryAggregation }).(AggregationResponseOutput)
}

// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
//
// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
func (o TimeSeriesFilterResponseOutput) StatisticalTimeSeriesFilter() StatisticalTimeSeriesFilterResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterResponse) StatisticalTimeSeriesFilterResponse {
		return v.StatisticalTimeSeriesFilter
	}).(StatisticalTimeSeriesFilterResponseOutput)
}

// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
type TimeSeriesQuery struct {
	// A query used to fetch time series with PromQL.
	PrometheusQuery *string `pulumi:"prometheusQuery"`
	// Filter parameters to fetch time series.
	TimeSeriesFilter *TimeSeriesFilter `pulumi:"timeSeriesFilter"`
	// Parameters to fetch a ratio between two time series filters.
	TimeSeriesFilterRatio *TimeSeriesFilterRatio `pulumi:"timeSeriesFilterRatio"`
	// A query used to fetch time series with MQL.
	TimeSeriesQueryLanguage *string `pulumi:"timeSeriesQueryLanguage"`
	// The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
	UnitOverride *string `pulumi:"unitOverride"`
}

// TimeSeriesQueryInput is an input type that accepts TimeSeriesQueryArgs and TimeSeriesQueryOutput values.
// You can construct a concrete instance of `TimeSeriesQueryInput` via:
//
//	TimeSeriesQueryArgs{...}
type TimeSeriesQueryInput interface {
	pulumi.Input

	ToTimeSeriesQueryOutput() TimeSeriesQueryOutput
	ToTimeSeriesQueryOutputWithContext(context.Context) TimeSeriesQueryOutput
}

// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
type TimeSeriesQueryArgs struct {
	// A query used to fetch time series with PromQL.
	PrometheusQuery pulumi.StringPtrInput `pulumi:"prometheusQuery"`
	// Filter parameters to fetch time series.
	TimeSeriesFilter TimeSeriesFilterPtrInput `pulumi:"timeSeriesFilter"`
	// Parameters to fetch a ratio between two time series filters.
	TimeSeriesFilterRatio TimeSeriesFilterRatioPtrInput `pulumi:"timeSeriesFilterRatio"`
	// A query used to fetch time series with MQL.
	TimeSeriesQueryLanguage pulumi.StringPtrInput `pulumi:"timeSeriesQueryLanguage"`
	// The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
	UnitOverride pulumi.StringPtrInput `pulumi:"unitOverride"`
}

func (TimeSeriesQueryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesQuery)(nil)).Elem()
}

func (i TimeSeriesQueryArgs) ToTimeSeriesQueryOutput() TimeSeriesQueryOutput {
	return i.ToTimeSeriesQueryOutputWithContext(context.Background())
}

func (i TimeSeriesQueryArgs) ToTimeSeriesQueryOutputWithContext(ctx context.Context) TimeSeriesQueryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesQueryOutput)
}

func (i TimeSeriesQueryArgs) ToTimeSeriesQueryPtrOutput() TimeSeriesQueryPtrOutput {
	return i.ToTimeSeriesQueryPtrOutputWithContext(context.Background())
}

func (i TimeSeriesQueryArgs) ToTimeSeriesQueryPtrOutputWithContext(ctx context.Context) TimeSeriesQueryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesQueryOutput).ToTimeSeriesQueryPtrOutputWithContext(ctx)
}

// TimeSeriesQueryPtrInput is an input type that accepts TimeSeriesQueryArgs, TimeSeriesQueryPtr and TimeSeriesQueryPtrOutput values.
// You can construct a concrete instance of `TimeSeriesQueryPtrInput` via:
//
//	        TimeSeriesQueryArgs{...}
//
//	or:
//
//	        nil
type TimeSeriesQueryPtrInput interface {
	pulumi.Input

	ToTimeSeriesQueryPtrOutput() TimeSeriesQueryPtrOutput
	ToTimeSeriesQueryPtrOutputWithContext(context.Context) TimeSeriesQueryPtrOutput
}

type timeSeriesQueryPtrType TimeSeriesQueryArgs

func TimeSeriesQueryPtr(v *TimeSeriesQueryArgs) TimeSeriesQueryPtrInput {
	return (*timeSeriesQueryPtrType)(v)
}

func (*timeSeriesQueryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesQuery)(nil)).Elem()
}

func (i *timeSeriesQueryPtrType) ToTimeSeriesQueryPtrOutput() TimeSeriesQueryPtrOutput {
	return i.ToTimeSeriesQueryPtrOutputWithContext(context.Background())
}

func (i *timeSeriesQueryPtrType) ToTimeSeriesQueryPtrOutputWithContext(ctx context.Context) TimeSeriesQueryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesQueryPtrOutput)
}

// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
type TimeSeriesQueryOutput struct{ *pulumi.OutputState }

func (TimeSeriesQueryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesQuery)(nil)).Elem()
}

func (o TimeSeriesQueryOutput) ToTimeSeriesQueryOutput() TimeSeriesQueryOutput {
	return o
}

func (o TimeSeriesQueryOutput) ToTimeSeriesQueryOutputWithContext(ctx context.Context) TimeSeriesQueryOutput {
	return o
}

func (o TimeSeriesQueryOutput) ToTimeSeriesQueryPtrOutput() TimeSeriesQueryPtrOutput {
	return o.ToTimeSeriesQueryPtrOutputWithContext(context.Background())
}

func (o TimeSeriesQueryOutput) ToTimeSeriesQueryPtrOutputWithContext(ctx context.Context) TimeSeriesQueryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TimeSeriesQuery) *TimeSeriesQuery {
		return &v
	}).(TimeSeriesQueryPtrOutput)
}

// A query used to fetch time series with PromQL.
func (o TimeSeriesQueryOutput) PrometheusQuery() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesQuery) *string { return v.PrometheusQuery }).(pulumi.StringPtrOutput)
}

// Filter parameters to fetch time series.
func (o TimeSeriesQueryOutput) TimeSeriesFilter() TimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v TimeSeriesQuery) *TimeSeriesFilter { return v.TimeSeriesFilter }).(TimeSeriesFilterPtrOutput)
}

// Parameters to fetch a ratio between two time series filters.
func (o TimeSeriesQueryOutput) TimeSeriesFilterRatio() TimeSeriesFilterRatioPtrOutput {
	return o.ApplyT(func(v TimeSeriesQuery) *TimeSeriesFilterRatio { return v.TimeSeriesFilterRatio }).(TimeSeriesFilterRatioPtrOutput)
}

// A query used to fetch time series with MQL.
func (o TimeSeriesQueryOutput) TimeSeriesQueryLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesQuery) *string { return v.TimeSeriesQueryLanguage }).(pulumi.StringPtrOutput)
}

// The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
func (o TimeSeriesQueryOutput) UnitOverride() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesQuery) *string { return v.UnitOverride }).(pulumi.StringPtrOutput)
}

type TimeSeriesQueryPtrOutput struct{ *pulumi.OutputState }

func (TimeSeriesQueryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesQuery)(nil)).Elem()
}

func (o TimeSeriesQueryPtrOutput) ToTimeSeriesQueryPtrOutput() TimeSeriesQueryPtrOutput {
	return o
}

func (o TimeSeriesQueryPtrOutput) ToTimeSeriesQueryPtrOutputWithContext(ctx context.Context) TimeSeriesQueryPtrOutput {
	return o
}

func (o TimeSeriesQueryPtrOutput) Elem() TimeSeriesQueryOutput {
	return o.ApplyT(func(v *TimeSeriesQuery) TimeSeriesQuery {
		if v != nil {
			return *v
		}
		var ret TimeSeriesQuery
		return ret
	}).(TimeSeriesQueryOutput)
}

// A query used to fetch time series with PromQL.
func (o TimeSeriesQueryPtrOutput) PrometheusQuery() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesQuery) *string {
		if v == nil {
			return nil
		}
		return v.PrometheusQuery
	}).(pulumi.StringPtrOutput)
}

// Filter parameters to fetch time series.
func (o TimeSeriesQueryPtrOutput) TimeSeriesFilter() TimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v *TimeSeriesQuery) *TimeSeriesFilter {
		if v == nil {
			return nil
		}
		return v.TimeSeriesFilter
	}).(TimeSeriesFilterPtrOutput)
}

// Parameters to fetch a ratio between two time series filters.
func (o TimeSeriesQueryPtrOutput) TimeSeriesFilterRatio() TimeSeriesFilterRatioPtrOutput {
	return o.ApplyT(func(v *TimeSeriesQuery) *TimeSeriesFilterRatio {
		if v == nil {
			return nil
		}
		return v.TimeSeriesFilterRatio
	}).(TimeSeriesFilterRatioPtrOutput)
}

// A query used to fetch time series with MQL.
func (o TimeSeriesQueryPtrOutput) TimeSeriesQueryLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesQuery) *string {
		if v == nil {
			return nil
		}
		return v.TimeSeriesQueryLanguage
	}).(pulumi.StringPtrOutput)
}

// The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
func (o TimeSeriesQueryPtrOutput) UnitOverride() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesQuery) *string {
		if v == nil {
			return nil
		}
		return v.UnitOverride
	}).(pulumi.StringPtrOutput)
}

// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
type TimeSeriesQueryResponse struct {
	// A query used to fetch time series with PromQL.
	PrometheusQuery string `pulumi:"prometheusQuery"`
	// Filter parameters to fetch time series.
	TimeSeriesFilter TimeSeriesFilterResponse `pulumi:"timeSeriesFilter"`
	// Parameters to fetch a ratio between two time series filters.
	TimeSeriesFilterRatio TimeSeriesFilterRatioResponse `pulumi:"timeSeriesFilterRatio"`
	// A query used to fetch time series with MQL.
	TimeSeriesQueryLanguage string `pulumi:"timeSeriesQueryLanguage"`
	// The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
	UnitOverride string `pulumi:"unitOverride"`
}

// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
type TimeSeriesQueryResponseOutput struct{ *pulumi.OutputState }

func (TimeSeriesQueryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesQueryResponse)(nil)).Elem()
}

func (o TimeSeriesQueryResponseOutput) ToTimeSeriesQueryResponseOutput() TimeSeriesQueryResponseOutput {
	return o
}

func (o TimeSeriesQueryResponseOutput) ToTimeSeriesQueryResponseOutputWithContext(ctx context.Context) TimeSeriesQueryResponseOutput {
	return o
}

// A query used to fetch time series with PromQL.
func (o TimeSeriesQueryResponseOutput) PrometheusQuery() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesQueryResponse) string { return v.PrometheusQuery }).(pulumi.StringOutput)
}

// Filter parameters to fetch time series.
func (o TimeSeriesQueryResponseOutput) TimeSeriesFilter() TimeSeriesFilterResponseOutput {
	return o.ApplyT(func(v TimeSeriesQueryResponse) TimeSeriesFilterResponse { return v.TimeSeriesFilter }).(TimeSeriesFilterResponseOutput)
}

// Parameters to fetch a ratio between two time series filters.
func (o TimeSeriesQueryResponseOutput) TimeSeriesFilterRatio() TimeSeriesFilterRatioResponseOutput {
	return o.ApplyT(func(v TimeSeriesQueryResponse) TimeSeriesFilterRatioResponse { return v.TimeSeriesFilterRatio }).(TimeSeriesFilterRatioResponseOutput)
}

// A query used to fetch time series with MQL.
func (o TimeSeriesQueryResponseOutput) TimeSeriesQueryLanguage() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesQueryResponse) string { return v.TimeSeriesQueryLanguage }).(pulumi.StringOutput)
}

// The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
func (o TimeSeriesQueryResponseOutput) UnitOverride() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesQueryResponse) string { return v.UnitOverride }).(pulumi.StringOutput)
}

// A table that displays time series data.
type TimeSeriesTable struct {
	// Optional. The list of the persistent column settings for the table.
	ColumnSettings []ColumnSettings `pulumi:"columnSettings"`
	// The data displayed in this table.
	DataSets []TableDataSet `pulumi:"dataSets"`
	// Optional. Store rendering strategy
	MetricVisualization *TimeSeriesTableMetricVisualization `pulumi:"metricVisualization"`
}

// TimeSeriesTableInput is an input type that accepts TimeSeriesTableArgs and TimeSeriesTableOutput values.
// You can construct a concrete instance of `TimeSeriesTableInput` via:
//
//	TimeSeriesTableArgs{...}
type TimeSeriesTableInput interface {
	pulumi.Input

	ToTimeSeriesTableOutput() TimeSeriesTableOutput
	ToTimeSeriesTableOutputWithContext(context.Context) TimeSeriesTableOutput
}

// A table that displays time series data.
type TimeSeriesTableArgs struct {
	// Optional. The list of the persistent column settings for the table.
	ColumnSettings ColumnSettingsArrayInput `pulumi:"columnSettings"`
	// The data displayed in this table.
	DataSets TableDataSetArrayInput `pulumi:"dataSets"`
	// Optional. Store rendering strategy
	MetricVisualization TimeSeriesTableMetricVisualizationPtrInput `pulumi:"metricVisualization"`
}

func (TimeSeriesTableArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesTable)(nil)).Elem()
}

func (i TimeSeriesTableArgs) ToTimeSeriesTableOutput() TimeSeriesTableOutput {
	return i.ToTimeSeriesTableOutputWithContext(context.Background())
}

func (i TimeSeriesTableArgs) ToTimeSeriesTableOutputWithContext(ctx context.Context) TimeSeriesTableOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesTableOutput)
}

func (i TimeSeriesTableArgs) ToTimeSeriesTablePtrOutput() TimeSeriesTablePtrOutput {
	return i.ToTimeSeriesTablePtrOutputWithContext(context.Background())
}

func (i TimeSeriesTableArgs) ToTimeSeriesTablePtrOutputWithContext(ctx context.Context) TimeSeriesTablePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesTableOutput).ToTimeSeriesTablePtrOutputWithContext(ctx)
}

// TimeSeriesTablePtrInput is an input type that accepts TimeSeriesTableArgs, TimeSeriesTablePtr and TimeSeriesTablePtrOutput values.
// You can construct a concrete instance of `TimeSeriesTablePtrInput` via:
//
//	        TimeSeriesTableArgs{...}
//
//	or:
//
//	        nil
type TimeSeriesTablePtrInput interface {
	pulumi.Input

	ToTimeSeriesTablePtrOutput() TimeSeriesTablePtrOutput
	ToTimeSeriesTablePtrOutputWithContext(context.Context) TimeSeriesTablePtrOutput
}

type timeSeriesTablePtrType TimeSeriesTableArgs

func TimeSeriesTablePtr(v *TimeSeriesTableArgs) TimeSeriesTablePtrInput {
	return (*timeSeriesTablePtrType)(v)
}

func (*timeSeriesTablePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesTable)(nil)).Elem()
}

func (i *timeSeriesTablePtrType) ToTimeSeriesTablePtrOutput() TimeSeriesTablePtrOutput {
	return i.ToTimeSeriesTablePtrOutputWithContext(context.Background())
}

func (i *timeSeriesTablePtrType) ToTimeSeriesTablePtrOutputWithContext(ctx context.Context) TimeSeriesTablePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesTablePtrOutput)
}

// A table that displays time series data.
type TimeSeriesTableOutput struct{ *pulumi.OutputState }

func (TimeSeriesTableOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesTable)(nil)).Elem()
}

func (o TimeSeriesTableOutput) ToTimeSeriesTableOutput() TimeSeriesTableOutput {
	return o
}

func (o TimeSeriesTableOutput) ToTimeSeriesTableOutputWithContext(ctx context.Context) TimeSeriesTableOutput {
	return o
}

func (o TimeSeriesTableOutput) ToTimeSeriesTablePtrOutput() TimeSeriesTablePtrOutput {
	return o.ToTimeSeriesTablePtrOutputWithContext(context.Background())
}

func (o TimeSeriesTableOutput) ToTimeSeriesTablePtrOutputWithContext(ctx context.Context) TimeSeriesTablePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TimeSeriesTable) *TimeSeriesTable {
		return &v
	}).(TimeSeriesTablePtrOutput)
}

// Optional. The list of the persistent column settings for the table.
func (o TimeSeriesTableOutput) ColumnSettings() ColumnSettingsArrayOutput {
	return o.ApplyT(func(v TimeSeriesTable) []ColumnSettings { return v.ColumnSettings }).(ColumnSettingsArrayOutput)
}

// The data displayed in this table.
func (o TimeSeriesTableOutput) DataSets() TableDataSetArrayOutput {
	return o.ApplyT(func(v TimeSeriesTable) []TableDataSet { return v.DataSets }).(TableDataSetArrayOutput)
}

// Optional. Store rendering strategy
func (o TimeSeriesTableOutput) MetricVisualization() TimeSeriesTableMetricVisualizationPtrOutput {
	return o.ApplyT(func(v TimeSeriesTable) *TimeSeriesTableMetricVisualization { return v.MetricVisualization }).(TimeSeriesTableMetricVisualizationPtrOutput)
}

type TimeSeriesTablePtrOutput struct{ *pulumi.OutputState }

func (TimeSeriesTablePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesTable)(nil)).Elem()
}

func (o TimeSeriesTablePtrOutput) ToTimeSeriesTablePtrOutput() TimeSeriesTablePtrOutput {
	return o
}

func (o TimeSeriesTablePtrOutput) ToTimeSeriesTablePtrOutputWithContext(ctx context.Context) TimeSeriesTablePtrOutput {
	return o
}

func (o TimeSeriesTablePtrOutput) Elem() TimeSeriesTableOutput {
	return o.ApplyT(func(v *TimeSeriesTable) TimeSeriesTable {
		if v != nil {
			return *v
		}
		var ret TimeSeriesTable
		return ret
	}).(TimeSeriesTableOutput)
}

// Optional. The list of the persistent column settings for the table.
func (o TimeSeriesTablePtrOutput) ColumnSettings() ColumnSettingsArrayOutput {
	return o.ApplyT(func(v *TimeSeriesTable) []ColumnSettings {
		if v == nil {
			return nil
		}
		return v.ColumnSettings
	}).(ColumnSettingsArrayOutput)
}

// The data displayed in this table.
func (o TimeSeriesTablePtrOutput) DataSets() TableDataSetArrayOutput {
	return o.ApplyT(func(v *TimeSeriesTable) []TableDataSet {
		if v == nil {
			return nil
		}
		return v.DataSets
	}).(TableDataSetArrayOutput)
}

// Optional. Store rendering strategy
func (o TimeSeriesTablePtrOutput) MetricVisualization() TimeSeriesTableMetricVisualizationPtrOutput {
	return o.ApplyT(func(v *TimeSeriesTable) *TimeSeriesTableMetricVisualization {
		if v == nil {
			return nil
		}
		return v.MetricVisualization
	}).(TimeSeriesTableMetricVisualizationPtrOutput)
}

// A table that displays time series data.
type TimeSeriesTableResponse struct {
	// Optional. The list of the persistent column settings for the table.
	ColumnSettings []ColumnSettingsResponse `pulumi:"columnSettings"`
	// The data displayed in this table.
	DataSets []TableDataSetResponse `pulumi:"dataSets"`
	// Optional. Store rendering strategy
	MetricVisualization string `pulumi:"metricVisualization"`
}

// A table that displays time series data.
type TimeSeriesTableResponseOutput struct{ *pulumi.OutputState }

func (TimeSeriesTableResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesTableResponse)(nil)).Elem()
}

func (o TimeSeriesTableResponseOutput) ToTimeSeriesTableResponseOutput() TimeSeriesTableResponseOutput {
	return o
}

func (o TimeSeriesTableResponseOutput) ToTimeSeriesTableResponseOutputWithContext(ctx context.Context) TimeSeriesTableResponseOutput {
	return o
}

// Optional. The list of the persistent column settings for the table.
func (o TimeSeriesTableResponseOutput) ColumnSettings() ColumnSettingsResponseArrayOutput {
	return o.ApplyT(func(v TimeSeriesTableResponse) []ColumnSettingsResponse { return v.ColumnSettings }).(ColumnSettingsResponseArrayOutput)
}

// The data displayed in this table.
func (o TimeSeriesTableResponseOutput) DataSets() TableDataSetResponseArrayOutput {
	return o.ApplyT(func(v TimeSeriesTableResponse) []TableDataSetResponse { return v.DataSets }).(TableDataSetResponseArrayOutput)
}

// Optional. Store rendering strategy
func (o TimeSeriesTableResponseOutput) MetricVisualization() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesTableResponse) string { return v.MetricVisualization }).(pulumi.StringOutput)
}

// Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
type Widget struct {
	// A chart of alert policy data.
	AlertChart *AlertChart `pulumi:"alertChart"`
	// A blank space.
	Blank *Empty `pulumi:"blank"`
	// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
	CollapsibleGroup *CollapsibleGroup `pulumi:"collapsibleGroup"`
	// A widget that shows list of incidents.
	IncidentList *IncidentList `pulumi:"incidentList"`
	// A widget that shows a stream of logs.
	LogsPanel *LogsPanel `pulumi:"logsPanel"`
	// A scorecard summarizing time series data.
	Scorecard *Scorecard `pulumi:"scorecard"`
	// A raw string or markdown displaying textual content.
	Text *Text `pulumi:"text"`
	// A widget that displays time series data in a tabular format.
	TimeSeriesTable *TimeSeriesTable `pulumi:"timeSeriesTable"`
	// Optional. The title of the widget.
	Title *string `pulumi:"title"`
	// A chart of time series data.
	XyChart *XyChart `pulumi:"xyChart"`
}

// WidgetInput is an input type that accepts WidgetArgs and WidgetOutput values.
// You can construct a concrete instance of `WidgetInput` via:
//
//	WidgetArgs{...}
type WidgetInput interface {
	pulumi.Input

	ToWidgetOutput() WidgetOutput
	ToWidgetOutputWithContext(context.Context) WidgetOutput
}

// Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
type WidgetArgs struct {
	// A chart of alert policy data.
	AlertChart AlertChartPtrInput `pulumi:"alertChart"`
	// A blank space.
	Blank EmptyPtrInput `pulumi:"blank"`
	// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
	CollapsibleGroup CollapsibleGroupPtrInput `pulumi:"collapsibleGroup"`
	// A widget that shows list of incidents.
	IncidentList IncidentListPtrInput `pulumi:"incidentList"`
	// A widget that shows a stream of logs.
	LogsPanel LogsPanelPtrInput `pulumi:"logsPanel"`
	// A scorecard summarizing time series data.
	Scorecard ScorecardPtrInput `pulumi:"scorecard"`
	// A raw string or markdown displaying textual content.
	Text TextPtrInput `pulumi:"text"`
	// A widget that displays time series data in a tabular format.
	TimeSeriesTable TimeSeriesTablePtrInput `pulumi:"timeSeriesTable"`
	// Optional. The title of the widget.
	Title pulumi.StringPtrInput `pulumi:"title"`
	// A chart of time series data.
	XyChart XyChartPtrInput `pulumi:"xyChart"`
}

func (WidgetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Widget)(nil)).Elem()
}

func (i WidgetArgs) ToWidgetOutput() WidgetOutput {
	return i.ToWidgetOutputWithContext(context.Background())
}

func (i WidgetArgs) ToWidgetOutputWithContext(ctx context.Context) WidgetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WidgetOutput)
}

func (i WidgetArgs) ToWidgetPtrOutput() WidgetPtrOutput {
	return i.ToWidgetPtrOutputWithContext(context.Background())
}

func (i WidgetArgs) ToWidgetPtrOutputWithContext(ctx context.Context) WidgetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WidgetOutput).ToWidgetPtrOutputWithContext(ctx)
}

// WidgetPtrInput is an input type that accepts WidgetArgs, WidgetPtr and WidgetPtrOutput values.
// You can construct a concrete instance of `WidgetPtrInput` via:
//
//	        WidgetArgs{...}
//
//	or:
//
//	        nil
type WidgetPtrInput interface {
	pulumi.Input

	ToWidgetPtrOutput() WidgetPtrOutput
	ToWidgetPtrOutputWithContext(context.Context) WidgetPtrOutput
}

type widgetPtrType WidgetArgs

func WidgetPtr(v *WidgetArgs) WidgetPtrInput {
	return (*widgetPtrType)(v)
}

func (*widgetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Widget)(nil)).Elem()
}

func (i *widgetPtrType) ToWidgetPtrOutput() WidgetPtrOutput {
	return i.ToWidgetPtrOutputWithContext(context.Background())
}

func (i *widgetPtrType) ToWidgetPtrOutputWithContext(ctx context.Context) WidgetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WidgetPtrOutput)
}

// WidgetArrayInput is an input type that accepts WidgetArray and WidgetArrayOutput values.
// You can construct a concrete instance of `WidgetArrayInput` via:
//
//	WidgetArray{ WidgetArgs{...} }
type WidgetArrayInput interface {
	pulumi.Input

	ToWidgetArrayOutput() WidgetArrayOutput
	ToWidgetArrayOutputWithContext(context.Context) WidgetArrayOutput
}

type WidgetArray []WidgetInput

func (WidgetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Widget)(nil)).Elem()
}

func (i WidgetArray) ToWidgetArrayOutput() WidgetArrayOutput {
	return i.ToWidgetArrayOutputWithContext(context.Background())
}

func (i WidgetArray) ToWidgetArrayOutputWithContext(ctx context.Context) WidgetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WidgetArrayOutput)
}

// Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
type WidgetOutput struct{ *pulumi.OutputState }

func (WidgetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Widget)(nil)).Elem()
}

func (o WidgetOutput) ToWidgetOutput() WidgetOutput {
	return o
}

func (o WidgetOutput) ToWidgetOutputWithContext(ctx context.Context) WidgetOutput {
	return o
}

func (o WidgetOutput) ToWidgetPtrOutput() WidgetPtrOutput {
	return o.ToWidgetPtrOutputWithContext(context.Background())
}

func (o WidgetOutput) ToWidgetPtrOutputWithContext(ctx context.Context) WidgetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Widget) *Widget {
		return &v
	}).(WidgetPtrOutput)
}

// A chart of alert policy data.
func (o WidgetOutput) AlertChart() AlertChartPtrOutput {
	return o.ApplyT(func(v Widget) *AlertChart { return v.AlertChart }).(AlertChartPtrOutput)
}

// A blank space.
func (o WidgetOutput) Blank() EmptyPtrOutput {
	return o.ApplyT(func(v Widget) *Empty { return v.Blank }).(EmptyPtrOutput)
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
func (o WidgetOutput) CollapsibleGroup() CollapsibleGroupPtrOutput {
	return o.ApplyT(func(v Widget) *CollapsibleGroup { return v.CollapsibleGroup }).(CollapsibleGroupPtrOutput)
}

// A widget that shows list of incidents.
func (o WidgetOutput) IncidentList() IncidentListPtrOutput {
	return o.ApplyT(func(v Widget) *IncidentList { return v.IncidentList }).(IncidentListPtrOutput)
}

// A widget that shows a stream of logs.
func (o WidgetOutput) LogsPanel() LogsPanelPtrOutput {
	return o.ApplyT(func(v Widget) *LogsPanel { return v.LogsPanel }).(LogsPanelPtrOutput)
}

// A scorecard summarizing time series data.
func (o WidgetOutput) Scorecard() ScorecardPtrOutput {
	return o.ApplyT(func(v Widget) *Scorecard { return v.Scorecard }).(ScorecardPtrOutput)
}

// A raw string or markdown displaying textual content.
func (o WidgetOutput) Text() TextPtrOutput {
	return o.ApplyT(func(v Widget) *Text { return v.Text }).(TextPtrOutput)
}

// A widget that displays time series data in a tabular format.
func (o WidgetOutput) TimeSeriesTable() TimeSeriesTablePtrOutput {
	return o.ApplyT(func(v Widget) *TimeSeriesTable { return v.TimeSeriesTable }).(TimeSeriesTablePtrOutput)
}

// Optional. The title of the widget.
func (o WidgetOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Widget) *string { return v.Title }).(pulumi.StringPtrOutput)
}

// A chart of time series data.
func (o WidgetOutput) XyChart() XyChartPtrOutput {
	return o.ApplyT(func(v Widget) *XyChart { return v.XyChart }).(XyChartPtrOutput)
}

type WidgetPtrOutput struct{ *pulumi.OutputState }

func (WidgetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Widget)(nil)).Elem()
}

func (o WidgetPtrOutput) ToWidgetPtrOutput() WidgetPtrOutput {
	return o
}

func (o WidgetPtrOutput) ToWidgetPtrOutputWithContext(ctx context.Context) WidgetPtrOutput {
	return o
}

func (o WidgetPtrOutput) Elem() WidgetOutput {
	return o.ApplyT(func(v *Widget) Widget {
		if v != nil {
			return *v
		}
		var ret Widget
		return ret
	}).(WidgetOutput)
}

// A chart of alert policy data.
func (o WidgetPtrOutput) AlertChart() AlertChartPtrOutput {
	return o.ApplyT(func(v *Widget) *AlertChart {
		if v == nil {
			return nil
		}
		return v.AlertChart
	}).(AlertChartPtrOutput)
}

// A blank space.
func (o WidgetPtrOutput) Blank() EmptyPtrOutput {
	return o.ApplyT(func(v *Widget) *Empty {
		if v == nil {
			return nil
		}
		return v.Blank
	}).(EmptyPtrOutput)
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
func (o WidgetPtrOutput) CollapsibleGroup() CollapsibleGroupPtrOutput {
	return o.ApplyT(func(v *Widget) *CollapsibleGroup {
		if v == nil {
			return nil
		}
		return v.CollapsibleGroup
	}).(CollapsibleGroupPtrOutput)
}

// A widget that shows list of incidents.
func (o WidgetPtrOutput) IncidentList() IncidentListPtrOutput {
	return o.ApplyT(func(v *Widget) *IncidentList {
		if v == nil {
			return nil
		}
		return v.IncidentList
	}).(IncidentListPtrOutput)
}

// A widget that shows a stream of logs.
func (o WidgetPtrOutput) LogsPanel() LogsPanelPtrOutput {
	return o.ApplyT(func(v *Widget) *LogsPanel {
		if v == nil {
			return nil
		}
		return v.LogsPanel
	}).(LogsPanelPtrOutput)
}

// A scorecard summarizing time series data.
func (o WidgetPtrOutput) Scorecard() ScorecardPtrOutput {
	return o.ApplyT(func(v *Widget) *Scorecard {
		if v == nil {
			return nil
		}
		return v.Scorecard
	}).(ScorecardPtrOutput)
}

// A raw string or markdown displaying textual content.
func (o WidgetPtrOutput) Text() TextPtrOutput {
	return o.ApplyT(func(v *Widget) *Text {
		if v == nil {
			return nil
		}
		return v.Text
	}).(TextPtrOutput)
}

// A widget that displays time series data in a tabular format.
func (o WidgetPtrOutput) TimeSeriesTable() TimeSeriesTablePtrOutput {
	return o.ApplyT(func(v *Widget) *TimeSeriesTable {
		if v == nil {
			return nil
		}
		return v.TimeSeriesTable
	}).(TimeSeriesTablePtrOutput)
}

// Optional. The title of the widget.
func (o WidgetPtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Widget) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// A chart of time series data.
func (o WidgetPtrOutput) XyChart() XyChartPtrOutput {
	return o.ApplyT(func(v *Widget) *XyChart {
		if v == nil {
			return nil
		}
		return v.XyChart
	}).(XyChartPtrOutput)
}

type WidgetArrayOutput struct{ *pulumi.OutputState }

func (WidgetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Widget)(nil)).Elem()
}

func (o WidgetArrayOutput) ToWidgetArrayOutput() WidgetArrayOutput {
	return o
}

func (o WidgetArrayOutput) ToWidgetArrayOutputWithContext(ctx context.Context) WidgetArrayOutput {
	return o
}

func (o WidgetArrayOutput) Index(i pulumi.IntInput) WidgetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Widget {
		return vs[0].([]Widget)[vs[1].(int)]
	}).(WidgetOutput)
}

// Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
type WidgetResponse struct {
	// A chart of alert policy data.
	AlertChart AlertChartResponse `pulumi:"alertChart"`
	// A blank space.
	Blank EmptyResponse `pulumi:"blank"`
	// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
	CollapsibleGroup CollapsibleGroupResponse `pulumi:"collapsibleGroup"`
	// A widget that shows list of incidents.
	IncidentList IncidentListResponse `pulumi:"incidentList"`
	// A widget that shows a stream of logs.
	LogsPanel LogsPanelResponse `pulumi:"logsPanel"`
	// A scorecard summarizing time series data.
	Scorecard ScorecardResponse `pulumi:"scorecard"`
	// A raw string or markdown displaying textual content.
	Text TextResponse `pulumi:"text"`
	// A widget that displays time series data in a tabular format.
	TimeSeriesTable TimeSeriesTableResponse `pulumi:"timeSeriesTable"`
	// Optional. The title of the widget.
	Title string `pulumi:"title"`
	// A chart of time series data.
	XyChart XyChartResponse `pulumi:"xyChart"`
}

// Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
type WidgetResponseOutput struct{ *pulumi.OutputState }

func (WidgetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WidgetResponse)(nil)).Elem()
}

func (o WidgetResponseOutput) ToWidgetResponseOutput() WidgetResponseOutput {
	return o
}

func (o WidgetResponseOutput) ToWidgetResponseOutputWithContext(ctx context.Context) WidgetResponseOutput {
	return o
}

// A chart of alert policy data.
func (o WidgetResponseOutput) AlertChart() AlertChartResponseOutput {
	return o.ApplyT(func(v WidgetResponse) AlertChartResponse { return v.AlertChart }).(AlertChartResponseOutput)
}

// A blank space.
func (o WidgetResponseOutput) Blank() EmptyResponseOutput {
	return o.ApplyT(func(v WidgetResponse) EmptyResponse { return v.Blank }).(EmptyResponseOutput)
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
func (o WidgetResponseOutput) CollapsibleGroup() CollapsibleGroupResponseOutput {
	return o.ApplyT(func(v WidgetResponse) CollapsibleGroupResponse { return v.CollapsibleGroup }).(CollapsibleGroupResponseOutput)
}

// A widget that shows list of incidents.
func (o WidgetResponseOutput) IncidentList() IncidentListResponseOutput {
	return o.ApplyT(func(v WidgetResponse) IncidentListResponse { return v.IncidentList }).(IncidentListResponseOutput)
}

// A widget that shows a stream of logs.
func (o WidgetResponseOutput) LogsPanel() LogsPanelResponseOutput {
	return o.ApplyT(func(v WidgetResponse) LogsPanelResponse { return v.LogsPanel }).(LogsPanelResponseOutput)
}

// A scorecard summarizing time series data.
func (o WidgetResponseOutput) Scorecard() ScorecardResponseOutput {
	return o.ApplyT(func(v WidgetResponse) ScorecardResponse { return v.Scorecard }).(ScorecardResponseOutput)
}

// A raw string or markdown displaying textual content.
func (o WidgetResponseOutput) Text() TextResponseOutput {
	return o.ApplyT(func(v WidgetResponse) TextResponse { return v.Text }).(TextResponseOutput)
}

// A widget that displays time series data in a tabular format.
func (o WidgetResponseOutput) TimeSeriesTable() TimeSeriesTableResponseOutput {
	return o.ApplyT(func(v WidgetResponse) TimeSeriesTableResponse { return v.TimeSeriesTable }).(TimeSeriesTableResponseOutput)
}

// Optional. The title of the widget.
func (o WidgetResponseOutput) Title() pulumi.StringOutput {
	return o.ApplyT(func(v WidgetResponse) string { return v.Title }).(pulumi.StringOutput)
}

// A chart of time series data.
func (o WidgetResponseOutput) XyChart() XyChartResponseOutput {
	return o.ApplyT(func(v WidgetResponse) XyChartResponse { return v.XyChart }).(XyChartResponseOutput)
}

type WidgetResponseArrayOutput struct{ *pulumi.OutputState }

func (WidgetResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WidgetResponse)(nil)).Elem()
}

func (o WidgetResponseArrayOutput) ToWidgetResponseArrayOutput() WidgetResponseArrayOutput {
	return o
}

func (o WidgetResponseArrayOutput) ToWidgetResponseArrayOutputWithContext(ctx context.Context) WidgetResponseArrayOutput {
	return o
}

func (o WidgetResponseArrayOutput) Index(i pulumi.IntInput) WidgetResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WidgetResponse {
		return vs[0].([]WidgetResponse)[vs[1].(int)]
	}).(WidgetResponseOutput)
}

// A chart that displays data on a 2D (X and Y axes) plane.
type XyChart struct {
	// Display options for the chart.
	ChartOptions *ChartOptions `pulumi:"chartOptions"`
	// The data displayed in this chart.
	DataSets []DataSet `pulumi:"dataSets"`
	// Threshold lines drawn horizontally across the chart.
	Thresholds []Threshold `pulumi:"thresholds"`
	// The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
	TimeshiftDuration *string `pulumi:"timeshiftDuration"`
	// The properties applied to the x-axis.
	XAxis *Axis `pulumi:"xAxis"`
	// The properties applied to the y2-axis.
	Y2Axis *Axis `pulumi:"y2Axis"`
	// The properties applied to the y-axis.
	YAxis *Axis `pulumi:"yAxis"`
}

// XyChartInput is an input type that accepts XyChartArgs and XyChartOutput values.
// You can construct a concrete instance of `XyChartInput` via:
//
//	XyChartArgs{...}
type XyChartInput interface {
	pulumi.Input

	ToXyChartOutput() XyChartOutput
	ToXyChartOutputWithContext(context.Context) XyChartOutput
}

// A chart that displays data on a 2D (X and Y axes) plane.
type XyChartArgs struct {
	// Display options for the chart.
	ChartOptions ChartOptionsPtrInput `pulumi:"chartOptions"`
	// The data displayed in this chart.
	DataSets DataSetArrayInput `pulumi:"dataSets"`
	// Threshold lines drawn horizontally across the chart.
	Thresholds ThresholdArrayInput `pulumi:"thresholds"`
	// The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
	TimeshiftDuration pulumi.StringPtrInput `pulumi:"timeshiftDuration"`
	// The properties applied to the x-axis.
	XAxis AxisPtrInput `pulumi:"xAxis"`
	// The properties applied to the y2-axis.
	Y2Axis AxisPtrInput `pulumi:"y2Axis"`
	// The properties applied to the y-axis.
	YAxis AxisPtrInput `pulumi:"yAxis"`
}

func (XyChartArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XyChart)(nil)).Elem()
}

func (i XyChartArgs) ToXyChartOutput() XyChartOutput {
	return i.ToXyChartOutputWithContext(context.Background())
}

func (i XyChartArgs) ToXyChartOutputWithContext(ctx context.Context) XyChartOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XyChartOutput)
}

func (i XyChartArgs) ToXyChartPtrOutput() XyChartPtrOutput {
	return i.ToXyChartPtrOutputWithContext(context.Background())
}

func (i XyChartArgs) ToXyChartPtrOutputWithContext(ctx context.Context) XyChartPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XyChartOutput).ToXyChartPtrOutputWithContext(ctx)
}

// XyChartPtrInput is an input type that accepts XyChartArgs, XyChartPtr and XyChartPtrOutput values.
// You can construct a concrete instance of `XyChartPtrInput` via:
//
//	        XyChartArgs{...}
//
//	or:
//
//	        nil
type XyChartPtrInput interface {
	pulumi.Input

	ToXyChartPtrOutput() XyChartPtrOutput
	ToXyChartPtrOutputWithContext(context.Context) XyChartPtrOutput
}

type xyChartPtrType XyChartArgs

func XyChartPtr(v *XyChartArgs) XyChartPtrInput {
	return (*xyChartPtrType)(v)
}

func (*xyChartPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XyChart)(nil)).Elem()
}

func (i *xyChartPtrType) ToXyChartPtrOutput() XyChartPtrOutput {
	return i.ToXyChartPtrOutputWithContext(context.Background())
}

func (i *xyChartPtrType) ToXyChartPtrOutputWithContext(ctx context.Context) XyChartPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XyChartPtrOutput)
}

// A chart that displays data on a 2D (X and Y axes) plane.
type XyChartOutput struct{ *pulumi.OutputState }

func (XyChartOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XyChart)(nil)).Elem()
}

func (o XyChartOutput) ToXyChartOutput() XyChartOutput {
	return o
}

func (o XyChartOutput) ToXyChartOutputWithContext(ctx context.Context) XyChartOutput {
	return o
}

func (o XyChartOutput) ToXyChartPtrOutput() XyChartPtrOutput {
	return o.ToXyChartPtrOutputWithContext(context.Background())
}

func (o XyChartOutput) ToXyChartPtrOutputWithContext(ctx context.Context) XyChartPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XyChart) *XyChart {
		return &v
	}).(XyChartPtrOutput)
}

// Display options for the chart.
func (o XyChartOutput) ChartOptions() ChartOptionsPtrOutput {
	return o.ApplyT(func(v XyChart) *ChartOptions { return v.ChartOptions }).(ChartOptionsPtrOutput)
}

// The data displayed in this chart.
func (o XyChartOutput) DataSets() DataSetArrayOutput {
	return o.ApplyT(func(v XyChart) []DataSet { return v.DataSets }).(DataSetArrayOutput)
}

// Threshold lines drawn horizontally across the chart.
func (o XyChartOutput) Thresholds() ThresholdArrayOutput {
	return o.ApplyT(func(v XyChart) []Threshold { return v.Thresholds }).(ThresholdArrayOutput)
}

// The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
func (o XyChartOutput) TimeshiftDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XyChart) *string { return v.TimeshiftDuration }).(pulumi.StringPtrOutput)
}

// The properties applied to the x-axis.
func (o XyChartOutput) XAxis() AxisPtrOutput {
	return o.ApplyT(func(v XyChart) *Axis { return v.XAxis }).(AxisPtrOutput)
}

// The properties applied to the y2-axis.
func (o XyChartOutput) Y2Axis() AxisPtrOutput {
	return o.ApplyT(func(v XyChart) *Axis { return v.Y2Axis }).(AxisPtrOutput)
}

// The properties applied to the y-axis.
func (o XyChartOutput) YAxis() AxisPtrOutput {
	return o.ApplyT(func(v XyChart) *Axis { return v.YAxis }).(AxisPtrOutput)
}

type XyChartPtrOutput struct{ *pulumi.OutputState }

func (XyChartPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XyChart)(nil)).Elem()
}

func (o XyChartPtrOutput) ToXyChartPtrOutput() XyChartPtrOutput {
	return o
}

func (o XyChartPtrOutput) ToXyChartPtrOutputWithContext(ctx context.Context) XyChartPtrOutput {
	return o
}

func (o XyChartPtrOutput) Elem() XyChartOutput {
	return o.ApplyT(func(v *XyChart) XyChart {
		if v != nil {
			return *v
		}
		var ret XyChart
		return ret
	}).(XyChartOutput)
}

// Display options for the chart.
func (o XyChartPtrOutput) ChartOptions() ChartOptionsPtrOutput {
	return o.ApplyT(func(v *XyChart) *ChartOptions {
		if v == nil {
			return nil
		}
		return v.ChartOptions
	}).(ChartOptionsPtrOutput)
}

// The data displayed in this chart.
func (o XyChartPtrOutput) DataSets() DataSetArrayOutput {
	return o.ApplyT(func(v *XyChart) []DataSet {
		if v == nil {
			return nil
		}
		return v.DataSets
	}).(DataSetArrayOutput)
}

// Threshold lines drawn horizontally across the chart.
func (o XyChartPtrOutput) Thresholds() ThresholdArrayOutput {
	return o.ApplyT(func(v *XyChart) []Threshold {
		if v == nil {
			return nil
		}
		return v.Thresholds
	}).(ThresholdArrayOutput)
}

// The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
func (o XyChartPtrOutput) TimeshiftDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XyChart) *string {
		if v == nil {
			return nil
		}
		return v.TimeshiftDuration
	}).(pulumi.StringPtrOutput)
}

// The properties applied to the x-axis.
func (o XyChartPtrOutput) XAxis() AxisPtrOutput {
	return o.ApplyT(func(v *XyChart) *Axis {
		if v == nil {
			return nil
		}
		return v.XAxis
	}).(AxisPtrOutput)
}

// The properties applied to the y2-axis.
func (o XyChartPtrOutput) Y2Axis() AxisPtrOutput {
	return o.ApplyT(func(v *XyChart) *Axis {
		if v == nil {
			return nil
		}
		return v.Y2Axis
	}).(AxisPtrOutput)
}

// The properties applied to the y-axis.
func (o XyChartPtrOutput) YAxis() AxisPtrOutput {
	return o.ApplyT(func(v *XyChart) *Axis {
		if v == nil {
			return nil
		}
		return v.YAxis
	}).(AxisPtrOutput)
}

// A chart that displays data on a 2D (X and Y axes) plane.
type XyChartResponse struct {
	// Display options for the chart.
	ChartOptions ChartOptionsResponse `pulumi:"chartOptions"`
	// The data displayed in this chart.
	DataSets []DataSetResponse `pulumi:"dataSets"`
	// Threshold lines drawn horizontally across the chart.
	Thresholds []ThresholdResponse `pulumi:"thresholds"`
	// The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
	TimeshiftDuration string `pulumi:"timeshiftDuration"`
	// The properties applied to the x-axis.
	XAxis AxisResponse `pulumi:"xAxis"`
	// The properties applied to the y2-axis.
	Y2Axis AxisResponse `pulumi:"y2Axis"`
	// The properties applied to the y-axis.
	YAxis AxisResponse `pulumi:"yAxis"`
}

// A chart that displays data on a 2D (X and Y axes) plane.
type XyChartResponseOutput struct{ *pulumi.OutputState }

func (XyChartResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XyChartResponse)(nil)).Elem()
}

func (o XyChartResponseOutput) ToXyChartResponseOutput() XyChartResponseOutput {
	return o
}

func (o XyChartResponseOutput) ToXyChartResponseOutputWithContext(ctx context.Context) XyChartResponseOutput {
	return o
}

// Display options for the chart.
func (o XyChartResponseOutput) ChartOptions() ChartOptionsResponseOutput {
	return o.ApplyT(func(v XyChartResponse) ChartOptionsResponse { return v.ChartOptions }).(ChartOptionsResponseOutput)
}

// The data displayed in this chart.
func (o XyChartResponseOutput) DataSets() DataSetResponseArrayOutput {
	return o.ApplyT(func(v XyChartResponse) []DataSetResponse { return v.DataSets }).(DataSetResponseArrayOutput)
}

// Threshold lines drawn horizontally across the chart.
func (o XyChartResponseOutput) Thresholds() ThresholdResponseArrayOutput {
	return o.ApplyT(func(v XyChartResponse) []ThresholdResponse { return v.Thresholds }).(ThresholdResponseArrayOutput)
}

// The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
func (o XyChartResponseOutput) TimeshiftDuration() pulumi.StringOutput {
	return o.ApplyT(func(v XyChartResponse) string { return v.TimeshiftDuration }).(pulumi.StringOutput)
}

// The properties applied to the x-axis.
func (o XyChartResponseOutput) XAxis() AxisResponseOutput {
	return o.ApplyT(func(v XyChartResponse) AxisResponse { return v.XAxis }).(AxisResponseOutput)
}

// The properties applied to the y2-axis.
func (o XyChartResponseOutput) Y2Axis() AxisResponseOutput {
	return o.ApplyT(func(v XyChartResponse) AxisResponse { return v.Y2Axis }).(AxisResponseOutput)
}

// The properties applied to the y-axis.
func (o XyChartResponseOutput) YAxis() AxisResponseOutput {
	return o.ApplyT(func(v XyChartResponse) AxisResponse { return v.YAxis }).(AxisResponseOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AggregationInput)(nil)).Elem(), AggregationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AggregationPtrInput)(nil)).Elem(), AggregationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlertChartInput)(nil)).Elem(), AlertChartArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlertChartPtrInput)(nil)).Elem(), AlertChartArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AxisInput)(nil)).Elem(), AxisArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AxisPtrInput)(nil)).Elem(), AxisArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChartOptionsInput)(nil)).Elem(), ChartOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChartOptionsPtrInput)(nil)).Elem(), ChartOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CollapsibleGroupInput)(nil)).Elem(), CollapsibleGroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CollapsibleGroupPtrInput)(nil)).Elem(), CollapsibleGroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ColumnInput)(nil)).Elem(), ColumnArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ColumnArrayInput)(nil)).Elem(), ColumnArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ColumnLayoutInput)(nil)).Elem(), ColumnLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ColumnLayoutPtrInput)(nil)).Elem(), ColumnLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ColumnSettingsInput)(nil)).Elem(), ColumnSettingsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ColumnSettingsArrayInput)(nil)).Elem(), ColumnSettingsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DashboardFilterInput)(nil)).Elem(), DashboardFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DashboardFilterArrayInput)(nil)).Elem(), DashboardFilterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DataSetInput)(nil)).Elem(), DataSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DataSetArrayInput)(nil)).Elem(), DataSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*EmptyInput)(nil)).Elem(), EmptyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*EmptyPtrInput)(nil)).Elem(), EmptyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GaugeViewInput)(nil)).Elem(), GaugeViewArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GaugeViewPtrInput)(nil)).Elem(), GaugeViewArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GridLayoutInput)(nil)).Elem(), GridLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GridLayoutPtrInput)(nil)).Elem(), GridLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IncidentListInput)(nil)).Elem(), IncidentListArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IncidentListPtrInput)(nil)).Elem(), IncidentListArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogsPanelInput)(nil)).Elem(), LogsPanelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogsPanelPtrInput)(nil)).Elem(), LogsPanelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MonitoredResourceInput)(nil)).Elem(), MonitoredResourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MonitoredResourceArrayInput)(nil)).Elem(), MonitoredResourceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MosaicLayoutInput)(nil)).Elem(), MosaicLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MosaicLayoutPtrInput)(nil)).Elem(), MosaicLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PickTimeSeriesFilterInput)(nil)).Elem(), PickTimeSeriesFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PickTimeSeriesFilterPtrInput)(nil)).Elem(), PickTimeSeriesFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RatioPartInput)(nil)).Elem(), RatioPartArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RatioPartPtrInput)(nil)).Elem(), RatioPartArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RowInput)(nil)).Elem(), RowArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RowArrayInput)(nil)).Elem(), RowArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RowLayoutInput)(nil)).Elem(), RowLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RowLayoutPtrInput)(nil)).Elem(), RowLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScorecardInput)(nil)).Elem(), ScorecardArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScorecardPtrInput)(nil)).Elem(), ScorecardArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SparkChartViewInput)(nil)).Elem(), SparkChartViewArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SparkChartViewPtrInput)(nil)).Elem(), SparkChartViewArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatisticalTimeSeriesFilterInput)(nil)).Elem(), StatisticalTimeSeriesFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatisticalTimeSeriesFilterPtrInput)(nil)).Elem(), StatisticalTimeSeriesFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TableDataSetInput)(nil)).Elem(), TableDataSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TableDataSetArrayInput)(nil)).Elem(), TableDataSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TableDisplayOptionsInput)(nil)).Elem(), TableDisplayOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TableDisplayOptionsPtrInput)(nil)).Elem(), TableDisplayOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TextInput)(nil)).Elem(), TextArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TextPtrInput)(nil)).Elem(), TextArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ThresholdInput)(nil)).Elem(), ThresholdArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ThresholdArrayInput)(nil)).Elem(), ThresholdArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TileInput)(nil)).Elem(), TileArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TileArrayInput)(nil)).Elem(), TileArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesFilterInput)(nil)).Elem(), TimeSeriesFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesFilterPtrInput)(nil)).Elem(), TimeSeriesFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesFilterRatioInput)(nil)).Elem(), TimeSeriesFilterRatioArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesFilterRatioPtrInput)(nil)).Elem(), TimeSeriesFilterRatioArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesQueryInput)(nil)).Elem(), TimeSeriesQueryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesQueryPtrInput)(nil)).Elem(), TimeSeriesQueryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesTableInput)(nil)).Elem(), TimeSeriesTableArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesTablePtrInput)(nil)).Elem(), TimeSeriesTableArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WidgetInput)(nil)).Elem(), WidgetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WidgetPtrInput)(nil)).Elem(), WidgetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WidgetArrayInput)(nil)).Elem(), WidgetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XyChartInput)(nil)).Elem(), XyChartArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XyChartPtrInput)(nil)).Elem(), XyChartArgs{})
	pulumi.RegisterOutputType(AggregationOutput{})
	pulumi.RegisterOutputType(AggregationPtrOutput{})
	pulumi.RegisterOutputType(AggregationResponseOutput{})
	pulumi.RegisterOutputType(AlertChartOutput{})
	pulumi.RegisterOutputType(AlertChartPtrOutput{})
	pulumi.RegisterOutputType(AlertChartResponseOutput{})
	pulumi.RegisterOutputType(AxisOutput{})
	pulumi.RegisterOutputType(AxisPtrOutput{})
	pulumi.RegisterOutputType(AxisResponseOutput{})
	pulumi.RegisterOutputType(ChartOptionsOutput{})
	pulumi.RegisterOutputType(ChartOptionsPtrOutput{})
	pulumi.RegisterOutputType(ChartOptionsResponseOutput{})
	pulumi.RegisterOutputType(CollapsibleGroupOutput{})
	pulumi.RegisterOutputType(CollapsibleGroupPtrOutput{})
	pulumi.RegisterOutputType(CollapsibleGroupResponseOutput{})
	pulumi.RegisterOutputType(ColumnOutput{})
	pulumi.RegisterOutputType(ColumnArrayOutput{})
	pulumi.RegisterOutputType(ColumnLayoutOutput{})
	pulumi.RegisterOutputType(ColumnLayoutPtrOutput{})
	pulumi.RegisterOutputType(ColumnLayoutResponseOutput{})
	pulumi.RegisterOutputType(ColumnResponseOutput{})
	pulumi.RegisterOutputType(ColumnResponseArrayOutput{})
	pulumi.RegisterOutputType(ColumnSettingsOutput{})
	pulumi.RegisterOutputType(ColumnSettingsArrayOutput{})
	pulumi.RegisterOutputType(ColumnSettingsResponseOutput{})
	pulumi.RegisterOutputType(ColumnSettingsResponseArrayOutput{})
	pulumi.RegisterOutputType(DashboardFilterOutput{})
	pulumi.RegisterOutputType(DashboardFilterArrayOutput{})
	pulumi.RegisterOutputType(DashboardFilterResponseOutput{})
	pulumi.RegisterOutputType(DashboardFilterResponseArrayOutput{})
	pulumi.RegisterOutputType(DataSetOutput{})
	pulumi.RegisterOutputType(DataSetArrayOutput{})
	pulumi.RegisterOutputType(DataSetResponseOutput{})
	pulumi.RegisterOutputType(DataSetResponseArrayOutput{})
	pulumi.RegisterOutputType(EmptyOutput{})
	pulumi.RegisterOutputType(EmptyPtrOutput{})
	pulumi.RegisterOutputType(EmptyResponseOutput{})
	pulumi.RegisterOutputType(GaugeViewOutput{})
	pulumi.RegisterOutputType(GaugeViewPtrOutput{})
	pulumi.RegisterOutputType(GaugeViewResponseOutput{})
	pulumi.RegisterOutputType(GridLayoutOutput{})
	pulumi.RegisterOutputType(GridLayoutPtrOutput{})
	pulumi.RegisterOutputType(GridLayoutResponseOutput{})
	pulumi.RegisterOutputType(IncidentListOutput{})
	pulumi.RegisterOutputType(IncidentListPtrOutput{})
	pulumi.RegisterOutputType(IncidentListResponseOutput{})
	pulumi.RegisterOutputType(LogsPanelOutput{})
	pulumi.RegisterOutputType(LogsPanelPtrOutput{})
	pulumi.RegisterOutputType(LogsPanelResponseOutput{})
	pulumi.RegisterOutputType(MonitoredResourceOutput{})
	pulumi.RegisterOutputType(MonitoredResourceArrayOutput{})
	pulumi.RegisterOutputType(MonitoredResourceResponseOutput{})
	pulumi.RegisterOutputType(MonitoredResourceResponseArrayOutput{})
	pulumi.RegisterOutputType(MosaicLayoutOutput{})
	pulumi.RegisterOutputType(MosaicLayoutPtrOutput{})
	pulumi.RegisterOutputType(MosaicLayoutResponseOutput{})
	pulumi.RegisterOutputType(PickTimeSeriesFilterOutput{})
	pulumi.RegisterOutputType(PickTimeSeriesFilterPtrOutput{})
	pulumi.RegisterOutputType(PickTimeSeriesFilterResponseOutput{})
	pulumi.RegisterOutputType(RatioPartOutput{})
	pulumi.RegisterOutputType(RatioPartPtrOutput{})
	pulumi.RegisterOutputType(RatioPartResponseOutput{})
	pulumi.RegisterOutputType(RowOutput{})
	pulumi.RegisterOutputType(RowArrayOutput{})
	pulumi.RegisterOutputType(RowLayoutOutput{})
	pulumi.RegisterOutputType(RowLayoutPtrOutput{})
	pulumi.RegisterOutputType(RowLayoutResponseOutput{})
	pulumi.RegisterOutputType(RowResponseOutput{})
	pulumi.RegisterOutputType(RowResponseArrayOutput{})
	pulumi.RegisterOutputType(ScorecardOutput{})
	pulumi.RegisterOutputType(ScorecardPtrOutput{})
	pulumi.RegisterOutputType(ScorecardResponseOutput{})
	pulumi.RegisterOutputType(SparkChartViewOutput{})
	pulumi.RegisterOutputType(SparkChartViewPtrOutput{})
	pulumi.RegisterOutputType(SparkChartViewResponseOutput{})
	pulumi.RegisterOutputType(StatisticalTimeSeriesFilterOutput{})
	pulumi.RegisterOutputType(StatisticalTimeSeriesFilterPtrOutput{})
	pulumi.RegisterOutputType(StatisticalTimeSeriesFilterResponseOutput{})
	pulumi.RegisterOutputType(TableDataSetOutput{})
	pulumi.RegisterOutputType(TableDataSetArrayOutput{})
	pulumi.RegisterOutputType(TableDataSetResponseOutput{})
	pulumi.RegisterOutputType(TableDataSetResponseArrayOutput{})
	pulumi.RegisterOutputType(TableDisplayOptionsOutput{})
	pulumi.RegisterOutputType(TableDisplayOptionsPtrOutput{})
	pulumi.RegisterOutputType(TableDisplayOptionsResponseOutput{})
	pulumi.RegisterOutputType(TextOutput{})
	pulumi.RegisterOutputType(TextPtrOutput{})
	pulumi.RegisterOutputType(TextResponseOutput{})
	pulumi.RegisterOutputType(ThresholdOutput{})
	pulumi.RegisterOutputType(ThresholdArrayOutput{})
	pulumi.RegisterOutputType(ThresholdResponseOutput{})
	pulumi.RegisterOutputType(ThresholdResponseArrayOutput{})
	pulumi.RegisterOutputType(TileOutput{})
	pulumi.RegisterOutputType(TileArrayOutput{})
	pulumi.RegisterOutputType(TileResponseOutput{})
	pulumi.RegisterOutputType(TileResponseArrayOutput{})
	pulumi.RegisterOutputType(TimeSeriesFilterOutput{})
	pulumi.RegisterOutputType(TimeSeriesFilterPtrOutput{})
	pulumi.RegisterOutputType(TimeSeriesFilterRatioOutput{})
	pulumi.RegisterOutputType(TimeSeriesFilterRatioPtrOutput{})
	pulumi.RegisterOutputType(TimeSeriesFilterRatioResponseOutput{})
	pulumi.RegisterOutputType(TimeSeriesFilterResponseOutput{})
	pulumi.RegisterOutputType(TimeSeriesQueryOutput{})
	pulumi.RegisterOutputType(TimeSeriesQueryPtrOutput{})
	pulumi.RegisterOutputType(TimeSeriesQueryResponseOutput{})
	pulumi.RegisterOutputType(TimeSeriesTableOutput{})
	pulumi.RegisterOutputType(TimeSeriesTablePtrOutput{})
	pulumi.RegisterOutputType(TimeSeriesTableResponseOutput{})
	pulumi.RegisterOutputType(WidgetOutput{})
	pulumi.RegisterOutputType(WidgetPtrOutput{})
	pulumi.RegisterOutputType(WidgetArrayOutput{})
	pulumi.RegisterOutputType(WidgetResponseOutput{})
	pulumi.RegisterOutputType(WidgetResponseArrayOutput{})
	pulumi.RegisterOutputType(XyChartOutput{})
	pulumi.RegisterOutputType(XyChartPtrOutput{})
	pulumi.RegisterOutputType(XyChartResponseOutput{})
}

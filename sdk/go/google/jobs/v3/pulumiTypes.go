// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v3

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Application related details of a job posting.
type ApplicationInfo struct {
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
	Emails []string `pulumi:"emails"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
	Instruction *string `pulumi:"instruction"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
	Uris []string `pulumi:"uris"`
}

// ApplicationInfoInput is an input type that accepts ApplicationInfoArgs and ApplicationInfoOutput values.
// You can construct a concrete instance of `ApplicationInfoInput` via:
//
//          ApplicationInfoArgs{...}
type ApplicationInfoInput interface {
	pulumi.Input

	ToApplicationInfoOutput() ApplicationInfoOutput
	ToApplicationInfoOutputWithContext(context.Context) ApplicationInfoOutput
}

// Application related details of a job posting.
type ApplicationInfoArgs struct {
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
	Emails pulumi.StringArrayInput `pulumi:"emails"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
	Instruction pulumi.StringPtrInput `pulumi:"instruction"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
	Uris pulumi.StringArrayInput `pulumi:"uris"`
}

func (ApplicationInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInfo)(nil)).Elem()
}

func (i ApplicationInfoArgs) ToApplicationInfoOutput() ApplicationInfoOutput {
	return i.ToApplicationInfoOutputWithContext(context.Background())
}

func (i ApplicationInfoArgs) ToApplicationInfoOutputWithContext(ctx context.Context) ApplicationInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoOutput)
}

func (i ApplicationInfoArgs) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return i.ToApplicationInfoPtrOutputWithContext(context.Background())
}

func (i ApplicationInfoArgs) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoOutput).ToApplicationInfoPtrOutputWithContext(ctx)
}

// ApplicationInfoPtrInput is an input type that accepts ApplicationInfoArgs, ApplicationInfoPtr and ApplicationInfoPtrOutput values.
// You can construct a concrete instance of `ApplicationInfoPtrInput` via:
//
//          ApplicationInfoArgs{...}
//
//  or:
//
//          nil
type ApplicationInfoPtrInput interface {
	pulumi.Input

	ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput
	ToApplicationInfoPtrOutputWithContext(context.Context) ApplicationInfoPtrOutput
}

type applicationInfoPtrType ApplicationInfoArgs

func ApplicationInfoPtr(v *ApplicationInfoArgs) ApplicationInfoPtrInput {
	return (*applicationInfoPtrType)(v)
}

func (*applicationInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationInfo)(nil)).Elem()
}

func (i *applicationInfoPtrType) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return i.ToApplicationInfoPtrOutputWithContext(context.Background())
}

func (i *applicationInfoPtrType) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoPtrOutput)
}

// Application related details of a job posting.
type ApplicationInfoOutput struct{ *pulumi.OutputState }

func (ApplicationInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInfo)(nil)).Elem()
}

func (o ApplicationInfoOutput) ToApplicationInfoOutput() ApplicationInfoOutput {
	return o
}

func (o ApplicationInfoOutput) ToApplicationInfoOutputWithContext(ctx context.Context) ApplicationInfoOutput {
	return o
}

func (o ApplicationInfoOutput) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return o.ToApplicationInfoPtrOutputWithContext(context.Background())
}

func (o ApplicationInfoOutput) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return o.ApplyT(func(v ApplicationInfo) *ApplicationInfo {
		return &v
	}).(ApplicationInfoPtrOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
func (o ApplicationInfoOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ApplicationInfo) []string { return v.Emails }).(pulumi.StringArrayOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
func (o ApplicationInfoOutput) Instruction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApplicationInfo) *string { return v.Instruction }).(pulumi.StringPtrOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
func (o ApplicationInfoOutput) Uris() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ApplicationInfo) []string { return v.Uris }).(pulumi.StringArrayOutput)
}

type ApplicationInfoPtrOutput struct{ *pulumi.OutputState }

func (ApplicationInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationInfo)(nil)).Elem()
}

func (o ApplicationInfoPtrOutput) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return o
}

func (o ApplicationInfoPtrOutput) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return o
}

func (o ApplicationInfoPtrOutput) Elem() ApplicationInfoOutput {
	return o.ApplyT(func(v *ApplicationInfo) ApplicationInfo { return *v }).(ApplicationInfoOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
func (o ApplicationInfoPtrOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationInfo) []string {
		if v == nil {
			return nil
		}
		return v.Emails
	}).(pulumi.StringArrayOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
func (o ApplicationInfoPtrOutput) Instruction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationInfo) *string {
		if v == nil {
			return nil
		}
		return v.Instruction
	}).(pulumi.StringPtrOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
func (o ApplicationInfoPtrOutput) Uris() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationInfo) []string {
		if v == nil {
			return nil
		}
		return v.Uris
	}).(pulumi.StringArrayOutput)
}

// Application related details of a job posting.
type ApplicationInfoResponse struct {
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
	Emails []string `pulumi:"emails"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
	Instruction string `pulumi:"instruction"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
	Uris []string `pulumi:"uris"`
}

// ApplicationInfoResponseInput is an input type that accepts ApplicationInfoResponseArgs and ApplicationInfoResponseOutput values.
// You can construct a concrete instance of `ApplicationInfoResponseInput` via:
//
//          ApplicationInfoResponseArgs{...}
type ApplicationInfoResponseInput interface {
	pulumi.Input

	ToApplicationInfoResponseOutput() ApplicationInfoResponseOutput
	ToApplicationInfoResponseOutputWithContext(context.Context) ApplicationInfoResponseOutput
}

// Application related details of a job posting.
type ApplicationInfoResponseArgs struct {
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
	Emails pulumi.StringArrayInput `pulumi:"emails"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
	Instruction pulumi.StringInput `pulumi:"instruction"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
	Uris pulumi.StringArrayInput `pulumi:"uris"`
}

func (ApplicationInfoResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInfoResponse)(nil)).Elem()
}

func (i ApplicationInfoResponseArgs) ToApplicationInfoResponseOutput() ApplicationInfoResponseOutput {
	return i.ToApplicationInfoResponseOutputWithContext(context.Background())
}

func (i ApplicationInfoResponseArgs) ToApplicationInfoResponseOutputWithContext(ctx context.Context) ApplicationInfoResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoResponseOutput)
}

func (i ApplicationInfoResponseArgs) ToApplicationInfoResponsePtrOutput() ApplicationInfoResponsePtrOutput {
	return i.ToApplicationInfoResponsePtrOutputWithContext(context.Background())
}

func (i ApplicationInfoResponseArgs) ToApplicationInfoResponsePtrOutputWithContext(ctx context.Context) ApplicationInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoResponseOutput).ToApplicationInfoResponsePtrOutputWithContext(ctx)
}

// ApplicationInfoResponsePtrInput is an input type that accepts ApplicationInfoResponseArgs, ApplicationInfoResponsePtr and ApplicationInfoResponsePtrOutput values.
// You can construct a concrete instance of `ApplicationInfoResponsePtrInput` via:
//
//          ApplicationInfoResponseArgs{...}
//
//  or:
//
//          nil
type ApplicationInfoResponsePtrInput interface {
	pulumi.Input

	ToApplicationInfoResponsePtrOutput() ApplicationInfoResponsePtrOutput
	ToApplicationInfoResponsePtrOutputWithContext(context.Context) ApplicationInfoResponsePtrOutput
}

type applicationInfoResponsePtrType ApplicationInfoResponseArgs

func ApplicationInfoResponsePtr(v *ApplicationInfoResponseArgs) ApplicationInfoResponsePtrInput {
	return (*applicationInfoResponsePtrType)(v)
}

func (*applicationInfoResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationInfoResponse)(nil)).Elem()
}

func (i *applicationInfoResponsePtrType) ToApplicationInfoResponsePtrOutput() ApplicationInfoResponsePtrOutput {
	return i.ToApplicationInfoResponsePtrOutputWithContext(context.Background())
}

func (i *applicationInfoResponsePtrType) ToApplicationInfoResponsePtrOutputWithContext(ctx context.Context) ApplicationInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoResponsePtrOutput)
}

// Application related details of a job posting.
type ApplicationInfoResponseOutput struct{ *pulumi.OutputState }

func (ApplicationInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInfoResponse)(nil)).Elem()
}

func (o ApplicationInfoResponseOutput) ToApplicationInfoResponseOutput() ApplicationInfoResponseOutput {
	return o
}

func (o ApplicationInfoResponseOutput) ToApplicationInfoResponseOutputWithContext(ctx context.Context) ApplicationInfoResponseOutput {
	return o
}

func (o ApplicationInfoResponseOutput) ToApplicationInfoResponsePtrOutput() ApplicationInfoResponsePtrOutput {
	return o.ToApplicationInfoResponsePtrOutputWithContext(context.Background())
}

func (o ApplicationInfoResponseOutput) ToApplicationInfoResponsePtrOutputWithContext(ctx context.Context) ApplicationInfoResponsePtrOutput {
	return o.ApplyT(func(v ApplicationInfoResponse) *ApplicationInfoResponse {
		return &v
	}).(ApplicationInfoResponsePtrOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
func (o ApplicationInfoResponseOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ApplicationInfoResponse) []string { return v.Emails }).(pulumi.StringArrayOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
func (o ApplicationInfoResponseOutput) Instruction() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationInfoResponse) string { return v.Instruction }).(pulumi.StringOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
func (o ApplicationInfoResponseOutput) Uris() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ApplicationInfoResponse) []string { return v.Uris }).(pulumi.StringArrayOutput)
}

type ApplicationInfoResponsePtrOutput struct{ *pulumi.OutputState }

func (ApplicationInfoResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationInfoResponse)(nil)).Elem()
}

func (o ApplicationInfoResponsePtrOutput) ToApplicationInfoResponsePtrOutput() ApplicationInfoResponsePtrOutput {
	return o
}

func (o ApplicationInfoResponsePtrOutput) ToApplicationInfoResponsePtrOutputWithContext(ctx context.Context) ApplicationInfoResponsePtrOutput {
	return o
}

func (o ApplicationInfoResponsePtrOutput) Elem() ApplicationInfoResponseOutput {
	return o.ApplyT(func(v *ApplicationInfoResponse) ApplicationInfoResponse { return *v }).(ApplicationInfoResponseOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
func (o ApplicationInfoResponsePtrOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationInfoResponse) []string {
		if v == nil {
			return nil
		}
		return v.Emails
	}).(pulumi.StringArrayOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
func (o ApplicationInfoResponsePtrOutput) Instruction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationInfoResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Instruction
	}).(pulumi.StringPtrOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
func (o ApplicationInfoResponsePtrOutput) Uris() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationInfoResponse) []string {
		if v == nil {
			return nil
		}
		return v.Uris
	}).(pulumi.StringArrayOutput)
}

// Derived details about the company.
type CompanyDerivedInfoResponse struct {
	// A structured headquarters location of the company, resolved from Company.hq_location if provided.
	HeadquartersLocation LocationResponse `pulumi:"headquartersLocation"`
}

// CompanyDerivedInfoResponseInput is an input type that accepts CompanyDerivedInfoResponseArgs and CompanyDerivedInfoResponseOutput values.
// You can construct a concrete instance of `CompanyDerivedInfoResponseInput` via:
//
//          CompanyDerivedInfoResponseArgs{...}
type CompanyDerivedInfoResponseInput interface {
	pulumi.Input

	ToCompanyDerivedInfoResponseOutput() CompanyDerivedInfoResponseOutput
	ToCompanyDerivedInfoResponseOutputWithContext(context.Context) CompanyDerivedInfoResponseOutput
}

// Derived details about the company.
type CompanyDerivedInfoResponseArgs struct {
	// A structured headquarters location of the company, resolved from Company.hq_location if provided.
	HeadquartersLocation LocationResponseInput `pulumi:"headquartersLocation"`
}

func (CompanyDerivedInfoResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompanyDerivedInfoResponse)(nil)).Elem()
}

func (i CompanyDerivedInfoResponseArgs) ToCompanyDerivedInfoResponseOutput() CompanyDerivedInfoResponseOutput {
	return i.ToCompanyDerivedInfoResponseOutputWithContext(context.Background())
}

func (i CompanyDerivedInfoResponseArgs) ToCompanyDerivedInfoResponseOutputWithContext(ctx context.Context) CompanyDerivedInfoResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyDerivedInfoResponseOutput)
}

func (i CompanyDerivedInfoResponseArgs) ToCompanyDerivedInfoResponsePtrOutput() CompanyDerivedInfoResponsePtrOutput {
	return i.ToCompanyDerivedInfoResponsePtrOutputWithContext(context.Background())
}

func (i CompanyDerivedInfoResponseArgs) ToCompanyDerivedInfoResponsePtrOutputWithContext(ctx context.Context) CompanyDerivedInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyDerivedInfoResponseOutput).ToCompanyDerivedInfoResponsePtrOutputWithContext(ctx)
}

// CompanyDerivedInfoResponsePtrInput is an input type that accepts CompanyDerivedInfoResponseArgs, CompanyDerivedInfoResponsePtr and CompanyDerivedInfoResponsePtrOutput values.
// You can construct a concrete instance of `CompanyDerivedInfoResponsePtrInput` via:
//
//          CompanyDerivedInfoResponseArgs{...}
//
//  or:
//
//          nil
type CompanyDerivedInfoResponsePtrInput interface {
	pulumi.Input

	ToCompanyDerivedInfoResponsePtrOutput() CompanyDerivedInfoResponsePtrOutput
	ToCompanyDerivedInfoResponsePtrOutputWithContext(context.Context) CompanyDerivedInfoResponsePtrOutput
}

type companyDerivedInfoResponsePtrType CompanyDerivedInfoResponseArgs

func CompanyDerivedInfoResponsePtr(v *CompanyDerivedInfoResponseArgs) CompanyDerivedInfoResponsePtrInput {
	return (*companyDerivedInfoResponsePtrType)(v)
}

func (*companyDerivedInfoResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompanyDerivedInfoResponse)(nil)).Elem()
}

func (i *companyDerivedInfoResponsePtrType) ToCompanyDerivedInfoResponsePtrOutput() CompanyDerivedInfoResponsePtrOutput {
	return i.ToCompanyDerivedInfoResponsePtrOutputWithContext(context.Background())
}

func (i *companyDerivedInfoResponsePtrType) ToCompanyDerivedInfoResponsePtrOutputWithContext(ctx context.Context) CompanyDerivedInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyDerivedInfoResponsePtrOutput)
}

// Derived details about the company.
type CompanyDerivedInfoResponseOutput struct{ *pulumi.OutputState }

func (CompanyDerivedInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompanyDerivedInfoResponse)(nil)).Elem()
}

func (o CompanyDerivedInfoResponseOutput) ToCompanyDerivedInfoResponseOutput() CompanyDerivedInfoResponseOutput {
	return o
}

func (o CompanyDerivedInfoResponseOutput) ToCompanyDerivedInfoResponseOutputWithContext(ctx context.Context) CompanyDerivedInfoResponseOutput {
	return o
}

func (o CompanyDerivedInfoResponseOutput) ToCompanyDerivedInfoResponsePtrOutput() CompanyDerivedInfoResponsePtrOutput {
	return o.ToCompanyDerivedInfoResponsePtrOutputWithContext(context.Background())
}

func (o CompanyDerivedInfoResponseOutput) ToCompanyDerivedInfoResponsePtrOutputWithContext(ctx context.Context) CompanyDerivedInfoResponsePtrOutput {
	return o.ApplyT(func(v CompanyDerivedInfoResponse) *CompanyDerivedInfoResponse {
		return &v
	}).(CompanyDerivedInfoResponsePtrOutput)
}

// A structured headquarters location of the company, resolved from Company.hq_location if provided.
func (o CompanyDerivedInfoResponseOutput) HeadquartersLocation() LocationResponseOutput {
	return o.ApplyT(func(v CompanyDerivedInfoResponse) LocationResponse { return v.HeadquartersLocation }).(LocationResponseOutput)
}

type CompanyDerivedInfoResponsePtrOutput struct{ *pulumi.OutputState }

func (CompanyDerivedInfoResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompanyDerivedInfoResponse)(nil)).Elem()
}

func (o CompanyDerivedInfoResponsePtrOutput) ToCompanyDerivedInfoResponsePtrOutput() CompanyDerivedInfoResponsePtrOutput {
	return o
}

func (o CompanyDerivedInfoResponsePtrOutput) ToCompanyDerivedInfoResponsePtrOutputWithContext(ctx context.Context) CompanyDerivedInfoResponsePtrOutput {
	return o
}

func (o CompanyDerivedInfoResponsePtrOutput) Elem() CompanyDerivedInfoResponseOutput {
	return o.ApplyT(func(v *CompanyDerivedInfoResponse) CompanyDerivedInfoResponse { return *v }).(CompanyDerivedInfoResponseOutput)
}

// A structured headquarters location of the company, resolved from Company.hq_location if provided.
func (o CompanyDerivedInfoResponsePtrOutput) HeadquartersLocation() LocationResponsePtrOutput {
	return o.ApplyT(func(v *CompanyDerivedInfoResponse) *LocationResponse {
		if v == nil {
			return nil
		}
		return &v.HeadquartersLocation
	}).(LocationResponsePtrOutput)
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntry struct {
	// Optional. Compensation amount.
	Amount *Money `pulumi:"amount"`
	// Optional. Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
	Description *string `pulumi:"description"`
	// Optional. Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
	ExpectedUnitsPerYear *float64 `pulumi:"expectedUnitsPerYear"`
	// Optional. Compensation range.
	Range *CompensationRange `pulumi:"range"`
	// Optional. Compensation type. Default is CompensationUnit.COMPENSATION_TYPE_UNSPECIFIED.
	Type *string `pulumi:"type"`
	// Optional. Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
	Unit *string `pulumi:"unit"`
}

// CompensationEntryInput is an input type that accepts CompensationEntryArgs and CompensationEntryOutput values.
// You can construct a concrete instance of `CompensationEntryInput` via:
//
//          CompensationEntryArgs{...}
type CompensationEntryInput interface {
	pulumi.Input

	ToCompensationEntryOutput() CompensationEntryOutput
	ToCompensationEntryOutputWithContext(context.Context) CompensationEntryOutput
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryArgs struct {
	// Optional. Compensation amount.
	Amount MoneyPtrInput `pulumi:"amount"`
	// Optional. Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Optional. Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
	ExpectedUnitsPerYear pulumi.Float64PtrInput `pulumi:"expectedUnitsPerYear"`
	// Optional. Compensation range.
	Range CompensationRangePtrInput `pulumi:"range"`
	// Optional. Compensation type. Default is CompensationUnit.COMPENSATION_TYPE_UNSPECIFIED.
	Type *CompensationEntryType `pulumi:"type"`
	// Optional. Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
	Unit *CompensationEntryUnit `pulumi:"unit"`
}

func (CompensationEntryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationEntry)(nil)).Elem()
}

func (i CompensationEntryArgs) ToCompensationEntryOutput() CompensationEntryOutput {
	return i.ToCompensationEntryOutputWithContext(context.Background())
}

func (i CompensationEntryArgs) ToCompensationEntryOutputWithContext(ctx context.Context) CompensationEntryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationEntryOutput)
}

// CompensationEntryArrayInput is an input type that accepts CompensationEntryArray and CompensationEntryArrayOutput values.
// You can construct a concrete instance of `CompensationEntryArrayInput` via:
//
//          CompensationEntryArray{ CompensationEntryArgs{...} }
type CompensationEntryArrayInput interface {
	pulumi.Input

	ToCompensationEntryArrayOutput() CompensationEntryArrayOutput
	ToCompensationEntryArrayOutputWithContext(context.Context) CompensationEntryArrayOutput
}

type CompensationEntryArray []CompensationEntryInput

func (CompensationEntryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CompensationEntry)(nil)).Elem()
}

func (i CompensationEntryArray) ToCompensationEntryArrayOutput() CompensationEntryArrayOutput {
	return i.ToCompensationEntryArrayOutputWithContext(context.Background())
}

func (i CompensationEntryArray) ToCompensationEntryArrayOutputWithContext(ctx context.Context) CompensationEntryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationEntryArrayOutput)
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryOutput struct{ *pulumi.OutputState }

func (CompensationEntryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationEntry)(nil)).Elem()
}

func (o CompensationEntryOutput) ToCompensationEntryOutput() CompensationEntryOutput {
	return o
}

func (o CompensationEntryOutput) ToCompensationEntryOutputWithContext(ctx context.Context) CompensationEntryOutput {
	return o
}

// Optional. Compensation amount.
func (o CompensationEntryOutput) Amount() MoneyPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *Money { return v.Amount }).(MoneyPtrOutput)
}

// Optional. Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
func (o CompensationEntryOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Optional. Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
func (o CompensationEntryOutput) ExpectedUnitsPerYear() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v CompensationEntry) *float64 { return v.ExpectedUnitsPerYear }).(pulumi.Float64PtrOutput)
}

// Optional. Compensation range.
func (o CompensationEntryOutput) Range() CompensationRangePtrOutput {
	return o.ApplyT(func(v CompensationEntry) *CompensationRange { return v.Range }).(CompensationRangePtrOutput)
}

// Optional. Compensation type. Default is CompensationUnit.COMPENSATION_TYPE_UNSPECIFIED.
func (o CompensationEntryOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Optional. Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
func (o CompensationEntryOutput) Unit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *string { return v.Unit }).(pulumi.StringPtrOutput)
}

type CompensationEntryArrayOutput struct{ *pulumi.OutputState }

func (CompensationEntryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CompensationEntry)(nil)).Elem()
}

func (o CompensationEntryArrayOutput) ToCompensationEntryArrayOutput() CompensationEntryArrayOutput {
	return o
}

func (o CompensationEntryArrayOutput) ToCompensationEntryArrayOutputWithContext(ctx context.Context) CompensationEntryArrayOutput {
	return o
}

func (o CompensationEntryArrayOutput) Index(i pulumi.IntInput) CompensationEntryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CompensationEntry {
		return vs[0].([]CompensationEntry)[vs[1].(int)]
	}).(CompensationEntryOutput)
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryResponse struct {
	// Optional. Compensation amount.
	Amount MoneyResponse `pulumi:"amount"`
	// Optional. Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
	Description string `pulumi:"description"`
	// Optional. Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
	ExpectedUnitsPerYear float64 `pulumi:"expectedUnitsPerYear"`
	// Optional. Compensation range.
	Range CompensationRangeResponse `pulumi:"range"`
	// Optional. Compensation type. Default is CompensationUnit.COMPENSATION_TYPE_UNSPECIFIED.
	Type string `pulumi:"type"`
	// Optional. Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
	Unit string `pulumi:"unit"`
}

// CompensationEntryResponseInput is an input type that accepts CompensationEntryResponseArgs and CompensationEntryResponseOutput values.
// You can construct a concrete instance of `CompensationEntryResponseInput` via:
//
//          CompensationEntryResponseArgs{...}
type CompensationEntryResponseInput interface {
	pulumi.Input

	ToCompensationEntryResponseOutput() CompensationEntryResponseOutput
	ToCompensationEntryResponseOutputWithContext(context.Context) CompensationEntryResponseOutput
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryResponseArgs struct {
	// Optional. Compensation amount.
	Amount MoneyResponseInput `pulumi:"amount"`
	// Optional. Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
	Description pulumi.StringInput `pulumi:"description"`
	// Optional. Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
	ExpectedUnitsPerYear pulumi.Float64Input `pulumi:"expectedUnitsPerYear"`
	// Optional. Compensation range.
	Range CompensationRangeResponseInput `pulumi:"range"`
	// Optional. Compensation type. Default is CompensationUnit.COMPENSATION_TYPE_UNSPECIFIED.
	Type pulumi.StringInput `pulumi:"type"`
	// Optional. Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
	Unit pulumi.StringInput `pulumi:"unit"`
}

func (CompensationEntryResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationEntryResponse)(nil)).Elem()
}

func (i CompensationEntryResponseArgs) ToCompensationEntryResponseOutput() CompensationEntryResponseOutput {
	return i.ToCompensationEntryResponseOutputWithContext(context.Background())
}

func (i CompensationEntryResponseArgs) ToCompensationEntryResponseOutputWithContext(ctx context.Context) CompensationEntryResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationEntryResponseOutput)
}

// CompensationEntryResponseArrayInput is an input type that accepts CompensationEntryResponseArray and CompensationEntryResponseArrayOutput values.
// You can construct a concrete instance of `CompensationEntryResponseArrayInput` via:
//
//          CompensationEntryResponseArray{ CompensationEntryResponseArgs{...} }
type CompensationEntryResponseArrayInput interface {
	pulumi.Input

	ToCompensationEntryResponseArrayOutput() CompensationEntryResponseArrayOutput
	ToCompensationEntryResponseArrayOutputWithContext(context.Context) CompensationEntryResponseArrayOutput
}

type CompensationEntryResponseArray []CompensationEntryResponseInput

func (CompensationEntryResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CompensationEntryResponse)(nil)).Elem()
}

func (i CompensationEntryResponseArray) ToCompensationEntryResponseArrayOutput() CompensationEntryResponseArrayOutput {
	return i.ToCompensationEntryResponseArrayOutputWithContext(context.Background())
}

func (i CompensationEntryResponseArray) ToCompensationEntryResponseArrayOutputWithContext(ctx context.Context) CompensationEntryResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationEntryResponseArrayOutput)
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryResponseOutput struct{ *pulumi.OutputState }

func (CompensationEntryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationEntryResponse)(nil)).Elem()
}

func (o CompensationEntryResponseOutput) ToCompensationEntryResponseOutput() CompensationEntryResponseOutput {
	return o
}

func (o CompensationEntryResponseOutput) ToCompensationEntryResponseOutputWithContext(ctx context.Context) CompensationEntryResponseOutput {
	return o
}

// Optional. Compensation amount.
func (o CompensationEntryResponseOutput) Amount() MoneyResponseOutput {
	return o.ApplyT(func(v CompensationEntryResponse) MoneyResponse { return v.Amount }).(MoneyResponseOutput)
}

// Optional. Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
func (o CompensationEntryResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v CompensationEntryResponse) string { return v.Description }).(pulumi.StringOutput)
}

// Optional. Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
func (o CompensationEntryResponseOutput) ExpectedUnitsPerYear() pulumi.Float64Output {
	return o.ApplyT(func(v CompensationEntryResponse) float64 { return v.ExpectedUnitsPerYear }).(pulumi.Float64Output)
}

// Optional. Compensation range.
func (o CompensationEntryResponseOutput) Range() CompensationRangeResponseOutput {
	return o.ApplyT(func(v CompensationEntryResponse) CompensationRangeResponse { return v.Range }).(CompensationRangeResponseOutput)
}

// Optional. Compensation type. Default is CompensationUnit.COMPENSATION_TYPE_UNSPECIFIED.
func (o CompensationEntryResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v CompensationEntryResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Optional. Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
func (o CompensationEntryResponseOutput) Unit() pulumi.StringOutput {
	return o.ApplyT(func(v CompensationEntryResponse) string { return v.Unit }).(pulumi.StringOutput)
}

type CompensationEntryResponseArrayOutput struct{ *pulumi.OutputState }

func (CompensationEntryResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CompensationEntryResponse)(nil)).Elem()
}

func (o CompensationEntryResponseArrayOutput) ToCompensationEntryResponseArrayOutput() CompensationEntryResponseArrayOutput {
	return o
}

func (o CompensationEntryResponseArrayOutput) ToCompensationEntryResponseArrayOutputWithContext(ctx context.Context) CompensationEntryResponseArrayOutput {
	return o
}

func (o CompensationEntryResponseArrayOutput) Index(i pulumi.IntInput) CompensationEntryResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CompensationEntryResponse {
		return vs[0].([]CompensationEntryResponse)[vs[1].(int)]
	}).(CompensationEntryResponseOutput)
}

// Job compensation details.
type CompensationInfo struct {
	// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
	Entries []CompensationEntry `pulumi:"entries"`
}

// CompensationInfoInput is an input type that accepts CompensationInfoArgs and CompensationInfoOutput values.
// You can construct a concrete instance of `CompensationInfoInput` via:
//
//          CompensationInfoArgs{...}
type CompensationInfoInput interface {
	pulumi.Input

	ToCompensationInfoOutput() CompensationInfoOutput
	ToCompensationInfoOutputWithContext(context.Context) CompensationInfoOutput
}

// Job compensation details.
type CompensationInfoArgs struct {
	// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
	Entries CompensationEntryArrayInput `pulumi:"entries"`
}

func (CompensationInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationInfo)(nil)).Elem()
}

func (i CompensationInfoArgs) ToCompensationInfoOutput() CompensationInfoOutput {
	return i.ToCompensationInfoOutputWithContext(context.Background())
}

func (i CompensationInfoArgs) ToCompensationInfoOutputWithContext(ctx context.Context) CompensationInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoOutput)
}

func (i CompensationInfoArgs) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return i.ToCompensationInfoPtrOutputWithContext(context.Background())
}

func (i CompensationInfoArgs) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoOutput).ToCompensationInfoPtrOutputWithContext(ctx)
}

// CompensationInfoPtrInput is an input type that accepts CompensationInfoArgs, CompensationInfoPtr and CompensationInfoPtrOutput values.
// You can construct a concrete instance of `CompensationInfoPtrInput` via:
//
//          CompensationInfoArgs{...}
//
//  or:
//
//          nil
type CompensationInfoPtrInput interface {
	pulumi.Input

	ToCompensationInfoPtrOutput() CompensationInfoPtrOutput
	ToCompensationInfoPtrOutputWithContext(context.Context) CompensationInfoPtrOutput
}

type compensationInfoPtrType CompensationInfoArgs

func CompensationInfoPtr(v *CompensationInfoArgs) CompensationInfoPtrInput {
	return (*compensationInfoPtrType)(v)
}

func (*compensationInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationInfo)(nil)).Elem()
}

func (i *compensationInfoPtrType) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return i.ToCompensationInfoPtrOutputWithContext(context.Background())
}

func (i *compensationInfoPtrType) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoPtrOutput)
}

// Job compensation details.
type CompensationInfoOutput struct{ *pulumi.OutputState }

func (CompensationInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationInfo)(nil)).Elem()
}

func (o CompensationInfoOutput) ToCompensationInfoOutput() CompensationInfoOutput {
	return o
}

func (o CompensationInfoOutput) ToCompensationInfoOutputWithContext(ctx context.Context) CompensationInfoOutput {
	return o
}

func (o CompensationInfoOutput) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return o.ToCompensationInfoPtrOutputWithContext(context.Background())
}

func (o CompensationInfoOutput) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return o.ApplyT(func(v CompensationInfo) *CompensationInfo {
		return &v
	}).(CompensationInfoPtrOutput)
}

// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
func (o CompensationInfoOutput) Entries() CompensationEntryArrayOutput {
	return o.ApplyT(func(v CompensationInfo) []CompensationEntry { return v.Entries }).(CompensationEntryArrayOutput)
}

type CompensationInfoPtrOutput struct{ *pulumi.OutputState }

func (CompensationInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationInfo)(nil)).Elem()
}

func (o CompensationInfoPtrOutput) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return o
}

func (o CompensationInfoPtrOutput) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return o
}

func (o CompensationInfoPtrOutput) Elem() CompensationInfoOutput {
	return o.ApplyT(func(v *CompensationInfo) CompensationInfo { return *v }).(CompensationInfoOutput)
}

// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
func (o CompensationInfoPtrOutput) Entries() CompensationEntryArrayOutput {
	return o.ApplyT(func(v *CompensationInfo) []CompensationEntry {
		if v == nil {
			return nil
		}
		return v.Entries
	}).(CompensationEntryArrayOutput)
}

// Job compensation details.
type CompensationInfoResponse struct {
	// Annualized base compensation range. Computed as base compensation entry's CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedBaseCompensationRange CompensationRangeResponse `pulumi:"annualizedBaseCompensationRange"`
	// Annualized total compensation range. Computed as all compensation entries' CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedTotalCompensationRange CompensationRangeResponse `pulumi:"annualizedTotalCompensationRange"`
	// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
	Entries []CompensationEntryResponse `pulumi:"entries"`
}

// CompensationInfoResponseInput is an input type that accepts CompensationInfoResponseArgs and CompensationInfoResponseOutput values.
// You can construct a concrete instance of `CompensationInfoResponseInput` via:
//
//          CompensationInfoResponseArgs{...}
type CompensationInfoResponseInput interface {
	pulumi.Input

	ToCompensationInfoResponseOutput() CompensationInfoResponseOutput
	ToCompensationInfoResponseOutputWithContext(context.Context) CompensationInfoResponseOutput
}

// Job compensation details.
type CompensationInfoResponseArgs struct {
	// Annualized base compensation range. Computed as base compensation entry's CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedBaseCompensationRange CompensationRangeResponseInput `pulumi:"annualizedBaseCompensationRange"`
	// Annualized total compensation range. Computed as all compensation entries' CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedTotalCompensationRange CompensationRangeResponseInput `pulumi:"annualizedTotalCompensationRange"`
	// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
	Entries CompensationEntryResponseArrayInput `pulumi:"entries"`
}

func (CompensationInfoResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationInfoResponse)(nil)).Elem()
}

func (i CompensationInfoResponseArgs) ToCompensationInfoResponseOutput() CompensationInfoResponseOutput {
	return i.ToCompensationInfoResponseOutputWithContext(context.Background())
}

func (i CompensationInfoResponseArgs) ToCompensationInfoResponseOutputWithContext(ctx context.Context) CompensationInfoResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoResponseOutput)
}

func (i CompensationInfoResponseArgs) ToCompensationInfoResponsePtrOutput() CompensationInfoResponsePtrOutput {
	return i.ToCompensationInfoResponsePtrOutputWithContext(context.Background())
}

func (i CompensationInfoResponseArgs) ToCompensationInfoResponsePtrOutputWithContext(ctx context.Context) CompensationInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoResponseOutput).ToCompensationInfoResponsePtrOutputWithContext(ctx)
}

// CompensationInfoResponsePtrInput is an input type that accepts CompensationInfoResponseArgs, CompensationInfoResponsePtr and CompensationInfoResponsePtrOutput values.
// You can construct a concrete instance of `CompensationInfoResponsePtrInput` via:
//
//          CompensationInfoResponseArgs{...}
//
//  or:
//
//          nil
type CompensationInfoResponsePtrInput interface {
	pulumi.Input

	ToCompensationInfoResponsePtrOutput() CompensationInfoResponsePtrOutput
	ToCompensationInfoResponsePtrOutputWithContext(context.Context) CompensationInfoResponsePtrOutput
}

type compensationInfoResponsePtrType CompensationInfoResponseArgs

func CompensationInfoResponsePtr(v *CompensationInfoResponseArgs) CompensationInfoResponsePtrInput {
	return (*compensationInfoResponsePtrType)(v)
}

func (*compensationInfoResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationInfoResponse)(nil)).Elem()
}

func (i *compensationInfoResponsePtrType) ToCompensationInfoResponsePtrOutput() CompensationInfoResponsePtrOutput {
	return i.ToCompensationInfoResponsePtrOutputWithContext(context.Background())
}

func (i *compensationInfoResponsePtrType) ToCompensationInfoResponsePtrOutputWithContext(ctx context.Context) CompensationInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoResponsePtrOutput)
}

// Job compensation details.
type CompensationInfoResponseOutput struct{ *pulumi.OutputState }

func (CompensationInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationInfoResponse)(nil)).Elem()
}

func (o CompensationInfoResponseOutput) ToCompensationInfoResponseOutput() CompensationInfoResponseOutput {
	return o
}

func (o CompensationInfoResponseOutput) ToCompensationInfoResponseOutputWithContext(ctx context.Context) CompensationInfoResponseOutput {
	return o
}

func (o CompensationInfoResponseOutput) ToCompensationInfoResponsePtrOutput() CompensationInfoResponsePtrOutput {
	return o.ToCompensationInfoResponsePtrOutputWithContext(context.Background())
}

func (o CompensationInfoResponseOutput) ToCompensationInfoResponsePtrOutputWithContext(ctx context.Context) CompensationInfoResponsePtrOutput {
	return o.ApplyT(func(v CompensationInfoResponse) *CompensationInfoResponse {
		return &v
	}).(CompensationInfoResponsePtrOutput)
}

// Annualized base compensation range. Computed as base compensation entry's CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoResponseOutput) AnnualizedBaseCompensationRange() CompensationRangeResponseOutput {
	return o.ApplyT(func(v CompensationInfoResponse) CompensationRangeResponse { return v.AnnualizedBaseCompensationRange }).(CompensationRangeResponseOutput)
}

// Annualized total compensation range. Computed as all compensation entries' CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoResponseOutput) AnnualizedTotalCompensationRange() CompensationRangeResponseOutput {
	return o.ApplyT(func(v CompensationInfoResponse) CompensationRangeResponse { return v.AnnualizedTotalCompensationRange }).(CompensationRangeResponseOutput)
}

// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
func (o CompensationInfoResponseOutput) Entries() CompensationEntryResponseArrayOutput {
	return o.ApplyT(func(v CompensationInfoResponse) []CompensationEntryResponse { return v.Entries }).(CompensationEntryResponseArrayOutput)
}

type CompensationInfoResponsePtrOutput struct{ *pulumi.OutputState }

func (CompensationInfoResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationInfoResponse)(nil)).Elem()
}

func (o CompensationInfoResponsePtrOutput) ToCompensationInfoResponsePtrOutput() CompensationInfoResponsePtrOutput {
	return o
}

func (o CompensationInfoResponsePtrOutput) ToCompensationInfoResponsePtrOutputWithContext(ctx context.Context) CompensationInfoResponsePtrOutput {
	return o
}

func (o CompensationInfoResponsePtrOutput) Elem() CompensationInfoResponseOutput {
	return o.ApplyT(func(v *CompensationInfoResponse) CompensationInfoResponse { return *v }).(CompensationInfoResponseOutput)
}

// Annualized base compensation range. Computed as base compensation entry's CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoResponsePtrOutput) AnnualizedBaseCompensationRange() CompensationRangeResponsePtrOutput {
	return o.ApplyT(func(v *CompensationInfoResponse) *CompensationRangeResponse {
		if v == nil {
			return nil
		}
		return &v.AnnualizedBaseCompensationRange
	}).(CompensationRangeResponsePtrOutput)
}

// Annualized total compensation range. Computed as all compensation entries' CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoResponsePtrOutput) AnnualizedTotalCompensationRange() CompensationRangeResponsePtrOutput {
	return o.ApplyT(func(v *CompensationInfoResponse) *CompensationRangeResponse {
		if v == nil {
			return nil
		}
		return &v.AnnualizedTotalCompensationRange
	}).(CompensationRangeResponsePtrOutput)
}

// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
func (o CompensationInfoResponsePtrOutput) Entries() CompensationEntryResponseArrayOutput {
	return o.ApplyT(func(v *CompensationInfoResponse) []CompensationEntryResponse {
		if v == nil {
			return nil
		}
		return v.Entries
	}).(CompensationEntryResponseArrayOutput)
}

// Compensation range.
type CompensationRange struct {
	// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
	MaxCompensation *Money `pulumi:"maxCompensation"`
	// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
	MinCompensation *Money `pulumi:"minCompensation"`
}

// CompensationRangeInput is an input type that accepts CompensationRangeArgs and CompensationRangeOutput values.
// You can construct a concrete instance of `CompensationRangeInput` via:
//
//          CompensationRangeArgs{...}
type CompensationRangeInput interface {
	pulumi.Input

	ToCompensationRangeOutput() CompensationRangeOutput
	ToCompensationRangeOutputWithContext(context.Context) CompensationRangeOutput
}

// Compensation range.
type CompensationRangeArgs struct {
	// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
	MaxCompensation MoneyPtrInput `pulumi:"maxCompensation"`
	// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
	MinCompensation MoneyPtrInput `pulumi:"minCompensation"`
}

func (CompensationRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationRange)(nil)).Elem()
}

func (i CompensationRangeArgs) ToCompensationRangeOutput() CompensationRangeOutput {
	return i.ToCompensationRangeOutputWithContext(context.Background())
}

func (i CompensationRangeArgs) ToCompensationRangeOutputWithContext(ctx context.Context) CompensationRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangeOutput)
}

func (i CompensationRangeArgs) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return i.ToCompensationRangePtrOutputWithContext(context.Background())
}

func (i CompensationRangeArgs) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangeOutput).ToCompensationRangePtrOutputWithContext(ctx)
}

// CompensationRangePtrInput is an input type that accepts CompensationRangeArgs, CompensationRangePtr and CompensationRangePtrOutput values.
// You can construct a concrete instance of `CompensationRangePtrInput` via:
//
//          CompensationRangeArgs{...}
//
//  or:
//
//          nil
type CompensationRangePtrInput interface {
	pulumi.Input

	ToCompensationRangePtrOutput() CompensationRangePtrOutput
	ToCompensationRangePtrOutputWithContext(context.Context) CompensationRangePtrOutput
}

type compensationRangePtrType CompensationRangeArgs

func CompensationRangePtr(v *CompensationRangeArgs) CompensationRangePtrInput {
	return (*compensationRangePtrType)(v)
}

func (*compensationRangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationRange)(nil)).Elem()
}

func (i *compensationRangePtrType) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return i.ToCompensationRangePtrOutputWithContext(context.Background())
}

func (i *compensationRangePtrType) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangePtrOutput)
}

// Compensation range.
type CompensationRangeOutput struct{ *pulumi.OutputState }

func (CompensationRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationRange)(nil)).Elem()
}

func (o CompensationRangeOutput) ToCompensationRangeOutput() CompensationRangeOutput {
	return o
}

func (o CompensationRangeOutput) ToCompensationRangeOutputWithContext(ctx context.Context) CompensationRangeOutput {
	return o
}

func (o CompensationRangeOutput) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return o.ToCompensationRangePtrOutputWithContext(context.Background())
}

func (o CompensationRangeOutput) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return o.ApplyT(func(v CompensationRange) *CompensationRange {
		return &v
	}).(CompensationRangePtrOutput)
}

// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
func (o CompensationRangeOutput) MaxCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v CompensationRange) *Money { return v.MaxCompensation }).(MoneyPtrOutput)
}

// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
func (o CompensationRangeOutput) MinCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v CompensationRange) *Money { return v.MinCompensation }).(MoneyPtrOutput)
}

type CompensationRangePtrOutput struct{ *pulumi.OutputState }

func (CompensationRangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationRange)(nil)).Elem()
}

func (o CompensationRangePtrOutput) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return o
}

func (o CompensationRangePtrOutput) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return o
}

func (o CompensationRangePtrOutput) Elem() CompensationRangeOutput {
	return o.ApplyT(func(v *CompensationRange) CompensationRange { return *v }).(CompensationRangeOutput)
}

// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
func (o CompensationRangePtrOutput) MaxCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v *CompensationRange) *Money {
		if v == nil {
			return nil
		}
		return v.MaxCompensation
	}).(MoneyPtrOutput)
}

// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
func (o CompensationRangePtrOutput) MinCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v *CompensationRange) *Money {
		if v == nil {
			return nil
		}
		return v.MinCompensation
	}).(MoneyPtrOutput)
}

// Compensation range.
type CompensationRangeResponse struct {
	// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
	MaxCompensation MoneyResponse `pulumi:"maxCompensation"`
	// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
	MinCompensation MoneyResponse `pulumi:"minCompensation"`
}

// CompensationRangeResponseInput is an input type that accepts CompensationRangeResponseArgs and CompensationRangeResponseOutput values.
// You can construct a concrete instance of `CompensationRangeResponseInput` via:
//
//          CompensationRangeResponseArgs{...}
type CompensationRangeResponseInput interface {
	pulumi.Input

	ToCompensationRangeResponseOutput() CompensationRangeResponseOutput
	ToCompensationRangeResponseOutputWithContext(context.Context) CompensationRangeResponseOutput
}

// Compensation range.
type CompensationRangeResponseArgs struct {
	// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
	MaxCompensation MoneyResponseInput `pulumi:"maxCompensation"`
	// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
	MinCompensation MoneyResponseInput `pulumi:"minCompensation"`
}

func (CompensationRangeResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationRangeResponse)(nil)).Elem()
}

func (i CompensationRangeResponseArgs) ToCompensationRangeResponseOutput() CompensationRangeResponseOutput {
	return i.ToCompensationRangeResponseOutputWithContext(context.Background())
}

func (i CompensationRangeResponseArgs) ToCompensationRangeResponseOutputWithContext(ctx context.Context) CompensationRangeResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangeResponseOutput)
}

func (i CompensationRangeResponseArgs) ToCompensationRangeResponsePtrOutput() CompensationRangeResponsePtrOutput {
	return i.ToCompensationRangeResponsePtrOutputWithContext(context.Background())
}

func (i CompensationRangeResponseArgs) ToCompensationRangeResponsePtrOutputWithContext(ctx context.Context) CompensationRangeResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangeResponseOutput).ToCompensationRangeResponsePtrOutputWithContext(ctx)
}

// CompensationRangeResponsePtrInput is an input type that accepts CompensationRangeResponseArgs, CompensationRangeResponsePtr and CompensationRangeResponsePtrOutput values.
// You can construct a concrete instance of `CompensationRangeResponsePtrInput` via:
//
//          CompensationRangeResponseArgs{...}
//
//  or:
//
//          nil
type CompensationRangeResponsePtrInput interface {
	pulumi.Input

	ToCompensationRangeResponsePtrOutput() CompensationRangeResponsePtrOutput
	ToCompensationRangeResponsePtrOutputWithContext(context.Context) CompensationRangeResponsePtrOutput
}

type compensationRangeResponsePtrType CompensationRangeResponseArgs

func CompensationRangeResponsePtr(v *CompensationRangeResponseArgs) CompensationRangeResponsePtrInput {
	return (*compensationRangeResponsePtrType)(v)
}

func (*compensationRangeResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationRangeResponse)(nil)).Elem()
}

func (i *compensationRangeResponsePtrType) ToCompensationRangeResponsePtrOutput() CompensationRangeResponsePtrOutput {
	return i.ToCompensationRangeResponsePtrOutputWithContext(context.Background())
}

func (i *compensationRangeResponsePtrType) ToCompensationRangeResponsePtrOutputWithContext(ctx context.Context) CompensationRangeResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangeResponsePtrOutput)
}

// Compensation range.
type CompensationRangeResponseOutput struct{ *pulumi.OutputState }

func (CompensationRangeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationRangeResponse)(nil)).Elem()
}

func (o CompensationRangeResponseOutput) ToCompensationRangeResponseOutput() CompensationRangeResponseOutput {
	return o
}

func (o CompensationRangeResponseOutput) ToCompensationRangeResponseOutputWithContext(ctx context.Context) CompensationRangeResponseOutput {
	return o
}

func (o CompensationRangeResponseOutput) ToCompensationRangeResponsePtrOutput() CompensationRangeResponsePtrOutput {
	return o.ToCompensationRangeResponsePtrOutputWithContext(context.Background())
}

func (o CompensationRangeResponseOutput) ToCompensationRangeResponsePtrOutputWithContext(ctx context.Context) CompensationRangeResponsePtrOutput {
	return o.ApplyT(func(v CompensationRangeResponse) *CompensationRangeResponse {
		return &v
	}).(CompensationRangeResponsePtrOutput)
}

// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
func (o CompensationRangeResponseOutput) MaxCompensation() MoneyResponseOutput {
	return o.ApplyT(func(v CompensationRangeResponse) MoneyResponse { return v.MaxCompensation }).(MoneyResponseOutput)
}

// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
func (o CompensationRangeResponseOutput) MinCompensation() MoneyResponseOutput {
	return o.ApplyT(func(v CompensationRangeResponse) MoneyResponse { return v.MinCompensation }).(MoneyResponseOutput)
}

type CompensationRangeResponsePtrOutput struct{ *pulumi.OutputState }

func (CompensationRangeResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationRangeResponse)(nil)).Elem()
}

func (o CompensationRangeResponsePtrOutput) ToCompensationRangeResponsePtrOutput() CompensationRangeResponsePtrOutput {
	return o
}

func (o CompensationRangeResponsePtrOutput) ToCompensationRangeResponsePtrOutputWithContext(ctx context.Context) CompensationRangeResponsePtrOutput {
	return o
}

func (o CompensationRangeResponsePtrOutput) Elem() CompensationRangeResponseOutput {
	return o.ApplyT(func(v *CompensationRangeResponse) CompensationRangeResponse { return *v }).(CompensationRangeResponseOutput)
}

// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
func (o CompensationRangeResponsePtrOutput) MaxCompensation() MoneyResponsePtrOutput {
	return o.ApplyT(func(v *CompensationRangeResponse) *MoneyResponse {
		if v == nil {
			return nil
		}
		return &v.MaxCompensation
	}).(MoneyResponsePtrOutput)
}

// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
func (o CompensationRangeResponsePtrOutput) MinCompensation() MoneyResponsePtrOutput {
	return o.ApplyT(func(v *CompensationRangeResponse) *MoneyResponse {
		if v == nil {
			return nil
		}
		return &v.MinCompensation
	}).(MoneyResponsePtrOutput)
}

// Output only. Derived details about the job posting.
type JobDerivedInfoResponse struct {
	// Job categories derived from Job.title and Job.description.
	JobCategories []string `pulumi:"jobCategories"`
	// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
	Locations []LocationResponse `pulumi:"locations"`
}

// JobDerivedInfoResponseInput is an input type that accepts JobDerivedInfoResponseArgs and JobDerivedInfoResponseOutput values.
// You can construct a concrete instance of `JobDerivedInfoResponseInput` via:
//
//          JobDerivedInfoResponseArgs{...}
type JobDerivedInfoResponseInput interface {
	pulumi.Input

	ToJobDerivedInfoResponseOutput() JobDerivedInfoResponseOutput
	ToJobDerivedInfoResponseOutputWithContext(context.Context) JobDerivedInfoResponseOutput
}

// Output only. Derived details about the job posting.
type JobDerivedInfoResponseArgs struct {
	// Job categories derived from Job.title and Job.description.
	JobCategories pulumi.StringArrayInput `pulumi:"jobCategories"`
	// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
	Locations LocationResponseArrayInput `pulumi:"locations"`
}

func (JobDerivedInfoResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobDerivedInfoResponse)(nil)).Elem()
}

func (i JobDerivedInfoResponseArgs) ToJobDerivedInfoResponseOutput() JobDerivedInfoResponseOutput {
	return i.ToJobDerivedInfoResponseOutputWithContext(context.Background())
}

func (i JobDerivedInfoResponseArgs) ToJobDerivedInfoResponseOutputWithContext(ctx context.Context) JobDerivedInfoResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobDerivedInfoResponseOutput)
}

func (i JobDerivedInfoResponseArgs) ToJobDerivedInfoResponsePtrOutput() JobDerivedInfoResponsePtrOutput {
	return i.ToJobDerivedInfoResponsePtrOutputWithContext(context.Background())
}

func (i JobDerivedInfoResponseArgs) ToJobDerivedInfoResponsePtrOutputWithContext(ctx context.Context) JobDerivedInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobDerivedInfoResponseOutput).ToJobDerivedInfoResponsePtrOutputWithContext(ctx)
}

// JobDerivedInfoResponsePtrInput is an input type that accepts JobDerivedInfoResponseArgs, JobDerivedInfoResponsePtr and JobDerivedInfoResponsePtrOutput values.
// You can construct a concrete instance of `JobDerivedInfoResponsePtrInput` via:
//
//          JobDerivedInfoResponseArgs{...}
//
//  or:
//
//          nil
type JobDerivedInfoResponsePtrInput interface {
	pulumi.Input

	ToJobDerivedInfoResponsePtrOutput() JobDerivedInfoResponsePtrOutput
	ToJobDerivedInfoResponsePtrOutputWithContext(context.Context) JobDerivedInfoResponsePtrOutput
}

type jobDerivedInfoResponsePtrType JobDerivedInfoResponseArgs

func JobDerivedInfoResponsePtr(v *JobDerivedInfoResponseArgs) JobDerivedInfoResponsePtrInput {
	return (*jobDerivedInfoResponsePtrType)(v)
}

func (*jobDerivedInfoResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**JobDerivedInfoResponse)(nil)).Elem()
}

func (i *jobDerivedInfoResponsePtrType) ToJobDerivedInfoResponsePtrOutput() JobDerivedInfoResponsePtrOutput {
	return i.ToJobDerivedInfoResponsePtrOutputWithContext(context.Background())
}

func (i *jobDerivedInfoResponsePtrType) ToJobDerivedInfoResponsePtrOutputWithContext(ctx context.Context) JobDerivedInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobDerivedInfoResponsePtrOutput)
}

// Output only. Derived details about the job posting.
type JobDerivedInfoResponseOutput struct{ *pulumi.OutputState }

func (JobDerivedInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobDerivedInfoResponse)(nil)).Elem()
}

func (o JobDerivedInfoResponseOutput) ToJobDerivedInfoResponseOutput() JobDerivedInfoResponseOutput {
	return o
}

func (o JobDerivedInfoResponseOutput) ToJobDerivedInfoResponseOutputWithContext(ctx context.Context) JobDerivedInfoResponseOutput {
	return o
}

func (o JobDerivedInfoResponseOutput) ToJobDerivedInfoResponsePtrOutput() JobDerivedInfoResponsePtrOutput {
	return o.ToJobDerivedInfoResponsePtrOutputWithContext(context.Background())
}

func (o JobDerivedInfoResponseOutput) ToJobDerivedInfoResponsePtrOutputWithContext(ctx context.Context) JobDerivedInfoResponsePtrOutput {
	return o.ApplyT(func(v JobDerivedInfoResponse) *JobDerivedInfoResponse {
		return &v
	}).(JobDerivedInfoResponsePtrOutput)
}

// Job categories derived from Job.title and Job.description.
func (o JobDerivedInfoResponseOutput) JobCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobDerivedInfoResponse) []string { return v.JobCategories }).(pulumi.StringArrayOutput)
}

// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
func (o JobDerivedInfoResponseOutput) Locations() LocationResponseArrayOutput {
	return o.ApplyT(func(v JobDerivedInfoResponse) []LocationResponse { return v.Locations }).(LocationResponseArrayOutput)
}

type JobDerivedInfoResponsePtrOutput struct{ *pulumi.OutputState }

func (JobDerivedInfoResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**JobDerivedInfoResponse)(nil)).Elem()
}

func (o JobDerivedInfoResponsePtrOutput) ToJobDerivedInfoResponsePtrOutput() JobDerivedInfoResponsePtrOutput {
	return o
}

func (o JobDerivedInfoResponsePtrOutput) ToJobDerivedInfoResponsePtrOutputWithContext(ctx context.Context) JobDerivedInfoResponsePtrOutput {
	return o
}

func (o JobDerivedInfoResponsePtrOutput) Elem() JobDerivedInfoResponseOutput {
	return o.ApplyT(func(v *JobDerivedInfoResponse) JobDerivedInfoResponse { return *v }).(JobDerivedInfoResponseOutput)
}

// Job categories derived from Job.title and Job.description.
func (o JobDerivedInfoResponsePtrOutput) JobCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *JobDerivedInfoResponse) []string {
		if v == nil {
			return nil
		}
		return v.JobCategories
	}).(pulumi.StringArrayOutput)
}

// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
func (o JobDerivedInfoResponsePtrOutput) Locations() LocationResponseArrayOutput {
	return o.ApplyT(func(v *JobDerivedInfoResponse) []LocationResponse {
		if v == nil {
			return nil
		}
		return v.Locations
	}).(LocationResponseArrayOutput)
}

// An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this object must conform to the WGS84 standard. Values must be within normalized ranges.
type LatLngResponse struct {
	// The latitude in degrees. It must be in the range [-90.0, +90.0].
	Latitude float64 `pulumi:"latitude"`
	// The longitude in degrees. It must be in the range [-180.0, +180.0].
	Longitude float64 `pulumi:"longitude"`
}

// LatLngResponseInput is an input type that accepts LatLngResponseArgs and LatLngResponseOutput values.
// You can construct a concrete instance of `LatLngResponseInput` via:
//
//          LatLngResponseArgs{...}
type LatLngResponseInput interface {
	pulumi.Input

	ToLatLngResponseOutput() LatLngResponseOutput
	ToLatLngResponseOutputWithContext(context.Context) LatLngResponseOutput
}

// An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this object must conform to the WGS84 standard. Values must be within normalized ranges.
type LatLngResponseArgs struct {
	// The latitude in degrees. It must be in the range [-90.0, +90.0].
	Latitude pulumi.Float64Input `pulumi:"latitude"`
	// The longitude in degrees. It must be in the range [-180.0, +180.0].
	Longitude pulumi.Float64Input `pulumi:"longitude"`
}

func (LatLngResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LatLngResponse)(nil)).Elem()
}

func (i LatLngResponseArgs) ToLatLngResponseOutput() LatLngResponseOutput {
	return i.ToLatLngResponseOutputWithContext(context.Background())
}

func (i LatLngResponseArgs) ToLatLngResponseOutputWithContext(ctx context.Context) LatLngResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatLngResponseOutput)
}

func (i LatLngResponseArgs) ToLatLngResponsePtrOutput() LatLngResponsePtrOutput {
	return i.ToLatLngResponsePtrOutputWithContext(context.Background())
}

func (i LatLngResponseArgs) ToLatLngResponsePtrOutputWithContext(ctx context.Context) LatLngResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatLngResponseOutput).ToLatLngResponsePtrOutputWithContext(ctx)
}

// LatLngResponsePtrInput is an input type that accepts LatLngResponseArgs, LatLngResponsePtr and LatLngResponsePtrOutput values.
// You can construct a concrete instance of `LatLngResponsePtrInput` via:
//
//          LatLngResponseArgs{...}
//
//  or:
//
//          nil
type LatLngResponsePtrInput interface {
	pulumi.Input

	ToLatLngResponsePtrOutput() LatLngResponsePtrOutput
	ToLatLngResponsePtrOutputWithContext(context.Context) LatLngResponsePtrOutput
}

type latLngResponsePtrType LatLngResponseArgs

func LatLngResponsePtr(v *LatLngResponseArgs) LatLngResponsePtrInput {
	return (*latLngResponsePtrType)(v)
}

func (*latLngResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LatLngResponse)(nil)).Elem()
}

func (i *latLngResponsePtrType) ToLatLngResponsePtrOutput() LatLngResponsePtrOutput {
	return i.ToLatLngResponsePtrOutputWithContext(context.Background())
}

func (i *latLngResponsePtrType) ToLatLngResponsePtrOutputWithContext(ctx context.Context) LatLngResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatLngResponsePtrOutput)
}

// An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this object must conform to the WGS84 standard. Values must be within normalized ranges.
type LatLngResponseOutput struct{ *pulumi.OutputState }

func (LatLngResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LatLngResponse)(nil)).Elem()
}

func (o LatLngResponseOutput) ToLatLngResponseOutput() LatLngResponseOutput {
	return o
}

func (o LatLngResponseOutput) ToLatLngResponseOutputWithContext(ctx context.Context) LatLngResponseOutput {
	return o
}

func (o LatLngResponseOutput) ToLatLngResponsePtrOutput() LatLngResponsePtrOutput {
	return o.ToLatLngResponsePtrOutputWithContext(context.Background())
}

func (o LatLngResponseOutput) ToLatLngResponsePtrOutputWithContext(ctx context.Context) LatLngResponsePtrOutput {
	return o.ApplyT(func(v LatLngResponse) *LatLngResponse {
		return &v
	}).(LatLngResponsePtrOutput)
}

// The latitude in degrees. It must be in the range [-90.0, +90.0].
func (o LatLngResponseOutput) Latitude() pulumi.Float64Output {
	return o.ApplyT(func(v LatLngResponse) float64 { return v.Latitude }).(pulumi.Float64Output)
}

// The longitude in degrees. It must be in the range [-180.0, +180.0].
func (o LatLngResponseOutput) Longitude() pulumi.Float64Output {
	return o.ApplyT(func(v LatLngResponse) float64 { return v.Longitude }).(pulumi.Float64Output)
}

type LatLngResponsePtrOutput struct{ *pulumi.OutputState }

func (LatLngResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LatLngResponse)(nil)).Elem()
}

func (o LatLngResponsePtrOutput) ToLatLngResponsePtrOutput() LatLngResponsePtrOutput {
	return o
}

func (o LatLngResponsePtrOutput) ToLatLngResponsePtrOutputWithContext(ctx context.Context) LatLngResponsePtrOutput {
	return o
}

func (o LatLngResponsePtrOutput) Elem() LatLngResponseOutput {
	return o.ApplyT(func(v *LatLngResponse) LatLngResponse { return *v }).(LatLngResponseOutput)
}

// The latitude in degrees. It must be in the range [-90.0, +90.0].
func (o LatLngResponsePtrOutput) Latitude() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LatLngResponse) *float64 {
		if v == nil {
			return nil
		}
		return &v.Latitude
	}).(pulumi.Float64PtrOutput)
}

// The longitude in degrees. It must be in the range [-180.0, +180.0].
func (o LatLngResponsePtrOutput) Longitude() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LatLngResponse) *float64 {
		if v == nil {
			return nil
		}
		return &v.Longitude
	}).(pulumi.Float64PtrOutput)
}

// Output only. A resource that represents a location with full geographic information.
type LocationResponse struct {
	// An object representing a latitude/longitude pair.
	LatLng LatLngResponse `pulumi:"latLng"`
	// The type of a location, which corresponds to the address lines field of PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType#NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType#LOCALITY.
	LocationType string `pulumi:"locationType"`
	// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
	PostalAddress PostalAddressResponse `pulumi:"postalAddress"`
	// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
	RadiusInMiles float64 `pulumi:"radiusInMiles"`
}

// LocationResponseInput is an input type that accepts LocationResponseArgs and LocationResponseOutput values.
// You can construct a concrete instance of `LocationResponseInput` via:
//
//          LocationResponseArgs{...}
type LocationResponseInput interface {
	pulumi.Input

	ToLocationResponseOutput() LocationResponseOutput
	ToLocationResponseOutputWithContext(context.Context) LocationResponseOutput
}

// Output only. A resource that represents a location with full geographic information.
type LocationResponseArgs struct {
	// An object representing a latitude/longitude pair.
	LatLng LatLngResponseInput `pulumi:"latLng"`
	// The type of a location, which corresponds to the address lines field of PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType#NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType#LOCALITY.
	LocationType pulumi.StringInput `pulumi:"locationType"`
	// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
	PostalAddress PostalAddressResponseInput `pulumi:"postalAddress"`
	// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
	RadiusInMiles pulumi.Float64Input `pulumi:"radiusInMiles"`
}

func (LocationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationResponse)(nil)).Elem()
}

func (i LocationResponseArgs) ToLocationResponseOutput() LocationResponseOutput {
	return i.ToLocationResponseOutputWithContext(context.Background())
}

func (i LocationResponseArgs) ToLocationResponseOutputWithContext(ctx context.Context) LocationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationResponseOutput)
}

func (i LocationResponseArgs) ToLocationResponsePtrOutput() LocationResponsePtrOutput {
	return i.ToLocationResponsePtrOutputWithContext(context.Background())
}

func (i LocationResponseArgs) ToLocationResponsePtrOutputWithContext(ctx context.Context) LocationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationResponseOutput).ToLocationResponsePtrOutputWithContext(ctx)
}

// LocationResponsePtrInput is an input type that accepts LocationResponseArgs, LocationResponsePtr and LocationResponsePtrOutput values.
// You can construct a concrete instance of `LocationResponsePtrInput` via:
//
//          LocationResponseArgs{...}
//
//  or:
//
//          nil
type LocationResponsePtrInput interface {
	pulumi.Input

	ToLocationResponsePtrOutput() LocationResponsePtrOutput
	ToLocationResponsePtrOutputWithContext(context.Context) LocationResponsePtrOutput
}

type locationResponsePtrType LocationResponseArgs

func LocationResponsePtr(v *LocationResponseArgs) LocationResponsePtrInput {
	return (*locationResponsePtrType)(v)
}

func (*locationResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LocationResponse)(nil)).Elem()
}

func (i *locationResponsePtrType) ToLocationResponsePtrOutput() LocationResponsePtrOutput {
	return i.ToLocationResponsePtrOutputWithContext(context.Background())
}

func (i *locationResponsePtrType) ToLocationResponsePtrOutputWithContext(ctx context.Context) LocationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationResponsePtrOutput)
}

// LocationResponseArrayInput is an input type that accepts LocationResponseArray and LocationResponseArrayOutput values.
// You can construct a concrete instance of `LocationResponseArrayInput` via:
//
//          LocationResponseArray{ LocationResponseArgs{...} }
type LocationResponseArrayInput interface {
	pulumi.Input

	ToLocationResponseArrayOutput() LocationResponseArrayOutput
	ToLocationResponseArrayOutputWithContext(context.Context) LocationResponseArrayOutput
}

type LocationResponseArray []LocationResponseInput

func (LocationResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LocationResponse)(nil)).Elem()
}

func (i LocationResponseArray) ToLocationResponseArrayOutput() LocationResponseArrayOutput {
	return i.ToLocationResponseArrayOutputWithContext(context.Background())
}

func (i LocationResponseArray) ToLocationResponseArrayOutputWithContext(ctx context.Context) LocationResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationResponseArrayOutput)
}

// Output only. A resource that represents a location with full geographic information.
type LocationResponseOutput struct{ *pulumi.OutputState }

func (LocationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationResponse)(nil)).Elem()
}

func (o LocationResponseOutput) ToLocationResponseOutput() LocationResponseOutput {
	return o
}

func (o LocationResponseOutput) ToLocationResponseOutputWithContext(ctx context.Context) LocationResponseOutput {
	return o
}

func (o LocationResponseOutput) ToLocationResponsePtrOutput() LocationResponsePtrOutput {
	return o.ToLocationResponsePtrOutputWithContext(context.Background())
}

func (o LocationResponseOutput) ToLocationResponsePtrOutputWithContext(ctx context.Context) LocationResponsePtrOutput {
	return o.ApplyT(func(v LocationResponse) *LocationResponse {
		return &v
	}).(LocationResponsePtrOutput)
}

// An object representing a latitude/longitude pair.
func (o LocationResponseOutput) LatLng() LatLngResponseOutput {
	return o.ApplyT(func(v LocationResponse) LatLngResponse { return v.LatLng }).(LatLngResponseOutput)
}

// The type of a location, which corresponds to the address lines field of PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType#NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType#LOCALITY.
func (o LocationResponseOutput) LocationType() pulumi.StringOutput {
	return o.ApplyT(func(v LocationResponse) string { return v.LocationType }).(pulumi.StringOutput)
}

// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
func (o LocationResponseOutput) PostalAddress() PostalAddressResponseOutput {
	return o.ApplyT(func(v LocationResponse) PostalAddressResponse { return v.PostalAddress }).(PostalAddressResponseOutput)
}

// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
func (o LocationResponseOutput) RadiusInMiles() pulumi.Float64Output {
	return o.ApplyT(func(v LocationResponse) float64 { return v.RadiusInMiles }).(pulumi.Float64Output)
}

type LocationResponsePtrOutput struct{ *pulumi.OutputState }

func (LocationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LocationResponse)(nil)).Elem()
}

func (o LocationResponsePtrOutput) ToLocationResponsePtrOutput() LocationResponsePtrOutput {
	return o
}

func (o LocationResponsePtrOutput) ToLocationResponsePtrOutputWithContext(ctx context.Context) LocationResponsePtrOutput {
	return o
}

func (o LocationResponsePtrOutput) Elem() LocationResponseOutput {
	return o.ApplyT(func(v *LocationResponse) LocationResponse { return *v }).(LocationResponseOutput)
}

// An object representing a latitude/longitude pair.
func (o LocationResponsePtrOutput) LatLng() LatLngResponsePtrOutput {
	return o.ApplyT(func(v *LocationResponse) *LatLngResponse {
		if v == nil {
			return nil
		}
		return &v.LatLng
	}).(LatLngResponsePtrOutput)
}

// The type of a location, which corresponds to the address lines field of PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType#NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType#LOCALITY.
func (o LocationResponsePtrOutput) LocationType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LocationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.LocationType
	}).(pulumi.StringPtrOutput)
}

// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
func (o LocationResponsePtrOutput) PostalAddress() PostalAddressResponsePtrOutput {
	return o.ApplyT(func(v *LocationResponse) *PostalAddressResponse {
		if v == nil {
			return nil
		}
		return &v.PostalAddress
	}).(PostalAddressResponsePtrOutput)
}

// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
func (o LocationResponsePtrOutput) RadiusInMiles() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LocationResponse) *float64 {
		if v == nil {
			return nil
		}
		return &v.RadiusInMiles
	}).(pulumi.Float64PtrOutput)
}

type LocationResponseArrayOutput struct{ *pulumi.OutputState }

func (LocationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LocationResponse)(nil)).Elem()
}

func (o LocationResponseArrayOutput) ToLocationResponseArrayOutput() LocationResponseArrayOutput {
	return o
}

func (o LocationResponseArrayOutput) ToLocationResponseArrayOutputWithContext(ctx context.Context) LocationResponseArrayOutput {
	return o
}

func (o LocationResponseArrayOutput) Index(i pulumi.IntInput) LocationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LocationResponse {
		return vs[0].([]LocationResponse)[vs[1].(int)]
	}).(LocationResponseOutput)
}

// Represents an amount of money with its currency type.
type Money struct {
	// The three-letter currency code defined in ISO 4217.
	CurrencyCode *string `pulumi:"currencyCode"`
	// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos *int `pulumi:"nanos"`
	// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units *string `pulumi:"units"`
}

// MoneyInput is an input type that accepts MoneyArgs and MoneyOutput values.
// You can construct a concrete instance of `MoneyInput` via:
//
//          MoneyArgs{...}
type MoneyInput interface {
	pulumi.Input

	ToMoneyOutput() MoneyOutput
	ToMoneyOutputWithContext(context.Context) MoneyOutput
}

// Represents an amount of money with its currency type.
type MoneyArgs struct {
	// The three-letter currency code defined in ISO 4217.
	CurrencyCode pulumi.StringPtrInput `pulumi:"currencyCode"`
	// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos pulumi.IntPtrInput `pulumi:"nanos"`
	// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units pulumi.StringPtrInput `pulumi:"units"`
}

func (MoneyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Money)(nil)).Elem()
}

func (i MoneyArgs) ToMoneyOutput() MoneyOutput {
	return i.ToMoneyOutputWithContext(context.Background())
}

func (i MoneyArgs) ToMoneyOutputWithContext(ctx context.Context) MoneyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyOutput)
}

func (i MoneyArgs) ToMoneyPtrOutput() MoneyPtrOutput {
	return i.ToMoneyPtrOutputWithContext(context.Background())
}

func (i MoneyArgs) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyOutput).ToMoneyPtrOutputWithContext(ctx)
}

// MoneyPtrInput is an input type that accepts MoneyArgs, MoneyPtr and MoneyPtrOutput values.
// You can construct a concrete instance of `MoneyPtrInput` via:
//
//          MoneyArgs{...}
//
//  or:
//
//          nil
type MoneyPtrInput interface {
	pulumi.Input

	ToMoneyPtrOutput() MoneyPtrOutput
	ToMoneyPtrOutputWithContext(context.Context) MoneyPtrOutput
}

type moneyPtrType MoneyArgs

func MoneyPtr(v *MoneyArgs) MoneyPtrInput {
	return (*moneyPtrType)(v)
}

func (*moneyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Money)(nil)).Elem()
}

func (i *moneyPtrType) ToMoneyPtrOutput() MoneyPtrOutput {
	return i.ToMoneyPtrOutputWithContext(context.Background())
}

func (i *moneyPtrType) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyPtrOutput)
}

// Represents an amount of money with its currency type.
type MoneyOutput struct{ *pulumi.OutputState }

func (MoneyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Money)(nil)).Elem()
}

func (o MoneyOutput) ToMoneyOutput() MoneyOutput {
	return o
}

func (o MoneyOutput) ToMoneyOutputWithContext(ctx context.Context) MoneyOutput {
	return o
}

func (o MoneyOutput) ToMoneyPtrOutput() MoneyPtrOutput {
	return o.ToMoneyPtrOutputWithContext(context.Background())
}

func (o MoneyOutput) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return o.ApplyT(func(v Money) *Money {
		return &v
	}).(MoneyPtrOutput)
}

// The three-letter currency code defined in ISO 4217.
func (o MoneyOutput) CurrencyCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Money) *string { return v.CurrencyCode }).(pulumi.StringPtrOutput)
}

// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
func (o MoneyOutput) Nanos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Money) *int { return v.Nanos }).(pulumi.IntPtrOutput)
}

// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
func (o MoneyOutput) Units() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Money) *string { return v.Units }).(pulumi.StringPtrOutput)
}

type MoneyPtrOutput struct{ *pulumi.OutputState }

func (MoneyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Money)(nil)).Elem()
}

func (o MoneyPtrOutput) ToMoneyPtrOutput() MoneyPtrOutput {
	return o
}

func (o MoneyPtrOutput) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return o
}

func (o MoneyPtrOutput) Elem() MoneyOutput {
	return o.ApplyT(func(v *Money) Money { return *v }).(MoneyOutput)
}

// The three-letter currency code defined in ISO 4217.
func (o MoneyPtrOutput) CurrencyCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Money) *string {
		if v == nil {
			return nil
		}
		return v.CurrencyCode
	}).(pulumi.StringPtrOutput)
}

// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
func (o MoneyPtrOutput) Nanos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Money) *int {
		if v == nil {
			return nil
		}
		return v.Nanos
	}).(pulumi.IntPtrOutput)
}

// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
func (o MoneyPtrOutput) Units() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Money) *string {
		if v == nil {
			return nil
		}
		return v.Units
	}).(pulumi.StringPtrOutput)
}

// Represents an amount of money with its currency type.
type MoneyResponse struct {
	// The three-letter currency code defined in ISO 4217.
	CurrencyCode string `pulumi:"currencyCode"`
	// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos int `pulumi:"nanos"`
	// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units string `pulumi:"units"`
}

// MoneyResponseInput is an input type that accepts MoneyResponseArgs and MoneyResponseOutput values.
// You can construct a concrete instance of `MoneyResponseInput` via:
//
//          MoneyResponseArgs{...}
type MoneyResponseInput interface {
	pulumi.Input

	ToMoneyResponseOutput() MoneyResponseOutput
	ToMoneyResponseOutputWithContext(context.Context) MoneyResponseOutput
}

// Represents an amount of money with its currency type.
type MoneyResponseArgs struct {
	// The three-letter currency code defined in ISO 4217.
	CurrencyCode pulumi.StringInput `pulumi:"currencyCode"`
	// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos pulumi.IntInput `pulumi:"nanos"`
	// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units pulumi.StringInput `pulumi:"units"`
}

func (MoneyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MoneyResponse)(nil)).Elem()
}

func (i MoneyResponseArgs) ToMoneyResponseOutput() MoneyResponseOutput {
	return i.ToMoneyResponseOutputWithContext(context.Background())
}

func (i MoneyResponseArgs) ToMoneyResponseOutputWithContext(ctx context.Context) MoneyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyResponseOutput)
}

func (i MoneyResponseArgs) ToMoneyResponsePtrOutput() MoneyResponsePtrOutput {
	return i.ToMoneyResponsePtrOutputWithContext(context.Background())
}

func (i MoneyResponseArgs) ToMoneyResponsePtrOutputWithContext(ctx context.Context) MoneyResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyResponseOutput).ToMoneyResponsePtrOutputWithContext(ctx)
}

// MoneyResponsePtrInput is an input type that accepts MoneyResponseArgs, MoneyResponsePtr and MoneyResponsePtrOutput values.
// You can construct a concrete instance of `MoneyResponsePtrInput` via:
//
//          MoneyResponseArgs{...}
//
//  or:
//
//          nil
type MoneyResponsePtrInput interface {
	pulumi.Input

	ToMoneyResponsePtrOutput() MoneyResponsePtrOutput
	ToMoneyResponsePtrOutputWithContext(context.Context) MoneyResponsePtrOutput
}

type moneyResponsePtrType MoneyResponseArgs

func MoneyResponsePtr(v *MoneyResponseArgs) MoneyResponsePtrInput {
	return (*moneyResponsePtrType)(v)
}

func (*moneyResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MoneyResponse)(nil)).Elem()
}

func (i *moneyResponsePtrType) ToMoneyResponsePtrOutput() MoneyResponsePtrOutput {
	return i.ToMoneyResponsePtrOutputWithContext(context.Background())
}

func (i *moneyResponsePtrType) ToMoneyResponsePtrOutputWithContext(ctx context.Context) MoneyResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyResponsePtrOutput)
}

// Represents an amount of money with its currency type.
type MoneyResponseOutput struct{ *pulumi.OutputState }

func (MoneyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MoneyResponse)(nil)).Elem()
}

func (o MoneyResponseOutput) ToMoneyResponseOutput() MoneyResponseOutput {
	return o
}

func (o MoneyResponseOutput) ToMoneyResponseOutputWithContext(ctx context.Context) MoneyResponseOutput {
	return o
}

func (o MoneyResponseOutput) ToMoneyResponsePtrOutput() MoneyResponsePtrOutput {
	return o.ToMoneyResponsePtrOutputWithContext(context.Background())
}

func (o MoneyResponseOutput) ToMoneyResponsePtrOutputWithContext(ctx context.Context) MoneyResponsePtrOutput {
	return o.ApplyT(func(v MoneyResponse) *MoneyResponse {
		return &v
	}).(MoneyResponsePtrOutput)
}

// The three-letter currency code defined in ISO 4217.
func (o MoneyResponseOutput) CurrencyCode() pulumi.StringOutput {
	return o.ApplyT(func(v MoneyResponse) string { return v.CurrencyCode }).(pulumi.StringOutput)
}

// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
func (o MoneyResponseOutput) Nanos() pulumi.IntOutput {
	return o.ApplyT(func(v MoneyResponse) int { return v.Nanos }).(pulumi.IntOutput)
}

// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
func (o MoneyResponseOutput) Units() pulumi.StringOutput {
	return o.ApplyT(func(v MoneyResponse) string { return v.Units }).(pulumi.StringOutput)
}

type MoneyResponsePtrOutput struct{ *pulumi.OutputState }

func (MoneyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MoneyResponse)(nil)).Elem()
}

func (o MoneyResponsePtrOutput) ToMoneyResponsePtrOutput() MoneyResponsePtrOutput {
	return o
}

func (o MoneyResponsePtrOutput) ToMoneyResponsePtrOutputWithContext(ctx context.Context) MoneyResponsePtrOutput {
	return o
}

func (o MoneyResponsePtrOutput) Elem() MoneyResponseOutput {
	return o.ApplyT(func(v *MoneyResponse) MoneyResponse { return *v }).(MoneyResponseOutput)
}

// The three-letter currency code defined in ISO 4217.
func (o MoneyResponsePtrOutput) CurrencyCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MoneyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.CurrencyCode
	}).(pulumi.StringPtrOutput)
}

// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
func (o MoneyResponsePtrOutput) Nanos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *MoneyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Nanos
	}).(pulumi.IntPtrOutput)
}

// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
func (o MoneyResponsePtrOutput) Units() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MoneyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Units
	}).(pulumi.StringPtrOutput)
}

// Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an i18n-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
type PostalAddressResponse struct {
	// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
	AddressLines []string `pulumi:"addressLines"`
	// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
	AdministrativeArea string `pulumi:"administrativeArea"`
	// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode string `pulumi:"languageCode"`
	// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
	Locality string `pulumi:"locality"`
	// Optional. The name of the organization at the address.
	Organization string `pulumi:"organization"`
	// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode string `pulumi:"postalCode"`
	// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
	Recipients []string `pulumi:"recipients"`
	// CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
	RegionCode string `pulumi:"regionCode"`
	// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
	Revision int `pulumi:"revision"`
	// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
	SortingCode string `pulumi:"sortingCode"`
	// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
	Sublocality string `pulumi:"sublocality"`
}

// PostalAddressResponseInput is an input type that accepts PostalAddressResponseArgs and PostalAddressResponseOutput values.
// You can construct a concrete instance of `PostalAddressResponseInput` via:
//
//          PostalAddressResponseArgs{...}
type PostalAddressResponseInput interface {
	pulumi.Input

	ToPostalAddressResponseOutput() PostalAddressResponseOutput
	ToPostalAddressResponseOutputWithContext(context.Context) PostalAddressResponseOutput
}

// Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an i18n-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
type PostalAddressResponseArgs struct {
	// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
	AddressLines pulumi.StringArrayInput `pulumi:"addressLines"`
	// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
	AdministrativeArea pulumi.StringInput `pulumi:"administrativeArea"`
	// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode pulumi.StringInput `pulumi:"languageCode"`
	// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
	Locality pulumi.StringInput `pulumi:"locality"`
	// Optional. The name of the organization at the address.
	Organization pulumi.StringInput `pulumi:"organization"`
	// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode pulumi.StringInput `pulumi:"postalCode"`
	// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
	Recipients pulumi.StringArrayInput `pulumi:"recipients"`
	// CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
	RegionCode pulumi.StringInput `pulumi:"regionCode"`
	// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
	Revision pulumi.IntInput `pulumi:"revision"`
	// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
	SortingCode pulumi.StringInput `pulumi:"sortingCode"`
	// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
	Sublocality pulumi.StringInput `pulumi:"sublocality"`
}

func (PostalAddressResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PostalAddressResponse)(nil)).Elem()
}

func (i PostalAddressResponseArgs) ToPostalAddressResponseOutput() PostalAddressResponseOutput {
	return i.ToPostalAddressResponseOutputWithContext(context.Background())
}

func (i PostalAddressResponseArgs) ToPostalAddressResponseOutputWithContext(ctx context.Context) PostalAddressResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostalAddressResponseOutput)
}

func (i PostalAddressResponseArgs) ToPostalAddressResponsePtrOutput() PostalAddressResponsePtrOutput {
	return i.ToPostalAddressResponsePtrOutputWithContext(context.Background())
}

func (i PostalAddressResponseArgs) ToPostalAddressResponsePtrOutputWithContext(ctx context.Context) PostalAddressResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostalAddressResponseOutput).ToPostalAddressResponsePtrOutputWithContext(ctx)
}

// PostalAddressResponsePtrInput is an input type that accepts PostalAddressResponseArgs, PostalAddressResponsePtr and PostalAddressResponsePtrOutput values.
// You can construct a concrete instance of `PostalAddressResponsePtrInput` via:
//
//          PostalAddressResponseArgs{...}
//
//  or:
//
//          nil
type PostalAddressResponsePtrInput interface {
	pulumi.Input

	ToPostalAddressResponsePtrOutput() PostalAddressResponsePtrOutput
	ToPostalAddressResponsePtrOutputWithContext(context.Context) PostalAddressResponsePtrOutput
}

type postalAddressResponsePtrType PostalAddressResponseArgs

func PostalAddressResponsePtr(v *PostalAddressResponseArgs) PostalAddressResponsePtrInput {
	return (*postalAddressResponsePtrType)(v)
}

func (*postalAddressResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PostalAddressResponse)(nil)).Elem()
}

func (i *postalAddressResponsePtrType) ToPostalAddressResponsePtrOutput() PostalAddressResponsePtrOutput {
	return i.ToPostalAddressResponsePtrOutputWithContext(context.Background())
}

func (i *postalAddressResponsePtrType) ToPostalAddressResponsePtrOutputWithContext(ctx context.Context) PostalAddressResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostalAddressResponsePtrOutput)
}

// Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an i18n-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
type PostalAddressResponseOutput struct{ *pulumi.OutputState }

func (PostalAddressResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PostalAddressResponse)(nil)).Elem()
}

func (o PostalAddressResponseOutput) ToPostalAddressResponseOutput() PostalAddressResponseOutput {
	return o
}

func (o PostalAddressResponseOutput) ToPostalAddressResponseOutputWithContext(ctx context.Context) PostalAddressResponseOutput {
	return o
}

func (o PostalAddressResponseOutput) ToPostalAddressResponsePtrOutput() PostalAddressResponsePtrOutput {
	return o.ToPostalAddressResponsePtrOutputWithContext(context.Background())
}

func (o PostalAddressResponseOutput) ToPostalAddressResponsePtrOutputWithContext(ctx context.Context) PostalAddressResponsePtrOutput {
	return o.ApplyT(func(v PostalAddressResponse) *PostalAddressResponse {
		return &v
	}).(PostalAddressResponsePtrOutput)
}

// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
func (o PostalAddressResponseOutput) AddressLines() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PostalAddressResponse) []string { return v.AddressLines }).(pulumi.StringArrayOutput)
}

// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
func (o PostalAddressResponseOutput) AdministrativeArea() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.AdministrativeArea }).(pulumi.StringOutput)
}

// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
func (o PostalAddressResponseOutput) LanguageCode() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.LanguageCode }).(pulumi.StringOutput)
}

// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
func (o PostalAddressResponseOutput) Locality() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.Locality }).(pulumi.StringOutput)
}

// Optional. The name of the organization at the address.
func (o PostalAddressResponseOutput) Organization() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.Organization }).(pulumi.StringOutput)
}

// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
func (o PostalAddressResponseOutput) PostalCode() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.PostalCode }).(pulumi.StringOutput)
}

// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
func (o PostalAddressResponseOutput) Recipients() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PostalAddressResponse) []string { return v.Recipients }).(pulumi.StringArrayOutput)
}

// CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
func (o PostalAddressResponseOutput) RegionCode() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.RegionCode }).(pulumi.StringOutput)
}

// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
func (o PostalAddressResponseOutput) Revision() pulumi.IntOutput {
	return o.ApplyT(func(v PostalAddressResponse) int { return v.Revision }).(pulumi.IntOutput)
}

// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
func (o PostalAddressResponseOutput) SortingCode() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.SortingCode }).(pulumi.StringOutput)
}

// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
func (o PostalAddressResponseOutput) Sublocality() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.Sublocality }).(pulumi.StringOutput)
}

type PostalAddressResponsePtrOutput struct{ *pulumi.OutputState }

func (PostalAddressResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PostalAddressResponse)(nil)).Elem()
}

func (o PostalAddressResponsePtrOutput) ToPostalAddressResponsePtrOutput() PostalAddressResponsePtrOutput {
	return o
}

func (o PostalAddressResponsePtrOutput) ToPostalAddressResponsePtrOutputWithContext(ctx context.Context) PostalAddressResponsePtrOutput {
	return o
}

func (o PostalAddressResponsePtrOutput) Elem() PostalAddressResponseOutput {
	return o.ApplyT(func(v *PostalAddressResponse) PostalAddressResponse { return *v }).(PostalAddressResponseOutput)
}

// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
func (o PostalAddressResponsePtrOutput) AddressLines() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PostalAddressResponse) []string {
		if v == nil {
			return nil
		}
		return v.AddressLines
	}).(pulumi.StringArrayOutput)
}

// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
func (o PostalAddressResponsePtrOutput) AdministrativeArea() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.AdministrativeArea
	}).(pulumi.StringPtrOutput)
}

// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
func (o PostalAddressResponsePtrOutput) LanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.LanguageCode
	}).(pulumi.StringPtrOutput)
}

// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
func (o PostalAddressResponsePtrOutput) Locality() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Locality
	}).(pulumi.StringPtrOutput)
}

// Optional. The name of the organization at the address.
func (o PostalAddressResponsePtrOutput) Organization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Organization
	}).(pulumi.StringPtrOutput)
}

// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
func (o PostalAddressResponsePtrOutput) PostalCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.PostalCode
	}).(pulumi.StringPtrOutput)
}

// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
func (o PostalAddressResponsePtrOutput) Recipients() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PostalAddressResponse) []string {
		if v == nil {
			return nil
		}
		return v.Recipients
	}).(pulumi.StringArrayOutput)
}

// CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
func (o PostalAddressResponsePtrOutput) RegionCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.RegionCode
	}).(pulumi.StringPtrOutput)
}

// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
func (o PostalAddressResponsePtrOutput) Revision() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Revision
	}).(pulumi.IntPtrOutput)
}

// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
func (o PostalAddressResponsePtrOutput) SortingCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.SortingCode
	}).(pulumi.StringPtrOutput)
}

// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
func (o PostalAddressResponsePtrOutput) Sublocality() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Sublocality
	}).(pulumi.StringPtrOutput)
}

// Input only. Options for job processing.
type ProcessingOptions struct {
	// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
	DisableStreetAddressResolution *bool `pulumi:"disableStreetAddressResolution"`
	// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
	HtmlSanitization *string `pulumi:"htmlSanitization"`
}

// ProcessingOptionsInput is an input type that accepts ProcessingOptionsArgs and ProcessingOptionsOutput values.
// You can construct a concrete instance of `ProcessingOptionsInput` via:
//
//          ProcessingOptionsArgs{...}
type ProcessingOptionsInput interface {
	pulumi.Input

	ToProcessingOptionsOutput() ProcessingOptionsOutput
	ToProcessingOptionsOutputWithContext(context.Context) ProcessingOptionsOutput
}

// Input only. Options for job processing.
type ProcessingOptionsArgs struct {
	// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
	DisableStreetAddressResolution pulumi.BoolPtrInput `pulumi:"disableStreetAddressResolution"`
	// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
	HtmlSanitization *ProcessingOptionsHtmlSanitization `pulumi:"htmlSanitization"`
}

func (ProcessingOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ProcessingOptions)(nil)).Elem()
}

func (i ProcessingOptionsArgs) ToProcessingOptionsOutput() ProcessingOptionsOutput {
	return i.ToProcessingOptionsOutputWithContext(context.Background())
}

func (i ProcessingOptionsArgs) ToProcessingOptionsOutputWithContext(ctx context.Context) ProcessingOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsOutput)
}

func (i ProcessingOptionsArgs) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return i.ToProcessingOptionsPtrOutputWithContext(context.Background())
}

func (i ProcessingOptionsArgs) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsOutput).ToProcessingOptionsPtrOutputWithContext(ctx)
}

// ProcessingOptionsPtrInput is an input type that accepts ProcessingOptionsArgs, ProcessingOptionsPtr and ProcessingOptionsPtrOutput values.
// You can construct a concrete instance of `ProcessingOptionsPtrInput` via:
//
//          ProcessingOptionsArgs{...}
//
//  or:
//
//          nil
type ProcessingOptionsPtrInput interface {
	pulumi.Input

	ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput
	ToProcessingOptionsPtrOutputWithContext(context.Context) ProcessingOptionsPtrOutput
}

type processingOptionsPtrType ProcessingOptionsArgs

func ProcessingOptionsPtr(v *ProcessingOptionsArgs) ProcessingOptionsPtrInput {
	return (*processingOptionsPtrType)(v)
}

func (*processingOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessingOptions)(nil)).Elem()
}

func (i *processingOptionsPtrType) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return i.ToProcessingOptionsPtrOutputWithContext(context.Background())
}

func (i *processingOptionsPtrType) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsPtrOutput)
}

// Input only. Options for job processing.
type ProcessingOptionsOutput struct{ *pulumi.OutputState }

func (ProcessingOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ProcessingOptions)(nil)).Elem()
}

func (o ProcessingOptionsOutput) ToProcessingOptionsOutput() ProcessingOptionsOutput {
	return o
}

func (o ProcessingOptionsOutput) ToProcessingOptionsOutputWithContext(ctx context.Context) ProcessingOptionsOutput {
	return o
}

func (o ProcessingOptionsOutput) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return o.ToProcessingOptionsPtrOutputWithContext(context.Background())
}

func (o ProcessingOptionsOutput) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return o.ApplyT(func(v ProcessingOptions) *ProcessingOptions {
		return &v
	}).(ProcessingOptionsPtrOutput)
}

// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
func (o ProcessingOptionsOutput) DisableStreetAddressResolution() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ProcessingOptions) *bool { return v.DisableStreetAddressResolution }).(pulumi.BoolPtrOutput)
}

// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
func (o ProcessingOptionsOutput) HtmlSanitization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ProcessingOptions) *string { return v.HtmlSanitization }).(pulumi.StringPtrOutput)
}

type ProcessingOptionsPtrOutput struct{ *pulumi.OutputState }

func (ProcessingOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessingOptions)(nil)).Elem()
}

func (o ProcessingOptionsPtrOutput) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return o
}

func (o ProcessingOptionsPtrOutput) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return o
}

func (o ProcessingOptionsPtrOutput) Elem() ProcessingOptionsOutput {
	return o.ApplyT(func(v *ProcessingOptions) ProcessingOptions { return *v }).(ProcessingOptionsOutput)
}

// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
func (o ProcessingOptionsPtrOutput) DisableStreetAddressResolution() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ProcessingOptions) *bool {
		if v == nil {
			return nil
		}
		return v.DisableStreetAddressResolution
	}).(pulumi.BoolPtrOutput)
}

// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
func (o ProcessingOptionsPtrOutput) HtmlSanitization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProcessingOptions) *string {
		if v == nil {
			return nil
		}
		return v.HtmlSanitization
	}).(pulumi.StringPtrOutput)
}

// Input only. Options for job processing.
type ProcessingOptionsResponse struct {
	// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
	DisableStreetAddressResolution bool `pulumi:"disableStreetAddressResolution"`
	// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
	HtmlSanitization string `pulumi:"htmlSanitization"`
}

// ProcessingOptionsResponseInput is an input type that accepts ProcessingOptionsResponseArgs and ProcessingOptionsResponseOutput values.
// You can construct a concrete instance of `ProcessingOptionsResponseInput` via:
//
//          ProcessingOptionsResponseArgs{...}
type ProcessingOptionsResponseInput interface {
	pulumi.Input

	ToProcessingOptionsResponseOutput() ProcessingOptionsResponseOutput
	ToProcessingOptionsResponseOutputWithContext(context.Context) ProcessingOptionsResponseOutput
}

// Input only. Options for job processing.
type ProcessingOptionsResponseArgs struct {
	// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
	DisableStreetAddressResolution pulumi.BoolInput `pulumi:"disableStreetAddressResolution"`
	// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
	HtmlSanitization pulumi.StringInput `pulumi:"htmlSanitization"`
}

func (ProcessingOptionsResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ProcessingOptionsResponse)(nil)).Elem()
}

func (i ProcessingOptionsResponseArgs) ToProcessingOptionsResponseOutput() ProcessingOptionsResponseOutput {
	return i.ToProcessingOptionsResponseOutputWithContext(context.Background())
}

func (i ProcessingOptionsResponseArgs) ToProcessingOptionsResponseOutputWithContext(ctx context.Context) ProcessingOptionsResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsResponseOutput)
}

func (i ProcessingOptionsResponseArgs) ToProcessingOptionsResponsePtrOutput() ProcessingOptionsResponsePtrOutput {
	return i.ToProcessingOptionsResponsePtrOutputWithContext(context.Background())
}

func (i ProcessingOptionsResponseArgs) ToProcessingOptionsResponsePtrOutputWithContext(ctx context.Context) ProcessingOptionsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsResponseOutput).ToProcessingOptionsResponsePtrOutputWithContext(ctx)
}

// ProcessingOptionsResponsePtrInput is an input type that accepts ProcessingOptionsResponseArgs, ProcessingOptionsResponsePtr and ProcessingOptionsResponsePtrOutput values.
// You can construct a concrete instance of `ProcessingOptionsResponsePtrInput` via:
//
//          ProcessingOptionsResponseArgs{...}
//
//  or:
//
//          nil
type ProcessingOptionsResponsePtrInput interface {
	pulumi.Input

	ToProcessingOptionsResponsePtrOutput() ProcessingOptionsResponsePtrOutput
	ToProcessingOptionsResponsePtrOutputWithContext(context.Context) ProcessingOptionsResponsePtrOutput
}

type processingOptionsResponsePtrType ProcessingOptionsResponseArgs

func ProcessingOptionsResponsePtr(v *ProcessingOptionsResponseArgs) ProcessingOptionsResponsePtrInput {
	return (*processingOptionsResponsePtrType)(v)
}

func (*processingOptionsResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessingOptionsResponse)(nil)).Elem()
}

func (i *processingOptionsResponsePtrType) ToProcessingOptionsResponsePtrOutput() ProcessingOptionsResponsePtrOutput {
	return i.ToProcessingOptionsResponsePtrOutputWithContext(context.Background())
}

func (i *processingOptionsResponsePtrType) ToProcessingOptionsResponsePtrOutputWithContext(ctx context.Context) ProcessingOptionsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsResponsePtrOutput)
}

// Input only. Options for job processing.
type ProcessingOptionsResponseOutput struct{ *pulumi.OutputState }

func (ProcessingOptionsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ProcessingOptionsResponse)(nil)).Elem()
}

func (o ProcessingOptionsResponseOutput) ToProcessingOptionsResponseOutput() ProcessingOptionsResponseOutput {
	return o
}

func (o ProcessingOptionsResponseOutput) ToProcessingOptionsResponseOutputWithContext(ctx context.Context) ProcessingOptionsResponseOutput {
	return o
}

func (o ProcessingOptionsResponseOutput) ToProcessingOptionsResponsePtrOutput() ProcessingOptionsResponsePtrOutput {
	return o.ToProcessingOptionsResponsePtrOutputWithContext(context.Background())
}

func (o ProcessingOptionsResponseOutput) ToProcessingOptionsResponsePtrOutputWithContext(ctx context.Context) ProcessingOptionsResponsePtrOutput {
	return o.ApplyT(func(v ProcessingOptionsResponse) *ProcessingOptionsResponse {
		return &v
	}).(ProcessingOptionsResponsePtrOutput)
}

// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
func (o ProcessingOptionsResponseOutput) DisableStreetAddressResolution() pulumi.BoolOutput {
	return o.ApplyT(func(v ProcessingOptionsResponse) bool { return v.DisableStreetAddressResolution }).(pulumi.BoolOutput)
}

// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
func (o ProcessingOptionsResponseOutput) HtmlSanitization() pulumi.StringOutput {
	return o.ApplyT(func(v ProcessingOptionsResponse) string { return v.HtmlSanitization }).(pulumi.StringOutput)
}

type ProcessingOptionsResponsePtrOutput struct{ *pulumi.OutputState }

func (ProcessingOptionsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessingOptionsResponse)(nil)).Elem()
}

func (o ProcessingOptionsResponsePtrOutput) ToProcessingOptionsResponsePtrOutput() ProcessingOptionsResponsePtrOutput {
	return o
}

func (o ProcessingOptionsResponsePtrOutput) ToProcessingOptionsResponsePtrOutputWithContext(ctx context.Context) ProcessingOptionsResponsePtrOutput {
	return o
}

func (o ProcessingOptionsResponsePtrOutput) Elem() ProcessingOptionsResponseOutput {
	return o.ApplyT(func(v *ProcessingOptionsResponse) ProcessingOptionsResponse { return *v }).(ProcessingOptionsResponseOutput)
}

// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
func (o ProcessingOptionsResponsePtrOutput) DisableStreetAddressResolution() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ProcessingOptionsResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.DisableStreetAddressResolution
	}).(pulumi.BoolPtrOutput)
}

// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
func (o ProcessingOptionsResponsePtrOutput) HtmlSanitization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProcessingOptionsResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HtmlSanitization
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterOutputType(ApplicationInfoOutput{})
	pulumi.RegisterOutputType(ApplicationInfoPtrOutput{})
	pulumi.RegisterOutputType(ApplicationInfoResponseOutput{})
	pulumi.RegisterOutputType(ApplicationInfoResponsePtrOutput{})
	pulumi.RegisterOutputType(CompanyDerivedInfoResponseOutput{})
	pulumi.RegisterOutputType(CompanyDerivedInfoResponsePtrOutput{})
	pulumi.RegisterOutputType(CompensationEntryOutput{})
	pulumi.RegisterOutputType(CompensationEntryArrayOutput{})
	pulumi.RegisterOutputType(CompensationEntryResponseOutput{})
	pulumi.RegisterOutputType(CompensationEntryResponseArrayOutput{})
	pulumi.RegisterOutputType(CompensationInfoOutput{})
	pulumi.RegisterOutputType(CompensationInfoPtrOutput{})
	pulumi.RegisterOutputType(CompensationInfoResponseOutput{})
	pulumi.RegisterOutputType(CompensationInfoResponsePtrOutput{})
	pulumi.RegisterOutputType(CompensationRangeOutput{})
	pulumi.RegisterOutputType(CompensationRangePtrOutput{})
	pulumi.RegisterOutputType(CompensationRangeResponseOutput{})
	pulumi.RegisterOutputType(CompensationRangeResponsePtrOutput{})
	pulumi.RegisterOutputType(JobDerivedInfoResponseOutput{})
	pulumi.RegisterOutputType(JobDerivedInfoResponsePtrOutput{})
	pulumi.RegisterOutputType(LatLngResponseOutput{})
	pulumi.RegisterOutputType(LatLngResponsePtrOutput{})
	pulumi.RegisterOutputType(LocationResponseOutput{})
	pulumi.RegisterOutputType(LocationResponsePtrOutput{})
	pulumi.RegisterOutputType(LocationResponseArrayOutput{})
	pulumi.RegisterOutputType(MoneyOutput{})
	pulumi.RegisterOutputType(MoneyPtrOutput{})
	pulumi.RegisterOutputType(MoneyResponseOutput{})
	pulumi.RegisterOutputType(MoneyResponsePtrOutput{})
	pulumi.RegisterOutputType(PostalAddressResponseOutput{})
	pulumi.RegisterOutputType(PostalAddressResponsePtrOutput{})
	pulumi.RegisterOutputType(ProcessingOptionsOutput{})
	pulumi.RegisterOutputType(ProcessingOptionsPtrOutput{})
	pulumi.RegisterOutputType(ProcessingOptionsResponseOutput{})
	pulumi.RegisterOutputType(ProcessingOptionsResponsePtrOutput{})
}

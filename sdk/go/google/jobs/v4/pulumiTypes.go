// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v4

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

// Application related details of a job posting.
type ApplicationInfo struct {
	// Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
	Emails []string `pulumi:"emails"`
	// Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
	Instruction *string `pulumi:"instruction"`
	// Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
	Uris []string `pulumi:"uris"`
}

// ApplicationInfoInput is an input type that accepts ApplicationInfoArgs and ApplicationInfoOutput values.
// You can construct a concrete instance of `ApplicationInfoInput` via:
//
//	ApplicationInfoArgs{...}
type ApplicationInfoInput interface {
	pulumi.Input

	ToApplicationInfoOutput() ApplicationInfoOutput
	ToApplicationInfoOutputWithContext(context.Context) ApplicationInfoOutput
}

// Application related details of a job posting.
type ApplicationInfoArgs struct {
	// Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
	Emails pulumi.StringArrayInput `pulumi:"emails"`
	// Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
	Instruction pulumi.StringPtrInput `pulumi:"instruction"`
	// Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
	Uris pulumi.StringArrayInput `pulumi:"uris"`
}

func (ApplicationInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInfo)(nil)).Elem()
}

func (i ApplicationInfoArgs) ToApplicationInfoOutput() ApplicationInfoOutput {
	return i.ToApplicationInfoOutputWithContext(context.Background())
}

func (i ApplicationInfoArgs) ToApplicationInfoOutputWithContext(ctx context.Context) ApplicationInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoOutput)
}

func (i ApplicationInfoArgs) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return i.ToApplicationInfoPtrOutputWithContext(context.Background())
}

func (i ApplicationInfoArgs) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoOutput).ToApplicationInfoPtrOutputWithContext(ctx)
}

// ApplicationInfoPtrInput is an input type that accepts ApplicationInfoArgs, ApplicationInfoPtr and ApplicationInfoPtrOutput values.
// You can construct a concrete instance of `ApplicationInfoPtrInput` via:
//
//	        ApplicationInfoArgs{...}
//
//	or:
//
//	        nil
type ApplicationInfoPtrInput interface {
	pulumi.Input

	ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput
	ToApplicationInfoPtrOutputWithContext(context.Context) ApplicationInfoPtrOutput
}

type applicationInfoPtrType ApplicationInfoArgs

func ApplicationInfoPtr(v *ApplicationInfoArgs) ApplicationInfoPtrInput {
	return (*applicationInfoPtrType)(v)
}

func (*applicationInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationInfo)(nil)).Elem()
}

func (i *applicationInfoPtrType) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return i.ToApplicationInfoPtrOutputWithContext(context.Background())
}

func (i *applicationInfoPtrType) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoPtrOutput)
}

// Application related details of a job posting.
type ApplicationInfoOutput struct{ *pulumi.OutputState }

func (ApplicationInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInfo)(nil)).Elem()
}

func (o ApplicationInfoOutput) ToApplicationInfoOutput() ApplicationInfoOutput {
	return o
}

func (o ApplicationInfoOutput) ToApplicationInfoOutputWithContext(ctx context.Context) ApplicationInfoOutput {
	return o
}

func (o ApplicationInfoOutput) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return o.ToApplicationInfoPtrOutputWithContext(context.Background())
}

func (o ApplicationInfoOutput) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ApplicationInfo) *ApplicationInfo {
		return &v
	}).(ApplicationInfoPtrOutput)
}

// Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
func (o ApplicationInfoOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ApplicationInfo) []string { return v.Emails }).(pulumi.StringArrayOutput)
}

// Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
func (o ApplicationInfoOutput) Instruction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApplicationInfo) *string { return v.Instruction }).(pulumi.StringPtrOutput)
}

// Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
func (o ApplicationInfoOutput) Uris() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ApplicationInfo) []string { return v.Uris }).(pulumi.StringArrayOutput)
}

type ApplicationInfoPtrOutput struct{ *pulumi.OutputState }

func (ApplicationInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationInfo)(nil)).Elem()
}

func (o ApplicationInfoPtrOutput) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return o
}

func (o ApplicationInfoPtrOutput) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return o
}

func (o ApplicationInfoPtrOutput) Elem() ApplicationInfoOutput {
	return o.ApplyT(func(v *ApplicationInfo) ApplicationInfo {
		if v != nil {
			return *v
		}
		var ret ApplicationInfo
		return ret
	}).(ApplicationInfoOutput)
}

// Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
func (o ApplicationInfoPtrOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationInfo) []string {
		if v == nil {
			return nil
		}
		return v.Emails
	}).(pulumi.StringArrayOutput)
}

// Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
func (o ApplicationInfoPtrOutput) Instruction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationInfo) *string {
		if v == nil {
			return nil
		}
		return v.Instruction
	}).(pulumi.StringPtrOutput)
}

// Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
func (o ApplicationInfoPtrOutput) Uris() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationInfo) []string {
		if v == nil {
			return nil
		}
		return v.Uris
	}).(pulumi.StringArrayOutput)
}

// Application related details of a job posting.
type ApplicationInfoResponse struct {
	// Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
	Emails []string `pulumi:"emails"`
	// Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
	Instruction string `pulumi:"instruction"`
	// Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
	Uris []string `pulumi:"uris"`
}

// Application related details of a job posting.
type ApplicationInfoResponseOutput struct{ *pulumi.OutputState }

func (ApplicationInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInfoResponse)(nil)).Elem()
}

func (o ApplicationInfoResponseOutput) ToApplicationInfoResponseOutput() ApplicationInfoResponseOutput {
	return o
}

func (o ApplicationInfoResponseOutput) ToApplicationInfoResponseOutputWithContext(ctx context.Context) ApplicationInfoResponseOutput {
	return o
}

// Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
func (o ApplicationInfoResponseOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ApplicationInfoResponse) []string { return v.Emails }).(pulumi.StringArrayOutput)
}

// Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
func (o ApplicationInfoResponseOutput) Instruction() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationInfoResponse) string { return v.Instruction }).(pulumi.StringOutput)
}

// Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
func (o ApplicationInfoResponseOutput) Uris() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ApplicationInfoResponse) []string { return v.Uris }).(pulumi.StringArrayOutput)
}

// Derived details about the company.
type CompanyDerivedInfoResponse struct {
	// A structured headquarters location of the company, resolved from Company.headquarters_address if provided.
	HeadquartersLocation LocationResponse `pulumi:"headquartersLocation"`
}

// Derived details about the company.
type CompanyDerivedInfoResponseOutput struct{ *pulumi.OutputState }

func (CompanyDerivedInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompanyDerivedInfoResponse)(nil)).Elem()
}

func (o CompanyDerivedInfoResponseOutput) ToCompanyDerivedInfoResponseOutput() CompanyDerivedInfoResponseOutput {
	return o
}

func (o CompanyDerivedInfoResponseOutput) ToCompanyDerivedInfoResponseOutputWithContext(ctx context.Context) CompanyDerivedInfoResponseOutput {
	return o
}

// A structured headquarters location of the company, resolved from Company.headquarters_address if provided.
func (o CompanyDerivedInfoResponseOutput) HeadquartersLocation() LocationResponseOutput {
	return o.ApplyT(func(v CompanyDerivedInfoResponse) LocationResponse { return v.HeadquartersLocation }).(LocationResponseOutput)
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntry struct {
	// Compensation amount.
	Amount *Money `pulumi:"amount"`
	// Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
	Description *string `pulumi:"description"`
	// Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
	ExpectedUnitsPerYear *float64 `pulumi:"expectedUnitsPerYear"`
	// Compensation range.
	Range *CompensationRange `pulumi:"range"`
	// Compensation type. Default is CompensationType.COMPENSATION_TYPE_UNSPECIFIED.
	Type *CompensationEntryType `pulumi:"type"`
	// Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
	Unit *CompensationEntryUnit `pulumi:"unit"`
}

// CompensationEntryInput is an input type that accepts CompensationEntryArgs and CompensationEntryOutput values.
// You can construct a concrete instance of `CompensationEntryInput` via:
//
//	CompensationEntryArgs{...}
type CompensationEntryInput interface {
	pulumi.Input

	ToCompensationEntryOutput() CompensationEntryOutput
	ToCompensationEntryOutputWithContext(context.Context) CompensationEntryOutput
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryArgs struct {
	// Compensation amount.
	Amount MoneyPtrInput `pulumi:"amount"`
	// Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
	ExpectedUnitsPerYear pulumi.Float64PtrInput `pulumi:"expectedUnitsPerYear"`
	// Compensation range.
	Range CompensationRangePtrInput `pulumi:"range"`
	// Compensation type. Default is CompensationType.COMPENSATION_TYPE_UNSPECIFIED.
	Type CompensationEntryTypePtrInput `pulumi:"type"`
	// Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
	Unit CompensationEntryUnitPtrInput `pulumi:"unit"`
}

func (CompensationEntryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationEntry)(nil)).Elem()
}

func (i CompensationEntryArgs) ToCompensationEntryOutput() CompensationEntryOutput {
	return i.ToCompensationEntryOutputWithContext(context.Background())
}

func (i CompensationEntryArgs) ToCompensationEntryOutputWithContext(ctx context.Context) CompensationEntryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationEntryOutput)
}

// CompensationEntryArrayInput is an input type that accepts CompensationEntryArray and CompensationEntryArrayOutput values.
// You can construct a concrete instance of `CompensationEntryArrayInput` via:
//
//	CompensationEntryArray{ CompensationEntryArgs{...} }
type CompensationEntryArrayInput interface {
	pulumi.Input

	ToCompensationEntryArrayOutput() CompensationEntryArrayOutput
	ToCompensationEntryArrayOutputWithContext(context.Context) CompensationEntryArrayOutput
}

type CompensationEntryArray []CompensationEntryInput

func (CompensationEntryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CompensationEntry)(nil)).Elem()
}

func (i CompensationEntryArray) ToCompensationEntryArrayOutput() CompensationEntryArrayOutput {
	return i.ToCompensationEntryArrayOutputWithContext(context.Background())
}

func (i CompensationEntryArray) ToCompensationEntryArrayOutputWithContext(ctx context.Context) CompensationEntryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationEntryArrayOutput)
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryOutput struct{ *pulumi.OutputState }

func (CompensationEntryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationEntry)(nil)).Elem()
}

func (o CompensationEntryOutput) ToCompensationEntryOutput() CompensationEntryOutput {
	return o
}

func (o CompensationEntryOutput) ToCompensationEntryOutputWithContext(ctx context.Context) CompensationEntryOutput {
	return o
}

// Compensation amount.
func (o CompensationEntryOutput) Amount() MoneyPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *Money { return v.Amount }).(MoneyPtrOutput)
}

// Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
func (o CompensationEntryOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
func (o CompensationEntryOutput) ExpectedUnitsPerYear() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v CompensationEntry) *float64 { return v.ExpectedUnitsPerYear }).(pulumi.Float64PtrOutput)
}

// Compensation range.
func (o CompensationEntryOutput) Range() CompensationRangePtrOutput {
	return o.ApplyT(func(v CompensationEntry) *CompensationRange { return v.Range }).(CompensationRangePtrOutput)
}

// Compensation type. Default is CompensationType.COMPENSATION_TYPE_UNSPECIFIED.
func (o CompensationEntryOutput) Type() CompensationEntryTypePtrOutput {
	return o.ApplyT(func(v CompensationEntry) *CompensationEntryType { return v.Type }).(CompensationEntryTypePtrOutput)
}

// Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
func (o CompensationEntryOutput) Unit() CompensationEntryUnitPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *CompensationEntryUnit { return v.Unit }).(CompensationEntryUnitPtrOutput)
}

type CompensationEntryArrayOutput struct{ *pulumi.OutputState }

func (CompensationEntryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CompensationEntry)(nil)).Elem()
}

func (o CompensationEntryArrayOutput) ToCompensationEntryArrayOutput() CompensationEntryArrayOutput {
	return o
}

func (o CompensationEntryArrayOutput) ToCompensationEntryArrayOutputWithContext(ctx context.Context) CompensationEntryArrayOutput {
	return o
}

func (o CompensationEntryArrayOutput) Index(i pulumi.IntInput) CompensationEntryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CompensationEntry {
		return vs[0].([]CompensationEntry)[vs[1].(int)]
	}).(CompensationEntryOutput)
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryResponse struct {
	// Compensation amount.
	Amount MoneyResponse `pulumi:"amount"`
	// Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
	Description string `pulumi:"description"`
	// Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
	ExpectedUnitsPerYear float64 `pulumi:"expectedUnitsPerYear"`
	// Compensation range.
	Range CompensationRangeResponse `pulumi:"range"`
	// Compensation type. Default is CompensationType.COMPENSATION_TYPE_UNSPECIFIED.
	Type string `pulumi:"type"`
	// Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
	Unit string `pulumi:"unit"`
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryResponseOutput struct{ *pulumi.OutputState }

func (CompensationEntryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationEntryResponse)(nil)).Elem()
}

func (o CompensationEntryResponseOutput) ToCompensationEntryResponseOutput() CompensationEntryResponseOutput {
	return o
}

func (o CompensationEntryResponseOutput) ToCompensationEntryResponseOutputWithContext(ctx context.Context) CompensationEntryResponseOutput {
	return o
}

// Compensation amount.
func (o CompensationEntryResponseOutput) Amount() MoneyResponseOutput {
	return o.ApplyT(func(v CompensationEntryResponse) MoneyResponse { return v.Amount }).(MoneyResponseOutput)
}

// Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
func (o CompensationEntryResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v CompensationEntryResponse) string { return v.Description }).(pulumi.StringOutput)
}

// Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
func (o CompensationEntryResponseOutput) ExpectedUnitsPerYear() pulumi.Float64Output {
	return o.ApplyT(func(v CompensationEntryResponse) float64 { return v.ExpectedUnitsPerYear }).(pulumi.Float64Output)
}

// Compensation range.
func (o CompensationEntryResponseOutput) Range() CompensationRangeResponseOutput {
	return o.ApplyT(func(v CompensationEntryResponse) CompensationRangeResponse { return v.Range }).(CompensationRangeResponseOutput)
}

// Compensation type. Default is CompensationType.COMPENSATION_TYPE_UNSPECIFIED.
func (o CompensationEntryResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v CompensationEntryResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
func (o CompensationEntryResponseOutput) Unit() pulumi.StringOutput {
	return o.ApplyT(func(v CompensationEntryResponse) string { return v.Unit }).(pulumi.StringOutput)
}

type CompensationEntryResponseArrayOutput struct{ *pulumi.OutputState }

func (CompensationEntryResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CompensationEntryResponse)(nil)).Elem()
}

func (o CompensationEntryResponseArrayOutput) ToCompensationEntryResponseArrayOutput() CompensationEntryResponseArrayOutput {
	return o
}

func (o CompensationEntryResponseArrayOutput) ToCompensationEntryResponseArrayOutputWithContext(ctx context.Context) CompensationEntryResponseArrayOutput {
	return o
}

func (o CompensationEntryResponseArrayOutput) Index(i pulumi.IntInput) CompensationEntryResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CompensationEntryResponse {
		return vs[0].([]CompensationEntryResponse)[vs[1].(int)]
	}).(CompensationEntryResponseOutput)
}

// Job compensation details.
type CompensationInfo struct {
	// Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as **base compensation entry** for the job.
	Entries []CompensationEntry `pulumi:"entries"`
}

// CompensationInfoInput is an input type that accepts CompensationInfoArgs and CompensationInfoOutput values.
// You can construct a concrete instance of `CompensationInfoInput` via:
//
//	CompensationInfoArgs{...}
type CompensationInfoInput interface {
	pulumi.Input

	ToCompensationInfoOutput() CompensationInfoOutput
	ToCompensationInfoOutputWithContext(context.Context) CompensationInfoOutput
}

// Job compensation details.
type CompensationInfoArgs struct {
	// Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as **base compensation entry** for the job.
	Entries CompensationEntryArrayInput `pulumi:"entries"`
}

func (CompensationInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationInfo)(nil)).Elem()
}

func (i CompensationInfoArgs) ToCompensationInfoOutput() CompensationInfoOutput {
	return i.ToCompensationInfoOutputWithContext(context.Background())
}

func (i CompensationInfoArgs) ToCompensationInfoOutputWithContext(ctx context.Context) CompensationInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoOutput)
}

func (i CompensationInfoArgs) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return i.ToCompensationInfoPtrOutputWithContext(context.Background())
}

func (i CompensationInfoArgs) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoOutput).ToCompensationInfoPtrOutputWithContext(ctx)
}

// CompensationInfoPtrInput is an input type that accepts CompensationInfoArgs, CompensationInfoPtr and CompensationInfoPtrOutput values.
// You can construct a concrete instance of `CompensationInfoPtrInput` via:
//
//	        CompensationInfoArgs{...}
//
//	or:
//
//	        nil
type CompensationInfoPtrInput interface {
	pulumi.Input

	ToCompensationInfoPtrOutput() CompensationInfoPtrOutput
	ToCompensationInfoPtrOutputWithContext(context.Context) CompensationInfoPtrOutput
}

type compensationInfoPtrType CompensationInfoArgs

func CompensationInfoPtr(v *CompensationInfoArgs) CompensationInfoPtrInput {
	return (*compensationInfoPtrType)(v)
}

func (*compensationInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationInfo)(nil)).Elem()
}

func (i *compensationInfoPtrType) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return i.ToCompensationInfoPtrOutputWithContext(context.Background())
}

func (i *compensationInfoPtrType) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoPtrOutput)
}

// Job compensation details.
type CompensationInfoOutput struct{ *pulumi.OutputState }

func (CompensationInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationInfo)(nil)).Elem()
}

func (o CompensationInfoOutput) ToCompensationInfoOutput() CompensationInfoOutput {
	return o
}

func (o CompensationInfoOutput) ToCompensationInfoOutputWithContext(ctx context.Context) CompensationInfoOutput {
	return o
}

func (o CompensationInfoOutput) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return o.ToCompensationInfoPtrOutputWithContext(context.Background())
}

func (o CompensationInfoOutput) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CompensationInfo) *CompensationInfo {
		return &v
	}).(CompensationInfoPtrOutput)
}

// Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as **base compensation entry** for the job.
func (o CompensationInfoOutput) Entries() CompensationEntryArrayOutput {
	return o.ApplyT(func(v CompensationInfo) []CompensationEntry { return v.Entries }).(CompensationEntryArrayOutput)
}

type CompensationInfoPtrOutput struct{ *pulumi.OutputState }

func (CompensationInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationInfo)(nil)).Elem()
}

func (o CompensationInfoPtrOutput) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return o
}

func (o CompensationInfoPtrOutput) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return o
}

func (o CompensationInfoPtrOutput) Elem() CompensationInfoOutput {
	return o.ApplyT(func(v *CompensationInfo) CompensationInfo {
		if v != nil {
			return *v
		}
		var ret CompensationInfo
		return ret
	}).(CompensationInfoOutput)
}

// Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as **base compensation entry** for the job.
func (o CompensationInfoPtrOutput) Entries() CompensationEntryArrayOutput {
	return o.ApplyT(func(v *CompensationInfo) []CompensationEntry {
		if v == nil {
			return nil
		}
		return v.Entries
	}).(CompensationEntryArrayOutput)
}

// Job compensation details.
type CompensationInfoResponse struct {
	// Annualized base compensation range. Computed as base compensation entry's CompensationEntry.amount times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedBaseCompensationRange CompensationRangeResponse `pulumi:"annualizedBaseCompensationRange"`
	// Annualized total compensation range. Computed as all compensation entries' CompensationEntry.amount times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedTotalCompensationRange CompensationRangeResponse `pulumi:"annualizedTotalCompensationRange"`
	// Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as **base compensation entry** for the job.
	Entries []CompensationEntryResponse `pulumi:"entries"`
}

// Job compensation details.
type CompensationInfoResponseOutput struct{ *pulumi.OutputState }

func (CompensationInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationInfoResponse)(nil)).Elem()
}

func (o CompensationInfoResponseOutput) ToCompensationInfoResponseOutput() CompensationInfoResponseOutput {
	return o
}

func (o CompensationInfoResponseOutput) ToCompensationInfoResponseOutputWithContext(ctx context.Context) CompensationInfoResponseOutput {
	return o
}

// Annualized base compensation range. Computed as base compensation entry's CompensationEntry.amount times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoResponseOutput) AnnualizedBaseCompensationRange() CompensationRangeResponseOutput {
	return o.ApplyT(func(v CompensationInfoResponse) CompensationRangeResponse { return v.AnnualizedBaseCompensationRange }).(CompensationRangeResponseOutput)
}

// Annualized total compensation range. Computed as all compensation entries' CompensationEntry.amount times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoResponseOutput) AnnualizedTotalCompensationRange() CompensationRangeResponseOutput {
	return o.ApplyT(func(v CompensationInfoResponse) CompensationRangeResponse { return v.AnnualizedTotalCompensationRange }).(CompensationRangeResponseOutput)
}

// Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as **base compensation entry** for the job.
func (o CompensationInfoResponseOutput) Entries() CompensationEntryResponseArrayOutput {
	return o.ApplyT(func(v CompensationInfoResponse) []CompensationEntryResponse { return v.Entries }).(CompensationEntryResponseArrayOutput)
}

// Compensation range.
type CompensationRange struct {
	// The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
	MaxCompensation *Money `pulumi:"maxCompensation"`
	// The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
	MinCompensation *Money `pulumi:"minCompensation"`
}

// CompensationRangeInput is an input type that accepts CompensationRangeArgs and CompensationRangeOutput values.
// You can construct a concrete instance of `CompensationRangeInput` via:
//
//	CompensationRangeArgs{...}
type CompensationRangeInput interface {
	pulumi.Input

	ToCompensationRangeOutput() CompensationRangeOutput
	ToCompensationRangeOutputWithContext(context.Context) CompensationRangeOutput
}

// Compensation range.
type CompensationRangeArgs struct {
	// The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
	MaxCompensation MoneyPtrInput `pulumi:"maxCompensation"`
	// The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
	MinCompensation MoneyPtrInput `pulumi:"minCompensation"`
}

func (CompensationRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationRange)(nil)).Elem()
}

func (i CompensationRangeArgs) ToCompensationRangeOutput() CompensationRangeOutput {
	return i.ToCompensationRangeOutputWithContext(context.Background())
}

func (i CompensationRangeArgs) ToCompensationRangeOutputWithContext(ctx context.Context) CompensationRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangeOutput)
}

func (i CompensationRangeArgs) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return i.ToCompensationRangePtrOutputWithContext(context.Background())
}

func (i CompensationRangeArgs) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangeOutput).ToCompensationRangePtrOutputWithContext(ctx)
}

// CompensationRangePtrInput is an input type that accepts CompensationRangeArgs, CompensationRangePtr and CompensationRangePtrOutput values.
// You can construct a concrete instance of `CompensationRangePtrInput` via:
//
//	        CompensationRangeArgs{...}
//
//	or:
//
//	        nil
type CompensationRangePtrInput interface {
	pulumi.Input

	ToCompensationRangePtrOutput() CompensationRangePtrOutput
	ToCompensationRangePtrOutputWithContext(context.Context) CompensationRangePtrOutput
}

type compensationRangePtrType CompensationRangeArgs

func CompensationRangePtr(v *CompensationRangeArgs) CompensationRangePtrInput {
	return (*compensationRangePtrType)(v)
}

func (*compensationRangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationRange)(nil)).Elem()
}

func (i *compensationRangePtrType) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return i.ToCompensationRangePtrOutputWithContext(context.Background())
}

func (i *compensationRangePtrType) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangePtrOutput)
}

// Compensation range.
type CompensationRangeOutput struct{ *pulumi.OutputState }

func (CompensationRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationRange)(nil)).Elem()
}

func (o CompensationRangeOutput) ToCompensationRangeOutput() CompensationRangeOutput {
	return o
}

func (o CompensationRangeOutput) ToCompensationRangeOutputWithContext(ctx context.Context) CompensationRangeOutput {
	return o
}

func (o CompensationRangeOutput) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return o.ToCompensationRangePtrOutputWithContext(context.Background())
}

func (o CompensationRangeOutput) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CompensationRange) *CompensationRange {
		return &v
	}).(CompensationRangePtrOutput)
}

// The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
func (o CompensationRangeOutput) MaxCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v CompensationRange) *Money { return v.MaxCompensation }).(MoneyPtrOutput)
}

// The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
func (o CompensationRangeOutput) MinCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v CompensationRange) *Money { return v.MinCompensation }).(MoneyPtrOutput)
}

type CompensationRangePtrOutput struct{ *pulumi.OutputState }

func (CompensationRangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationRange)(nil)).Elem()
}

func (o CompensationRangePtrOutput) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return o
}

func (o CompensationRangePtrOutput) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return o
}

func (o CompensationRangePtrOutput) Elem() CompensationRangeOutput {
	return o.ApplyT(func(v *CompensationRange) CompensationRange {
		if v != nil {
			return *v
		}
		var ret CompensationRange
		return ret
	}).(CompensationRangeOutput)
}

// The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
func (o CompensationRangePtrOutput) MaxCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v *CompensationRange) *Money {
		if v == nil {
			return nil
		}
		return v.MaxCompensation
	}).(MoneyPtrOutput)
}

// The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
func (o CompensationRangePtrOutput) MinCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v *CompensationRange) *Money {
		if v == nil {
			return nil
		}
		return v.MinCompensation
	}).(MoneyPtrOutput)
}

// Compensation range.
type CompensationRangeResponse struct {
	// The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
	MaxCompensation MoneyResponse `pulumi:"maxCompensation"`
	// The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
	MinCompensation MoneyResponse `pulumi:"minCompensation"`
}

// Compensation range.
type CompensationRangeResponseOutput struct{ *pulumi.OutputState }

func (CompensationRangeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationRangeResponse)(nil)).Elem()
}

func (o CompensationRangeResponseOutput) ToCompensationRangeResponseOutput() CompensationRangeResponseOutput {
	return o
}

func (o CompensationRangeResponseOutput) ToCompensationRangeResponseOutputWithContext(ctx context.Context) CompensationRangeResponseOutput {
	return o
}

// The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
func (o CompensationRangeResponseOutput) MaxCompensation() MoneyResponseOutput {
	return o.ApplyT(func(v CompensationRangeResponse) MoneyResponse { return v.MaxCompensation }).(MoneyResponseOutput)
}

// The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
func (o CompensationRangeResponseOutput) MinCompensation() MoneyResponseOutput {
	return o.ApplyT(func(v CompensationRangeResponse) MoneyResponse { return v.MinCompensation }).(MoneyResponseOutput)
}

// Custom attribute values that are either filterable or non-filterable.
type CustomAttribute struct {
	// If the `filterable` flag is true, the custom field values may be used for custom attribute filters JobQuery.custom_attribute_filter. If false, these values may not be used for custom attribute filters. Default is false.
	Filterable *bool `pulumi:"filterable"`
	// If the `keyword_searchable` flag is true, the keywords in custom fields are searchable by keyword match. If false, the values are not searchable by keyword match. Default is false.
	KeywordSearchable *bool `pulumi:"keywordSearchable"`
	// Exactly one of string_values or long_values must be specified. This field is used to perform number range search. (`EQ`, `GT`, `GE`, `LE`, `LT`) over filterable `long_value`. Currently at most 1 long_values is supported.
	LongValues []string `pulumi:"longValues"`
	// Exactly one of string_values or long_values must be specified. This field is used to perform a string match (`CASE_SENSITIVE_MATCH` or `CASE_INSENSITIVE_MATCH`) search. For filterable `string_value`s, a maximum total number of 200 values is allowed, with each `string_value` has a byte size of no more than 500B. For unfilterable `string_values`, the maximum total byte size of unfilterable `string_values` is 50KB. Empty string isn't allowed.
	StringValues []string `pulumi:"stringValues"`
}

// CustomAttributeInput is an input type that accepts CustomAttributeArgs and CustomAttributeOutput values.
// You can construct a concrete instance of `CustomAttributeInput` via:
//
//	CustomAttributeArgs{...}
type CustomAttributeInput interface {
	pulumi.Input

	ToCustomAttributeOutput() CustomAttributeOutput
	ToCustomAttributeOutputWithContext(context.Context) CustomAttributeOutput
}

// Custom attribute values that are either filterable or non-filterable.
type CustomAttributeArgs struct {
	// If the `filterable` flag is true, the custom field values may be used for custom attribute filters JobQuery.custom_attribute_filter. If false, these values may not be used for custom attribute filters. Default is false.
	Filterable pulumi.BoolPtrInput `pulumi:"filterable"`
	// If the `keyword_searchable` flag is true, the keywords in custom fields are searchable by keyword match. If false, the values are not searchable by keyword match. Default is false.
	KeywordSearchable pulumi.BoolPtrInput `pulumi:"keywordSearchable"`
	// Exactly one of string_values or long_values must be specified. This field is used to perform number range search. (`EQ`, `GT`, `GE`, `LE`, `LT`) over filterable `long_value`. Currently at most 1 long_values is supported.
	LongValues pulumi.StringArrayInput `pulumi:"longValues"`
	// Exactly one of string_values or long_values must be specified. This field is used to perform a string match (`CASE_SENSITIVE_MATCH` or `CASE_INSENSITIVE_MATCH`) search. For filterable `string_value`s, a maximum total number of 200 values is allowed, with each `string_value` has a byte size of no more than 500B. For unfilterable `string_values`, the maximum total byte size of unfilterable `string_values` is 50KB. Empty string isn't allowed.
	StringValues pulumi.StringArrayInput `pulumi:"stringValues"`
}

func (CustomAttributeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomAttribute)(nil)).Elem()
}

func (i CustomAttributeArgs) ToCustomAttributeOutput() CustomAttributeOutput {
	return i.ToCustomAttributeOutputWithContext(context.Background())
}

func (i CustomAttributeArgs) ToCustomAttributeOutputWithContext(ctx context.Context) CustomAttributeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomAttributeOutput)
}

// CustomAttributeMapInput is an input type that accepts CustomAttributeMap and CustomAttributeMapOutput values.
// You can construct a concrete instance of `CustomAttributeMapInput` via:
//
//	CustomAttributeMap{ "key": CustomAttributeArgs{...} }
type CustomAttributeMapInput interface {
	pulumi.Input

	ToCustomAttributeMapOutput() CustomAttributeMapOutput
	ToCustomAttributeMapOutputWithContext(context.Context) CustomAttributeMapOutput
}

type CustomAttributeMap map[string]CustomAttributeInput

func (CustomAttributeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]CustomAttribute)(nil)).Elem()
}

func (i CustomAttributeMap) ToCustomAttributeMapOutput() CustomAttributeMapOutput {
	return i.ToCustomAttributeMapOutputWithContext(context.Background())
}

func (i CustomAttributeMap) ToCustomAttributeMapOutputWithContext(ctx context.Context) CustomAttributeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomAttributeMapOutput)
}

// Custom attribute values that are either filterable or non-filterable.
type CustomAttributeOutput struct{ *pulumi.OutputState }

func (CustomAttributeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomAttribute)(nil)).Elem()
}

func (o CustomAttributeOutput) ToCustomAttributeOutput() CustomAttributeOutput {
	return o
}

func (o CustomAttributeOutput) ToCustomAttributeOutputWithContext(ctx context.Context) CustomAttributeOutput {
	return o
}

// If the `filterable` flag is true, the custom field values may be used for custom attribute filters JobQuery.custom_attribute_filter. If false, these values may not be used for custom attribute filters. Default is false.
func (o CustomAttributeOutput) Filterable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CustomAttribute) *bool { return v.Filterable }).(pulumi.BoolPtrOutput)
}

// If the `keyword_searchable` flag is true, the keywords in custom fields are searchable by keyword match. If false, the values are not searchable by keyword match. Default is false.
func (o CustomAttributeOutput) KeywordSearchable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CustomAttribute) *bool { return v.KeywordSearchable }).(pulumi.BoolPtrOutput)
}

// Exactly one of string_values or long_values must be specified. This field is used to perform number range search. (`EQ`, `GT`, `GE`, `LE`, `LT`) over filterable `long_value`. Currently at most 1 long_values is supported.
func (o CustomAttributeOutput) LongValues() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CustomAttribute) []string { return v.LongValues }).(pulumi.StringArrayOutput)
}

// Exactly one of string_values or long_values must be specified. This field is used to perform a string match (`CASE_SENSITIVE_MATCH` or `CASE_INSENSITIVE_MATCH`) search. For filterable `string_value`s, a maximum total number of 200 values is allowed, with each `string_value` has a byte size of no more than 500B. For unfilterable `string_values`, the maximum total byte size of unfilterable `string_values` is 50KB. Empty string isn't allowed.
func (o CustomAttributeOutput) StringValues() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CustomAttribute) []string { return v.StringValues }).(pulumi.StringArrayOutput)
}

type CustomAttributeMapOutput struct{ *pulumi.OutputState }

func (CustomAttributeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]CustomAttribute)(nil)).Elem()
}

func (o CustomAttributeMapOutput) ToCustomAttributeMapOutput() CustomAttributeMapOutput {
	return o
}

func (o CustomAttributeMapOutput) ToCustomAttributeMapOutputWithContext(ctx context.Context) CustomAttributeMapOutput {
	return o
}

func (o CustomAttributeMapOutput) MapIndex(k pulumi.StringInput) CustomAttributeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) CustomAttribute {
		return vs[0].(map[string]CustomAttribute)[vs[1].(string)]
	}).(CustomAttributeOutput)
}

// Custom attribute values that are either filterable or non-filterable.
type CustomAttributeResponse struct {
	// If the `filterable` flag is true, the custom field values may be used for custom attribute filters JobQuery.custom_attribute_filter. If false, these values may not be used for custom attribute filters. Default is false.
	Filterable bool `pulumi:"filterable"`
	// If the `keyword_searchable` flag is true, the keywords in custom fields are searchable by keyword match. If false, the values are not searchable by keyword match. Default is false.
	KeywordSearchable bool `pulumi:"keywordSearchable"`
	// Exactly one of string_values or long_values must be specified. This field is used to perform number range search. (`EQ`, `GT`, `GE`, `LE`, `LT`) over filterable `long_value`. Currently at most 1 long_values is supported.
	LongValues []string `pulumi:"longValues"`
	// Exactly one of string_values or long_values must be specified. This field is used to perform a string match (`CASE_SENSITIVE_MATCH` or `CASE_INSENSITIVE_MATCH`) search. For filterable `string_value`s, a maximum total number of 200 values is allowed, with each `string_value` has a byte size of no more than 500B. For unfilterable `string_values`, the maximum total byte size of unfilterable `string_values` is 50KB. Empty string isn't allowed.
	StringValues []string `pulumi:"stringValues"`
}

// Custom attribute values that are either filterable or non-filterable.
type CustomAttributeResponseOutput struct{ *pulumi.OutputState }

func (CustomAttributeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomAttributeResponse)(nil)).Elem()
}

func (o CustomAttributeResponseOutput) ToCustomAttributeResponseOutput() CustomAttributeResponseOutput {
	return o
}

func (o CustomAttributeResponseOutput) ToCustomAttributeResponseOutputWithContext(ctx context.Context) CustomAttributeResponseOutput {
	return o
}

// If the `filterable` flag is true, the custom field values may be used for custom attribute filters JobQuery.custom_attribute_filter. If false, these values may not be used for custom attribute filters. Default is false.
func (o CustomAttributeResponseOutput) Filterable() pulumi.BoolOutput {
	return o.ApplyT(func(v CustomAttributeResponse) bool { return v.Filterable }).(pulumi.BoolOutput)
}

// If the `keyword_searchable` flag is true, the keywords in custom fields are searchable by keyword match. If false, the values are not searchable by keyword match. Default is false.
func (o CustomAttributeResponseOutput) KeywordSearchable() pulumi.BoolOutput {
	return o.ApplyT(func(v CustomAttributeResponse) bool { return v.KeywordSearchable }).(pulumi.BoolOutput)
}

// Exactly one of string_values or long_values must be specified. This field is used to perform number range search. (`EQ`, `GT`, `GE`, `LE`, `LT`) over filterable `long_value`. Currently at most 1 long_values is supported.
func (o CustomAttributeResponseOutput) LongValues() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CustomAttributeResponse) []string { return v.LongValues }).(pulumi.StringArrayOutput)
}

// Exactly one of string_values or long_values must be specified. This field is used to perform a string match (`CASE_SENSITIVE_MATCH` or `CASE_INSENSITIVE_MATCH`) search. For filterable `string_value`s, a maximum total number of 200 values is allowed, with each `string_value` has a byte size of no more than 500B. For unfilterable `string_values`, the maximum total byte size of unfilterable `string_values` is 50KB. Empty string isn't allowed.
func (o CustomAttributeResponseOutput) StringValues() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CustomAttributeResponse) []string { return v.StringValues }).(pulumi.StringArrayOutput)
}

type CustomAttributeResponseMapOutput struct{ *pulumi.OutputState }

func (CustomAttributeResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]CustomAttributeResponse)(nil)).Elem()
}

func (o CustomAttributeResponseMapOutput) ToCustomAttributeResponseMapOutput() CustomAttributeResponseMapOutput {
	return o
}

func (o CustomAttributeResponseMapOutput) ToCustomAttributeResponseMapOutputWithContext(ctx context.Context) CustomAttributeResponseMapOutput {
	return o
}

func (o CustomAttributeResponseMapOutput) MapIndex(k pulumi.StringInput) CustomAttributeResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) CustomAttributeResponse {
		return vs[0].(map[string]CustomAttributeResponse)[vs[1].(string)]
	}).(CustomAttributeResponseOutput)
}

// Derived details about the job posting.
type JobDerivedInfoResponse struct {
	// Job categories derived from Job.title and Job.description.
	JobCategories []string `pulumi:"jobCategories"`
	// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
	Locations []LocationResponse `pulumi:"locations"`
}

// Derived details about the job posting.
type JobDerivedInfoResponseOutput struct{ *pulumi.OutputState }

func (JobDerivedInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobDerivedInfoResponse)(nil)).Elem()
}

func (o JobDerivedInfoResponseOutput) ToJobDerivedInfoResponseOutput() JobDerivedInfoResponseOutput {
	return o
}

func (o JobDerivedInfoResponseOutput) ToJobDerivedInfoResponseOutputWithContext(ctx context.Context) JobDerivedInfoResponseOutput {
	return o
}

// Job categories derived from Job.title and Job.description.
func (o JobDerivedInfoResponseOutput) JobCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobDerivedInfoResponse) []string { return v.JobCategories }).(pulumi.StringArrayOutput)
}

// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
func (o JobDerivedInfoResponseOutput) Locations() LocationResponseArrayOutput {
	return o.ApplyT(func(v JobDerivedInfoResponse) []LocationResponse { return v.Locations }).(LocationResponseArrayOutput)
}

// An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this object must conform to the WGS84 standard. Values must be within normalized ranges.
type LatLngResponse struct {
	// The latitude in degrees. It must be in the range [-90.0, +90.0].
	Latitude float64 `pulumi:"latitude"`
	// The longitude in degrees. It must be in the range [-180.0, +180.0].
	Longitude float64 `pulumi:"longitude"`
}

// An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this object must conform to the WGS84 standard. Values must be within normalized ranges.
type LatLngResponseOutput struct{ *pulumi.OutputState }

func (LatLngResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LatLngResponse)(nil)).Elem()
}

func (o LatLngResponseOutput) ToLatLngResponseOutput() LatLngResponseOutput {
	return o
}

func (o LatLngResponseOutput) ToLatLngResponseOutputWithContext(ctx context.Context) LatLngResponseOutput {
	return o
}

// The latitude in degrees. It must be in the range [-90.0, +90.0].
func (o LatLngResponseOutput) Latitude() pulumi.Float64Output {
	return o.ApplyT(func(v LatLngResponse) float64 { return v.Latitude }).(pulumi.Float64Output)
}

// The longitude in degrees. It must be in the range [-180.0, +180.0].
func (o LatLngResponseOutput) Longitude() pulumi.Float64Output {
	return o.ApplyT(func(v LatLngResponse) float64 { return v.Longitude }).(pulumi.Float64Output)
}

// A resource that represents a location with full geographic information.
type LocationResponse struct {
	// An object representing a latitude/longitude pair.
	LatLng LatLngResponse `pulumi:"latLng"`
	// The type of a location, which corresponds to the address lines field of google.type.PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType.NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType.LOCALITY.
	LocationType string `pulumi:"locationType"`
	// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
	PostalAddress PostalAddressResponse `pulumi:"postalAddress"`
	// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from google.type.LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
	RadiusMiles float64 `pulumi:"radiusMiles"`
}

// A resource that represents a location with full geographic information.
type LocationResponseOutput struct{ *pulumi.OutputState }

func (LocationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationResponse)(nil)).Elem()
}

func (o LocationResponseOutput) ToLocationResponseOutput() LocationResponseOutput {
	return o
}

func (o LocationResponseOutput) ToLocationResponseOutputWithContext(ctx context.Context) LocationResponseOutput {
	return o
}

// An object representing a latitude/longitude pair.
func (o LocationResponseOutput) LatLng() LatLngResponseOutput {
	return o.ApplyT(func(v LocationResponse) LatLngResponse { return v.LatLng }).(LatLngResponseOutput)
}

// The type of a location, which corresponds to the address lines field of google.type.PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType.NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType.LOCALITY.
func (o LocationResponseOutput) LocationType() pulumi.StringOutput {
	return o.ApplyT(func(v LocationResponse) string { return v.LocationType }).(pulumi.StringOutput)
}

// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
func (o LocationResponseOutput) PostalAddress() PostalAddressResponseOutput {
	return o.ApplyT(func(v LocationResponse) PostalAddressResponse { return v.PostalAddress }).(PostalAddressResponseOutput)
}

// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from google.type.LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
func (o LocationResponseOutput) RadiusMiles() pulumi.Float64Output {
	return o.ApplyT(func(v LocationResponse) float64 { return v.RadiusMiles }).(pulumi.Float64Output)
}

type LocationResponseArrayOutput struct{ *pulumi.OutputState }

func (LocationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LocationResponse)(nil)).Elem()
}

func (o LocationResponseArrayOutput) ToLocationResponseArrayOutput() LocationResponseArrayOutput {
	return o
}

func (o LocationResponseArrayOutput) ToLocationResponseArrayOutputWithContext(ctx context.Context) LocationResponseArrayOutput {
	return o
}

func (o LocationResponseArrayOutput) Index(i pulumi.IntInput) LocationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LocationResponse {
		return vs[0].([]LocationResponse)[vs[1].(int)]
	}).(LocationResponseOutput)
}

// Represents an amount of money with its currency type.
type Money struct {
	// The three-letter currency code defined in ISO 4217.
	CurrencyCode *string `pulumi:"currencyCode"`
	// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos *int `pulumi:"nanos"`
	// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units *string `pulumi:"units"`
}

// MoneyInput is an input type that accepts MoneyArgs and MoneyOutput values.
// You can construct a concrete instance of `MoneyInput` via:
//
//	MoneyArgs{...}
type MoneyInput interface {
	pulumi.Input

	ToMoneyOutput() MoneyOutput
	ToMoneyOutputWithContext(context.Context) MoneyOutput
}

// Represents an amount of money with its currency type.
type MoneyArgs struct {
	// The three-letter currency code defined in ISO 4217.
	CurrencyCode pulumi.StringPtrInput `pulumi:"currencyCode"`
	// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos pulumi.IntPtrInput `pulumi:"nanos"`
	// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units pulumi.StringPtrInput `pulumi:"units"`
}

func (MoneyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Money)(nil)).Elem()
}

func (i MoneyArgs) ToMoneyOutput() MoneyOutput {
	return i.ToMoneyOutputWithContext(context.Background())
}

func (i MoneyArgs) ToMoneyOutputWithContext(ctx context.Context) MoneyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyOutput)
}

func (i MoneyArgs) ToMoneyPtrOutput() MoneyPtrOutput {
	return i.ToMoneyPtrOutputWithContext(context.Background())
}

func (i MoneyArgs) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyOutput).ToMoneyPtrOutputWithContext(ctx)
}

// MoneyPtrInput is an input type that accepts MoneyArgs, MoneyPtr and MoneyPtrOutput values.
// You can construct a concrete instance of `MoneyPtrInput` via:
//
//	        MoneyArgs{...}
//
//	or:
//
//	        nil
type MoneyPtrInput interface {
	pulumi.Input

	ToMoneyPtrOutput() MoneyPtrOutput
	ToMoneyPtrOutputWithContext(context.Context) MoneyPtrOutput
}

type moneyPtrType MoneyArgs

func MoneyPtr(v *MoneyArgs) MoneyPtrInput {
	return (*moneyPtrType)(v)
}

func (*moneyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Money)(nil)).Elem()
}

func (i *moneyPtrType) ToMoneyPtrOutput() MoneyPtrOutput {
	return i.ToMoneyPtrOutputWithContext(context.Background())
}

func (i *moneyPtrType) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyPtrOutput)
}

// Represents an amount of money with its currency type.
type MoneyOutput struct{ *pulumi.OutputState }

func (MoneyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Money)(nil)).Elem()
}

func (o MoneyOutput) ToMoneyOutput() MoneyOutput {
	return o
}

func (o MoneyOutput) ToMoneyOutputWithContext(ctx context.Context) MoneyOutput {
	return o
}

func (o MoneyOutput) ToMoneyPtrOutput() MoneyPtrOutput {
	return o.ToMoneyPtrOutputWithContext(context.Background())
}

func (o MoneyOutput) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Money) *Money {
		return &v
	}).(MoneyPtrOutput)
}

// The three-letter currency code defined in ISO 4217.
func (o MoneyOutput) CurrencyCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Money) *string { return v.CurrencyCode }).(pulumi.StringPtrOutput)
}

// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
func (o MoneyOutput) Nanos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Money) *int { return v.Nanos }).(pulumi.IntPtrOutput)
}

// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
func (o MoneyOutput) Units() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Money) *string { return v.Units }).(pulumi.StringPtrOutput)
}

type MoneyPtrOutput struct{ *pulumi.OutputState }

func (MoneyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Money)(nil)).Elem()
}

func (o MoneyPtrOutput) ToMoneyPtrOutput() MoneyPtrOutput {
	return o
}

func (o MoneyPtrOutput) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return o
}

func (o MoneyPtrOutput) Elem() MoneyOutput {
	return o.ApplyT(func(v *Money) Money {
		if v != nil {
			return *v
		}
		var ret Money
		return ret
	}).(MoneyOutput)
}

// The three-letter currency code defined in ISO 4217.
func (o MoneyPtrOutput) CurrencyCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Money) *string {
		if v == nil {
			return nil
		}
		return v.CurrencyCode
	}).(pulumi.StringPtrOutput)
}

// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
func (o MoneyPtrOutput) Nanos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Money) *int {
		if v == nil {
			return nil
		}
		return v.Nanos
	}).(pulumi.IntPtrOutput)
}

// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
func (o MoneyPtrOutput) Units() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Money) *string {
		if v == nil {
			return nil
		}
		return v.Units
	}).(pulumi.StringPtrOutput)
}

// Represents an amount of money with its currency type.
type MoneyResponse struct {
	// The three-letter currency code defined in ISO 4217.
	CurrencyCode string `pulumi:"currencyCode"`
	// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos int `pulumi:"nanos"`
	// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units string `pulumi:"units"`
}

// Represents an amount of money with its currency type.
type MoneyResponseOutput struct{ *pulumi.OutputState }

func (MoneyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MoneyResponse)(nil)).Elem()
}

func (o MoneyResponseOutput) ToMoneyResponseOutput() MoneyResponseOutput {
	return o
}

func (o MoneyResponseOutput) ToMoneyResponseOutputWithContext(ctx context.Context) MoneyResponseOutput {
	return o
}

// The three-letter currency code defined in ISO 4217.
func (o MoneyResponseOutput) CurrencyCode() pulumi.StringOutput {
	return o.ApplyT(func(v MoneyResponse) string { return v.CurrencyCode }).(pulumi.StringOutput)
}

// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
func (o MoneyResponseOutput) Nanos() pulumi.IntOutput {
	return o.ApplyT(func(v MoneyResponse) int { return v.Nanos }).(pulumi.IntOutput)
}

// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
func (o MoneyResponseOutput) Units() pulumi.StringOutput {
	return o.ApplyT(func(v MoneyResponse) string { return v.Units }).(pulumi.StringOutput)
}

// Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an internationalization-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
type PostalAddressResponse struct {
	// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
	AddressLines []string `pulumi:"addressLines"`
	// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
	AdministrativeArea string `pulumi:"administrativeArea"`
	// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode string `pulumi:"languageCode"`
	// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
	Locality string `pulumi:"locality"`
	// Optional. The name of the organization at the address.
	Organization string `pulumi:"organization"`
	// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode string `pulumi:"postalCode"`
	// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
	Recipients []string `pulumi:"recipients"`
	// CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See https://cldr.unicode.org/ and https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
	RegionCode string `pulumi:"regionCode"`
	// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
	Revision int `pulumi:"revision"`
	// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
	SortingCode string `pulumi:"sortingCode"`
	// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
	Sublocality string `pulumi:"sublocality"`
}

// Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an internationalization-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
type PostalAddressResponseOutput struct{ *pulumi.OutputState }

func (PostalAddressResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PostalAddressResponse)(nil)).Elem()
}

func (o PostalAddressResponseOutput) ToPostalAddressResponseOutput() PostalAddressResponseOutput {
	return o
}

func (o PostalAddressResponseOutput) ToPostalAddressResponseOutputWithContext(ctx context.Context) PostalAddressResponseOutput {
	return o
}

// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
func (o PostalAddressResponseOutput) AddressLines() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PostalAddressResponse) []string { return v.AddressLines }).(pulumi.StringArrayOutput)
}

// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
func (o PostalAddressResponseOutput) AdministrativeArea() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.AdministrativeArea }).(pulumi.StringOutput)
}

// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
func (o PostalAddressResponseOutput) LanguageCode() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.LanguageCode }).(pulumi.StringOutput)
}

// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
func (o PostalAddressResponseOutput) Locality() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.Locality }).(pulumi.StringOutput)
}

// Optional. The name of the organization at the address.
func (o PostalAddressResponseOutput) Organization() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.Organization }).(pulumi.StringOutput)
}

// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
func (o PostalAddressResponseOutput) PostalCode() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.PostalCode }).(pulumi.StringOutput)
}

// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
func (o PostalAddressResponseOutput) Recipients() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PostalAddressResponse) []string { return v.Recipients }).(pulumi.StringArrayOutput)
}

// CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See https://cldr.unicode.org/ and https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
func (o PostalAddressResponseOutput) RegionCode() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.RegionCode }).(pulumi.StringOutput)
}

// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
func (o PostalAddressResponseOutput) Revision() pulumi.IntOutput {
	return o.ApplyT(func(v PostalAddressResponse) int { return v.Revision }).(pulumi.IntOutput)
}

// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
func (o PostalAddressResponseOutput) SortingCode() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.SortingCode }).(pulumi.StringOutput)
}

// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
func (o PostalAddressResponseOutput) Sublocality() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.Sublocality }).(pulumi.StringOutput)
}

// Options for job processing.
type ProcessingOptions struct {
	// If set to `true`, the service does not attempt to resolve a more precise address for the job.
	DisableStreetAddressResolution *bool `pulumi:"disableStreetAddressResolution"`
	// Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation isn't disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
	HtmlSanitization *ProcessingOptionsHtmlSanitization `pulumi:"htmlSanitization"`
}

// ProcessingOptionsInput is an input type that accepts ProcessingOptionsArgs and ProcessingOptionsOutput values.
// You can construct a concrete instance of `ProcessingOptionsInput` via:
//
//	ProcessingOptionsArgs{...}
type ProcessingOptionsInput interface {
	pulumi.Input

	ToProcessingOptionsOutput() ProcessingOptionsOutput
	ToProcessingOptionsOutputWithContext(context.Context) ProcessingOptionsOutput
}

// Options for job processing.
type ProcessingOptionsArgs struct {
	// If set to `true`, the service does not attempt to resolve a more precise address for the job.
	DisableStreetAddressResolution pulumi.BoolPtrInput `pulumi:"disableStreetAddressResolution"`
	// Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation isn't disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
	HtmlSanitization ProcessingOptionsHtmlSanitizationPtrInput `pulumi:"htmlSanitization"`
}

func (ProcessingOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ProcessingOptions)(nil)).Elem()
}

func (i ProcessingOptionsArgs) ToProcessingOptionsOutput() ProcessingOptionsOutput {
	return i.ToProcessingOptionsOutputWithContext(context.Background())
}

func (i ProcessingOptionsArgs) ToProcessingOptionsOutputWithContext(ctx context.Context) ProcessingOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsOutput)
}

func (i ProcessingOptionsArgs) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return i.ToProcessingOptionsPtrOutputWithContext(context.Background())
}

func (i ProcessingOptionsArgs) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsOutput).ToProcessingOptionsPtrOutputWithContext(ctx)
}

// ProcessingOptionsPtrInput is an input type that accepts ProcessingOptionsArgs, ProcessingOptionsPtr and ProcessingOptionsPtrOutput values.
// You can construct a concrete instance of `ProcessingOptionsPtrInput` via:
//
//	        ProcessingOptionsArgs{...}
//
//	or:
//
//	        nil
type ProcessingOptionsPtrInput interface {
	pulumi.Input

	ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput
	ToProcessingOptionsPtrOutputWithContext(context.Context) ProcessingOptionsPtrOutput
}

type processingOptionsPtrType ProcessingOptionsArgs

func ProcessingOptionsPtr(v *ProcessingOptionsArgs) ProcessingOptionsPtrInput {
	return (*processingOptionsPtrType)(v)
}

func (*processingOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessingOptions)(nil)).Elem()
}

func (i *processingOptionsPtrType) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return i.ToProcessingOptionsPtrOutputWithContext(context.Background())
}

func (i *processingOptionsPtrType) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsPtrOutput)
}

// Options for job processing.
type ProcessingOptionsOutput struct{ *pulumi.OutputState }

func (ProcessingOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ProcessingOptions)(nil)).Elem()
}

func (o ProcessingOptionsOutput) ToProcessingOptionsOutput() ProcessingOptionsOutput {
	return o
}

func (o ProcessingOptionsOutput) ToProcessingOptionsOutputWithContext(ctx context.Context) ProcessingOptionsOutput {
	return o
}

func (o ProcessingOptionsOutput) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return o.ToProcessingOptionsPtrOutputWithContext(context.Background())
}

func (o ProcessingOptionsOutput) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ProcessingOptions) *ProcessingOptions {
		return &v
	}).(ProcessingOptionsPtrOutput)
}

// If set to `true`, the service does not attempt to resolve a more precise address for the job.
func (o ProcessingOptionsOutput) DisableStreetAddressResolution() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ProcessingOptions) *bool { return v.DisableStreetAddressResolution }).(pulumi.BoolPtrOutput)
}

// Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation isn't disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
func (o ProcessingOptionsOutput) HtmlSanitization() ProcessingOptionsHtmlSanitizationPtrOutput {
	return o.ApplyT(func(v ProcessingOptions) *ProcessingOptionsHtmlSanitization { return v.HtmlSanitization }).(ProcessingOptionsHtmlSanitizationPtrOutput)
}

type ProcessingOptionsPtrOutput struct{ *pulumi.OutputState }

func (ProcessingOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessingOptions)(nil)).Elem()
}

func (o ProcessingOptionsPtrOutput) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return o
}

func (o ProcessingOptionsPtrOutput) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return o
}

func (o ProcessingOptionsPtrOutput) Elem() ProcessingOptionsOutput {
	return o.ApplyT(func(v *ProcessingOptions) ProcessingOptions {
		if v != nil {
			return *v
		}
		var ret ProcessingOptions
		return ret
	}).(ProcessingOptionsOutput)
}

// If set to `true`, the service does not attempt to resolve a more precise address for the job.
func (o ProcessingOptionsPtrOutput) DisableStreetAddressResolution() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ProcessingOptions) *bool {
		if v == nil {
			return nil
		}
		return v.DisableStreetAddressResolution
	}).(pulumi.BoolPtrOutput)
}

// Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation isn't disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
func (o ProcessingOptionsPtrOutput) HtmlSanitization() ProcessingOptionsHtmlSanitizationPtrOutput {
	return o.ApplyT(func(v *ProcessingOptions) *ProcessingOptionsHtmlSanitization {
		if v == nil {
			return nil
		}
		return v.HtmlSanitization
	}).(ProcessingOptionsHtmlSanitizationPtrOutput)
}

// Options for job processing.
type ProcessingOptionsResponse struct {
	// If set to `true`, the service does not attempt to resolve a more precise address for the job.
	DisableStreetAddressResolution bool `pulumi:"disableStreetAddressResolution"`
	// Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation isn't disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
	HtmlSanitization string `pulumi:"htmlSanitization"`
}

// Options for job processing.
type ProcessingOptionsResponseOutput struct{ *pulumi.OutputState }

func (ProcessingOptionsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ProcessingOptionsResponse)(nil)).Elem()
}

func (o ProcessingOptionsResponseOutput) ToProcessingOptionsResponseOutput() ProcessingOptionsResponseOutput {
	return o
}

func (o ProcessingOptionsResponseOutput) ToProcessingOptionsResponseOutputWithContext(ctx context.Context) ProcessingOptionsResponseOutput {
	return o
}

// If set to `true`, the service does not attempt to resolve a more precise address for the job.
func (o ProcessingOptionsResponseOutput) DisableStreetAddressResolution() pulumi.BoolOutput {
	return o.ApplyT(func(v ProcessingOptionsResponse) bool { return v.DisableStreetAddressResolution }).(pulumi.BoolOutput)
}

// Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation isn't disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
func (o ProcessingOptionsResponseOutput) HtmlSanitization() pulumi.StringOutput {
	return o.ApplyT(func(v ProcessingOptionsResponse) string { return v.HtmlSanitization }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationInfoInput)(nil)).Elem(), ApplicationInfoArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplicationInfoPtrInput)(nil)).Elem(), ApplicationInfoArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CompensationEntryInput)(nil)).Elem(), CompensationEntryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CompensationEntryArrayInput)(nil)).Elem(), CompensationEntryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CompensationInfoInput)(nil)).Elem(), CompensationInfoArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CompensationInfoPtrInput)(nil)).Elem(), CompensationInfoArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CompensationRangeInput)(nil)).Elem(), CompensationRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CompensationRangePtrInput)(nil)).Elem(), CompensationRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CustomAttributeInput)(nil)).Elem(), CustomAttributeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CustomAttributeMapInput)(nil)).Elem(), CustomAttributeMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*MoneyInput)(nil)).Elem(), MoneyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MoneyPtrInput)(nil)).Elem(), MoneyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProcessingOptionsInput)(nil)).Elem(), ProcessingOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProcessingOptionsPtrInput)(nil)).Elem(), ProcessingOptionsArgs{})
	pulumi.RegisterOutputType(ApplicationInfoOutput{})
	pulumi.RegisterOutputType(ApplicationInfoPtrOutput{})
	pulumi.RegisterOutputType(ApplicationInfoResponseOutput{})
	pulumi.RegisterOutputType(CompanyDerivedInfoResponseOutput{})
	pulumi.RegisterOutputType(CompensationEntryOutput{})
	pulumi.RegisterOutputType(CompensationEntryArrayOutput{})
	pulumi.RegisterOutputType(CompensationEntryResponseOutput{})
	pulumi.RegisterOutputType(CompensationEntryResponseArrayOutput{})
	pulumi.RegisterOutputType(CompensationInfoOutput{})
	pulumi.RegisterOutputType(CompensationInfoPtrOutput{})
	pulumi.RegisterOutputType(CompensationInfoResponseOutput{})
	pulumi.RegisterOutputType(CompensationRangeOutput{})
	pulumi.RegisterOutputType(CompensationRangePtrOutput{})
	pulumi.RegisterOutputType(CompensationRangeResponseOutput{})
	pulumi.RegisterOutputType(CustomAttributeOutput{})
	pulumi.RegisterOutputType(CustomAttributeMapOutput{})
	pulumi.RegisterOutputType(CustomAttributeResponseOutput{})
	pulumi.RegisterOutputType(CustomAttributeResponseMapOutput{})
	pulumi.RegisterOutputType(JobDerivedInfoResponseOutput{})
	pulumi.RegisterOutputType(LatLngResponseOutput{})
	pulumi.RegisterOutputType(LocationResponseOutput{})
	pulumi.RegisterOutputType(LocationResponseArrayOutput{})
	pulumi.RegisterOutputType(MoneyOutput{})
	pulumi.RegisterOutputType(MoneyPtrOutput{})
	pulumi.RegisterOutputType(MoneyResponseOutput{})
	pulumi.RegisterOutputType(PostalAddressResponseOutput{})
	pulumi.RegisterOutputType(ProcessingOptionsOutput{})
	pulumi.RegisterOutputType(ProcessingOptionsPtrOutput{})
	pulumi.RegisterOutputType(ProcessingOptionsResponseOutput{})
}

// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates a new subscription.
type Subscription struct {
	pulumi.CustomResourceState

	// The settings for this subscription's message delivery.
	DeliveryConfig DeliveryConfigResponseOutput `pulumi:"deliveryConfig"`
	// If present, messages are automatically written from the Pub/Sub Lite topic associated with this subscription to a destination.
	ExportConfig ExportConfigResponseOutput `pulumi:"exportConfig"`
	Location     pulumi.StringOutput        `pulumi:"location"`
	// The name of the subscription. Structured like: projects/{project_number}/locations/{location}/subscriptions/{subscription_id}
	Name    pulumi.StringOutput `pulumi:"name"`
	Project pulumi.StringOutput `pulumi:"project"`
	// If true, the newly created subscription will only receive messages published after the subscription was created. Otherwise, the entire message backlog will be received on the subscription. Defaults to false.
	SkipBacklog pulumi.BoolPtrOutput `pulumi:"skipBacklog"`
	// Required. The ID to use for the subscription, which will become the final component of the subscription's name. This value is structured like: `my-sub-name`.
	SubscriptionId pulumi.StringOutput `pulumi:"subscriptionId"`
	// The name of the topic this subscription is attached to. Structured like: projects/{project_number}/locations/{location}/topics/{topic_id}
	Topic pulumi.StringOutput `pulumi:"topic"`
}

// NewSubscription registers a new resource with the given unique name, arguments, and options.
func NewSubscription(ctx *pulumi.Context,
	name string, args *SubscriptionArgs, opts ...pulumi.ResourceOption) (*Subscription, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.SubscriptionId == nil {
		return nil, errors.New("invalid value for required argument 'SubscriptionId'")
	}
	replaceOnChanges := pulumi.ReplaceOnChanges([]string{
		"location",
		"project",
		"subscriptionId",
	})
	opts = append(opts, replaceOnChanges)
	var resource Subscription
	err := ctx.RegisterResource("google-native:pubsublite/v1:Subscription", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSubscription gets an existing Subscription resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSubscription(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SubscriptionState, opts ...pulumi.ResourceOption) (*Subscription, error) {
	var resource Subscription
	err := ctx.ReadResource("google-native:pubsublite/v1:Subscription", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Subscription resources.
type subscriptionState struct {
}

type SubscriptionState struct {
}

func (SubscriptionState) ElementType() reflect.Type {
	return reflect.TypeOf((*subscriptionState)(nil)).Elem()
}

type subscriptionArgs struct {
	// The settings for this subscription's message delivery.
	DeliveryConfig *DeliveryConfig `pulumi:"deliveryConfig"`
	// If present, messages are automatically written from the Pub/Sub Lite topic associated with this subscription to a destination.
	ExportConfig *ExportConfig `pulumi:"exportConfig"`
	Location     *string       `pulumi:"location"`
	// The name of the subscription. Structured like: projects/{project_number}/locations/{location}/subscriptions/{subscription_id}
	Name    *string `pulumi:"name"`
	Project *string `pulumi:"project"`
	// If true, the newly created subscription will only receive messages published after the subscription was created. Otherwise, the entire message backlog will be received on the subscription. Defaults to false.
	SkipBacklog *bool `pulumi:"skipBacklog"`
	// Required. The ID to use for the subscription, which will become the final component of the subscription's name. This value is structured like: `my-sub-name`.
	SubscriptionId string `pulumi:"subscriptionId"`
	// The name of the topic this subscription is attached to. Structured like: projects/{project_number}/locations/{location}/topics/{topic_id}
	Topic *string `pulumi:"topic"`
}

// The set of arguments for constructing a Subscription resource.
type SubscriptionArgs struct {
	// The settings for this subscription's message delivery.
	DeliveryConfig DeliveryConfigPtrInput
	// If present, messages are automatically written from the Pub/Sub Lite topic associated with this subscription to a destination.
	ExportConfig ExportConfigPtrInput
	Location     pulumi.StringPtrInput
	// The name of the subscription. Structured like: projects/{project_number}/locations/{location}/subscriptions/{subscription_id}
	Name    pulumi.StringPtrInput
	Project pulumi.StringPtrInput
	// If true, the newly created subscription will only receive messages published after the subscription was created. Otherwise, the entire message backlog will be received on the subscription. Defaults to false.
	SkipBacklog pulumi.BoolPtrInput
	// Required. The ID to use for the subscription, which will become the final component of the subscription's name. This value is structured like: `my-sub-name`.
	SubscriptionId pulumi.StringInput
	// The name of the topic this subscription is attached to. Structured like: projects/{project_number}/locations/{location}/topics/{topic_id}
	Topic pulumi.StringPtrInput
}

func (SubscriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*subscriptionArgs)(nil)).Elem()
}

type SubscriptionInput interface {
	pulumi.Input

	ToSubscriptionOutput() SubscriptionOutput
	ToSubscriptionOutputWithContext(ctx context.Context) SubscriptionOutput
}

func (*Subscription) ElementType() reflect.Type {
	return reflect.TypeOf((**Subscription)(nil)).Elem()
}

func (i *Subscription) ToSubscriptionOutput() SubscriptionOutput {
	return i.ToSubscriptionOutputWithContext(context.Background())
}

func (i *Subscription) ToSubscriptionOutputWithContext(ctx context.Context) SubscriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionOutput)
}

type SubscriptionOutput struct{ *pulumi.OutputState }

func (SubscriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Subscription)(nil)).Elem()
}

func (o SubscriptionOutput) ToSubscriptionOutput() SubscriptionOutput {
	return o
}

func (o SubscriptionOutput) ToSubscriptionOutputWithContext(ctx context.Context) SubscriptionOutput {
	return o
}

// The settings for this subscription's message delivery.
func (o SubscriptionOutput) DeliveryConfig() DeliveryConfigResponseOutput {
	return o.ApplyT(func(v *Subscription) DeliveryConfigResponseOutput { return v.DeliveryConfig }).(DeliveryConfigResponseOutput)
}

// If present, messages are automatically written from the Pub/Sub Lite topic associated with this subscription to a destination.
func (o SubscriptionOutput) ExportConfig() ExportConfigResponseOutput {
	return o.ApplyT(func(v *Subscription) ExportConfigResponseOutput { return v.ExportConfig }).(ExportConfigResponseOutput)
}

func (o SubscriptionOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// The name of the subscription. Structured like: projects/{project_number}/locations/{location}/subscriptions/{subscription_id}
func (o SubscriptionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o SubscriptionOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// If true, the newly created subscription will only receive messages published after the subscription was created. Otherwise, the entire message backlog will be received on the subscription. Defaults to false.
func (o SubscriptionOutput) SkipBacklog() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Subscription) pulumi.BoolPtrOutput { return v.SkipBacklog }).(pulumi.BoolPtrOutput)
}

// Required. The ID to use for the subscription, which will become the final component of the subscription's name. This value is structured like: `my-sub-name`.
func (o SubscriptionOutput) SubscriptionId() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.SubscriptionId }).(pulumi.StringOutput)
}

// The name of the topic this subscription is attached to. Structured like: projects/{project_number}/locations/{location}/topics/{topic_id}
func (o SubscriptionOutput) Topic() pulumi.StringOutput {
	return o.ApplyT(func(v *Subscription) pulumi.StringOutput { return v.Topic }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SubscriptionInput)(nil)).Elem(), &Subscription{})
	pulumi.RegisterOutputType(SubscriptionOutput{})
}

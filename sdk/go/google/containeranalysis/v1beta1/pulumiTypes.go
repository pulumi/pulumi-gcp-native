// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// An alias to a repo revision.
type AliasContext struct {
	// The alias kind.
	Kind *AliasContextKind `pulumi:"kind"`
	// The alias name.
	Name *string `pulumi:"name"`
}

// AliasContextInput is an input type that accepts AliasContextArgs and AliasContextOutput values.
// You can construct a concrete instance of `AliasContextInput` via:
//
//          AliasContextArgs{...}
type AliasContextInput interface {
	pulumi.Input

	ToAliasContextOutput() AliasContextOutput
	ToAliasContextOutputWithContext(context.Context) AliasContextOutput
}

// An alias to a repo revision.
type AliasContextArgs struct {
	// The alias kind.
	Kind AliasContextKindPtrInput `pulumi:"kind"`
	// The alias name.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (AliasContextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasContext)(nil)).Elem()
}

func (i AliasContextArgs) ToAliasContextOutput() AliasContextOutput {
	return i.ToAliasContextOutputWithContext(context.Background())
}

func (i AliasContextArgs) ToAliasContextOutputWithContext(ctx context.Context) AliasContextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasContextOutput)
}

func (i AliasContextArgs) ToAliasContextPtrOutput() AliasContextPtrOutput {
	return i.ToAliasContextPtrOutputWithContext(context.Background())
}

func (i AliasContextArgs) ToAliasContextPtrOutputWithContext(ctx context.Context) AliasContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasContextOutput).ToAliasContextPtrOutputWithContext(ctx)
}

// AliasContextPtrInput is an input type that accepts AliasContextArgs, AliasContextPtr and AliasContextPtrOutput values.
// You can construct a concrete instance of `AliasContextPtrInput` via:
//
//          AliasContextArgs{...}
//
//  or:
//
//          nil
type AliasContextPtrInput interface {
	pulumi.Input

	ToAliasContextPtrOutput() AliasContextPtrOutput
	ToAliasContextPtrOutputWithContext(context.Context) AliasContextPtrOutput
}

type aliasContextPtrType AliasContextArgs

func AliasContextPtr(v *AliasContextArgs) AliasContextPtrInput {
	return (*aliasContextPtrType)(v)
}

func (*aliasContextPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AliasContext)(nil)).Elem()
}

func (i *aliasContextPtrType) ToAliasContextPtrOutput() AliasContextPtrOutput {
	return i.ToAliasContextPtrOutputWithContext(context.Background())
}

func (i *aliasContextPtrType) ToAliasContextPtrOutputWithContext(ctx context.Context) AliasContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasContextPtrOutput)
}

// An alias to a repo revision.
type AliasContextOutput struct{ *pulumi.OutputState }

func (AliasContextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasContext)(nil)).Elem()
}

func (o AliasContextOutput) ToAliasContextOutput() AliasContextOutput {
	return o
}

func (o AliasContextOutput) ToAliasContextOutputWithContext(ctx context.Context) AliasContextOutput {
	return o
}

func (o AliasContextOutput) ToAliasContextPtrOutput() AliasContextPtrOutput {
	return o.ToAliasContextPtrOutputWithContext(context.Background())
}

func (o AliasContextOutput) ToAliasContextPtrOutputWithContext(ctx context.Context) AliasContextPtrOutput {
	return o.ApplyT(func(v AliasContext) *AliasContext {
		return &v
	}).(AliasContextPtrOutput)
}

// The alias kind.
func (o AliasContextOutput) Kind() AliasContextKindPtrOutput {
	return o.ApplyT(func(v AliasContext) *AliasContextKind { return v.Kind }).(AliasContextKindPtrOutput)
}

// The alias name.
func (o AliasContextOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AliasContext) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type AliasContextPtrOutput struct{ *pulumi.OutputState }

func (AliasContextPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AliasContext)(nil)).Elem()
}

func (o AliasContextPtrOutput) ToAliasContextPtrOutput() AliasContextPtrOutput {
	return o
}

func (o AliasContextPtrOutput) ToAliasContextPtrOutputWithContext(ctx context.Context) AliasContextPtrOutput {
	return o
}

func (o AliasContextPtrOutput) Elem() AliasContextOutput {
	return o.ApplyT(func(v *AliasContext) AliasContext { return *v }).(AliasContextOutput)
}

// The alias kind.
func (o AliasContextPtrOutput) Kind() AliasContextKindPtrOutput {
	return o.ApplyT(func(v *AliasContext) *AliasContextKind {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(AliasContextKindPtrOutput)
}

// The alias name.
func (o AliasContextPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AliasContext) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// An alias to a repo revision.
type AliasContextResponse struct {
	// The alias kind.
	Kind string `pulumi:"kind"`
	// The alias name.
	Name string `pulumi:"name"`
}

// AliasContextResponseInput is an input type that accepts AliasContextResponseArgs and AliasContextResponseOutput values.
// You can construct a concrete instance of `AliasContextResponseInput` via:
//
//          AliasContextResponseArgs{...}
type AliasContextResponseInput interface {
	pulumi.Input

	ToAliasContextResponseOutput() AliasContextResponseOutput
	ToAliasContextResponseOutputWithContext(context.Context) AliasContextResponseOutput
}

// An alias to a repo revision.
type AliasContextResponseArgs struct {
	// The alias kind.
	Kind pulumi.StringInput `pulumi:"kind"`
	// The alias name.
	Name pulumi.StringInput `pulumi:"name"`
}

func (AliasContextResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasContextResponse)(nil)).Elem()
}

func (i AliasContextResponseArgs) ToAliasContextResponseOutput() AliasContextResponseOutput {
	return i.ToAliasContextResponseOutputWithContext(context.Background())
}

func (i AliasContextResponseArgs) ToAliasContextResponseOutputWithContext(ctx context.Context) AliasContextResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasContextResponseOutput)
}

func (i AliasContextResponseArgs) ToAliasContextResponsePtrOutput() AliasContextResponsePtrOutput {
	return i.ToAliasContextResponsePtrOutputWithContext(context.Background())
}

func (i AliasContextResponseArgs) ToAliasContextResponsePtrOutputWithContext(ctx context.Context) AliasContextResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasContextResponseOutput).ToAliasContextResponsePtrOutputWithContext(ctx)
}

// AliasContextResponsePtrInput is an input type that accepts AliasContextResponseArgs, AliasContextResponsePtr and AliasContextResponsePtrOutput values.
// You can construct a concrete instance of `AliasContextResponsePtrInput` via:
//
//          AliasContextResponseArgs{...}
//
//  or:
//
//          nil
type AliasContextResponsePtrInput interface {
	pulumi.Input

	ToAliasContextResponsePtrOutput() AliasContextResponsePtrOutput
	ToAliasContextResponsePtrOutputWithContext(context.Context) AliasContextResponsePtrOutput
}

type aliasContextResponsePtrType AliasContextResponseArgs

func AliasContextResponsePtr(v *AliasContextResponseArgs) AliasContextResponsePtrInput {
	return (*aliasContextResponsePtrType)(v)
}

func (*aliasContextResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AliasContextResponse)(nil)).Elem()
}

func (i *aliasContextResponsePtrType) ToAliasContextResponsePtrOutput() AliasContextResponsePtrOutput {
	return i.ToAliasContextResponsePtrOutputWithContext(context.Background())
}

func (i *aliasContextResponsePtrType) ToAliasContextResponsePtrOutputWithContext(ctx context.Context) AliasContextResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasContextResponsePtrOutput)
}

// An alias to a repo revision.
type AliasContextResponseOutput struct{ *pulumi.OutputState }

func (AliasContextResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasContextResponse)(nil)).Elem()
}

func (o AliasContextResponseOutput) ToAliasContextResponseOutput() AliasContextResponseOutput {
	return o
}

func (o AliasContextResponseOutput) ToAliasContextResponseOutputWithContext(ctx context.Context) AliasContextResponseOutput {
	return o
}

func (o AliasContextResponseOutput) ToAliasContextResponsePtrOutput() AliasContextResponsePtrOutput {
	return o.ToAliasContextResponsePtrOutputWithContext(context.Background())
}

func (o AliasContextResponseOutput) ToAliasContextResponsePtrOutputWithContext(ctx context.Context) AliasContextResponsePtrOutput {
	return o.ApplyT(func(v AliasContextResponse) *AliasContextResponse {
		return &v
	}).(AliasContextResponsePtrOutput)
}

// The alias kind.
func (o AliasContextResponseOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v AliasContextResponse) string { return v.Kind }).(pulumi.StringOutput)
}

// The alias name.
func (o AliasContextResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v AliasContextResponse) string { return v.Name }).(pulumi.StringOutput)
}

type AliasContextResponsePtrOutput struct{ *pulumi.OutputState }

func (AliasContextResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AliasContextResponse)(nil)).Elem()
}

func (o AliasContextResponsePtrOutput) ToAliasContextResponsePtrOutput() AliasContextResponsePtrOutput {
	return o
}

func (o AliasContextResponsePtrOutput) ToAliasContextResponsePtrOutputWithContext(ctx context.Context) AliasContextResponsePtrOutput {
	return o
}

func (o AliasContextResponsePtrOutput) Elem() AliasContextResponseOutput {
	return o.ApplyT(func(v *AliasContextResponse) AliasContextResponse { return *v }).(AliasContextResponseOutput)
}

// The alias kind.
func (o AliasContextResponsePtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AliasContextResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Kind
	}).(pulumi.StringPtrOutput)
}

// The alias name.
func (o AliasContextResponsePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AliasContextResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Artifact describes a build product.
type Artifact struct {
	// Hash or checksum value of a binary, or Docker Registry 2.0 digest of a container.
	Checksum *string `pulumi:"checksum"`
	// Artifact ID, if any; for container images, this will be a URL by digest like `gcr.io/projectID/imagename@sha256:123456`.
	Id *string `pulumi:"id"`
	// Related artifact names. This may be the path to a binary or jar file, or in the case of a container build, the name used to push the container image to Google Container Registry, as presented to `docker push`. Note that a single Artifact ID can have multiple names, for example if two tags are applied to one image.
	Names []string `pulumi:"names"`
}

// ArtifactInput is an input type that accepts ArtifactArgs and ArtifactOutput values.
// You can construct a concrete instance of `ArtifactInput` via:
//
//          ArtifactArgs{...}
type ArtifactInput interface {
	pulumi.Input

	ToArtifactOutput() ArtifactOutput
	ToArtifactOutputWithContext(context.Context) ArtifactOutput
}

// Artifact describes a build product.
type ArtifactArgs struct {
	// Hash or checksum value of a binary, or Docker Registry 2.0 digest of a container.
	Checksum pulumi.StringPtrInput `pulumi:"checksum"`
	// Artifact ID, if any; for container images, this will be a URL by digest like `gcr.io/projectID/imagename@sha256:123456`.
	Id pulumi.StringPtrInput `pulumi:"id"`
	// Related artifact names. This may be the path to a binary or jar file, or in the case of a container build, the name used to push the container image to Google Container Registry, as presented to `docker push`. Note that a single Artifact ID can have multiple names, for example if two tags are applied to one image.
	Names pulumi.StringArrayInput `pulumi:"names"`
}

func (ArtifactArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Artifact)(nil)).Elem()
}

func (i ArtifactArgs) ToArtifactOutput() ArtifactOutput {
	return i.ToArtifactOutputWithContext(context.Background())
}

func (i ArtifactArgs) ToArtifactOutputWithContext(ctx context.Context) ArtifactOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArtifactOutput)
}

// ArtifactArrayInput is an input type that accepts ArtifactArray and ArtifactArrayOutput values.
// You can construct a concrete instance of `ArtifactArrayInput` via:
//
//          ArtifactArray{ ArtifactArgs{...} }
type ArtifactArrayInput interface {
	pulumi.Input

	ToArtifactArrayOutput() ArtifactArrayOutput
	ToArtifactArrayOutputWithContext(context.Context) ArtifactArrayOutput
}

type ArtifactArray []ArtifactInput

func (ArtifactArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Artifact)(nil)).Elem()
}

func (i ArtifactArray) ToArtifactArrayOutput() ArtifactArrayOutput {
	return i.ToArtifactArrayOutputWithContext(context.Background())
}

func (i ArtifactArray) ToArtifactArrayOutputWithContext(ctx context.Context) ArtifactArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArtifactArrayOutput)
}

// Artifact describes a build product.
type ArtifactOutput struct{ *pulumi.OutputState }

func (ArtifactOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Artifact)(nil)).Elem()
}

func (o ArtifactOutput) ToArtifactOutput() ArtifactOutput {
	return o
}

func (o ArtifactOutput) ToArtifactOutputWithContext(ctx context.Context) ArtifactOutput {
	return o
}

// Hash or checksum value of a binary, or Docker Registry 2.0 digest of a container.
func (o ArtifactOutput) Checksum() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Artifact) *string { return v.Checksum }).(pulumi.StringPtrOutput)
}

// Artifact ID, if any; for container images, this will be a URL by digest like `gcr.io/projectID/imagename@sha256:123456`.
func (o ArtifactOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Artifact) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Related artifact names. This may be the path to a binary or jar file, or in the case of a container build, the name used to push the container image to Google Container Registry, as presented to `docker push`. Note that a single Artifact ID can have multiple names, for example if two tags are applied to one image.
func (o ArtifactOutput) Names() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Artifact) []string { return v.Names }).(pulumi.StringArrayOutput)
}

type ArtifactArrayOutput struct{ *pulumi.OutputState }

func (ArtifactArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Artifact)(nil)).Elem()
}

func (o ArtifactArrayOutput) ToArtifactArrayOutput() ArtifactArrayOutput {
	return o
}

func (o ArtifactArrayOutput) ToArtifactArrayOutputWithContext(ctx context.Context) ArtifactArrayOutput {
	return o
}

func (o ArtifactArrayOutput) Index(i pulumi.IntInput) ArtifactOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Artifact {
		return vs[0].([]Artifact)[vs[1].(int)]
	}).(ArtifactOutput)
}

// Defines a hash object for use in Materials and Products.
type ArtifactHashes struct {
	Sha256 *string `pulumi:"sha256"`
}

// ArtifactHashesInput is an input type that accepts ArtifactHashesArgs and ArtifactHashesOutput values.
// You can construct a concrete instance of `ArtifactHashesInput` via:
//
//          ArtifactHashesArgs{...}
type ArtifactHashesInput interface {
	pulumi.Input

	ToArtifactHashesOutput() ArtifactHashesOutput
	ToArtifactHashesOutputWithContext(context.Context) ArtifactHashesOutput
}

// Defines a hash object for use in Materials and Products.
type ArtifactHashesArgs struct {
	Sha256 pulumi.StringPtrInput `pulumi:"sha256"`
}

func (ArtifactHashesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ArtifactHashes)(nil)).Elem()
}

func (i ArtifactHashesArgs) ToArtifactHashesOutput() ArtifactHashesOutput {
	return i.ToArtifactHashesOutputWithContext(context.Background())
}

func (i ArtifactHashesArgs) ToArtifactHashesOutputWithContext(ctx context.Context) ArtifactHashesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArtifactHashesOutput)
}

func (i ArtifactHashesArgs) ToArtifactHashesPtrOutput() ArtifactHashesPtrOutput {
	return i.ToArtifactHashesPtrOutputWithContext(context.Background())
}

func (i ArtifactHashesArgs) ToArtifactHashesPtrOutputWithContext(ctx context.Context) ArtifactHashesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArtifactHashesOutput).ToArtifactHashesPtrOutputWithContext(ctx)
}

// ArtifactHashesPtrInput is an input type that accepts ArtifactHashesArgs, ArtifactHashesPtr and ArtifactHashesPtrOutput values.
// You can construct a concrete instance of `ArtifactHashesPtrInput` via:
//
//          ArtifactHashesArgs{...}
//
//  or:
//
//          nil
type ArtifactHashesPtrInput interface {
	pulumi.Input

	ToArtifactHashesPtrOutput() ArtifactHashesPtrOutput
	ToArtifactHashesPtrOutputWithContext(context.Context) ArtifactHashesPtrOutput
}

type artifactHashesPtrType ArtifactHashesArgs

func ArtifactHashesPtr(v *ArtifactHashesArgs) ArtifactHashesPtrInput {
	return (*artifactHashesPtrType)(v)
}

func (*artifactHashesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ArtifactHashes)(nil)).Elem()
}

func (i *artifactHashesPtrType) ToArtifactHashesPtrOutput() ArtifactHashesPtrOutput {
	return i.ToArtifactHashesPtrOutputWithContext(context.Background())
}

func (i *artifactHashesPtrType) ToArtifactHashesPtrOutputWithContext(ctx context.Context) ArtifactHashesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArtifactHashesPtrOutput)
}

// Defines a hash object for use in Materials and Products.
type ArtifactHashesOutput struct{ *pulumi.OutputState }

func (ArtifactHashesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ArtifactHashes)(nil)).Elem()
}

func (o ArtifactHashesOutput) ToArtifactHashesOutput() ArtifactHashesOutput {
	return o
}

func (o ArtifactHashesOutput) ToArtifactHashesOutputWithContext(ctx context.Context) ArtifactHashesOutput {
	return o
}

func (o ArtifactHashesOutput) ToArtifactHashesPtrOutput() ArtifactHashesPtrOutput {
	return o.ToArtifactHashesPtrOutputWithContext(context.Background())
}

func (o ArtifactHashesOutput) ToArtifactHashesPtrOutputWithContext(ctx context.Context) ArtifactHashesPtrOutput {
	return o.ApplyT(func(v ArtifactHashes) *ArtifactHashes {
		return &v
	}).(ArtifactHashesPtrOutput)
}
func (o ArtifactHashesOutput) Sha256() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ArtifactHashes) *string { return v.Sha256 }).(pulumi.StringPtrOutput)
}

type ArtifactHashesPtrOutput struct{ *pulumi.OutputState }

func (ArtifactHashesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ArtifactHashes)(nil)).Elem()
}

func (o ArtifactHashesPtrOutput) ToArtifactHashesPtrOutput() ArtifactHashesPtrOutput {
	return o
}

func (o ArtifactHashesPtrOutput) ToArtifactHashesPtrOutputWithContext(ctx context.Context) ArtifactHashesPtrOutput {
	return o
}

func (o ArtifactHashesPtrOutput) Elem() ArtifactHashesOutput {
	return o.ApplyT(func(v *ArtifactHashes) ArtifactHashes { return *v }).(ArtifactHashesOutput)
}

func (o ArtifactHashesPtrOutput) Sha256() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ArtifactHashes) *string {
		if v == nil {
			return nil
		}
		return v.Sha256
	}).(pulumi.StringPtrOutput)
}

// Defines a hash object for use in Materials and Products.
type ArtifactHashesResponse struct {
	Sha256 string `pulumi:"sha256"`
}

// ArtifactHashesResponseInput is an input type that accepts ArtifactHashesResponseArgs and ArtifactHashesResponseOutput values.
// You can construct a concrete instance of `ArtifactHashesResponseInput` via:
//
//          ArtifactHashesResponseArgs{...}
type ArtifactHashesResponseInput interface {
	pulumi.Input

	ToArtifactHashesResponseOutput() ArtifactHashesResponseOutput
	ToArtifactHashesResponseOutputWithContext(context.Context) ArtifactHashesResponseOutput
}

// Defines a hash object for use in Materials and Products.
type ArtifactHashesResponseArgs struct {
	Sha256 pulumi.StringInput `pulumi:"sha256"`
}

func (ArtifactHashesResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ArtifactHashesResponse)(nil)).Elem()
}

func (i ArtifactHashesResponseArgs) ToArtifactHashesResponseOutput() ArtifactHashesResponseOutput {
	return i.ToArtifactHashesResponseOutputWithContext(context.Background())
}

func (i ArtifactHashesResponseArgs) ToArtifactHashesResponseOutputWithContext(ctx context.Context) ArtifactHashesResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArtifactHashesResponseOutput)
}

// Defines a hash object for use in Materials and Products.
type ArtifactHashesResponseOutput struct{ *pulumi.OutputState }

func (ArtifactHashesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ArtifactHashesResponse)(nil)).Elem()
}

func (o ArtifactHashesResponseOutput) ToArtifactHashesResponseOutput() ArtifactHashesResponseOutput {
	return o
}

func (o ArtifactHashesResponseOutput) ToArtifactHashesResponseOutputWithContext(ctx context.Context) ArtifactHashesResponseOutput {
	return o
}

func (o ArtifactHashesResponseOutput) Sha256() pulumi.StringOutput {
	return o.ApplyT(func(v ArtifactHashesResponse) string { return v.Sha256 }).(pulumi.StringOutput)
}

// Artifact describes a build product.
type ArtifactResponse struct {
	// Hash or checksum value of a binary, or Docker Registry 2.0 digest of a container.
	Checksum string `pulumi:"checksum"`
	// Related artifact names. This may be the path to a binary or jar file, or in the case of a container build, the name used to push the container image to Google Container Registry, as presented to `docker push`. Note that a single Artifact ID can have multiple names, for example if two tags are applied to one image.
	Names []string `pulumi:"names"`
}

// ArtifactResponseInput is an input type that accepts ArtifactResponseArgs and ArtifactResponseOutput values.
// You can construct a concrete instance of `ArtifactResponseInput` via:
//
//          ArtifactResponseArgs{...}
type ArtifactResponseInput interface {
	pulumi.Input

	ToArtifactResponseOutput() ArtifactResponseOutput
	ToArtifactResponseOutputWithContext(context.Context) ArtifactResponseOutput
}

// Artifact describes a build product.
type ArtifactResponseArgs struct {
	// Hash or checksum value of a binary, or Docker Registry 2.0 digest of a container.
	Checksum pulumi.StringInput `pulumi:"checksum"`
	// Related artifact names. This may be the path to a binary or jar file, or in the case of a container build, the name used to push the container image to Google Container Registry, as presented to `docker push`. Note that a single Artifact ID can have multiple names, for example if two tags are applied to one image.
	Names pulumi.StringArrayInput `pulumi:"names"`
}

func (ArtifactResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ArtifactResponse)(nil)).Elem()
}

func (i ArtifactResponseArgs) ToArtifactResponseOutput() ArtifactResponseOutput {
	return i.ToArtifactResponseOutputWithContext(context.Background())
}

func (i ArtifactResponseArgs) ToArtifactResponseOutputWithContext(ctx context.Context) ArtifactResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArtifactResponseOutput)
}

// ArtifactResponseArrayInput is an input type that accepts ArtifactResponseArray and ArtifactResponseArrayOutput values.
// You can construct a concrete instance of `ArtifactResponseArrayInput` via:
//
//          ArtifactResponseArray{ ArtifactResponseArgs{...} }
type ArtifactResponseArrayInput interface {
	pulumi.Input

	ToArtifactResponseArrayOutput() ArtifactResponseArrayOutput
	ToArtifactResponseArrayOutputWithContext(context.Context) ArtifactResponseArrayOutput
}

type ArtifactResponseArray []ArtifactResponseInput

func (ArtifactResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ArtifactResponse)(nil)).Elem()
}

func (i ArtifactResponseArray) ToArtifactResponseArrayOutput() ArtifactResponseArrayOutput {
	return i.ToArtifactResponseArrayOutputWithContext(context.Background())
}

func (i ArtifactResponseArray) ToArtifactResponseArrayOutputWithContext(ctx context.Context) ArtifactResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArtifactResponseArrayOutput)
}

// Artifact describes a build product.
type ArtifactResponseOutput struct{ *pulumi.OutputState }

func (ArtifactResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ArtifactResponse)(nil)).Elem()
}

func (o ArtifactResponseOutput) ToArtifactResponseOutput() ArtifactResponseOutput {
	return o
}

func (o ArtifactResponseOutput) ToArtifactResponseOutputWithContext(ctx context.Context) ArtifactResponseOutput {
	return o
}

// Hash or checksum value of a binary, or Docker Registry 2.0 digest of a container.
func (o ArtifactResponseOutput) Checksum() pulumi.StringOutput {
	return o.ApplyT(func(v ArtifactResponse) string { return v.Checksum }).(pulumi.StringOutput)
}

// Related artifact names. This may be the path to a binary or jar file, or in the case of a container build, the name used to push the container image to Google Container Registry, as presented to `docker push`. Note that a single Artifact ID can have multiple names, for example if two tags are applied to one image.
func (o ArtifactResponseOutput) Names() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ArtifactResponse) []string { return v.Names }).(pulumi.StringArrayOutput)
}

type ArtifactResponseArrayOutput struct{ *pulumi.OutputState }

func (ArtifactResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ArtifactResponse)(nil)).Elem()
}

func (o ArtifactResponseArrayOutput) ToArtifactResponseArrayOutput() ArtifactResponseArrayOutput {
	return o
}

func (o ArtifactResponseArrayOutput) ToArtifactResponseArrayOutputWithContext(ctx context.Context) ArtifactResponseArrayOutput {
	return o
}

func (o ArtifactResponseArrayOutput) Index(i pulumi.IntInput) ArtifactResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ArtifactResponse {
		return vs[0].([]ArtifactResponse)[vs[1].(int)]
	}).(ArtifactResponseOutput)
}

// Defines an object to declare an in-toto artifact rule
type ArtifactRule struct {
	ArtifactRule []string `pulumi:"artifactRule"`
}

// ArtifactRuleInput is an input type that accepts ArtifactRuleArgs and ArtifactRuleOutput values.
// You can construct a concrete instance of `ArtifactRuleInput` via:
//
//          ArtifactRuleArgs{...}
type ArtifactRuleInput interface {
	pulumi.Input

	ToArtifactRuleOutput() ArtifactRuleOutput
	ToArtifactRuleOutputWithContext(context.Context) ArtifactRuleOutput
}

// Defines an object to declare an in-toto artifact rule
type ArtifactRuleArgs struct {
	ArtifactRule pulumi.StringArrayInput `pulumi:"artifactRule"`
}

func (ArtifactRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ArtifactRule)(nil)).Elem()
}

func (i ArtifactRuleArgs) ToArtifactRuleOutput() ArtifactRuleOutput {
	return i.ToArtifactRuleOutputWithContext(context.Background())
}

func (i ArtifactRuleArgs) ToArtifactRuleOutputWithContext(ctx context.Context) ArtifactRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArtifactRuleOutput)
}

// ArtifactRuleArrayInput is an input type that accepts ArtifactRuleArray and ArtifactRuleArrayOutput values.
// You can construct a concrete instance of `ArtifactRuleArrayInput` via:
//
//          ArtifactRuleArray{ ArtifactRuleArgs{...} }
type ArtifactRuleArrayInput interface {
	pulumi.Input

	ToArtifactRuleArrayOutput() ArtifactRuleArrayOutput
	ToArtifactRuleArrayOutputWithContext(context.Context) ArtifactRuleArrayOutput
}

type ArtifactRuleArray []ArtifactRuleInput

func (ArtifactRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ArtifactRule)(nil)).Elem()
}

func (i ArtifactRuleArray) ToArtifactRuleArrayOutput() ArtifactRuleArrayOutput {
	return i.ToArtifactRuleArrayOutputWithContext(context.Background())
}

func (i ArtifactRuleArray) ToArtifactRuleArrayOutputWithContext(ctx context.Context) ArtifactRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArtifactRuleArrayOutput)
}

// Defines an object to declare an in-toto artifact rule
type ArtifactRuleOutput struct{ *pulumi.OutputState }

func (ArtifactRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ArtifactRule)(nil)).Elem()
}

func (o ArtifactRuleOutput) ToArtifactRuleOutput() ArtifactRuleOutput {
	return o
}

func (o ArtifactRuleOutput) ToArtifactRuleOutputWithContext(ctx context.Context) ArtifactRuleOutput {
	return o
}

func (o ArtifactRuleOutput) ArtifactRule() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ArtifactRule) []string { return v.ArtifactRule }).(pulumi.StringArrayOutput)
}

type ArtifactRuleArrayOutput struct{ *pulumi.OutputState }

func (ArtifactRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ArtifactRule)(nil)).Elem()
}

func (o ArtifactRuleArrayOutput) ToArtifactRuleArrayOutput() ArtifactRuleArrayOutput {
	return o
}

func (o ArtifactRuleArrayOutput) ToArtifactRuleArrayOutputWithContext(ctx context.Context) ArtifactRuleArrayOutput {
	return o
}

func (o ArtifactRuleArrayOutput) Index(i pulumi.IntInput) ArtifactRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ArtifactRule {
		return vs[0].([]ArtifactRule)[vs[1].(int)]
	}).(ArtifactRuleOutput)
}

// Defines an object to declare an in-toto artifact rule
type ArtifactRuleResponse struct {
	ArtifactRule []string `pulumi:"artifactRule"`
}

// ArtifactRuleResponseInput is an input type that accepts ArtifactRuleResponseArgs and ArtifactRuleResponseOutput values.
// You can construct a concrete instance of `ArtifactRuleResponseInput` via:
//
//          ArtifactRuleResponseArgs{...}
type ArtifactRuleResponseInput interface {
	pulumi.Input

	ToArtifactRuleResponseOutput() ArtifactRuleResponseOutput
	ToArtifactRuleResponseOutputWithContext(context.Context) ArtifactRuleResponseOutput
}

// Defines an object to declare an in-toto artifact rule
type ArtifactRuleResponseArgs struct {
	ArtifactRule pulumi.StringArrayInput `pulumi:"artifactRule"`
}

func (ArtifactRuleResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ArtifactRuleResponse)(nil)).Elem()
}

func (i ArtifactRuleResponseArgs) ToArtifactRuleResponseOutput() ArtifactRuleResponseOutput {
	return i.ToArtifactRuleResponseOutputWithContext(context.Background())
}

func (i ArtifactRuleResponseArgs) ToArtifactRuleResponseOutputWithContext(ctx context.Context) ArtifactRuleResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArtifactRuleResponseOutput)
}

// ArtifactRuleResponseArrayInput is an input type that accepts ArtifactRuleResponseArray and ArtifactRuleResponseArrayOutput values.
// You can construct a concrete instance of `ArtifactRuleResponseArrayInput` via:
//
//          ArtifactRuleResponseArray{ ArtifactRuleResponseArgs{...} }
type ArtifactRuleResponseArrayInput interface {
	pulumi.Input

	ToArtifactRuleResponseArrayOutput() ArtifactRuleResponseArrayOutput
	ToArtifactRuleResponseArrayOutputWithContext(context.Context) ArtifactRuleResponseArrayOutput
}

type ArtifactRuleResponseArray []ArtifactRuleResponseInput

func (ArtifactRuleResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ArtifactRuleResponse)(nil)).Elem()
}

func (i ArtifactRuleResponseArray) ToArtifactRuleResponseArrayOutput() ArtifactRuleResponseArrayOutput {
	return i.ToArtifactRuleResponseArrayOutputWithContext(context.Background())
}

func (i ArtifactRuleResponseArray) ToArtifactRuleResponseArrayOutputWithContext(ctx context.Context) ArtifactRuleResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArtifactRuleResponseArrayOutput)
}

// Defines an object to declare an in-toto artifact rule
type ArtifactRuleResponseOutput struct{ *pulumi.OutputState }

func (ArtifactRuleResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ArtifactRuleResponse)(nil)).Elem()
}

func (o ArtifactRuleResponseOutput) ToArtifactRuleResponseOutput() ArtifactRuleResponseOutput {
	return o
}

func (o ArtifactRuleResponseOutput) ToArtifactRuleResponseOutputWithContext(ctx context.Context) ArtifactRuleResponseOutput {
	return o
}

func (o ArtifactRuleResponseOutput) ArtifactRule() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ArtifactRuleResponse) []string { return v.ArtifactRule }).(pulumi.StringArrayOutput)
}

type ArtifactRuleResponseArrayOutput struct{ *pulumi.OutputState }

func (ArtifactRuleResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ArtifactRuleResponse)(nil)).Elem()
}

func (o ArtifactRuleResponseArrayOutput) ToArtifactRuleResponseArrayOutput() ArtifactRuleResponseArrayOutput {
	return o
}

func (o ArtifactRuleResponseArrayOutput) ToArtifactRuleResponseArrayOutputWithContext(ctx context.Context) ArtifactRuleResponseArrayOutput {
	return o
}

func (o ArtifactRuleResponseArrayOutput) Index(i pulumi.IntInput) ArtifactRuleResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ArtifactRuleResponse {
		return vs[0].([]ArtifactRuleResponse)[vs[1].(int)]
	}).(ArtifactRuleResponseOutput)
}

// Occurrence that represents a single "attestation". The authenticity of an attestation can be verified using the attached signature. If the verifier trusts the public key of the signer, then verifying the signature is sufficient to establish trust. In this circumstance, the authority to which this attestation is attached is primarily useful for look-up (how to find this attestation if you already know the authority and artifact to be verified) and intent (which authority was this attestation intended to sign for).
type Attestation struct {
	GenericSignedAttestation *GenericSignedAttestation `pulumi:"genericSignedAttestation"`
	// A PGP signed attestation.
	PgpSignedAttestation *PgpSignedAttestation `pulumi:"pgpSignedAttestation"`
}

// AttestationInput is an input type that accepts AttestationArgs and AttestationOutput values.
// You can construct a concrete instance of `AttestationInput` via:
//
//          AttestationArgs{...}
type AttestationInput interface {
	pulumi.Input

	ToAttestationOutput() AttestationOutput
	ToAttestationOutputWithContext(context.Context) AttestationOutput
}

// Occurrence that represents a single "attestation". The authenticity of an attestation can be verified using the attached signature. If the verifier trusts the public key of the signer, then verifying the signature is sufficient to establish trust. In this circumstance, the authority to which this attestation is attached is primarily useful for look-up (how to find this attestation if you already know the authority and artifact to be verified) and intent (which authority was this attestation intended to sign for).
type AttestationArgs struct {
	GenericSignedAttestation GenericSignedAttestationPtrInput `pulumi:"genericSignedAttestation"`
	// A PGP signed attestation.
	PgpSignedAttestation PgpSignedAttestationPtrInput `pulumi:"pgpSignedAttestation"`
}

func (AttestationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Attestation)(nil)).Elem()
}

func (i AttestationArgs) ToAttestationOutput() AttestationOutput {
	return i.ToAttestationOutputWithContext(context.Background())
}

func (i AttestationArgs) ToAttestationOutputWithContext(ctx context.Context) AttestationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttestationOutput)
}

func (i AttestationArgs) ToAttestationPtrOutput() AttestationPtrOutput {
	return i.ToAttestationPtrOutputWithContext(context.Background())
}

func (i AttestationArgs) ToAttestationPtrOutputWithContext(ctx context.Context) AttestationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttestationOutput).ToAttestationPtrOutputWithContext(ctx)
}

// AttestationPtrInput is an input type that accepts AttestationArgs, AttestationPtr and AttestationPtrOutput values.
// You can construct a concrete instance of `AttestationPtrInput` via:
//
//          AttestationArgs{...}
//
//  or:
//
//          nil
type AttestationPtrInput interface {
	pulumi.Input

	ToAttestationPtrOutput() AttestationPtrOutput
	ToAttestationPtrOutputWithContext(context.Context) AttestationPtrOutput
}

type attestationPtrType AttestationArgs

func AttestationPtr(v *AttestationArgs) AttestationPtrInput {
	return (*attestationPtrType)(v)
}

func (*attestationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Attestation)(nil)).Elem()
}

func (i *attestationPtrType) ToAttestationPtrOutput() AttestationPtrOutput {
	return i.ToAttestationPtrOutputWithContext(context.Background())
}

func (i *attestationPtrType) ToAttestationPtrOutputWithContext(ctx context.Context) AttestationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttestationPtrOutput)
}

// Occurrence that represents a single "attestation". The authenticity of an attestation can be verified using the attached signature. If the verifier trusts the public key of the signer, then verifying the signature is sufficient to establish trust. In this circumstance, the authority to which this attestation is attached is primarily useful for look-up (how to find this attestation if you already know the authority and artifact to be verified) and intent (which authority was this attestation intended to sign for).
type AttestationOutput struct{ *pulumi.OutputState }

func (AttestationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Attestation)(nil)).Elem()
}

func (o AttestationOutput) ToAttestationOutput() AttestationOutput {
	return o
}

func (o AttestationOutput) ToAttestationOutputWithContext(ctx context.Context) AttestationOutput {
	return o
}

func (o AttestationOutput) ToAttestationPtrOutput() AttestationPtrOutput {
	return o.ToAttestationPtrOutputWithContext(context.Background())
}

func (o AttestationOutput) ToAttestationPtrOutputWithContext(ctx context.Context) AttestationPtrOutput {
	return o.ApplyT(func(v Attestation) *Attestation {
		return &v
	}).(AttestationPtrOutput)
}
func (o AttestationOutput) GenericSignedAttestation() GenericSignedAttestationPtrOutput {
	return o.ApplyT(func(v Attestation) *GenericSignedAttestation { return v.GenericSignedAttestation }).(GenericSignedAttestationPtrOutput)
}

// A PGP signed attestation.
func (o AttestationOutput) PgpSignedAttestation() PgpSignedAttestationPtrOutput {
	return o.ApplyT(func(v Attestation) *PgpSignedAttestation { return v.PgpSignedAttestation }).(PgpSignedAttestationPtrOutput)
}

type AttestationPtrOutput struct{ *pulumi.OutputState }

func (AttestationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Attestation)(nil)).Elem()
}

func (o AttestationPtrOutput) ToAttestationPtrOutput() AttestationPtrOutput {
	return o
}

func (o AttestationPtrOutput) ToAttestationPtrOutputWithContext(ctx context.Context) AttestationPtrOutput {
	return o
}

func (o AttestationPtrOutput) Elem() AttestationOutput {
	return o.ApplyT(func(v *Attestation) Attestation { return *v }).(AttestationOutput)
}

func (o AttestationPtrOutput) GenericSignedAttestation() GenericSignedAttestationPtrOutput {
	return o.ApplyT(func(v *Attestation) *GenericSignedAttestation {
		if v == nil {
			return nil
		}
		return v.GenericSignedAttestation
	}).(GenericSignedAttestationPtrOutput)
}

// A PGP signed attestation.
func (o AttestationPtrOutput) PgpSignedAttestation() PgpSignedAttestationPtrOutput {
	return o.ApplyT(func(v *Attestation) *PgpSignedAttestation {
		if v == nil {
			return nil
		}
		return v.PgpSignedAttestation
	}).(PgpSignedAttestationPtrOutput)
}

// Occurrence that represents a single "attestation". The authenticity of an attestation can be verified using the attached signature. If the verifier trusts the public key of the signer, then verifying the signature is sufficient to establish trust. In this circumstance, the authority to which this attestation is attached is primarily useful for look-up (how to find this attestation if you already know the authority and artifact to be verified) and intent (which authority was this attestation intended to sign for).
type AttestationResponse struct {
	GenericSignedAttestation GenericSignedAttestationResponse `pulumi:"genericSignedAttestation"`
	// A PGP signed attestation.
	PgpSignedAttestation PgpSignedAttestationResponse `pulumi:"pgpSignedAttestation"`
}

// AttestationResponseInput is an input type that accepts AttestationResponseArgs and AttestationResponseOutput values.
// You can construct a concrete instance of `AttestationResponseInput` via:
//
//          AttestationResponseArgs{...}
type AttestationResponseInput interface {
	pulumi.Input

	ToAttestationResponseOutput() AttestationResponseOutput
	ToAttestationResponseOutputWithContext(context.Context) AttestationResponseOutput
}

// Occurrence that represents a single "attestation". The authenticity of an attestation can be verified using the attached signature. If the verifier trusts the public key of the signer, then verifying the signature is sufficient to establish trust. In this circumstance, the authority to which this attestation is attached is primarily useful for look-up (how to find this attestation if you already know the authority and artifact to be verified) and intent (which authority was this attestation intended to sign for).
type AttestationResponseArgs struct {
	GenericSignedAttestation GenericSignedAttestationResponseInput `pulumi:"genericSignedAttestation"`
	// A PGP signed attestation.
	PgpSignedAttestation PgpSignedAttestationResponseInput `pulumi:"pgpSignedAttestation"`
}

func (AttestationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AttestationResponse)(nil)).Elem()
}

func (i AttestationResponseArgs) ToAttestationResponseOutput() AttestationResponseOutput {
	return i.ToAttestationResponseOutputWithContext(context.Background())
}

func (i AttestationResponseArgs) ToAttestationResponseOutputWithContext(ctx context.Context) AttestationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttestationResponseOutput)
}

func (i AttestationResponseArgs) ToAttestationResponsePtrOutput() AttestationResponsePtrOutput {
	return i.ToAttestationResponsePtrOutputWithContext(context.Background())
}

func (i AttestationResponseArgs) ToAttestationResponsePtrOutputWithContext(ctx context.Context) AttestationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttestationResponseOutput).ToAttestationResponsePtrOutputWithContext(ctx)
}

// AttestationResponsePtrInput is an input type that accepts AttestationResponseArgs, AttestationResponsePtr and AttestationResponsePtrOutput values.
// You can construct a concrete instance of `AttestationResponsePtrInput` via:
//
//          AttestationResponseArgs{...}
//
//  or:
//
//          nil
type AttestationResponsePtrInput interface {
	pulumi.Input

	ToAttestationResponsePtrOutput() AttestationResponsePtrOutput
	ToAttestationResponsePtrOutputWithContext(context.Context) AttestationResponsePtrOutput
}

type attestationResponsePtrType AttestationResponseArgs

func AttestationResponsePtr(v *AttestationResponseArgs) AttestationResponsePtrInput {
	return (*attestationResponsePtrType)(v)
}

func (*attestationResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AttestationResponse)(nil)).Elem()
}

func (i *attestationResponsePtrType) ToAttestationResponsePtrOutput() AttestationResponsePtrOutput {
	return i.ToAttestationResponsePtrOutputWithContext(context.Background())
}

func (i *attestationResponsePtrType) ToAttestationResponsePtrOutputWithContext(ctx context.Context) AttestationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttestationResponsePtrOutput)
}

// Occurrence that represents a single "attestation". The authenticity of an attestation can be verified using the attached signature. If the verifier trusts the public key of the signer, then verifying the signature is sufficient to establish trust. In this circumstance, the authority to which this attestation is attached is primarily useful for look-up (how to find this attestation if you already know the authority and artifact to be verified) and intent (which authority was this attestation intended to sign for).
type AttestationResponseOutput struct{ *pulumi.OutputState }

func (AttestationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AttestationResponse)(nil)).Elem()
}

func (o AttestationResponseOutput) ToAttestationResponseOutput() AttestationResponseOutput {
	return o
}

func (o AttestationResponseOutput) ToAttestationResponseOutputWithContext(ctx context.Context) AttestationResponseOutput {
	return o
}

func (o AttestationResponseOutput) ToAttestationResponsePtrOutput() AttestationResponsePtrOutput {
	return o.ToAttestationResponsePtrOutputWithContext(context.Background())
}

func (o AttestationResponseOutput) ToAttestationResponsePtrOutputWithContext(ctx context.Context) AttestationResponsePtrOutput {
	return o.ApplyT(func(v AttestationResponse) *AttestationResponse {
		return &v
	}).(AttestationResponsePtrOutput)
}
func (o AttestationResponseOutput) GenericSignedAttestation() GenericSignedAttestationResponseOutput {
	return o.ApplyT(func(v AttestationResponse) GenericSignedAttestationResponse { return v.GenericSignedAttestation }).(GenericSignedAttestationResponseOutput)
}

// A PGP signed attestation.
func (o AttestationResponseOutput) PgpSignedAttestation() PgpSignedAttestationResponseOutput {
	return o.ApplyT(func(v AttestationResponse) PgpSignedAttestationResponse { return v.PgpSignedAttestation }).(PgpSignedAttestationResponseOutput)
}

type AttestationResponsePtrOutput struct{ *pulumi.OutputState }

func (AttestationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AttestationResponse)(nil)).Elem()
}

func (o AttestationResponsePtrOutput) ToAttestationResponsePtrOutput() AttestationResponsePtrOutput {
	return o
}

func (o AttestationResponsePtrOutput) ToAttestationResponsePtrOutputWithContext(ctx context.Context) AttestationResponsePtrOutput {
	return o
}

func (o AttestationResponsePtrOutput) Elem() AttestationResponseOutput {
	return o.ApplyT(func(v *AttestationResponse) AttestationResponse { return *v }).(AttestationResponseOutput)
}

func (o AttestationResponsePtrOutput) GenericSignedAttestation() GenericSignedAttestationResponsePtrOutput {
	return o.ApplyT(func(v *AttestationResponse) *GenericSignedAttestationResponse {
		if v == nil {
			return nil
		}
		return &v.GenericSignedAttestation
	}).(GenericSignedAttestationResponsePtrOutput)
}

// A PGP signed attestation.
func (o AttestationResponsePtrOutput) PgpSignedAttestation() PgpSignedAttestationResponsePtrOutput {
	return o.ApplyT(func(v *AttestationResponse) *PgpSignedAttestationResponse {
		if v == nil {
			return nil
		}
		return &v.PgpSignedAttestation
	}).(PgpSignedAttestationResponsePtrOutput)
}

// Note kind that represents a logical attestation "role" or "authority". For example, an organization might have one `Authority` for "QA" and one for "build". This note is intended to act strictly as a grouping mechanism for the attached occurrences (Attestations). This grouping mechanism also provides a security boundary, since IAM ACLs gate the ability for a principle to attach an occurrence to a given note. It also provides a single point of lookup to find all attached attestation occurrences, even if they don't all live in the same project.
type Authority struct {
	// Hint hints at the purpose of the attestation authority.
	Hint *Hint `pulumi:"hint"`
}

// AuthorityInput is an input type that accepts AuthorityArgs and AuthorityOutput values.
// You can construct a concrete instance of `AuthorityInput` via:
//
//          AuthorityArgs{...}
type AuthorityInput interface {
	pulumi.Input

	ToAuthorityOutput() AuthorityOutput
	ToAuthorityOutputWithContext(context.Context) AuthorityOutput
}

// Note kind that represents a logical attestation "role" or "authority". For example, an organization might have one `Authority` for "QA" and one for "build". This note is intended to act strictly as a grouping mechanism for the attached occurrences (Attestations). This grouping mechanism also provides a security boundary, since IAM ACLs gate the ability for a principle to attach an occurrence to a given note. It also provides a single point of lookup to find all attached attestation occurrences, even if they don't all live in the same project.
type AuthorityArgs struct {
	// Hint hints at the purpose of the attestation authority.
	Hint HintPtrInput `pulumi:"hint"`
}

func (AuthorityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Authority)(nil)).Elem()
}

func (i AuthorityArgs) ToAuthorityOutput() AuthorityOutput {
	return i.ToAuthorityOutputWithContext(context.Background())
}

func (i AuthorityArgs) ToAuthorityOutputWithContext(ctx context.Context) AuthorityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuthorityOutput)
}

func (i AuthorityArgs) ToAuthorityPtrOutput() AuthorityPtrOutput {
	return i.ToAuthorityPtrOutputWithContext(context.Background())
}

func (i AuthorityArgs) ToAuthorityPtrOutputWithContext(ctx context.Context) AuthorityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuthorityOutput).ToAuthorityPtrOutputWithContext(ctx)
}

// AuthorityPtrInput is an input type that accepts AuthorityArgs, AuthorityPtr and AuthorityPtrOutput values.
// You can construct a concrete instance of `AuthorityPtrInput` via:
//
//          AuthorityArgs{...}
//
//  or:
//
//          nil
type AuthorityPtrInput interface {
	pulumi.Input

	ToAuthorityPtrOutput() AuthorityPtrOutput
	ToAuthorityPtrOutputWithContext(context.Context) AuthorityPtrOutput
}

type authorityPtrType AuthorityArgs

func AuthorityPtr(v *AuthorityArgs) AuthorityPtrInput {
	return (*authorityPtrType)(v)
}

func (*authorityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Authority)(nil)).Elem()
}

func (i *authorityPtrType) ToAuthorityPtrOutput() AuthorityPtrOutput {
	return i.ToAuthorityPtrOutputWithContext(context.Background())
}

func (i *authorityPtrType) ToAuthorityPtrOutputWithContext(ctx context.Context) AuthorityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuthorityPtrOutput)
}

// Note kind that represents a logical attestation "role" or "authority". For example, an organization might have one `Authority` for "QA" and one for "build". This note is intended to act strictly as a grouping mechanism for the attached occurrences (Attestations). This grouping mechanism also provides a security boundary, since IAM ACLs gate the ability for a principle to attach an occurrence to a given note. It also provides a single point of lookup to find all attached attestation occurrences, even if they don't all live in the same project.
type AuthorityOutput struct{ *pulumi.OutputState }

func (AuthorityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Authority)(nil)).Elem()
}

func (o AuthorityOutput) ToAuthorityOutput() AuthorityOutput {
	return o
}

func (o AuthorityOutput) ToAuthorityOutputWithContext(ctx context.Context) AuthorityOutput {
	return o
}

func (o AuthorityOutput) ToAuthorityPtrOutput() AuthorityPtrOutput {
	return o.ToAuthorityPtrOutputWithContext(context.Background())
}

func (o AuthorityOutput) ToAuthorityPtrOutputWithContext(ctx context.Context) AuthorityPtrOutput {
	return o.ApplyT(func(v Authority) *Authority {
		return &v
	}).(AuthorityPtrOutput)
}

// Hint hints at the purpose of the attestation authority.
func (o AuthorityOutput) Hint() HintPtrOutput {
	return o.ApplyT(func(v Authority) *Hint { return v.Hint }).(HintPtrOutput)
}

type AuthorityPtrOutput struct{ *pulumi.OutputState }

func (AuthorityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Authority)(nil)).Elem()
}

func (o AuthorityPtrOutput) ToAuthorityPtrOutput() AuthorityPtrOutput {
	return o
}

func (o AuthorityPtrOutput) ToAuthorityPtrOutputWithContext(ctx context.Context) AuthorityPtrOutput {
	return o
}

func (o AuthorityPtrOutput) Elem() AuthorityOutput {
	return o.ApplyT(func(v *Authority) Authority { return *v }).(AuthorityOutput)
}

// Hint hints at the purpose of the attestation authority.
func (o AuthorityPtrOutput) Hint() HintPtrOutput {
	return o.ApplyT(func(v *Authority) *Hint {
		if v == nil {
			return nil
		}
		return v.Hint
	}).(HintPtrOutput)
}

// Note kind that represents a logical attestation "role" or "authority". For example, an organization might have one `Authority` for "QA" and one for "build". This note is intended to act strictly as a grouping mechanism for the attached occurrences (Attestations). This grouping mechanism also provides a security boundary, since IAM ACLs gate the ability for a principle to attach an occurrence to a given note. It also provides a single point of lookup to find all attached attestation occurrences, even if they don't all live in the same project.
type AuthorityResponse struct {
	// Hint hints at the purpose of the attestation authority.
	Hint HintResponse `pulumi:"hint"`
}

// AuthorityResponseInput is an input type that accepts AuthorityResponseArgs and AuthorityResponseOutput values.
// You can construct a concrete instance of `AuthorityResponseInput` via:
//
//          AuthorityResponseArgs{...}
type AuthorityResponseInput interface {
	pulumi.Input

	ToAuthorityResponseOutput() AuthorityResponseOutput
	ToAuthorityResponseOutputWithContext(context.Context) AuthorityResponseOutput
}

// Note kind that represents a logical attestation "role" or "authority". For example, an organization might have one `Authority` for "QA" and one for "build". This note is intended to act strictly as a grouping mechanism for the attached occurrences (Attestations). This grouping mechanism also provides a security boundary, since IAM ACLs gate the ability for a principle to attach an occurrence to a given note. It also provides a single point of lookup to find all attached attestation occurrences, even if they don't all live in the same project.
type AuthorityResponseArgs struct {
	// Hint hints at the purpose of the attestation authority.
	Hint HintResponseInput `pulumi:"hint"`
}

func (AuthorityResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AuthorityResponse)(nil)).Elem()
}

func (i AuthorityResponseArgs) ToAuthorityResponseOutput() AuthorityResponseOutput {
	return i.ToAuthorityResponseOutputWithContext(context.Background())
}

func (i AuthorityResponseArgs) ToAuthorityResponseOutputWithContext(ctx context.Context) AuthorityResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuthorityResponseOutput)
}

func (i AuthorityResponseArgs) ToAuthorityResponsePtrOutput() AuthorityResponsePtrOutput {
	return i.ToAuthorityResponsePtrOutputWithContext(context.Background())
}

func (i AuthorityResponseArgs) ToAuthorityResponsePtrOutputWithContext(ctx context.Context) AuthorityResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuthorityResponseOutput).ToAuthorityResponsePtrOutputWithContext(ctx)
}

// AuthorityResponsePtrInput is an input type that accepts AuthorityResponseArgs, AuthorityResponsePtr and AuthorityResponsePtrOutput values.
// You can construct a concrete instance of `AuthorityResponsePtrInput` via:
//
//          AuthorityResponseArgs{...}
//
//  or:
//
//          nil
type AuthorityResponsePtrInput interface {
	pulumi.Input

	ToAuthorityResponsePtrOutput() AuthorityResponsePtrOutput
	ToAuthorityResponsePtrOutputWithContext(context.Context) AuthorityResponsePtrOutput
}

type authorityResponsePtrType AuthorityResponseArgs

func AuthorityResponsePtr(v *AuthorityResponseArgs) AuthorityResponsePtrInput {
	return (*authorityResponsePtrType)(v)
}

func (*authorityResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AuthorityResponse)(nil)).Elem()
}

func (i *authorityResponsePtrType) ToAuthorityResponsePtrOutput() AuthorityResponsePtrOutput {
	return i.ToAuthorityResponsePtrOutputWithContext(context.Background())
}

func (i *authorityResponsePtrType) ToAuthorityResponsePtrOutputWithContext(ctx context.Context) AuthorityResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuthorityResponsePtrOutput)
}

// Note kind that represents a logical attestation "role" or "authority". For example, an organization might have one `Authority` for "QA" and one for "build". This note is intended to act strictly as a grouping mechanism for the attached occurrences (Attestations). This grouping mechanism also provides a security boundary, since IAM ACLs gate the ability for a principle to attach an occurrence to a given note. It also provides a single point of lookup to find all attached attestation occurrences, even if they don't all live in the same project.
type AuthorityResponseOutput struct{ *pulumi.OutputState }

func (AuthorityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AuthorityResponse)(nil)).Elem()
}

func (o AuthorityResponseOutput) ToAuthorityResponseOutput() AuthorityResponseOutput {
	return o
}

func (o AuthorityResponseOutput) ToAuthorityResponseOutputWithContext(ctx context.Context) AuthorityResponseOutput {
	return o
}

func (o AuthorityResponseOutput) ToAuthorityResponsePtrOutput() AuthorityResponsePtrOutput {
	return o.ToAuthorityResponsePtrOutputWithContext(context.Background())
}

func (o AuthorityResponseOutput) ToAuthorityResponsePtrOutputWithContext(ctx context.Context) AuthorityResponsePtrOutput {
	return o.ApplyT(func(v AuthorityResponse) *AuthorityResponse {
		return &v
	}).(AuthorityResponsePtrOutput)
}

// Hint hints at the purpose of the attestation authority.
func (o AuthorityResponseOutput) Hint() HintResponseOutput {
	return o.ApplyT(func(v AuthorityResponse) HintResponse { return v.Hint }).(HintResponseOutput)
}

type AuthorityResponsePtrOutput struct{ *pulumi.OutputState }

func (AuthorityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AuthorityResponse)(nil)).Elem()
}

func (o AuthorityResponsePtrOutput) ToAuthorityResponsePtrOutput() AuthorityResponsePtrOutput {
	return o
}

func (o AuthorityResponsePtrOutput) ToAuthorityResponsePtrOutputWithContext(ctx context.Context) AuthorityResponsePtrOutput {
	return o
}

func (o AuthorityResponsePtrOutput) Elem() AuthorityResponseOutput {
	return o.ApplyT(func(v *AuthorityResponse) AuthorityResponse { return *v }).(AuthorityResponseOutput)
}

// Hint hints at the purpose of the attestation authority.
func (o AuthorityResponsePtrOutput) Hint() HintResponsePtrOutput {
	return o.ApplyT(func(v *AuthorityResponse) *HintResponse {
		if v == nil {
			return nil
		}
		return &v.Hint
	}).(HintResponsePtrOutput)
}

// Basis describes the base image portion (Note) of the DockerImage relationship. Linked occurrences are derived from this or an equivalent image via: FROM Or an equivalent reference, e.g. a tag of the resource_url.
type Basis struct {
	// Immutable. The fingerprint of the base image.
	Fingerprint Fingerprint `pulumi:"fingerprint"`
	// Immutable. The resource_url for the resource representing the basis of associated occurrence images.
	ResourceUrl string `pulumi:"resourceUrl"`
}

// BasisInput is an input type that accepts BasisArgs and BasisOutput values.
// You can construct a concrete instance of `BasisInput` via:
//
//          BasisArgs{...}
type BasisInput interface {
	pulumi.Input

	ToBasisOutput() BasisOutput
	ToBasisOutputWithContext(context.Context) BasisOutput
}

// Basis describes the base image portion (Note) of the DockerImage relationship. Linked occurrences are derived from this or an equivalent image via: FROM Or an equivalent reference, e.g. a tag of the resource_url.
type BasisArgs struct {
	// Immutable. The fingerprint of the base image.
	Fingerprint FingerprintInput `pulumi:"fingerprint"`
	// Immutable. The resource_url for the resource representing the basis of associated occurrence images.
	ResourceUrl pulumi.StringInput `pulumi:"resourceUrl"`
}

func (BasisArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Basis)(nil)).Elem()
}

func (i BasisArgs) ToBasisOutput() BasisOutput {
	return i.ToBasisOutputWithContext(context.Background())
}

func (i BasisArgs) ToBasisOutputWithContext(ctx context.Context) BasisOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasisOutput)
}

func (i BasisArgs) ToBasisPtrOutput() BasisPtrOutput {
	return i.ToBasisPtrOutputWithContext(context.Background())
}

func (i BasisArgs) ToBasisPtrOutputWithContext(ctx context.Context) BasisPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasisOutput).ToBasisPtrOutputWithContext(ctx)
}

// BasisPtrInput is an input type that accepts BasisArgs, BasisPtr and BasisPtrOutput values.
// You can construct a concrete instance of `BasisPtrInput` via:
//
//          BasisArgs{...}
//
//  or:
//
//          nil
type BasisPtrInput interface {
	pulumi.Input

	ToBasisPtrOutput() BasisPtrOutput
	ToBasisPtrOutputWithContext(context.Context) BasisPtrOutput
}

type basisPtrType BasisArgs

func BasisPtr(v *BasisArgs) BasisPtrInput {
	return (*basisPtrType)(v)
}

func (*basisPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Basis)(nil)).Elem()
}

func (i *basisPtrType) ToBasisPtrOutput() BasisPtrOutput {
	return i.ToBasisPtrOutputWithContext(context.Background())
}

func (i *basisPtrType) ToBasisPtrOutputWithContext(ctx context.Context) BasisPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasisPtrOutput)
}

// Basis describes the base image portion (Note) of the DockerImage relationship. Linked occurrences are derived from this or an equivalent image via: FROM Or an equivalent reference, e.g. a tag of the resource_url.
type BasisOutput struct{ *pulumi.OutputState }

func (BasisOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Basis)(nil)).Elem()
}

func (o BasisOutput) ToBasisOutput() BasisOutput {
	return o
}

func (o BasisOutput) ToBasisOutputWithContext(ctx context.Context) BasisOutput {
	return o
}

func (o BasisOutput) ToBasisPtrOutput() BasisPtrOutput {
	return o.ToBasisPtrOutputWithContext(context.Background())
}

func (o BasisOutput) ToBasisPtrOutputWithContext(ctx context.Context) BasisPtrOutput {
	return o.ApplyT(func(v Basis) *Basis {
		return &v
	}).(BasisPtrOutput)
}

// Immutable. The fingerprint of the base image.
func (o BasisOutput) Fingerprint() FingerprintOutput {
	return o.ApplyT(func(v Basis) Fingerprint { return v.Fingerprint }).(FingerprintOutput)
}

// Immutable. The resource_url for the resource representing the basis of associated occurrence images.
func (o BasisOutput) ResourceUrl() pulumi.StringOutput {
	return o.ApplyT(func(v Basis) string { return v.ResourceUrl }).(pulumi.StringOutput)
}

type BasisPtrOutput struct{ *pulumi.OutputState }

func (BasisPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Basis)(nil)).Elem()
}

func (o BasisPtrOutput) ToBasisPtrOutput() BasisPtrOutput {
	return o
}

func (o BasisPtrOutput) ToBasisPtrOutputWithContext(ctx context.Context) BasisPtrOutput {
	return o
}

func (o BasisPtrOutput) Elem() BasisOutput {
	return o.ApplyT(func(v *Basis) Basis { return *v }).(BasisOutput)
}

// Immutable. The fingerprint of the base image.
func (o BasisPtrOutput) Fingerprint() FingerprintPtrOutput {
	return o.ApplyT(func(v *Basis) *Fingerprint {
		if v == nil {
			return nil
		}
		return &v.Fingerprint
	}).(FingerprintPtrOutput)
}

// Immutable. The resource_url for the resource representing the basis of associated occurrence images.
func (o BasisPtrOutput) ResourceUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Basis) *string {
		if v == nil {
			return nil
		}
		return &v.ResourceUrl
	}).(pulumi.StringPtrOutput)
}

// Basis describes the base image portion (Note) of the DockerImage relationship. Linked occurrences are derived from this or an equivalent image via: FROM Or an equivalent reference, e.g. a tag of the resource_url.
type BasisResponse struct {
	// Immutable. The fingerprint of the base image.
	Fingerprint FingerprintResponse `pulumi:"fingerprint"`
	// Immutable. The resource_url for the resource representing the basis of associated occurrence images.
	ResourceUrl string `pulumi:"resourceUrl"`
}

// BasisResponseInput is an input type that accepts BasisResponseArgs and BasisResponseOutput values.
// You can construct a concrete instance of `BasisResponseInput` via:
//
//          BasisResponseArgs{...}
type BasisResponseInput interface {
	pulumi.Input

	ToBasisResponseOutput() BasisResponseOutput
	ToBasisResponseOutputWithContext(context.Context) BasisResponseOutput
}

// Basis describes the base image portion (Note) of the DockerImage relationship. Linked occurrences are derived from this or an equivalent image via: FROM Or an equivalent reference, e.g. a tag of the resource_url.
type BasisResponseArgs struct {
	// Immutable. The fingerprint of the base image.
	Fingerprint FingerprintResponseInput `pulumi:"fingerprint"`
	// Immutable. The resource_url for the resource representing the basis of associated occurrence images.
	ResourceUrl pulumi.StringInput `pulumi:"resourceUrl"`
}

func (BasisResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasisResponse)(nil)).Elem()
}

func (i BasisResponseArgs) ToBasisResponseOutput() BasisResponseOutput {
	return i.ToBasisResponseOutputWithContext(context.Background())
}

func (i BasisResponseArgs) ToBasisResponseOutputWithContext(ctx context.Context) BasisResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasisResponseOutput)
}

func (i BasisResponseArgs) ToBasisResponsePtrOutput() BasisResponsePtrOutput {
	return i.ToBasisResponsePtrOutputWithContext(context.Background())
}

func (i BasisResponseArgs) ToBasisResponsePtrOutputWithContext(ctx context.Context) BasisResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasisResponseOutput).ToBasisResponsePtrOutputWithContext(ctx)
}

// BasisResponsePtrInput is an input type that accepts BasisResponseArgs, BasisResponsePtr and BasisResponsePtrOutput values.
// You can construct a concrete instance of `BasisResponsePtrInput` via:
//
//          BasisResponseArgs{...}
//
//  or:
//
//          nil
type BasisResponsePtrInput interface {
	pulumi.Input

	ToBasisResponsePtrOutput() BasisResponsePtrOutput
	ToBasisResponsePtrOutputWithContext(context.Context) BasisResponsePtrOutput
}

type basisResponsePtrType BasisResponseArgs

func BasisResponsePtr(v *BasisResponseArgs) BasisResponsePtrInput {
	return (*basisResponsePtrType)(v)
}

func (*basisResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasisResponse)(nil)).Elem()
}

func (i *basisResponsePtrType) ToBasisResponsePtrOutput() BasisResponsePtrOutput {
	return i.ToBasisResponsePtrOutputWithContext(context.Background())
}

func (i *basisResponsePtrType) ToBasisResponsePtrOutputWithContext(ctx context.Context) BasisResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasisResponsePtrOutput)
}

// Basis describes the base image portion (Note) of the DockerImage relationship. Linked occurrences are derived from this or an equivalent image via: FROM Or an equivalent reference, e.g. a tag of the resource_url.
type BasisResponseOutput struct{ *pulumi.OutputState }

func (BasisResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasisResponse)(nil)).Elem()
}

func (o BasisResponseOutput) ToBasisResponseOutput() BasisResponseOutput {
	return o
}

func (o BasisResponseOutput) ToBasisResponseOutputWithContext(ctx context.Context) BasisResponseOutput {
	return o
}

func (o BasisResponseOutput) ToBasisResponsePtrOutput() BasisResponsePtrOutput {
	return o.ToBasisResponsePtrOutputWithContext(context.Background())
}

func (o BasisResponseOutput) ToBasisResponsePtrOutputWithContext(ctx context.Context) BasisResponsePtrOutput {
	return o.ApplyT(func(v BasisResponse) *BasisResponse {
		return &v
	}).(BasisResponsePtrOutput)
}

// Immutable. The fingerprint of the base image.
func (o BasisResponseOutput) Fingerprint() FingerprintResponseOutput {
	return o.ApplyT(func(v BasisResponse) FingerprintResponse { return v.Fingerprint }).(FingerprintResponseOutput)
}

// Immutable. The resource_url for the resource representing the basis of associated occurrence images.
func (o BasisResponseOutput) ResourceUrl() pulumi.StringOutput {
	return o.ApplyT(func(v BasisResponse) string { return v.ResourceUrl }).(pulumi.StringOutput)
}

type BasisResponsePtrOutput struct{ *pulumi.OutputState }

func (BasisResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasisResponse)(nil)).Elem()
}

func (o BasisResponsePtrOutput) ToBasisResponsePtrOutput() BasisResponsePtrOutput {
	return o
}

func (o BasisResponsePtrOutput) ToBasisResponsePtrOutputWithContext(ctx context.Context) BasisResponsePtrOutput {
	return o
}

func (o BasisResponsePtrOutput) Elem() BasisResponseOutput {
	return o.ApplyT(func(v *BasisResponse) BasisResponse { return *v }).(BasisResponseOutput)
}

// Immutable. The fingerprint of the base image.
func (o BasisResponsePtrOutput) Fingerprint() FingerprintResponsePtrOutput {
	return o.ApplyT(func(v *BasisResponse) *FingerprintResponse {
		if v == nil {
			return nil
		}
		return &v.Fingerprint
	}).(FingerprintResponsePtrOutput)
}

// Immutable. The resource_url for the resource representing the basis of associated occurrence images.
func (o BasisResponsePtrOutput) ResourceUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BasisResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ResourceUrl
	}).(pulumi.StringPtrOutput)
}

// Associates `members` with a `role`.
type Binding struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition *Expr `pulumi:"condition"`
	// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
	Members []string `pulumi:"members"`
	// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role *string `pulumi:"role"`
}

// BindingInput is an input type that accepts BindingArgs and BindingOutput values.
// You can construct a concrete instance of `BindingInput` via:
//
//          BindingArgs{...}
type BindingInput interface {
	pulumi.Input

	ToBindingOutput() BindingOutput
	ToBindingOutputWithContext(context.Context) BindingOutput
}

// Associates `members` with a `role`.
type BindingArgs struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition ExprPtrInput `pulumi:"condition"`
	// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
	Members pulumi.StringArrayInput `pulumi:"members"`
	// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role pulumi.StringPtrInput `pulumi:"role"`
}

func (BindingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Binding)(nil)).Elem()
}

func (i BindingArgs) ToBindingOutput() BindingOutput {
	return i.ToBindingOutputWithContext(context.Background())
}

func (i BindingArgs) ToBindingOutputWithContext(ctx context.Context) BindingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingOutput)
}

// BindingArrayInput is an input type that accepts BindingArray and BindingArrayOutput values.
// You can construct a concrete instance of `BindingArrayInput` via:
//
//          BindingArray{ BindingArgs{...} }
type BindingArrayInput interface {
	pulumi.Input

	ToBindingArrayOutput() BindingArrayOutput
	ToBindingArrayOutputWithContext(context.Context) BindingArrayOutput
}

type BindingArray []BindingInput

func (BindingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Binding)(nil)).Elem()
}

func (i BindingArray) ToBindingArrayOutput() BindingArrayOutput {
	return i.ToBindingArrayOutputWithContext(context.Background())
}

func (i BindingArray) ToBindingArrayOutputWithContext(ctx context.Context) BindingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingArrayOutput)
}

// Associates `members` with a `role`.
type BindingOutput struct{ *pulumi.OutputState }

func (BindingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Binding)(nil)).Elem()
}

func (o BindingOutput) ToBindingOutput() BindingOutput {
	return o
}

func (o BindingOutput) ToBindingOutputWithContext(ctx context.Context) BindingOutput {
	return o
}

// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o BindingOutput) Condition() ExprPtrOutput {
	return o.ApplyT(func(v Binding) *Expr { return v.Condition }).(ExprPtrOutput)
}

// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
func (o BindingOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Binding) []string { return v.Members }).(pulumi.StringArrayOutput)
}

// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
func (o BindingOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Binding) *string { return v.Role }).(pulumi.StringPtrOutput)
}

type BindingArrayOutput struct{ *pulumi.OutputState }

func (BindingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Binding)(nil)).Elem()
}

func (o BindingArrayOutput) ToBindingArrayOutput() BindingArrayOutput {
	return o
}

func (o BindingArrayOutput) ToBindingArrayOutputWithContext(ctx context.Context) BindingArrayOutput {
	return o
}

func (o BindingArrayOutput) Index(i pulumi.IntInput) BindingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Binding {
		return vs[0].([]Binding)[vs[1].(int)]
	}).(BindingOutput)
}

// Associates `members` with a `role`.
type BindingResponse struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition ExprResponse `pulumi:"condition"`
	// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
	Members []string `pulumi:"members"`
	// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role string `pulumi:"role"`
}

// BindingResponseInput is an input type that accepts BindingResponseArgs and BindingResponseOutput values.
// You can construct a concrete instance of `BindingResponseInput` via:
//
//          BindingResponseArgs{...}
type BindingResponseInput interface {
	pulumi.Input

	ToBindingResponseOutput() BindingResponseOutput
	ToBindingResponseOutputWithContext(context.Context) BindingResponseOutput
}

// Associates `members` with a `role`.
type BindingResponseArgs struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition ExprResponseInput `pulumi:"condition"`
	// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
	Members pulumi.StringArrayInput `pulumi:"members"`
	// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role pulumi.StringInput `pulumi:"role"`
}

func (BindingResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BindingResponse)(nil)).Elem()
}

func (i BindingResponseArgs) ToBindingResponseOutput() BindingResponseOutput {
	return i.ToBindingResponseOutputWithContext(context.Background())
}

func (i BindingResponseArgs) ToBindingResponseOutputWithContext(ctx context.Context) BindingResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingResponseOutput)
}

// BindingResponseArrayInput is an input type that accepts BindingResponseArray and BindingResponseArrayOutput values.
// You can construct a concrete instance of `BindingResponseArrayInput` via:
//
//          BindingResponseArray{ BindingResponseArgs{...} }
type BindingResponseArrayInput interface {
	pulumi.Input

	ToBindingResponseArrayOutput() BindingResponseArrayOutput
	ToBindingResponseArrayOutputWithContext(context.Context) BindingResponseArrayOutput
}

type BindingResponseArray []BindingResponseInput

func (BindingResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BindingResponse)(nil)).Elem()
}

func (i BindingResponseArray) ToBindingResponseArrayOutput() BindingResponseArrayOutput {
	return i.ToBindingResponseArrayOutputWithContext(context.Background())
}

func (i BindingResponseArray) ToBindingResponseArrayOutputWithContext(ctx context.Context) BindingResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingResponseArrayOutput)
}

// Associates `members` with a `role`.
type BindingResponseOutput struct{ *pulumi.OutputState }

func (BindingResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BindingResponse)(nil)).Elem()
}

func (o BindingResponseOutput) ToBindingResponseOutput() BindingResponseOutput {
	return o
}

func (o BindingResponseOutput) ToBindingResponseOutputWithContext(ctx context.Context) BindingResponseOutput {
	return o
}

// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the members in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o BindingResponseOutput) Condition() ExprResponseOutput {
	return o.ApplyT(func(v BindingResponse) ExprResponse { return v.Condition }).(ExprResponseOutput)
}

// Specifies the identities requesting access for a Cloud Platform resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`.
func (o BindingResponseOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BindingResponse) []string { return v.Members }).(pulumi.StringArrayOutput)
}

// Role that is assigned to `members`. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
func (o BindingResponseOutput) Role() pulumi.StringOutput {
	return o.ApplyT(func(v BindingResponse) string { return v.Role }).(pulumi.StringOutput)
}

type BindingResponseArrayOutput struct{ *pulumi.OutputState }

func (BindingResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BindingResponse)(nil)).Elem()
}

func (o BindingResponseArrayOutput) ToBindingResponseArrayOutput() BindingResponseArrayOutput {
	return o
}

func (o BindingResponseArrayOutput) ToBindingResponseArrayOutputWithContext(ctx context.Context) BindingResponseArrayOutput {
	return o
}

func (o BindingResponseArrayOutput) Index(i pulumi.IntInput) BindingResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BindingResponse {
		return vs[0].([]BindingResponse)[vs[1].(int)]
	}).(BindingResponseOutput)
}

// Note holding the version of the provider's builder and the signature of the provenance message in the build details occurrence.
type Build struct {
	// Immutable. Version of the builder which produced this build.
	BuilderVersion string `pulumi:"builderVersion"`
	// Signature of the build in occurrences pointing to this build note containing build details.
	Signature *BuildSignature `pulumi:"signature"`
}

// BuildInput is an input type that accepts BuildArgs and BuildOutput values.
// You can construct a concrete instance of `BuildInput` via:
//
//          BuildArgs{...}
type BuildInput interface {
	pulumi.Input

	ToBuildOutput() BuildOutput
	ToBuildOutputWithContext(context.Context) BuildOutput
}

// Note holding the version of the provider's builder and the signature of the provenance message in the build details occurrence.
type BuildArgs struct {
	// Immutable. Version of the builder which produced this build.
	BuilderVersion pulumi.StringInput `pulumi:"builderVersion"`
	// Signature of the build in occurrences pointing to this build note containing build details.
	Signature BuildSignaturePtrInput `pulumi:"signature"`
}

func (BuildArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Build)(nil)).Elem()
}

func (i BuildArgs) ToBuildOutput() BuildOutput {
	return i.ToBuildOutputWithContext(context.Background())
}

func (i BuildArgs) ToBuildOutputWithContext(ctx context.Context) BuildOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildOutput)
}

func (i BuildArgs) ToBuildPtrOutput() BuildPtrOutput {
	return i.ToBuildPtrOutputWithContext(context.Background())
}

func (i BuildArgs) ToBuildPtrOutputWithContext(ctx context.Context) BuildPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildOutput).ToBuildPtrOutputWithContext(ctx)
}

// BuildPtrInput is an input type that accepts BuildArgs, BuildPtr and BuildPtrOutput values.
// You can construct a concrete instance of `BuildPtrInput` via:
//
//          BuildArgs{...}
//
//  or:
//
//          nil
type BuildPtrInput interface {
	pulumi.Input

	ToBuildPtrOutput() BuildPtrOutput
	ToBuildPtrOutputWithContext(context.Context) BuildPtrOutput
}

type buildPtrType BuildArgs

func BuildPtr(v *BuildArgs) BuildPtrInput {
	return (*buildPtrType)(v)
}

func (*buildPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Build)(nil)).Elem()
}

func (i *buildPtrType) ToBuildPtrOutput() BuildPtrOutput {
	return i.ToBuildPtrOutputWithContext(context.Background())
}

func (i *buildPtrType) ToBuildPtrOutputWithContext(ctx context.Context) BuildPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildPtrOutput)
}

// Note holding the version of the provider's builder and the signature of the provenance message in the build details occurrence.
type BuildOutput struct{ *pulumi.OutputState }

func (BuildOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Build)(nil)).Elem()
}

func (o BuildOutput) ToBuildOutput() BuildOutput {
	return o
}

func (o BuildOutput) ToBuildOutputWithContext(ctx context.Context) BuildOutput {
	return o
}

func (o BuildOutput) ToBuildPtrOutput() BuildPtrOutput {
	return o.ToBuildPtrOutputWithContext(context.Background())
}

func (o BuildOutput) ToBuildPtrOutputWithContext(ctx context.Context) BuildPtrOutput {
	return o.ApplyT(func(v Build) *Build {
		return &v
	}).(BuildPtrOutput)
}

// Immutable. Version of the builder which produced this build.
func (o BuildOutput) BuilderVersion() pulumi.StringOutput {
	return o.ApplyT(func(v Build) string { return v.BuilderVersion }).(pulumi.StringOutput)
}

// Signature of the build in occurrences pointing to this build note containing build details.
func (o BuildOutput) Signature() BuildSignaturePtrOutput {
	return o.ApplyT(func(v Build) *BuildSignature { return v.Signature }).(BuildSignaturePtrOutput)
}

type BuildPtrOutput struct{ *pulumi.OutputState }

func (BuildPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Build)(nil)).Elem()
}

func (o BuildPtrOutput) ToBuildPtrOutput() BuildPtrOutput {
	return o
}

func (o BuildPtrOutput) ToBuildPtrOutputWithContext(ctx context.Context) BuildPtrOutput {
	return o
}

func (o BuildPtrOutput) Elem() BuildOutput {
	return o.ApplyT(func(v *Build) Build { return *v }).(BuildOutput)
}

// Immutable. Version of the builder which produced this build.
func (o BuildPtrOutput) BuilderVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Build) *string {
		if v == nil {
			return nil
		}
		return &v.BuilderVersion
	}).(pulumi.StringPtrOutput)
}

// Signature of the build in occurrences pointing to this build note containing build details.
func (o BuildPtrOutput) Signature() BuildSignaturePtrOutput {
	return o.ApplyT(func(v *Build) *BuildSignature {
		if v == nil {
			return nil
		}
		return v.Signature
	}).(BuildSignaturePtrOutput)
}

// Provenance of a build. Contains all information needed to verify the full details about the build from source to completion.
type BuildProvenance struct {
	// Special options applied to this build. This is a catch-all field where build providers can enter any desired additional details.
	BuildOptions map[string]string `pulumi:"buildOptions"`
	// Version string of the builder at the time this build was executed.
	BuilderVersion *string `pulumi:"builderVersion"`
	// Output of the build.
	BuiltArtifacts []Artifact `pulumi:"builtArtifacts"`
	// Commands requested by the build.
	Commands []Command `pulumi:"commands"`
	// Time at which the build was created.
	CreateTime *string `pulumi:"createTime"`
	// E-mail address of the user who initiated this build. Note that this was the user's e-mail address at the time the build was initiated; this address may not represent the same end-user for all time.
	Creator *string `pulumi:"creator"`
	// Time at which execution of the build was finished.
	EndTime *string `pulumi:"endTime"`
	// Unique identifier of the build.
	Id string `pulumi:"id"`
	// URI where any logs for this provenance were written.
	LogsUri *string `pulumi:"logsUri"`
	// ID of the project.
	Project *string `pulumi:"project"`
	// Details of the Source input to the build.
	SourceProvenance *Source `pulumi:"sourceProvenance"`
	// Time at which execution of the build was started.
	StartTime *string `pulumi:"startTime"`
	// Trigger identifier if the build was triggered automatically; empty if not.
	TriggerId *string `pulumi:"triggerId"`
}

// BuildProvenanceInput is an input type that accepts BuildProvenanceArgs and BuildProvenanceOutput values.
// You can construct a concrete instance of `BuildProvenanceInput` via:
//
//          BuildProvenanceArgs{...}
type BuildProvenanceInput interface {
	pulumi.Input

	ToBuildProvenanceOutput() BuildProvenanceOutput
	ToBuildProvenanceOutputWithContext(context.Context) BuildProvenanceOutput
}

// Provenance of a build. Contains all information needed to verify the full details about the build from source to completion.
type BuildProvenanceArgs struct {
	// Special options applied to this build. This is a catch-all field where build providers can enter any desired additional details.
	BuildOptions pulumi.StringMapInput `pulumi:"buildOptions"`
	// Version string of the builder at the time this build was executed.
	BuilderVersion pulumi.StringPtrInput `pulumi:"builderVersion"`
	// Output of the build.
	BuiltArtifacts ArtifactArrayInput `pulumi:"builtArtifacts"`
	// Commands requested by the build.
	Commands CommandArrayInput `pulumi:"commands"`
	// Time at which the build was created.
	CreateTime pulumi.StringPtrInput `pulumi:"createTime"`
	// E-mail address of the user who initiated this build. Note that this was the user's e-mail address at the time the build was initiated; this address may not represent the same end-user for all time.
	Creator pulumi.StringPtrInput `pulumi:"creator"`
	// Time at which execution of the build was finished.
	EndTime pulumi.StringPtrInput `pulumi:"endTime"`
	// Unique identifier of the build.
	Id pulumi.StringInput `pulumi:"id"`
	// URI where any logs for this provenance were written.
	LogsUri pulumi.StringPtrInput `pulumi:"logsUri"`
	// ID of the project.
	Project pulumi.StringPtrInput `pulumi:"project"`
	// Details of the Source input to the build.
	SourceProvenance SourcePtrInput `pulumi:"sourceProvenance"`
	// Time at which execution of the build was started.
	StartTime pulumi.StringPtrInput `pulumi:"startTime"`
	// Trigger identifier if the build was triggered automatically; empty if not.
	TriggerId pulumi.StringPtrInput `pulumi:"triggerId"`
}

func (BuildProvenanceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildProvenance)(nil)).Elem()
}

func (i BuildProvenanceArgs) ToBuildProvenanceOutput() BuildProvenanceOutput {
	return i.ToBuildProvenanceOutputWithContext(context.Background())
}

func (i BuildProvenanceArgs) ToBuildProvenanceOutputWithContext(ctx context.Context) BuildProvenanceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildProvenanceOutput)
}

func (i BuildProvenanceArgs) ToBuildProvenancePtrOutput() BuildProvenancePtrOutput {
	return i.ToBuildProvenancePtrOutputWithContext(context.Background())
}

func (i BuildProvenanceArgs) ToBuildProvenancePtrOutputWithContext(ctx context.Context) BuildProvenancePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildProvenanceOutput).ToBuildProvenancePtrOutputWithContext(ctx)
}

// BuildProvenancePtrInput is an input type that accepts BuildProvenanceArgs, BuildProvenancePtr and BuildProvenancePtrOutput values.
// You can construct a concrete instance of `BuildProvenancePtrInput` via:
//
//          BuildProvenanceArgs{...}
//
//  or:
//
//          nil
type BuildProvenancePtrInput interface {
	pulumi.Input

	ToBuildProvenancePtrOutput() BuildProvenancePtrOutput
	ToBuildProvenancePtrOutputWithContext(context.Context) BuildProvenancePtrOutput
}

type buildProvenancePtrType BuildProvenanceArgs

func BuildProvenancePtr(v *BuildProvenanceArgs) BuildProvenancePtrInput {
	return (*buildProvenancePtrType)(v)
}

func (*buildProvenancePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildProvenance)(nil)).Elem()
}

func (i *buildProvenancePtrType) ToBuildProvenancePtrOutput() BuildProvenancePtrOutput {
	return i.ToBuildProvenancePtrOutputWithContext(context.Background())
}

func (i *buildProvenancePtrType) ToBuildProvenancePtrOutputWithContext(ctx context.Context) BuildProvenancePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildProvenancePtrOutput)
}

// Provenance of a build. Contains all information needed to verify the full details about the build from source to completion.
type BuildProvenanceOutput struct{ *pulumi.OutputState }

func (BuildProvenanceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildProvenance)(nil)).Elem()
}

func (o BuildProvenanceOutput) ToBuildProvenanceOutput() BuildProvenanceOutput {
	return o
}

func (o BuildProvenanceOutput) ToBuildProvenanceOutputWithContext(ctx context.Context) BuildProvenanceOutput {
	return o
}

func (o BuildProvenanceOutput) ToBuildProvenancePtrOutput() BuildProvenancePtrOutput {
	return o.ToBuildProvenancePtrOutputWithContext(context.Background())
}

func (o BuildProvenanceOutput) ToBuildProvenancePtrOutputWithContext(ctx context.Context) BuildProvenancePtrOutput {
	return o.ApplyT(func(v BuildProvenance) *BuildProvenance {
		return &v
	}).(BuildProvenancePtrOutput)
}

// Special options applied to this build. This is a catch-all field where build providers can enter any desired additional details.
func (o BuildProvenanceOutput) BuildOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v BuildProvenance) map[string]string { return v.BuildOptions }).(pulumi.StringMapOutput)
}

// Version string of the builder at the time this build was executed.
func (o BuildProvenanceOutput) BuilderVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildProvenance) *string { return v.BuilderVersion }).(pulumi.StringPtrOutput)
}

// Output of the build.
func (o BuildProvenanceOutput) BuiltArtifacts() ArtifactArrayOutput {
	return o.ApplyT(func(v BuildProvenance) []Artifact { return v.BuiltArtifacts }).(ArtifactArrayOutput)
}

// Commands requested by the build.
func (o BuildProvenanceOutput) Commands() CommandArrayOutput {
	return o.ApplyT(func(v BuildProvenance) []Command { return v.Commands }).(CommandArrayOutput)
}

// Time at which the build was created.
func (o BuildProvenanceOutput) CreateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildProvenance) *string { return v.CreateTime }).(pulumi.StringPtrOutput)
}

// E-mail address of the user who initiated this build. Note that this was the user's e-mail address at the time the build was initiated; this address may not represent the same end-user for all time.
func (o BuildProvenanceOutput) Creator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildProvenance) *string { return v.Creator }).(pulumi.StringPtrOutput)
}

// Time at which execution of the build was finished.
func (o BuildProvenanceOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildProvenance) *string { return v.EndTime }).(pulumi.StringPtrOutput)
}

// Unique identifier of the build.
func (o BuildProvenanceOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v BuildProvenance) string { return v.Id }).(pulumi.StringOutput)
}

// URI where any logs for this provenance were written.
func (o BuildProvenanceOutput) LogsUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildProvenance) *string { return v.LogsUri }).(pulumi.StringPtrOutput)
}

// ID of the project.
func (o BuildProvenanceOutput) Project() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildProvenance) *string { return v.Project }).(pulumi.StringPtrOutput)
}

// Details of the Source input to the build.
func (o BuildProvenanceOutput) SourceProvenance() SourcePtrOutput {
	return o.ApplyT(func(v BuildProvenance) *Source { return v.SourceProvenance }).(SourcePtrOutput)
}

// Time at which execution of the build was started.
func (o BuildProvenanceOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildProvenance) *string { return v.StartTime }).(pulumi.StringPtrOutput)
}

// Trigger identifier if the build was triggered automatically; empty if not.
func (o BuildProvenanceOutput) TriggerId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildProvenance) *string { return v.TriggerId }).(pulumi.StringPtrOutput)
}

type BuildProvenancePtrOutput struct{ *pulumi.OutputState }

func (BuildProvenancePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildProvenance)(nil)).Elem()
}

func (o BuildProvenancePtrOutput) ToBuildProvenancePtrOutput() BuildProvenancePtrOutput {
	return o
}

func (o BuildProvenancePtrOutput) ToBuildProvenancePtrOutputWithContext(ctx context.Context) BuildProvenancePtrOutput {
	return o
}

func (o BuildProvenancePtrOutput) Elem() BuildProvenanceOutput {
	return o.ApplyT(func(v *BuildProvenance) BuildProvenance { return *v }).(BuildProvenanceOutput)
}

// Special options applied to this build. This is a catch-all field where build providers can enter any desired additional details.
func (o BuildProvenancePtrOutput) BuildOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *BuildProvenance) map[string]string {
		if v == nil {
			return nil
		}
		return v.BuildOptions
	}).(pulumi.StringMapOutput)
}

// Version string of the builder at the time this build was executed.
func (o BuildProvenancePtrOutput) BuilderVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenance) *string {
		if v == nil {
			return nil
		}
		return v.BuilderVersion
	}).(pulumi.StringPtrOutput)
}

// Output of the build.
func (o BuildProvenancePtrOutput) BuiltArtifacts() ArtifactArrayOutput {
	return o.ApplyT(func(v *BuildProvenance) []Artifact {
		if v == nil {
			return nil
		}
		return v.BuiltArtifacts
	}).(ArtifactArrayOutput)
}

// Commands requested by the build.
func (o BuildProvenancePtrOutput) Commands() CommandArrayOutput {
	return o.ApplyT(func(v *BuildProvenance) []Command {
		if v == nil {
			return nil
		}
		return v.Commands
	}).(CommandArrayOutput)
}

// Time at which the build was created.
func (o BuildProvenancePtrOutput) CreateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenance) *string {
		if v == nil {
			return nil
		}
		return v.CreateTime
	}).(pulumi.StringPtrOutput)
}

// E-mail address of the user who initiated this build. Note that this was the user's e-mail address at the time the build was initiated; this address may not represent the same end-user for all time.
func (o BuildProvenancePtrOutput) Creator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenance) *string {
		if v == nil {
			return nil
		}
		return v.Creator
	}).(pulumi.StringPtrOutput)
}

// Time at which execution of the build was finished.
func (o BuildProvenancePtrOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenance) *string {
		if v == nil {
			return nil
		}
		return v.EndTime
	}).(pulumi.StringPtrOutput)
}

// Unique identifier of the build.
func (o BuildProvenancePtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenance) *string {
		if v == nil {
			return nil
		}
		return &v.Id
	}).(pulumi.StringPtrOutput)
}

// URI where any logs for this provenance were written.
func (o BuildProvenancePtrOutput) LogsUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenance) *string {
		if v == nil {
			return nil
		}
		return v.LogsUri
	}).(pulumi.StringPtrOutput)
}

// ID of the project.
func (o BuildProvenancePtrOutput) Project() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenance) *string {
		if v == nil {
			return nil
		}
		return v.Project
	}).(pulumi.StringPtrOutput)
}

// Details of the Source input to the build.
func (o BuildProvenancePtrOutput) SourceProvenance() SourcePtrOutput {
	return o.ApplyT(func(v *BuildProvenance) *Source {
		if v == nil {
			return nil
		}
		return v.SourceProvenance
	}).(SourcePtrOutput)
}

// Time at which execution of the build was started.
func (o BuildProvenancePtrOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenance) *string {
		if v == nil {
			return nil
		}
		return v.StartTime
	}).(pulumi.StringPtrOutput)
}

// Trigger identifier if the build was triggered automatically; empty if not.
func (o BuildProvenancePtrOutput) TriggerId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenance) *string {
		if v == nil {
			return nil
		}
		return v.TriggerId
	}).(pulumi.StringPtrOutput)
}

// Provenance of a build. Contains all information needed to verify the full details about the build from source to completion.
type BuildProvenanceResponse struct {
	// Special options applied to this build. This is a catch-all field where build providers can enter any desired additional details.
	BuildOptions map[string]string `pulumi:"buildOptions"`
	// Version string of the builder at the time this build was executed.
	BuilderVersion string `pulumi:"builderVersion"`
	// Output of the build.
	BuiltArtifacts []ArtifactResponse `pulumi:"builtArtifacts"`
	// Commands requested by the build.
	Commands []CommandResponse `pulumi:"commands"`
	// Time at which the build was created.
	CreateTime string `pulumi:"createTime"`
	// E-mail address of the user who initiated this build. Note that this was the user's e-mail address at the time the build was initiated; this address may not represent the same end-user for all time.
	Creator string `pulumi:"creator"`
	// Time at which execution of the build was finished.
	EndTime string `pulumi:"endTime"`
	// URI where any logs for this provenance were written.
	LogsUri string `pulumi:"logsUri"`
	// ID of the project.
	Project string `pulumi:"project"`
	// Details of the Source input to the build.
	SourceProvenance SourceResponse `pulumi:"sourceProvenance"`
	// Time at which execution of the build was started.
	StartTime string `pulumi:"startTime"`
	// Trigger identifier if the build was triggered automatically; empty if not.
	TriggerId string `pulumi:"triggerId"`
}

// BuildProvenanceResponseInput is an input type that accepts BuildProvenanceResponseArgs and BuildProvenanceResponseOutput values.
// You can construct a concrete instance of `BuildProvenanceResponseInput` via:
//
//          BuildProvenanceResponseArgs{...}
type BuildProvenanceResponseInput interface {
	pulumi.Input

	ToBuildProvenanceResponseOutput() BuildProvenanceResponseOutput
	ToBuildProvenanceResponseOutputWithContext(context.Context) BuildProvenanceResponseOutput
}

// Provenance of a build. Contains all information needed to verify the full details about the build from source to completion.
type BuildProvenanceResponseArgs struct {
	// Special options applied to this build. This is a catch-all field where build providers can enter any desired additional details.
	BuildOptions pulumi.StringMapInput `pulumi:"buildOptions"`
	// Version string of the builder at the time this build was executed.
	BuilderVersion pulumi.StringInput `pulumi:"builderVersion"`
	// Output of the build.
	BuiltArtifacts ArtifactResponseArrayInput `pulumi:"builtArtifacts"`
	// Commands requested by the build.
	Commands CommandResponseArrayInput `pulumi:"commands"`
	// Time at which the build was created.
	CreateTime pulumi.StringInput `pulumi:"createTime"`
	// E-mail address of the user who initiated this build. Note that this was the user's e-mail address at the time the build was initiated; this address may not represent the same end-user for all time.
	Creator pulumi.StringInput `pulumi:"creator"`
	// Time at which execution of the build was finished.
	EndTime pulumi.StringInput `pulumi:"endTime"`
	// URI where any logs for this provenance were written.
	LogsUri pulumi.StringInput `pulumi:"logsUri"`
	// ID of the project.
	Project pulumi.StringInput `pulumi:"project"`
	// Details of the Source input to the build.
	SourceProvenance SourceResponseInput `pulumi:"sourceProvenance"`
	// Time at which execution of the build was started.
	StartTime pulumi.StringInput `pulumi:"startTime"`
	// Trigger identifier if the build was triggered automatically; empty if not.
	TriggerId pulumi.StringInput `pulumi:"triggerId"`
}

func (BuildProvenanceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildProvenanceResponse)(nil)).Elem()
}

func (i BuildProvenanceResponseArgs) ToBuildProvenanceResponseOutput() BuildProvenanceResponseOutput {
	return i.ToBuildProvenanceResponseOutputWithContext(context.Background())
}

func (i BuildProvenanceResponseArgs) ToBuildProvenanceResponseOutputWithContext(ctx context.Context) BuildProvenanceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildProvenanceResponseOutput)
}

func (i BuildProvenanceResponseArgs) ToBuildProvenanceResponsePtrOutput() BuildProvenanceResponsePtrOutput {
	return i.ToBuildProvenanceResponsePtrOutputWithContext(context.Background())
}

func (i BuildProvenanceResponseArgs) ToBuildProvenanceResponsePtrOutputWithContext(ctx context.Context) BuildProvenanceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildProvenanceResponseOutput).ToBuildProvenanceResponsePtrOutputWithContext(ctx)
}

// BuildProvenanceResponsePtrInput is an input type that accepts BuildProvenanceResponseArgs, BuildProvenanceResponsePtr and BuildProvenanceResponsePtrOutput values.
// You can construct a concrete instance of `BuildProvenanceResponsePtrInput` via:
//
//          BuildProvenanceResponseArgs{...}
//
//  or:
//
//          nil
type BuildProvenanceResponsePtrInput interface {
	pulumi.Input

	ToBuildProvenanceResponsePtrOutput() BuildProvenanceResponsePtrOutput
	ToBuildProvenanceResponsePtrOutputWithContext(context.Context) BuildProvenanceResponsePtrOutput
}

type buildProvenanceResponsePtrType BuildProvenanceResponseArgs

func BuildProvenanceResponsePtr(v *BuildProvenanceResponseArgs) BuildProvenanceResponsePtrInput {
	return (*buildProvenanceResponsePtrType)(v)
}

func (*buildProvenanceResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildProvenanceResponse)(nil)).Elem()
}

func (i *buildProvenanceResponsePtrType) ToBuildProvenanceResponsePtrOutput() BuildProvenanceResponsePtrOutput {
	return i.ToBuildProvenanceResponsePtrOutputWithContext(context.Background())
}

func (i *buildProvenanceResponsePtrType) ToBuildProvenanceResponsePtrOutputWithContext(ctx context.Context) BuildProvenanceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildProvenanceResponsePtrOutput)
}

// Provenance of a build. Contains all information needed to verify the full details about the build from source to completion.
type BuildProvenanceResponseOutput struct{ *pulumi.OutputState }

func (BuildProvenanceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildProvenanceResponse)(nil)).Elem()
}

func (o BuildProvenanceResponseOutput) ToBuildProvenanceResponseOutput() BuildProvenanceResponseOutput {
	return o
}

func (o BuildProvenanceResponseOutput) ToBuildProvenanceResponseOutputWithContext(ctx context.Context) BuildProvenanceResponseOutput {
	return o
}

func (o BuildProvenanceResponseOutput) ToBuildProvenanceResponsePtrOutput() BuildProvenanceResponsePtrOutput {
	return o.ToBuildProvenanceResponsePtrOutputWithContext(context.Background())
}

func (o BuildProvenanceResponseOutput) ToBuildProvenanceResponsePtrOutputWithContext(ctx context.Context) BuildProvenanceResponsePtrOutput {
	return o.ApplyT(func(v BuildProvenanceResponse) *BuildProvenanceResponse {
		return &v
	}).(BuildProvenanceResponsePtrOutput)
}

// Special options applied to this build. This is a catch-all field where build providers can enter any desired additional details.
func (o BuildProvenanceResponseOutput) BuildOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v BuildProvenanceResponse) map[string]string { return v.BuildOptions }).(pulumi.StringMapOutput)
}

// Version string of the builder at the time this build was executed.
func (o BuildProvenanceResponseOutput) BuilderVersion() pulumi.StringOutput {
	return o.ApplyT(func(v BuildProvenanceResponse) string { return v.BuilderVersion }).(pulumi.StringOutput)
}

// Output of the build.
func (o BuildProvenanceResponseOutput) BuiltArtifacts() ArtifactResponseArrayOutput {
	return o.ApplyT(func(v BuildProvenanceResponse) []ArtifactResponse { return v.BuiltArtifacts }).(ArtifactResponseArrayOutput)
}

// Commands requested by the build.
func (o BuildProvenanceResponseOutput) Commands() CommandResponseArrayOutput {
	return o.ApplyT(func(v BuildProvenanceResponse) []CommandResponse { return v.Commands }).(CommandResponseArrayOutput)
}

// Time at which the build was created.
func (o BuildProvenanceResponseOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v BuildProvenanceResponse) string { return v.CreateTime }).(pulumi.StringOutput)
}

// E-mail address of the user who initiated this build. Note that this was the user's e-mail address at the time the build was initiated; this address may not represent the same end-user for all time.
func (o BuildProvenanceResponseOutput) Creator() pulumi.StringOutput {
	return o.ApplyT(func(v BuildProvenanceResponse) string { return v.Creator }).(pulumi.StringOutput)
}

// Time at which execution of the build was finished.
func (o BuildProvenanceResponseOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v BuildProvenanceResponse) string { return v.EndTime }).(pulumi.StringOutput)
}

// URI where any logs for this provenance were written.
func (o BuildProvenanceResponseOutput) LogsUri() pulumi.StringOutput {
	return o.ApplyT(func(v BuildProvenanceResponse) string { return v.LogsUri }).(pulumi.StringOutput)
}

// ID of the project.
func (o BuildProvenanceResponseOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v BuildProvenanceResponse) string { return v.Project }).(pulumi.StringOutput)
}

// Details of the Source input to the build.
func (o BuildProvenanceResponseOutput) SourceProvenance() SourceResponseOutput {
	return o.ApplyT(func(v BuildProvenanceResponse) SourceResponse { return v.SourceProvenance }).(SourceResponseOutput)
}

// Time at which execution of the build was started.
func (o BuildProvenanceResponseOutput) StartTime() pulumi.StringOutput {
	return o.ApplyT(func(v BuildProvenanceResponse) string { return v.StartTime }).(pulumi.StringOutput)
}

// Trigger identifier if the build was triggered automatically; empty if not.
func (o BuildProvenanceResponseOutput) TriggerId() pulumi.StringOutput {
	return o.ApplyT(func(v BuildProvenanceResponse) string { return v.TriggerId }).(pulumi.StringOutput)
}

type BuildProvenanceResponsePtrOutput struct{ *pulumi.OutputState }

func (BuildProvenanceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildProvenanceResponse)(nil)).Elem()
}

func (o BuildProvenanceResponsePtrOutput) ToBuildProvenanceResponsePtrOutput() BuildProvenanceResponsePtrOutput {
	return o
}

func (o BuildProvenanceResponsePtrOutput) ToBuildProvenanceResponsePtrOutputWithContext(ctx context.Context) BuildProvenanceResponsePtrOutput {
	return o
}

func (o BuildProvenanceResponsePtrOutput) Elem() BuildProvenanceResponseOutput {
	return o.ApplyT(func(v *BuildProvenanceResponse) BuildProvenanceResponse { return *v }).(BuildProvenanceResponseOutput)
}

// Special options applied to this build. This is a catch-all field where build providers can enter any desired additional details.
func (o BuildProvenanceResponsePtrOutput) BuildOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *BuildProvenanceResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.BuildOptions
	}).(pulumi.StringMapOutput)
}

// Version string of the builder at the time this build was executed.
func (o BuildProvenanceResponsePtrOutput) BuilderVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenanceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.BuilderVersion
	}).(pulumi.StringPtrOutput)
}

// Output of the build.
func (o BuildProvenanceResponsePtrOutput) BuiltArtifacts() ArtifactResponseArrayOutput {
	return o.ApplyT(func(v *BuildProvenanceResponse) []ArtifactResponse {
		if v == nil {
			return nil
		}
		return v.BuiltArtifacts
	}).(ArtifactResponseArrayOutput)
}

// Commands requested by the build.
func (o BuildProvenanceResponsePtrOutput) Commands() CommandResponseArrayOutput {
	return o.ApplyT(func(v *BuildProvenanceResponse) []CommandResponse {
		if v == nil {
			return nil
		}
		return v.Commands
	}).(CommandResponseArrayOutput)
}

// Time at which the build was created.
func (o BuildProvenanceResponsePtrOutput) CreateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenanceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.CreateTime
	}).(pulumi.StringPtrOutput)
}

// E-mail address of the user who initiated this build. Note that this was the user's e-mail address at the time the build was initiated; this address may not represent the same end-user for all time.
func (o BuildProvenanceResponsePtrOutput) Creator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenanceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Creator
	}).(pulumi.StringPtrOutput)
}

// Time at which execution of the build was finished.
func (o BuildProvenanceResponsePtrOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenanceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.EndTime
	}).(pulumi.StringPtrOutput)
}

// URI where any logs for this provenance were written.
func (o BuildProvenanceResponsePtrOutput) LogsUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenanceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.LogsUri
	}).(pulumi.StringPtrOutput)
}

// ID of the project.
func (o BuildProvenanceResponsePtrOutput) Project() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenanceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Project
	}).(pulumi.StringPtrOutput)
}

// Details of the Source input to the build.
func (o BuildProvenanceResponsePtrOutput) SourceProvenance() SourceResponsePtrOutput {
	return o.ApplyT(func(v *BuildProvenanceResponse) *SourceResponse {
		if v == nil {
			return nil
		}
		return &v.SourceProvenance
	}).(SourceResponsePtrOutput)
}

// Time at which execution of the build was started.
func (o BuildProvenanceResponsePtrOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenanceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.StartTime
	}).(pulumi.StringPtrOutput)
}

// Trigger identifier if the build was triggered automatically; empty if not.
func (o BuildProvenanceResponsePtrOutput) TriggerId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildProvenanceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.TriggerId
	}).(pulumi.StringPtrOutput)
}

// Note holding the version of the provider's builder and the signature of the provenance message in the build details occurrence.
type BuildResponse struct {
	// Immutable. Version of the builder which produced this build.
	BuilderVersion string `pulumi:"builderVersion"`
	// Signature of the build in occurrences pointing to this build note containing build details.
	Signature BuildSignatureResponse `pulumi:"signature"`
}

// BuildResponseInput is an input type that accepts BuildResponseArgs and BuildResponseOutput values.
// You can construct a concrete instance of `BuildResponseInput` via:
//
//          BuildResponseArgs{...}
type BuildResponseInput interface {
	pulumi.Input

	ToBuildResponseOutput() BuildResponseOutput
	ToBuildResponseOutputWithContext(context.Context) BuildResponseOutput
}

// Note holding the version of the provider's builder and the signature of the provenance message in the build details occurrence.
type BuildResponseArgs struct {
	// Immutable. Version of the builder which produced this build.
	BuilderVersion pulumi.StringInput `pulumi:"builderVersion"`
	// Signature of the build in occurrences pointing to this build note containing build details.
	Signature BuildSignatureResponseInput `pulumi:"signature"`
}

func (BuildResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildResponse)(nil)).Elem()
}

func (i BuildResponseArgs) ToBuildResponseOutput() BuildResponseOutput {
	return i.ToBuildResponseOutputWithContext(context.Background())
}

func (i BuildResponseArgs) ToBuildResponseOutputWithContext(ctx context.Context) BuildResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildResponseOutput)
}

func (i BuildResponseArgs) ToBuildResponsePtrOutput() BuildResponsePtrOutput {
	return i.ToBuildResponsePtrOutputWithContext(context.Background())
}

func (i BuildResponseArgs) ToBuildResponsePtrOutputWithContext(ctx context.Context) BuildResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildResponseOutput).ToBuildResponsePtrOutputWithContext(ctx)
}

// BuildResponsePtrInput is an input type that accepts BuildResponseArgs, BuildResponsePtr and BuildResponsePtrOutput values.
// You can construct a concrete instance of `BuildResponsePtrInput` via:
//
//          BuildResponseArgs{...}
//
//  or:
//
//          nil
type BuildResponsePtrInput interface {
	pulumi.Input

	ToBuildResponsePtrOutput() BuildResponsePtrOutput
	ToBuildResponsePtrOutputWithContext(context.Context) BuildResponsePtrOutput
}

type buildResponsePtrType BuildResponseArgs

func BuildResponsePtr(v *BuildResponseArgs) BuildResponsePtrInput {
	return (*buildResponsePtrType)(v)
}

func (*buildResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildResponse)(nil)).Elem()
}

func (i *buildResponsePtrType) ToBuildResponsePtrOutput() BuildResponsePtrOutput {
	return i.ToBuildResponsePtrOutputWithContext(context.Background())
}

func (i *buildResponsePtrType) ToBuildResponsePtrOutputWithContext(ctx context.Context) BuildResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildResponsePtrOutput)
}

// Note holding the version of the provider's builder and the signature of the provenance message in the build details occurrence.
type BuildResponseOutput struct{ *pulumi.OutputState }

func (BuildResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildResponse)(nil)).Elem()
}

func (o BuildResponseOutput) ToBuildResponseOutput() BuildResponseOutput {
	return o
}

func (o BuildResponseOutput) ToBuildResponseOutputWithContext(ctx context.Context) BuildResponseOutput {
	return o
}

func (o BuildResponseOutput) ToBuildResponsePtrOutput() BuildResponsePtrOutput {
	return o.ToBuildResponsePtrOutputWithContext(context.Background())
}

func (o BuildResponseOutput) ToBuildResponsePtrOutputWithContext(ctx context.Context) BuildResponsePtrOutput {
	return o.ApplyT(func(v BuildResponse) *BuildResponse {
		return &v
	}).(BuildResponsePtrOutput)
}

// Immutable. Version of the builder which produced this build.
func (o BuildResponseOutput) BuilderVersion() pulumi.StringOutput {
	return o.ApplyT(func(v BuildResponse) string { return v.BuilderVersion }).(pulumi.StringOutput)
}

// Signature of the build in occurrences pointing to this build note containing build details.
func (o BuildResponseOutput) Signature() BuildSignatureResponseOutput {
	return o.ApplyT(func(v BuildResponse) BuildSignatureResponse { return v.Signature }).(BuildSignatureResponseOutput)
}

type BuildResponsePtrOutput struct{ *pulumi.OutputState }

func (BuildResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildResponse)(nil)).Elem()
}

func (o BuildResponsePtrOutput) ToBuildResponsePtrOutput() BuildResponsePtrOutput {
	return o
}

func (o BuildResponsePtrOutput) ToBuildResponsePtrOutputWithContext(ctx context.Context) BuildResponsePtrOutput {
	return o
}

func (o BuildResponsePtrOutput) Elem() BuildResponseOutput {
	return o.ApplyT(func(v *BuildResponse) BuildResponse { return *v }).(BuildResponseOutput)
}

// Immutable. Version of the builder which produced this build.
func (o BuildResponsePtrOutput) BuilderVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildResponse) *string {
		if v == nil {
			return nil
		}
		return &v.BuilderVersion
	}).(pulumi.StringPtrOutput)
}

// Signature of the build in occurrences pointing to this build note containing build details.
func (o BuildResponsePtrOutput) Signature() BuildSignatureResponsePtrOutput {
	return o.ApplyT(func(v *BuildResponse) *BuildSignatureResponse {
		if v == nil {
			return nil
		}
		return &v.Signature
	}).(BuildSignatureResponsePtrOutput)
}

// Message encapsulating the signature of the verified build.
type BuildSignature struct {
	// An ID for the key used to sign. This could be either an ID for the key stored in `public_key` (such as the ID or fingerprint for a PGP key, or the CN for a cert), or a reference to an external key (such as a reference to a key in Cloud Key Management Service).
	KeyId *string `pulumi:"keyId"`
	// The type of the key, either stored in `public_key` or referenced in `key_id`.
	KeyType *BuildSignatureKeyType `pulumi:"keyType"`
	// Public key of the builder which can be used to verify that the related findings are valid and unchanged. If `key_type` is empty, this defaults to PEM encoded public keys. This field may be empty if `key_id` references an external key. For Cloud Build based signatures, this is a PEM encoded public key. To verify the Cloud Build signature, place the contents of this field into a file (public.pem). The signature field is base64-decoded into its binary representation in signature.bin, and the provenance bytes from `BuildDetails` are base64-decoded into a binary representation in signed.bin. OpenSSL can then verify the signature: `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
	PublicKey *string `pulumi:"publicKey"`
	// Signature of the related `BuildProvenance`. In JSON, this is base-64 encoded.
	Signature string `pulumi:"signature"`
}

// BuildSignatureInput is an input type that accepts BuildSignatureArgs and BuildSignatureOutput values.
// You can construct a concrete instance of `BuildSignatureInput` via:
//
//          BuildSignatureArgs{...}
type BuildSignatureInput interface {
	pulumi.Input

	ToBuildSignatureOutput() BuildSignatureOutput
	ToBuildSignatureOutputWithContext(context.Context) BuildSignatureOutput
}

// Message encapsulating the signature of the verified build.
type BuildSignatureArgs struct {
	// An ID for the key used to sign. This could be either an ID for the key stored in `public_key` (such as the ID or fingerprint for a PGP key, or the CN for a cert), or a reference to an external key (such as a reference to a key in Cloud Key Management Service).
	KeyId pulumi.StringPtrInput `pulumi:"keyId"`
	// The type of the key, either stored in `public_key` or referenced in `key_id`.
	KeyType BuildSignatureKeyTypePtrInput `pulumi:"keyType"`
	// Public key of the builder which can be used to verify that the related findings are valid and unchanged. If `key_type` is empty, this defaults to PEM encoded public keys. This field may be empty if `key_id` references an external key. For Cloud Build based signatures, this is a PEM encoded public key. To verify the Cloud Build signature, place the contents of this field into a file (public.pem). The signature field is base64-decoded into its binary representation in signature.bin, and the provenance bytes from `BuildDetails` are base64-decoded into a binary representation in signed.bin. OpenSSL can then verify the signature: `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
	PublicKey pulumi.StringPtrInput `pulumi:"publicKey"`
	// Signature of the related `BuildProvenance`. In JSON, this is base-64 encoded.
	Signature pulumi.StringInput `pulumi:"signature"`
}

func (BuildSignatureArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildSignature)(nil)).Elem()
}

func (i BuildSignatureArgs) ToBuildSignatureOutput() BuildSignatureOutput {
	return i.ToBuildSignatureOutputWithContext(context.Background())
}

func (i BuildSignatureArgs) ToBuildSignatureOutputWithContext(ctx context.Context) BuildSignatureOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildSignatureOutput)
}

func (i BuildSignatureArgs) ToBuildSignaturePtrOutput() BuildSignaturePtrOutput {
	return i.ToBuildSignaturePtrOutputWithContext(context.Background())
}

func (i BuildSignatureArgs) ToBuildSignaturePtrOutputWithContext(ctx context.Context) BuildSignaturePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildSignatureOutput).ToBuildSignaturePtrOutputWithContext(ctx)
}

// BuildSignaturePtrInput is an input type that accepts BuildSignatureArgs, BuildSignaturePtr and BuildSignaturePtrOutput values.
// You can construct a concrete instance of `BuildSignaturePtrInput` via:
//
//          BuildSignatureArgs{...}
//
//  or:
//
//          nil
type BuildSignaturePtrInput interface {
	pulumi.Input

	ToBuildSignaturePtrOutput() BuildSignaturePtrOutput
	ToBuildSignaturePtrOutputWithContext(context.Context) BuildSignaturePtrOutput
}

type buildSignaturePtrType BuildSignatureArgs

func BuildSignaturePtr(v *BuildSignatureArgs) BuildSignaturePtrInput {
	return (*buildSignaturePtrType)(v)
}

func (*buildSignaturePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildSignature)(nil)).Elem()
}

func (i *buildSignaturePtrType) ToBuildSignaturePtrOutput() BuildSignaturePtrOutput {
	return i.ToBuildSignaturePtrOutputWithContext(context.Background())
}

func (i *buildSignaturePtrType) ToBuildSignaturePtrOutputWithContext(ctx context.Context) BuildSignaturePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildSignaturePtrOutput)
}

// Message encapsulating the signature of the verified build.
type BuildSignatureOutput struct{ *pulumi.OutputState }

func (BuildSignatureOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildSignature)(nil)).Elem()
}

func (o BuildSignatureOutput) ToBuildSignatureOutput() BuildSignatureOutput {
	return o
}

func (o BuildSignatureOutput) ToBuildSignatureOutputWithContext(ctx context.Context) BuildSignatureOutput {
	return o
}

func (o BuildSignatureOutput) ToBuildSignaturePtrOutput() BuildSignaturePtrOutput {
	return o.ToBuildSignaturePtrOutputWithContext(context.Background())
}

func (o BuildSignatureOutput) ToBuildSignaturePtrOutputWithContext(ctx context.Context) BuildSignaturePtrOutput {
	return o.ApplyT(func(v BuildSignature) *BuildSignature {
		return &v
	}).(BuildSignaturePtrOutput)
}

// An ID for the key used to sign. This could be either an ID for the key stored in `public_key` (such as the ID or fingerprint for a PGP key, or the CN for a cert), or a reference to an external key (such as a reference to a key in Cloud Key Management Service).
func (o BuildSignatureOutput) KeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildSignature) *string { return v.KeyId }).(pulumi.StringPtrOutput)
}

// The type of the key, either stored in `public_key` or referenced in `key_id`.
func (o BuildSignatureOutput) KeyType() BuildSignatureKeyTypePtrOutput {
	return o.ApplyT(func(v BuildSignature) *BuildSignatureKeyType { return v.KeyType }).(BuildSignatureKeyTypePtrOutput)
}

// Public key of the builder which can be used to verify that the related findings are valid and unchanged. If `key_type` is empty, this defaults to PEM encoded public keys. This field may be empty if `key_id` references an external key. For Cloud Build based signatures, this is a PEM encoded public key. To verify the Cloud Build signature, place the contents of this field into a file (public.pem). The signature field is base64-decoded into its binary representation in signature.bin, and the provenance bytes from `BuildDetails` are base64-decoded into a binary representation in signed.bin. OpenSSL can then verify the signature: `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
func (o BuildSignatureOutput) PublicKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildSignature) *string { return v.PublicKey }).(pulumi.StringPtrOutput)
}

// Signature of the related `BuildProvenance`. In JSON, this is base-64 encoded.
func (o BuildSignatureOutput) Signature() pulumi.StringOutput {
	return o.ApplyT(func(v BuildSignature) string { return v.Signature }).(pulumi.StringOutput)
}

type BuildSignaturePtrOutput struct{ *pulumi.OutputState }

func (BuildSignaturePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildSignature)(nil)).Elem()
}

func (o BuildSignaturePtrOutput) ToBuildSignaturePtrOutput() BuildSignaturePtrOutput {
	return o
}

func (o BuildSignaturePtrOutput) ToBuildSignaturePtrOutputWithContext(ctx context.Context) BuildSignaturePtrOutput {
	return o
}

func (o BuildSignaturePtrOutput) Elem() BuildSignatureOutput {
	return o.ApplyT(func(v *BuildSignature) BuildSignature { return *v }).(BuildSignatureOutput)
}

// An ID for the key used to sign. This could be either an ID for the key stored in `public_key` (such as the ID or fingerprint for a PGP key, or the CN for a cert), or a reference to an external key (such as a reference to a key in Cloud Key Management Service).
func (o BuildSignaturePtrOutput) KeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildSignature) *string {
		if v == nil {
			return nil
		}
		return v.KeyId
	}).(pulumi.StringPtrOutput)
}

// The type of the key, either stored in `public_key` or referenced in `key_id`.
func (o BuildSignaturePtrOutput) KeyType() BuildSignatureKeyTypePtrOutput {
	return o.ApplyT(func(v *BuildSignature) *BuildSignatureKeyType {
		if v == nil {
			return nil
		}
		return v.KeyType
	}).(BuildSignatureKeyTypePtrOutput)
}

// Public key of the builder which can be used to verify that the related findings are valid and unchanged. If `key_type` is empty, this defaults to PEM encoded public keys. This field may be empty if `key_id` references an external key. For Cloud Build based signatures, this is a PEM encoded public key. To verify the Cloud Build signature, place the contents of this field into a file (public.pem). The signature field is base64-decoded into its binary representation in signature.bin, and the provenance bytes from `BuildDetails` are base64-decoded into a binary representation in signed.bin. OpenSSL can then verify the signature: `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
func (o BuildSignaturePtrOutput) PublicKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildSignature) *string {
		if v == nil {
			return nil
		}
		return v.PublicKey
	}).(pulumi.StringPtrOutput)
}

// Signature of the related `BuildProvenance`. In JSON, this is base-64 encoded.
func (o BuildSignaturePtrOutput) Signature() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildSignature) *string {
		if v == nil {
			return nil
		}
		return &v.Signature
	}).(pulumi.StringPtrOutput)
}

// Message encapsulating the signature of the verified build.
type BuildSignatureResponse struct {
	// An ID for the key used to sign. This could be either an ID for the key stored in `public_key` (such as the ID or fingerprint for a PGP key, or the CN for a cert), or a reference to an external key (such as a reference to a key in Cloud Key Management Service).
	KeyId string `pulumi:"keyId"`
	// The type of the key, either stored in `public_key` or referenced in `key_id`.
	KeyType string `pulumi:"keyType"`
	// Public key of the builder which can be used to verify that the related findings are valid and unchanged. If `key_type` is empty, this defaults to PEM encoded public keys. This field may be empty if `key_id` references an external key. For Cloud Build based signatures, this is a PEM encoded public key. To verify the Cloud Build signature, place the contents of this field into a file (public.pem). The signature field is base64-decoded into its binary representation in signature.bin, and the provenance bytes from `BuildDetails` are base64-decoded into a binary representation in signed.bin. OpenSSL can then verify the signature: `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
	PublicKey string `pulumi:"publicKey"`
	// Signature of the related `BuildProvenance`. In JSON, this is base-64 encoded.
	Signature string `pulumi:"signature"`
}

// BuildSignatureResponseInput is an input type that accepts BuildSignatureResponseArgs and BuildSignatureResponseOutput values.
// You can construct a concrete instance of `BuildSignatureResponseInput` via:
//
//          BuildSignatureResponseArgs{...}
type BuildSignatureResponseInput interface {
	pulumi.Input

	ToBuildSignatureResponseOutput() BuildSignatureResponseOutput
	ToBuildSignatureResponseOutputWithContext(context.Context) BuildSignatureResponseOutput
}

// Message encapsulating the signature of the verified build.
type BuildSignatureResponseArgs struct {
	// An ID for the key used to sign. This could be either an ID for the key stored in `public_key` (such as the ID or fingerprint for a PGP key, or the CN for a cert), or a reference to an external key (such as a reference to a key in Cloud Key Management Service).
	KeyId pulumi.StringInput `pulumi:"keyId"`
	// The type of the key, either stored in `public_key` or referenced in `key_id`.
	KeyType pulumi.StringInput `pulumi:"keyType"`
	// Public key of the builder which can be used to verify that the related findings are valid and unchanged. If `key_type` is empty, this defaults to PEM encoded public keys. This field may be empty if `key_id` references an external key. For Cloud Build based signatures, this is a PEM encoded public key. To verify the Cloud Build signature, place the contents of this field into a file (public.pem). The signature field is base64-decoded into its binary representation in signature.bin, and the provenance bytes from `BuildDetails` are base64-decoded into a binary representation in signed.bin. OpenSSL can then verify the signature: `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
	PublicKey pulumi.StringInput `pulumi:"publicKey"`
	// Signature of the related `BuildProvenance`. In JSON, this is base-64 encoded.
	Signature pulumi.StringInput `pulumi:"signature"`
}

func (BuildSignatureResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildSignatureResponse)(nil)).Elem()
}

func (i BuildSignatureResponseArgs) ToBuildSignatureResponseOutput() BuildSignatureResponseOutput {
	return i.ToBuildSignatureResponseOutputWithContext(context.Background())
}

func (i BuildSignatureResponseArgs) ToBuildSignatureResponseOutputWithContext(ctx context.Context) BuildSignatureResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildSignatureResponseOutput)
}

func (i BuildSignatureResponseArgs) ToBuildSignatureResponsePtrOutput() BuildSignatureResponsePtrOutput {
	return i.ToBuildSignatureResponsePtrOutputWithContext(context.Background())
}

func (i BuildSignatureResponseArgs) ToBuildSignatureResponsePtrOutputWithContext(ctx context.Context) BuildSignatureResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildSignatureResponseOutput).ToBuildSignatureResponsePtrOutputWithContext(ctx)
}

// BuildSignatureResponsePtrInput is an input type that accepts BuildSignatureResponseArgs, BuildSignatureResponsePtr and BuildSignatureResponsePtrOutput values.
// You can construct a concrete instance of `BuildSignatureResponsePtrInput` via:
//
//          BuildSignatureResponseArgs{...}
//
//  or:
//
//          nil
type BuildSignatureResponsePtrInput interface {
	pulumi.Input

	ToBuildSignatureResponsePtrOutput() BuildSignatureResponsePtrOutput
	ToBuildSignatureResponsePtrOutputWithContext(context.Context) BuildSignatureResponsePtrOutput
}

type buildSignatureResponsePtrType BuildSignatureResponseArgs

func BuildSignatureResponsePtr(v *BuildSignatureResponseArgs) BuildSignatureResponsePtrInput {
	return (*buildSignatureResponsePtrType)(v)
}

func (*buildSignatureResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildSignatureResponse)(nil)).Elem()
}

func (i *buildSignatureResponsePtrType) ToBuildSignatureResponsePtrOutput() BuildSignatureResponsePtrOutput {
	return i.ToBuildSignatureResponsePtrOutputWithContext(context.Background())
}

func (i *buildSignatureResponsePtrType) ToBuildSignatureResponsePtrOutputWithContext(ctx context.Context) BuildSignatureResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildSignatureResponsePtrOutput)
}

// Message encapsulating the signature of the verified build.
type BuildSignatureResponseOutput struct{ *pulumi.OutputState }

func (BuildSignatureResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildSignatureResponse)(nil)).Elem()
}

func (o BuildSignatureResponseOutput) ToBuildSignatureResponseOutput() BuildSignatureResponseOutput {
	return o
}

func (o BuildSignatureResponseOutput) ToBuildSignatureResponseOutputWithContext(ctx context.Context) BuildSignatureResponseOutput {
	return o
}

func (o BuildSignatureResponseOutput) ToBuildSignatureResponsePtrOutput() BuildSignatureResponsePtrOutput {
	return o.ToBuildSignatureResponsePtrOutputWithContext(context.Background())
}

func (o BuildSignatureResponseOutput) ToBuildSignatureResponsePtrOutputWithContext(ctx context.Context) BuildSignatureResponsePtrOutput {
	return o.ApplyT(func(v BuildSignatureResponse) *BuildSignatureResponse {
		return &v
	}).(BuildSignatureResponsePtrOutput)
}

// An ID for the key used to sign. This could be either an ID for the key stored in `public_key` (such as the ID or fingerprint for a PGP key, or the CN for a cert), or a reference to an external key (such as a reference to a key in Cloud Key Management Service).
func (o BuildSignatureResponseOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v BuildSignatureResponse) string { return v.KeyId }).(pulumi.StringOutput)
}

// The type of the key, either stored in `public_key` or referenced in `key_id`.
func (o BuildSignatureResponseOutput) KeyType() pulumi.StringOutput {
	return o.ApplyT(func(v BuildSignatureResponse) string { return v.KeyType }).(pulumi.StringOutput)
}

// Public key of the builder which can be used to verify that the related findings are valid and unchanged. If `key_type` is empty, this defaults to PEM encoded public keys. This field may be empty if `key_id` references an external key. For Cloud Build based signatures, this is a PEM encoded public key. To verify the Cloud Build signature, place the contents of this field into a file (public.pem). The signature field is base64-decoded into its binary representation in signature.bin, and the provenance bytes from `BuildDetails` are base64-decoded into a binary representation in signed.bin. OpenSSL can then verify the signature: `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
func (o BuildSignatureResponseOutput) PublicKey() pulumi.StringOutput {
	return o.ApplyT(func(v BuildSignatureResponse) string { return v.PublicKey }).(pulumi.StringOutput)
}

// Signature of the related `BuildProvenance`. In JSON, this is base-64 encoded.
func (o BuildSignatureResponseOutput) Signature() pulumi.StringOutput {
	return o.ApplyT(func(v BuildSignatureResponse) string { return v.Signature }).(pulumi.StringOutput)
}

type BuildSignatureResponsePtrOutput struct{ *pulumi.OutputState }

func (BuildSignatureResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildSignatureResponse)(nil)).Elem()
}

func (o BuildSignatureResponsePtrOutput) ToBuildSignatureResponsePtrOutput() BuildSignatureResponsePtrOutput {
	return o
}

func (o BuildSignatureResponsePtrOutput) ToBuildSignatureResponsePtrOutputWithContext(ctx context.Context) BuildSignatureResponsePtrOutput {
	return o
}

func (o BuildSignatureResponsePtrOutput) Elem() BuildSignatureResponseOutput {
	return o.ApplyT(func(v *BuildSignatureResponse) BuildSignatureResponse { return *v }).(BuildSignatureResponseOutput)
}

// An ID for the key used to sign. This could be either an ID for the key stored in `public_key` (such as the ID or fingerprint for a PGP key, or the CN for a cert), or a reference to an external key (such as a reference to a key in Cloud Key Management Service).
func (o BuildSignatureResponsePtrOutput) KeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildSignatureResponse) *string {
		if v == nil {
			return nil
		}
		return &v.KeyId
	}).(pulumi.StringPtrOutput)
}

// The type of the key, either stored in `public_key` or referenced in `key_id`.
func (o BuildSignatureResponsePtrOutput) KeyType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildSignatureResponse) *string {
		if v == nil {
			return nil
		}
		return &v.KeyType
	}).(pulumi.StringPtrOutput)
}

// Public key of the builder which can be used to verify that the related findings are valid and unchanged. If `key_type` is empty, this defaults to PEM encoded public keys. This field may be empty if `key_id` references an external key. For Cloud Build based signatures, this is a PEM encoded public key. To verify the Cloud Build signature, place the contents of this field into a file (public.pem). The signature field is base64-decoded into its binary representation in signature.bin, and the provenance bytes from `BuildDetails` are base64-decoded into a binary representation in signed.bin. OpenSSL can then verify the signature: `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
func (o BuildSignatureResponsePtrOutput) PublicKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildSignatureResponse) *string {
		if v == nil {
			return nil
		}
		return &v.PublicKey
	}).(pulumi.StringPtrOutput)
}

// Signature of the related `BuildProvenance`. In JSON, this is base-64 encoded.
func (o BuildSignatureResponsePtrOutput) Signature() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildSignatureResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Signature
	}).(pulumi.StringPtrOutput)
}

// Defines an object for the byproducts field in in-toto links. The suggested fields are "stderr", "stdout", and "return-value".
type ByProducts struct {
	CustomValues map[string]string `pulumi:"customValues"`
}

// ByProductsInput is an input type that accepts ByProductsArgs and ByProductsOutput values.
// You can construct a concrete instance of `ByProductsInput` via:
//
//          ByProductsArgs{...}
type ByProductsInput interface {
	pulumi.Input

	ToByProductsOutput() ByProductsOutput
	ToByProductsOutputWithContext(context.Context) ByProductsOutput
}

// Defines an object for the byproducts field in in-toto links. The suggested fields are "stderr", "stdout", and "return-value".
type ByProductsArgs struct {
	CustomValues pulumi.StringMapInput `pulumi:"customValues"`
}

func (ByProductsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ByProducts)(nil)).Elem()
}

func (i ByProductsArgs) ToByProductsOutput() ByProductsOutput {
	return i.ToByProductsOutputWithContext(context.Background())
}

func (i ByProductsArgs) ToByProductsOutputWithContext(ctx context.Context) ByProductsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ByProductsOutput)
}

func (i ByProductsArgs) ToByProductsPtrOutput() ByProductsPtrOutput {
	return i.ToByProductsPtrOutputWithContext(context.Background())
}

func (i ByProductsArgs) ToByProductsPtrOutputWithContext(ctx context.Context) ByProductsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ByProductsOutput).ToByProductsPtrOutputWithContext(ctx)
}

// ByProductsPtrInput is an input type that accepts ByProductsArgs, ByProductsPtr and ByProductsPtrOutput values.
// You can construct a concrete instance of `ByProductsPtrInput` via:
//
//          ByProductsArgs{...}
//
//  or:
//
//          nil
type ByProductsPtrInput interface {
	pulumi.Input

	ToByProductsPtrOutput() ByProductsPtrOutput
	ToByProductsPtrOutputWithContext(context.Context) ByProductsPtrOutput
}

type byProductsPtrType ByProductsArgs

func ByProductsPtr(v *ByProductsArgs) ByProductsPtrInput {
	return (*byProductsPtrType)(v)
}

func (*byProductsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ByProducts)(nil)).Elem()
}

func (i *byProductsPtrType) ToByProductsPtrOutput() ByProductsPtrOutput {
	return i.ToByProductsPtrOutputWithContext(context.Background())
}

func (i *byProductsPtrType) ToByProductsPtrOutputWithContext(ctx context.Context) ByProductsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ByProductsPtrOutput)
}

// Defines an object for the byproducts field in in-toto links. The suggested fields are "stderr", "stdout", and "return-value".
type ByProductsOutput struct{ *pulumi.OutputState }

func (ByProductsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ByProducts)(nil)).Elem()
}

func (o ByProductsOutput) ToByProductsOutput() ByProductsOutput {
	return o
}

func (o ByProductsOutput) ToByProductsOutputWithContext(ctx context.Context) ByProductsOutput {
	return o
}

func (o ByProductsOutput) ToByProductsPtrOutput() ByProductsPtrOutput {
	return o.ToByProductsPtrOutputWithContext(context.Background())
}

func (o ByProductsOutput) ToByProductsPtrOutputWithContext(ctx context.Context) ByProductsPtrOutput {
	return o.ApplyT(func(v ByProducts) *ByProducts {
		return &v
	}).(ByProductsPtrOutput)
}
func (o ByProductsOutput) CustomValues() pulumi.StringMapOutput {
	return o.ApplyT(func(v ByProducts) map[string]string { return v.CustomValues }).(pulumi.StringMapOutput)
}

type ByProductsPtrOutput struct{ *pulumi.OutputState }

func (ByProductsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ByProducts)(nil)).Elem()
}

func (o ByProductsPtrOutput) ToByProductsPtrOutput() ByProductsPtrOutput {
	return o
}

func (o ByProductsPtrOutput) ToByProductsPtrOutputWithContext(ctx context.Context) ByProductsPtrOutput {
	return o
}

func (o ByProductsPtrOutput) Elem() ByProductsOutput {
	return o.ApplyT(func(v *ByProducts) ByProducts { return *v }).(ByProductsOutput)
}

func (o ByProductsPtrOutput) CustomValues() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ByProducts) map[string]string {
		if v == nil {
			return nil
		}
		return v.CustomValues
	}).(pulumi.StringMapOutput)
}

// Defines an object for the byproducts field in in-toto links. The suggested fields are "stderr", "stdout", and "return-value".
type ByProductsResponse struct {
	CustomValues map[string]string `pulumi:"customValues"`
}

// ByProductsResponseInput is an input type that accepts ByProductsResponseArgs and ByProductsResponseOutput values.
// You can construct a concrete instance of `ByProductsResponseInput` via:
//
//          ByProductsResponseArgs{...}
type ByProductsResponseInput interface {
	pulumi.Input

	ToByProductsResponseOutput() ByProductsResponseOutput
	ToByProductsResponseOutputWithContext(context.Context) ByProductsResponseOutput
}

// Defines an object for the byproducts field in in-toto links. The suggested fields are "stderr", "stdout", and "return-value".
type ByProductsResponseArgs struct {
	CustomValues pulumi.StringMapInput `pulumi:"customValues"`
}

func (ByProductsResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ByProductsResponse)(nil)).Elem()
}

func (i ByProductsResponseArgs) ToByProductsResponseOutput() ByProductsResponseOutput {
	return i.ToByProductsResponseOutputWithContext(context.Background())
}

func (i ByProductsResponseArgs) ToByProductsResponseOutputWithContext(ctx context.Context) ByProductsResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ByProductsResponseOutput)
}

func (i ByProductsResponseArgs) ToByProductsResponsePtrOutput() ByProductsResponsePtrOutput {
	return i.ToByProductsResponsePtrOutputWithContext(context.Background())
}

func (i ByProductsResponseArgs) ToByProductsResponsePtrOutputWithContext(ctx context.Context) ByProductsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ByProductsResponseOutput).ToByProductsResponsePtrOutputWithContext(ctx)
}

// ByProductsResponsePtrInput is an input type that accepts ByProductsResponseArgs, ByProductsResponsePtr and ByProductsResponsePtrOutput values.
// You can construct a concrete instance of `ByProductsResponsePtrInput` via:
//
//          ByProductsResponseArgs{...}
//
//  or:
//
//          nil
type ByProductsResponsePtrInput interface {
	pulumi.Input

	ToByProductsResponsePtrOutput() ByProductsResponsePtrOutput
	ToByProductsResponsePtrOutputWithContext(context.Context) ByProductsResponsePtrOutput
}

type byProductsResponsePtrType ByProductsResponseArgs

func ByProductsResponsePtr(v *ByProductsResponseArgs) ByProductsResponsePtrInput {
	return (*byProductsResponsePtrType)(v)
}

func (*byProductsResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ByProductsResponse)(nil)).Elem()
}

func (i *byProductsResponsePtrType) ToByProductsResponsePtrOutput() ByProductsResponsePtrOutput {
	return i.ToByProductsResponsePtrOutputWithContext(context.Background())
}

func (i *byProductsResponsePtrType) ToByProductsResponsePtrOutputWithContext(ctx context.Context) ByProductsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ByProductsResponsePtrOutput)
}

// Defines an object for the byproducts field in in-toto links. The suggested fields are "stderr", "stdout", and "return-value".
type ByProductsResponseOutput struct{ *pulumi.OutputState }

func (ByProductsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ByProductsResponse)(nil)).Elem()
}

func (o ByProductsResponseOutput) ToByProductsResponseOutput() ByProductsResponseOutput {
	return o
}

func (o ByProductsResponseOutput) ToByProductsResponseOutputWithContext(ctx context.Context) ByProductsResponseOutput {
	return o
}

func (o ByProductsResponseOutput) ToByProductsResponsePtrOutput() ByProductsResponsePtrOutput {
	return o.ToByProductsResponsePtrOutputWithContext(context.Background())
}

func (o ByProductsResponseOutput) ToByProductsResponsePtrOutputWithContext(ctx context.Context) ByProductsResponsePtrOutput {
	return o.ApplyT(func(v ByProductsResponse) *ByProductsResponse {
		return &v
	}).(ByProductsResponsePtrOutput)
}
func (o ByProductsResponseOutput) CustomValues() pulumi.StringMapOutput {
	return o.ApplyT(func(v ByProductsResponse) map[string]string { return v.CustomValues }).(pulumi.StringMapOutput)
}

type ByProductsResponsePtrOutput struct{ *pulumi.OutputState }

func (ByProductsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ByProductsResponse)(nil)).Elem()
}

func (o ByProductsResponsePtrOutput) ToByProductsResponsePtrOutput() ByProductsResponsePtrOutput {
	return o
}

func (o ByProductsResponsePtrOutput) ToByProductsResponsePtrOutputWithContext(ctx context.Context) ByProductsResponsePtrOutput {
	return o
}

func (o ByProductsResponsePtrOutput) Elem() ByProductsResponseOutput {
	return o.ApplyT(func(v *ByProductsResponse) ByProductsResponse { return *v }).(ByProductsResponseOutput)
}

func (o ByProductsResponsePtrOutput) CustomValues() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ByProductsResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.CustomValues
	}).(pulumi.StringMapOutput)
}

// Common Vulnerability Scoring System version 3. For details, see https://www.first.org/cvss/specification-document
type CVSSv3 struct {
	AttackComplexity *CVSSv3AttackComplexity `pulumi:"attackComplexity"`
	// Base Metrics Represents the intrinsic characteristics of a vulnerability that are constant over time and across user environments.
	AttackVector       *CVSSv3AttackVector       `pulumi:"attackVector"`
	AvailabilityImpact *CVSSv3AvailabilityImpact `pulumi:"availabilityImpact"`
	// The base score is a function of the base metric scores.
	BaseScore             *float64                     `pulumi:"baseScore"`
	ConfidentialityImpact *CVSSv3ConfidentialityImpact `pulumi:"confidentialityImpact"`
	ExploitabilityScore   *float64                     `pulumi:"exploitabilityScore"`
	ImpactScore           *float64                     `pulumi:"impactScore"`
	IntegrityImpact       *CVSSv3IntegrityImpact       `pulumi:"integrityImpact"`
	PrivilegesRequired    *CVSSv3PrivilegesRequired    `pulumi:"privilegesRequired"`
	Scope                 *CVSSv3Scope                 `pulumi:"scope"`
	UserInteraction       *CVSSv3UserInteraction       `pulumi:"userInteraction"`
}

// CVSSv3Input is an input type that accepts CVSSv3Args and CVSSv3Output values.
// You can construct a concrete instance of `CVSSv3Input` via:
//
//          CVSSv3Args{...}
type CVSSv3Input interface {
	pulumi.Input

	ToCVSSv3Output() CVSSv3Output
	ToCVSSv3OutputWithContext(context.Context) CVSSv3Output
}

// Common Vulnerability Scoring System version 3. For details, see https://www.first.org/cvss/specification-document
type CVSSv3Args struct {
	AttackComplexity CVSSv3AttackComplexityPtrInput `pulumi:"attackComplexity"`
	// Base Metrics Represents the intrinsic characteristics of a vulnerability that are constant over time and across user environments.
	AttackVector       CVSSv3AttackVectorPtrInput       `pulumi:"attackVector"`
	AvailabilityImpact CVSSv3AvailabilityImpactPtrInput `pulumi:"availabilityImpact"`
	// The base score is a function of the base metric scores.
	BaseScore             pulumi.Float64PtrInput              `pulumi:"baseScore"`
	ConfidentialityImpact CVSSv3ConfidentialityImpactPtrInput `pulumi:"confidentialityImpact"`
	ExploitabilityScore   pulumi.Float64PtrInput              `pulumi:"exploitabilityScore"`
	ImpactScore           pulumi.Float64PtrInput              `pulumi:"impactScore"`
	IntegrityImpact       CVSSv3IntegrityImpactPtrInput       `pulumi:"integrityImpact"`
	PrivilegesRequired    CVSSv3PrivilegesRequiredPtrInput    `pulumi:"privilegesRequired"`
	Scope                 CVSSv3ScopePtrInput                 `pulumi:"scope"`
	UserInteraction       CVSSv3UserInteractionPtrInput       `pulumi:"userInteraction"`
}

func (CVSSv3Args) ElementType() reflect.Type {
	return reflect.TypeOf((*CVSSv3)(nil)).Elem()
}

func (i CVSSv3Args) ToCVSSv3Output() CVSSv3Output {
	return i.ToCVSSv3OutputWithContext(context.Background())
}

func (i CVSSv3Args) ToCVSSv3OutputWithContext(ctx context.Context) CVSSv3Output {
	return pulumi.ToOutputWithContext(ctx, i).(CVSSv3Output)
}

func (i CVSSv3Args) ToCVSSv3PtrOutput() CVSSv3PtrOutput {
	return i.ToCVSSv3PtrOutputWithContext(context.Background())
}

func (i CVSSv3Args) ToCVSSv3PtrOutputWithContext(ctx context.Context) CVSSv3PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CVSSv3Output).ToCVSSv3PtrOutputWithContext(ctx)
}

// CVSSv3PtrInput is an input type that accepts CVSSv3Args, CVSSv3Ptr and CVSSv3PtrOutput values.
// You can construct a concrete instance of `CVSSv3PtrInput` via:
//
//          CVSSv3Args{...}
//
//  or:
//
//          nil
type CVSSv3PtrInput interface {
	pulumi.Input

	ToCVSSv3PtrOutput() CVSSv3PtrOutput
	ToCVSSv3PtrOutputWithContext(context.Context) CVSSv3PtrOutput
}

type cvssv3PtrType CVSSv3Args

func CVSSv3Ptr(v *CVSSv3Args) CVSSv3PtrInput {
	return (*cvssv3PtrType)(v)
}

func (*cvssv3PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CVSSv3)(nil)).Elem()
}

func (i *cvssv3PtrType) ToCVSSv3PtrOutput() CVSSv3PtrOutput {
	return i.ToCVSSv3PtrOutputWithContext(context.Background())
}

func (i *cvssv3PtrType) ToCVSSv3PtrOutputWithContext(ctx context.Context) CVSSv3PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CVSSv3PtrOutput)
}

// Common Vulnerability Scoring System version 3. For details, see https://www.first.org/cvss/specification-document
type CVSSv3Output struct{ *pulumi.OutputState }

func (CVSSv3Output) ElementType() reflect.Type {
	return reflect.TypeOf((*CVSSv3)(nil)).Elem()
}

func (o CVSSv3Output) ToCVSSv3Output() CVSSv3Output {
	return o
}

func (o CVSSv3Output) ToCVSSv3OutputWithContext(ctx context.Context) CVSSv3Output {
	return o
}

func (o CVSSv3Output) ToCVSSv3PtrOutput() CVSSv3PtrOutput {
	return o.ToCVSSv3PtrOutputWithContext(context.Background())
}

func (o CVSSv3Output) ToCVSSv3PtrOutputWithContext(ctx context.Context) CVSSv3PtrOutput {
	return o.ApplyT(func(v CVSSv3) *CVSSv3 {
		return &v
	}).(CVSSv3PtrOutput)
}
func (o CVSSv3Output) AttackComplexity() CVSSv3AttackComplexityPtrOutput {
	return o.ApplyT(func(v CVSSv3) *CVSSv3AttackComplexity { return v.AttackComplexity }).(CVSSv3AttackComplexityPtrOutput)
}

// Base Metrics Represents the intrinsic characteristics of a vulnerability that are constant over time and across user environments.
func (o CVSSv3Output) AttackVector() CVSSv3AttackVectorPtrOutput {
	return o.ApplyT(func(v CVSSv3) *CVSSv3AttackVector { return v.AttackVector }).(CVSSv3AttackVectorPtrOutput)
}

func (o CVSSv3Output) AvailabilityImpact() CVSSv3AvailabilityImpactPtrOutput {
	return o.ApplyT(func(v CVSSv3) *CVSSv3AvailabilityImpact { return v.AvailabilityImpact }).(CVSSv3AvailabilityImpactPtrOutput)
}

// The base score is a function of the base metric scores.
func (o CVSSv3Output) BaseScore() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v CVSSv3) *float64 { return v.BaseScore }).(pulumi.Float64PtrOutput)
}

func (o CVSSv3Output) ConfidentialityImpact() CVSSv3ConfidentialityImpactPtrOutput {
	return o.ApplyT(func(v CVSSv3) *CVSSv3ConfidentialityImpact { return v.ConfidentialityImpact }).(CVSSv3ConfidentialityImpactPtrOutput)
}

func (o CVSSv3Output) ExploitabilityScore() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v CVSSv3) *float64 { return v.ExploitabilityScore }).(pulumi.Float64PtrOutput)
}

func (o CVSSv3Output) ImpactScore() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v CVSSv3) *float64 { return v.ImpactScore }).(pulumi.Float64PtrOutput)
}

func (o CVSSv3Output) IntegrityImpact() CVSSv3IntegrityImpactPtrOutput {
	return o.ApplyT(func(v CVSSv3) *CVSSv3IntegrityImpact { return v.IntegrityImpact }).(CVSSv3IntegrityImpactPtrOutput)
}

func (o CVSSv3Output) PrivilegesRequired() CVSSv3PrivilegesRequiredPtrOutput {
	return o.ApplyT(func(v CVSSv3) *CVSSv3PrivilegesRequired { return v.PrivilegesRequired }).(CVSSv3PrivilegesRequiredPtrOutput)
}

func (o CVSSv3Output) Scope() CVSSv3ScopePtrOutput {
	return o.ApplyT(func(v CVSSv3) *CVSSv3Scope { return v.Scope }).(CVSSv3ScopePtrOutput)
}

func (o CVSSv3Output) UserInteraction() CVSSv3UserInteractionPtrOutput {
	return o.ApplyT(func(v CVSSv3) *CVSSv3UserInteraction { return v.UserInteraction }).(CVSSv3UserInteractionPtrOutput)
}

type CVSSv3PtrOutput struct{ *pulumi.OutputState }

func (CVSSv3PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CVSSv3)(nil)).Elem()
}

func (o CVSSv3PtrOutput) ToCVSSv3PtrOutput() CVSSv3PtrOutput {
	return o
}

func (o CVSSv3PtrOutput) ToCVSSv3PtrOutputWithContext(ctx context.Context) CVSSv3PtrOutput {
	return o
}

func (o CVSSv3PtrOutput) Elem() CVSSv3Output {
	return o.ApplyT(func(v *CVSSv3) CVSSv3 { return *v }).(CVSSv3Output)
}

func (o CVSSv3PtrOutput) AttackComplexity() CVSSv3AttackComplexityPtrOutput {
	return o.ApplyT(func(v *CVSSv3) *CVSSv3AttackComplexity {
		if v == nil {
			return nil
		}
		return v.AttackComplexity
	}).(CVSSv3AttackComplexityPtrOutput)
}

// Base Metrics Represents the intrinsic characteristics of a vulnerability that are constant over time and across user environments.
func (o CVSSv3PtrOutput) AttackVector() CVSSv3AttackVectorPtrOutput {
	return o.ApplyT(func(v *CVSSv3) *CVSSv3AttackVector {
		if v == nil {
			return nil
		}
		return v.AttackVector
	}).(CVSSv3AttackVectorPtrOutput)
}

func (o CVSSv3PtrOutput) AvailabilityImpact() CVSSv3AvailabilityImpactPtrOutput {
	return o.ApplyT(func(v *CVSSv3) *CVSSv3AvailabilityImpact {
		if v == nil {
			return nil
		}
		return v.AvailabilityImpact
	}).(CVSSv3AvailabilityImpactPtrOutput)
}

// The base score is a function of the base metric scores.
func (o CVSSv3PtrOutput) BaseScore() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *CVSSv3) *float64 {
		if v == nil {
			return nil
		}
		return v.BaseScore
	}).(pulumi.Float64PtrOutput)
}

func (o CVSSv3PtrOutput) ConfidentialityImpact() CVSSv3ConfidentialityImpactPtrOutput {
	return o.ApplyT(func(v *CVSSv3) *CVSSv3ConfidentialityImpact {
		if v == nil {
			return nil
		}
		return v.ConfidentialityImpact
	}).(CVSSv3ConfidentialityImpactPtrOutput)
}

func (o CVSSv3PtrOutput) ExploitabilityScore() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *CVSSv3) *float64 {
		if v == nil {
			return nil
		}
		return v.ExploitabilityScore
	}).(pulumi.Float64PtrOutput)
}

func (o CVSSv3PtrOutput) ImpactScore() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *CVSSv3) *float64 {
		if v == nil {
			return nil
		}
		return v.ImpactScore
	}).(pulumi.Float64PtrOutput)
}

func (o CVSSv3PtrOutput) IntegrityImpact() CVSSv3IntegrityImpactPtrOutput {
	return o.ApplyT(func(v *CVSSv3) *CVSSv3IntegrityImpact {
		if v == nil {
			return nil
		}
		return v.IntegrityImpact
	}).(CVSSv3IntegrityImpactPtrOutput)
}

func (o CVSSv3PtrOutput) PrivilegesRequired() CVSSv3PrivilegesRequiredPtrOutput {
	return o.ApplyT(func(v *CVSSv3) *CVSSv3PrivilegesRequired {
		if v == nil {
			return nil
		}
		return v.PrivilegesRequired
	}).(CVSSv3PrivilegesRequiredPtrOutput)
}

func (o CVSSv3PtrOutput) Scope() CVSSv3ScopePtrOutput {
	return o.ApplyT(func(v *CVSSv3) *CVSSv3Scope {
		if v == nil {
			return nil
		}
		return v.Scope
	}).(CVSSv3ScopePtrOutput)
}

func (o CVSSv3PtrOutput) UserInteraction() CVSSv3UserInteractionPtrOutput {
	return o.ApplyT(func(v *CVSSv3) *CVSSv3UserInteraction {
		if v == nil {
			return nil
		}
		return v.UserInteraction
	}).(CVSSv3UserInteractionPtrOutput)
}

// Common Vulnerability Scoring System version 3. For details, see https://www.first.org/cvss/specification-document
type CVSSv3Response struct {
	AttackComplexity string `pulumi:"attackComplexity"`
	// Base Metrics Represents the intrinsic characteristics of a vulnerability that are constant over time and across user environments.
	AttackVector       string `pulumi:"attackVector"`
	AvailabilityImpact string `pulumi:"availabilityImpact"`
	// The base score is a function of the base metric scores.
	BaseScore             float64 `pulumi:"baseScore"`
	ConfidentialityImpact string  `pulumi:"confidentialityImpact"`
	ExploitabilityScore   float64 `pulumi:"exploitabilityScore"`
	ImpactScore           float64 `pulumi:"impactScore"`
	IntegrityImpact       string  `pulumi:"integrityImpact"`
	PrivilegesRequired    string  `pulumi:"privilegesRequired"`
	Scope                 string  `pulumi:"scope"`
	UserInteraction       string  `pulumi:"userInteraction"`
}

// CVSSv3ResponseInput is an input type that accepts CVSSv3ResponseArgs and CVSSv3ResponseOutput values.
// You can construct a concrete instance of `CVSSv3ResponseInput` via:
//
//          CVSSv3ResponseArgs{...}
type CVSSv3ResponseInput interface {
	pulumi.Input

	ToCVSSv3ResponseOutput() CVSSv3ResponseOutput
	ToCVSSv3ResponseOutputWithContext(context.Context) CVSSv3ResponseOutput
}

// Common Vulnerability Scoring System version 3. For details, see https://www.first.org/cvss/specification-document
type CVSSv3ResponseArgs struct {
	AttackComplexity pulumi.StringInput `pulumi:"attackComplexity"`
	// Base Metrics Represents the intrinsic characteristics of a vulnerability that are constant over time and across user environments.
	AttackVector       pulumi.StringInput `pulumi:"attackVector"`
	AvailabilityImpact pulumi.StringInput `pulumi:"availabilityImpact"`
	// The base score is a function of the base metric scores.
	BaseScore             pulumi.Float64Input `pulumi:"baseScore"`
	ConfidentialityImpact pulumi.StringInput  `pulumi:"confidentialityImpact"`
	ExploitabilityScore   pulumi.Float64Input `pulumi:"exploitabilityScore"`
	ImpactScore           pulumi.Float64Input `pulumi:"impactScore"`
	IntegrityImpact       pulumi.StringInput  `pulumi:"integrityImpact"`
	PrivilegesRequired    pulumi.StringInput  `pulumi:"privilegesRequired"`
	Scope                 pulumi.StringInput  `pulumi:"scope"`
	UserInteraction       pulumi.StringInput  `pulumi:"userInteraction"`
}

func (CVSSv3ResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CVSSv3Response)(nil)).Elem()
}

func (i CVSSv3ResponseArgs) ToCVSSv3ResponseOutput() CVSSv3ResponseOutput {
	return i.ToCVSSv3ResponseOutputWithContext(context.Background())
}

func (i CVSSv3ResponseArgs) ToCVSSv3ResponseOutputWithContext(ctx context.Context) CVSSv3ResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CVSSv3ResponseOutput)
}

func (i CVSSv3ResponseArgs) ToCVSSv3ResponsePtrOutput() CVSSv3ResponsePtrOutput {
	return i.ToCVSSv3ResponsePtrOutputWithContext(context.Background())
}

func (i CVSSv3ResponseArgs) ToCVSSv3ResponsePtrOutputWithContext(ctx context.Context) CVSSv3ResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CVSSv3ResponseOutput).ToCVSSv3ResponsePtrOutputWithContext(ctx)
}

// CVSSv3ResponsePtrInput is an input type that accepts CVSSv3ResponseArgs, CVSSv3ResponsePtr and CVSSv3ResponsePtrOutput values.
// You can construct a concrete instance of `CVSSv3ResponsePtrInput` via:
//
//          CVSSv3ResponseArgs{...}
//
//  or:
//
//          nil
type CVSSv3ResponsePtrInput interface {
	pulumi.Input

	ToCVSSv3ResponsePtrOutput() CVSSv3ResponsePtrOutput
	ToCVSSv3ResponsePtrOutputWithContext(context.Context) CVSSv3ResponsePtrOutput
}

type cvssv3ResponsePtrType CVSSv3ResponseArgs

func CVSSv3ResponsePtr(v *CVSSv3ResponseArgs) CVSSv3ResponsePtrInput {
	return (*cvssv3ResponsePtrType)(v)
}

func (*cvssv3ResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CVSSv3Response)(nil)).Elem()
}

func (i *cvssv3ResponsePtrType) ToCVSSv3ResponsePtrOutput() CVSSv3ResponsePtrOutput {
	return i.ToCVSSv3ResponsePtrOutputWithContext(context.Background())
}

func (i *cvssv3ResponsePtrType) ToCVSSv3ResponsePtrOutputWithContext(ctx context.Context) CVSSv3ResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CVSSv3ResponsePtrOutput)
}

// Common Vulnerability Scoring System version 3. For details, see https://www.first.org/cvss/specification-document
type CVSSv3ResponseOutput struct{ *pulumi.OutputState }

func (CVSSv3ResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CVSSv3Response)(nil)).Elem()
}

func (o CVSSv3ResponseOutput) ToCVSSv3ResponseOutput() CVSSv3ResponseOutput {
	return o
}

func (o CVSSv3ResponseOutput) ToCVSSv3ResponseOutputWithContext(ctx context.Context) CVSSv3ResponseOutput {
	return o
}

func (o CVSSv3ResponseOutput) ToCVSSv3ResponsePtrOutput() CVSSv3ResponsePtrOutput {
	return o.ToCVSSv3ResponsePtrOutputWithContext(context.Background())
}

func (o CVSSv3ResponseOutput) ToCVSSv3ResponsePtrOutputWithContext(ctx context.Context) CVSSv3ResponsePtrOutput {
	return o.ApplyT(func(v CVSSv3Response) *CVSSv3Response {
		return &v
	}).(CVSSv3ResponsePtrOutput)
}
func (o CVSSv3ResponseOutput) AttackComplexity() pulumi.StringOutput {
	return o.ApplyT(func(v CVSSv3Response) string { return v.AttackComplexity }).(pulumi.StringOutput)
}

// Base Metrics Represents the intrinsic characteristics of a vulnerability that are constant over time and across user environments.
func (o CVSSv3ResponseOutput) AttackVector() pulumi.StringOutput {
	return o.ApplyT(func(v CVSSv3Response) string { return v.AttackVector }).(pulumi.StringOutput)
}

func (o CVSSv3ResponseOutput) AvailabilityImpact() pulumi.StringOutput {
	return o.ApplyT(func(v CVSSv3Response) string { return v.AvailabilityImpact }).(pulumi.StringOutput)
}

// The base score is a function of the base metric scores.
func (o CVSSv3ResponseOutput) BaseScore() pulumi.Float64Output {
	return o.ApplyT(func(v CVSSv3Response) float64 { return v.BaseScore }).(pulumi.Float64Output)
}

func (o CVSSv3ResponseOutput) ConfidentialityImpact() pulumi.StringOutput {
	return o.ApplyT(func(v CVSSv3Response) string { return v.ConfidentialityImpact }).(pulumi.StringOutput)
}

func (o CVSSv3ResponseOutput) ExploitabilityScore() pulumi.Float64Output {
	return o.ApplyT(func(v CVSSv3Response) float64 { return v.ExploitabilityScore }).(pulumi.Float64Output)
}

func (o CVSSv3ResponseOutput) ImpactScore() pulumi.Float64Output {
	return o.ApplyT(func(v CVSSv3Response) float64 { return v.ImpactScore }).(pulumi.Float64Output)
}

func (o CVSSv3ResponseOutput) IntegrityImpact() pulumi.StringOutput {
	return o.ApplyT(func(v CVSSv3Response) string { return v.IntegrityImpact }).(pulumi.StringOutput)
}

func (o CVSSv3ResponseOutput) PrivilegesRequired() pulumi.StringOutput {
	return o.ApplyT(func(v CVSSv3Response) string { return v.PrivilegesRequired }).(pulumi.StringOutput)
}

func (o CVSSv3ResponseOutput) Scope() pulumi.StringOutput {
	return o.ApplyT(func(v CVSSv3Response) string { return v.Scope }).(pulumi.StringOutput)
}

func (o CVSSv3ResponseOutput) UserInteraction() pulumi.StringOutput {
	return o.ApplyT(func(v CVSSv3Response) string { return v.UserInteraction }).(pulumi.StringOutput)
}

type CVSSv3ResponsePtrOutput struct{ *pulumi.OutputState }

func (CVSSv3ResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CVSSv3Response)(nil)).Elem()
}

func (o CVSSv3ResponsePtrOutput) ToCVSSv3ResponsePtrOutput() CVSSv3ResponsePtrOutput {
	return o
}

func (o CVSSv3ResponsePtrOutput) ToCVSSv3ResponsePtrOutputWithContext(ctx context.Context) CVSSv3ResponsePtrOutput {
	return o
}

func (o CVSSv3ResponsePtrOutput) Elem() CVSSv3ResponseOutput {
	return o.ApplyT(func(v *CVSSv3Response) CVSSv3Response { return *v }).(CVSSv3ResponseOutput)
}

func (o CVSSv3ResponsePtrOutput) AttackComplexity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CVSSv3Response) *string {
		if v == nil {
			return nil
		}
		return &v.AttackComplexity
	}).(pulumi.StringPtrOutput)
}

// Base Metrics Represents the intrinsic characteristics of a vulnerability that are constant over time and across user environments.
func (o CVSSv3ResponsePtrOutput) AttackVector() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CVSSv3Response) *string {
		if v == nil {
			return nil
		}
		return &v.AttackVector
	}).(pulumi.StringPtrOutput)
}

func (o CVSSv3ResponsePtrOutput) AvailabilityImpact() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CVSSv3Response) *string {
		if v == nil {
			return nil
		}
		return &v.AvailabilityImpact
	}).(pulumi.StringPtrOutput)
}

// The base score is a function of the base metric scores.
func (o CVSSv3ResponsePtrOutput) BaseScore() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *CVSSv3Response) *float64 {
		if v == nil {
			return nil
		}
		return &v.BaseScore
	}).(pulumi.Float64PtrOutput)
}

func (o CVSSv3ResponsePtrOutput) ConfidentialityImpact() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CVSSv3Response) *string {
		if v == nil {
			return nil
		}
		return &v.ConfidentialityImpact
	}).(pulumi.StringPtrOutput)
}

func (o CVSSv3ResponsePtrOutput) ExploitabilityScore() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *CVSSv3Response) *float64 {
		if v == nil {
			return nil
		}
		return &v.ExploitabilityScore
	}).(pulumi.Float64PtrOutput)
}

func (o CVSSv3ResponsePtrOutput) ImpactScore() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *CVSSv3Response) *float64 {
		if v == nil {
			return nil
		}
		return &v.ImpactScore
	}).(pulumi.Float64PtrOutput)
}

func (o CVSSv3ResponsePtrOutput) IntegrityImpact() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CVSSv3Response) *string {
		if v == nil {
			return nil
		}
		return &v.IntegrityImpact
	}).(pulumi.StringPtrOutput)
}

func (o CVSSv3ResponsePtrOutput) PrivilegesRequired() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CVSSv3Response) *string {
		if v == nil {
			return nil
		}
		return &v.PrivilegesRequired
	}).(pulumi.StringPtrOutput)
}

func (o CVSSv3ResponsePtrOutput) Scope() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CVSSv3Response) *string {
		if v == nil {
			return nil
		}
		return &v.Scope
	}).(pulumi.StringPtrOutput)
}

func (o CVSSv3ResponsePtrOutput) UserInteraction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CVSSv3Response) *string {
		if v == nil {
			return nil
		}
		return &v.UserInteraction
	}).(pulumi.StringPtrOutput)
}

// A CloudRepoSourceContext denotes a particular revision in a Google Cloud Source Repo.
type CloudRepoSourceContext struct {
	// An alias, which may be a branch or tag.
	AliasContext *AliasContext `pulumi:"aliasContext"`
	// The ID of the repo.
	RepoId *RepoId `pulumi:"repoId"`
	// A revision ID.
	RevisionId *string `pulumi:"revisionId"`
}

// CloudRepoSourceContextInput is an input type that accepts CloudRepoSourceContextArgs and CloudRepoSourceContextOutput values.
// You can construct a concrete instance of `CloudRepoSourceContextInput` via:
//
//          CloudRepoSourceContextArgs{...}
type CloudRepoSourceContextInput interface {
	pulumi.Input

	ToCloudRepoSourceContextOutput() CloudRepoSourceContextOutput
	ToCloudRepoSourceContextOutputWithContext(context.Context) CloudRepoSourceContextOutput
}

// A CloudRepoSourceContext denotes a particular revision in a Google Cloud Source Repo.
type CloudRepoSourceContextArgs struct {
	// An alias, which may be a branch or tag.
	AliasContext AliasContextPtrInput `pulumi:"aliasContext"`
	// The ID of the repo.
	RepoId RepoIdPtrInput `pulumi:"repoId"`
	// A revision ID.
	RevisionId pulumi.StringPtrInput `pulumi:"revisionId"`
}

func (CloudRepoSourceContextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudRepoSourceContext)(nil)).Elem()
}

func (i CloudRepoSourceContextArgs) ToCloudRepoSourceContextOutput() CloudRepoSourceContextOutput {
	return i.ToCloudRepoSourceContextOutputWithContext(context.Background())
}

func (i CloudRepoSourceContextArgs) ToCloudRepoSourceContextOutputWithContext(ctx context.Context) CloudRepoSourceContextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudRepoSourceContextOutput)
}

func (i CloudRepoSourceContextArgs) ToCloudRepoSourceContextPtrOutput() CloudRepoSourceContextPtrOutput {
	return i.ToCloudRepoSourceContextPtrOutputWithContext(context.Background())
}

func (i CloudRepoSourceContextArgs) ToCloudRepoSourceContextPtrOutputWithContext(ctx context.Context) CloudRepoSourceContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudRepoSourceContextOutput).ToCloudRepoSourceContextPtrOutputWithContext(ctx)
}

// CloudRepoSourceContextPtrInput is an input type that accepts CloudRepoSourceContextArgs, CloudRepoSourceContextPtr and CloudRepoSourceContextPtrOutput values.
// You can construct a concrete instance of `CloudRepoSourceContextPtrInput` via:
//
//          CloudRepoSourceContextArgs{...}
//
//  or:
//
//          nil
type CloudRepoSourceContextPtrInput interface {
	pulumi.Input

	ToCloudRepoSourceContextPtrOutput() CloudRepoSourceContextPtrOutput
	ToCloudRepoSourceContextPtrOutputWithContext(context.Context) CloudRepoSourceContextPtrOutput
}

type cloudRepoSourceContextPtrType CloudRepoSourceContextArgs

func CloudRepoSourceContextPtr(v *CloudRepoSourceContextArgs) CloudRepoSourceContextPtrInput {
	return (*cloudRepoSourceContextPtrType)(v)
}

func (*cloudRepoSourceContextPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudRepoSourceContext)(nil)).Elem()
}

func (i *cloudRepoSourceContextPtrType) ToCloudRepoSourceContextPtrOutput() CloudRepoSourceContextPtrOutput {
	return i.ToCloudRepoSourceContextPtrOutputWithContext(context.Background())
}

func (i *cloudRepoSourceContextPtrType) ToCloudRepoSourceContextPtrOutputWithContext(ctx context.Context) CloudRepoSourceContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudRepoSourceContextPtrOutput)
}

// A CloudRepoSourceContext denotes a particular revision in a Google Cloud Source Repo.
type CloudRepoSourceContextOutput struct{ *pulumi.OutputState }

func (CloudRepoSourceContextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudRepoSourceContext)(nil)).Elem()
}

func (o CloudRepoSourceContextOutput) ToCloudRepoSourceContextOutput() CloudRepoSourceContextOutput {
	return o
}

func (o CloudRepoSourceContextOutput) ToCloudRepoSourceContextOutputWithContext(ctx context.Context) CloudRepoSourceContextOutput {
	return o
}

func (o CloudRepoSourceContextOutput) ToCloudRepoSourceContextPtrOutput() CloudRepoSourceContextPtrOutput {
	return o.ToCloudRepoSourceContextPtrOutputWithContext(context.Background())
}

func (o CloudRepoSourceContextOutput) ToCloudRepoSourceContextPtrOutputWithContext(ctx context.Context) CloudRepoSourceContextPtrOutput {
	return o.ApplyT(func(v CloudRepoSourceContext) *CloudRepoSourceContext {
		return &v
	}).(CloudRepoSourceContextPtrOutput)
}

// An alias, which may be a branch or tag.
func (o CloudRepoSourceContextOutput) AliasContext() AliasContextPtrOutput {
	return o.ApplyT(func(v CloudRepoSourceContext) *AliasContext { return v.AliasContext }).(AliasContextPtrOutput)
}

// The ID of the repo.
func (o CloudRepoSourceContextOutput) RepoId() RepoIdPtrOutput {
	return o.ApplyT(func(v CloudRepoSourceContext) *RepoId { return v.RepoId }).(RepoIdPtrOutput)
}

// A revision ID.
func (o CloudRepoSourceContextOutput) RevisionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CloudRepoSourceContext) *string { return v.RevisionId }).(pulumi.StringPtrOutput)
}

type CloudRepoSourceContextPtrOutput struct{ *pulumi.OutputState }

func (CloudRepoSourceContextPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudRepoSourceContext)(nil)).Elem()
}

func (o CloudRepoSourceContextPtrOutput) ToCloudRepoSourceContextPtrOutput() CloudRepoSourceContextPtrOutput {
	return o
}

func (o CloudRepoSourceContextPtrOutput) ToCloudRepoSourceContextPtrOutputWithContext(ctx context.Context) CloudRepoSourceContextPtrOutput {
	return o
}

func (o CloudRepoSourceContextPtrOutput) Elem() CloudRepoSourceContextOutput {
	return o.ApplyT(func(v *CloudRepoSourceContext) CloudRepoSourceContext { return *v }).(CloudRepoSourceContextOutput)
}

// An alias, which may be a branch or tag.
func (o CloudRepoSourceContextPtrOutput) AliasContext() AliasContextPtrOutput {
	return o.ApplyT(func(v *CloudRepoSourceContext) *AliasContext {
		if v == nil {
			return nil
		}
		return v.AliasContext
	}).(AliasContextPtrOutput)
}

// The ID of the repo.
func (o CloudRepoSourceContextPtrOutput) RepoId() RepoIdPtrOutput {
	return o.ApplyT(func(v *CloudRepoSourceContext) *RepoId {
		if v == nil {
			return nil
		}
		return v.RepoId
	}).(RepoIdPtrOutput)
}

// A revision ID.
func (o CloudRepoSourceContextPtrOutput) RevisionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CloudRepoSourceContext) *string {
		if v == nil {
			return nil
		}
		return v.RevisionId
	}).(pulumi.StringPtrOutput)
}

// A CloudRepoSourceContext denotes a particular revision in a Google Cloud Source Repo.
type CloudRepoSourceContextResponse struct {
	// An alias, which may be a branch or tag.
	AliasContext AliasContextResponse `pulumi:"aliasContext"`
	// The ID of the repo.
	RepoId RepoIdResponse `pulumi:"repoId"`
	// A revision ID.
	RevisionId string `pulumi:"revisionId"`
}

// CloudRepoSourceContextResponseInput is an input type that accepts CloudRepoSourceContextResponseArgs and CloudRepoSourceContextResponseOutput values.
// You can construct a concrete instance of `CloudRepoSourceContextResponseInput` via:
//
//          CloudRepoSourceContextResponseArgs{...}
type CloudRepoSourceContextResponseInput interface {
	pulumi.Input

	ToCloudRepoSourceContextResponseOutput() CloudRepoSourceContextResponseOutput
	ToCloudRepoSourceContextResponseOutputWithContext(context.Context) CloudRepoSourceContextResponseOutput
}

// A CloudRepoSourceContext denotes a particular revision in a Google Cloud Source Repo.
type CloudRepoSourceContextResponseArgs struct {
	// An alias, which may be a branch or tag.
	AliasContext AliasContextResponseInput `pulumi:"aliasContext"`
	// The ID of the repo.
	RepoId RepoIdResponseInput `pulumi:"repoId"`
	// A revision ID.
	RevisionId pulumi.StringInput `pulumi:"revisionId"`
}

func (CloudRepoSourceContextResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudRepoSourceContextResponse)(nil)).Elem()
}

func (i CloudRepoSourceContextResponseArgs) ToCloudRepoSourceContextResponseOutput() CloudRepoSourceContextResponseOutput {
	return i.ToCloudRepoSourceContextResponseOutputWithContext(context.Background())
}

func (i CloudRepoSourceContextResponseArgs) ToCloudRepoSourceContextResponseOutputWithContext(ctx context.Context) CloudRepoSourceContextResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudRepoSourceContextResponseOutput)
}

func (i CloudRepoSourceContextResponseArgs) ToCloudRepoSourceContextResponsePtrOutput() CloudRepoSourceContextResponsePtrOutput {
	return i.ToCloudRepoSourceContextResponsePtrOutputWithContext(context.Background())
}

func (i CloudRepoSourceContextResponseArgs) ToCloudRepoSourceContextResponsePtrOutputWithContext(ctx context.Context) CloudRepoSourceContextResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudRepoSourceContextResponseOutput).ToCloudRepoSourceContextResponsePtrOutputWithContext(ctx)
}

// CloudRepoSourceContextResponsePtrInput is an input type that accepts CloudRepoSourceContextResponseArgs, CloudRepoSourceContextResponsePtr and CloudRepoSourceContextResponsePtrOutput values.
// You can construct a concrete instance of `CloudRepoSourceContextResponsePtrInput` via:
//
//          CloudRepoSourceContextResponseArgs{...}
//
//  or:
//
//          nil
type CloudRepoSourceContextResponsePtrInput interface {
	pulumi.Input

	ToCloudRepoSourceContextResponsePtrOutput() CloudRepoSourceContextResponsePtrOutput
	ToCloudRepoSourceContextResponsePtrOutputWithContext(context.Context) CloudRepoSourceContextResponsePtrOutput
}

type cloudRepoSourceContextResponsePtrType CloudRepoSourceContextResponseArgs

func CloudRepoSourceContextResponsePtr(v *CloudRepoSourceContextResponseArgs) CloudRepoSourceContextResponsePtrInput {
	return (*cloudRepoSourceContextResponsePtrType)(v)
}

func (*cloudRepoSourceContextResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudRepoSourceContextResponse)(nil)).Elem()
}

func (i *cloudRepoSourceContextResponsePtrType) ToCloudRepoSourceContextResponsePtrOutput() CloudRepoSourceContextResponsePtrOutput {
	return i.ToCloudRepoSourceContextResponsePtrOutputWithContext(context.Background())
}

func (i *cloudRepoSourceContextResponsePtrType) ToCloudRepoSourceContextResponsePtrOutputWithContext(ctx context.Context) CloudRepoSourceContextResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudRepoSourceContextResponsePtrOutput)
}

// A CloudRepoSourceContext denotes a particular revision in a Google Cloud Source Repo.
type CloudRepoSourceContextResponseOutput struct{ *pulumi.OutputState }

func (CloudRepoSourceContextResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudRepoSourceContextResponse)(nil)).Elem()
}

func (o CloudRepoSourceContextResponseOutput) ToCloudRepoSourceContextResponseOutput() CloudRepoSourceContextResponseOutput {
	return o
}

func (o CloudRepoSourceContextResponseOutput) ToCloudRepoSourceContextResponseOutputWithContext(ctx context.Context) CloudRepoSourceContextResponseOutput {
	return o
}

func (o CloudRepoSourceContextResponseOutput) ToCloudRepoSourceContextResponsePtrOutput() CloudRepoSourceContextResponsePtrOutput {
	return o.ToCloudRepoSourceContextResponsePtrOutputWithContext(context.Background())
}

func (o CloudRepoSourceContextResponseOutput) ToCloudRepoSourceContextResponsePtrOutputWithContext(ctx context.Context) CloudRepoSourceContextResponsePtrOutput {
	return o.ApplyT(func(v CloudRepoSourceContextResponse) *CloudRepoSourceContextResponse {
		return &v
	}).(CloudRepoSourceContextResponsePtrOutput)
}

// An alias, which may be a branch or tag.
func (o CloudRepoSourceContextResponseOutput) AliasContext() AliasContextResponseOutput {
	return o.ApplyT(func(v CloudRepoSourceContextResponse) AliasContextResponse { return v.AliasContext }).(AliasContextResponseOutput)
}

// The ID of the repo.
func (o CloudRepoSourceContextResponseOutput) RepoId() RepoIdResponseOutput {
	return o.ApplyT(func(v CloudRepoSourceContextResponse) RepoIdResponse { return v.RepoId }).(RepoIdResponseOutput)
}

// A revision ID.
func (o CloudRepoSourceContextResponseOutput) RevisionId() pulumi.StringOutput {
	return o.ApplyT(func(v CloudRepoSourceContextResponse) string { return v.RevisionId }).(pulumi.StringOutput)
}

type CloudRepoSourceContextResponsePtrOutput struct{ *pulumi.OutputState }

func (CloudRepoSourceContextResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudRepoSourceContextResponse)(nil)).Elem()
}

func (o CloudRepoSourceContextResponsePtrOutput) ToCloudRepoSourceContextResponsePtrOutput() CloudRepoSourceContextResponsePtrOutput {
	return o
}

func (o CloudRepoSourceContextResponsePtrOutput) ToCloudRepoSourceContextResponsePtrOutputWithContext(ctx context.Context) CloudRepoSourceContextResponsePtrOutput {
	return o
}

func (o CloudRepoSourceContextResponsePtrOutput) Elem() CloudRepoSourceContextResponseOutput {
	return o.ApplyT(func(v *CloudRepoSourceContextResponse) CloudRepoSourceContextResponse { return *v }).(CloudRepoSourceContextResponseOutput)
}

// An alias, which may be a branch or tag.
func (o CloudRepoSourceContextResponsePtrOutput) AliasContext() AliasContextResponsePtrOutput {
	return o.ApplyT(func(v *CloudRepoSourceContextResponse) *AliasContextResponse {
		if v == nil {
			return nil
		}
		return &v.AliasContext
	}).(AliasContextResponsePtrOutput)
}

// The ID of the repo.
func (o CloudRepoSourceContextResponsePtrOutput) RepoId() RepoIdResponsePtrOutput {
	return o.ApplyT(func(v *CloudRepoSourceContextResponse) *RepoIdResponse {
		if v == nil {
			return nil
		}
		return &v.RepoId
	}).(RepoIdResponsePtrOutput)
}

// A revision ID.
func (o CloudRepoSourceContextResponsePtrOutput) RevisionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CloudRepoSourceContextResponse) *string {
		if v == nil {
			return nil
		}
		return &v.RevisionId
	}).(pulumi.StringPtrOutput)
}

// Command describes a step performed as part of the build pipeline.
type Command struct {
	// Command-line arguments used when executing this command.
	Args []string `pulumi:"args"`
	// Working directory (relative to project source root) used when running this command.
	Dir *string `pulumi:"dir"`
	// Environment variables set before running this command.
	Env []string `pulumi:"env"`
	// Optional unique identifier for this command, used in wait_for to reference this command as a dependency.
	Id *string `pulumi:"id"`
	// Name of the command, as presented on the command line, or if the command is packaged as a Docker container, as presented to `docker pull`.
	Name string `pulumi:"name"`
	// The ID(s) of the command(s) that this command depends on.
	WaitFor []string `pulumi:"waitFor"`
}

// CommandInput is an input type that accepts CommandArgs and CommandOutput values.
// You can construct a concrete instance of `CommandInput` via:
//
//          CommandArgs{...}
type CommandInput interface {
	pulumi.Input

	ToCommandOutput() CommandOutput
	ToCommandOutputWithContext(context.Context) CommandOutput
}

// Command describes a step performed as part of the build pipeline.
type CommandArgs struct {
	// Command-line arguments used when executing this command.
	Args pulumi.StringArrayInput `pulumi:"args"`
	// Working directory (relative to project source root) used when running this command.
	Dir pulumi.StringPtrInput `pulumi:"dir"`
	// Environment variables set before running this command.
	Env pulumi.StringArrayInput `pulumi:"env"`
	// Optional unique identifier for this command, used in wait_for to reference this command as a dependency.
	Id pulumi.StringPtrInput `pulumi:"id"`
	// Name of the command, as presented on the command line, or if the command is packaged as a Docker container, as presented to `docker pull`.
	Name pulumi.StringInput `pulumi:"name"`
	// The ID(s) of the command(s) that this command depends on.
	WaitFor pulumi.StringArrayInput `pulumi:"waitFor"`
}

func (CommandArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Command)(nil)).Elem()
}

func (i CommandArgs) ToCommandOutput() CommandOutput {
	return i.ToCommandOutputWithContext(context.Background())
}

func (i CommandArgs) ToCommandOutputWithContext(ctx context.Context) CommandOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommandOutput)
}

// CommandArrayInput is an input type that accepts CommandArray and CommandArrayOutput values.
// You can construct a concrete instance of `CommandArrayInput` via:
//
//          CommandArray{ CommandArgs{...} }
type CommandArrayInput interface {
	pulumi.Input

	ToCommandArrayOutput() CommandArrayOutput
	ToCommandArrayOutputWithContext(context.Context) CommandArrayOutput
}

type CommandArray []CommandInput

func (CommandArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Command)(nil)).Elem()
}

func (i CommandArray) ToCommandArrayOutput() CommandArrayOutput {
	return i.ToCommandArrayOutputWithContext(context.Background())
}

func (i CommandArray) ToCommandArrayOutputWithContext(ctx context.Context) CommandArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommandArrayOutput)
}

// Command describes a step performed as part of the build pipeline.
type CommandOutput struct{ *pulumi.OutputState }

func (CommandOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Command)(nil)).Elem()
}

func (o CommandOutput) ToCommandOutput() CommandOutput {
	return o
}

func (o CommandOutput) ToCommandOutputWithContext(ctx context.Context) CommandOutput {
	return o
}

// Command-line arguments used when executing this command.
func (o CommandOutput) Args() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Command) []string { return v.Args }).(pulumi.StringArrayOutput)
}

// Working directory (relative to project source root) used when running this command.
func (o CommandOutput) Dir() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Command) *string { return v.Dir }).(pulumi.StringPtrOutput)
}

// Environment variables set before running this command.
func (o CommandOutput) Env() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Command) []string { return v.Env }).(pulumi.StringArrayOutput)
}

// Optional unique identifier for this command, used in wait_for to reference this command as a dependency.
func (o CommandOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Command) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Name of the command, as presented on the command line, or if the command is packaged as a Docker container, as presented to `docker pull`.
func (o CommandOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v Command) string { return v.Name }).(pulumi.StringOutput)
}

// The ID(s) of the command(s) that this command depends on.
func (o CommandOutput) WaitFor() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Command) []string { return v.WaitFor }).(pulumi.StringArrayOutput)
}

type CommandArrayOutput struct{ *pulumi.OutputState }

func (CommandArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Command)(nil)).Elem()
}

func (o CommandArrayOutput) ToCommandArrayOutput() CommandArrayOutput {
	return o
}

func (o CommandArrayOutput) ToCommandArrayOutputWithContext(ctx context.Context) CommandArrayOutput {
	return o
}

func (o CommandArrayOutput) Index(i pulumi.IntInput) CommandOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Command {
		return vs[0].([]Command)[vs[1].(int)]
	}).(CommandOutput)
}

// Command describes a step performed as part of the build pipeline.
type CommandResponse struct {
	// Command-line arguments used when executing this command.
	Args []string `pulumi:"args"`
	// Working directory (relative to project source root) used when running this command.
	Dir string `pulumi:"dir"`
	// Environment variables set before running this command.
	Env []string `pulumi:"env"`
	// Name of the command, as presented on the command line, or if the command is packaged as a Docker container, as presented to `docker pull`.
	Name string `pulumi:"name"`
	// The ID(s) of the command(s) that this command depends on.
	WaitFor []string `pulumi:"waitFor"`
}

// CommandResponseInput is an input type that accepts CommandResponseArgs and CommandResponseOutput values.
// You can construct a concrete instance of `CommandResponseInput` via:
//
//          CommandResponseArgs{...}
type CommandResponseInput interface {
	pulumi.Input

	ToCommandResponseOutput() CommandResponseOutput
	ToCommandResponseOutputWithContext(context.Context) CommandResponseOutput
}

// Command describes a step performed as part of the build pipeline.
type CommandResponseArgs struct {
	// Command-line arguments used when executing this command.
	Args pulumi.StringArrayInput `pulumi:"args"`
	// Working directory (relative to project source root) used when running this command.
	Dir pulumi.StringInput `pulumi:"dir"`
	// Environment variables set before running this command.
	Env pulumi.StringArrayInput `pulumi:"env"`
	// Name of the command, as presented on the command line, or if the command is packaged as a Docker container, as presented to `docker pull`.
	Name pulumi.StringInput `pulumi:"name"`
	// The ID(s) of the command(s) that this command depends on.
	WaitFor pulumi.StringArrayInput `pulumi:"waitFor"`
}

func (CommandResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CommandResponse)(nil)).Elem()
}

func (i CommandResponseArgs) ToCommandResponseOutput() CommandResponseOutput {
	return i.ToCommandResponseOutputWithContext(context.Background())
}

func (i CommandResponseArgs) ToCommandResponseOutputWithContext(ctx context.Context) CommandResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommandResponseOutput)
}

// CommandResponseArrayInput is an input type that accepts CommandResponseArray and CommandResponseArrayOutput values.
// You can construct a concrete instance of `CommandResponseArrayInput` via:
//
//          CommandResponseArray{ CommandResponseArgs{...} }
type CommandResponseArrayInput interface {
	pulumi.Input

	ToCommandResponseArrayOutput() CommandResponseArrayOutput
	ToCommandResponseArrayOutputWithContext(context.Context) CommandResponseArrayOutput
}

type CommandResponseArray []CommandResponseInput

func (CommandResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CommandResponse)(nil)).Elem()
}

func (i CommandResponseArray) ToCommandResponseArrayOutput() CommandResponseArrayOutput {
	return i.ToCommandResponseArrayOutputWithContext(context.Background())
}

func (i CommandResponseArray) ToCommandResponseArrayOutputWithContext(ctx context.Context) CommandResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CommandResponseArrayOutput)
}

// Command describes a step performed as part of the build pipeline.
type CommandResponseOutput struct{ *pulumi.OutputState }

func (CommandResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CommandResponse)(nil)).Elem()
}

func (o CommandResponseOutput) ToCommandResponseOutput() CommandResponseOutput {
	return o
}

func (o CommandResponseOutput) ToCommandResponseOutputWithContext(ctx context.Context) CommandResponseOutput {
	return o
}

// Command-line arguments used when executing this command.
func (o CommandResponseOutput) Args() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CommandResponse) []string { return v.Args }).(pulumi.StringArrayOutput)
}

// Working directory (relative to project source root) used when running this command.
func (o CommandResponseOutput) Dir() pulumi.StringOutput {
	return o.ApplyT(func(v CommandResponse) string { return v.Dir }).(pulumi.StringOutput)
}

// Environment variables set before running this command.
func (o CommandResponseOutput) Env() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CommandResponse) []string { return v.Env }).(pulumi.StringArrayOutput)
}

// Name of the command, as presented on the command line, or if the command is packaged as a Docker container, as presented to `docker pull`.
func (o CommandResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v CommandResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The ID(s) of the command(s) that this command depends on.
func (o CommandResponseOutput) WaitFor() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CommandResponse) []string { return v.WaitFor }).(pulumi.StringArrayOutput)
}

type CommandResponseArrayOutput struct{ *pulumi.OutputState }

func (CommandResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CommandResponse)(nil)).Elem()
}

func (o CommandResponseArrayOutput) ToCommandResponseArrayOutput() CommandResponseArrayOutput {
	return o
}

func (o CommandResponseArrayOutput) ToCommandResponseArrayOutputWithContext(ctx context.Context) CommandResponseArrayOutput {
	return o
}

func (o CommandResponseArrayOutput) Index(i pulumi.IntInput) CommandResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CommandResponse {
		return vs[0].([]CommandResponse)[vs[1].(int)]
	}).(CommandResponseOutput)
}

// An artifact that can be deployed in some runtime.
type Deployable struct {
	// Resource URI for the artifact being deployed.
	ResourceUri []string `pulumi:"resourceUri"`
}

// DeployableInput is an input type that accepts DeployableArgs and DeployableOutput values.
// You can construct a concrete instance of `DeployableInput` via:
//
//          DeployableArgs{...}
type DeployableInput interface {
	pulumi.Input

	ToDeployableOutput() DeployableOutput
	ToDeployableOutputWithContext(context.Context) DeployableOutput
}

// An artifact that can be deployed in some runtime.
type DeployableArgs struct {
	// Resource URI for the artifact being deployed.
	ResourceUri pulumi.StringArrayInput `pulumi:"resourceUri"`
}

func (DeployableArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Deployable)(nil)).Elem()
}

func (i DeployableArgs) ToDeployableOutput() DeployableOutput {
	return i.ToDeployableOutputWithContext(context.Background())
}

func (i DeployableArgs) ToDeployableOutputWithContext(ctx context.Context) DeployableOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableOutput)
}

func (i DeployableArgs) ToDeployablePtrOutput() DeployablePtrOutput {
	return i.ToDeployablePtrOutputWithContext(context.Background())
}

func (i DeployableArgs) ToDeployablePtrOutputWithContext(ctx context.Context) DeployablePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableOutput).ToDeployablePtrOutputWithContext(ctx)
}

// DeployablePtrInput is an input type that accepts DeployableArgs, DeployablePtr and DeployablePtrOutput values.
// You can construct a concrete instance of `DeployablePtrInput` via:
//
//          DeployableArgs{...}
//
//  or:
//
//          nil
type DeployablePtrInput interface {
	pulumi.Input

	ToDeployablePtrOutput() DeployablePtrOutput
	ToDeployablePtrOutputWithContext(context.Context) DeployablePtrOutput
}

type deployablePtrType DeployableArgs

func DeployablePtr(v *DeployableArgs) DeployablePtrInput {
	return (*deployablePtrType)(v)
}

func (*deployablePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Deployable)(nil)).Elem()
}

func (i *deployablePtrType) ToDeployablePtrOutput() DeployablePtrOutput {
	return i.ToDeployablePtrOutputWithContext(context.Background())
}

func (i *deployablePtrType) ToDeployablePtrOutputWithContext(ctx context.Context) DeployablePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployablePtrOutput)
}

// An artifact that can be deployed in some runtime.
type DeployableOutput struct{ *pulumi.OutputState }

func (DeployableOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Deployable)(nil)).Elem()
}

func (o DeployableOutput) ToDeployableOutput() DeployableOutput {
	return o
}

func (o DeployableOutput) ToDeployableOutputWithContext(ctx context.Context) DeployableOutput {
	return o
}

func (o DeployableOutput) ToDeployablePtrOutput() DeployablePtrOutput {
	return o.ToDeployablePtrOutputWithContext(context.Background())
}

func (o DeployableOutput) ToDeployablePtrOutputWithContext(ctx context.Context) DeployablePtrOutput {
	return o.ApplyT(func(v Deployable) *Deployable {
		return &v
	}).(DeployablePtrOutput)
}

// Resource URI for the artifact being deployed.
func (o DeployableOutput) ResourceUri() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Deployable) []string { return v.ResourceUri }).(pulumi.StringArrayOutput)
}

type DeployablePtrOutput struct{ *pulumi.OutputState }

func (DeployablePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Deployable)(nil)).Elem()
}

func (o DeployablePtrOutput) ToDeployablePtrOutput() DeployablePtrOutput {
	return o
}

func (o DeployablePtrOutput) ToDeployablePtrOutputWithContext(ctx context.Context) DeployablePtrOutput {
	return o
}

func (o DeployablePtrOutput) Elem() DeployableOutput {
	return o.ApplyT(func(v *Deployable) Deployable { return *v }).(DeployableOutput)
}

// Resource URI for the artifact being deployed.
func (o DeployablePtrOutput) ResourceUri() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Deployable) []string {
		if v == nil {
			return nil
		}
		return v.ResourceUri
	}).(pulumi.StringArrayOutput)
}

// An artifact that can be deployed in some runtime.
type DeployableResponse struct {
	// Resource URI for the artifact being deployed.
	ResourceUri []string `pulumi:"resourceUri"`
}

// DeployableResponseInput is an input type that accepts DeployableResponseArgs and DeployableResponseOutput values.
// You can construct a concrete instance of `DeployableResponseInput` via:
//
//          DeployableResponseArgs{...}
type DeployableResponseInput interface {
	pulumi.Input

	ToDeployableResponseOutput() DeployableResponseOutput
	ToDeployableResponseOutputWithContext(context.Context) DeployableResponseOutput
}

// An artifact that can be deployed in some runtime.
type DeployableResponseArgs struct {
	// Resource URI for the artifact being deployed.
	ResourceUri pulumi.StringArrayInput `pulumi:"resourceUri"`
}

func (DeployableResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableResponse)(nil)).Elem()
}

func (i DeployableResponseArgs) ToDeployableResponseOutput() DeployableResponseOutput {
	return i.ToDeployableResponseOutputWithContext(context.Background())
}

func (i DeployableResponseArgs) ToDeployableResponseOutputWithContext(ctx context.Context) DeployableResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableResponseOutput)
}

func (i DeployableResponseArgs) ToDeployableResponsePtrOutput() DeployableResponsePtrOutput {
	return i.ToDeployableResponsePtrOutputWithContext(context.Background())
}

func (i DeployableResponseArgs) ToDeployableResponsePtrOutputWithContext(ctx context.Context) DeployableResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableResponseOutput).ToDeployableResponsePtrOutputWithContext(ctx)
}

// DeployableResponsePtrInput is an input type that accepts DeployableResponseArgs, DeployableResponsePtr and DeployableResponsePtrOutput values.
// You can construct a concrete instance of `DeployableResponsePtrInput` via:
//
//          DeployableResponseArgs{...}
//
//  or:
//
//          nil
type DeployableResponsePtrInput interface {
	pulumi.Input

	ToDeployableResponsePtrOutput() DeployableResponsePtrOutput
	ToDeployableResponsePtrOutputWithContext(context.Context) DeployableResponsePtrOutput
}

type deployableResponsePtrType DeployableResponseArgs

func DeployableResponsePtr(v *DeployableResponseArgs) DeployableResponsePtrInput {
	return (*deployableResponsePtrType)(v)
}

func (*deployableResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeployableResponse)(nil)).Elem()
}

func (i *deployableResponsePtrType) ToDeployableResponsePtrOutput() DeployableResponsePtrOutput {
	return i.ToDeployableResponsePtrOutputWithContext(context.Background())
}

func (i *deployableResponsePtrType) ToDeployableResponsePtrOutputWithContext(ctx context.Context) DeployableResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableResponsePtrOutput)
}

// An artifact that can be deployed in some runtime.
type DeployableResponseOutput struct{ *pulumi.OutputState }

func (DeployableResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableResponse)(nil)).Elem()
}

func (o DeployableResponseOutput) ToDeployableResponseOutput() DeployableResponseOutput {
	return o
}

func (o DeployableResponseOutput) ToDeployableResponseOutputWithContext(ctx context.Context) DeployableResponseOutput {
	return o
}

func (o DeployableResponseOutput) ToDeployableResponsePtrOutput() DeployableResponsePtrOutput {
	return o.ToDeployableResponsePtrOutputWithContext(context.Background())
}

func (o DeployableResponseOutput) ToDeployableResponsePtrOutputWithContext(ctx context.Context) DeployableResponsePtrOutput {
	return o.ApplyT(func(v DeployableResponse) *DeployableResponse {
		return &v
	}).(DeployableResponsePtrOutput)
}

// Resource URI for the artifact being deployed.
func (o DeployableResponseOutput) ResourceUri() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeployableResponse) []string { return v.ResourceUri }).(pulumi.StringArrayOutput)
}

type DeployableResponsePtrOutput struct{ *pulumi.OutputState }

func (DeployableResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeployableResponse)(nil)).Elem()
}

func (o DeployableResponsePtrOutput) ToDeployableResponsePtrOutput() DeployableResponsePtrOutput {
	return o
}

func (o DeployableResponsePtrOutput) ToDeployableResponsePtrOutputWithContext(ctx context.Context) DeployableResponsePtrOutput {
	return o
}

func (o DeployableResponsePtrOutput) Elem() DeployableResponseOutput {
	return o.ApplyT(func(v *DeployableResponse) DeployableResponse { return *v }).(DeployableResponseOutput)
}

// Resource URI for the artifact being deployed.
func (o DeployableResponsePtrOutput) ResourceUri() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DeployableResponse) []string {
		if v == nil {
			return nil
		}
		return v.ResourceUri
	}).(pulumi.StringArrayOutput)
}

// The period during which some deployable was active in a runtime.
type Deployment struct {
	// Address of the runtime element hosting this deployment.
	Address *string `pulumi:"address"`
	// Configuration used to create this deployment.
	Config *string `pulumi:"config"`
	// Beginning of the lifetime of this deployment.
	DeployTime string `pulumi:"deployTime"`
	// Platform hosting this deployment.
	Platform *DeploymentPlatform `pulumi:"platform"`
	// End of the lifetime of this deployment.
	UndeployTime *string `pulumi:"undeployTime"`
	// Identity of the user that triggered this deployment.
	UserEmail *string `pulumi:"userEmail"`
}

// DeploymentInput is an input type that accepts DeploymentArgs and DeploymentOutput values.
// You can construct a concrete instance of `DeploymentInput` via:
//
//          DeploymentArgs{...}
type DeploymentInput interface {
	pulumi.Input

	ToDeploymentOutput() DeploymentOutput
	ToDeploymentOutputWithContext(context.Context) DeploymentOutput
}

// The period during which some deployable was active in a runtime.
type DeploymentArgs struct {
	// Address of the runtime element hosting this deployment.
	Address pulumi.StringPtrInput `pulumi:"address"`
	// Configuration used to create this deployment.
	Config pulumi.StringPtrInput `pulumi:"config"`
	// Beginning of the lifetime of this deployment.
	DeployTime pulumi.StringInput `pulumi:"deployTime"`
	// Platform hosting this deployment.
	Platform DeploymentPlatformPtrInput `pulumi:"platform"`
	// End of the lifetime of this deployment.
	UndeployTime pulumi.StringPtrInput `pulumi:"undeployTime"`
	// Identity of the user that triggered this deployment.
	UserEmail pulumi.StringPtrInput `pulumi:"userEmail"`
}

func (DeploymentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Deployment)(nil)).Elem()
}

func (i DeploymentArgs) ToDeploymentOutput() DeploymentOutput {
	return i.ToDeploymentOutputWithContext(context.Background())
}

func (i DeploymentArgs) ToDeploymentOutputWithContext(ctx context.Context) DeploymentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentOutput)
}

func (i DeploymentArgs) ToDeploymentPtrOutput() DeploymentPtrOutput {
	return i.ToDeploymentPtrOutputWithContext(context.Background())
}

func (i DeploymentArgs) ToDeploymentPtrOutputWithContext(ctx context.Context) DeploymentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentOutput).ToDeploymentPtrOutputWithContext(ctx)
}

// DeploymentPtrInput is an input type that accepts DeploymentArgs, DeploymentPtr and DeploymentPtrOutput values.
// You can construct a concrete instance of `DeploymentPtrInput` via:
//
//          DeploymentArgs{...}
//
//  or:
//
//          nil
type DeploymentPtrInput interface {
	pulumi.Input

	ToDeploymentPtrOutput() DeploymentPtrOutput
	ToDeploymentPtrOutputWithContext(context.Context) DeploymentPtrOutput
}

type deploymentPtrType DeploymentArgs

func DeploymentPtr(v *DeploymentArgs) DeploymentPtrInput {
	return (*deploymentPtrType)(v)
}

func (*deploymentPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Deployment)(nil)).Elem()
}

func (i *deploymentPtrType) ToDeploymentPtrOutput() DeploymentPtrOutput {
	return i.ToDeploymentPtrOutputWithContext(context.Background())
}

func (i *deploymentPtrType) ToDeploymentPtrOutputWithContext(ctx context.Context) DeploymentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentPtrOutput)
}

// The period during which some deployable was active in a runtime.
type DeploymentOutput struct{ *pulumi.OutputState }

func (DeploymentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Deployment)(nil)).Elem()
}

func (o DeploymentOutput) ToDeploymentOutput() DeploymentOutput {
	return o
}

func (o DeploymentOutput) ToDeploymentOutputWithContext(ctx context.Context) DeploymentOutput {
	return o
}

func (o DeploymentOutput) ToDeploymentPtrOutput() DeploymentPtrOutput {
	return o.ToDeploymentPtrOutputWithContext(context.Background())
}

func (o DeploymentOutput) ToDeploymentPtrOutputWithContext(ctx context.Context) DeploymentPtrOutput {
	return o.ApplyT(func(v Deployment) *Deployment {
		return &v
	}).(DeploymentPtrOutput)
}

// Address of the runtime element hosting this deployment.
func (o DeploymentOutput) Address() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Deployment) *string { return v.Address }).(pulumi.StringPtrOutput)
}

// Configuration used to create this deployment.
func (o DeploymentOutput) Config() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Deployment) *string { return v.Config }).(pulumi.StringPtrOutput)
}

// Beginning of the lifetime of this deployment.
func (o DeploymentOutput) DeployTime() pulumi.StringOutput {
	return o.ApplyT(func(v Deployment) string { return v.DeployTime }).(pulumi.StringOutput)
}

// Platform hosting this deployment.
func (o DeploymentOutput) Platform() DeploymentPlatformPtrOutput {
	return o.ApplyT(func(v Deployment) *DeploymentPlatform { return v.Platform }).(DeploymentPlatformPtrOutput)
}

// End of the lifetime of this deployment.
func (o DeploymentOutput) UndeployTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Deployment) *string { return v.UndeployTime }).(pulumi.StringPtrOutput)
}

// Identity of the user that triggered this deployment.
func (o DeploymentOutput) UserEmail() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Deployment) *string { return v.UserEmail }).(pulumi.StringPtrOutput)
}

type DeploymentPtrOutput struct{ *pulumi.OutputState }

func (DeploymentPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Deployment)(nil)).Elem()
}

func (o DeploymentPtrOutput) ToDeploymentPtrOutput() DeploymentPtrOutput {
	return o
}

func (o DeploymentPtrOutput) ToDeploymentPtrOutputWithContext(ctx context.Context) DeploymentPtrOutput {
	return o
}

func (o DeploymentPtrOutput) Elem() DeploymentOutput {
	return o.ApplyT(func(v *Deployment) Deployment { return *v }).(DeploymentOutput)
}

// Address of the runtime element hosting this deployment.
func (o DeploymentPtrOutput) Address() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Deployment) *string {
		if v == nil {
			return nil
		}
		return v.Address
	}).(pulumi.StringPtrOutput)
}

// Configuration used to create this deployment.
func (o DeploymentPtrOutput) Config() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Deployment) *string {
		if v == nil {
			return nil
		}
		return v.Config
	}).(pulumi.StringPtrOutput)
}

// Beginning of the lifetime of this deployment.
func (o DeploymentPtrOutput) DeployTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Deployment) *string {
		if v == nil {
			return nil
		}
		return &v.DeployTime
	}).(pulumi.StringPtrOutput)
}

// Platform hosting this deployment.
func (o DeploymentPtrOutput) Platform() DeploymentPlatformPtrOutput {
	return o.ApplyT(func(v *Deployment) *DeploymentPlatform {
		if v == nil {
			return nil
		}
		return v.Platform
	}).(DeploymentPlatformPtrOutput)
}

// End of the lifetime of this deployment.
func (o DeploymentPtrOutput) UndeployTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Deployment) *string {
		if v == nil {
			return nil
		}
		return v.UndeployTime
	}).(pulumi.StringPtrOutput)
}

// Identity of the user that triggered this deployment.
func (o DeploymentPtrOutput) UserEmail() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Deployment) *string {
		if v == nil {
			return nil
		}
		return v.UserEmail
	}).(pulumi.StringPtrOutput)
}

// The period during which some deployable was active in a runtime.
type DeploymentResponse struct {
	// Address of the runtime element hosting this deployment.
	Address string `pulumi:"address"`
	// Configuration used to create this deployment.
	Config string `pulumi:"config"`
	// Beginning of the lifetime of this deployment.
	DeployTime string `pulumi:"deployTime"`
	// Platform hosting this deployment.
	Platform string `pulumi:"platform"`
	// Resource URI for the artifact being deployed taken from the deployable field with the same name.
	ResourceUri []string `pulumi:"resourceUri"`
	// End of the lifetime of this deployment.
	UndeployTime string `pulumi:"undeployTime"`
	// Identity of the user that triggered this deployment.
	UserEmail string `pulumi:"userEmail"`
}

// DeploymentResponseInput is an input type that accepts DeploymentResponseArgs and DeploymentResponseOutput values.
// You can construct a concrete instance of `DeploymentResponseInput` via:
//
//          DeploymentResponseArgs{...}
type DeploymentResponseInput interface {
	pulumi.Input

	ToDeploymentResponseOutput() DeploymentResponseOutput
	ToDeploymentResponseOutputWithContext(context.Context) DeploymentResponseOutput
}

// The period during which some deployable was active in a runtime.
type DeploymentResponseArgs struct {
	// Address of the runtime element hosting this deployment.
	Address pulumi.StringInput `pulumi:"address"`
	// Configuration used to create this deployment.
	Config pulumi.StringInput `pulumi:"config"`
	// Beginning of the lifetime of this deployment.
	DeployTime pulumi.StringInput `pulumi:"deployTime"`
	// Platform hosting this deployment.
	Platform pulumi.StringInput `pulumi:"platform"`
	// Resource URI for the artifact being deployed taken from the deployable field with the same name.
	ResourceUri pulumi.StringArrayInput `pulumi:"resourceUri"`
	// End of the lifetime of this deployment.
	UndeployTime pulumi.StringInput `pulumi:"undeployTime"`
	// Identity of the user that triggered this deployment.
	UserEmail pulumi.StringInput `pulumi:"userEmail"`
}

func (DeploymentResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentResponse)(nil)).Elem()
}

func (i DeploymentResponseArgs) ToDeploymentResponseOutput() DeploymentResponseOutput {
	return i.ToDeploymentResponseOutputWithContext(context.Background())
}

func (i DeploymentResponseArgs) ToDeploymentResponseOutputWithContext(ctx context.Context) DeploymentResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentResponseOutput)
}

func (i DeploymentResponseArgs) ToDeploymentResponsePtrOutput() DeploymentResponsePtrOutput {
	return i.ToDeploymentResponsePtrOutputWithContext(context.Background())
}

func (i DeploymentResponseArgs) ToDeploymentResponsePtrOutputWithContext(ctx context.Context) DeploymentResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentResponseOutput).ToDeploymentResponsePtrOutputWithContext(ctx)
}

// DeploymentResponsePtrInput is an input type that accepts DeploymentResponseArgs, DeploymentResponsePtr and DeploymentResponsePtrOutput values.
// You can construct a concrete instance of `DeploymentResponsePtrInput` via:
//
//          DeploymentResponseArgs{...}
//
//  or:
//
//          nil
type DeploymentResponsePtrInput interface {
	pulumi.Input

	ToDeploymentResponsePtrOutput() DeploymentResponsePtrOutput
	ToDeploymentResponsePtrOutputWithContext(context.Context) DeploymentResponsePtrOutput
}

type deploymentResponsePtrType DeploymentResponseArgs

func DeploymentResponsePtr(v *DeploymentResponseArgs) DeploymentResponsePtrInput {
	return (*deploymentResponsePtrType)(v)
}

func (*deploymentResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeploymentResponse)(nil)).Elem()
}

func (i *deploymentResponsePtrType) ToDeploymentResponsePtrOutput() DeploymentResponsePtrOutput {
	return i.ToDeploymentResponsePtrOutputWithContext(context.Background())
}

func (i *deploymentResponsePtrType) ToDeploymentResponsePtrOutputWithContext(ctx context.Context) DeploymentResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeploymentResponsePtrOutput)
}

// The period during which some deployable was active in a runtime.
type DeploymentResponseOutput struct{ *pulumi.OutputState }

func (DeploymentResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeploymentResponse)(nil)).Elem()
}

func (o DeploymentResponseOutput) ToDeploymentResponseOutput() DeploymentResponseOutput {
	return o
}

func (o DeploymentResponseOutput) ToDeploymentResponseOutputWithContext(ctx context.Context) DeploymentResponseOutput {
	return o
}

func (o DeploymentResponseOutput) ToDeploymentResponsePtrOutput() DeploymentResponsePtrOutput {
	return o.ToDeploymentResponsePtrOutputWithContext(context.Background())
}

func (o DeploymentResponseOutput) ToDeploymentResponsePtrOutputWithContext(ctx context.Context) DeploymentResponsePtrOutput {
	return o.ApplyT(func(v DeploymentResponse) *DeploymentResponse {
		return &v
	}).(DeploymentResponsePtrOutput)
}

// Address of the runtime element hosting this deployment.
func (o DeploymentResponseOutput) Address() pulumi.StringOutput {
	return o.ApplyT(func(v DeploymentResponse) string { return v.Address }).(pulumi.StringOutput)
}

// Configuration used to create this deployment.
func (o DeploymentResponseOutput) Config() pulumi.StringOutput {
	return o.ApplyT(func(v DeploymentResponse) string { return v.Config }).(pulumi.StringOutput)
}

// Beginning of the lifetime of this deployment.
func (o DeploymentResponseOutput) DeployTime() pulumi.StringOutput {
	return o.ApplyT(func(v DeploymentResponse) string { return v.DeployTime }).(pulumi.StringOutput)
}

// Platform hosting this deployment.
func (o DeploymentResponseOutput) Platform() pulumi.StringOutput {
	return o.ApplyT(func(v DeploymentResponse) string { return v.Platform }).(pulumi.StringOutput)
}

// Resource URI for the artifact being deployed taken from the deployable field with the same name.
func (o DeploymentResponseOutput) ResourceUri() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeploymentResponse) []string { return v.ResourceUri }).(pulumi.StringArrayOutput)
}

// End of the lifetime of this deployment.
func (o DeploymentResponseOutput) UndeployTime() pulumi.StringOutput {
	return o.ApplyT(func(v DeploymentResponse) string { return v.UndeployTime }).(pulumi.StringOutput)
}

// Identity of the user that triggered this deployment.
func (o DeploymentResponseOutput) UserEmail() pulumi.StringOutput {
	return o.ApplyT(func(v DeploymentResponse) string { return v.UserEmail }).(pulumi.StringOutput)
}

type DeploymentResponsePtrOutput struct{ *pulumi.OutputState }

func (DeploymentResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeploymentResponse)(nil)).Elem()
}

func (o DeploymentResponsePtrOutput) ToDeploymentResponsePtrOutput() DeploymentResponsePtrOutput {
	return o
}

func (o DeploymentResponsePtrOutput) ToDeploymentResponsePtrOutputWithContext(ctx context.Context) DeploymentResponsePtrOutput {
	return o
}

func (o DeploymentResponsePtrOutput) Elem() DeploymentResponseOutput {
	return o.ApplyT(func(v *DeploymentResponse) DeploymentResponse { return *v }).(DeploymentResponseOutput)
}

// Address of the runtime element hosting this deployment.
func (o DeploymentResponsePtrOutput) Address() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeploymentResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Address
	}).(pulumi.StringPtrOutput)
}

// Configuration used to create this deployment.
func (o DeploymentResponsePtrOutput) Config() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeploymentResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Config
	}).(pulumi.StringPtrOutput)
}

// Beginning of the lifetime of this deployment.
func (o DeploymentResponsePtrOutput) DeployTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeploymentResponse) *string {
		if v == nil {
			return nil
		}
		return &v.DeployTime
	}).(pulumi.StringPtrOutput)
}

// Platform hosting this deployment.
func (o DeploymentResponsePtrOutput) Platform() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeploymentResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Platform
	}).(pulumi.StringPtrOutput)
}

// Resource URI for the artifact being deployed taken from the deployable field with the same name.
func (o DeploymentResponsePtrOutput) ResourceUri() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DeploymentResponse) []string {
		if v == nil {
			return nil
		}
		return v.ResourceUri
	}).(pulumi.StringArrayOutput)
}

// End of the lifetime of this deployment.
func (o DeploymentResponsePtrOutput) UndeployTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeploymentResponse) *string {
		if v == nil {
			return nil
		}
		return &v.UndeployTime
	}).(pulumi.StringPtrOutput)
}

// Identity of the user that triggered this deployment.
func (o DeploymentResponsePtrOutput) UserEmail() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeploymentResponse) *string {
		if v == nil {
			return nil
		}
		return &v.UserEmail
	}).(pulumi.StringPtrOutput)
}

// Derived describes the derived image portion (Occurrence) of the DockerImage relationship. This image would be produced from a Dockerfile with FROM .
type Derived struct {
	// The fingerprint of the derived image.
	Fingerprint Fingerprint `pulumi:"fingerprint"`
	// This contains layer-specific metadata, if populated it has length "distance" and is ordered with [distance] being the layer immediately following the base image and [1] being the final layer.
	LayerInfo []Layer `pulumi:"layerInfo"`
}

// DerivedInput is an input type that accepts DerivedArgs and DerivedOutput values.
// You can construct a concrete instance of `DerivedInput` via:
//
//          DerivedArgs{...}
type DerivedInput interface {
	pulumi.Input

	ToDerivedOutput() DerivedOutput
	ToDerivedOutputWithContext(context.Context) DerivedOutput
}

// Derived describes the derived image portion (Occurrence) of the DockerImage relationship. This image would be produced from a Dockerfile with FROM .
type DerivedArgs struct {
	// The fingerprint of the derived image.
	Fingerprint FingerprintInput `pulumi:"fingerprint"`
	// This contains layer-specific metadata, if populated it has length "distance" and is ordered with [distance] being the layer immediately following the base image and [1] being the final layer.
	LayerInfo LayerArrayInput `pulumi:"layerInfo"`
}

func (DerivedArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Derived)(nil)).Elem()
}

func (i DerivedArgs) ToDerivedOutput() DerivedOutput {
	return i.ToDerivedOutputWithContext(context.Background())
}

func (i DerivedArgs) ToDerivedOutputWithContext(ctx context.Context) DerivedOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DerivedOutput)
}

func (i DerivedArgs) ToDerivedPtrOutput() DerivedPtrOutput {
	return i.ToDerivedPtrOutputWithContext(context.Background())
}

func (i DerivedArgs) ToDerivedPtrOutputWithContext(ctx context.Context) DerivedPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DerivedOutput).ToDerivedPtrOutputWithContext(ctx)
}

// DerivedPtrInput is an input type that accepts DerivedArgs, DerivedPtr and DerivedPtrOutput values.
// You can construct a concrete instance of `DerivedPtrInput` via:
//
//          DerivedArgs{...}
//
//  or:
//
//          nil
type DerivedPtrInput interface {
	pulumi.Input

	ToDerivedPtrOutput() DerivedPtrOutput
	ToDerivedPtrOutputWithContext(context.Context) DerivedPtrOutput
}

type derivedPtrType DerivedArgs

func DerivedPtr(v *DerivedArgs) DerivedPtrInput {
	return (*derivedPtrType)(v)
}

func (*derivedPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Derived)(nil)).Elem()
}

func (i *derivedPtrType) ToDerivedPtrOutput() DerivedPtrOutput {
	return i.ToDerivedPtrOutputWithContext(context.Background())
}

func (i *derivedPtrType) ToDerivedPtrOutputWithContext(ctx context.Context) DerivedPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DerivedPtrOutput)
}

// Derived describes the derived image portion (Occurrence) of the DockerImage relationship. This image would be produced from a Dockerfile with FROM .
type DerivedOutput struct{ *pulumi.OutputState }

func (DerivedOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Derived)(nil)).Elem()
}

func (o DerivedOutput) ToDerivedOutput() DerivedOutput {
	return o
}

func (o DerivedOutput) ToDerivedOutputWithContext(ctx context.Context) DerivedOutput {
	return o
}

func (o DerivedOutput) ToDerivedPtrOutput() DerivedPtrOutput {
	return o.ToDerivedPtrOutputWithContext(context.Background())
}

func (o DerivedOutput) ToDerivedPtrOutputWithContext(ctx context.Context) DerivedPtrOutput {
	return o.ApplyT(func(v Derived) *Derived {
		return &v
	}).(DerivedPtrOutput)
}

// The fingerprint of the derived image.
func (o DerivedOutput) Fingerprint() FingerprintOutput {
	return o.ApplyT(func(v Derived) Fingerprint { return v.Fingerprint }).(FingerprintOutput)
}

// This contains layer-specific metadata, if populated it has length "distance" and is ordered with [distance] being the layer immediately following the base image and [1] being the final layer.
func (o DerivedOutput) LayerInfo() LayerArrayOutput {
	return o.ApplyT(func(v Derived) []Layer { return v.LayerInfo }).(LayerArrayOutput)
}

type DerivedPtrOutput struct{ *pulumi.OutputState }

func (DerivedPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Derived)(nil)).Elem()
}

func (o DerivedPtrOutput) ToDerivedPtrOutput() DerivedPtrOutput {
	return o
}

func (o DerivedPtrOutput) ToDerivedPtrOutputWithContext(ctx context.Context) DerivedPtrOutput {
	return o
}

func (o DerivedPtrOutput) Elem() DerivedOutput {
	return o.ApplyT(func(v *Derived) Derived { return *v }).(DerivedOutput)
}

// The fingerprint of the derived image.
func (o DerivedPtrOutput) Fingerprint() FingerprintPtrOutput {
	return o.ApplyT(func(v *Derived) *Fingerprint {
		if v == nil {
			return nil
		}
		return &v.Fingerprint
	}).(FingerprintPtrOutput)
}

// This contains layer-specific metadata, if populated it has length "distance" and is ordered with [distance] being the layer immediately following the base image and [1] being the final layer.
func (o DerivedPtrOutput) LayerInfo() LayerArrayOutput {
	return o.ApplyT(func(v *Derived) []Layer {
		if v == nil {
			return nil
		}
		return v.LayerInfo
	}).(LayerArrayOutput)
}

// Derived describes the derived image portion (Occurrence) of the DockerImage relationship. This image would be produced from a Dockerfile with FROM .
type DerivedResponse struct {
	// This contains the base image URL for the derived image occurrence.
	BaseResourceUrl string `pulumi:"baseResourceUrl"`
	// The number of layers by which this image differs from the associated image basis.
	Distance int `pulumi:"distance"`
	// The fingerprint of the derived image.
	Fingerprint FingerprintResponse `pulumi:"fingerprint"`
	// This contains layer-specific metadata, if populated it has length "distance" and is ordered with [distance] being the layer immediately following the base image and [1] being the final layer.
	LayerInfo []LayerResponse `pulumi:"layerInfo"`
}

// DerivedResponseInput is an input type that accepts DerivedResponseArgs and DerivedResponseOutput values.
// You can construct a concrete instance of `DerivedResponseInput` via:
//
//          DerivedResponseArgs{...}
type DerivedResponseInput interface {
	pulumi.Input

	ToDerivedResponseOutput() DerivedResponseOutput
	ToDerivedResponseOutputWithContext(context.Context) DerivedResponseOutput
}

// Derived describes the derived image portion (Occurrence) of the DockerImage relationship. This image would be produced from a Dockerfile with FROM .
type DerivedResponseArgs struct {
	// This contains the base image URL for the derived image occurrence.
	BaseResourceUrl pulumi.StringInput `pulumi:"baseResourceUrl"`
	// The number of layers by which this image differs from the associated image basis.
	Distance pulumi.IntInput `pulumi:"distance"`
	// The fingerprint of the derived image.
	Fingerprint FingerprintResponseInput `pulumi:"fingerprint"`
	// This contains layer-specific metadata, if populated it has length "distance" and is ordered with [distance] being the layer immediately following the base image and [1] being the final layer.
	LayerInfo LayerResponseArrayInput `pulumi:"layerInfo"`
}

func (DerivedResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DerivedResponse)(nil)).Elem()
}

func (i DerivedResponseArgs) ToDerivedResponseOutput() DerivedResponseOutput {
	return i.ToDerivedResponseOutputWithContext(context.Background())
}

func (i DerivedResponseArgs) ToDerivedResponseOutputWithContext(ctx context.Context) DerivedResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DerivedResponseOutput)
}

func (i DerivedResponseArgs) ToDerivedResponsePtrOutput() DerivedResponsePtrOutput {
	return i.ToDerivedResponsePtrOutputWithContext(context.Background())
}

func (i DerivedResponseArgs) ToDerivedResponsePtrOutputWithContext(ctx context.Context) DerivedResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DerivedResponseOutput).ToDerivedResponsePtrOutputWithContext(ctx)
}

// DerivedResponsePtrInput is an input type that accepts DerivedResponseArgs, DerivedResponsePtr and DerivedResponsePtrOutput values.
// You can construct a concrete instance of `DerivedResponsePtrInput` via:
//
//          DerivedResponseArgs{...}
//
//  or:
//
//          nil
type DerivedResponsePtrInput interface {
	pulumi.Input

	ToDerivedResponsePtrOutput() DerivedResponsePtrOutput
	ToDerivedResponsePtrOutputWithContext(context.Context) DerivedResponsePtrOutput
}

type derivedResponsePtrType DerivedResponseArgs

func DerivedResponsePtr(v *DerivedResponseArgs) DerivedResponsePtrInput {
	return (*derivedResponsePtrType)(v)
}

func (*derivedResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DerivedResponse)(nil)).Elem()
}

func (i *derivedResponsePtrType) ToDerivedResponsePtrOutput() DerivedResponsePtrOutput {
	return i.ToDerivedResponsePtrOutputWithContext(context.Background())
}

func (i *derivedResponsePtrType) ToDerivedResponsePtrOutputWithContext(ctx context.Context) DerivedResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DerivedResponsePtrOutput)
}

// Derived describes the derived image portion (Occurrence) of the DockerImage relationship. This image would be produced from a Dockerfile with FROM .
type DerivedResponseOutput struct{ *pulumi.OutputState }

func (DerivedResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DerivedResponse)(nil)).Elem()
}

func (o DerivedResponseOutput) ToDerivedResponseOutput() DerivedResponseOutput {
	return o
}

func (o DerivedResponseOutput) ToDerivedResponseOutputWithContext(ctx context.Context) DerivedResponseOutput {
	return o
}

func (o DerivedResponseOutput) ToDerivedResponsePtrOutput() DerivedResponsePtrOutput {
	return o.ToDerivedResponsePtrOutputWithContext(context.Background())
}

func (o DerivedResponseOutput) ToDerivedResponsePtrOutputWithContext(ctx context.Context) DerivedResponsePtrOutput {
	return o.ApplyT(func(v DerivedResponse) *DerivedResponse {
		return &v
	}).(DerivedResponsePtrOutput)
}

// This contains the base image URL for the derived image occurrence.
func (o DerivedResponseOutput) BaseResourceUrl() pulumi.StringOutput {
	return o.ApplyT(func(v DerivedResponse) string { return v.BaseResourceUrl }).(pulumi.StringOutput)
}

// The number of layers by which this image differs from the associated image basis.
func (o DerivedResponseOutput) Distance() pulumi.IntOutput {
	return o.ApplyT(func(v DerivedResponse) int { return v.Distance }).(pulumi.IntOutput)
}

// The fingerprint of the derived image.
func (o DerivedResponseOutput) Fingerprint() FingerprintResponseOutput {
	return o.ApplyT(func(v DerivedResponse) FingerprintResponse { return v.Fingerprint }).(FingerprintResponseOutput)
}

// This contains layer-specific metadata, if populated it has length "distance" and is ordered with [distance] being the layer immediately following the base image and [1] being the final layer.
func (o DerivedResponseOutput) LayerInfo() LayerResponseArrayOutput {
	return o.ApplyT(func(v DerivedResponse) []LayerResponse { return v.LayerInfo }).(LayerResponseArrayOutput)
}

type DerivedResponsePtrOutput struct{ *pulumi.OutputState }

func (DerivedResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DerivedResponse)(nil)).Elem()
}

func (o DerivedResponsePtrOutput) ToDerivedResponsePtrOutput() DerivedResponsePtrOutput {
	return o
}

func (o DerivedResponsePtrOutput) ToDerivedResponsePtrOutputWithContext(ctx context.Context) DerivedResponsePtrOutput {
	return o
}

func (o DerivedResponsePtrOutput) Elem() DerivedResponseOutput {
	return o.ApplyT(func(v *DerivedResponse) DerivedResponse { return *v }).(DerivedResponseOutput)
}

// This contains the base image URL for the derived image occurrence.
func (o DerivedResponsePtrOutput) BaseResourceUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DerivedResponse) *string {
		if v == nil {
			return nil
		}
		return &v.BaseResourceUrl
	}).(pulumi.StringPtrOutput)
}

// The number of layers by which this image differs from the associated image basis.
func (o DerivedResponsePtrOutput) Distance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DerivedResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Distance
	}).(pulumi.IntPtrOutput)
}

// The fingerprint of the derived image.
func (o DerivedResponsePtrOutput) Fingerprint() FingerprintResponsePtrOutput {
	return o.ApplyT(func(v *DerivedResponse) *FingerprintResponse {
		if v == nil {
			return nil
		}
		return &v.Fingerprint
	}).(FingerprintResponsePtrOutput)
}

// This contains layer-specific metadata, if populated it has length "distance" and is ordered with [distance] being the layer immediately following the base image and [1] being the final layer.
func (o DerivedResponsePtrOutput) LayerInfo() LayerResponseArrayOutput {
	return o.ApplyT(func(v *DerivedResponse) []LayerResponse {
		if v == nil {
			return nil
		}
		return v.LayerInfo
	}).(LayerResponseArrayOutput)
}

// Identifies all appearances of this vulnerability in the package for a specific distro/location. For example: glibc in cpe:/o:debian:debian_linux:8 for versions 2.1 - 2.2
type Detail struct {
	// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) in which the vulnerability manifests. Examples include distro or storage location for vulnerable jar.
	CpeUri string `pulumi:"cpeUri"`
	// A vendor-specific description of this note.
	Description *string `pulumi:"description"`
	// The fix for this specific package version.
	FixedLocation *VulnerabilityLocation `pulumi:"fixedLocation"`
	// Whether this detail is obsolete. Occurrences are expected not to point to obsolete details.
	IsObsolete *bool `pulumi:"isObsolete"`
	// The max version of the package in which the vulnerability exists.
	MaxAffectedVersion *Version `pulumi:"maxAffectedVersion"`
	// The min version of the package in which the vulnerability exists.
	MinAffectedVersion *Version `pulumi:"minAffectedVersion"`
	// The name of the package where the vulnerability was found.
	Package string `pulumi:"package"`
	// The type of package; whether native or non native(ruby gems, node.js packages etc).
	PackageType *string `pulumi:"packageType"`
	// The severity (eg: distro assigned severity) for this vulnerability.
	SeverityName *string `pulumi:"severityName"`
	// The source from which the information in this Detail was obtained.
	Source *string `pulumi:"source"`
	// The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.
	SourceUpdateTime *string `pulumi:"sourceUpdateTime"`
	// The name of the vendor of the product.
	Vendor *string `pulumi:"vendor"`
}

// DetailInput is an input type that accepts DetailArgs and DetailOutput values.
// You can construct a concrete instance of `DetailInput` via:
//
//          DetailArgs{...}
type DetailInput interface {
	pulumi.Input

	ToDetailOutput() DetailOutput
	ToDetailOutputWithContext(context.Context) DetailOutput
}

// Identifies all appearances of this vulnerability in the package for a specific distro/location. For example: glibc in cpe:/o:debian:debian_linux:8 for versions 2.1 - 2.2
type DetailArgs struct {
	// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) in which the vulnerability manifests. Examples include distro or storage location for vulnerable jar.
	CpeUri pulumi.StringInput `pulumi:"cpeUri"`
	// A vendor-specific description of this note.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// The fix for this specific package version.
	FixedLocation VulnerabilityLocationPtrInput `pulumi:"fixedLocation"`
	// Whether this detail is obsolete. Occurrences are expected not to point to obsolete details.
	IsObsolete pulumi.BoolPtrInput `pulumi:"isObsolete"`
	// The max version of the package in which the vulnerability exists.
	MaxAffectedVersion VersionPtrInput `pulumi:"maxAffectedVersion"`
	// The min version of the package in which the vulnerability exists.
	MinAffectedVersion VersionPtrInput `pulumi:"minAffectedVersion"`
	// The name of the package where the vulnerability was found.
	Package pulumi.StringInput `pulumi:"package"`
	// The type of package; whether native or non native(ruby gems, node.js packages etc).
	PackageType pulumi.StringPtrInput `pulumi:"packageType"`
	// The severity (eg: distro assigned severity) for this vulnerability.
	SeverityName pulumi.StringPtrInput `pulumi:"severityName"`
	// The source from which the information in this Detail was obtained.
	Source pulumi.StringPtrInput `pulumi:"source"`
	// The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.
	SourceUpdateTime pulumi.StringPtrInput `pulumi:"sourceUpdateTime"`
	// The name of the vendor of the product.
	Vendor pulumi.StringPtrInput `pulumi:"vendor"`
}

func (DetailArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Detail)(nil)).Elem()
}

func (i DetailArgs) ToDetailOutput() DetailOutput {
	return i.ToDetailOutputWithContext(context.Background())
}

func (i DetailArgs) ToDetailOutputWithContext(ctx context.Context) DetailOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetailOutput)
}

// DetailArrayInput is an input type that accepts DetailArray and DetailArrayOutput values.
// You can construct a concrete instance of `DetailArrayInput` via:
//
//          DetailArray{ DetailArgs{...} }
type DetailArrayInput interface {
	pulumi.Input

	ToDetailArrayOutput() DetailArrayOutput
	ToDetailArrayOutputWithContext(context.Context) DetailArrayOutput
}

type DetailArray []DetailInput

func (DetailArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Detail)(nil)).Elem()
}

func (i DetailArray) ToDetailArrayOutput() DetailArrayOutput {
	return i.ToDetailArrayOutputWithContext(context.Background())
}

func (i DetailArray) ToDetailArrayOutputWithContext(ctx context.Context) DetailArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetailArrayOutput)
}

// Identifies all appearances of this vulnerability in the package for a specific distro/location. For example: glibc in cpe:/o:debian:debian_linux:8 for versions 2.1 - 2.2
type DetailOutput struct{ *pulumi.OutputState }

func (DetailOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Detail)(nil)).Elem()
}

func (o DetailOutput) ToDetailOutput() DetailOutput {
	return o
}

func (o DetailOutput) ToDetailOutputWithContext(ctx context.Context) DetailOutput {
	return o
}

// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) in which the vulnerability manifests. Examples include distro or storage location for vulnerable jar.
func (o DetailOutput) CpeUri() pulumi.StringOutput {
	return o.ApplyT(func(v Detail) string { return v.CpeUri }).(pulumi.StringOutput)
}

// A vendor-specific description of this note.
func (o DetailOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Detail) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The fix for this specific package version.
func (o DetailOutput) FixedLocation() VulnerabilityLocationPtrOutput {
	return o.ApplyT(func(v Detail) *VulnerabilityLocation { return v.FixedLocation }).(VulnerabilityLocationPtrOutput)
}

// Whether this detail is obsolete. Occurrences are expected not to point to obsolete details.
func (o DetailOutput) IsObsolete() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Detail) *bool { return v.IsObsolete }).(pulumi.BoolPtrOutput)
}

// The max version of the package in which the vulnerability exists.
func (o DetailOutput) MaxAffectedVersion() VersionPtrOutput {
	return o.ApplyT(func(v Detail) *Version { return v.MaxAffectedVersion }).(VersionPtrOutput)
}

// The min version of the package in which the vulnerability exists.
func (o DetailOutput) MinAffectedVersion() VersionPtrOutput {
	return o.ApplyT(func(v Detail) *Version { return v.MinAffectedVersion }).(VersionPtrOutput)
}

// The name of the package where the vulnerability was found.
func (o DetailOutput) Package() pulumi.StringOutput {
	return o.ApplyT(func(v Detail) string { return v.Package }).(pulumi.StringOutput)
}

// The type of package; whether native or non native(ruby gems, node.js packages etc).
func (o DetailOutput) PackageType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Detail) *string { return v.PackageType }).(pulumi.StringPtrOutput)
}

// The severity (eg: distro assigned severity) for this vulnerability.
func (o DetailOutput) SeverityName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Detail) *string { return v.SeverityName }).(pulumi.StringPtrOutput)
}

// The source from which the information in this Detail was obtained.
func (o DetailOutput) Source() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Detail) *string { return v.Source }).(pulumi.StringPtrOutput)
}

// The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.
func (o DetailOutput) SourceUpdateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Detail) *string { return v.SourceUpdateTime }).(pulumi.StringPtrOutput)
}

// The name of the vendor of the product.
func (o DetailOutput) Vendor() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Detail) *string { return v.Vendor }).(pulumi.StringPtrOutput)
}

type DetailArrayOutput struct{ *pulumi.OutputState }

func (DetailArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Detail)(nil)).Elem()
}

func (o DetailArrayOutput) ToDetailArrayOutput() DetailArrayOutput {
	return o
}

func (o DetailArrayOutput) ToDetailArrayOutputWithContext(ctx context.Context) DetailArrayOutput {
	return o
}

func (o DetailArrayOutput) Index(i pulumi.IntInput) DetailOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Detail {
		return vs[0].([]Detail)[vs[1].(int)]
	}).(DetailOutput)
}

// Identifies all appearances of this vulnerability in the package for a specific distro/location. For example: glibc in cpe:/o:debian:debian_linux:8 for versions 2.1 - 2.2
type DetailResponse struct {
	// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) in which the vulnerability manifests. Examples include distro or storage location for vulnerable jar.
	CpeUri string `pulumi:"cpeUri"`
	// A vendor-specific description of this note.
	Description string `pulumi:"description"`
	// The fix for this specific package version.
	FixedLocation VulnerabilityLocationResponse `pulumi:"fixedLocation"`
	// Whether this detail is obsolete. Occurrences are expected not to point to obsolete details.
	IsObsolete bool `pulumi:"isObsolete"`
	// The max version of the package in which the vulnerability exists.
	MaxAffectedVersion VersionResponse `pulumi:"maxAffectedVersion"`
	// The min version of the package in which the vulnerability exists.
	MinAffectedVersion VersionResponse `pulumi:"minAffectedVersion"`
	// The name of the package where the vulnerability was found.
	Package string `pulumi:"package"`
	// The type of package; whether native or non native(ruby gems, node.js packages etc).
	PackageType string `pulumi:"packageType"`
	// The severity (eg: distro assigned severity) for this vulnerability.
	SeverityName string `pulumi:"severityName"`
	// The source from which the information in this Detail was obtained.
	Source string `pulumi:"source"`
	// The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.
	SourceUpdateTime string `pulumi:"sourceUpdateTime"`
	// The name of the vendor of the product.
	Vendor string `pulumi:"vendor"`
}

// DetailResponseInput is an input type that accepts DetailResponseArgs and DetailResponseOutput values.
// You can construct a concrete instance of `DetailResponseInput` via:
//
//          DetailResponseArgs{...}
type DetailResponseInput interface {
	pulumi.Input

	ToDetailResponseOutput() DetailResponseOutput
	ToDetailResponseOutputWithContext(context.Context) DetailResponseOutput
}

// Identifies all appearances of this vulnerability in the package for a specific distro/location. For example: glibc in cpe:/o:debian:debian_linux:8 for versions 2.1 - 2.2
type DetailResponseArgs struct {
	// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) in which the vulnerability manifests. Examples include distro or storage location for vulnerable jar.
	CpeUri pulumi.StringInput `pulumi:"cpeUri"`
	// A vendor-specific description of this note.
	Description pulumi.StringInput `pulumi:"description"`
	// The fix for this specific package version.
	FixedLocation VulnerabilityLocationResponseInput `pulumi:"fixedLocation"`
	// Whether this detail is obsolete. Occurrences are expected not to point to obsolete details.
	IsObsolete pulumi.BoolInput `pulumi:"isObsolete"`
	// The max version of the package in which the vulnerability exists.
	MaxAffectedVersion VersionResponseInput `pulumi:"maxAffectedVersion"`
	// The min version of the package in which the vulnerability exists.
	MinAffectedVersion VersionResponseInput `pulumi:"minAffectedVersion"`
	// The name of the package where the vulnerability was found.
	Package pulumi.StringInput `pulumi:"package"`
	// The type of package; whether native or non native(ruby gems, node.js packages etc).
	PackageType pulumi.StringInput `pulumi:"packageType"`
	// The severity (eg: distro assigned severity) for this vulnerability.
	SeverityName pulumi.StringInput `pulumi:"severityName"`
	// The source from which the information in this Detail was obtained.
	Source pulumi.StringInput `pulumi:"source"`
	// The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.
	SourceUpdateTime pulumi.StringInput `pulumi:"sourceUpdateTime"`
	// The name of the vendor of the product.
	Vendor pulumi.StringInput `pulumi:"vendor"`
}

func (DetailResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DetailResponse)(nil)).Elem()
}

func (i DetailResponseArgs) ToDetailResponseOutput() DetailResponseOutput {
	return i.ToDetailResponseOutputWithContext(context.Background())
}

func (i DetailResponseArgs) ToDetailResponseOutputWithContext(ctx context.Context) DetailResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetailResponseOutput)
}

// DetailResponseArrayInput is an input type that accepts DetailResponseArray and DetailResponseArrayOutput values.
// You can construct a concrete instance of `DetailResponseArrayInput` via:
//
//          DetailResponseArray{ DetailResponseArgs{...} }
type DetailResponseArrayInput interface {
	pulumi.Input

	ToDetailResponseArrayOutput() DetailResponseArrayOutput
	ToDetailResponseArrayOutputWithContext(context.Context) DetailResponseArrayOutput
}

type DetailResponseArray []DetailResponseInput

func (DetailResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DetailResponse)(nil)).Elem()
}

func (i DetailResponseArray) ToDetailResponseArrayOutput() DetailResponseArrayOutput {
	return i.ToDetailResponseArrayOutputWithContext(context.Background())
}

func (i DetailResponseArray) ToDetailResponseArrayOutputWithContext(ctx context.Context) DetailResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetailResponseArrayOutput)
}

// Identifies all appearances of this vulnerability in the package for a specific distro/location. For example: glibc in cpe:/o:debian:debian_linux:8 for versions 2.1 - 2.2
type DetailResponseOutput struct{ *pulumi.OutputState }

func (DetailResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DetailResponse)(nil)).Elem()
}

func (o DetailResponseOutput) ToDetailResponseOutput() DetailResponseOutput {
	return o
}

func (o DetailResponseOutput) ToDetailResponseOutputWithContext(ctx context.Context) DetailResponseOutput {
	return o
}

// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) in which the vulnerability manifests. Examples include distro or storage location for vulnerable jar.
func (o DetailResponseOutput) CpeUri() pulumi.StringOutput {
	return o.ApplyT(func(v DetailResponse) string { return v.CpeUri }).(pulumi.StringOutput)
}

// A vendor-specific description of this note.
func (o DetailResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v DetailResponse) string { return v.Description }).(pulumi.StringOutput)
}

// The fix for this specific package version.
func (o DetailResponseOutput) FixedLocation() VulnerabilityLocationResponseOutput {
	return o.ApplyT(func(v DetailResponse) VulnerabilityLocationResponse { return v.FixedLocation }).(VulnerabilityLocationResponseOutput)
}

// Whether this detail is obsolete. Occurrences are expected not to point to obsolete details.
func (o DetailResponseOutput) IsObsolete() pulumi.BoolOutput {
	return o.ApplyT(func(v DetailResponse) bool { return v.IsObsolete }).(pulumi.BoolOutput)
}

// The max version of the package in which the vulnerability exists.
func (o DetailResponseOutput) MaxAffectedVersion() VersionResponseOutput {
	return o.ApplyT(func(v DetailResponse) VersionResponse { return v.MaxAffectedVersion }).(VersionResponseOutput)
}

// The min version of the package in which the vulnerability exists.
func (o DetailResponseOutput) MinAffectedVersion() VersionResponseOutput {
	return o.ApplyT(func(v DetailResponse) VersionResponse { return v.MinAffectedVersion }).(VersionResponseOutput)
}

// The name of the package where the vulnerability was found.
func (o DetailResponseOutput) Package() pulumi.StringOutput {
	return o.ApplyT(func(v DetailResponse) string { return v.Package }).(pulumi.StringOutput)
}

// The type of package; whether native or non native(ruby gems, node.js packages etc).
func (o DetailResponseOutput) PackageType() pulumi.StringOutput {
	return o.ApplyT(func(v DetailResponse) string { return v.PackageType }).(pulumi.StringOutput)
}

// The severity (eg: distro assigned severity) for this vulnerability.
func (o DetailResponseOutput) SeverityName() pulumi.StringOutput {
	return o.ApplyT(func(v DetailResponse) string { return v.SeverityName }).(pulumi.StringOutput)
}

// The source from which the information in this Detail was obtained.
func (o DetailResponseOutput) Source() pulumi.StringOutput {
	return o.ApplyT(func(v DetailResponse) string { return v.Source }).(pulumi.StringOutput)
}

// The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.
func (o DetailResponseOutput) SourceUpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v DetailResponse) string { return v.SourceUpdateTime }).(pulumi.StringOutput)
}

// The name of the vendor of the product.
func (o DetailResponseOutput) Vendor() pulumi.StringOutput {
	return o.ApplyT(func(v DetailResponse) string { return v.Vendor }).(pulumi.StringOutput)
}

type DetailResponseArrayOutput struct{ *pulumi.OutputState }

func (DetailResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DetailResponse)(nil)).Elem()
}

func (o DetailResponseArrayOutput) ToDetailResponseArrayOutput() DetailResponseArrayOutput {
	return o
}

func (o DetailResponseArrayOutput) ToDetailResponseArrayOutputWithContext(ctx context.Context) DetailResponseArrayOutput {
	return o
}

func (o DetailResponseArrayOutput) Index(i pulumi.IntInput) DetailResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DetailResponse {
		return vs[0].([]DetailResponse)[vs[1].(int)]
	}).(DetailResponseOutput)
}

// Details of an attestation occurrence.
type Details struct {
	// Attestation for the resource.
	Attestation Attestation `pulumi:"attestation"`
}

// DetailsInput is an input type that accepts DetailsArgs and DetailsOutput values.
// You can construct a concrete instance of `DetailsInput` via:
//
//          DetailsArgs{...}
type DetailsInput interface {
	pulumi.Input

	ToDetailsOutput() DetailsOutput
	ToDetailsOutputWithContext(context.Context) DetailsOutput
}

// Details of an attestation occurrence.
type DetailsArgs struct {
	// Attestation for the resource.
	Attestation AttestationInput `pulumi:"attestation"`
}

func (DetailsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Details)(nil)).Elem()
}

func (i DetailsArgs) ToDetailsOutput() DetailsOutput {
	return i.ToDetailsOutputWithContext(context.Background())
}

func (i DetailsArgs) ToDetailsOutputWithContext(ctx context.Context) DetailsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetailsOutput)
}

func (i DetailsArgs) ToDetailsPtrOutput() DetailsPtrOutput {
	return i.ToDetailsPtrOutputWithContext(context.Background())
}

func (i DetailsArgs) ToDetailsPtrOutputWithContext(ctx context.Context) DetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetailsOutput).ToDetailsPtrOutputWithContext(ctx)
}

// DetailsPtrInput is an input type that accepts DetailsArgs, DetailsPtr and DetailsPtrOutput values.
// You can construct a concrete instance of `DetailsPtrInput` via:
//
//          DetailsArgs{...}
//
//  or:
//
//          nil
type DetailsPtrInput interface {
	pulumi.Input

	ToDetailsPtrOutput() DetailsPtrOutput
	ToDetailsPtrOutputWithContext(context.Context) DetailsPtrOutput
}

type detailsPtrType DetailsArgs

func DetailsPtr(v *DetailsArgs) DetailsPtrInput {
	return (*detailsPtrType)(v)
}

func (*detailsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Details)(nil)).Elem()
}

func (i *detailsPtrType) ToDetailsPtrOutput() DetailsPtrOutput {
	return i.ToDetailsPtrOutputWithContext(context.Background())
}

func (i *detailsPtrType) ToDetailsPtrOutputWithContext(ctx context.Context) DetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetailsPtrOutput)
}

// Details of an attestation occurrence.
type DetailsOutput struct{ *pulumi.OutputState }

func (DetailsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Details)(nil)).Elem()
}

func (o DetailsOutput) ToDetailsOutput() DetailsOutput {
	return o
}

func (o DetailsOutput) ToDetailsOutputWithContext(ctx context.Context) DetailsOutput {
	return o
}

func (o DetailsOutput) ToDetailsPtrOutput() DetailsPtrOutput {
	return o.ToDetailsPtrOutputWithContext(context.Background())
}

func (o DetailsOutput) ToDetailsPtrOutputWithContext(ctx context.Context) DetailsPtrOutput {
	return o.ApplyT(func(v Details) *Details {
		return &v
	}).(DetailsPtrOutput)
}

// Attestation for the resource.
func (o DetailsOutput) Attestation() AttestationOutput {
	return o.ApplyT(func(v Details) Attestation { return v.Attestation }).(AttestationOutput)
}

type DetailsPtrOutput struct{ *pulumi.OutputState }

func (DetailsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Details)(nil)).Elem()
}

func (o DetailsPtrOutput) ToDetailsPtrOutput() DetailsPtrOutput {
	return o
}

func (o DetailsPtrOutput) ToDetailsPtrOutputWithContext(ctx context.Context) DetailsPtrOutput {
	return o
}

func (o DetailsPtrOutput) Elem() DetailsOutput {
	return o.ApplyT(func(v *Details) Details { return *v }).(DetailsOutput)
}

// Attestation for the resource.
func (o DetailsPtrOutput) Attestation() AttestationPtrOutput {
	return o.ApplyT(func(v *Details) *Attestation {
		if v == nil {
			return nil
		}
		return &v.Attestation
	}).(AttestationPtrOutput)
}

// Details of an attestation occurrence.
type DetailsResponse struct {
	// Attestation for the resource.
	Attestation AttestationResponse `pulumi:"attestation"`
}

// DetailsResponseInput is an input type that accepts DetailsResponseArgs and DetailsResponseOutput values.
// You can construct a concrete instance of `DetailsResponseInput` via:
//
//          DetailsResponseArgs{...}
type DetailsResponseInput interface {
	pulumi.Input

	ToDetailsResponseOutput() DetailsResponseOutput
	ToDetailsResponseOutputWithContext(context.Context) DetailsResponseOutput
}

// Details of an attestation occurrence.
type DetailsResponseArgs struct {
	// Attestation for the resource.
	Attestation AttestationResponseInput `pulumi:"attestation"`
}

func (DetailsResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DetailsResponse)(nil)).Elem()
}

func (i DetailsResponseArgs) ToDetailsResponseOutput() DetailsResponseOutput {
	return i.ToDetailsResponseOutputWithContext(context.Background())
}

func (i DetailsResponseArgs) ToDetailsResponseOutputWithContext(ctx context.Context) DetailsResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetailsResponseOutput)
}

func (i DetailsResponseArgs) ToDetailsResponsePtrOutput() DetailsResponsePtrOutput {
	return i.ToDetailsResponsePtrOutputWithContext(context.Background())
}

func (i DetailsResponseArgs) ToDetailsResponsePtrOutputWithContext(ctx context.Context) DetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetailsResponseOutput).ToDetailsResponsePtrOutputWithContext(ctx)
}

// DetailsResponsePtrInput is an input type that accepts DetailsResponseArgs, DetailsResponsePtr and DetailsResponsePtrOutput values.
// You can construct a concrete instance of `DetailsResponsePtrInput` via:
//
//          DetailsResponseArgs{...}
//
//  or:
//
//          nil
type DetailsResponsePtrInput interface {
	pulumi.Input

	ToDetailsResponsePtrOutput() DetailsResponsePtrOutput
	ToDetailsResponsePtrOutputWithContext(context.Context) DetailsResponsePtrOutput
}

type detailsResponsePtrType DetailsResponseArgs

func DetailsResponsePtr(v *DetailsResponseArgs) DetailsResponsePtrInput {
	return (*detailsResponsePtrType)(v)
}

func (*detailsResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DetailsResponse)(nil)).Elem()
}

func (i *detailsResponsePtrType) ToDetailsResponsePtrOutput() DetailsResponsePtrOutput {
	return i.ToDetailsResponsePtrOutputWithContext(context.Background())
}

func (i *detailsResponsePtrType) ToDetailsResponsePtrOutputWithContext(ctx context.Context) DetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetailsResponsePtrOutput)
}

// Details of an attestation occurrence.
type DetailsResponseOutput struct{ *pulumi.OutputState }

func (DetailsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DetailsResponse)(nil)).Elem()
}

func (o DetailsResponseOutput) ToDetailsResponseOutput() DetailsResponseOutput {
	return o
}

func (o DetailsResponseOutput) ToDetailsResponseOutputWithContext(ctx context.Context) DetailsResponseOutput {
	return o
}

func (o DetailsResponseOutput) ToDetailsResponsePtrOutput() DetailsResponsePtrOutput {
	return o.ToDetailsResponsePtrOutputWithContext(context.Background())
}

func (o DetailsResponseOutput) ToDetailsResponsePtrOutputWithContext(ctx context.Context) DetailsResponsePtrOutput {
	return o.ApplyT(func(v DetailsResponse) *DetailsResponse {
		return &v
	}).(DetailsResponsePtrOutput)
}

// Attestation for the resource.
func (o DetailsResponseOutput) Attestation() AttestationResponseOutput {
	return o.ApplyT(func(v DetailsResponse) AttestationResponse { return v.Attestation }).(AttestationResponseOutput)
}

type DetailsResponsePtrOutput struct{ *pulumi.OutputState }

func (DetailsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DetailsResponse)(nil)).Elem()
}

func (o DetailsResponsePtrOutput) ToDetailsResponsePtrOutput() DetailsResponsePtrOutput {
	return o
}

func (o DetailsResponsePtrOutput) ToDetailsResponsePtrOutputWithContext(ctx context.Context) DetailsResponsePtrOutput {
	return o
}

func (o DetailsResponsePtrOutput) Elem() DetailsResponseOutput {
	return o.ApplyT(func(v *DetailsResponse) DetailsResponse { return *v }).(DetailsResponseOutput)
}

// Attestation for the resource.
func (o DetailsResponsePtrOutput) Attestation() AttestationResponsePtrOutput {
	return o.ApplyT(func(v *DetailsResponse) *AttestationResponse {
		if v == nil {
			return nil
		}
		return &v.Attestation
	}).(AttestationResponsePtrOutput)
}

// Provides information about the analysis status of a discovered resource.
type Discovered struct {
	// The status of discovery for the resource.
	AnalysisStatus *DiscoveredAnalysisStatus `pulumi:"analysisStatus"`
	// When an error is encountered this will contain a LocalizedMessage under details to show to the user. The LocalizedMessage is output only and populated by the API.
	AnalysisStatusError *Status `pulumi:"analysisStatusError"`
	// Whether the resource is continuously analyzed.
	ContinuousAnalysis *DiscoveredContinuousAnalysis `pulumi:"continuousAnalysis"`
}

// DiscoveredInput is an input type that accepts DiscoveredArgs and DiscoveredOutput values.
// You can construct a concrete instance of `DiscoveredInput` via:
//
//          DiscoveredArgs{...}
type DiscoveredInput interface {
	pulumi.Input

	ToDiscoveredOutput() DiscoveredOutput
	ToDiscoveredOutputWithContext(context.Context) DiscoveredOutput
}

// Provides information about the analysis status of a discovered resource.
type DiscoveredArgs struct {
	// The status of discovery for the resource.
	AnalysisStatus DiscoveredAnalysisStatusPtrInput `pulumi:"analysisStatus"`
	// When an error is encountered this will contain a LocalizedMessage under details to show to the user. The LocalizedMessage is output only and populated by the API.
	AnalysisStatusError StatusPtrInput `pulumi:"analysisStatusError"`
	// Whether the resource is continuously analyzed.
	ContinuousAnalysis DiscoveredContinuousAnalysisPtrInput `pulumi:"continuousAnalysis"`
}

func (DiscoveredArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Discovered)(nil)).Elem()
}

func (i DiscoveredArgs) ToDiscoveredOutput() DiscoveredOutput {
	return i.ToDiscoveredOutputWithContext(context.Background())
}

func (i DiscoveredArgs) ToDiscoveredOutputWithContext(ctx context.Context) DiscoveredOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiscoveredOutput)
}

func (i DiscoveredArgs) ToDiscoveredPtrOutput() DiscoveredPtrOutput {
	return i.ToDiscoveredPtrOutputWithContext(context.Background())
}

func (i DiscoveredArgs) ToDiscoveredPtrOutputWithContext(ctx context.Context) DiscoveredPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiscoveredOutput).ToDiscoveredPtrOutputWithContext(ctx)
}

// DiscoveredPtrInput is an input type that accepts DiscoveredArgs, DiscoveredPtr and DiscoveredPtrOutput values.
// You can construct a concrete instance of `DiscoveredPtrInput` via:
//
//          DiscoveredArgs{...}
//
//  or:
//
//          nil
type DiscoveredPtrInput interface {
	pulumi.Input

	ToDiscoveredPtrOutput() DiscoveredPtrOutput
	ToDiscoveredPtrOutputWithContext(context.Context) DiscoveredPtrOutput
}

type discoveredPtrType DiscoveredArgs

func DiscoveredPtr(v *DiscoveredArgs) DiscoveredPtrInput {
	return (*discoveredPtrType)(v)
}

func (*discoveredPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Discovered)(nil)).Elem()
}

func (i *discoveredPtrType) ToDiscoveredPtrOutput() DiscoveredPtrOutput {
	return i.ToDiscoveredPtrOutputWithContext(context.Background())
}

func (i *discoveredPtrType) ToDiscoveredPtrOutputWithContext(ctx context.Context) DiscoveredPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiscoveredPtrOutput)
}

// Provides information about the analysis status of a discovered resource.
type DiscoveredOutput struct{ *pulumi.OutputState }

func (DiscoveredOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Discovered)(nil)).Elem()
}

func (o DiscoveredOutput) ToDiscoveredOutput() DiscoveredOutput {
	return o
}

func (o DiscoveredOutput) ToDiscoveredOutputWithContext(ctx context.Context) DiscoveredOutput {
	return o
}

func (o DiscoveredOutput) ToDiscoveredPtrOutput() DiscoveredPtrOutput {
	return o.ToDiscoveredPtrOutputWithContext(context.Background())
}

func (o DiscoveredOutput) ToDiscoveredPtrOutputWithContext(ctx context.Context) DiscoveredPtrOutput {
	return o.ApplyT(func(v Discovered) *Discovered {
		return &v
	}).(DiscoveredPtrOutput)
}

// The status of discovery for the resource.
func (o DiscoveredOutput) AnalysisStatus() DiscoveredAnalysisStatusPtrOutput {
	return o.ApplyT(func(v Discovered) *DiscoveredAnalysisStatus { return v.AnalysisStatus }).(DiscoveredAnalysisStatusPtrOutput)
}

// When an error is encountered this will contain a LocalizedMessage under details to show to the user. The LocalizedMessage is output only and populated by the API.
func (o DiscoveredOutput) AnalysisStatusError() StatusPtrOutput {
	return o.ApplyT(func(v Discovered) *Status { return v.AnalysisStatusError }).(StatusPtrOutput)
}

// Whether the resource is continuously analyzed.
func (o DiscoveredOutput) ContinuousAnalysis() DiscoveredContinuousAnalysisPtrOutput {
	return o.ApplyT(func(v Discovered) *DiscoveredContinuousAnalysis { return v.ContinuousAnalysis }).(DiscoveredContinuousAnalysisPtrOutput)
}

type DiscoveredPtrOutput struct{ *pulumi.OutputState }

func (DiscoveredPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Discovered)(nil)).Elem()
}

func (o DiscoveredPtrOutput) ToDiscoveredPtrOutput() DiscoveredPtrOutput {
	return o
}

func (o DiscoveredPtrOutput) ToDiscoveredPtrOutputWithContext(ctx context.Context) DiscoveredPtrOutput {
	return o
}

func (o DiscoveredPtrOutput) Elem() DiscoveredOutput {
	return o.ApplyT(func(v *Discovered) Discovered { return *v }).(DiscoveredOutput)
}

// The status of discovery for the resource.
func (o DiscoveredPtrOutput) AnalysisStatus() DiscoveredAnalysisStatusPtrOutput {
	return o.ApplyT(func(v *Discovered) *DiscoveredAnalysisStatus {
		if v == nil {
			return nil
		}
		return v.AnalysisStatus
	}).(DiscoveredAnalysisStatusPtrOutput)
}

// When an error is encountered this will contain a LocalizedMessage under details to show to the user. The LocalizedMessage is output only and populated by the API.
func (o DiscoveredPtrOutput) AnalysisStatusError() StatusPtrOutput {
	return o.ApplyT(func(v *Discovered) *Status {
		if v == nil {
			return nil
		}
		return v.AnalysisStatusError
	}).(StatusPtrOutput)
}

// Whether the resource is continuously analyzed.
func (o DiscoveredPtrOutput) ContinuousAnalysis() DiscoveredContinuousAnalysisPtrOutput {
	return o.ApplyT(func(v *Discovered) *DiscoveredContinuousAnalysis {
		if v == nil {
			return nil
		}
		return v.ContinuousAnalysis
	}).(DiscoveredContinuousAnalysisPtrOutput)
}

// Provides information about the analysis status of a discovered resource.
type DiscoveredResponse struct {
	// The status of discovery for the resource.
	AnalysisStatus string `pulumi:"analysisStatus"`
	// When an error is encountered this will contain a LocalizedMessage under details to show to the user. The LocalizedMessage is output only and populated by the API.
	AnalysisStatusError StatusResponse `pulumi:"analysisStatusError"`
	// Whether the resource is continuously analyzed.
	ContinuousAnalysis string `pulumi:"continuousAnalysis"`
}

// DiscoveredResponseInput is an input type that accepts DiscoveredResponseArgs and DiscoveredResponseOutput values.
// You can construct a concrete instance of `DiscoveredResponseInput` via:
//
//          DiscoveredResponseArgs{...}
type DiscoveredResponseInput interface {
	pulumi.Input

	ToDiscoveredResponseOutput() DiscoveredResponseOutput
	ToDiscoveredResponseOutputWithContext(context.Context) DiscoveredResponseOutput
}

// Provides information about the analysis status of a discovered resource.
type DiscoveredResponseArgs struct {
	// The status of discovery for the resource.
	AnalysisStatus pulumi.StringInput `pulumi:"analysisStatus"`
	// When an error is encountered this will contain a LocalizedMessage under details to show to the user. The LocalizedMessage is output only and populated by the API.
	AnalysisStatusError StatusResponseInput `pulumi:"analysisStatusError"`
	// Whether the resource is continuously analyzed.
	ContinuousAnalysis pulumi.StringInput `pulumi:"continuousAnalysis"`
}

func (DiscoveredResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DiscoveredResponse)(nil)).Elem()
}

func (i DiscoveredResponseArgs) ToDiscoveredResponseOutput() DiscoveredResponseOutput {
	return i.ToDiscoveredResponseOutputWithContext(context.Background())
}

func (i DiscoveredResponseArgs) ToDiscoveredResponseOutputWithContext(ctx context.Context) DiscoveredResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiscoveredResponseOutput)
}

func (i DiscoveredResponseArgs) ToDiscoveredResponsePtrOutput() DiscoveredResponsePtrOutput {
	return i.ToDiscoveredResponsePtrOutputWithContext(context.Background())
}

func (i DiscoveredResponseArgs) ToDiscoveredResponsePtrOutputWithContext(ctx context.Context) DiscoveredResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiscoveredResponseOutput).ToDiscoveredResponsePtrOutputWithContext(ctx)
}

// DiscoveredResponsePtrInput is an input type that accepts DiscoveredResponseArgs, DiscoveredResponsePtr and DiscoveredResponsePtrOutput values.
// You can construct a concrete instance of `DiscoveredResponsePtrInput` via:
//
//          DiscoveredResponseArgs{...}
//
//  or:
//
//          nil
type DiscoveredResponsePtrInput interface {
	pulumi.Input

	ToDiscoveredResponsePtrOutput() DiscoveredResponsePtrOutput
	ToDiscoveredResponsePtrOutputWithContext(context.Context) DiscoveredResponsePtrOutput
}

type discoveredResponsePtrType DiscoveredResponseArgs

func DiscoveredResponsePtr(v *DiscoveredResponseArgs) DiscoveredResponsePtrInput {
	return (*discoveredResponsePtrType)(v)
}

func (*discoveredResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DiscoveredResponse)(nil)).Elem()
}

func (i *discoveredResponsePtrType) ToDiscoveredResponsePtrOutput() DiscoveredResponsePtrOutput {
	return i.ToDiscoveredResponsePtrOutputWithContext(context.Background())
}

func (i *discoveredResponsePtrType) ToDiscoveredResponsePtrOutputWithContext(ctx context.Context) DiscoveredResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiscoveredResponsePtrOutput)
}

// Provides information about the analysis status of a discovered resource.
type DiscoveredResponseOutput struct{ *pulumi.OutputState }

func (DiscoveredResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DiscoveredResponse)(nil)).Elem()
}

func (o DiscoveredResponseOutput) ToDiscoveredResponseOutput() DiscoveredResponseOutput {
	return o
}

func (o DiscoveredResponseOutput) ToDiscoveredResponseOutputWithContext(ctx context.Context) DiscoveredResponseOutput {
	return o
}

func (o DiscoveredResponseOutput) ToDiscoveredResponsePtrOutput() DiscoveredResponsePtrOutput {
	return o.ToDiscoveredResponsePtrOutputWithContext(context.Background())
}

func (o DiscoveredResponseOutput) ToDiscoveredResponsePtrOutputWithContext(ctx context.Context) DiscoveredResponsePtrOutput {
	return o.ApplyT(func(v DiscoveredResponse) *DiscoveredResponse {
		return &v
	}).(DiscoveredResponsePtrOutput)
}

// The status of discovery for the resource.
func (o DiscoveredResponseOutput) AnalysisStatus() pulumi.StringOutput {
	return o.ApplyT(func(v DiscoveredResponse) string { return v.AnalysisStatus }).(pulumi.StringOutput)
}

// When an error is encountered this will contain a LocalizedMessage under details to show to the user. The LocalizedMessage is output only and populated by the API.
func (o DiscoveredResponseOutput) AnalysisStatusError() StatusResponseOutput {
	return o.ApplyT(func(v DiscoveredResponse) StatusResponse { return v.AnalysisStatusError }).(StatusResponseOutput)
}

// Whether the resource is continuously analyzed.
func (o DiscoveredResponseOutput) ContinuousAnalysis() pulumi.StringOutput {
	return o.ApplyT(func(v DiscoveredResponse) string { return v.ContinuousAnalysis }).(pulumi.StringOutput)
}

type DiscoveredResponsePtrOutput struct{ *pulumi.OutputState }

func (DiscoveredResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DiscoveredResponse)(nil)).Elem()
}

func (o DiscoveredResponsePtrOutput) ToDiscoveredResponsePtrOutput() DiscoveredResponsePtrOutput {
	return o
}

func (o DiscoveredResponsePtrOutput) ToDiscoveredResponsePtrOutputWithContext(ctx context.Context) DiscoveredResponsePtrOutput {
	return o
}

func (o DiscoveredResponsePtrOutput) Elem() DiscoveredResponseOutput {
	return o.ApplyT(func(v *DiscoveredResponse) DiscoveredResponse { return *v }).(DiscoveredResponseOutput)
}

// The status of discovery for the resource.
func (o DiscoveredResponsePtrOutput) AnalysisStatus() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DiscoveredResponse) *string {
		if v == nil {
			return nil
		}
		return &v.AnalysisStatus
	}).(pulumi.StringPtrOutput)
}

// When an error is encountered this will contain a LocalizedMessage under details to show to the user. The LocalizedMessage is output only and populated by the API.
func (o DiscoveredResponsePtrOutput) AnalysisStatusError() StatusResponsePtrOutput {
	return o.ApplyT(func(v *DiscoveredResponse) *StatusResponse {
		if v == nil {
			return nil
		}
		return &v.AnalysisStatusError
	}).(StatusResponsePtrOutput)
}

// Whether the resource is continuously analyzed.
func (o DiscoveredResponsePtrOutput) ContinuousAnalysis() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DiscoveredResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ContinuousAnalysis
	}).(pulumi.StringPtrOutput)
}

// A note that indicates a type of analysis a provider would perform. This note exists in a provider's project. A `Discovery` occurrence is created in a consumer's project at the start of analysis.
type Discovery struct {
	// Immutable. The kind of analysis that is handled by this discovery.
	AnalysisKind DiscoveryAnalysisKind `pulumi:"analysisKind"`
}

// DiscoveryInput is an input type that accepts DiscoveryArgs and DiscoveryOutput values.
// You can construct a concrete instance of `DiscoveryInput` via:
//
//          DiscoveryArgs{...}
type DiscoveryInput interface {
	pulumi.Input

	ToDiscoveryOutput() DiscoveryOutput
	ToDiscoveryOutputWithContext(context.Context) DiscoveryOutput
}

// A note that indicates a type of analysis a provider would perform. This note exists in a provider's project. A `Discovery` occurrence is created in a consumer's project at the start of analysis.
type DiscoveryArgs struct {
	// Immutable. The kind of analysis that is handled by this discovery.
	AnalysisKind DiscoveryAnalysisKindInput `pulumi:"analysisKind"`
}

func (DiscoveryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Discovery)(nil)).Elem()
}

func (i DiscoveryArgs) ToDiscoveryOutput() DiscoveryOutput {
	return i.ToDiscoveryOutputWithContext(context.Background())
}

func (i DiscoveryArgs) ToDiscoveryOutputWithContext(ctx context.Context) DiscoveryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiscoveryOutput)
}

func (i DiscoveryArgs) ToDiscoveryPtrOutput() DiscoveryPtrOutput {
	return i.ToDiscoveryPtrOutputWithContext(context.Background())
}

func (i DiscoveryArgs) ToDiscoveryPtrOutputWithContext(ctx context.Context) DiscoveryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiscoveryOutput).ToDiscoveryPtrOutputWithContext(ctx)
}

// DiscoveryPtrInput is an input type that accepts DiscoveryArgs, DiscoveryPtr and DiscoveryPtrOutput values.
// You can construct a concrete instance of `DiscoveryPtrInput` via:
//
//          DiscoveryArgs{...}
//
//  or:
//
//          nil
type DiscoveryPtrInput interface {
	pulumi.Input

	ToDiscoveryPtrOutput() DiscoveryPtrOutput
	ToDiscoveryPtrOutputWithContext(context.Context) DiscoveryPtrOutput
}

type discoveryPtrType DiscoveryArgs

func DiscoveryPtr(v *DiscoveryArgs) DiscoveryPtrInput {
	return (*discoveryPtrType)(v)
}

func (*discoveryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Discovery)(nil)).Elem()
}

func (i *discoveryPtrType) ToDiscoveryPtrOutput() DiscoveryPtrOutput {
	return i.ToDiscoveryPtrOutputWithContext(context.Background())
}

func (i *discoveryPtrType) ToDiscoveryPtrOutputWithContext(ctx context.Context) DiscoveryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiscoveryPtrOutput)
}

// A note that indicates a type of analysis a provider would perform. This note exists in a provider's project. A `Discovery` occurrence is created in a consumer's project at the start of analysis.
type DiscoveryOutput struct{ *pulumi.OutputState }

func (DiscoveryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Discovery)(nil)).Elem()
}

func (o DiscoveryOutput) ToDiscoveryOutput() DiscoveryOutput {
	return o
}

func (o DiscoveryOutput) ToDiscoveryOutputWithContext(ctx context.Context) DiscoveryOutput {
	return o
}

func (o DiscoveryOutput) ToDiscoveryPtrOutput() DiscoveryPtrOutput {
	return o.ToDiscoveryPtrOutputWithContext(context.Background())
}

func (o DiscoveryOutput) ToDiscoveryPtrOutputWithContext(ctx context.Context) DiscoveryPtrOutput {
	return o.ApplyT(func(v Discovery) *Discovery {
		return &v
	}).(DiscoveryPtrOutput)
}

// Immutable. The kind of analysis that is handled by this discovery.
func (o DiscoveryOutput) AnalysisKind() DiscoveryAnalysisKindOutput {
	return o.ApplyT(func(v Discovery) DiscoveryAnalysisKind { return v.AnalysisKind }).(DiscoveryAnalysisKindOutput)
}

type DiscoveryPtrOutput struct{ *pulumi.OutputState }

func (DiscoveryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Discovery)(nil)).Elem()
}

func (o DiscoveryPtrOutput) ToDiscoveryPtrOutput() DiscoveryPtrOutput {
	return o
}

func (o DiscoveryPtrOutput) ToDiscoveryPtrOutputWithContext(ctx context.Context) DiscoveryPtrOutput {
	return o
}

func (o DiscoveryPtrOutput) Elem() DiscoveryOutput {
	return o.ApplyT(func(v *Discovery) Discovery { return *v }).(DiscoveryOutput)
}

// Immutable. The kind of analysis that is handled by this discovery.
func (o DiscoveryPtrOutput) AnalysisKind() DiscoveryAnalysisKindPtrOutput {
	return o.ApplyT(func(v *Discovery) *DiscoveryAnalysisKind {
		if v == nil {
			return nil
		}
		return &v.AnalysisKind
	}).(DiscoveryAnalysisKindPtrOutput)
}

// A note that indicates a type of analysis a provider would perform. This note exists in a provider's project. A `Discovery` occurrence is created in a consumer's project at the start of analysis.
type DiscoveryResponse struct {
	// Immutable. The kind of analysis that is handled by this discovery.
	AnalysisKind string `pulumi:"analysisKind"`
}

// DiscoveryResponseInput is an input type that accepts DiscoveryResponseArgs and DiscoveryResponseOutput values.
// You can construct a concrete instance of `DiscoveryResponseInput` via:
//
//          DiscoveryResponseArgs{...}
type DiscoveryResponseInput interface {
	pulumi.Input

	ToDiscoveryResponseOutput() DiscoveryResponseOutput
	ToDiscoveryResponseOutputWithContext(context.Context) DiscoveryResponseOutput
}

// A note that indicates a type of analysis a provider would perform. This note exists in a provider's project. A `Discovery` occurrence is created in a consumer's project at the start of analysis.
type DiscoveryResponseArgs struct {
	// Immutable. The kind of analysis that is handled by this discovery.
	AnalysisKind pulumi.StringInput `pulumi:"analysisKind"`
}

func (DiscoveryResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DiscoveryResponse)(nil)).Elem()
}

func (i DiscoveryResponseArgs) ToDiscoveryResponseOutput() DiscoveryResponseOutput {
	return i.ToDiscoveryResponseOutputWithContext(context.Background())
}

func (i DiscoveryResponseArgs) ToDiscoveryResponseOutputWithContext(ctx context.Context) DiscoveryResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiscoveryResponseOutput)
}

func (i DiscoveryResponseArgs) ToDiscoveryResponsePtrOutput() DiscoveryResponsePtrOutput {
	return i.ToDiscoveryResponsePtrOutputWithContext(context.Background())
}

func (i DiscoveryResponseArgs) ToDiscoveryResponsePtrOutputWithContext(ctx context.Context) DiscoveryResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiscoveryResponseOutput).ToDiscoveryResponsePtrOutputWithContext(ctx)
}

// DiscoveryResponsePtrInput is an input type that accepts DiscoveryResponseArgs, DiscoveryResponsePtr and DiscoveryResponsePtrOutput values.
// You can construct a concrete instance of `DiscoveryResponsePtrInput` via:
//
//          DiscoveryResponseArgs{...}
//
//  or:
//
//          nil
type DiscoveryResponsePtrInput interface {
	pulumi.Input

	ToDiscoveryResponsePtrOutput() DiscoveryResponsePtrOutput
	ToDiscoveryResponsePtrOutputWithContext(context.Context) DiscoveryResponsePtrOutput
}

type discoveryResponsePtrType DiscoveryResponseArgs

func DiscoveryResponsePtr(v *DiscoveryResponseArgs) DiscoveryResponsePtrInput {
	return (*discoveryResponsePtrType)(v)
}

func (*discoveryResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DiscoveryResponse)(nil)).Elem()
}

func (i *discoveryResponsePtrType) ToDiscoveryResponsePtrOutput() DiscoveryResponsePtrOutput {
	return i.ToDiscoveryResponsePtrOutputWithContext(context.Background())
}

func (i *discoveryResponsePtrType) ToDiscoveryResponsePtrOutputWithContext(ctx context.Context) DiscoveryResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiscoveryResponsePtrOutput)
}

// A note that indicates a type of analysis a provider would perform. This note exists in a provider's project. A `Discovery` occurrence is created in a consumer's project at the start of analysis.
type DiscoveryResponseOutput struct{ *pulumi.OutputState }

func (DiscoveryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DiscoveryResponse)(nil)).Elem()
}

func (o DiscoveryResponseOutput) ToDiscoveryResponseOutput() DiscoveryResponseOutput {
	return o
}

func (o DiscoveryResponseOutput) ToDiscoveryResponseOutputWithContext(ctx context.Context) DiscoveryResponseOutput {
	return o
}

func (o DiscoveryResponseOutput) ToDiscoveryResponsePtrOutput() DiscoveryResponsePtrOutput {
	return o.ToDiscoveryResponsePtrOutputWithContext(context.Background())
}

func (o DiscoveryResponseOutput) ToDiscoveryResponsePtrOutputWithContext(ctx context.Context) DiscoveryResponsePtrOutput {
	return o.ApplyT(func(v DiscoveryResponse) *DiscoveryResponse {
		return &v
	}).(DiscoveryResponsePtrOutput)
}

// Immutable. The kind of analysis that is handled by this discovery.
func (o DiscoveryResponseOutput) AnalysisKind() pulumi.StringOutput {
	return o.ApplyT(func(v DiscoveryResponse) string { return v.AnalysisKind }).(pulumi.StringOutput)
}

type DiscoveryResponsePtrOutput struct{ *pulumi.OutputState }

func (DiscoveryResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DiscoveryResponse)(nil)).Elem()
}

func (o DiscoveryResponsePtrOutput) ToDiscoveryResponsePtrOutput() DiscoveryResponsePtrOutput {
	return o
}

func (o DiscoveryResponsePtrOutput) ToDiscoveryResponsePtrOutputWithContext(ctx context.Context) DiscoveryResponsePtrOutput {
	return o
}

func (o DiscoveryResponsePtrOutput) Elem() DiscoveryResponseOutput {
	return o.ApplyT(func(v *DiscoveryResponse) DiscoveryResponse { return *v }).(DiscoveryResponseOutput)
}

// Immutable. The kind of analysis that is handled by this discovery.
func (o DiscoveryResponsePtrOutput) AnalysisKind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DiscoveryResponse) *string {
		if v == nil {
			return nil
		}
		return &v.AnalysisKind
	}).(pulumi.StringPtrOutput)
}

// This represents a particular channel of distribution for a given package. E.g., Debian's jessie-backports dpkg mirror.
type Distribution struct {
	// The CPU architecture for which packages in this distribution channel were built.
	Architecture *DistributionArchitecture `pulumi:"architecture"`
	// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/) denoting the package manager version distributing a package.
	CpeUri string `pulumi:"cpeUri"`
	// The distribution channel-specific description of this package.
	Description *string `pulumi:"description"`
	// The latest available version of this package in this distribution channel.
	LatestVersion *Version `pulumi:"latestVersion"`
	// A freeform string denoting the maintainer of this package.
	Maintainer *string `pulumi:"maintainer"`
	// The distribution channel-specific homepage for this package.
	Url *string `pulumi:"url"`
}

// DistributionInput is an input type that accepts DistributionArgs and DistributionOutput values.
// You can construct a concrete instance of `DistributionInput` via:
//
//          DistributionArgs{...}
type DistributionInput interface {
	pulumi.Input

	ToDistributionOutput() DistributionOutput
	ToDistributionOutputWithContext(context.Context) DistributionOutput
}

// This represents a particular channel of distribution for a given package. E.g., Debian's jessie-backports dpkg mirror.
type DistributionArgs struct {
	// The CPU architecture for which packages in this distribution channel were built.
	Architecture DistributionArchitecturePtrInput `pulumi:"architecture"`
	// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/) denoting the package manager version distributing a package.
	CpeUri pulumi.StringInput `pulumi:"cpeUri"`
	// The distribution channel-specific description of this package.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// The latest available version of this package in this distribution channel.
	LatestVersion VersionPtrInput `pulumi:"latestVersion"`
	// A freeform string denoting the maintainer of this package.
	Maintainer pulumi.StringPtrInput `pulumi:"maintainer"`
	// The distribution channel-specific homepage for this package.
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (DistributionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Distribution)(nil)).Elem()
}

func (i DistributionArgs) ToDistributionOutput() DistributionOutput {
	return i.ToDistributionOutputWithContext(context.Background())
}

func (i DistributionArgs) ToDistributionOutputWithContext(ctx context.Context) DistributionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionOutput)
}

// DistributionArrayInput is an input type that accepts DistributionArray and DistributionArrayOutput values.
// You can construct a concrete instance of `DistributionArrayInput` via:
//
//          DistributionArray{ DistributionArgs{...} }
type DistributionArrayInput interface {
	pulumi.Input

	ToDistributionArrayOutput() DistributionArrayOutput
	ToDistributionArrayOutputWithContext(context.Context) DistributionArrayOutput
}

type DistributionArray []DistributionInput

func (DistributionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Distribution)(nil)).Elem()
}

func (i DistributionArray) ToDistributionArrayOutput() DistributionArrayOutput {
	return i.ToDistributionArrayOutputWithContext(context.Background())
}

func (i DistributionArray) ToDistributionArrayOutputWithContext(ctx context.Context) DistributionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionArrayOutput)
}

// This represents a particular channel of distribution for a given package. E.g., Debian's jessie-backports dpkg mirror.
type DistributionOutput struct{ *pulumi.OutputState }

func (DistributionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Distribution)(nil)).Elem()
}

func (o DistributionOutput) ToDistributionOutput() DistributionOutput {
	return o
}

func (o DistributionOutput) ToDistributionOutputWithContext(ctx context.Context) DistributionOutput {
	return o
}

// The CPU architecture for which packages in this distribution channel were built.
func (o DistributionOutput) Architecture() DistributionArchitecturePtrOutput {
	return o.ApplyT(func(v Distribution) *DistributionArchitecture { return v.Architecture }).(DistributionArchitecturePtrOutput)
}

// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/) denoting the package manager version distributing a package.
func (o DistributionOutput) CpeUri() pulumi.StringOutput {
	return o.ApplyT(func(v Distribution) string { return v.CpeUri }).(pulumi.StringOutput)
}

// The distribution channel-specific description of this package.
func (o DistributionOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Distribution) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The latest available version of this package in this distribution channel.
func (o DistributionOutput) LatestVersion() VersionPtrOutput {
	return o.ApplyT(func(v Distribution) *Version { return v.LatestVersion }).(VersionPtrOutput)
}

// A freeform string denoting the maintainer of this package.
func (o DistributionOutput) Maintainer() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Distribution) *string { return v.Maintainer }).(pulumi.StringPtrOutput)
}

// The distribution channel-specific homepage for this package.
func (o DistributionOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Distribution) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type DistributionArrayOutput struct{ *pulumi.OutputState }

func (DistributionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Distribution)(nil)).Elem()
}

func (o DistributionArrayOutput) ToDistributionArrayOutput() DistributionArrayOutput {
	return o
}

func (o DistributionArrayOutput) ToDistributionArrayOutputWithContext(ctx context.Context) DistributionArrayOutput {
	return o
}

func (o DistributionArrayOutput) Index(i pulumi.IntInput) DistributionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Distribution {
		return vs[0].([]Distribution)[vs[1].(int)]
	}).(DistributionOutput)
}

// This represents a particular channel of distribution for a given package. E.g., Debian's jessie-backports dpkg mirror.
type DistributionResponse struct {
	// The CPU architecture for which packages in this distribution channel were built.
	Architecture string `pulumi:"architecture"`
	// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/) denoting the package manager version distributing a package.
	CpeUri string `pulumi:"cpeUri"`
	// The distribution channel-specific description of this package.
	Description string `pulumi:"description"`
	// The latest available version of this package in this distribution channel.
	LatestVersion VersionResponse `pulumi:"latestVersion"`
	// A freeform string denoting the maintainer of this package.
	Maintainer string `pulumi:"maintainer"`
	// The distribution channel-specific homepage for this package.
	Url string `pulumi:"url"`
}

// DistributionResponseInput is an input type that accepts DistributionResponseArgs and DistributionResponseOutput values.
// You can construct a concrete instance of `DistributionResponseInput` via:
//
//          DistributionResponseArgs{...}
type DistributionResponseInput interface {
	pulumi.Input

	ToDistributionResponseOutput() DistributionResponseOutput
	ToDistributionResponseOutputWithContext(context.Context) DistributionResponseOutput
}

// This represents a particular channel of distribution for a given package. E.g., Debian's jessie-backports dpkg mirror.
type DistributionResponseArgs struct {
	// The CPU architecture for which packages in this distribution channel were built.
	Architecture pulumi.StringInput `pulumi:"architecture"`
	// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/) denoting the package manager version distributing a package.
	CpeUri pulumi.StringInput `pulumi:"cpeUri"`
	// The distribution channel-specific description of this package.
	Description pulumi.StringInput `pulumi:"description"`
	// The latest available version of this package in this distribution channel.
	LatestVersion VersionResponseInput `pulumi:"latestVersion"`
	// A freeform string denoting the maintainer of this package.
	Maintainer pulumi.StringInput `pulumi:"maintainer"`
	// The distribution channel-specific homepage for this package.
	Url pulumi.StringInput `pulumi:"url"`
}

func (DistributionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DistributionResponse)(nil)).Elem()
}

func (i DistributionResponseArgs) ToDistributionResponseOutput() DistributionResponseOutput {
	return i.ToDistributionResponseOutputWithContext(context.Background())
}

func (i DistributionResponseArgs) ToDistributionResponseOutputWithContext(ctx context.Context) DistributionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionResponseOutput)
}

// DistributionResponseArrayInput is an input type that accepts DistributionResponseArray and DistributionResponseArrayOutput values.
// You can construct a concrete instance of `DistributionResponseArrayInput` via:
//
//          DistributionResponseArray{ DistributionResponseArgs{...} }
type DistributionResponseArrayInput interface {
	pulumi.Input

	ToDistributionResponseArrayOutput() DistributionResponseArrayOutput
	ToDistributionResponseArrayOutputWithContext(context.Context) DistributionResponseArrayOutput
}

type DistributionResponseArray []DistributionResponseInput

func (DistributionResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DistributionResponse)(nil)).Elem()
}

func (i DistributionResponseArray) ToDistributionResponseArrayOutput() DistributionResponseArrayOutput {
	return i.ToDistributionResponseArrayOutputWithContext(context.Background())
}

func (i DistributionResponseArray) ToDistributionResponseArrayOutputWithContext(ctx context.Context) DistributionResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionResponseArrayOutput)
}

// This represents a particular channel of distribution for a given package. E.g., Debian's jessie-backports dpkg mirror.
type DistributionResponseOutput struct{ *pulumi.OutputState }

func (DistributionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DistributionResponse)(nil)).Elem()
}

func (o DistributionResponseOutput) ToDistributionResponseOutput() DistributionResponseOutput {
	return o
}

func (o DistributionResponseOutput) ToDistributionResponseOutputWithContext(ctx context.Context) DistributionResponseOutput {
	return o
}

// The CPU architecture for which packages in this distribution channel were built.
func (o DistributionResponseOutput) Architecture() pulumi.StringOutput {
	return o.ApplyT(func(v DistributionResponse) string { return v.Architecture }).(pulumi.StringOutput)
}

// The cpe_uri in [CPE format](https://cpe.mitre.org/specification/) denoting the package manager version distributing a package.
func (o DistributionResponseOutput) CpeUri() pulumi.StringOutput {
	return o.ApplyT(func(v DistributionResponse) string { return v.CpeUri }).(pulumi.StringOutput)
}

// The distribution channel-specific description of this package.
func (o DistributionResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v DistributionResponse) string { return v.Description }).(pulumi.StringOutput)
}

// The latest available version of this package in this distribution channel.
func (o DistributionResponseOutput) LatestVersion() VersionResponseOutput {
	return o.ApplyT(func(v DistributionResponse) VersionResponse { return v.LatestVersion }).(VersionResponseOutput)
}

// A freeform string denoting the maintainer of this package.
func (o DistributionResponseOutput) Maintainer() pulumi.StringOutput {
	return o.ApplyT(func(v DistributionResponse) string { return v.Maintainer }).(pulumi.StringOutput)
}

// The distribution channel-specific homepage for this package.
func (o DistributionResponseOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v DistributionResponse) string { return v.Url }).(pulumi.StringOutput)
}

type DistributionResponseArrayOutput struct{ *pulumi.OutputState }

func (DistributionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DistributionResponse)(nil)).Elem()
}

func (o DistributionResponseArrayOutput) ToDistributionResponseArrayOutput() DistributionResponseArrayOutput {
	return o
}

func (o DistributionResponseArrayOutput) ToDistributionResponseArrayOutputWithContext(ctx context.Context) DistributionResponseArrayOutput {
	return o
}

func (o DistributionResponseArrayOutput) Index(i pulumi.IntInput) DistributionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DistributionResponse {
		return vs[0].([]DistributionResponse)[vs[1].(int)]
	}).(DistributionResponseOutput)
}

// DocumentNote represents an SPDX Document Creation Infromation section: https://spdx.github.io/spdx-spec/2-document-creation-information/
type DocumentNote struct {
	// Compliance with the SPDX specification includes populating the SPDX fields therein with data related to such fields ("SPDX-Metadata")
	DataLicence *string `pulumi:"dataLicence"`
	// Provide a reference number that can be used to understand how to parse and interpret the rest of the file
	SpdxVersion *string `pulumi:"spdxVersion"`
}

// DocumentNoteInput is an input type that accepts DocumentNoteArgs and DocumentNoteOutput values.
// You can construct a concrete instance of `DocumentNoteInput` via:
//
//          DocumentNoteArgs{...}
type DocumentNoteInput interface {
	pulumi.Input

	ToDocumentNoteOutput() DocumentNoteOutput
	ToDocumentNoteOutputWithContext(context.Context) DocumentNoteOutput
}

// DocumentNote represents an SPDX Document Creation Infromation section: https://spdx.github.io/spdx-spec/2-document-creation-information/
type DocumentNoteArgs struct {
	// Compliance with the SPDX specification includes populating the SPDX fields therein with data related to such fields ("SPDX-Metadata")
	DataLicence pulumi.StringPtrInput `pulumi:"dataLicence"`
	// Provide a reference number that can be used to understand how to parse and interpret the rest of the file
	SpdxVersion pulumi.StringPtrInput `pulumi:"spdxVersion"`
}

func (DocumentNoteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DocumentNote)(nil)).Elem()
}

func (i DocumentNoteArgs) ToDocumentNoteOutput() DocumentNoteOutput {
	return i.ToDocumentNoteOutputWithContext(context.Background())
}

func (i DocumentNoteArgs) ToDocumentNoteOutputWithContext(ctx context.Context) DocumentNoteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentNoteOutput)
}

func (i DocumentNoteArgs) ToDocumentNotePtrOutput() DocumentNotePtrOutput {
	return i.ToDocumentNotePtrOutputWithContext(context.Background())
}

func (i DocumentNoteArgs) ToDocumentNotePtrOutputWithContext(ctx context.Context) DocumentNotePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentNoteOutput).ToDocumentNotePtrOutputWithContext(ctx)
}

// DocumentNotePtrInput is an input type that accepts DocumentNoteArgs, DocumentNotePtr and DocumentNotePtrOutput values.
// You can construct a concrete instance of `DocumentNotePtrInput` via:
//
//          DocumentNoteArgs{...}
//
//  or:
//
//          nil
type DocumentNotePtrInput interface {
	pulumi.Input

	ToDocumentNotePtrOutput() DocumentNotePtrOutput
	ToDocumentNotePtrOutputWithContext(context.Context) DocumentNotePtrOutput
}

type documentNotePtrType DocumentNoteArgs

func DocumentNotePtr(v *DocumentNoteArgs) DocumentNotePtrInput {
	return (*documentNotePtrType)(v)
}

func (*documentNotePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DocumentNote)(nil)).Elem()
}

func (i *documentNotePtrType) ToDocumentNotePtrOutput() DocumentNotePtrOutput {
	return i.ToDocumentNotePtrOutputWithContext(context.Background())
}

func (i *documentNotePtrType) ToDocumentNotePtrOutputWithContext(ctx context.Context) DocumentNotePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentNotePtrOutput)
}

// DocumentNote represents an SPDX Document Creation Infromation section: https://spdx.github.io/spdx-spec/2-document-creation-information/
type DocumentNoteOutput struct{ *pulumi.OutputState }

func (DocumentNoteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DocumentNote)(nil)).Elem()
}

func (o DocumentNoteOutput) ToDocumentNoteOutput() DocumentNoteOutput {
	return o
}

func (o DocumentNoteOutput) ToDocumentNoteOutputWithContext(ctx context.Context) DocumentNoteOutput {
	return o
}

func (o DocumentNoteOutput) ToDocumentNotePtrOutput() DocumentNotePtrOutput {
	return o.ToDocumentNotePtrOutputWithContext(context.Background())
}

func (o DocumentNoteOutput) ToDocumentNotePtrOutputWithContext(ctx context.Context) DocumentNotePtrOutput {
	return o.ApplyT(func(v DocumentNote) *DocumentNote {
		return &v
	}).(DocumentNotePtrOutput)
}

// Compliance with the SPDX specification includes populating the SPDX fields therein with data related to such fields ("SPDX-Metadata")
func (o DocumentNoteOutput) DataLicence() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DocumentNote) *string { return v.DataLicence }).(pulumi.StringPtrOutput)
}

// Provide a reference number that can be used to understand how to parse and interpret the rest of the file
func (o DocumentNoteOutput) SpdxVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DocumentNote) *string { return v.SpdxVersion }).(pulumi.StringPtrOutput)
}

type DocumentNotePtrOutput struct{ *pulumi.OutputState }

func (DocumentNotePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DocumentNote)(nil)).Elem()
}

func (o DocumentNotePtrOutput) ToDocumentNotePtrOutput() DocumentNotePtrOutput {
	return o
}

func (o DocumentNotePtrOutput) ToDocumentNotePtrOutputWithContext(ctx context.Context) DocumentNotePtrOutput {
	return o
}

func (o DocumentNotePtrOutput) Elem() DocumentNoteOutput {
	return o.ApplyT(func(v *DocumentNote) DocumentNote { return *v }).(DocumentNoteOutput)
}

// Compliance with the SPDX specification includes populating the SPDX fields therein with data related to such fields ("SPDX-Metadata")
func (o DocumentNotePtrOutput) DataLicence() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentNote) *string {
		if v == nil {
			return nil
		}
		return v.DataLicence
	}).(pulumi.StringPtrOutput)
}

// Provide a reference number that can be used to understand how to parse and interpret the rest of the file
func (o DocumentNotePtrOutput) SpdxVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentNote) *string {
		if v == nil {
			return nil
		}
		return v.SpdxVersion
	}).(pulumi.StringPtrOutput)
}

// DocumentNote represents an SPDX Document Creation Infromation section: https://spdx.github.io/spdx-spec/2-document-creation-information/
type DocumentNoteResponse struct {
	// Compliance with the SPDX specification includes populating the SPDX fields therein with data related to such fields ("SPDX-Metadata")
	DataLicence string `pulumi:"dataLicence"`
	// Provide a reference number that can be used to understand how to parse and interpret the rest of the file
	SpdxVersion string `pulumi:"spdxVersion"`
}

// DocumentNoteResponseInput is an input type that accepts DocumentNoteResponseArgs and DocumentNoteResponseOutput values.
// You can construct a concrete instance of `DocumentNoteResponseInput` via:
//
//          DocumentNoteResponseArgs{...}
type DocumentNoteResponseInput interface {
	pulumi.Input

	ToDocumentNoteResponseOutput() DocumentNoteResponseOutput
	ToDocumentNoteResponseOutputWithContext(context.Context) DocumentNoteResponseOutput
}

// DocumentNote represents an SPDX Document Creation Infromation section: https://spdx.github.io/spdx-spec/2-document-creation-information/
type DocumentNoteResponseArgs struct {
	// Compliance with the SPDX specification includes populating the SPDX fields therein with data related to such fields ("SPDX-Metadata")
	DataLicence pulumi.StringInput `pulumi:"dataLicence"`
	// Provide a reference number that can be used to understand how to parse and interpret the rest of the file
	SpdxVersion pulumi.StringInput `pulumi:"spdxVersion"`
}

func (DocumentNoteResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DocumentNoteResponse)(nil)).Elem()
}

func (i DocumentNoteResponseArgs) ToDocumentNoteResponseOutput() DocumentNoteResponseOutput {
	return i.ToDocumentNoteResponseOutputWithContext(context.Background())
}

func (i DocumentNoteResponseArgs) ToDocumentNoteResponseOutputWithContext(ctx context.Context) DocumentNoteResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentNoteResponseOutput)
}

func (i DocumentNoteResponseArgs) ToDocumentNoteResponsePtrOutput() DocumentNoteResponsePtrOutput {
	return i.ToDocumentNoteResponsePtrOutputWithContext(context.Background())
}

func (i DocumentNoteResponseArgs) ToDocumentNoteResponsePtrOutputWithContext(ctx context.Context) DocumentNoteResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentNoteResponseOutput).ToDocumentNoteResponsePtrOutputWithContext(ctx)
}

// DocumentNoteResponsePtrInput is an input type that accepts DocumentNoteResponseArgs, DocumentNoteResponsePtr and DocumentNoteResponsePtrOutput values.
// You can construct a concrete instance of `DocumentNoteResponsePtrInput` via:
//
//          DocumentNoteResponseArgs{...}
//
//  or:
//
//          nil
type DocumentNoteResponsePtrInput interface {
	pulumi.Input

	ToDocumentNoteResponsePtrOutput() DocumentNoteResponsePtrOutput
	ToDocumentNoteResponsePtrOutputWithContext(context.Context) DocumentNoteResponsePtrOutput
}

type documentNoteResponsePtrType DocumentNoteResponseArgs

func DocumentNoteResponsePtr(v *DocumentNoteResponseArgs) DocumentNoteResponsePtrInput {
	return (*documentNoteResponsePtrType)(v)
}

func (*documentNoteResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DocumentNoteResponse)(nil)).Elem()
}

func (i *documentNoteResponsePtrType) ToDocumentNoteResponsePtrOutput() DocumentNoteResponsePtrOutput {
	return i.ToDocumentNoteResponsePtrOutputWithContext(context.Background())
}

func (i *documentNoteResponsePtrType) ToDocumentNoteResponsePtrOutputWithContext(ctx context.Context) DocumentNoteResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentNoteResponsePtrOutput)
}

// DocumentNote represents an SPDX Document Creation Infromation section: https://spdx.github.io/spdx-spec/2-document-creation-information/
type DocumentNoteResponseOutput struct{ *pulumi.OutputState }

func (DocumentNoteResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DocumentNoteResponse)(nil)).Elem()
}

func (o DocumentNoteResponseOutput) ToDocumentNoteResponseOutput() DocumentNoteResponseOutput {
	return o
}

func (o DocumentNoteResponseOutput) ToDocumentNoteResponseOutputWithContext(ctx context.Context) DocumentNoteResponseOutput {
	return o
}

func (o DocumentNoteResponseOutput) ToDocumentNoteResponsePtrOutput() DocumentNoteResponsePtrOutput {
	return o.ToDocumentNoteResponsePtrOutputWithContext(context.Background())
}

func (o DocumentNoteResponseOutput) ToDocumentNoteResponsePtrOutputWithContext(ctx context.Context) DocumentNoteResponsePtrOutput {
	return o.ApplyT(func(v DocumentNoteResponse) *DocumentNoteResponse {
		return &v
	}).(DocumentNoteResponsePtrOutput)
}

// Compliance with the SPDX specification includes populating the SPDX fields therein with data related to such fields ("SPDX-Metadata")
func (o DocumentNoteResponseOutput) DataLicence() pulumi.StringOutput {
	return o.ApplyT(func(v DocumentNoteResponse) string { return v.DataLicence }).(pulumi.StringOutput)
}

// Provide a reference number that can be used to understand how to parse and interpret the rest of the file
func (o DocumentNoteResponseOutput) SpdxVersion() pulumi.StringOutput {
	return o.ApplyT(func(v DocumentNoteResponse) string { return v.SpdxVersion }).(pulumi.StringOutput)
}

type DocumentNoteResponsePtrOutput struct{ *pulumi.OutputState }

func (DocumentNoteResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DocumentNoteResponse)(nil)).Elem()
}

func (o DocumentNoteResponsePtrOutput) ToDocumentNoteResponsePtrOutput() DocumentNoteResponsePtrOutput {
	return o
}

func (o DocumentNoteResponsePtrOutput) ToDocumentNoteResponsePtrOutputWithContext(ctx context.Context) DocumentNoteResponsePtrOutput {
	return o
}

func (o DocumentNoteResponsePtrOutput) Elem() DocumentNoteResponseOutput {
	return o.ApplyT(func(v *DocumentNoteResponse) DocumentNoteResponse { return *v }).(DocumentNoteResponseOutput)
}

// Compliance with the SPDX specification includes populating the SPDX fields therein with data related to such fields ("SPDX-Metadata")
func (o DocumentNoteResponsePtrOutput) DataLicence() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.DataLicence
	}).(pulumi.StringPtrOutput)
}

// Provide a reference number that can be used to understand how to parse and interpret the rest of the file
func (o DocumentNoteResponsePtrOutput) SpdxVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.SpdxVersion
	}).(pulumi.StringPtrOutput)
}

// DocumentOccurrence represents an SPDX Document Creation Information section: https://spdx.github.io/spdx-spec/2-document-creation-information/
type DocumentOccurrence struct {
	// Identify when the SPDX file was originally created. The date is to be specified according to combined date and time in UTC format as specified in ISO 8601 standard
	CreateTime *string `pulumi:"createTime"`
	// A field for creators of the SPDX file to provide general comments about the creation of the SPDX file or any other relevant comment not included in the other fields
	CreatorComment *string `pulumi:"creatorComment"`
	// Identify who (or what, in the case of a tool) created the SPDX file. If the SPDX file was created by an individual, indicate the person's name
	Creators []string `pulumi:"creators"`
	// A field for creators of the SPDX file content to provide comments to the consumers of the SPDX document
	DocumentComment *string `pulumi:"documentComment"`
	// Identify any external SPDX documents referenced within this SPDX document
	ExternalDocumentRefs []string `pulumi:"externalDocumentRefs"`
	// Identify the current SPDX document which may be referenced in relationships by other files, packages internally and documents externally
	Id *string `pulumi:"id"`
	// A field for creators of the SPDX file to provide the version of the SPDX License List used when the SPDX file was created
	LicenseListVersion *string `pulumi:"licenseListVersion"`
	// Provide an SPDX document specific namespace as a unique absolute Uniform Resource Identifier (URI) as specified in RFC-3986, with the exception of the ‘#’ delimiter
	Namespace *string `pulumi:"namespace"`
	// Identify name of this document as designated by creator
	Title *string `pulumi:"title"`
}

// DocumentOccurrenceInput is an input type that accepts DocumentOccurrenceArgs and DocumentOccurrenceOutput values.
// You can construct a concrete instance of `DocumentOccurrenceInput` via:
//
//          DocumentOccurrenceArgs{...}
type DocumentOccurrenceInput interface {
	pulumi.Input

	ToDocumentOccurrenceOutput() DocumentOccurrenceOutput
	ToDocumentOccurrenceOutputWithContext(context.Context) DocumentOccurrenceOutput
}

// DocumentOccurrence represents an SPDX Document Creation Information section: https://spdx.github.io/spdx-spec/2-document-creation-information/
type DocumentOccurrenceArgs struct {
	// Identify when the SPDX file was originally created. The date is to be specified according to combined date and time in UTC format as specified in ISO 8601 standard
	CreateTime pulumi.StringPtrInput `pulumi:"createTime"`
	// A field for creators of the SPDX file to provide general comments about the creation of the SPDX file or any other relevant comment not included in the other fields
	CreatorComment pulumi.StringPtrInput `pulumi:"creatorComment"`
	// Identify who (or what, in the case of a tool) created the SPDX file. If the SPDX file was created by an individual, indicate the person's name
	Creators pulumi.StringArrayInput `pulumi:"creators"`
	// A field for creators of the SPDX file content to provide comments to the consumers of the SPDX document
	DocumentComment pulumi.StringPtrInput `pulumi:"documentComment"`
	// Identify any external SPDX documents referenced within this SPDX document
	ExternalDocumentRefs pulumi.StringArrayInput `pulumi:"externalDocumentRefs"`
	// Identify the current SPDX document which may be referenced in relationships by other files, packages internally and documents externally
	Id pulumi.StringPtrInput `pulumi:"id"`
	// A field for creators of the SPDX file to provide the version of the SPDX License List used when the SPDX file was created
	LicenseListVersion pulumi.StringPtrInput `pulumi:"licenseListVersion"`
	// Provide an SPDX document specific namespace as a unique absolute Uniform Resource Identifier (URI) as specified in RFC-3986, with the exception of the ‘#’ delimiter
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Identify name of this document as designated by creator
	Title pulumi.StringPtrInput `pulumi:"title"`
}

func (DocumentOccurrenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DocumentOccurrence)(nil)).Elem()
}

func (i DocumentOccurrenceArgs) ToDocumentOccurrenceOutput() DocumentOccurrenceOutput {
	return i.ToDocumentOccurrenceOutputWithContext(context.Background())
}

func (i DocumentOccurrenceArgs) ToDocumentOccurrenceOutputWithContext(ctx context.Context) DocumentOccurrenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentOccurrenceOutput)
}

func (i DocumentOccurrenceArgs) ToDocumentOccurrencePtrOutput() DocumentOccurrencePtrOutput {
	return i.ToDocumentOccurrencePtrOutputWithContext(context.Background())
}

func (i DocumentOccurrenceArgs) ToDocumentOccurrencePtrOutputWithContext(ctx context.Context) DocumentOccurrencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentOccurrenceOutput).ToDocumentOccurrencePtrOutputWithContext(ctx)
}

// DocumentOccurrencePtrInput is an input type that accepts DocumentOccurrenceArgs, DocumentOccurrencePtr and DocumentOccurrencePtrOutput values.
// You can construct a concrete instance of `DocumentOccurrencePtrInput` via:
//
//          DocumentOccurrenceArgs{...}
//
//  or:
//
//          nil
type DocumentOccurrencePtrInput interface {
	pulumi.Input

	ToDocumentOccurrencePtrOutput() DocumentOccurrencePtrOutput
	ToDocumentOccurrencePtrOutputWithContext(context.Context) DocumentOccurrencePtrOutput
}

type documentOccurrencePtrType DocumentOccurrenceArgs

func DocumentOccurrencePtr(v *DocumentOccurrenceArgs) DocumentOccurrencePtrInput {
	return (*documentOccurrencePtrType)(v)
}

func (*documentOccurrencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DocumentOccurrence)(nil)).Elem()
}

func (i *documentOccurrencePtrType) ToDocumentOccurrencePtrOutput() DocumentOccurrencePtrOutput {
	return i.ToDocumentOccurrencePtrOutputWithContext(context.Background())
}

func (i *documentOccurrencePtrType) ToDocumentOccurrencePtrOutputWithContext(ctx context.Context) DocumentOccurrencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentOccurrencePtrOutput)
}

// DocumentOccurrence represents an SPDX Document Creation Information section: https://spdx.github.io/spdx-spec/2-document-creation-information/
type DocumentOccurrenceOutput struct{ *pulumi.OutputState }

func (DocumentOccurrenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DocumentOccurrence)(nil)).Elem()
}

func (o DocumentOccurrenceOutput) ToDocumentOccurrenceOutput() DocumentOccurrenceOutput {
	return o
}

func (o DocumentOccurrenceOutput) ToDocumentOccurrenceOutputWithContext(ctx context.Context) DocumentOccurrenceOutput {
	return o
}

func (o DocumentOccurrenceOutput) ToDocumentOccurrencePtrOutput() DocumentOccurrencePtrOutput {
	return o.ToDocumentOccurrencePtrOutputWithContext(context.Background())
}

func (o DocumentOccurrenceOutput) ToDocumentOccurrencePtrOutputWithContext(ctx context.Context) DocumentOccurrencePtrOutput {
	return o.ApplyT(func(v DocumentOccurrence) *DocumentOccurrence {
		return &v
	}).(DocumentOccurrencePtrOutput)
}

// Identify when the SPDX file was originally created. The date is to be specified according to combined date and time in UTC format as specified in ISO 8601 standard
func (o DocumentOccurrenceOutput) CreateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DocumentOccurrence) *string { return v.CreateTime }).(pulumi.StringPtrOutput)
}

// A field for creators of the SPDX file to provide general comments about the creation of the SPDX file or any other relevant comment not included in the other fields
func (o DocumentOccurrenceOutput) CreatorComment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DocumentOccurrence) *string { return v.CreatorComment }).(pulumi.StringPtrOutput)
}

// Identify who (or what, in the case of a tool) created the SPDX file. If the SPDX file was created by an individual, indicate the person's name
func (o DocumentOccurrenceOutput) Creators() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DocumentOccurrence) []string { return v.Creators }).(pulumi.StringArrayOutput)
}

// A field for creators of the SPDX file content to provide comments to the consumers of the SPDX document
func (o DocumentOccurrenceOutput) DocumentComment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DocumentOccurrence) *string { return v.DocumentComment }).(pulumi.StringPtrOutput)
}

// Identify any external SPDX documents referenced within this SPDX document
func (o DocumentOccurrenceOutput) ExternalDocumentRefs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DocumentOccurrence) []string { return v.ExternalDocumentRefs }).(pulumi.StringArrayOutput)
}

// Identify the current SPDX document which may be referenced in relationships by other files, packages internally and documents externally
func (o DocumentOccurrenceOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DocumentOccurrence) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// A field for creators of the SPDX file to provide the version of the SPDX License List used when the SPDX file was created
func (o DocumentOccurrenceOutput) LicenseListVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DocumentOccurrence) *string { return v.LicenseListVersion }).(pulumi.StringPtrOutput)
}

// Provide an SPDX document specific namespace as a unique absolute Uniform Resource Identifier (URI) as specified in RFC-3986, with the exception of the ‘#’ delimiter
func (o DocumentOccurrenceOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DocumentOccurrence) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Identify name of this document as designated by creator
func (o DocumentOccurrenceOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DocumentOccurrence) *string { return v.Title }).(pulumi.StringPtrOutput)
}

type DocumentOccurrencePtrOutput struct{ *pulumi.OutputState }

func (DocumentOccurrencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DocumentOccurrence)(nil)).Elem()
}

func (o DocumentOccurrencePtrOutput) ToDocumentOccurrencePtrOutput() DocumentOccurrencePtrOutput {
	return o
}

func (o DocumentOccurrencePtrOutput) ToDocumentOccurrencePtrOutputWithContext(ctx context.Context) DocumentOccurrencePtrOutput {
	return o
}

func (o DocumentOccurrencePtrOutput) Elem() DocumentOccurrenceOutput {
	return o.ApplyT(func(v *DocumentOccurrence) DocumentOccurrence { return *v }).(DocumentOccurrenceOutput)
}

// Identify when the SPDX file was originally created. The date is to be specified according to combined date and time in UTC format as specified in ISO 8601 standard
func (o DocumentOccurrencePtrOutput) CreateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.CreateTime
	}).(pulumi.StringPtrOutput)
}

// A field for creators of the SPDX file to provide general comments about the creation of the SPDX file or any other relevant comment not included in the other fields
func (o DocumentOccurrencePtrOutput) CreatorComment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.CreatorComment
	}).(pulumi.StringPtrOutput)
}

// Identify who (or what, in the case of a tool) created the SPDX file. If the SPDX file was created by an individual, indicate the person's name
func (o DocumentOccurrencePtrOutput) Creators() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DocumentOccurrence) []string {
		if v == nil {
			return nil
		}
		return v.Creators
	}).(pulumi.StringArrayOutput)
}

// A field for creators of the SPDX file content to provide comments to the consumers of the SPDX document
func (o DocumentOccurrencePtrOutput) DocumentComment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.DocumentComment
	}).(pulumi.StringPtrOutput)
}

// Identify any external SPDX documents referenced within this SPDX document
func (o DocumentOccurrencePtrOutput) ExternalDocumentRefs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DocumentOccurrence) []string {
		if v == nil {
			return nil
		}
		return v.ExternalDocumentRefs
	}).(pulumi.StringArrayOutput)
}

// Identify the current SPDX document which may be referenced in relationships by other files, packages internally and documents externally
func (o DocumentOccurrencePtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

// A field for creators of the SPDX file to provide the version of the SPDX License List used when the SPDX file was created
func (o DocumentOccurrencePtrOutput) LicenseListVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.LicenseListVersion
	}).(pulumi.StringPtrOutput)
}

// Provide an SPDX document specific namespace as a unique absolute Uniform Resource Identifier (URI) as specified in RFC-3986, with the exception of the ‘#’ delimiter
func (o DocumentOccurrencePtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Identify name of this document as designated by creator
func (o DocumentOccurrencePtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// DocumentOccurrence represents an SPDX Document Creation Information section: https://spdx.github.io/spdx-spec/2-document-creation-information/
type DocumentOccurrenceResponse struct {
	// Identify when the SPDX file was originally created. The date is to be specified according to combined date and time in UTC format as specified in ISO 8601 standard
	CreateTime string `pulumi:"createTime"`
	// A field for creators of the SPDX file to provide general comments about the creation of the SPDX file or any other relevant comment not included in the other fields
	CreatorComment string `pulumi:"creatorComment"`
	// Identify who (or what, in the case of a tool) created the SPDX file. If the SPDX file was created by an individual, indicate the person's name
	Creators []string `pulumi:"creators"`
	// A field for creators of the SPDX file content to provide comments to the consumers of the SPDX document
	DocumentComment string `pulumi:"documentComment"`
	// Identify any external SPDX documents referenced within this SPDX document
	ExternalDocumentRefs []string `pulumi:"externalDocumentRefs"`
	// A field for creators of the SPDX file to provide the version of the SPDX License List used when the SPDX file was created
	LicenseListVersion string `pulumi:"licenseListVersion"`
	// Provide an SPDX document specific namespace as a unique absolute Uniform Resource Identifier (URI) as specified in RFC-3986, with the exception of the ‘#’ delimiter
	Namespace string `pulumi:"namespace"`
	// Identify name of this document as designated by creator
	Title string `pulumi:"title"`
}

// DocumentOccurrenceResponseInput is an input type that accepts DocumentOccurrenceResponseArgs and DocumentOccurrenceResponseOutput values.
// You can construct a concrete instance of `DocumentOccurrenceResponseInput` via:
//
//          DocumentOccurrenceResponseArgs{...}
type DocumentOccurrenceResponseInput interface {
	pulumi.Input

	ToDocumentOccurrenceResponseOutput() DocumentOccurrenceResponseOutput
	ToDocumentOccurrenceResponseOutputWithContext(context.Context) DocumentOccurrenceResponseOutput
}

// DocumentOccurrence represents an SPDX Document Creation Information section: https://spdx.github.io/spdx-spec/2-document-creation-information/
type DocumentOccurrenceResponseArgs struct {
	// Identify when the SPDX file was originally created. The date is to be specified according to combined date and time in UTC format as specified in ISO 8601 standard
	CreateTime pulumi.StringInput `pulumi:"createTime"`
	// A field for creators of the SPDX file to provide general comments about the creation of the SPDX file or any other relevant comment not included in the other fields
	CreatorComment pulumi.StringInput `pulumi:"creatorComment"`
	// Identify who (or what, in the case of a tool) created the SPDX file. If the SPDX file was created by an individual, indicate the person's name
	Creators pulumi.StringArrayInput `pulumi:"creators"`
	// A field for creators of the SPDX file content to provide comments to the consumers of the SPDX document
	DocumentComment pulumi.StringInput `pulumi:"documentComment"`
	// Identify any external SPDX documents referenced within this SPDX document
	ExternalDocumentRefs pulumi.StringArrayInput `pulumi:"externalDocumentRefs"`
	// A field for creators of the SPDX file to provide the version of the SPDX License List used when the SPDX file was created
	LicenseListVersion pulumi.StringInput `pulumi:"licenseListVersion"`
	// Provide an SPDX document specific namespace as a unique absolute Uniform Resource Identifier (URI) as specified in RFC-3986, with the exception of the ‘#’ delimiter
	Namespace pulumi.StringInput `pulumi:"namespace"`
	// Identify name of this document as designated by creator
	Title pulumi.StringInput `pulumi:"title"`
}

func (DocumentOccurrenceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DocumentOccurrenceResponse)(nil)).Elem()
}

func (i DocumentOccurrenceResponseArgs) ToDocumentOccurrenceResponseOutput() DocumentOccurrenceResponseOutput {
	return i.ToDocumentOccurrenceResponseOutputWithContext(context.Background())
}

func (i DocumentOccurrenceResponseArgs) ToDocumentOccurrenceResponseOutputWithContext(ctx context.Context) DocumentOccurrenceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentOccurrenceResponseOutput)
}

func (i DocumentOccurrenceResponseArgs) ToDocumentOccurrenceResponsePtrOutput() DocumentOccurrenceResponsePtrOutput {
	return i.ToDocumentOccurrenceResponsePtrOutputWithContext(context.Background())
}

func (i DocumentOccurrenceResponseArgs) ToDocumentOccurrenceResponsePtrOutputWithContext(ctx context.Context) DocumentOccurrenceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentOccurrenceResponseOutput).ToDocumentOccurrenceResponsePtrOutputWithContext(ctx)
}

// DocumentOccurrenceResponsePtrInput is an input type that accepts DocumentOccurrenceResponseArgs, DocumentOccurrenceResponsePtr and DocumentOccurrenceResponsePtrOutput values.
// You can construct a concrete instance of `DocumentOccurrenceResponsePtrInput` via:
//
//          DocumentOccurrenceResponseArgs{...}
//
//  or:
//
//          nil
type DocumentOccurrenceResponsePtrInput interface {
	pulumi.Input

	ToDocumentOccurrenceResponsePtrOutput() DocumentOccurrenceResponsePtrOutput
	ToDocumentOccurrenceResponsePtrOutputWithContext(context.Context) DocumentOccurrenceResponsePtrOutput
}

type documentOccurrenceResponsePtrType DocumentOccurrenceResponseArgs

func DocumentOccurrenceResponsePtr(v *DocumentOccurrenceResponseArgs) DocumentOccurrenceResponsePtrInput {
	return (*documentOccurrenceResponsePtrType)(v)
}

func (*documentOccurrenceResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DocumentOccurrenceResponse)(nil)).Elem()
}

func (i *documentOccurrenceResponsePtrType) ToDocumentOccurrenceResponsePtrOutput() DocumentOccurrenceResponsePtrOutput {
	return i.ToDocumentOccurrenceResponsePtrOutputWithContext(context.Background())
}

func (i *documentOccurrenceResponsePtrType) ToDocumentOccurrenceResponsePtrOutputWithContext(ctx context.Context) DocumentOccurrenceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentOccurrenceResponsePtrOutput)
}

// DocumentOccurrence represents an SPDX Document Creation Information section: https://spdx.github.io/spdx-spec/2-document-creation-information/
type DocumentOccurrenceResponseOutput struct{ *pulumi.OutputState }

func (DocumentOccurrenceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DocumentOccurrenceResponse)(nil)).Elem()
}

func (o DocumentOccurrenceResponseOutput) ToDocumentOccurrenceResponseOutput() DocumentOccurrenceResponseOutput {
	return o
}

func (o DocumentOccurrenceResponseOutput) ToDocumentOccurrenceResponseOutputWithContext(ctx context.Context) DocumentOccurrenceResponseOutput {
	return o
}

func (o DocumentOccurrenceResponseOutput) ToDocumentOccurrenceResponsePtrOutput() DocumentOccurrenceResponsePtrOutput {
	return o.ToDocumentOccurrenceResponsePtrOutputWithContext(context.Background())
}

func (o DocumentOccurrenceResponseOutput) ToDocumentOccurrenceResponsePtrOutputWithContext(ctx context.Context) DocumentOccurrenceResponsePtrOutput {
	return o.ApplyT(func(v DocumentOccurrenceResponse) *DocumentOccurrenceResponse {
		return &v
	}).(DocumentOccurrenceResponsePtrOutput)
}

// Identify when the SPDX file was originally created. The date is to be specified according to combined date and time in UTC format as specified in ISO 8601 standard
func (o DocumentOccurrenceResponseOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v DocumentOccurrenceResponse) string { return v.CreateTime }).(pulumi.StringOutput)
}

// A field for creators of the SPDX file to provide general comments about the creation of the SPDX file or any other relevant comment not included in the other fields
func (o DocumentOccurrenceResponseOutput) CreatorComment() pulumi.StringOutput {
	return o.ApplyT(func(v DocumentOccurrenceResponse) string { return v.CreatorComment }).(pulumi.StringOutput)
}

// Identify who (or what, in the case of a tool) created the SPDX file. If the SPDX file was created by an individual, indicate the person's name
func (o DocumentOccurrenceResponseOutput) Creators() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DocumentOccurrenceResponse) []string { return v.Creators }).(pulumi.StringArrayOutput)
}

// A field for creators of the SPDX file content to provide comments to the consumers of the SPDX document
func (o DocumentOccurrenceResponseOutput) DocumentComment() pulumi.StringOutput {
	return o.ApplyT(func(v DocumentOccurrenceResponse) string { return v.DocumentComment }).(pulumi.StringOutput)
}

// Identify any external SPDX documents referenced within this SPDX document
func (o DocumentOccurrenceResponseOutput) ExternalDocumentRefs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DocumentOccurrenceResponse) []string { return v.ExternalDocumentRefs }).(pulumi.StringArrayOutput)
}

// A field for creators of the SPDX file to provide the version of the SPDX License List used when the SPDX file was created
func (o DocumentOccurrenceResponseOutput) LicenseListVersion() pulumi.StringOutput {
	return o.ApplyT(func(v DocumentOccurrenceResponse) string { return v.LicenseListVersion }).(pulumi.StringOutput)
}

// Provide an SPDX document specific namespace as a unique absolute Uniform Resource Identifier (URI) as specified in RFC-3986, with the exception of the ‘#’ delimiter
func (o DocumentOccurrenceResponseOutput) Namespace() pulumi.StringOutput {
	return o.ApplyT(func(v DocumentOccurrenceResponse) string { return v.Namespace }).(pulumi.StringOutput)
}

// Identify name of this document as designated by creator
func (o DocumentOccurrenceResponseOutput) Title() pulumi.StringOutput {
	return o.ApplyT(func(v DocumentOccurrenceResponse) string { return v.Title }).(pulumi.StringOutput)
}

type DocumentOccurrenceResponsePtrOutput struct{ *pulumi.OutputState }

func (DocumentOccurrenceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DocumentOccurrenceResponse)(nil)).Elem()
}

func (o DocumentOccurrenceResponsePtrOutput) ToDocumentOccurrenceResponsePtrOutput() DocumentOccurrenceResponsePtrOutput {
	return o
}

func (o DocumentOccurrenceResponsePtrOutput) ToDocumentOccurrenceResponsePtrOutputWithContext(ctx context.Context) DocumentOccurrenceResponsePtrOutput {
	return o
}

func (o DocumentOccurrenceResponsePtrOutput) Elem() DocumentOccurrenceResponseOutput {
	return o.ApplyT(func(v *DocumentOccurrenceResponse) DocumentOccurrenceResponse { return *v }).(DocumentOccurrenceResponseOutput)
}

// Identify when the SPDX file was originally created. The date is to be specified according to combined date and time in UTC format as specified in ISO 8601 standard
func (o DocumentOccurrenceResponsePtrOutput) CreateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.CreateTime
	}).(pulumi.StringPtrOutput)
}

// A field for creators of the SPDX file to provide general comments about the creation of the SPDX file or any other relevant comment not included in the other fields
func (o DocumentOccurrenceResponsePtrOutput) CreatorComment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.CreatorComment
	}).(pulumi.StringPtrOutput)
}

// Identify who (or what, in the case of a tool) created the SPDX file. If the SPDX file was created by an individual, indicate the person's name
func (o DocumentOccurrenceResponsePtrOutput) Creators() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DocumentOccurrenceResponse) []string {
		if v == nil {
			return nil
		}
		return v.Creators
	}).(pulumi.StringArrayOutput)
}

// A field for creators of the SPDX file content to provide comments to the consumers of the SPDX document
func (o DocumentOccurrenceResponsePtrOutput) DocumentComment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.DocumentComment
	}).(pulumi.StringPtrOutput)
}

// Identify any external SPDX documents referenced within this SPDX document
func (o DocumentOccurrenceResponsePtrOutput) ExternalDocumentRefs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DocumentOccurrenceResponse) []string {
		if v == nil {
			return nil
		}
		return v.ExternalDocumentRefs
	}).(pulumi.StringArrayOutput)
}

// A field for creators of the SPDX file to provide the version of the SPDX License List used when the SPDX file was created
func (o DocumentOccurrenceResponsePtrOutput) LicenseListVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.LicenseListVersion
	}).(pulumi.StringPtrOutput)
}

// Provide an SPDX document specific namespace as a unique absolute Uniform Resource Identifier (URI) as specified in RFC-3986, with the exception of the ‘#’ delimiter
func (o DocumentOccurrenceResponsePtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Identify name of this document as designated by creator
func (o DocumentOccurrenceResponsePtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DocumentOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Title
	}).(pulumi.StringPtrOutput)
}

// Defines an object for the environment field in in-toto links. The suggested fields are "variables", "filesystem", and "workdir".
type Environment struct {
	CustomValues map[string]string `pulumi:"customValues"`
}

// EnvironmentInput is an input type that accepts EnvironmentArgs and EnvironmentOutput values.
// You can construct a concrete instance of `EnvironmentInput` via:
//
//          EnvironmentArgs{...}
type EnvironmentInput interface {
	pulumi.Input

	ToEnvironmentOutput() EnvironmentOutput
	ToEnvironmentOutputWithContext(context.Context) EnvironmentOutput
}

// Defines an object for the environment field in in-toto links. The suggested fields are "variables", "filesystem", and "workdir".
type EnvironmentArgs struct {
	CustomValues pulumi.StringMapInput `pulumi:"customValues"`
}

func (EnvironmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Environment)(nil)).Elem()
}

func (i EnvironmentArgs) ToEnvironmentOutput() EnvironmentOutput {
	return i.ToEnvironmentOutputWithContext(context.Background())
}

func (i EnvironmentArgs) ToEnvironmentOutputWithContext(ctx context.Context) EnvironmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentOutput)
}

func (i EnvironmentArgs) ToEnvironmentPtrOutput() EnvironmentPtrOutput {
	return i.ToEnvironmentPtrOutputWithContext(context.Background())
}

func (i EnvironmentArgs) ToEnvironmentPtrOutputWithContext(ctx context.Context) EnvironmentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentOutput).ToEnvironmentPtrOutputWithContext(ctx)
}

// EnvironmentPtrInput is an input type that accepts EnvironmentArgs, EnvironmentPtr and EnvironmentPtrOutput values.
// You can construct a concrete instance of `EnvironmentPtrInput` via:
//
//          EnvironmentArgs{...}
//
//  or:
//
//          nil
type EnvironmentPtrInput interface {
	pulumi.Input

	ToEnvironmentPtrOutput() EnvironmentPtrOutput
	ToEnvironmentPtrOutputWithContext(context.Context) EnvironmentPtrOutput
}

type environmentPtrType EnvironmentArgs

func EnvironmentPtr(v *EnvironmentArgs) EnvironmentPtrInput {
	return (*environmentPtrType)(v)
}

func (*environmentPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Environment)(nil)).Elem()
}

func (i *environmentPtrType) ToEnvironmentPtrOutput() EnvironmentPtrOutput {
	return i.ToEnvironmentPtrOutputWithContext(context.Background())
}

func (i *environmentPtrType) ToEnvironmentPtrOutputWithContext(ctx context.Context) EnvironmentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentPtrOutput)
}

// Defines an object for the environment field in in-toto links. The suggested fields are "variables", "filesystem", and "workdir".
type EnvironmentOutput struct{ *pulumi.OutputState }

func (EnvironmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Environment)(nil)).Elem()
}

func (o EnvironmentOutput) ToEnvironmentOutput() EnvironmentOutput {
	return o
}

func (o EnvironmentOutput) ToEnvironmentOutputWithContext(ctx context.Context) EnvironmentOutput {
	return o
}

func (o EnvironmentOutput) ToEnvironmentPtrOutput() EnvironmentPtrOutput {
	return o.ToEnvironmentPtrOutputWithContext(context.Background())
}

func (o EnvironmentOutput) ToEnvironmentPtrOutputWithContext(ctx context.Context) EnvironmentPtrOutput {
	return o.ApplyT(func(v Environment) *Environment {
		return &v
	}).(EnvironmentPtrOutput)
}
func (o EnvironmentOutput) CustomValues() pulumi.StringMapOutput {
	return o.ApplyT(func(v Environment) map[string]string { return v.CustomValues }).(pulumi.StringMapOutput)
}

type EnvironmentPtrOutput struct{ *pulumi.OutputState }

func (EnvironmentPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Environment)(nil)).Elem()
}

func (o EnvironmentPtrOutput) ToEnvironmentPtrOutput() EnvironmentPtrOutput {
	return o
}

func (o EnvironmentPtrOutput) ToEnvironmentPtrOutputWithContext(ctx context.Context) EnvironmentPtrOutput {
	return o
}

func (o EnvironmentPtrOutput) Elem() EnvironmentOutput {
	return o.ApplyT(func(v *Environment) Environment { return *v }).(EnvironmentOutput)
}

func (o EnvironmentPtrOutput) CustomValues() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Environment) map[string]string {
		if v == nil {
			return nil
		}
		return v.CustomValues
	}).(pulumi.StringMapOutput)
}

// Defines an object for the environment field in in-toto links. The suggested fields are "variables", "filesystem", and "workdir".
type EnvironmentResponse struct {
	CustomValues map[string]string `pulumi:"customValues"`
}

// EnvironmentResponseInput is an input type that accepts EnvironmentResponseArgs and EnvironmentResponseOutput values.
// You can construct a concrete instance of `EnvironmentResponseInput` via:
//
//          EnvironmentResponseArgs{...}
type EnvironmentResponseInput interface {
	pulumi.Input

	ToEnvironmentResponseOutput() EnvironmentResponseOutput
	ToEnvironmentResponseOutputWithContext(context.Context) EnvironmentResponseOutput
}

// Defines an object for the environment field in in-toto links. The suggested fields are "variables", "filesystem", and "workdir".
type EnvironmentResponseArgs struct {
	CustomValues pulumi.StringMapInput `pulumi:"customValues"`
}

func (EnvironmentResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentResponse)(nil)).Elem()
}

func (i EnvironmentResponseArgs) ToEnvironmentResponseOutput() EnvironmentResponseOutput {
	return i.ToEnvironmentResponseOutputWithContext(context.Background())
}

func (i EnvironmentResponseArgs) ToEnvironmentResponseOutputWithContext(ctx context.Context) EnvironmentResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentResponseOutput)
}

func (i EnvironmentResponseArgs) ToEnvironmentResponsePtrOutput() EnvironmentResponsePtrOutput {
	return i.ToEnvironmentResponsePtrOutputWithContext(context.Background())
}

func (i EnvironmentResponseArgs) ToEnvironmentResponsePtrOutputWithContext(ctx context.Context) EnvironmentResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentResponseOutput).ToEnvironmentResponsePtrOutputWithContext(ctx)
}

// EnvironmentResponsePtrInput is an input type that accepts EnvironmentResponseArgs, EnvironmentResponsePtr and EnvironmentResponsePtrOutput values.
// You can construct a concrete instance of `EnvironmentResponsePtrInput` via:
//
//          EnvironmentResponseArgs{...}
//
//  or:
//
//          nil
type EnvironmentResponsePtrInput interface {
	pulumi.Input

	ToEnvironmentResponsePtrOutput() EnvironmentResponsePtrOutput
	ToEnvironmentResponsePtrOutputWithContext(context.Context) EnvironmentResponsePtrOutput
}

type environmentResponsePtrType EnvironmentResponseArgs

func EnvironmentResponsePtr(v *EnvironmentResponseArgs) EnvironmentResponsePtrInput {
	return (*environmentResponsePtrType)(v)
}

func (*environmentResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EnvironmentResponse)(nil)).Elem()
}

func (i *environmentResponsePtrType) ToEnvironmentResponsePtrOutput() EnvironmentResponsePtrOutput {
	return i.ToEnvironmentResponsePtrOutputWithContext(context.Background())
}

func (i *environmentResponsePtrType) ToEnvironmentResponsePtrOutputWithContext(ctx context.Context) EnvironmentResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentResponsePtrOutput)
}

// Defines an object for the environment field in in-toto links. The suggested fields are "variables", "filesystem", and "workdir".
type EnvironmentResponseOutput struct{ *pulumi.OutputState }

func (EnvironmentResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentResponse)(nil)).Elem()
}

func (o EnvironmentResponseOutput) ToEnvironmentResponseOutput() EnvironmentResponseOutput {
	return o
}

func (o EnvironmentResponseOutput) ToEnvironmentResponseOutputWithContext(ctx context.Context) EnvironmentResponseOutput {
	return o
}

func (o EnvironmentResponseOutput) ToEnvironmentResponsePtrOutput() EnvironmentResponsePtrOutput {
	return o.ToEnvironmentResponsePtrOutputWithContext(context.Background())
}

func (o EnvironmentResponseOutput) ToEnvironmentResponsePtrOutputWithContext(ctx context.Context) EnvironmentResponsePtrOutput {
	return o.ApplyT(func(v EnvironmentResponse) *EnvironmentResponse {
		return &v
	}).(EnvironmentResponsePtrOutput)
}
func (o EnvironmentResponseOutput) CustomValues() pulumi.StringMapOutput {
	return o.ApplyT(func(v EnvironmentResponse) map[string]string { return v.CustomValues }).(pulumi.StringMapOutput)
}

type EnvironmentResponsePtrOutput struct{ *pulumi.OutputState }

func (EnvironmentResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EnvironmentResponse)(nil)).Elem()
}

func (o EnvironmentResponsePtrOutput) ToEnvironmentResponsePtrOutput() EnvironmentResponsePtrOutput {
	return o
}

func (o EnvironmentResponsePtrOutput) ToEnvironmentResponsePtrOutputWithContext(ctx context.Context) EnvironmentResponsePtrOutput {
	return o
}

func (o EnvironmentResponsePtrOutput) Elem() EnvironmentResponseOutput {
	return o.ApplyT(func(v *EnvironmentResponse) EnvironmentResponse { return *v }).(EnvironmentResponseOutput)
}

func (o EnvironmentResponsePtrOutput) CustomValues() pulumi.StringMapOutput {
	return o.ApplyT(func(v *EnvironmentResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.CustomValues
	}).(pulumi.StringMapOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type Expr struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description *string `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression *string `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location *string `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title *string `pulumi:"title"`
}

// ExprInput is an input type that accepts ExprArgs and ExprOutput values.
// You can construct a concrete instance of `ExprInput` via:
//
//          ExprArgs{...}
type ExprInput interface {
	pulumi.Input

	ToExprOutput() ExprOutput
	ToExprOutputWithContext(context.Context) ExprOutput
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprArgs struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression pulumi.StringPtrInput `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title pulumi.StringPtrInput `pulumi:"title"`
}

func (ExprArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (i ExprArgs) ToExprOutput() ExprOutput {
	return i.ToExprOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput)
}

func (i ExprArgs) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput).ToExprPtrOutputWithContext(ctx)
}

// ExprPtrInput is an input type that accepts ExprArgs, ExprPtr and ExprPtrOutput values.
// You can construct a concrete instance of `ExprPtrInput` via:
//
//          ExprArgs{...}
//
//  or:
//
//          nil
type ExprPtrInput interface {
	pulumi.Input

	ToExprPtrOutput() ExprPtrOutput
	ToExprPtrOutputWithContext(context.Context) ExprPtrOutput
}

type exprPtrType ExprArgs

func ExprPtr(v *ExprArgs) ExprPtrInput {
	return (*exprPtrType)(v)
}

func (*exprPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (i *exprPtrType) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i *exprPtrType) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprOutput struct{ *pulumi.OutputState }

func (ExprOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (o ExprOutput) ToExprOutput() ExprOutput {
	return o
}

func (o ExprOutput) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return o
}

func (o ExprOutput) ToExprPtrOutput() ExprPtrOutput {
	return o.ToExprPtrOutputWithContext(context.Background())
}

func (o ExprOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o.ApplyT(func(v Expr) *Expr {
		return &v
	}).(ExprPtrOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Expression }).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Title }).(pulumi.StringPtrOutput)
}

type ExprPtrOutput struct{ *pulumi.OutputState }

func (ExprPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (o ExprPtrOutput) ToExprPtrOutput() ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) Elem() ExprOutput {
	return o.ApplyT(func(v *Expr) Expr { return *v }).(ExprOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprPtrOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Expression
	}).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprPtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprPtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprResponse struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description string `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression string `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location string `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title string `pulumi:"title"`
}

// ExprResponseInput is an input type that accepts ExprResponseArgs and ExprResponseOutput values.
// You can construct a concrete instance of `ExprResponseInput` via:
//
//          ExprResponseArgs{...}
type ExprResponseInput interface {
	pulumi.Input

	ToExprResponseOutput() ExprResponseOutput
	ToExprResponseOutputWithContext(context.Context) ExprResponseOutput
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprResponseArgs struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description pulumi.StringInput `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression pulumi.StringInput `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location pulumi.StringInput `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title pulumi.StringInput `pulumi:"title"`
}

func (ExprResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ExprResponse)(nil)).Elem()
}

func (i ExprResponseArgs) ToExprResponseOutput() ExprResponseOutput {
	return i.ToExprResponseOutputWithContext(context.Background())
}

func (i ExprResponseArgs) ToExprResponseOutputWithContext(ctx context.Context) ExprResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprResponseOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprResponseOutput struct{ *pulumi.OutputState }

func (ExprResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExprResponse)(nil)).Elem()
}

func (o ExprResponseOutput) ToExprResponseOutput() ExprResponseOutput {
	return o
}

func (o ExprResponseOutput) ToExprResponseOutputWithContext(ctx context.Context) ExprResponseOutput {
	return o
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Description }).(pulumi.StringOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprResponseOutput) Expression() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Expression }).(pulumi.StringOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprResponseOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Location }).(pulumi.StringOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprResponseOutput) Title() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Title }).(pulumi.StringOutput)
}

// An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package
type ExternalRef struct {
	// An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package
	Category *ExternalRefCategory `pulumi:"category"`
	// Human-readable information about the purpose and target of the reference
	Comment *string `pulumi:"comment"`
	// The unique string with no spaces necessary to access the package-specific information, metadata, or content within the target location
	Locator *string `pulumi:"locator"`
	// Type of category (e.g. 'npm' for the PACKAGE_MANAGER category)
	Type *string `pulumi:"type"`
}

// ExternalRefInput is an input type that accepts ExternalRefArgs and ExternalRefOutput values.
// You can construct a concrete instance of `ExternalRefInput` via:
//
//          ExternalRefArgs{...}
type ExternalRefInput interface {
	pulumi.Input

	ToExternalRefOutput() ExternalRefOutput
	ToExternalRefOutputWithContext(context.Context) ExternalRefOutput
}

// An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package
type ExternalRefArgs struct {
	// An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package
	Category ExternalRefCategoryPtrInput `pulumi:"category"`
	// Human-readable information about the purpose and target of the reference
	Comment pulumi.StringPtrInput `pulumi:"comment"`
	// The unique string with no spaces necessary to access the package-specific information, metadata, or content within the target location
	Locator pulumi.StringPtrInput `pulumi:"locator"`
	// Type of category (e.g. 'npm' for the PACKAGE_MANAGER category)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (ExternalRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ExternalRef)(nil)).Elem()
}

func (i ExternalRefArgs) ToExternalRefOutput() ExternalRefOutput {
	return i.ToExternalRefOutputWithContext(context.Background())
}

func (i ExternalRefArgs) ToExternalRefOutputWithContext(ctx context.Context) ExternalRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExternalRefOutput)
}

// ExternalRefArrayInput is an input type that accepts ExternalRefArray and ExternalRefArrayOutput values.
// You can construct a concrete instance of `ExternalRefArrayInput` via:
//
//          ExternalRefArray{ ExternalRefArgs{...} }
type ExternalRefArrayInput interface {
	pulumi.Input

	ToExternalRefArrayOutput() ExternalRefArrayOutput
	ToExternalRefArrayOutputWithContext(context.Context) ExternalRefArrayOutput
}

type ExternalRefArray []ExternalRefInput

func (ExternalRefArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ExternalRef)(nil)).Elem()
}

func (i ExternalRefArray) ToExternalRefArrayOutput() ExternalRefArrayOutput {
	return i.ToExternalRefArrayOutputWithContext(context.Background())
}

func (i ExternalRefArray) ToExternalRefArrayOutputWithContext(ctx context.Context) ExternalRefArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExternalRefArrayOutput)
}

// An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package
type ExternalRefOutput struct{ *pulumi.OutputState }

func (ExternalRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExternalRef)(nil)).Elem()
}

func (o ExternalRefOutput) ToExternalRefOutput() ExternalRefOutput {
	return o
}

func (o ExternalRefOutput) ToExternalRefOutputWithContext(ctx context.Context) ExternalRefOutput {
	return o
}

// An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package
func (o ExternalRefOutput) Category() ExternalRefCategoryPtrOutput {
	return o.ApplyT(func(v ExternalRef) *ExternalRefCategory { return v.Category }).(ExternalRefCategoryPtrOutput)
}

// Human-readable information about the purpose and target of the reference
func (o ExternalRefOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ExternalRef) *string { return v.Comment }).(pulumi.StringPtrOutput)
}

// The unique string with no spaces necessary to access the package-specific information, metadata, or content within the target location
func (o ExternalRefOutput) Locator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ExternalRef) *string { return v.Locator }).(pulumi.StringPtrOutput)
}

// Type of category (e.g. 'npm' for the PACKAGE_MANAGER category)
func (o ExternalRefOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ExternalRef) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type ExternalRefArrayOutput struct{ *pulumi.OutputState }

func (ExternalRefArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ExternalRef)(nil)).Elem()
}

func (o ExternalRefArrayOutput) ToExternalRefArrayOutput() ExternalRefArrayOutput {
	return o
}

func (o ExternalRefArrayOutput) ToExternalRefArrayOutputWithContext(ctx context.Context) ExternalRefArrayOutput {
	return o
}

func (o ExternalRefArrayOutput) Index(i pulumi.IntInput) ExternalRefOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ExternalRef {
		return vs[0].([]ExternalRef)[vs[1].(int)]
	}).(ExternalRefOutput)
}

// An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package
type ExternalRefResponse struct {
	// An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package
	Category string `pulumi:"category"`
	// Human-readable information about the purpose and target of the reference
	Comment string `pulumi:"comment"`
	// The unique string with no spaces necessary to access the package-specific information, metadata, or content within the target location
	Locator string `pulumi:"locator"`
	// Type of category (e.g. 'npm' for the PACKAGE_MANAGER category)
	Type string `pulumi:"type"`
}

// ExternalRefResponseInput is an input type that accepts ExternalRefResponseArgs and ExternalRefResponseOutput values.
// You can construct a concrete instance of `ExternalRefResponseInput` via:
//
//          ExternalRefResponseArgs{...}
type ExternalRefResponseInput interface {
	pulumi.Input

	ToExternalRefResponseOutput() ExternalRefResponseOutput
	ToExternalRefResponseOutputWithContext(context.Context) ExternalRefResponseOutput
}

// An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package
type ExternalRefResponseArgs struct {
	// An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package
	Category pulumi.StringInput `pulumi:"category"`
	// Human-readable information about the purpose and target of the reference
	Comment pulumi.StringInput `pulumi:"comment"`
	// The unique string with no spaces necessary to access the package-specific information, metadata, or content within the target location
	Locator pulumi.StringInput `pulumi:"locator"`
	// Type of category (e.g. 'npm' for the PACKAGE_MANAGER category)
	Type pulumi.StringInput `pulumi:"type"`
}

func (ExternalRefResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ExternalRefResponse)(nil)).Elem()
}

func (i ExternalRefResponseArgs) ToExternalRefResponseOutput() ExternalRefResponseOutput {
	return i.ToExternalRefResponseOutputWithContext(context.Background())
}

func (i ExternalRefResponseArgs) ToExternalRefResponseOutputWithContext(ctx context.Context) ExternalRefResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExternalRefResponseOutput)
}

// ExternalRefResponseArrayInput is an input type that accepts ExternalRefResponseArray and ExternalRefResponseArrayOutput values.
// You can construct a concrete instance of `ExternalRefResponseArrayInput` via:
//
//          ExternalRefResponseArray{ ExternalRefResponseArgs{...} }
type ExternalRefResponseArrayInput interface {
	pulumi.Input

	ToExternalRefResponseArrayOutput() ExternalRefResponseArrayOutput
	ToExternalRefResponseArrayOutputWithContext(context.Context) ExternalRefResponseArrayOutput
}

type ExternalRefResponseArray []ExternalRefResponseInput

func (ExternalRefResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ExternalRefResponse)(nil)).Elem()
}

func (i ExternalRefResponseArray) ToExternalRefResponseArrayOutput() ExternalRefResponseArrayOutput {
	return i.ToExternalRefResponseArrayOutputWithContext(context.Background())
}

func (i ExternalRefResponseArray) ToExternalRefResponseArrayOutputWithContext(ctx context.Context) ExternalRefResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExternalRefResponseArrayOutput)
}

// An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package
type ExternalRefResponseOutput struct{ *pulumi.OutputState }

func (ExternalRefResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExternalRefResponse)(nil)).Elem()
}

func (o ExternalRefResponseOutput) ToExternalRefResponseOutput() ExternalRefResponseOutput {
	return o
}

func (o ExternalRefResponseOutput) ToExternalRefResponseOutputWithContext(ctx context.Context) ExternalRefResponseOutput {
	return o
}

// An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package
func (o ExternalRefResponseOutput) Category() pulumi.StringOutput {
	return o.ApplyT(func(v ExternalRefResponse) string { return v.Category }).(pulumi.StringOutput)
}

// Human-readable information about the purpose and target of the reference
func (o ExternalRefResponseOutput) Comment() pulumi.StringOutput {
	return o.ApplyT(func(v ExternalRefResponse) string { return v.Comment }).(pulumi.StringOutput)
}

// The unique string with no spaces necessary to access the package-specific information, metadata, or content within the target location
func (o ExternalRefResponseOutput) Locator() pulumi.StringOutput {
	return o.ApplyT(func(v ExternalRefResponse) string { return v.Locator }).(pulumi.StringOutput)
}

// Type of category (e.g. 'npm' for the PACKAGE_MANAGER category)
func (o ExternalRefResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ExternalRefResponse) string { return v.Type }).(pulumi.StringOutput)
}

type ExternalRefResponseArrayOutput struct{ *pulumi.OutputState }

func (ExternalRefResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ExternalRefResponse)(nil)).Elem()
}

func (o ExternalRefResponseArrayOutput) ToExternalRefResponseArrayOutput() ExternalRefResponseArrayOutput {
	return o
}

func (o ExternalRefResponseArrayOutput) ToExternalRefResponseArrayOutputWithContext(ctx context.Context) ExternalRefResponseArrayOutput {
	return o
}

func (o ExternalRefResponseArrayOutput) Index(i pulumi.IntInput) ExternalRefResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ExternalRefResponse {
		return vs[0].([]ExternalRefResponse)[vs[1].(int)]
	}).(ExternalRefResponseOutput)
}

// FileNote represents an SPDX File Information section: https://spdx.github.io/spdx-spec/4-file-information/
type FileNote struct {
	// Provide a unique identifier to match analysis information on each specific file in a package
	Checksum []string `pulumi:"checksum"`
	// This field provides information about the type of file identified
	FileType *FileNoteFileType `pulumi:"fileType"`
	// Identify the full path and filename that corresponds to the file information in this section
	Title *string `pulumi:"title"`
}

// FileNoteInput is an input type that accepts FileNoteArgs and FileNoteOutput values.
// You can construct a concrete instance of `FileNoteInput` via:
//
//          FileNoteArgs{...}
type FileNoteInput interface {
	pulumi.Input

	ToFileNoteOutput() FileNoteOutput
	ToFileNoteOutputWithContext(context.Context) FileNoteOutput
}

// FileNote represents an SPDX File Information section: https://spdx.github.io/spdx-spec/4-file-information/
type FileNoteArgs struct {
	// Provide a unique identifier to match analysis information on each specific file in a package
	Checksum pulumi.StringArrayInput `pulumi:"checksum"`
	// This field provides information about the type of file identified
	FileType FileNoteFileTypePtrInput `pulumi:"fileType"`
	// Identify the full path and filename that corresponds to the file information in this section
	Title pulumi.StringPtrInput `pulumi:"title"`
}

func (FileNoteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FileNote)(nil)).Elem()
}

func (i FileNoteArgs) ToFileNoteOutput() FileNoteOutput {
	return i.ToFileNoteOutputWithContext(context.Background())
}

func (i FileNoteArgs) ToFileNoteOutputWithContext(ctx context.Context) FileNoteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileNoteOutput)
}

func (i FileNoteArgs) ToFileNotePtrOutput() FileNotePtrOutput {
	return i.ToFileNotePtrOutputWithContext(context.Background())
}

func (i FileNoteArgs) ToFileNotePtrOutputWithContext(ctx context.Context) FileNotePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileNoteOutput).ToFileNotePtrOutputWithContext(ctx)
}

// FileNotePtrInput is an input type that accepts FileNoteArgs, FileNotePtr and FileNotePtrOutput values.
// You can construct a concrete instance of `FileNotePtrInput` via:
//
//          FileNoteArgs{...}
//
//  or:
//
//          nil
type FileNotePtrInput interface {
	pulumi.Input

	ToFileNotePtrOutput() FileNotePtrOutput
	ToFileNotePtrOutputWithContext(context.Context) FileNotePtrOutput
}

type fileNotePtrType FileNoteArgs

func FileNotePtr(v *FileNoteArgs) FileNotePtrInput {
	return (*fileNotePtrType)(v)
}

func (*fileNotePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FileNote)(nil)).Elem()
}

func (i *fileNotePtrType) ToFileNotePtrOutput() FileNotePtrOutput {
	return i.ToFileNotePtrOutputWithContext(context.Background())
}

func (i *fileNotePtrType) ToFileNotePtrOutputWithContext(ctx context.Context) FileNotePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileNotePtrOutput)
}

// FileNote represents an SPDX File Information section: https://spdx.github.io/spdx-spec/4-file-information/
type FileNoteOutput struct{ *pulumi.OutputState }

func (FileNoteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FileNote)(nil)).Elem()
}

func (o FileNoteOutput) ToFileNoteOutput() FileNoteOutput {
	return o
}

func (o FileNoteOutput) ToFileNoteOutputWithContext(ctx context.Context) FileNoteOutput {
	return o
}

func (o FileNoteOutput) ToFileNotePtrOutput() FileNotePtrOutput {
	return o.ToFileNotePtrOutputWithContext(context.Background())
}

func (o FileNoteOutput) ToFileNotePtrOutputWithContext(ctx context.Context) FileNotePtrOutput {
	return o.ApplyT(func(v FileNote) *FileNote {
		return &v
	}).(FileNotePtrOutput)
}

// Provide a unique identifier to match analysis information on each specific file in a package
func (o FileNoteOutput) Checksum() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FileNote) []string { return v.Checksum }).(pulumi.StringArrayOutput)
}

// This field provides information about the type of file identified
func (o FileNoteOutput) FileType() FileNoteFileTypePtrOutput {
	return o.ApplyT(func(v FileNote) *FileNoteFileType { return v.FileType }).(FileNoteFileTypePtrOutput)
}

// Identify the full path and filename that corresponds to the file information in this section
func (o FileNoteOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FileNote) *string { return v.Title }).(pulumi.StringPtrOutput)
}

type FileNotePtrOutput struct{ *pulumi.OutputState }

func (FileNotePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FileNote)(nil)).Elem()
}

func (o FileNotePtrOutput) ToFileNotePtrOutput() FileNotePtrOutput {
	return o
}

func (o FileNotePtrOutput) ToFileNotePtrOutputWithContext(ctx context.Context) FileNotePtrOutput {
	return o
}

func (o FileNotePtrOutput) Elem() FileNoteOutput {
	return o.ApplyT(func(v *FileNote) FileNote { return *v }).(FileNoteOutput)
}

// Provide a unique identifier to match analysis information on each specific file in a package
func (o FileNotePtrOutput) Checksum() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileNote) []string {
		if v == nil {
			return nil
		}
		return v.Checksum
	}).(pulumi.StringArrayOutput)
}

// This field provides information about the type of file identified
func (o FileNotePtrOutput) FileType() FileNoteFileTypePtrOutput {
	return o.ApplyT(func(v *FileNote) *FileNoteFileType {
		if v == nil {
			return nil
		}
		return v.FileType
	}).(FileNoteFileTypePtrOutput)
}

// Identify the full path and filename that corresponds to the file information in this section
func (o FileNotePtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileNote) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// FileNote represents an SPDX File Information section: https://spdx.github.io/spdx-spec/4-file-information/
type FileNoteResponse struct {
	// Provide a unique identifier to match analysis information on each specific file in a package
	Checksum []string `pulumi:"checksum"`
	// This field provides information about the type of file identified
	FileType string `pulumi:"fileType"`
	// Identify the full path and filename that corresponds to the file information in this section
	Title string `pulumi:"title"`
}

// FileNoteResponseInput is an input type that accepts FileNoteResponseArgs and FileNoteResponseOutput values.
// You can construct a concrete instance of `FileNoteResponseInput` via:
//
//          FileNoteResponseArgs{...}
type FileNoteResponseInput interface {
	pulumi.Input

	ToFileNoteResponseOutput() FileNoteResponseOutput
	ToFileNoteResponseOutputWithContext(context.Context) FileNoteResponseOutput
}

// FileNote represents an SPDX File Information section: https://spdx.github.io/spdx-spec/4-file-information/
type FileNoteResponseArgs struct {
	// Provide a unique identifier to match analysis information on each specific file in a package
	Checksum pulumi.StringArrayInput `pulumi:"checksum"`
	// This field provides information about the type of file identified
	FileType pulumi.StringInput `pulumi:"fileType"`
	// Identify the full path and filename that corresponds to the file information in this section
	Title pulumi.StringInput `pulumi:"title"`
}

func (FileNoteResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FileNoteResponse)(nil)).Elem()
}

func (i FileNoteResponseArgs) ToFileNoteResponseOutput() FileNoteResponseOutput {
	return i.ToFileNoteResponseOutputWithContext(context.Background())
}

func (i FileNoteResponseArgs) ToFileNoteResponseOutputWithContext(ctx context.Context) FileNoteResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileNoteResponseOutput)
}

func (i FileNoteResponseArgs) ToFileNoteResponsePtrOutput() FileNoteResponsePtrOutput {
	return i.ToFileNoteResponsePtrOutputWithContext(context.Background())
}

func (i FileNoteResponseArgs) ToFileNoteResponsePtrOutputWithContext(ctx context.Context) FileNoteResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileNoteResponseOutput).ToFileNoteResponsePtrOutputWithContext(ctx)
}

// FileNoteResponsePtrInput is an input type that accepts FileNoteResponseArgs, FileNoteResponsePtr and FileNoteResponsePtrOutput values.
// You can construct a concrete instance of `FileNoteResponsePtrInput` via:
//
//          FileNoteResponseArgs{...}
//
//  or:
//
//          nil
type FileNoteResponsePtrInput interface {
	pulumi.Input

	ToFileNoteResponsePtrOutput() FileNoteResponsePtrOutput
	ToFileNoteResponsePtrOutputWithContext(context.Context) FileNoteResponsePtrOutput
}

type fileNoteResponsePtrType FileNoteResponseArgs

func FileNoteResponsePtr(v *FileNoteResponseArgs) FileNoteResponsePtrInput {
	return (*fileNoteResponsePtrType)(v)
}

func (*fileNoteResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FileNoteResponse)(nil)).Elem()
}

func (i *fileNoteResponsePtrType) ToFileNoteResponsePtrOutput() FileNoteResponsePtrOutput {
	return i.ToFileNoteResponsePtrOutputWithContext(context.Background())
}

func (i *fileNoteResponsePtrType) ToFileNoteResponsePtrOutputWithContext(ctx context.Context) FileNoteResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileNoteResponsePtrOutput)
}

// FileNote represents an SPDX File Information section: https://spdx.github.io/spdx-spec/4-file-information/
type FileNoteResponseOutput struct{ *pulumi.OutputState }

func (FileNoteResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FileNoteResponse)(nil)).Elem()
}

func (o FileNoteResponseOutput) ToFileNoteResponseOutput() FileNoteResponseOutput {
	return o
}

func (o FileNoteResponseOutput) ToFileNoteResponseOutputWithContext(ctx context.Context) FileNoteResponseOutput {
	return o
}

func (o FileNoteResponseOutput) ToFileNoteResponsePtrOutput() FileNoteResponsePtrOutput {
	return o.ToFileNoteResponsePtrOutputWithContext(context.Background())
}

func (o FileNoteResponseOutput) ToFileNoteResponsePtrOutputWithContext(ctx context.Context) FileNoteResponsePtrOutput {
	return o.ApplyT(func(v FileNoteResponse) *FileNoteResponse {
		return &v
	}).(FileNoteResponsePtrOutput)
}

// Provide a unique identifier to match analysis information on each specific file in a package
func (o FileNoteResponseOutput) Checksum() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FileNoteResponse) []string { return v.Checksum }).(pulumi.StringArrayOutput)
}

// This field provides information about the type of file identified
func (o FileNoteResponseOutput) FileType() pulumi.StringOutput {
	return o.ApplyT(func(v FileNoteResponse) string { return v.FileType }).(pulumi.StringOutput)
}

// Identify the full path and filename that corresponds to the file information in this section
func (o FileNoteResponseOutput) Title() pulumi.StringOutput {
	return o.ApplyT(func(v FileNoteResponse) string { return v.Title }).(pulumi.StringOutput)
}

type FileNoteResponsePtrOutput struct{ *pulumi.OutputState }

func (FileNoteResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FileNoteResponse)(nil)).Elem()
}

func (o FileNoteResponsePtrOutput) ToFileNoteResponsePtrOutput() FileNoteResponsePtrOutput {
	return o
}

func (o FileNoteResponsePtrOutput) ToFileNoteResponsePtrOutputWithContext(ctx context.Context) FileNoteResponsePtrOutput {
	return o
}

func (o FileNoteResponsePtrOutput) Elem() FileNoteResponseOutput {
	return o.ApplyT(func(v *FileNoteResponse) FileNoteResponse { return *v }).(FileNoteResponseOutput)
}

// Provide a unique identifier to match analysis information on each specific file in a package
func (o FileNoteResponsePtrOutput) Checksum() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileNoteResponse) []string {
		if v == nil {
			return nil
		}
		return v.Checksum
	}).(pulumi.StringArrayOutput)
}

// This field provides information about the type of file identified
func (o FileNoteResponsePtrOutput) FileType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.FileType
	}).(pulumi.StringPtrOutput)
}

// Identify the full path and filename that corresponds to the file information in this section
func (o FileNoteResponsePtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Title
	}).(pulumi.StringPtrOutput)
}

// FileOccurrence represents an SPDX File Information section: https://spdx.github.io/spdx-spec/4-file-information/
type FileOccurrence struct {
	// This field provides a place for the SPDX data creator to record, at the file level, acknowledgements that may be needed to be communicated in some contexts
	Attributions []string `pulumi:"attributions"`
	// This field provides a place for the SPDX file creator to record any general comments about the file
	Comment *string `pulumi:"comment"`
	// This field provides a place for the SPDX file creator to record file contributors
	Contributors []string `pulumi:"contributors"`
	// Identify the copyright holder of the file, as well as any dates present
	Copyright *string `pulumi:"copyright"`
	// This field contains the license information actually found in the file, if any
	FilesLicenseInfo []string `pulumi:"filesLicenseInfo"`
	// Uniquely identify any element in an SPDX document which may be referenced by other elements
	Id *string `pulumi:"id"`
	// This field provides a place for the SPDX file creator to record any relevant background references or analysis that went in to arriving at the Concluded License for a file
	LicenseComments *string `pulumi:"licenseComments"`
	// This field contains the license the SPDX file creator has concluded as governing the file or alternative values if the governing license cannot be determined
	LicenseConcluded *string `pulumi:"licenseConcluded"`
	// This field provides a place for the SPDX file creator to record license notices or other such related notices found in the file
	Notice *string `pulumi:"notice"`
}

// FileOccurrenceInput is an input type that accepts FileOccurrenceArgs and FileOccurrenceOutput values.
// You can construct a concrete instance of `FileOccurrenceInput` via:
//
//          FileOccurrenceArgs{...}
type FileOccurrenceInput interface {
	pulumi.Input

	ToFileOccurrenceOutput() FileOccurrenceOutput
	ToFileOccurrenceOutputWithContext(context.Context) FileOccurrenceOutput
}

// FileOccurrence represents an SPDX File Information section: https://spdx.github.io/spdx-spec/4-file-information/
type FileOccurrenceArgs struct {
	// This field provides a place for the SPDX data creator to record, at the file level, acknowledgements that may be needed to be communicated in some contexts
	Attributions pulumi.StringArrayInput `pulumi:"attributions"`
	// This field provides a place for the SPDX file creator to record any general comments about the file
	Comment pulumi.StringPtrInput `pulumi:"comment"`
	// This field provides a place for the SPDX file creator to record file contributors
	Contributors pulumi.StringArrayInput `pulumi:"contributors"`
	// Identify the copyright holder of the file, as well as any dates present
	Copyright pulumi.StringPtrInput `pulumi:"copyright"`
	// This field contains the license information actually found in the file, if any
	FilesLicenseInfo pulumi.StringArrayInput `pulumi:"filesLicenseInfo"`
	// Uniquely identify any element in an SPDX document which may be referenced by other elements
	Id pulumi.StringPtrInput `pulumi:"id"`
	// This field provides a place for the SPDX file creator to record any relevant background references or analysis that went in to arriving at the Concluded License for a file
	LicenseComments pulumi.StringPtrInput `pulumi:"licenseComments"`
	// This field contains the license the SPDX file creator has concluded as governing the file or alternative values if the governing license cannot be determined
	LicenseConcluded pulumi.StringPtrInput `pulumi:"licenseConcluded"`
	// This field provides a place for the SPDX file creator to record license notices or other such related notices found in the file
	Notice pulumi.StringPtrInput `pulumi:"notice"`
}

func (FileOccurrenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FileOccurrence)(nil)).Elem()
}

func (i FileOccurrenceArgs) ToFileOccurrenceOutput() FileOccurrenceOutput {
	return i.ToFileOccurrenceOutputWithContext(context.Background())
}

func (i FileOccurrenceArgs) ToFileOccurrenceOutputWithContext(ctx context.Context) FileOccurrenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileOccurrenceOutput)
}

func (i FileOccurrenceArgs) ToFileOccurrencePtrOutput() FileOccurrencePtrOutput {
	return i.ToFileOccurrencePtrOutputWithContext(context.Background())
}

func (i FileOccurrenceArgs) ToFileOccurrencePtrOutputWithContext(ctx context.Context) FileOccurrencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileOccurrenceOutput).ToFileOccurrencePtrOutputWithContext(ctx)
}

// FileOccurrencePtrInput is an input type that accepts FileOccurrenceArgs, FileOccurrencePtr and FileOccurrencePtrOutput values.
// You can construct a concrete instance of `FileOccurrencePtrInput` via:
//
//          FileOccurrenceArgs{...}
//
//  or:
//
//          nil
type FileOccurrencePtrInput interface {
	pulumi.Input

	ToFileOccurrencePtrOutput() FileOccurrencePtrOutput
	ToFileOccurrencePtrOutputWithContext(context.Context) FileOccurrencePtrOutput
}

type fileOccurrencePtrType FileOccurrenceArgs

func FileOccurrencePtr(v *FileOccurrenceArgs) FileOccurrencePtrInput {
	return (*fileOccurrencePtrType)(v)
}

func (*fileOccurrencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FileOccurrence)(nil)).Elem()
}

func (i *fileOccurrencePtrType) ToFileOccurrencePtrOutput() FileOccurrencePtrOutput {
	return i.ToFileOccurrencePtrOutputWithContext(context.Background())
}

func (i *fileOccurrencePtrType) ToFileOccurrencePtrOutputWithContext(ctx context.Context) FileOccurrencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileOccurrencePtrOutput)
}

// FileOccurrence represents an SPDX File Information section: https://spdx.github.io/spdx-spec/4-file-information/
type FileOccurrenceOutput struct{ *pulumi.OutputState }

func (FileOccurrenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FileOccurrence)(nil)).Elem()
}

func (o FileOccurrenceOutput) ToFileOccurrenceOutput() FileOccurrenceOutput {
	return o
}

func (o FileOccurrenceOutput) ToFileOccurrenceOutputWithContext(ctx context.Context) FileOccurrenceOutput {
	return o
}

func (o FileOccurrenceOutput) ToFileOccurrencePtrOutput() FileOccurrencePtrOutput {
	return o.ToFileOccurrencePtrOutputWithContext(context.Background())
}

func (o FileOccurrenceOutput) ToFileOccurrencePtrOutputWithContext(ctx context.Context) FileOccurrencePtrOutput {
	return o.ApplyT(func(v FileOccurrence) *FileOccurrence {
		return &v
	}).(FileOccurrencePtrOutput)
}

// This field provides a place for the SPDX data creator to record, at the file level, acknowledgements that may be needed to be communicated in some contexts
func (o FileOccurrenceOutput) Attributions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FileOccurrence) []string { return v.Attributions }).(pulumi.StringArrayOutput)
}

// This field provides a place for the SPDX file creator to record any general comments about the file
func (o FileOccurrenceOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FileOccurrence) *string { return v.Comment }).(pulumi.StringPtrOutput)
}

// This field provides a place for the SPDX file creator to record file contributors
func (o FileOccurrenceOutput) Contributors() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FileOccurrence) []string { return v.Contributors }).(pulumi.StringArrayOutput)
}

// Identify the copyright holder of the file, as well as any dates present
func (o FileOccurrenceOutput) Copyright() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FileOccurrence) *string { return v.Copyright }).(pulumi.StringPtrOutput)
}

// This field contains the license information actually found in the file, if any
func (o FileOccurrenceOutput) FilesLicenseInfo() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FileOccurrence) []string { return v.FilesLicenseInfo }).(pulumi.StringArrayOutput)
}

// Uniquely identify any element in an SPDX document which may be referenced by other elements
func (o FileOccurrenceOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FileOccurrence) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// This field provides a place for the SPDX file creator to record any relevant background references or analysis that went in to arriving at the Concluded License for a file
func (o FileOccurrenceOutput) LicenseComments() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FileOccurrence) *string { return v.LicenseComments }).(pulumi.StringPtrOutput)
}

// This field contains the license the SPDX file creator has concluded as governing the file or alternative values if the governing license cannot be determined
func (o FileOccurrenceOutput) LicenseConcluded() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FileOccurrence) *string { return v.LicenseConcluded }).(pulumi.StringPtrOutput)
}

// This field provides a place for the SPDX file creator to record license notices or other such related notices found in the file
func (o FileOccurrenceOutput) Notice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FileOccurrence) *string { return v.Notice }).(pulumi.StringPtrOutput)
}

type FileOccurrencePtrOutput struct{ *pulumi.OutputState }

func (FileOccurrencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FileOccurrence)(nil)).Elem()
}

func (o FileOccurrencePtrOutput) ToFileOccurrencePtrOutput() FileOccurrencePtrOutput {
	return o
}

func (o FileOccurrencePtrOutput) ToFileOccurrencePtrOutputWithContext(ctx context.Context) FileOccurrencePtrOutput {
	return o
}

func (o FileOccurrencePtrOutput) Elem() FileOccurrenceOutput {
	return o.ApplyT(func(v *FileOccurrence) FileOccurrence { return *v }).(FileOccurrenceOutput)
}

// This field provides a place for the SPDX data creator to record, at the file level, acknowledgements that may be needed to be communicated in some contexts
func (o FileOccurrencePtrOutput) Attributions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileOccurrence) []string {
		if v == nil {
			return nil
		}
		return v.Attributions
	}).(pulumi.StringArrayOutput)
}

// This field provides a place for the SPDX file creator to record any general comments about the file
func (o FileOccurrencePtrOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.Comment
	}).(pulumi.StringPtrOutput)
}

// This field provides a place for the SPDX file creator to record file contributors
func (o FileOccurrencePtrOutput) Contributors() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileOccurrence) []string {
		if v == nil {
			return nil
		}
		return v.Contributors
	}).(pulumi.StringArrayOutput)
}

// Identify the copyright holder of the file, as well as any dates present
func (o FileOccurrencePtrOutput) Copyright() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.Copyright
	}).(pulumi.StringPtrOutput)
}

// This field contains the license information actually found in the file, if any
func (o FileOccurrencePtrOutput) FilesLicenseInfo() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileOccurrence) []string {
		if v == nil {
			return nil
		}
		return v.FilesLicenseInfo
	}).(pulumi.StringArrayOutput)
}

// Uniquely identify any element in an SPDX document which may be referenced by other elements
func (o FileOccurrencePtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

// This field provides a place for the SPDX file creator to record any relevant background references or analysis that went in to arriving at the Concluded License for a file
func (o FileOccurrencePtrOutput) LicenseComments() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.LicenseComments
	}).(pulumi.StringPtrOutput)
}

// This field contains the license the SPDX file creator has concluded as governing the file or alternative values if the governing license cannot be determined
func (o FileOccurrencePtrOutput) LicenseConcluded() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.LicenseConcluded
	}).(pulumi.StringPtrOutput)
}

// This field provides a place for the SPDX file creator to record license notices or other such related notices found in the file
func (o FileOccurrencePtrOutput) Notice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.Notice
	}).(pulumi.StringPtrOutput)
}

// FileOccurrence represents an SPDX File Information section: https://spdx.github.io/spdx-spec/4-file-information/
type FileOccurrenceResponse struct {
	// This field provides a place for the SPDX data creator to record, at the file level, acknowledgements that may be needed to be communicated in some contexts
	Attributions []string `pulumi:"attributions"`
	// This field provides a place for the SPDX file creator to record any general comments about the file
	Comment string `pulumi:"comment"`
	// This field provides a place for the SPDX file creator to record file contributors
	Contributors []string `pulumi:"contributors"`
	// Identify the copyright holder of the file, as well as any dates present
	Copyright string `pulumi:"copyright"`
	// This field contains the license information actually found in the file, if any
	FilesLicenseInfo []string `pulumi:"filesLicenseInfo"`
	// This field provides a place for the SPDX file creator to record any relevant background references or analysis that went in to arriving at the Concluded License for a file
	LicenseComments string `pulumi:"licenseComments"`
	// This field contains the license the SPDX file creator has concluded as governing the file or alternative values if the governing license cannot be determined
	LicenseConcluded string `pulumi:"licenseConcluded"`
	// This field provides a place for the SPDX file creator to record license notices or other such related notices found in the file
	Notice string `pulumi:"notice"`
}

// FileOccurrenceResponseInput is an input type that accepts FileOccurrenceResponseArgs and FileOccurrenceResponseOutput values.
// You can construct a concrete instance of `FileOccurrenceResponseInput` via:
//
//          FileOccurrenceResponseArgs{...}
type FileOccurrenceResponseInput interface {
	pulumi.Input

	ToFileOccurrenceResponseOutput() FileOccurrenceResponseOutput
	ToFileOccurrenceResponseOutputWithContext(context.Context) FileOccurrenceResponseOutput
}

// FileOccurrence represents an SPDX File Information section: https://spdx.github.io/spdx-spec/4-file-information/
type FileOccurrenceResponseArgs struct {
	// This field provides a place for the SPDX data creator to record, at the file level, acknowledgements that may be needed to be communicated in some contexts
	Attributions pulumi.StringArrayInput `pulumi:"attributions"`
	// This field provides a place for the SPDX file creator to record any general comments about the file
	Comment pulumi.StringInput `pulumi:"comment"`
	// This field provides a place for the SPDX file creator to record file contributors
	Contributors pulumi.StringArrayInput `pulumi:"contributors"`
	// Identify the copyright holder of the file, as well as any dates present
	Copyright pulumi.StringInput `pulumi:"copyright"`
	// This field contains the license information actually found in the file, if any
	FilesLicenseInfo pulumi.StringArrayInput `pulumi:"filesLicenseInfo"`
	// This field provides a place for the SPDX file creator to record any relevant background references or analysis that went in to arriving at the Concluded License for a file
	LicenseComments pulumi.StringInput `pulumi:"licenseComments"`
	// This field contains the license the SPDX file creator has concluded as governing the file or alternative values if the governing license cannot be determined
	LicenseConcluded pulumi.StringInput `pulumi:"licenseConcluded"`
	// This field provides a place for the SPDX file creator to record license notices or other such related notices found in the file
	Notice pulumi.StringInput `pulumi:"notice"`
}

func (FileOccurrenceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FileOccurrenceResponse)(nil)).Elem()
}

func (i FileOccurrenceResponseArgs) ToFileOccurrenceResponseOutput() FileOccurrenceResponseOutput {
	return i.ToFileOccurrenceResponseOutputWithContext(context.Background())
}

func (i FileOccurrenceResponseArgs) ToFileOccurrenceResponseOutputWithContext(ctx context.Context) FileOccurrenceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileOccurrenceResponseOutput)
}

func (i FileOccurrenceResponseArgs) ToFileOccurrenceResponsePtrOutput() FileOccurrenceResponsePtrOutput {
	return i.ToFileOccurrenceResponsePtrOutputWithContext(context.Background())
}

func (i FileOccurrenceResponseArgs) ToFileOccurrenceResponsePtrOutputWithContext(ctx context.Context) FileOccurrenceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileOccurrenceResponseOutput).ToFileOccurrenceResponsePtrOutputWithContext(ctx)
}

// FileOccurrenceResponsePtrInput is an input type that accepts FileOccurrenceResponseArgs, FileOccurrenceResponsePtr and FileOccurrenceResponsePtrOutput values.
// You can construct a concrete instance of `FileOccurrenceResponsePtrInput` via:
//
//          FileOccurrenceResponseArgs{...}
//
//  or:
//
//          nil
type FileOccurrenceResponsePtrInput interface {
	pulumi.Input

	ToFileOccurrenceResponsePtrOutput() FileOccurrenceResponsePtrOutput
	ToFileOccurrenceResponsePtrOutputWithContext(context.Context) FileOccurrenceResponsePtrOutput
}

type fileOccurrenceResponsePtrType FileOccurrenceResponseArgs

func FileOccurrenceResponsePtr(v *FileOccurrenceResponseArgs) FileOccurrenceResponsePtrInput {
	return (*fileOccurrenceResponsePtrType)(v)
}

func (*fileOccurrenceResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FileOccurrenceResponse)(nil)).Elem()
}

func (i *fileOccurrenceResponsePtrType) ToFileOccurrenceResponsePtrOutput() FileOccurrenceResponsePtrOutput {
	return i.ToFileOccurrenceResponsePtrOutputWithContext(context.Background())
}

func (i *fileOccurrenceResponsePtrType) ToFileOccurrenceResponsePtrOutputWithContext(ctx context.Context) FileOccurrenceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileOccurrenceResponsePtrOutput)
}

// FileOccurrence represents an SPDX File Information section: https://spdx.github.io/spdx-spec/4-file-information/
type FileOccurrenceResponseOutput struct{ *pulumi.OutputState }

func (FileOccurrenceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FileOccurrenceResponse)(nil)).Elem()
}

func (o FileOccurrenceResponseOutput) ToFileOccurrenceResponseOutput() FileOccurrenceResponseOutput {
	return o
}

func (o FileOccurrenceResponseOutput) ToFileOccurrenceResponseOutputWithContext(ctx context.Context) FileOccurrenceResponseOutput {
	return o
}

func (o FileOccurrenceResponseOutput) ToFileOccurrenceResponsePtrOutput() FileOccurrenceResponsePtrOutput {
	return o.ToFileOccurrenceResponsePtrOutputWithContext(context.Background())
}

func (o FileOccurrenceResponseOutput) ToFileOccurrenceResponsePtrOutputWithContext(ctx context.Context) FileOccurrenceResponsePtrOutput {
	return o.ApplyT(func(v FileOccurrenceResponse) *FileOccurrenceResponse {
		return &v
	}).(FileOccurrenceResponsePtrOutput)
}

// This field provides a place for the SPDX data creator to record, at the file level, acknowledgements that may be needed to be communicated in some contexts
func (o FileOccurrenceResponseOutput) Attributions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FileOccurrenceResponse) []string { return v.Attributions }).(pulumi.StringArrayOutput)
}

// This field provides a place for the SPDX file creator to record any general comments about the file
func (o FileOccurrenceResponseOutput) Comment() pulumi.StringOutput {
	return o.ApplyT(func(v FileOccurrenceResponse) string { return v.Comment }).(pulumi.StringOutput)
}

// This field provides a place for the SPDX file creator to record file contributors
func (o FileOccurrenceResponseOutput) Contributors() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FileOccurrenceResponse) []string { return v.Contributors }).(pulumi.StringArrayOutput)
}

// Identify the copyright holder of the file, as well as any dates present
func (o FileOccurrenceResponseOutput) Copyright() pulumi.StringOutput {
	return o.ApplyT(func(v FileOccurrenceResponse) string { return v.Copyright }).(pulumi.StringOutput)
}

// This field contains the license information actually found in the file, if any
func (o FileOccurrenceResponseOutput) FilesLicenseInfo() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FileOccurrenceResponse) []string { return v.FilesLicenseInfo }).(pulumi.StringArrayOutput)
}

// This field provides a place for the SPDX file creator to record any relevant background references or analysis that went in to arriving at the Concluded License for a file
func (o FileOccurrenceResponseOutput) LicenseComments() pulumi.StringOutput {
	return o.ApplyT(func(v FileOccurrenceResponse) string { return v.LicenseComments }).(pulumi.StringOutput)
}

// This field contains the license the SPDX file creator has concluded as governing the file or alternative values if the governing license cannot be determined
func (o FileOccurrenceResponseOutput) LicenseConcluded() pulumi.StringOutput {
	return o.ApplyT(func(v FileOccurrenceResponse) string { return v.LicenseConcluded }).(pulumi.StringOutput)
}

// This field provides a place for the SPDX file creator to record license notices or other such related notices found in the file
func (o FileOccurrenceResponseOutput) Notice() pulumi.StringOutput {
	return o.ApplyT(func(v FileOccurrenceResponse) string { return v.Notice }).(pulumi.StringOutput)
}

type FileOccurrenceResponsePtrOutput struct{ *pulumi.OutputState }

func (FileOccurrenceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FileOccurrenceResponse)(nil)).Elem()
}

func (o FileOccurrenceResponsePtrOutput) ToFileOccurrenceResponsePtrOutput() FileOccurrenceResponsePtrOutput {
	return o
}

func (o FileOccurrenceResponsePtrOutput) ToFileOccurrenceResponsePtrOutputWithContext(ctx context.Context) FileOccurrenceResponsePtrOutput {
	return o
}

func (o FileOccurrenceResponsePtrOutput) Elem() FileOccurrenceResponseOutput {
	return o.ApplyT(func(v *FileOccurrenceResponse) FileOccurrenceResponse { return *v }).(FileOccurrenceResponseOutput)
}

// This field provides a place for the SPDX data creator to record, at the file level, acknowledgements that may be needed to be communicated in some contexts
func (o FileOccurrenceResponsePtrOutput) Attributions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileOccurrenceResponse) []string {
		if v == nil {
			return nil
		}
		return v.Attributions
	}).(pulumi.StringArrayOutput)
}

// This field provides a place for the SPDX file creator to record any general comments about the file
func (o FileOccurrenceResponsePtrOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Comment
	}).(pulumi.StringPtrOutput)
}

// This field provides a place for the SPDX file creator to record file contributors
func (o FileOccurrenceResponsePtrOutput) Contributors() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileOccurrenceResponse) []string {
		if v == nil {
			return nil
		}
		return v.Contributors
	}).(pulumi.StringArrayOutput)
}

// Identify the copyright holder of the file, as well as any dates present
func (o FileOccurrenceResponsePtrOutput) Copyright() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Copyright
	}).(pulumi.StringPtrOutput)
}

// This field contains the license information actually found in the file, if any
func (o FileOccurrenceResponsePtrOutput) FilesLicenseInfo() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileOccurrenceResponse) []string {
		if v == nil {
			return nil
		}
		return v.FilesLicenseInfo
	}).(pulumi.StringArrayOutput)
}

// This field provides a place for the SPDX file creator to record any relevant background references or analysis that went in to arriving at the Concluded License for a file
func (o FileOccurrenceResponsePtrOutput) LicenseComments() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.LicenseComments
	}).(pulumi.StringPtrOutput)
}

// This field contains the license the SPDX file creator has concluded as governing the file or alternative values if the governing license cannot be determined
func (o FileOccurrenceResponsePtrOutput) LicenseConcluded() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.LicenseConcluded
	}).(pulumi.StringPtrOutput)
}

// This field provides a place for the SPDX file creator to record license notices or other such related notices found in the file
func (o FileOccurrenceResponsePtrOutput) Notice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Notice
	}).(pulumi.StringPtrOutput)
}

// A set of properties that uniquely identify a given Docker image.
type Fingerprint struct {
	// The layer ID of the final layer in the Docker image's v1 representation.
	V1Name string `pulumi:"v1Name"`
	// The ordered list of v2 blobs that represent a given image.
	V2Blob []string `pulumi:"v2Blob"`
}

// FingerprintInput is an input type that accepts FingerprintArgs and FingerprintOutput values.
// You can construct a concrete instance of `FingerprintInput` via:
//
//          FingerprintArgs{...}
type FingerprintInput interface {
	pulumi.Input

	ToFingerprintOutput() FingerprintOutput
	ToFingerprintOutputWithContext(context.Context) FingerprintOutput
}

// A set of properties that uniquely identify a given Docker image.
type FingerprintArgs struct {
	// The layer ID of the final layer in the Docker image's v1 representation.
	V1Name pulumi.StringInput `pulumi:"v1Name"`
	// The ordered list of v2 blobs that represent a given image.
	V2Blob pulumi.StringArrayInput `pulumi:"v2Blob"`
}

func (FingerprintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Fingerprint)(nil)).Elem()
}

func (i FingerprintArgs) ToFingerprintOutput() FingerprintOutput {
	return i.ToFingerprintOutputWithContext(context.Background())
}

func (i FingerprintArgs) ToFingerprintOutputWithContext(ctx context.Context) FingerprintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FingerprintOutput)
}

func (i FingerprintArgs) ToFingerprintPtrOutput() FingerprintPtrOutput {
	return i.ToFingerprintPtrOutputWithContext(context.Background())
}

func (i FingerprintArgs) ToFingerprintPtrOutputWithContext(ctx context.Context) FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FingerprintOutput).ToFingerprintPtrOutputWithContext(ctx)
}

// FingerprintPtrInput is an input type that accepts FingerprintArgs, FingerprintPtr and FingerprintPtrOutput values.
// You can construct a concrete instance of `FingerprintPtrInput` via:
//
//          FingerprintArgs{...}
//
//  or:
//
//          nil
type FingerprintPtrInput interface {
	pulumi.Input

	ToFingerprintPtrOutput() FingerprintPtrOutput
	ToFingerprintPtrOutputWithContext(context.Context) FingerprintPtrOutput
}

type fingerprintPtrType FingerprintArgs

func FingerprintPtr(v *FingerprintArgs) FingerprintPtrInput {
	return (*fingerprintPtrType)(v)
}

func (*fingerprintPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Fingerprint)(nil)).Elem()
}

func (i *fingerprintPtrType) ToFingerprintPtrOutput() FingerprintPtrOutput {
	return i.ToFingerprintPtrOutputWithContext(context.Background())
}

func (i *fingerprintPtrType) ToFingerprintPtrOutputWithContext(ctx context.Context) FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FingerprintPtrOutput)
}

// A set of properties that uniquely identify a given Docker image.
type FingerprintOutput struct{ *pulumi.OutputState }

func (FingerprintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Fingerprint)(nil)).Elem()
}

func (o FingerprintOutput) ToFingerprintOutput() FingerprintOutput {
	return o
}

func (o FingerprintOutput) ToFingerprintOutputWithContext(ctx context.Context) FingerprintOutput {
	return o
}

func (o FingerprintOutput) ToFingerprintPtrOutput() FingerprintPtrOutput {
	return o.ToFingerprintPtrOutputWithContext(context.Background())
}

func (o FingerprintOutput) ToFingerprintPtrOutputWithContext(ctx context.Context) FingerprintPtrOutput {
	return o.ApplyT(func(v Fingerprint) *Fingerprint {
		return &v
	}).(FingerprintPtrOutput)
}

// The layer ID of the final layer in the Docker image's v1 representation.
func (o FingerprintOutput) V1Name() pulumi.StringOutput {
	return o.ApplyT(func(v Fingerprint) string { return v.V1Name }).(pulumi.StringOutput)
}

// The ordered list of v2 blobs that represent a given image.
func (o FingerprintOutput) V2Blob() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Fingerprint) []string { return v.V2Blob }).(pulumi.StringArrayOutput)
}

type FingerprintPtrOutput struct{ *pulumi.OutputState }

func (FingerprintPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Fingerprint)(nil)).Elem()
}

func (o FingerprintPtrOutput) ToFingerprintPtrOutput() FingerprintPtrOutput {
	return o
}

func (o FingerprintPtrOutput) ToFingerprintPtrOutputWithContext(ctx context.Context) FingerprintPtrOutput {
	return o
}

func (o FingerprintPtrOutput) Elem() FingerprintOutput {
	return o.ApplyT(func(v *Fingerprint) Fingerprint { return *v }).(FingerprintOutput)
}

// The layer ID of the final layer in the Docker image's v1 representation.
func (o FingerprintPtrOutput) V1Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Fingerprint) *string {
		if v == nil {
			return nil
		}
		return &v.V1Name
	}).(pulumi.StringPtrOutput)
}

// The ordered list of v2 blobs that represent a given image.
func (o FingerprintPtrOutput) V2Blob() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Fingerprint) []string {
		if v == nil {
			return nil
		}
		return v.V2Blob
	}).(pulumi.StringArrayOutput)
}

// A set of properties that uniquely identify a given Docker image.
type FingerprintResponse struct {
	// The layer ID of the final layer in the Docker image's v1 representation.
	V1Name string `pulumi:"v1Name"`
	// The ordered list of v2 blobs that represent a given image.
	V2Blob []string `pulumi:"v2Blob"`
	// The name of the image's v2 blobs computed via: [bottom] := v2_blobbottom := sha256(v2_blob[N] + " " + v2_name[N+1]) Only the name of the final blob is kept.
	V2Name string `pulumi:"v2Name"`
}

// FingerprintResponseInput is an input type that accepts FingerprintResponseArgs and FingerprintResponseOutput values.
// You can construct a concrete instance of `FingerprintResponseInput` via:
//
//          FingerprintResponseArgs{...}
type FingerprintResponseInput interface {
	pulumi.Input

	ToFingerprintResponseOutput() FingerprintResponseOutput
	ToFingerprintResponseOutputWithContext(context.Context) FingerprintResponseOutput
}

// A set of properties that uniquely identify a given Docker image.
type FingerprintResponseArgs struct {
	// The layer ID of the final layer in the Docker image's v1 representation.
	V1Name pulumi.StringInput `pulumi:"v1Name"`
	// The ordered list of v2 blobs that represent a given image.
	V2Blob pulumi.StringArrayInput `pulumi:"v2Blob"`
	// The name of the image's v2 blobs computed via: [bottom] := v2_blobbottom := sha256(v2_blob[N] + " " + v2_name[N+1]) Only the name of the final blob is kept.
	V2Name pulumi.StringInput `pulumi:"v2Name"`
}

func (FingerprintResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FingerprintResponse)(nil)).Elem()
}

func (i FingerprintResponseArgs) ToFingerprintResponseOutput() FingerprintResponseOutput {
	return i.ToFingerprintResponseOutputWithContext(context.Background())
}

func (i FingerprintResponseArgs) ToFingerprintResponseOutputWithContext(ctx context.Context) FingerprintResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FingerprintResponseOutput)
}

func (i FingerprintResponseArgs) ToFingerprintResponsePtrOutput() FingerprintResponsePtrOutput {
	return i.ToFingerprintResponsePtrOutputWithContext(context.Background())
}

func (i FingerprintResponseArgs) ToFingerprintResponsePtrOutputWithContext(ctx context.Context) FingerprintResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FingerprintResponseOutput).ToFingerprintResponsePtrOutputWithContext(ctx)
}

// FingerprintResponsePtrInput is an input type that accepts FingerprintResponseArgs, FingerprintResponsePtr and FingerprintResponsePtrOutput values.
// You can construct a concrete instance of `FingerprintResponsePtrInput` via:
//
//          FingerprintResponseArgs{...}
//
//  or:
//
//          nil
type FingerprintResponsePtrInput interface {
	pulumi.Input

	ToFingerprintResponsePtrOutput() FingerprintResponsePtrOutput
	ToFingerprintResponsePtrOutputWithContext(context.Context) FingerprintResponsePtrOutput
}

type fingerprintResponsePtrType FingerprintResponseArgs

func FingerprintResponsePtr(v *FingerprintResponseArgs) FingerprintResponsePtrInput {
	return (*fingerprintResponsePtrType)(v)
}

func (*fingerprintResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FingerprintResponse)(nil)).Elem()
}

func (i *fingerprintResponsePtrType) ToFingerprintResponsePtrOutput() FingerprintResponsePtrOutput {
	return i.ToFingerprintResponsePtrOutputWithContext(context.Background())
}

func (i *fingerprintResponsePtrType) ToFingerprintResponsePtrOutputWithContext(ctx context.Context) FingerprintResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FingerprintResponsePtrOutput)
}

// A set of properties that uniquely identify a given Docker image.
type FingerprintResponseOutput struct{ *pulumi.OutputState }

func (FingerprintResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FingerprintResponse)(nil)).Elem()
}

func (o FingerprintResponseOutput) ToFingerprintResponseOutput() FingerprintResponseOutput {
	return o
}

func (o FingerprintResponseOutput) ToFingerprintResponseOutputWithContext(ctx context.Context) FingerprintResponseOutput {
	return o
}

func (o FingerprintResponseOutput) ToFingerprintResponsePtrOutput() FingerprintResponsePtrOutput {
	return o.ToFingerprintResponsePtrOutputWithContext(context.Background())
}

func (o FingerprintResponseOutput) ToFingerprintResponsePtrOutputWithContext(ctx context.Context) FingerprintResponsePtrOutput {
	return o.ApplyT(func(v FingerprintResponse) *FingerprintResponse {
		return &v
	}).(FingerprintResponsePtrOutput)
}

// The layer ID of the final layer in the Docker image's v1 representation.
func (o FingerprintResponseOutput) V1Name() pulumi.StringOutput {
	return o.ApplyT(func(v FingerprintResponse) string { return v.V1Name }).(pulumi.StringOutput)
}

// The ordered list of v2 blobs that represent a given image.
func (o FingerprintResponseOutput) V2Blob() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FingerprintResponse) []string { return v.V2Blob }).(pulumi.StringArrayOutput)
}

// The name of the image's v2 blobs computed via: [bottom] := v2_blobbottom := sha256(v2_blob[N] + " " + v2_name[N+1]) Only the name of the final blob is kept.
func (o FingerprintResponseOutput) V2Name() pulumi.StringOutput {
	return o.ApplyT(func(v FingerprintResponse) string { return v.V2Name }).(pulumi.StringOutput)
}

type FingerprintResponsePtrOutput struct{ *pulumi.OutputState }

func (FingerprintResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FingerprintResponse)(nil)).Elem()
}

func (o FingerprintResponsePtrOutput) ToFingerprintResponsePtrOutput() FingerprintResponsePtrOutput {
	return o
}

func (o FingerprintResponsePtrOutput) ToFingerprintResponsePtrOutputWithContext(ctx context.Context) FingerprintResponsePtrOutput {
	return o
}

func (o FingerprintResponsePtrOutput) Elem() FingerprintResponseOutput {
	return o.ApplyT(func(v *FingerprintResponse) FingerprintResponse { return *v }).(FingerprintResponseOutput)
}

// The layer ID of the final layer in the Docker image's v1 representation.
func (o FingerprintResponsePtrOutput) V1Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FingerprintResponse) *string {
		if v == nil {
			return nil
		}
		return &v.V1Name
	}).(pulumi.StringPtrOutput)
}

// The ordered list of v2 blobs that represent a given image.
func (o FingerprintResponsePtrOutput) V2Blob() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FingerprintResponse) []string {
		if v == nil {
			return nil
		}
		return v.V2Blob
	}).(pulumi.StringArrayOutput)
}

// The name of the image's v2 blobs computed via: [bottom] := v2_blobbottom := sha256(v2_blob[N] + " " + v2_name[N+1]) Only the name of the final blob is kept.
func (o FingerprintResponsePtrOutput) V2Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FingerprintResponse) *string {
		if v == nil {
			return nil
		}
		return &v.V2Name
	}).(pulumi.StringPtrOutput)
}

// An attestation wrapper that uses the Grafeas `Signature` message. This attestation must define the `serialized_payload` that the `signatures` verify and any metadata necessary to interpret that plaintext. The signatures should always be over the `serialized_payload` bytestring.
type GenericSignedAttestation struct {
	// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
	ContentType *GenericSignedAttestationContentType `pulumi:"contentType"`
	// The serialized payload that is verified by one or more `signatures`. The encoding and semantic meaning of this payload must match what is set in `content_type`.
	SerializedPayload *string `pulumi:"serializedPayload"`
	// One or more signatures over `serialized_payload`. Verifier implementations should consider this attestation message verified if at least one `signature` verifies `serialized_payload`. See `Signature` in common.proto for more details on signature structure and verification.
	Signatures []Signature `pulumi:"signatures"`
}

// GenericSignedAttestationInput is an input type that accepts GenericSignedAttestationArgs and GenericSignedAttestationOutput values.
// You can construct a concrete instance of `GenericSignedAttestationInput` via:
//
//          GenericSignedAttestationArgs{...}
type GenericSignedAttestationInput interface {
	pulumi.Input

	ToGenericSignedAttestationOutput() GenericSignedAttestationOutput
	ToGenericSignedAttestationOutputWithContext(context.Context) GenericSignedAttestationOutput
}

// An attestation wrapper that uses the Grafeas `Signature` message. This attestation must define the `serialized_payload` that the `signatures` verify and any metadata necessary to interpret that plaintext. The signatures should always be over the `serialized_payload` bytestring.
type GenericSignedAttestationArgs struct {
	// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
	ContentType GenericSignedAttestationContentTypePtrInput `pulumi:"contentType"`
	// The serialized payload that is verified by one or more `signatures`. The encoding and semantic meaning of this payload must match what is set in `content_type`.
	SerializedPayload pulumi.StringPtrInput `pulumi:"serializedPayload"`
	// One or more signatures over `serialized_payload`. Verifier implementations should consider this attestation message verified if at least one `signature` verifies `serialized_payload`. See `Signature` in common.proto for more details on signature structure and verification.
	Signatures SignatureArrayInput `pulumi:"signatures"`
}

func (GenericSignedAttestationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GenericSignedAttestation)(nil)).Elem()
}

func (i GenericSignedAttestationArgs) ToGenericSignedAttestationOutput() GenericSignedAttestationOutput {
	return i.ToGenericSignedAttestationOutputWithContext(context.Background())
}

func (i GenericSignedAttestationArgs) ToGenericSignedAttestationOutputWithContext(ctx context.Context) GenericSignedAttestationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GenericSignedAttestationOutput)
}

func (i GenericSignedAttestationArgs) ToGenericSignedAttestationPtrOutput() GenericSignedAttestationPtrOutput {
	return i.ToGenericSignedAttestationPtrOutputWithContext(context.Background())
}

func (i GenericSignedAttestationArgs) ToGenericSignedAttestationPtrOutputWithContext(ctx context.Context) GenericSignedAttestationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GenericSignedAttestationOutput).ToGenericSignedAttestationPtrOutputWithContext(ctx)
}

// GenericSignedAttestationPtrInput is an input type that accepts GenericSignedAttestationArgs, GenericSignedAttestationPtr and GenericSignedAttestationPtrOutput values.
// You can construct a concrete instance of `GenericSignedAttestationPtrInput` via:
//
//          GenericSignedAttestationArgs{...}
//
//  or:
//
//          nil
type GenericSignedAttestationPtrInput interface {
	pulumi.Input

	ToGenericSignedAttestationPtrOutput() GenericSignedAttestationPtrOutput
	ToGenericSignedAttestationPtrOutputWithContext(context.Context) GenericSignedAttestationPtrOutput
}

type genericSignedAttestationPtrType GenericSignedAttestationArgs

func GenericSignedAttestationPtr(v *GenericSignedAttestationArgs) GenericSignedAttestationPtrInput {
	return (*genericSignedAttestationPtrType)(v)
}

func (*genericSignedAttestationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GenericSignedAttestation)(nil)).Elem()
}

func (i *genericSignedAttestationPtrType) ToGenericSignedAttestationPtrOutput() GenericSignedAttestationPtrOutput {
	return i.ToGenericSignedAttestationPtrOutputWithContext(context.Background())
}

func (i *genericSignedAttestationPtrType) ToGenericSignedAttestationPtrOutputWithContext(ctx context.Context) GenericSignedAttestationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GenericSignedAttestationPtrOutput)
}

// An attestation wrapper that uses the Grafeas `Signature` message. This attestation must define the `serialized_payload` that the `signatures` verify and any metadata necessary to interpret that plaintext. The signatures should always be over the `serialized_payload` bytestring.
type GenericSignedAttestationOutput struct{ *pulumi.OutputState }

func (GenericSignedAttestationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GenericSignedAttestation)(nil)).Elem()
}

func (o GenericSignedAttestationOutput) ToGenericSignedAttestationOutput() GenericSignedAttestationOutput {
	return o
}

func (o GenericSignedAttestationOutput) ToGenericSignedAttestationOutputWithContext(ctx context.Context) GenericSignedAttestationOutput {
	return o
}

func (o GenericSignedAttestationOutput) ToGenericSignedAttestationPtrOutput() GenericSignedAttestationPtrOutput {
	return o.ToGenericSignedAttestationPtrOutputWithContext(context.Background())
}

func (o GenericSignedAttestationOutput) ToGenericSignedAttestationPtrOutputWithContext(ctx context.Context) GenericSignedAttestationPtrOutput {
	return o.ApplyT(func(v GenericSignedAttestation) *GenericSignedAttestation {
		return &v
	}).(GenericSignedAttestationPtrOutput)
}

// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
func (o GenericSignedAttestationOutput) ContentType() GenericSignedAttestationContentTypePtrOutput {
	return o.ApplyT(func(v GenericSignedAttestation) *GenericSignedAttestationContentType { return v.ContentType }).(GenericSignedAttestationContentTypePtrOutput)
}

// The serialized payload that is verified by one or more `signatures`. The encoding and semantic meaning of this payload must match what is set in `content_type`.
func (o GenericSignedAttestationOutput) SerializedPayload() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GenericSignedAttestation) *string { return v.SerializedPayload }).(pulumi.StringPtrOutput)
}

// One or more signatures over `serialized_payload`. Verifier implementations should consider this attestation message verified if at least one `signature` verifies `serialized_payload`. See `Signature` in common.proto for more details on signature structure and verification.
func (o GenericSignedAttestationOutput) Signatures() SignatureArrayOutput {
	return o.ApplyT(func(v GenericSignedAttestation) []Signature { return v.Signatures }).(SignatureArrayOutput)
}

type GenericSignedAttestationPtrOutput struct{ *pulumi.OutputState }

func (GenericSignedAttestationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GenericSignedAttestation)(nil)).Elem()
}

func (o GenericSignedAttestationPtrOutput) ToGenericSignedAttestationPtrOutput() GenericSignedAttestationPtrOutput {
	return o
}

func (o GenericSignedAttestationPtrOutput) ToGenericSignedAttestationPtrOutputWithContext(ctx context.Context) GenericSignedAttestationPtrOutput {
	return o
}

func (o GenericSignedAttestationPtrOutput) Elem() GenericSignedAttestationOutput {
	return o.ApplyT(func(v *GenericSignedAttestation) GenericSignedAttestation { return *v }).(GenericSignedAttestationOutput)
}

// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
func (o GenericSignedAttestationPtrOutput) ContentType() GenericSignedAttestationContentTypePtrOutput {
	return o.ApplyT(func(v *GenericSignedAttestation) *GenericSignedAttestationContentType {
		if v == nil {
			return nil
		}
		return v.ContentType
	}).(GenericSignedAttestationContentTypePtrOutput)
}

// The serialized payload that is verified by one or more `signatures`. The encoding and semantic meaning of this payload must match what is set in `content_type`.
func (o GenericSignedAttestationPtrOutput) SerializedPayload() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GenericSignedAttestation) *string {
		if v == nil {
			return nil
		}
		return v.SerializedPayload
	}).(pulumi.StringPtrOutput)
}

// One or more signatures over `serialized_payload`. Verifier implementations should consider this attestation message verified if at least one `signature` verifies `serialized_payload`. See `Signature` in common.proto for more details on signature structure and verification.
func (o GenericSignedAttestationPtrOutput) Signatures() SignatureArrayOutput {
	return o.ApplyT(func(v *GenericSignedAttestation) []Signature {
		if v == nil {
			return nil
		}
		return v.Signatures
	}).(SignatureArrayOutput)
}

// An attestation wrapper that uses the Grafeas `Signature` message. This attestation must define the `serialized_payload` that the `signatures` verify and any metadata necessary to interpret that plaintext. The signatures should always be over the `serialized_payload` bytestring.
type GenericSignedAttestationResponse struct {
	// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
	ContentType string `pulumi:"contentType"`
	// The serialized payload that is verified by one or more `signatures`. The encoding and semantic meaning of this payload must match what is set in `content_type`.
	SerializedPayload string `pulumi:"serializedPayload"`
	// One or more signatures over `serialized_payload`. Verifier implementations should consider this attestation message verified if at least one `signature` verifies `serialized_payload`. See `Signature` in common.proto for more details on signature structure and verification.
	Signatures []SignatureResponse `pulumi:"signatures"`
}

// GenericSignedAttestationResponseInput is an input type that accepts GenericSignedAttestationResponseArgs and GenericSignedAttestationResponseOutput values.
// You can construct a concrete instance of `GenericSignedAttestationResponseInput` via:
//
//          GenericSignedAttestationResponseArgs{...}
type GenericSignedAttestationResponseInput interface {
	pulumi.Input

	ToGenericSignedAttestationResponseOutput() GenericSignedAttestationResponseOutput
	ToGenericSignedAttestationResponseOutputWithContext(context.Context) GenericSignedAttestationResponseOutput
}

// An attestation wrapper that uses the Grafeas `Signature` message. This attestation must define the `serialized_payload` that the `signatures` verify and any metadata necessary to interpret that plaintext. The signatures should always be over the `serialized_payload` bytestring.
type GenericSignedAttestationResponseArgs struct {
	// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
	ContentType pulumi.StringInput `pulumi:"contentType"`
	// The serialized payload that is verified by one or more `signatures`. The encoding and semantic meaning of this payload must match what is set in `content_type`.
	SerializedPayload pulumi.StringInput `pulumi:"serializedPayload"`
	// One or more signatures over `serialized_payload`. Verifier implementations should consider this attestation message verified if at least one `signature` verifies `serialized_payload`. See `Signature` in common.proto for more details on signature structure and verification.
	Signatures SignatureResponseArrayInput `pulumi:"signatures"`
}

func (GenericSignedAttestationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GenericSignedAttestationResponse)(nil)).Elem()
}

func (i GenericSignedAttestationResponseArgs) ToGenericSignedAttestationResponseOutput() GenericSignedAttestationResponseOutput {
	return i.ToGenericSignedAttestationResponseOutputWithContext(context.Background())
}

func (i GenericSignedAttestationResponseArgs) ToGenericSignedAttestationResponseOutputWithContext(ctx context.Context) GenericSignedAttestationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GenericSignedAttestationResponseOutput)
}

func (i GenericSignedAttestationResponseArgs) ToGenericSignedAttestationResponsePtrOutput() GenericSignedAttestationResponsePtrOutput {
	return i.ToGenericSignedAttestationResponsePtrOutputWithContext(context.Background())
}

func (i GenericSignedAttestationResponseArgs) ToGenericSignedAttestationResponsePtrOutputWithContext(ctx context.Context) GenericSignedAttestationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GenericSignedAttestationResponseOutput).ToGenericSignedAttestationResponsePtrOutputWithContext(ctx)
}

// GenericSignedAttestationResponsePtrInput is an input type that accepts GenericSignedAttestationResponseArgs, GenericSignedAttestationResponsePtr and GenericSignedAttestationResponsePtrOutput values.
// You can construct a concrete instance of `GenericSignedAttestationResponsePtrInput` via:
//
//          GenericSignedAttestationResponseArgs{...}
//
//  or:
//
//          nil
type GenericSignedAttestationResponsePtrInput interface {
	pulumi.Input

	ToGenericSignedAttestationResponsePtrOutput() GenericSignedAttestationResponsePtrOutput
	ToGenericSignedAttestationResponsePtrOutputWithContext(context.Context) GenericSignedAttestationResponsePtrOutput
}

type genericSignedAttestationResponsePtrType GenericSignedAttestationResponseArgs

func GenericSignedAttestationResponsePtr(v *GenericSignedAttestationResponseArgs) GenericSignedAttestationResponsePtrInput {
	return (*genericSignedAttestationResponsePtrType)(v)
}

func (*genericSignedAttestationResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GenericSignedAttestationResponse)(nil)).Elem()
}

func (i *genericSignedAttestationResponsePtrType) ToGenericSignedAttestationResponsePtrOutput() GenericSignedAttestationResponsePtrOutput {
	return i.ToGenericSignedAttestationResponsePtrOutputWithContext(context.Background())
}

func (i *genericSignedAttestationResponsePtrType) ToGenericSignedAttestationResponsePtrOutputWithContext(ctx context.Context) GenericSignedAttestationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GenericSignedAttestationResponsePtrOutput)
}

// An attestation wrapper that uses the Grafeas `Signature` message. This attestation must define the `serialized_payload` that the `signatures` verify and any metadata necessary to interpret that plaintext. The signatures should always be over the `serialized_payload` bytestring.
type GenericSignedAttestationResponseOutput struct{ *pulumi.OutputState }

func (GenericSignedAttestationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GenericSignedAttestationResponse)(nil)).Elem()
}

func (o GenericSignedAttestationResponseOutput) ToGenericSignedAttestationResponseOutput() GenericSignedAttestationResponseOutput {
	return o
}

func (o GenericSignedAttestationResponseOutput) ToGenericSignedAttestationResponseOutputWithContext(ctx context.Context) GenericSignedAttestationResponseOutput {
	return o
}

func (o GenericSignedAttestationResponseOutput) ToGenericSignedAttestationResponsePtrOutput() GenericSignedAttestationResponsePtrOutput {
	return o.ToGenericSignedAttestationResponsePtrOutputWithContext(context.Background())
}

func (o GenericSignedAttestationResponseOutput) ToGenericSignedAttestationResponsePtrOutputWithContext(ctx context.Context) GenericSignedAttestationResponsePtrOutput {
	return o.ApplyT(func(v GenericSignedAttestationResponse) *GenericSignedAttestationResponse {
		return &v
	}).(GenericSignedAttestationResponsePtrOutput)
}

// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
func (o GenericSignedAttestationResponseOutput) ContentType() pulumi.StringOutput {
	return o.ApplyT(func(v GenericSignedAttestationResponse) string { return v.ContentType }).(pulumi.StringOutput)
}

// The serialized payload that is verified by one or more `signatures`. The encoding and semantic meaning of this payload must match what is set in `content_type`.
func (o GenericSignedAttestationResponseOutput) SerializedPayload() pulumi.StringOutput {
	return o.ApplyT(func(v GenericSignedAttestationResponse) string { return v.SerializedPayload }).(pulumi.StringOutput)
}

// One or more signatures over `serialized_payload`. Verifier implementations should consider this attestation message verified if at least one `signature` verifies `serialized_payload`. See `Signature` in common.proto for more details on signature structure and verification.
func (o GenericSignedAttestationResponseOutput) Signatures() SignatureResponseArrayOutput {
	return o.ApplyT(func(v GenericSignedAttestationResponse) []SignatureResponse { return v.Signatures }).(SignatureResponseArrayOutput)
}

type GenericSignedAttestationResponsePtrOutput struct{ *pulumi.OutputState }

func (GenericSignedAttestationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GenericSignedAttestationResponse)(nil)).Elem()
}

func (o GenericSignedAttestationResponsePtrOutput) ToGenericSignedAttestationResponsePtrOutput() GenericSignedAttestationResponsePtrOutput {
	return o
}

func (o GenericSignedAttestationResponsePtrOutput) ToGenericSignedAttestationResponsePtrOutputWithContext(ctx context.Context) GenericSignedAttestationResponsePtrOutput {
	return o
}

func (o GenericSignedAttestationResponsePtrOutput) Elem() GenericSignedAttestationResponseOutput {
	return o.ApplyT(func(v *GenericSignedAttestationResponse) GenericSignedAttestationResponse { return *v }).(GenericSignedAttestationResponseOutput)
}

// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
func (o GenericSignedAttestationResponsePtrOutput) ContentType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GenericSignedAttestationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ContentType
	}).(pulumi.StringPtrOutput)
}

// The serialized payload that is verified by one or more `signatures`. The encoding and semantic meaning of this payload must match what is set in `content_type`.
func (o GenericSignedAttestationResponsePtrOutput) SerializedPayload() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GenericSignedAttestationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.SerializedPayload
	}).(pulumi.StringPtrOutput)
}

// One or more signatures over `serialized_payload`. Verifier implementations should consider this attestation message verified if at least one `signature` verifies `serialized_payload`. See `Signature` in common.proto for more details on signature structure and verification.
func (o GenericSignedAttestationResponsePtrOutput) Signatures() SignatureResponseArrayOutput {
	return o.ApplyT(func(v *GenericSignedAttestationResponse) []SignatureResponse {
		if v == nil {
			return nil
		}
		return v.Signatures
	}).(SignatureResponseArrayOutput)
}

// A SourceContext referring to a Gerrit project.
type GerritSourceContext struct {
	// An alias, which may be a branch or tag.
	AliasContext *AliasContext `pulumi:"aliasContext"`
	// The full project name within the host. Projects may be nested, so "project/subproject" is a valid project name. The "repo name" is the hostURI/project.
	GerritProject *string `pulumi:"gerritProject"`
	// The URI of a running Gerrit instance.
	HostUri *string `pulumi:"hostUri"`
	// A revision (commit) ID.
	RevisionId *string `pulumi:"revisionId"`
}

// GerritSourceContextInput is an input type that accepts GerritSourceContextArgs and GerritSourceContextOutput values.
// You can construct a concrete instance of `GerritSourceContextInput` via:
//
//          GerritSourceContextArgs{...}
type GerritSourceContextInput interface {
	pulumi.Input

	ToGerritSourceContextOutput() GerritSourceContextOutput
	ToGerritSourceContextOutputWithContext(context.Context) GerritSourceContextOutput
}

// A SourceContext referring to a Gerrit project.
type GerritSourceContextArgs struct {
	// An alias, which may be a branch or tag.
	AliasContext AliasContextPtrInput `pulumi:"aliasContext"`
	// The full project name within the host. Projects may be nested, so "project/subproject" is a valid project name. The "repo name" is the hostURI/project.
	GerritProject pulumi.StringPtrInput `pulumi:"gerritProject"`
	// The URI of a running Gerrit instance.
	HostUri pulumi.StringPtrInput `pulumi:"hostUri"`
	// A revision (commit) ID.
	RevisionId pulumi.StringPtrInput `pulumi:"revisionId"`
}

func (GerritSourceContextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GerritSourceContext)(nil)).Elem()
}

func (i GerritSourceContextArgs) ToGerritSourceContextOutput() GerritSourceContextOutput {
	return i.ToGerritSourceContextOutputWithContext(context.Background())
}

func (i GerritSourceContextArgs) ToGerritSourceContextOutputWithContext(ctx context.Context) GerritSourceContextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GerritSourceContextOutput)
}

func (i GerritSourceContextArgs) ToGerritSourceContextPtrOutput() GerritSourceContextPtrOutput {
	return i.ToGerritSourceContextPtrOutputWithContext(context.Background())
}

func (i GerritSourceContextArgs) ToGerritSourceContextPtrOutputWithContext(ctx context.Context) GerritSourceContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GerritSourceContextOutput).ToGerritSourceContextPtrOutputWithContext(ctx)
}

// GerritSourceContextPtrInput is an input type that accepts GerritSourceContextArgs, GerritSourceContextPtr and GerritSourceContextPtrOutput values.
// You can construct a concrete instance of `GerritSourceContextPtrInput` via:
//
//          GerritSourceContextArgs{...}
//
//  or:
//
//          nil
type GerritSourceContextPtrInput interface {
	pulumi.Input

	ToGerritSourceContextPtrOutput() GerritSourceContextPtrOutput
	ToGerritSourceContextPtrOutputWithContext(context.Context) GerritSourceContextPtrOutput
}

type gerritSourceContextPtrType GerritSourceContextArgs

func GerritSourceContextPtr(v *GerritSourceContextArgs) GerritSourceContextPtrInput {
	return (*gerritSourceContextPtrType)(v)
}

func (*gerritSourceContextPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GerritSourceContext)(nil)).Elem()
}

func (i *gerritSourceContextPtrType) ToGerritSourceContextPtrOutput() GerritSourceContextPtrOutput {
	return i.ToGerritSourceContextPtrOutputWithContext(context.Background())
}

func (i *gerritSourceContextPtrType) ToGerritSourceContextPtrOutputWithContext(ctx context.Context) GerritSourceContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GerritSourceContextPtrOutput)
}

// A SourceContext referring to a Gerrit project.
type GerritSourceContextOutput struct{ *pulumi.OutputState }

func (GerritSourceContextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GerritSourceContext)(nil)).Elem()
}

func (o GerritSourceContextOutput) ToGerritSourceContextOutput() GerritSourceContextOutput {
	return o
}

func (o GerritSourceContextOutput) ToGerritSourceContextOutputWithContext(ctx context.Context) GerritSourceContextOutput {
	return o
}

func (o GerritSourceContextOutput) ToGerritSourceContextPtrOutput() GerritSourceContextPtrOutput {
	return o.ToGerritSourceContextPtrOutputWithContext(context.Background())
}

func (o GerritSourceContextOutput) ToGerritSourceContextPtrOutputWithContext(ctx context.Context) GerritSourceContextPtrOutput {
	return o.ApplyT(func(v GerritSourceContext) *GerritSourceContext {
		return &v
	}).(GerritSourceContextPtrOutput)
}

// An alias, which may be a branch or tag.
func (o GerritSourceContextOutput) AliasContext() AliasContextPtrOutput {
	return o.ApplyT(func(v GerritSourceContext) *AliasContext { return v.AliasContext }).(AliasContextPtrOutput)
}

// The full project name within the host. Projects may be nested, so "project/subproject" is a valid project name. The "repo name" is the hostURI/project.
func (o GerritSourceContextOutput) GerritProject() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GerritSourceContext) *string { return v.GerritProject }).(pulumi.StringPtrOutput)
}

// The URI of a running Gerrit instance.
func (o GerritSourceContextOutput) HostUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GerritSourceContext) *string { return v.HostUri }).(pulumi.StringPtrOutput)
}

// A revision (commit) ID.
func (o GerritSourceContextOutput) RevisionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GerritSourceContext) *string { return v.RevisionId }).(pulumi.StringPtrOutput)
}

type GerritSourceContextPtrOutput struct{ *pulumi.OutputState }

func (GerritSourceContextPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GerritSourceContext)(nil)).Elem()
}

func (o GerritSourceContextPtrOutput) ToGerritSourceContextPtrOutput() GerritSourceContextPtrOutput {
	return o
}

func (o GerritSourceContextPtrOutput) ToGerritSourceContextPtrOutputWithContext(ctx context.Context) GerritSourceContextPtrOutput {
	return o
}

func (o GerritSourceContextPtrOutput) Elem() GerritSourceContextOutput {
	return o.ApplyT(func(v *GerritSourceContext) GerritSourceContext { return *v }).(GerritSourceContextOutput)
}

// An alias, which may be a branch or tag.
func (o GerritSourceContextPtrOutput) AliasContext() AliasContextPtrOutput {
	return o.ApplyT(func(v *GerritSourceContext) *AliasContext {
		if v == nil {
			return nil
		}
		return v.AliasContext
	}).(AliasContextPtrOutput)
}

// The full project name within the host. Projects may be nested, so "project/subproject" is a valid project name. The "repo name" is the hostURI/project.
func (o GerritSourceContextPtrOutput) GerritProject() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GerritSourceContext) *string {
		if v == nil {
			return nil
		}
		return v.GerritProject
	}).(pulumi.StringPtrOutput)
}

// The URI of a running Gerrit instance.
func (o GerritSourceContextPtrOutput) HostUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GerritSourceContext) *string {
		if v == nil {
			return nil
		}
		return v.HostUri
	}).(pulumi.StringPtrOutput)
}

// A revision (commit) ID.
func (o GerritSourceContextPtrOutput) RevisionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GerritSourceContext) *string {
		if v == nil {
			return nil
		}
		return v.RevisionId
	}).(pulumi.StringPtrOutput)
}

// A SourceContext referring to a Gerrit project.
type GerritSourceContextResponse struct {
	// An alias, which may be a branch or tag.
	AliasContext AliasContextResponse `pulumi:"aliasContext"`
	// The full project name within the host. Projects may be nested, so "project/subproject" is a valid project name. The "repo name" is the hostURI/project.
	GerritProject string `pulumi:"gerritProject"`
	// The URI of a running Gerrit instance.
	HostUri string `pulumi:"hostUri"`
	// A revision (commit) ID.
	RevisionId string `pulumi:"revisionId"`
}

// GerritSourceContextResponseInput is an input type that accepts GerritSourceContextResponseArgs and GerritSourceContextResponseOutput values.
// You can construct a concrete instance of `GerritSourceContextResponseInput` via:
//
//          GerritSourceContextResponseArgs{...}
type GerritSourceContextResponseInput interface {
	pulumi.Input

	ToGerritSourceContextResponseOutput() GerritSourceContextResponseOutput
	ToGerritSourceContextResponseOutputWithContext(context.Context) GerritSourceContextResponseOutput
}

// A SourceContext referring to a Gerrit project.
type GerritSourceContextResponseArgs struct {
	// An alias, which may be a branch or tag.
	AliasContext AliasContextResponseInput `pulumi:"aliasContext"`
	// The full project name within the host. Projects may be nested, so "project/subproject" is a valid project name. The "repo name" is the hostURI/project.
	GerritProject pulumi.StringInput `pulumi:"gerritProject"`
	// The URI of a running Gerrit instance.
	HostUri pulumi.StringInput `pulumi:"hostUri"`
	// A revision (commit) ID.
	RevisionId pulumi.StringInput `pulumi:"revisionId"`
}

func (GerritSourceContextResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GerritSourceContextResponse)(nil)).Elem()
}

func (i GerritSourceContextResponseArgs) ToGerritSourceContextResponseOutput() GerritSourceContextResponseOutput {
	return i.ToGerritSourceContextResponseOutputWithContext(context.Background())
}

func (i GerritSourceContextResponseArgs) ToGerritSourceContextResponseOutputWithContext(ctx context.Context) GerritSourceContextResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GerritSourceContextResponseOutput)
}

func (i GerritSourceContextResponseArgs) ToGerritSourceContextResponsePtrOutput() GerritSourceContextResponsePtrOutput {
	return i.ToGerritSourceContextResponsePtrOutputWithContext(context.Background())
}

func (i GerritSourceContextResponseArgs) ToGerritSourceContextResponsePtrOutputWithContext(ctx context.Context) GerritSourceContextResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GerritSourceContextResponseOutput).ToGerritSourceContextResponsePtrOutputWithContext(ctx)
}

// GerritSourceContextResponsePtrInput is an input type that accepts GerritSourceContextResponseArgs, GerritSourceContextResponsePtr and GerritSourceContextResponsePtrOutput values.
// You can construct a concrete instance of `GerritSourceContextResponsePtrInput` via:
//
//          GerritSourceContextResponseArgs{...}
//
//  or:
//
//          nil
type GerritSourceContextResponsePtrInput interface {
	pulumi.Input

	ToGerritSourceContextResponsePtrOutput() GerritSourceContextResponsePtrOutput
	ToGerritSourceContextResponsePtrOutputWithContext(context.Context) GerritSourceContextResponsePtrOutput
}

type gerritSourceContextResponsePtrType GerritSourceContextResponseArgs

func GerritSourceContextResponsePtr(v *GerritSourceContextResponseArgs) GerritSourceContextResponsePtrInput {
	return (*gerritSourceContextResponsePtrType)(v)
}

func (*gerritSourceContextResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GerritSourceContextResponse)(nil)).Elem()
}

func (i *gerritSourceContextResponsePtrType) ToGerritSourceContextResponsePtrOutput() GerritSourceContextResponsePtrOutput {
	return i.ToGerritSourceContextResponsePtrOutputWithContext(context.Background())
}

func (i *gerritSourceContextResponsePtrType) ToGerritSourceContextResponsePtrOutputWithContext(ctx context.Context) GerritSourceContextResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GerritSourceContextResponsePtrOutput)
}

// A SourceContext referring to a Gerrit project.
type GerritSourceContextResponseOutput struct{ *pulumi.OutputState }

func (GerritSourceContextResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GerritSourceContextResponse)(nil)).Elem()
}

func (o GerritSourceContextResponseOutput) ToGerritSourceContextResponseOutput() GerritSourceContextResponseOutput {
	return o
}

func (o GerritSourceContextResponseOutput) ToGerritSourceContextResponseOutputWithContext(ctx context.Context) GerritSourceContextResponseOutput {
	return o
}

func (o GerritSourceContextResponseOutput) ToGerritSourceContextResponsePtrOutput() GerritSourceContextResponsePtrOutput {
	return o.ToGerritSourceContextResponsePtrOutputWithContext(context.Background())
}

func (o GerritSourceContextResponseOutput) ToGerritSourceContextResponsePtrOutputWithContext(ctx context.Context) GerritSourceContextResponsePtrOutput {
	return o.ApplyT(func(v GerritSourceContextResponse) *GerritSourceContextResponse {
		return &v
	}).(GerritSourceContextResponsePtrOutput)
}

// An alias, which may be a branch or tag.
func (o GerritSourceContextResponseOutput) AliasContext() AliasContextResponseOutput {
	return o.ApplyT(func(v GerritSourceContextResponse) AliasContextResponse { return v.AliasContext }).(AliasContextResponseOutput)
}

// The full project name within the host. Projects may be nested, so "project/subproject" is a valid project name. The "repo name" is the hostURI/project.
func (o GerritSourceContextResponseOutput) GerritProject() pulumi.StringOutput {
	return o.ApplyT(func(v GerritSourceContextResponse) string { return v.GerritProject }).(pulumi.StringOutput)
}

// The URI of a running Gerrit instance.
func (o GerritSourceContextResponseOutput) HostUri() pulumi.StringOutput {
	return o.ApplyT(func(v GerritSourceContextResponse) string { return v.HostUri }).(pulumi.StringOutput)
}

// A revision (commit) ID.
func (o GerritSourceContextResponseOutput) RevisionId() pulumi.StringOutput {
	return o.ApplyT(func(v GerritSourceContextResponse) string { return v.RevisionId }).(pulumi.StringOutput)
}

type GerritSourceContextResponsePtrOutput struct{ *pulumi.OutputState }

func (GerritSourceContextResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GerritSourceContextResponse)(nil)).Elem()
}

func (o GerritSourceContextResponsePtrOutput) ToGerritSourceContextResponsePtrOutput() GerritSourceContextResponsePtrOutput {
	return o
}

func (o GerritSourceContextResponsePtrOutput) ToGerritSourceContextResponsePtrOutputWithContext(ctx context.Context) GerritSourceContextResponsePtrOutput {
	return o
}

func (o GerritSourceContextResponsePtrOutput) Elem() GerritSourceContextResponseOutput {
	return o.ApplyT(func(v *GerritSourceContextResponse) GerritSourceContextResponse { return *v }).(GerritSourceContextResponseOutput)
}

// An alias, which may be a branch or tag.
func (o GerritSourceContextResponsePtrOutput) AliasContext() AliasContextResponsePtrOutput {
	return o.ApplyT(func(v *GerritSourceContextResponse) *AliasContextResponse {
		if v == nil {
			return nil
		}
		return &v.AliasContext
	}).(AliasContextResponsePtrOutput)
}

// The full project name within the host. Projects may be nested, so "project/subproject" is a valid project name. The "repo name" is the hostURI/project.
func (o GerritSourceContextResponsePtrOutput) GerritProject() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GerritSourceContextResponse) *string {
		if v == nil {
			return nil
		}
		return &v.GerritProject
	}).(pulumi.StringPtrOutput)
}

// The URI of a running Gerrit instance.
func (o GerritSourceContextResponsePtrOutput) HostUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GerritSourceContextResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HostUri
	}).(pulumi.StringPtrOutput)
}

// A revision (commit) ID.
func (o GerritSourceContextResponsePtrOutput) RevisionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GerritSourceContextResponse) *string {
		if v == nil {
			return nil
		}
		return &v.RevisionId
	}).(pulumi.StringPtrOutput)
}

// A GitSourceContext denotes a particular revision in a third party Git repository (e.g., GitHub).
type GitSourceContext struct {
	// Git commit hash.
	RevisionId *string `pulumi:"revisionId"`
	// Git repository URL.
	Url *string `pulumi:"url"`
}

// GitSourceContextInput is an input type that accepts GitSourceContextArgs and GitSourceContextOutput values.
// You can construct a concrete instance of `GitSourceContextInput` via:
//
//          GitSourceContextArgs{...}
type GitSourceContextInput interface {
	pulumi.Input

	ToGitSourceContextOutput() GitSourceContextOutput
	ToGitSourceContextOutputWithContext(context.Context) GitSourceContextOutput
}

// A GitSourceContext denotes a particular revision in a third party Git repository (e.g., GitHub).
type GitSourceContextArgs struct {
	// Git commit hash.
	RevisionId pulumi.StringPtrInput `pulumi:"revisionId"`
	// Git repository URL.
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (GitSourceContextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GitSourceContext)(nil)).Elem()
}

func (i GitSourceContextArgs) ToGitSourceContextOutput() GitSourceContextOutput {
	return i.ToGitSourceContextOutputWithContext(context.Background())
}

func (i GitSourceContextArgs) ToGitSourceContextOutputWithContext(ctx context.Context) GitSourceContextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GitSourceContextOutput)
}

func (i GitSourceContextArgs) ToGitSourceContextPtrOutput() GitSourceContextPtrOutput {
	return i.ToGitSourceContextPtrOutputWithContext(context.Background())
}

func (i GitSourceContextArgs) ToGitSourceContextPtrOutputWithContext(ctx context.Context) GitSourceContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GitSourceContextOutput).ToGitSourceContextPtrOutputWithContext(ctx)
}

// GitSourceContextPtrInput is an input type that accepts GitSourceContextArgs, GitSourceContextPtr and GitSourceContextPtrOutput values.
// You can construct a concrete instance of `GitSourceContextPtrInput` via:
//
//          GitSourceContextArgs{...}
//
//  or:
//
//          nil
type GitSourceContextPtrInput interface {
	pulumi.Input

	ToGitSourceContextPtrOutput() GitSourceContextPtrOutput
	ToGitSourceContextPtrOutputWithContext(context.Context) GitSourceContextPtrOutput
}

type gitSourceContextPtrType GitSourceContextArgs

func GitSourceContextPtr(v *GitSourceContextArgs) GitSourceContextPtrInput {
	return (*gitSourceContextPtrType)(v)
}

func (*gitSourceContextPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GitSourceContext)(nil)).Elem()
}

func (i *gitSourceContextPtrType) ToGitSourceContextPtrOutput() GitSourceContextPtrOutput {
	return i.ToGitSourceContextPtrOutputWithContext(context.Background())
}

func (i *gitSourceContextPtrType) ToGitSourceContextPtrOutputWithContext(ctx context.Context) GitSourceContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GitSourceContextPtrOutput)
}

// A GitSourceContext denotes a particular revision in a third party Git repository (e.g., GitHub).
type GitSourceContextOutput struct{ *pulumi.OutputState }

func (GitSourceContextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GitSourceContext)(nil)).Elem()
}

func (o GitSourceContextOutput) ToGitSourceContextOutput() GitSourceContextOutput {
	return o
}

func (o GitSourceContextOutput) ToGitSourceContextOutputWithContext(ctx context.Context) GitSourceContextOutput {
	return o
}

func (o GitSourceContextOutput) ToGitSourceContextPtrOutput() GitSourceContextPtrOutput {
	return o.ToGitSourceContextPtrOutputWithContext(context.Background())
}

func (o GitSourceContextOutput) ToGitSourceContextPtrOutputWithContext(ctx context.Context) GitSourceContextPtrOutput {
	return o.ApplyT(func(v GitSourceContext) *GitSourceContext {
		return &v
	}).(GitSourceContextPtrOutput)
}

// Git commit hash.
func (o GitSourceContextOutput) RevisionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GitSourceContext) *string { return v.RevisionId }).(pulumi.StringPtrOutput)
}

// Git repository URL.
func (o GitSourceContextOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GitSourceContext) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type GitSourceContextPtrOutput struct{ *pulumi.OutputState }

func (GitSourceContextPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GitSourceContext)(nil)).Elem()
}

func (o GitSourceContextPtrOutput) ToGitSourceContextPtrOutput() GitSourceContextPtrOutput {
	return o
}

func (o GitSourceContextPtrOutput) ToGitSourceContextPtrOutputWithContext(ctx context.Context) GitSourceContextPtrOutput {
	return o
}

func (o GitSourceContextPtrOutput) Elem() GitSourceContextOutput {
	return o.ApplyT(func(v *GitSourceContext) GitSourceContext { return *v }).(GitSourceContextOutput)
}

// Git commit hash.
func (o GitSourceContextPtrOutput) RevisionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GitSourceContext) *string {
		if v == nil {
			return nil
		}
		return v.RevisionId
	}).(pulumi.StringPtrOutput)
}

// Git repository URL.
func (o GitSourceContextPtrOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GitSourceContext) *string {
		if v == nil {
			return nil
		}
		return v.Url
	}).(pulumi.StringPtrOutput)
}

// A GitSourceContext denotes a particular revision in a third party Git repository (e.g., GitHub).
type GitSourceContextResponse struct {
	// Git commit hash.
	RevisionId string `pulumi:"revisionId"`
	// Git repository URL.
	Url string `pulumi:"url"`
}

// GitSourceContextResponseInput is an input type that accepts GitSourceContextResponseArgs and GitSourceContextResponseOutput values.
// You can construct a concrete instance of `GitSourceContextResponseInput` via:
//
//          GitSourceContextResponseArgs{...}
type GitSourceContextResponseInput interface {
	pulumi.Input

	ToGitSourceContextResponseOutput() GitSourceContextResponseOutput
	ToGitSourceContextResponseOutputWithContext(context.Context) GitSourceContextResponseOutput
}

// A GitSourceContext denotes a particular revision in a third party Git repository (e.g., GitHub).
type GitSourceContextResponseArgs struct {
	// Git commit hash.
	RevisionId pulumi.StringInput `pulumi:"revisionId"`
	// Git repository URL.
	Url pulumi.StringInput `pulumi:"url"`
}

func (GitSourceContextResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GitSourceContextResponse)(nil)).Elem()
}

func (i GitSourceContextResponseArgs) ToGitSourceContextResponseOutput() GitSourceContextResponseOutput {
	return i.ToGitSourceContextResponseOutputWithContext(context.Background())
}

func (i GitSourceContextResponseArgs) ToGitSourceContextResponseOutputWithContext(ctx context.Context) GitSourceContextResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GitSourceContextResponseOutput)
}

func (i GitSourceContextResponseArgs) ToGitSourceContextResponsePtrOutput() GitSourceContextResponsePtrOutput {
	return i.ToGitSourceContextResponsePtrOutputWithContext(context.Background())
}

func (i GitSourceContextResponseArgs) ToGitSourceContextResponsePtrOutputWithContext(ctx context.Context) GitSourceContextResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GitSourceContextResponseOutput).ToGitSourceContextResponsePtrOutputWithContext(ctx)
}

// GitSourceContextResponsePtrInput is an input type that accepts GitSourceContextResponseArgs, GitSourceContextResponsePtr and GitSourceContextResponsePtrOutput values.
// You can construct a concrete instance of `GitSourceContextResponsePtrInput` via:
//
//          GitSourceContextResponseArgs{...}
//
//  or:
//
//          nil
type GitSourceContextResponsePtrInput interface {
	pulumi.Input

	ToGitSourceContextResponsePtrOutput() GitSourceContextResponsePtrOutput
	ToGitSourceContextResponsePtrOutputWithContext(context.Context) GitSourceContextResponsePtrOutput
}

type gitSourceContextResponsePtrType GitSourceContextResponseArgs

func GitSourceContextResponsePtr(v *GitSourceContextResponseArgs) GitSourceContextResponsePtrInput {
	return (*gitSourceContextResponsePtrType)(v)
}

func (*gitSourceContextResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GitSourceContextResponse)(nil)).Elem()
}

func (i *gitSourceContextResponsePtrType) ToGitSourceContextResponsePtrOutput() GitSourceContextResponsePtrOutput {
	return i.ToGitSourceContextResponsePtrOutputWithContext(context.Background())
}

func (i *gitSourceContextResponsePtrType) ToGitSourceContextResponsePtrOutputWithContext(ctx context.Context) GitSourceContextResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GitSourceContextResponsePtrOutput)
}

// A GitSourceContext denotes a particular revision in a third party Git repository (e.g., GitHub).
type GitSourceContextResponseOutput struct{ *pulumi.OutputState }

func (GitSourceContextResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GitSourceContextResponse)(nil)).Elem()
}

func (o GitSourceContextResponseOutput) ToGitSourceContextResponseOutput() GitSourceContextResponseOutput {
	return o
}

func (o GitSourceContextResponseOutput) ToGitSourceContextResponseOutputWithContext(ctx context.Context) GitSourceContextResponseOutput {
	return o
}

func (o GitSourceContextResponseOutput) ToGitSourceContextResponsePtrOutput() GitSourceContextResponsePtrOutput {
	return o.ToGitSourceContextResponsePtrOutputWithContext(context.Background())
}

func (o GitSourceContextResponseOutput) ToGitSourceContextResponsePtrOutputWithContext(ctx context.Context) GitSourceContextResponsePtrOutput {
	return o.ApplyT(func(v GitSourceContextResponse) *GitSourceContextResponse {
		return &v
	}).(GitSourceContextResponsePtrOutput)
}

// Git commit hash.
func (o GitSourceContextResponseOutput) RevisionId() pulumi.StringOutput {
	return o.ApplyT(func(v GitSourceContextResponse) string { return v.RevisionId }).(pulumi.StringOutput)
}

// Git repository URL.
func (o GitSourceContextResponseOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v GitSourceContextResponse) string { return v.Url }).(pulumi.StringOutput)
}

type GitSourceContextResponsePtrOutput struct{ *pulumi.OutputState }

func (GitSourceContextResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GitSourceContextResponse)(nil)).Elem()
}

func (o GitSourceContextResponsePtrOutput) ToGitSourceContextResponsePtrOutput() GitSourceContextResponsePtrOutput {
	return o
}

func (o GitSourceContextResponsePtrOutput) ToGitSourceContextResponsePtrOutputWithContext(ctx context.Context) GitSourceContextResponsePtrOutput {
	return o
}

func (o GitSourceContextResponsePtrOutput) Elem() GitSourceContextResponseOutput {
	return o.ApplyT(func(v *GitSourceContextResponse) GitSourceContextResponse { return *v }).(GitSourceContextResponseOutput)
}

// Git commit hash.
func (o GitSourceContextResponsePtrOutput) RevisionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GitSourceContextResponse) *string {
		if v == nil {
			return nil
		}
		return &v.RevisionId
	}).(pulumi.StringPtrOutput)
}

// Git repository URL.
func (o GitSourceContextResponsePtrOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GitSourceContextResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Url
	}).(pulumi.StringPtrOutput)
}

// Details of a build occurrence.
type GrafeasV1beta1BuildDetails struct {
	// The actual provenance for the build.
	Provenance BuildProvenance `pulumi:"provenance"`
	// Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
	ProvenanceBytes *string `pulumi:"provenanceBytes"`
}

// GrafeasV1beta1BuildDetailsInput is an input type that accepts GrafeasV1beta1BuildDetailsArgs and GrafeasV1beta1BuildDetailsOutput values.
// You can construct a concrete instance of `GrafeasV1beta1BuildDetailsInput` via:
//
//          GrafeasV1beta1BuildDetailsArgs{...}
type GrafeasV1beta1BuildDetailsInput interface {
	pulumi.Input

	ToGrafeasV1beta1BuildDetailsOutput() GrafeasV1beta1BuildDetailsOutput
	ToGrafeasV1beta1BuildDetailsOutputWithContext(context.Context) GrafeasV1beta1BuildDetailsOutput
}

// Details of a build occurrence.
type GrafeasV1beta1BuildDetailsArgs struct {
	// The actual provenance for the build.
	Provenance BuildProvenanceInput `pulumi:"provenance"`
	// Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
	ProvenanceBytes pulumi.StringPtrInput `pulumi:"provenanceBytes"`
}

func (GrafeasV1beta1BuildDetailsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1BuildDetails)(nil)).Elem()
}

func (i GrafeasV1beta1BuildDetailsArgs) ToGrafeasV1beta1BuildDetailsOutput() GrafeasV1beta1BuildDetailsOutput {
	return i.ToGrafeasV1beta1BuildDetailsOutputWithContext(context.Background())
}

func (i GrafeasV1beta1BuildDetailsArgs) ToGrafeasV1beta1BuildDetailsOutputWithContext(ctx context.Context) GrafeasV1beta1BuildDetailsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1BuildDetailsOutput)
}

func (i GrafeasV1beta1BuildDetailsArgs) ToGrafeasV1beta1BuildDetailsPtrOutput() GrafeasV1beta1BuildDetailsPtrOutput {
	return i.ToGrafeasV1beta1BuildDetailsPtrOutputWithContext(context.Background())
}

func (i GrafeasV1beta1BuildDetailsArgs) ToGrafeasV1beta1BuildDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1BuildDetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1BuildDetailsOutput).ToGrafeasV1beta1BuildDetailsPtrOutputWithContext(ctx)
}

// GrafeasV1beta1BuildDetailsPtrInput is an input type that accepts GrafeasV1beta1BuildDetailsArgs, GrafeasV1beta1BuildDetailsPtr and GrafeasV1beta1BuildDetailsPtrOutput values.
// You can construct a concrete instance of `GrafeasV1beta1BuildDetailsPtrInput` via:
//
//          GrafeasV1beta1BuildDetailsArgs{...}
//
//  or:
//
//          nil
type GrafeasV1beta1BuildDetailsPtrInput interface {
	pulumi.Input

	ToGrafeasV1beta1BuildDetailsPtrOutput() GrafeasV1beta1BuildDetailsPtrOutput
	ToGrafeasV1beta1BuildDetailsPtrOutputWithContext(context.Context) GrafeasV1beta1BuildDetailsPtrOutput
}

type grafeasV1beta1BuildDetailsPtrType GrafeasV1beta1BuildDetailsArgs

func GrafeasV1beta1BuildDetailsPtr(v *GrafeasV1beta1BuildDetailsArgs) GrafeasV1beta1BuildDetailsPtrInput {
	return (*grafeasV1beta1BuildDetailsPtrType)(v)
}

func (*grafeasV1beta1BuildDetailsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1BuildDetails)(nil)).Elem()
}

func (i *grafeasV1beta1BuildDetailsPtrType) ToGrafeasV1beta1BuildDetailsPtrOutput() GrafeasV1beta1BuildDetailsPtrOutput {
	return i.ToGrafeasV1beta1BuildDetailsPtrOutputWithContext(context.Background())
}

func (i *grafeasV1beta1BuildDetailsPtrType) ToGrafeasV1beta1BuildDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1BuildDetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1BuildDetailsPtrOutput)
}

// Details of a build occurrence.
type GrafeasV1beta1BuildDetailsOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1BuildDetailsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1BuildDetails)(nil)).Elem()
}

func (o GrafeasV1beta1BuildDetailsOutput) ToGrafeasV1beta1BuildDetailsOutput() GrafeasV1beta1BuildDetailsOutput {
	return o
}

func (o GrafeasV1beta1BuildDetailsOutput) ToGrafeasV1beta1BuildDetailsOutputWithContext(ctx context.Context) GrafeasV1beta1BuildDetailsOutput {
	return o
}

func (o GrafeasV1beta1BuildDetailsOutput) ToGrafeasV1beta1BuildDetailsPtrOutput() GrafeasV1beta1BuildDetailsPtrOutput {
	return o.ToGrafeasV1beta1BuildDetailsPtrOutputWithContext(context.Background())
}

func (o GrafeasV1beta1BuildDetailsOutput) ToGrafeasV1beta1BuildDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1BuildDetailsPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1BuildDetails) *GrafeasV1beta1BuildDetails {
		return &v
	}).(GrafeasV1beta1BuildDetailsPtrOutput)
}

// The actual provenance for the build.
func (o GrafeasV1beta1BuildDetailsOutput) Provenance() BuildProvenanceOutput {
	return o.ApplyT(func(v GrafeasV1beta1BuildDetails) BuildProvenance { return v.Provenance }).(BuildProvenanceOutput)
}

// Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
func (o GrafeasV1beta1BuildDetailsOutput) ProvenanceBytes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1BuildDetails) *string { return v.ProvenanceBytes }).(pulumi.StringPtrOutput)
}

type GrafeasV1beta1BuildDetailsPtrOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1BuildDetailsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1BuildDetails)(nil)).Elem()
}

func (o GrafeasV1beta1BuildDetailsPtrOutput) ToGrafeasV1beta1BuildDetailsPtrOutput() GrafeasV1beta1BuildDetailsPtrOutput {
	return o
}

func (o GrafeasV1beta1BuildDetailsPtrOutput) ToGrafeasV1beta1BuildDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1BuildDetailsPtrOutput {
	return o
}

func (o GrafeasV1beta1BuildDetailsPtrOutput) Elem() GrafeasV1beta1BuildDetailsOutput {
	return o.ApplyT(func(v *GrafeasV1beta1BuildDetails) GrafeasV1beta1BuildDetails { return *v }).(GrafeasV1beta1BuildDetailsOutput)
}

// The actual provenance for the build.
func (o GrafeasV1beta1BuildDetailsPtrOutput) Provenance() BuildProvenancePtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1BuildDetails) *BuildProvenance {
		if v == nil {
			return nil
		}
		return &v.Provenance
	}).(BuildProvenancePtrOutput)
}

// Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
func (o GrafeasV1beta1BuildDetailsPtrOutput) ProvenanceBytes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1BuildDetails) *string {
		if v == nil {
			return nil
		}
		return v.ProvenanceBytes
	}).(pulumi.StringPtrOutput)
}

// Details of a build occurrence.
type GrafeasV1beta1BuildDetailsResponse struct {
	// The actual provenance for the build.
	Provenance BuildProvenanceResponse `pulumi:"provenance"`
	// Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
	ProvenanceBytes string `pulumi:"provenanceBytes"`
}

// GrafeasV1beta1BuildDetailsResponseInput is an input type that accepts GrafeasV1beta1BuildDetailsResponseArgs and GrafeasV1beta1BuildDetailsResponseOutput values.
// You can construct a concrete instance of `GrafeasV1beta1BuildDetailsResponseInput` via:
//
//          GrafeasV1beta1BuildDetailsResponseArgs{...}
type GrafeasV1beta1BuildDetailsResponseInput interface {
	pulumi.Input

	ToGrafeasV1beta1BuildDetailsResponseOutput() GrafeasV1beta1BuildDetailsResponseOutput
	ToGrafeasV1beta1BuildDetailsResponseOutputWithContext(context.Context) GrafeasV1beta1BuildDetailsResponseOutput
}

// Details of a build occurrence.
type GrafeasV1beta1BuildDetailsResponseArgs struct {
	// The actual provenance for the build.
	Provenance BuildProvenanceResponseInput `pulumi:"provenance"`
	// Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
	ProvenanceBytes pulumi.StringInput `pulumi:"provenanceBytes"`
}

func (GrafeasV1beta1BuildDetailsResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1BuildDetailsResponse)(nil)).Elem()
}

func (i GrafeasV1beta1BuildDetailsResponseArgs) ToGrafeasV1beta1BuildDetailsResponseOutput() GrafeasV1beta1BuildDetailsResponseOutput {
	return i.ToGrafeasV1beta1BuildDetailsResponseOutputWithContext(context.Background())
}

func (i GrafeasV1beta1BuildDetailsResponseArgs) ToGrafeasV1beta1BuildDetailsResponseOutputWithContext(ctx context.Context) GrafeasV1beta1BuildDetailsResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1BuildDetailsResponseOutput)
}

func (i GrafeasV1beta1BuildDetailsResponseArgs) ToGrafeasV1beta1BuildDetailsResponsePtrOutput() GrafeasV1beta1BuildDetailsResponsePtrOutput {
	return i.ToGrafeasV1beta1BuildDetailsResponsePtrOutputWithContext(context.Background())
}

func (i GrafeasV1beta1BuildDetailsResponseArgs) ToGrafeasV1beta1BuildDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1BuildDetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1BuildDetailsResponseOutput).ToGrafeasV1beta1BuildDetailsResponsePtrOutputWithContext(ctx)
}

// GrafeasV1beta1BuildDetailsResponsePtrInput is an input type that accepts GrafeasV1beta1BuildDetailsResponseArgs, GrafeasV1beta1BuildDetailsResponsePtr and GrafeasV1beta1BuildDetailsResponsePtrOutput values.
// You can construct a concrete instance of `GrafeasV1beta1BuildDetailsResponsePtrInput` via:
//
//          GrafeasV1beta1BuildDetailsResponseArgs{...}
//
//  or:
//
//          nil
type GrafeasV1beta1BuildDetailsResponsePtrInput interface {
	pulumi.Input

	ToGrafeasV1beta1BuildDetailsResponsePtrOutput() GrafeasV1beta1BuildDetailsResponsePtrOutput
	ToGrafeasV1beta1BuildDetailsResponsePtrOutputWithContext(context.Context) GrafeasV1beta1BuildDetailsResponsePtrOutput
}

type grafeasV1beta1BuildDetailsResponsePtrType GrafeasV1beta1BuildDetailsResponseArgs

func GrafeasV1beta1BuildDetailsResponsePtr(v *GrafeasV1beta1BuildDetailsResponseArgs) GrafeasV1beta1BuildDetailsResponsePtrInput {
	return (*grafeasV1beta1BuildDetailsResponsePtrType)(v)
}

func (*grafeasV1beta1BuildDetailsResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1BuildDetailsResponse)(nil)).Elem()
}

func (i *grafeasV1beta1BuildDetailsResponsePtrType) ToGrafeasV1beta1BuildDetailsResponsePtrOutput() GrafeasV1beta1BuildDetailsResponsePtrOutput {
	return i.ToGrafeasV1beta1BuildDetailsResponsePtrOutputWithContext(context.Background())
}

func (i *grafeasV1beta1BuildDetailsResponsePtrType) ToGrafeasV1beta1BuildDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1BuildDetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1BuildDetailsResponsePtrOutput)
}

// Details of a build occurrence.
type GrafeasV1beta1BuildDetailsResponseOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1BuildDetailsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1BuildDetailsResponse)(nil)).Elem()
}

func (o GrafeasV1beta1BuildDetailsResponseOutput) ToGrafeasV1beta1BuildDetailsResponseOutput() GrafeasV1beta1BuildDetailsResponseOutput {
	return o
}

func (o GrafeasV1beta1BuildDetailsResponseOutput) ToGrafeasV1beta1BuildDetailsResponseOutputWithContext(ctx context.Context) GrafeasV1beta1BuildDetailsResponseOutput {
	return o
}

func (o GrafeasV1beta1BuildDetailsResponseOutput) ToGrafeasV1beta1BuildDetailsResponsePtrOutput() GrafeasV1beta1BuildDetailsResponsePtrOutput {
	return o.ToGrafeasV1beta1BuildDetailsResponsePtrOutputWithContext(context.Background())
}

func (o GrafeasV1beta1BuildDetailsResponseOutput) ToGrafeasV1beta1BuildDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1BuildDetailsResponsePtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1BuildDetailsResponse) *GrafeasV1beta1BuildDetailsResponse {
		return &v
	}).(GrafeasV1beta1BuildDetailsResponsePtrOutput)
}

// The actual provenance for the build.
func (o GrafeasV1beta1BuildDetailsResponseOutput) Provenance() BuildProvenanceResponseOutput {
	return o.ApplyT(func(v GrafeasV1beta1BuildDetailsResponse) BuildProvenanceResponse { return v.Provenance }).(BuildProvenanceResponseOutput)
}

// Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
func (o GrafeasV1beta1BuildDetailsResponseOutput) ProvenanceBytes() pulumi.StringOutput {
	return o.ApplyT(func(v GrafeasV1beta1BuildDetailsResponse) string { return v.ProvenanceBytes }).(pulumi.StringOutput)
}

type GrafeasV1beta1BuildDetailsResponsePtrOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1BuildDetailsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1BuildDetailsResponse)(nil)).Elem()
}

func (o GrafeasV1beta1BuildDetailsResponsePtrOutput) ToGrafeasV1beta1BuildDetailsResponsePtrOutput() GrafeasV1beta1BuildDetailsResponsePtrOutput {
	return o
}

func (o GrafeasV1beta1BuildDetailsResponsePtrOutput) ToGrafeasV1beta1BuildDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1BuildDetailsResponsePtrOutput {
	return o
}

func (o GrafeasV1beta1BuildDetailsResponsePtrOutput) Elem() GrafeasV1beta1BuildDetailsResponseOutput {
	return o.ApplyT(func(v *GrafeasV1beta1BuildDetailsResponse) GrafeasV1beta1BuildDetailsResponse { return *v }).(GrafeasV1beta1BuildDetailsResponseOutput)
}

// The actual provenance for the build.
func (o GrafeasV1beta1BuildDetailsResponsePtrOutput) Provenance() BuildProvenanceResponsePtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1BuildDetailsResponse) *BuildProvenanceResponse {
		if v == nil {
			return nil
		}
		return &v.Provenance
	}).(BuildProvenanceResponsePtrOutput)
}

// Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
func (o GrafeasV1beta1BuildDetailsResponsePtrOutput) ProvenanceBytes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1BuildDetailsResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ProvenanceBytes
	}).(pulumi.StringPtrOutput)
}

// Details of a deployment occurrence.
type GrafeasV1beta1DeploymentDetails struct {
	// Deployment history for the resource.
	Deployment Deployment `pulumi:"deployment"`
}

// GrafeasV1beta1DeploymentDetailsInput is an input type that accepts GrafeasV1beta1DeploymentDetailsArgs and GrafeasV1beta1DeploymentDetailsOutput values.
// You can construct a concrete instance of `GrafeasV1beta1DeploymentDetailsInput` via:
//
//          GrafeasV1beta1DeploymentDetailsArgs{...}
type GrafeasV1beta1DeploymentDetailsInput interface {
	pulumi.Input

	ToGrafeasV1beta1DeploymentDetailsOutput() GrafeasV1beta1DeploymentDetailsOutput
	ToGrafeasV1beta1DeploymentDetailsOutputWithContext(context.Context) GrafeasV1beta1DeploymentDetailsOutput
}

// Details of a deployment occurrence.
type GrafeasV1beta1DeploymentDetailsArgs struct {
	// Deployment history for the resource.
	Deployment DeploymentInput `pulumi:"deployment"`
}

func (GrafeasV1beta1DeploymentDetailsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1DeploymentDetails)(nil)).Elem()
}

func (i GrafeasV1beta1DeploymentDetailsArgs) ToGrafeasV1beta1DeploymentDetailsOutput() GrafeasV1beta1DeploymentDetailsOutput {
	return i.ToGrafeasV1beta1DeploymentDetailsOutputWithContext(context.Background())
}

func (i GrafeasV1beta1DeploymentDetailsArgs) ToGrafeasV1beta1DeploymentDetailsOutputWithContext(ctx context.Context) GrafeasV1beta1DeploymentDetailsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1DeploymentDetailsOutput)
}

func (i GrafeasV1beta1DeploymentDetailsArgs) ToGrafeasV1beta1DeploymentDetailsPtrOutput() GrafeasV1beta1DeploymentDetailsPtrOutput {
	return i.ToGrafeasV1beta1DeploymentDetailsPtrOutputWithContext(context.Background())
}

func (i GrafeasV1beta1DeploymentDetailsArgs) ToGrafeasV1beta1DeploymentDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1DeploymentDetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1DeploymentDetailsOutput).ToGrafeasV1beta1DeploymentDetailsPtrOutputWithContext(ctx)
}

// GrafeasV1beta1DeploymentDetailsPtrInput is an input type that accepts GrafeasV1beta1DeploymentDetailsArgs, GrafeasV1beta1DeploymentDetailsPtr and GrafeasV1beta1DeploymentDetailsPtrOutput values.
// You can construct a concrete instance of `GrafeasV1beta1DeploymentDetailsPtrInput` via:
//
//          GrafeasV1beta1DeploymentDetailsArgs{...}
//
//  or:
//
//          nil
type GrafeasV1beta1DeploymentDetailsPtrInput interface {
	pulumi.Input

	ToGrafeasV1beta1DeploymentDetailsPtrOutput() GrafeasV1beta1DeploymentDetailsPtrOutput
	ToGrafeasV1beta1DeploymentDetailsPtrOutputWithContext(context.Context) GrafeasV1beta1DeploymentDetailsPtrOutput
}

type grafeasV1beta1DeploymentDetailsPtrType GrafeasV1beta1DeploymentDetailsArgs

func GrafeasV1beta1DeploymentDetailsPtr(v *GrafeasV1beta1DeploymentDetailsArgs) GrafeasV1beta1DeploymentDetailsPtrInput {
	return (*grafeasV1beta1DeploymentDetailsPtrType)(v)
}

func (*grafeasV1beta1DeploymentDetailsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1DeploymentDetails)(nil)).Elem()
}

func (i *grafeasV1beta1DeploymentDetailsPtrType) ToGrafeasV1beta1DeploymentDetailsPtrOutput() GrafeasV1beta1DeploymentDetailsPtrOutput {
	return i.ToGrafeasV1beta1DeploymentDetailsPtrOutputWithContext(context.Background())
}

func (i *grafeasV1beta1DeploymentDetailsPtrType) ToGrafeasV1beta1DeploymentDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1DeploymentDetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1DeploymentDetailsPtrOutput)
}

// Details of a deployment occurrence.
type GrafeasV1beta1DeploymentDetailsOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1DeploymentDetailsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1DeploymentDetails)(nil)).Elem()
}

func (o GrafeasV1beta1DeploymentDetailsOutput) ToGrafeasV1beta1DeploymentDetailsOutput() GrafeasV1beta1DeploymentDetailsOutput {
	return o
}

func (o GrafeasV1beta1DeploymentDetailsOutput) ToGrafeasV1beta1DeploymentDetailsOutputWithContext(ctx context.Context) GrafeasV1beta1DeploymentDetailsOutput {
	return o
}

func (o GrafeasV1beta1DeploymentDetailsOutput) ToGrafeasV1beta1DeploymentDetailsPtrOutput() GrafeasV1beta1DeploymentDetailsPtrOutput {
	return o.ToGrafeasV1beta1DeploymentDetailsPtrOutputWithContext(context.Background())
}

func (o GrafeasV1beta1DeploymentDetailsOutput) ToGrafeasV1beta1DeploymentDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1DeploymentDetailsPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1DeploymentDetails) *GrafeasV1beta1DeploymentDetails {
		return &v
	}).(GrafeasV1beta1DeploymentDetailsPtrOutput)
}

// Deployment history for the resource.
func (o GrafeasV1beta1DeploymentDetailsOutput) Deployment() DeploymentOutput {
	return o.ApplyT(func(v GrafeasV1beta1DeploymentDetails) Deployment { return v.Deployment }).(DeploymentOutput)
}

type GrafeasV1beta1DeploymentDetailsPtrOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1DeploymentDetailsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1DeploymentDetails)(nil)).Elem()
}

func (o GrafeasV1beta1DeploymentDetailsPtrOutput) ToGrafeasV1beta1DeploymentDetailsPtrOutput() GrafeasV1beta1DeploymentDetailsPtrOutput {
	return o
}

func (o GrafeasV1beta1DeploymentDetailsPtrOutput) ToGrafeasV1beta1DeploymentDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1DeploymentDetailsPtrOutput {
	return o
}

func (o GrafeasV1beta1DeploymentDetailsPtrOutput) Elem() GrafeasV1beta1DeploymentDetailsOutput {
	return o.ApplyT(func(v *GrafeasV1beta1DeploymentDetails) GrafeasV1beta1DeploymentDetails { return *v }).(GrafeasV1beta1DeploymentDetailsOutput)
}

// Deployment history for the resource.
func (o GrafeasV1beta1DeploymentDetailsPtrOutput) Deployment() DeploymentPtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1DeploymentDetails) *Deployment {
		if v == nil {
			return nil
		}
		return &v.Deployment
	}).(DeploymentPtrOutput)
}

// Details of a deployment occurrence.
type GrafeasV1beta1DeploymentDetailsResponse struct {
	// Deployment history for the resource.
	Deployment DeploymentResponse `pulumi:"deployment"`
}

// GrafeasV1beta1DeploymentDetailsResponseInput is an input type that accepts GrafeasV1beta1DeploymentDetailsResponseArgs and GrafeasV1beta1DeploymentDetailsResponseOutput values.
// You can construct a concrete instance of `GrafeasV1beta1DeploymentDetailsResponseInput` via:
//
//          GrafeasV1beta1DeploymentDetailsResponseArgs{...}
type GrafeasV1beta1DeploymentDetailsResponseInput interface {
	pulumi.Input

	ToGrafeasV1beta1DeploymentDetailsResponseOutput() GrafeasV1beta1DeploymentDetailsResponseOutput
	ToGrafeasV1beta1DeploymentDetailsResponseOutputWithContext(context.Context) GrafeasV1beta1DeploymentDetailsResponseOutput
}

// Details of a deployment occurrence.
type GrafeasV1beta1DeploymentDetailsResponseArgs struct {
	// Deployment history for the resource.
	Deployment DeploymentResponseInput `pulumi:"deployment"`
}

func (GrafeasV1beta1DeploymentDetailsResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1DeploymentDetailsResponse)(nil)).Elem()
}

func (i GrafeasV1beta1DeploymentDetailsResponseArgs) ToGrafeasV1beta1DeploymentDetailsResponseOutput() GrafeasV1beta1DeploymentDetailsResponseOutput {
	return i.ToGrafeasV1beta1DeploymentDetailsResponseOutputWithContext(context.Background())
}

func (i GrafeasV1beta1DeploymentDetailsResponseArgs) ToGrafeasV1beta1DeploymentDetailsResponseOutputWithContext(ctx context.Context) GrafeasV1beta1DeploymentDetailsResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1DeploymentDetailsResponseOutput)
}

func (i GrafeasV1beta1DeploymentDetailsResponseArgs) ToGrafeasV1beta1DeploymentDetailsResponsePtrOutput() GrafeasV1beta1DeploymentDetailsResponsePtrOutput {
	return i.ToGrafeasV1beta1DeploymentDetailsResponsePtrOutputWithContext(context.Background())
}

func (i GrafeasV1beta1DeploymentDetailsResponseArgs) ToGrafeasV1beta1DeploymentDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1DeploymentDetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1DeploymentDetailsResponseOutput).ToGrafeasV1beta1DeploymentDetailsResponsePtrOutputWithContext(ctx)
}

// GrafeasV1beta1DeploymentDetailsResponsePtrInput is an input type that accepts GrafeasV1beta1DeploymentDetailsResponseArgs, GrafeasV1beta1DeploymentDetailsResponsePtr and GrafeasV1beta1DeploymentDetailsResponsePtrOutput values.
// You can construct a concrete instance of `GrafeasV1beta1DeploymentDetailsResponsePtrInput` via:
//
//          GrafeasV1beta1DeploymentDetailsResponseArgs{...}
//
//  or:
//
//          nil
type GrafeasV1beta1DeploymentDetailsResponsePtrInput interface {
	pulumi.Input

	ToGrafeasV1beta1DeploymentDetailsResponsePtrOutput() GrafeasV1beta1DeploymentDetailsResponsePtrOutput
	ToGrafeasV1beta1DeploymentDetailsResponsePtrOutputWithContext(context.Context) GrafeasV1beta1DeploymentDetailsResponsePtrOutput
}

type grafeasV1beta1DeploymentDetailsResponsePtrType GrafeasV1beta1DeploymentDetailsResponseArgs

func GrafeasV1beta1DeploymentDetailsResponsePtr(v *GrafeasV1beta1DeploymentDetailsResponseArgs) GrafeasV1beta1DeploymentDetailsResponsePtrInput {
	return (*grafeasV1beta1DeploymentDetailsResponsePtrType)(v)
}

func (*grafeasV1beta1DeploymentDetailsResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1DeploymentDetailsResponse)(nil)).Elem()
}

func (i *grafeasV1beta1DeploymentDetailsResponsePtrType) ToGrafeasV1beta1DeploymentDetailsResponsePtrOutput() GrafeasV1beta1DeploymentDetailsResponsePtrOutput {
	return i.ToGrafeasV1beta1DeploymentDetailsResponsePtrOutputWithContext(context.Background())
}

func (i *grafeasV1beta1DeploymentDetailsResponsePtrType) ToGrafeasV1beta1DeploymentDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1DeploymentDetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1DeploymentDetailsResponsePtrOutput)
}

// Details of a deployment occurrence.
type GrafeasV1beta1DeploymentDetailsResponseOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1DeploymentDetailsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1DeploymentDetailsResponse)(nil)).Elem()
}

func (o GrafeasV1beta1DeploymentDetailsResponseOutput) ToGrafeasV1beta1DeploymentDetailsResponseOutput() GrafeasV1beta1DeploymentDetailsResponseOutput {
	return o
}

func (o GrafeasV1beta1DeploymentDetailsResponseOutput) ToGrafeasV1beta1DeploymentDetailsResponseOutputWithContext(ctx context.Context) GrafeasV1beta1DeploymentDetailsResponseOutput {
	return o
}

func (o GrafeasV1beta1DeploymentDetailsResponseOutput) ToGrafeasV1beta1DeploymentDetailsResponsePtrOutput() GrafeasV1beta1DeploymentDetailsResponsePtrOutput {
	return o.ToGrafeasV1beta1DeploymentDetailsResponsePtrOutputWithContext(context.Background())
}

func (o GrafeasV1beta1DeploymentDetailsResponseOutput) ToGrafeasV1beta1DeploymentDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1DeploymentDetailsResponsePtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1DeploymentDetailsResponse) *GrafeasV1beta1DeploymentDetailsResponse {
		return &v
	}).(GrafeasV1beta1DeploymentDetailsResponsePtrOutput)
}

// Deployment history for the resource.
func (o GrafeasV1beta1DeploymentDetailsResponseOutput) Deployment() DeploymentResponseOutput {
	return o.ApplyT(func(v GrafeasV1beta1DeploymentDetailsResponse) DeploymentResponse { return v.Deployment }).(DeploymentResponseOutput)
}

type GrafeasV1beta1DeploymentDetailsResponsePtrOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1DeploymentDetailsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1DeploymentDetailsResponse)(nil)).Elem()
}

func (o GrafeasV1beta1DeploymentDetailsResponsePtrOutput) ToGrafeasV1beta1DeploymentDetailsResponsePtrOutput() GrafeasV1beta1DeploymentDetailsResponsePtrOutput {
	return o
}

func (o GrafeasV1beta1DeploymentDetailsResponsePtrOutput) ToGrafeasV1beta1DeploymentDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1DeploymentDetailsResponsePtrOutput {
	return o
}

func (o GrafeasV1beta1DeploymentDetailsResponsePtrOutput) Elem() GrafeasV1beta1DeploymentDetailsResponseOutput {
	return o.ApplyT(func(v *GrafeasV1beta1DeploymentDetailsResponse) GrafeasV1beta1DeploymentDetailsResponse { return *v }).(GrafeasV1beta1DeploymentDetailsResponseOutput)
}

// Deployment history for the resource.
func (o GrafeasV1beta1DeploymentDetailsResponsePtrOutput) Deployment() DeploymentResponsePtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1DeploymentDetailsResponse) *DeploymentResponse {
		if v == nil {
			return nil
		}
		return &v.Deployment
	}).(DeploymentResponsePtrOutput)
}

// Details of a discovery occurrence.
type GrafeasV1beta1DiscoveryDetails struct {
	// Analysis status for the discovered resource.
	Discovered Discovered `pulumi:"discovered"`
}

// GrafeasV1beta1DiscoveryDetailsInput is an input type that accepts GrafeasV1beta1DiscoveryDetailsArgs and GrafeasV1beta1DiscoveryDetailsOutput values.
// You can construct a concrete instance of `GrafeasV1beta1DiscoveryDetailsInput` via:
//
//          GrafeasV1beta1DiscoveryDetailsArgs{...}
type GrafeasV1beta1DiscoveryDetailsInput interface {
	pulumi.Input

	ToGrafeasV1beta1DiscoveryDetailsOutput() GrafeasV1beta1DiscoveryDetailsOutput
	ToGrafeasV1beta1DiscoveryDetailsOutputWithContext(context.Context) GrafeasV1beta1DiscoveryDetailsOutput
}

// Details of a discovery occurrence.
type GrafeasV1beta1DiscoveryDetailsArgs struct {
	// Analysis status for the discovered resource.
	Discovered DiscoveredInput `pulumi:"discovered"`
}

func (GrafeasV1beta1DiscoveryDetailsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1DiscoveryDetails)(nil)).Elem()
}

func (i GrafeasV1beta1DiscoveryDetailsArgs) ToGrafeasV1beta1DiscoveryDetailsOutput() GrafeasV1beta1DiscoveryDetailsOutput {
	return i.ToGrafeasV1beta1DiscoveryDetailsOutputWithContext(context.Background())
}

func (i GrafeasV1beta1DiscoveryDetailsArgs) ToGrafeasV1beta1DiscoveryDetailsOutputWithContext(ctx context.Context) GrafeasV1beta1DiscoveryDetailsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1DiscoveryDetailsOutput)
}

func (i GrafeasV1beta1DiscoveryDetailsArgs) ToGrafeasV1beta1DiscoveryDetailsPtrOutput() GrafeasV1beta1DiscoveryDetailsPtrOutput {
	return i.ToGrafeasV1beta1DiscoveryDetailsPtrOutputWithContext(context.Background())
}

func (i GrafeasV1beta1DiscoveryDetailsArgs) ToGrafeasV1beta1DiscoveryDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1DiscoveryDetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1DiscoveryDetailsOutput).ToGrafeasV1beta1DiscoveryDetailsPtrOutputWithContext(ctx)
}

// GrafeasV1beta1DiscoveryDetailsPtrInput is an input type that accepts GrafeasV1beta1DiscoveryDetailsArgs, GrafeasV1beta1DiscoveryDetailsPtr and GrafeasV1beta1DiscoveryDetailsPtrOutput values.
// You can construct a concrete instance of `GrafeasV1beta1DiscoveryDetailsPtrInput` via:
//
//          GrafeasV1beta1DiscoveryDetailsArgs{...}
//
//  or:
//
//          nil
type GrafeasV1beta1DiscoveryDetailsPtrInput interface {
	pulumi.Input

	ToGrafeasV1beta1DiscoveryDetailsPtrOutput() GrafeasV1beta1DiscoveryDetailsPtrOutput
	ToGrafeasV1beta1DiscoveryDetailsPtrOutputWithContext(context.Context) GrafeasV1beta1DiscoveryDetailsPtrOutput
}

type grafeasV1beta1DiscoveryDetailsPtrType GrafeasV1beta1DiscoveryDetailsArgs

func GrafeasV1beta1DiscoveryDetailsPtr(v *GrafeasV1beta1DiscoveryDetailsArgs) GrafeasV1beta1DiscoveryDetailsPtrInput {
	return (*grafeasV1beta1DiscoveryDetailsPtrType)(v)
}

func (*grafeasV1beta1DiscoveryDetailsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1DiscoveryDetails)(nil)).Elem()
}

func (i *grafeasV1beta1DiscoveryDetailsPtrType) ToGrafeasV1beta1DiscoveryDetailsPtrOutput() GrafeasV1beta1DiscoveryDetailsPtrOutput {
	return i.ToGrafeasV1beta1DiscoveryDetailsPtrOutputWithContext(context.Background())
}

func (i *grafeasV1beta1DiscoveryDetailsPtrType) ToGrafeasV1beta1DiscoveryDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1DiscoveryDetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1DiscoveryDetailsPtrOutput)
}

// Details of a discovery occurrence.
type GrafeasV1beta1DiscoveryDetailsOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1DiscoveryDetailsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1DiscoveryDetails)(nil)).Elem()
}

func (o GrafeasV1beta1DiscoveryDetailsOutput) ToGrafeasV1beta1DiscoveryDetailsOutput() GrafeasV1beta1DiscoveryDetailsOutput {
	return o
}

func (o GrafeasV1beta1DiscoveryDetailsOutput) ToGrafeasV1beta1DiscoveryDetailsOutputWithContext(ctx context.Context) GrafeasV1beta1DiscoveryDetailsOutput {
	return o
}

func (o GrafeasV1beta1DiscoveryDetailsOutput) ToGrafeasV1beta1DiscoveryDetailsPtrOutput() GrafeasV1beta1DiscoveryDetailsPtrOutput {
	return o.ToGrafeasV1beta1DiscoveryDetailsPtrOutputWithContext(context.Background())
}

func (o GrafeasV1beta1DiscoveryDetailsOutput) ToGrafeasV1beta1DiscoveryDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1DiscoveryDetailsPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1DiscoveryDetails) *GrafeasV1beta1DiscoveryDetails {
		return &v
	}).(GrafeasV1beta1DiscoveryDetailsPtrOutput)
}

// Analysis status for the discovered resource.
func (o GrafeasV1beta1DiscoveryDetailsOutput) Discovered() DiscoveredOutput {
	return o.ApplyT(func(v GrafeasV1beta1DiscoveryDetails) Discovered { return v.Discovered }).(DiscoveredOutput)
}

type GrafeasV1beta1DiscoveryDetailsPtrOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1DiscoveryDetailsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1DiscoveryDetails)(nil)).Elem()
}

func (o GrafeasV1beta1DiscoveryDetailsPtrOutput) ToGrafeasV1beta1DiscoveryDetailsPtrOutput() GrafeasV1beta1DiscoveryDetailsPtrOutput {
	return o
}

func (o GrafeasV1beta1DiscoveryDetailsPtrOutput) ToGrafeasV1beta1DiscoveryDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1DiscoveryDetailsPtrOutput {
	return o
}

func (o GrafeasV1beta1DiscoveryDetailsPtrOutput) Elem() GrafeasV1beta1DiscoveryDetailsOutput {
	return o.ApplyT(func(v *GrafeasV1beta1DiscoveryDetails) GrafeasV1beta1DiscoveryDetails { return *v }).(GrafeasV1beta1DiscoveryDetailsOutput)
}

// Analysis status for the discovered resource.
func (o GrafeasV1beta1DiscoveryDetailsPtrOutput) Discovered() DiscoveredPtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1DiscoveryDetails) *Discovered {
		if v == nil {
			return nil
		}
		return &v.Discovered
	}).(DiscoveredPtrOutput)
}

// Details of a discovery occurrence.
type GrafeasV1beta1DiscoveryDetailsResponse struct {
	// Analysis status for the discovered resource.
	Discovered DiscoveredResponse `pulumi:"discovered"`
}

// GrafeasV1beta1DiscoveryDetailsResponseInput is an input type that accepts GrafeasV1beta1DiscoveryDetailsResponseArgs and GrafeasV1beta1DiscoveryDetailsResponseOutput values.
// You can construct a concrete instance of `GrafeasV1beta1DiscoveryDetailsResponseInput` via:
//
//          GrafeasV1beta1DiscoveryDetailsResponseArgs{...}
type GrafeasV1beta1DiscoveryDetailsResponseInput interface {
	pulumi.Input

	ToGrafeasV1beta1DiscoveryDetailsResponseOutput() GrafeasV1beta1DiscoveryDetailsResponseOutput
	ToGrafeasV1beta1DiscoveryDetailsResponseOutputWithContext(context.Context) GrafeasV1beta1DiscoveryDetailsResponseOutput
}

// Details of a discovery occurrence.
type GrafeasV1beta1DiscoveryDetailsResponseArgs struct {
	// Analysis status for the discovered resource.
	Discovered DiscoveredResponseInput `pulumi:"discovered"`
}

func (GrafeasV1beta1DiscoveryDetailsResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1DiscoveryDetailsResponse)(nil)).Elem()
}

func (i GrafeasV1beta1DiscoveryDetailsResponseArgs) ToGrafeasV1beta1DiscoveryDetailsResponseOutput() GrafeasV1beta1DiscoveryDetailsResponseOutput {
	return i.ToGrafeasV1beta1DiscoveryDetailsResponseOutputWithContext(context.Background())
}

func (i GrafeasV1beta1DiscoveryDetailsResponseArgs) ToGrafeasV1beta1DiscoveryDetailsResponseOutputWithContext(ctx context.Context) GrafeasV1beta1DiscoveryDetailsResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1DiscoveryDetailsResponseOutput)
}

func (i GrafeasV1beta1DiscoveryDetailsResponseArgs) ToGrafeasV1beta1DiscoveryDetailsResponsePtrOutput() GrafeasV1beta1DiscoveryDetailsResponsePtrOutput {
	return i.ToGrafeasV1beta1DiscoveryDetailsResponsePtrOutputWithContext(context.Background())
}

func (i GrafeasV1beta1DiscoveryDetailsResponseArgs) ToGrafeasV1beta1DiscoveryDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1DiscoveryDetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1DiscoveryDetailsResponseOutput).ToGrafeasV1beta1DiscoveryDetailsResponsePtrOutputWithContext(ctx)
}

// GrafeasV1beta1DiscoveryDetailsResponsePtrInput is an input type that accepts GrafeasV1beta1DiscoveryDetailsResponseArgs, GrafeasV1beta1DiscoveryDetailsResponsePtr and GrafeasV1beta1DiscoveryDetailsResponsePtrOutput values.
// You can construct a concrete instance of `GrafeasV1beta1DiscoveryDetailsResponsePtrInput` via:
//
//          GrafeasV1beta1DiscoveryDetailsResponseArgs{...}
//
//  or:
//
//          nil
type GrafeasV1beta1DiscoveryDetailsResponsePtrInput interface {
	pulumi.Input

	ToGrafeasV1beta1DiscoveryDetailsResponsePtrOutput() GrafeasV1beta1DiscoveryDetailsResponsePtrOutput
	ToGrafeasV1beta1DiscoveryDetailsResponsePtrOutputWithContext(context.Context) GrafeasV1beta1DiscoveryDetailsResponsePtrOutput
}

type grafeasV1beta1DiscoveryDetailsResponsePtrType GrafeasV1beta1DiscoveryDetailsResponseArgs

func GrafeasV1beta1DiscoveryDetailsResponsePtr(v *GrafeasV1beta1DiscoveryDetailsResponseArgs) GrafeasV1beta1DiscoveryDetailsResponsePtrInput {
	return (*grafeasV1beta1DiscoveryDetailsResponsePtrType)(v)
}

func (*grafeasV1beta1DiscoveryDetailsResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1DiscoveryDetailsResponse)(nil)).Elem()
}

func (i *grafeasV1beta1DiscoveryDetailsResponsePtrType) ToGrafeasV1beta1DiscoveryDetailsResponsePtrOutput() GrafeasV1beta1DiscoveryDetailsResponsePtrOutput {
	return i.ToGrafeasV1beta1DiscoveryDetailsResponsePtrOutputWithContext(context.Background())
}

func (i *grafeasV1beta1DiscoveryDetailsResponsePtrType) ToGrafeasV1beta1DiscoveryDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1DiscoveryDetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1DiscoveryDetailsResponsePtrOutput)
}

// Details of a discovery occurrence.
type GrafeasV1beta1DiscoveryDetailsResponseOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1DiscoveryDetailsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1DiscoveryDetailsResponse)(nil)).Elem()
}

func (o GrafeasV1beta1DiscoveryDetailsResponseOutput) ToGrafeasV1beta1DiscoveryDetailsResponseOutput() GrafeasV1beta1DiscoveryDetailsResponseOutput {
	return o
}

func (o GrafeasV1beta1DiscoveryDetailsResponseOutput) ToGrafeasV1beta1DiscoveryDetailsResponseOutputWithContext(ctx context.Context) GrafeasV1beta1DiscoveryDetailsResponseOutput {
	return o
}

func (o GrafeasV1beta1DiscoveryDetailsResponseOutput) ToGrafeasV1beta1DiscoveryDetailsResponsePtrOutput() GrafeasV1beta1DiscoveryDetailsResponsePtrOutput {
	return o.ToGrafeasV1beta1DiscoveryDetailsResponsePtrOutputWithContext(context.Background())
}

func (o GrafeasV1beta1DiscoveryDetailsResponseOutput) ToGrafeasV1beta1DiscoveryDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1DiscoveryDetailsResponsePtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1DiscoveryDetailsResponse) *GrafeasV1beta1DiscoveryDetailsResponse {
		return &v
	}).(GrafeasV1beta1DiscoveryDetailsResponsePtrOutput)
}

// Analysis status for the discovered resource.
func (o GrafeasV1beta1DiscoveryDetailsResponseOutput) Discovered() DiscoveredResponseOutput {
	return o.ApplyT(func(v GrafeasV1beta1DiscoveryDetailsResponse) DiscoveredResponse { return v.Discovered }).(DiscoveredResponseOutput)
}

type GrafeasV1beta1DiscoveryDetailsResponsePtrOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1DiscoveryDetailsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1DiscoveryDetailsResponse)(nil)).Elem()
}

func (o GrafeasV1beta1DiscoveryDetailsResponsePtrOutput) ToGrafeasV1beta1DiscoveryDetailsResponsePtrOutput() GrafeasV1beta1DiscoveryDetailsResponsePtrOutput {
	return o
}

func (o GrafeasV1beta1DiscoveryDetailsResponsePtrOutput) ToGrafeasV1beta1DiscoveryDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1DiscoveryDetailsResponsePtrOutput {
	return o
}

func (o GrafeasV1beta1DiscoveryDetailsResponsePtrOutput) Elem() GrafeasV1beta1DiscoveryDetailsResponseOutput {
	return o.ApplyT(func(v *GrafeasV1beta1DiscoveryDetailsResponse) GrafeasV1beta1DiscoveryDetailsResponse { return *v }).(GrafeasV1beta1DiscoveryDetailsResponseOutput)
}

// Analysis status for the discovered resource.
func (o GrafeasV1beta1DiscoveryDetailsResponsePtrOutput) Discovered() DiscoveredResponsePtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1DiscoveryDetailsResponse) *DiscoveredResponse {
		if v == nil {
			return nil
		}
		return &v.Discovered
	}).(DiscoveredResponsePtrOutput)
}

// Details of an image occurrence.
type GrafeasV1beta1ImageDetails struct {
	// Immutable. The child image derived from the base image.
	DerivedImage Derived `pulumi:"derivedImage"`
}

// GrafeasV1beta1ImageDetailsInput is an input type that accepts GrafeasV1beta1ImageDetailsArgs and GrafeasV1beta1ImageDetailsOutput values.
// You can construct a concrete instance of `GrafeasV1beta1ImageDetailsInput` via:
//
//          GrafeasV1beta1ImageDetailsArgs{...}
type GrafeasV1beta1ImageDetailsInput interface {
	pulumi.Input

	ToGrafeasV1beta1ImageDetailsOutput() GrafeasV1beta1ImageDetailsOutput
	ToGrafeasV1beta1ImageDetailsOutputWithContext(context.Context) GrafeasV1beta1ImageDetailsOutput
}

// Details of an image occurrence.
type GrafeasV1beta1ImageDetailsArgs struct {
	// Immutable. The child image derived from the base image.
	DerivedImage DerivedInput `pulumi:"derivedImage"`
}

func (GrafeasV1beta1ImageDetailsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1ImageDetails)(nil)).Elem()
}

func (i GrafeasV1beta1ImageDetailsArgs) ToGrafeasV1beta1ImageDetailsOutput() GrafeasV1beta1ImageDetailsOutput {
	return i.ToGrafeasV1beta1ImageDetailsOutputWithContext(context.Background())
}

func (i GrafeasV1beta1ImageDetailsArgs) ToGrafeasV1beta1ImageDetailsOutputWithContext(ctx context.Context) GrafeasV1beta1ImageDetailsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1ImageDetailsOutput)
}

func (i GrafeasV1beta1ImageDetailsArgs) ToGrafeasV1beta1ImageDetailsPtrOutput() GrafeasV1beta1ImageDetailsPtrOutput {
	return i.ToGrafeasV1beta1ImageDetailsPtrOutputWithContext(context.Background())
}

func (i GrafeasV1beta1ImageDetailsArgs) ToGrafeasV1beta1ImageDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1ImageDetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1ImageDetailsOutput).ToGrafeasV1beta1ImageDetailsPtrOutputWithContext(ctx)
}

// GrafeasV1beta1ImageDetailsPtrInput is an input type that accepts GrafeasV1beta1ImageDetailsArgs, GrafeasV1beta1ImageDetailsPtr and GrafeasV1beta1ImageDetailsPtrOutput values.
// You can construct a concrete instance of `GrafeasV1beta1ImageDetailsPtrInput` via:
//
//          GrafeasV1beta1ImageDetailsArgs{...}
//
//  or:
//
//          nil
type GrafeasV1beta1ImageDetailsPtrInput interface {
	pulumi.Input

	ToGrafeasV1beta1ImageDetailsPtrOutput() GrafeasV1beta1ImageDetailsPtrOutput
	ToGrafeasV1beta1ImageDetailsPtrOutputWithContext(context.Context) GrafeasV1beta1ImageDetailsPtrOutput
}

type grafeasV1beta1ImageDetailsPtrType GrafeasV1beta1ImageDetailsArgs

func GrafeasV1beta1ImageDetailsPtr(v *GrafeasV1beta1ImageDetailsArgs) GrafeasV1beta1ImageDetailsPtrInput {
	return (*grafeasV1beta1ImageDetailsPtrType)(v)
}

func (*grafeasV1beta1ImageDetailsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1ImageDetails)(nil)).Elem()
}

func (i *grafeasV1beta1ImageDetailsPtrType) ToGrafeasV1beta1ImageDetailsPtrOutput() GrafeasV1beta1ImageDetailsPtrOutput {
	return i.ToGrafeasV1beta1ImageDetailsPtrOutputWithContext(context.Background())
}

func (i *grafeasV1beta1ImageDetailsPtrType) ToGrafeasV1beta1ImageDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1ImageDetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1ImageDetailsPtrOutput)
}

// Details of an image occurrence.
type GrafeasV1beta1ImageDetailsOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1ImageDetailsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1ImageDetails)(nil)).Elem()
}

func (o GrafeasV1beta1ImageDetailsOutput) ToGrafeasV1beta1ImageDetailsOutput() GrafeasV1beta1ImageDetailsOutput {
	return o
}

func (o GrafeasV1beta1ImageDetailsOutput) ToGrafeasV1beta1ImageDetailsOutputWithContext(ctx context.Context) GrafeasV1beta1ImageDetailsOutput {
	return o
}

func (o GrafeasV1beta1ImageDetailsOutput) ToGrafeasV1beta1ImageDetailsPtrOutput() GrafeasV1beta1ImageDetailsPtrOutput {
	return o.ToGrafeasV1beta1ImageDetailsPtrOutputWithContext(context.Background())
}

func (o GrafeasV1beta1ImageDetailsOutput) ToGrafeasV1beta1ImageDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1ImageDetailsPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1ImageDetails) *GrafeasV1beta1ImageDetails {
		return &v
	}).(GrafeasV1beta1ImageDetailsPtrOutput)
}

// Immutable. The child image derived from the base image.
func (o GrafeasV1beta1ImageDetailsOutput) DerivedImage() DerivedOutput {
	return o.ApplyT(func(v GrafeasV1beta1ImageDetails) Derived { return v.DerivedImage }).(DerivedOutput)
}

type GrafeasV1beta1ImageDetailsPtrOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1ImageDetailsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1ImageDetails)(nil)).Elem()
}

func (o GrafeasV1beta1ImageDetailsPtrOutput) ToGrafeasV1beta1ImageDetailsPtrOutput() GrafeasV1beta1ImageDetailsPtrOutput {
	return o
}

func (o GrafeasV1beta1ImageDetailsPtrOutput) ToGrafeasV1beta1ImageDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1ImageDetailsPtrOutput {
	return o
}

func (o GrafeasV1beta1ImageDetailsPtrOutput) Elem() GrafeasV1beta1ImageDetailsOutput {
	return o.ApplyT(func(v *GrafeasV1beta1ImageDetails) GrafeasV1beta1ImageDetails { return *v }).(GrafeasV1beta1ImageDetailsOutput)
}

// Immutable. The child image derived from the base image.
func (o GrafeasV1beta1ImageDetailsPtrOutput) DerivedImage() DerivedPtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1ImageDetails) *Derived {
		if v == nil {
			return nil
		}
		return &v.DerivedImage
	}).(DerivedPtrOutput)
}

// Details of an image occurrence.
type GrafeasV1beta1ImageDetailsResponse struct {
	// Immutable. The child image derived from the base image.
	DerivedImage DerivedResponse `pulumi:"derivedImage"`
}

// GrafeasV1beta1ImageDetailsResponseInput is an input type that accepts GrafeasV1beta1ImageDetailsResponseArgs and GrafeasV1beta1ImageDetailsResponseOutput values.
// You can construct a concrete instance of `GrafeasV1beta1ImageDetailsResponseInput` via:
//
//          GrafeasV1beta1ImageDetailsResponseArgs{...}
type GrafeasV1beta1ImageDetailsResponseInput interface {
	pulumi.Input

	ToGrafeasV1beta1ImageDetailsResponseOutput() GrafeasV1beta1ImageDetailsResponseOutput
	ToGrafeasV1beta1ImageDetailsResponseOutputWithContext(context.Context) GrafeasV1beta1ImageDetailsResponseOutput
}

// Details of an image occurrence.
type GrafeasV1beta1ImageDetailsResponseArgs struct {
	// Immutable. The child image derived from the base image.
	DerivedImage DerivedResponseInput `pulumi:"derivedImage"`
}

func (GrafeasV1beta1ImageDetailsResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1ImageDetailsResponse)(nil)).Elem()
}

func (i GrafeasV1beta1ImageDetailsResponseArgs) ToGrafeasV1beta1ImageDetailsResponseOutput() GrafeasV1beta1ImageDetailsResponseOutput {
	return i.ToGrafeasV1beta1ImageDetailsResponseOutputWithContext(context.Background())
}

func (i GrafeasV1beta1ImageDetailsResponseArgs) ToGrafeasV1beta1ImageDetailsResponseOutputWithContext(ctx context.Context) GrafeasV1beta1ImageDetailsResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1ImageDetailsResponseOutput)
}

func (i GrafeasV1beta1ImageDetailsResponseArgs) ToGrafeasV1beta1ImageDetailsResponsePtrOutput() GrafeasV1beta1ImageDetailsResponsePtrOutput {
	return i.ToGrafeasV1beta1ImageDetailsResponsePtrOutputWithContext(context.Background())
}

func (i GrafeasV1beta1ImageDetailsResponseArgs) ToGrafeasV1beta1ImageDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1ImageDetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1ImageDetailsResponseOutput).ToGrafeasV1beta1ImageDetailsResponsePtrOutputWithContext(ctx)
}

// GrafeasV1beta1ImageDetailsResponsePtrInput is an input type that accepts GrafeasV1beta1ImageDetailsResponseArgs, GrafeasV1beta1ImageDetailsResponsePtr and GrafeasV1beta1ImageDetailsResponsePtrOutput values.
// You can construct a concrete instance of `GrafeasV1beta1ImageDetailsResponsePtrInput` via:
//
//          GrafeasV1beta1ImageDetailsResponseArgs{...}
//
//  or:
//
//          nil
type GrafeasV1beta1ImageDetailsResponsePtrInput interface {
	pulumi.Input

	ToGrafeasV1beta1ImageDetailsResponsePtrOutput() GrafeasV1beta1ImageDetailsResponsePtrOutput
	ToGrafeasV1beta1ImageDetailsResponsePtrOutputWithContext(context.Context) GrafeasV1beta1ImageDetailsResponsePtrOutput
}

type grafeasV1beta1ImageDetailsResponsePtrType GrafeasV1beta1ImageDetailsResponseArgs

func GrafeasV1beta1ImageDetailsResponsePtr(v *GrafeasV1beta1ImageDetailsResponseArgs) GrafeasV1beta1ImageDetailsResponsePtrInput {
	return (*grafeasV1beta1ImageDetailsResponsePtrType)(v)
}

func (*grafeasV1beta1ImageDetailsResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1ImageDetailsResponse)(nil)).Elem()
}

func (i *grafeasV1beta1ImageDetailsResponsePtrType) ToGrafeasV1beta1ImageDetailsResponsePtrOutput() GrafeasV1beta1ImageDetailsResponsePtrOutput {
	return i.ToGrafeasV1beta1ImageDetailsResponsePtrOutputWithContext(context.Background())
}

func (i *grafeasV1beta1ImageDetailsResponsePtrType) ToGrafeasV1beta1ImageDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1ImageDetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1ImageDetailsResponsePtrOutput)
}

// Details of an image occurrence.
type GrafeasV1beta1ImageDetailsResponseOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1ImageDetailsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1ImageDetailsResponse)(nil)).Elem()
}

func (o GrafeasV1beta1ImageDetailsResponseOutput) ToGrafeasV1beta1ImageDetailsResponseOutput() GrafeasV1beta1ImageDetailsResponseOutput {
	return o
}

func (o GrafeasV1beta1ImageDetailsResponseOutput) ToGrafeasV1beta1ImageDetailsResponseOutputWithContext(ctx context.Context) GrafeasV1beta1ImageDetailsResponseOutput {
	return o
}

func (o GrafeasV1beta1ImageDetailsResponseOutput) ToGrafeasV1beta1ImageDetailsResponsePtrOutput() GrafeasV1beta1ImageDetailsResponsePtrOutput {
	return o.ToGrafeasV1beta1ImageDetailsResponsePtrOutputWithContext(context.Background())
}

func (o GrafeasV1beta1ImageDetailsResponseOutput) ToGrafeasV1beta1ImageDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1ImageDetailsResponsePtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1ImageDetailsResponse) *GrafeasV1beta1ImageDetailsResponse {
		return &v
	}).(GrafeasV1beta1ImageDetailsResponsePtrOutput)
}

// Immutable. The child image derived from the base image.
func (o GrafeasV1beta1ImageDetailsResponseOutput) DerivedImage() DerivedResponseOutput {
	return o.ApplyT(func(v GrafeasV1beta1ImageDetailsResponse) DerivedResponse { return v.DerivedImage }).(DerivedResponseOutput)
}

type GrafeasV1beta1ImageDetailsResponsePtrOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1ImageDetailsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1ImageDetailsResponse)(nil)).Elem()
}

func (o GrafeasV1beta1ImageDetailsResponsePtrOutput) ToGrafeasV1beta1ImageDetailsResponsePtrOutput() GrafeasV1beta1ImageDetailsResponsePtrOutput {
	return o
}

func (o GrafeasV1beta1ImageDetailsResponsePtrOutput) ToGrafeasV1beta1ImageDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1ImageDetailsResponsePtrOutput {
	return o
}

func (o GrafeasV1beta1ImageDetailsResponsePtrOutput) Elem() GrafeasV1beta1ImageDetailsResponseOutput {
	return o.ApplyT(func(v *GrafeasV1beta1ImageDetailsResponse) GrafeasV1beta1ImageDetailsResponse { return *v }).(GrafeasV1beta1ImageDetailsResponseOutput)
}

// Immutable. The child image derived from the base image.
func (o GrafeasV1beta1ImageDetailsResponsePtrOutput) DerivedImage() DerivedResponsePtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1ImageDetailsResponse) *DerivedResponse {
		if v == nil {
			return nil
		}
		return &v.DerivedImage
	}).(DerivedResponsePtrOutput)
}

type GrafeasV1beta1IntotoArtifact struct {
	Hashes      *ArtifactHashes `pulumi:"hashes"`
	ResourceUri *string         `pulumi:"resourceUri"`
}

// GrafeasV1beta1IntotoArtifactInput is an input type that accepts GrafeasV1beta1IntotoArtifactArgs and GrafeasV1beta1IntotoArtifactOutput values.
// You can construct a concrete instance of `GrafeasV1beta1IntotoArtifactInput` via:
//
//          GrafeasV1beta1IntotoArtifactArgs{...}
type GrafeasV1beta1IntotoArtifactInput interface {
	pulumi.Input

	ToGrafeasV1beta1IntotoArtifactOutput() GrafeasV1beta1IntotoArtifactOutput
	ToGrafeasV1beta1IntotoArtifactOutputWithContext(context.Context) GrafeasV1beta1IntotoArtifactOutput
}

type GrafeasV1beta1IntotoArtifactArgs struct {
	Hashes      ArtifactHashesPtrInput `pulumi:"hashes"`
	ResourceUri pulumi.StringPtrInput  `pulumi:"resourceUri"`
}

func (GrafeasV1beta1IntotoArtifactArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1IntotoArtifact)(nil)).Elem()
}

func (i GrafeasV1beta1IntotoArtifactArgs) ToGrafeasV1beta1IntotoArtifactOutput() GrafeasV1beta1IntotoArtifactOutput {
	return i.ToGrafeasV1beta1IntotoArtifactOutputWithContext(context.Background())
}

func (i GrafeasV1beta1IntotoArtifactArgs) ToGrafeasV1beta1IntotoArtifactOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoArtifactOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1IntotoArtifactOutput)
}

// GrafeasV1beta1IntotoArtifactArrayInput is an input type that accepts GrafeasV1beta1IntotoArtifactArray and GrafeasV1beta1IntotoArtifactArrayOutput values.
// You can construct a concrete instance of `GrafeasV1beta1IntotoArtifactArrayInput` via:
//
//          GrafeasV1beta1IntotoArtifactArray{ GrafeasV1beta1IntotoArtifactArgs{...} }
type GrafeasV1beta1IntotoArtifactArrayInput interface {
	pulumi.Input

	ToGrafeasV1beta1IntotoArtifactArrayOutput() GrafeasV1beta1IntotoArtifactArrayOutput
	ToGrafeasV1beta1IntotoArtifactArrayOutputWithContext(context.Context) GrafeasV1beta1IntotoArtifactArrayOutput
}

type GrafeasV1beta1IntotoArtifactArray []GrafeasV1beta1IntotoArtifactInput

func (GrafeasV1beta1IntotoArtifactArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GrafeasV1beta1IntotoArtifact)(nil)).Elem()
}

func (i GrafeasV1beta1IntotoArtifactArray) ToGrafeasV1beta1IntotoArtifactArrayOutput() GrafeasV1beta1IntotoArtifactArrayOutput {
	return i.ToGrafeasV1beta1IntotoArtifactArrayOutputWithContext(context.Background())
}

func (i GrafeasV1beta1IntotoArtifactArray) ToGrafeasV1beta1IntotoArtifactArrayOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoArtifactArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1IntotoArtifactArrayOutput)
}

type GrafeasV1beta1IntotoArtifactOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1IntotoArtifactOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1IntotoArtifact)(nil)).Elem()
}

func (o GrafeasV1beta1IntotoArtifactOutput) ToGrafeasV1beta1IntotoArtifactOutput() GrafeasV1beta1IntotoArtifactOutput {
	return o
}

func (o GrafeasV1beta1IntotoArtifactOutput) ToGrafeasV1beta1IntotoArtifactOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoArtifactOutput {
	return o
}

func (o GrafeasV1beta1IntotoArtifactOutput) Hashes() ArtifactHashesPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1IntotoArtifact) *ArtifactHashes { return v.Hashes }).(ArtifactHashesPtrOutput)
}

func (o GrafeasV1beta1IntotoArtifactOutput) ResourceUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1IntotoArtifact) *string { return v.ResourceUri }).(pulumi.StringPtrOutput)
}

type GrafeasV1beta1IntotoArtifactArrayOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1IntotoArtifactArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GrafeasV1beta1IntotoArtifact)(nil)).Elem()
}

func (o GrafeasV1beta1IntotoArtifactArrayOutput) ToGrafeasV1beta1IntotoArtifactArrayOutput() GrafeasV1beta1IntotoArtifactArrayOutput {
	return o
}

func (o GrafeasV1beta1IntotoArtifactArrayOutput) ToGrafeasV1beta1IntotoArtifactArrayOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoArtifactArrayOutput {
	return o
}

func (o GrafeasV1beta1IntotoArtifactArrayOutput) Index(i pulumi.IntInput) GrafeasV1beta1IntotoArtifactOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GrafeasV1beta1IntotoArtifact {
		return vs[0].([]GrafeasV1beta1IntotoArtifact)[vs[1].(int)]
	}).(GrafeasV1beta1IntotoArtifactOutput)
}

type GrafeasV1beta1IntotoArtifactResponse struct {
	Hashes      ArtifactHashesResponse `pulumi:"hashes"`
	ResourceUri string                 `pulumi:"resourceUri"`
}

// GrafeasV1beta1IntotoArtifactResponseInput is an input type that accepts GrafeasV1beta1IntotoArtifactResponseArgs and GrafeasV1beta1IntotoArtifactResponseOutput values.
// You can construct a concrete instance of `GrafeasV1beta1IntotoArtifactResponseInput` via:
//
//          GrafeasV1beta1IntotoArtifactResponseArgs{...}
type GrafeasV1beta1IntotoArtifactResponseInput interface {
	pulumi.Input

	ToGrafeasV1beta1IntotoArtifactResponseOutput() GrafeasV1beta1IntotoArtifactResponseOutput
	ToGrafeasV1beta1IntotoArtifactResponseOutputWithContext(context.Context) GrafeasV1beta1IntotoArtifactResponseOutput
}

type GrafeasV1beta1IntotoArtifactResponseArgs struct {
	Hashes      ArtifactHashesResponseInput `pulumi:"hashes"`
	ResourceUri pulumi.StringInput          `pulumi:"resourceUri"`
}

func (GrafeasV1beta1IntotoArtifactResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1IntotoArtifactResponse)(nil)).Elem()
}

func (i GrafeasV1beta1IntotoArtifactResponseArgs) ToGrafeasV1beta1IntotoArtifactResponseOutput() GrafeasV1beta1IntotoArtifactResponseOutput {
	return i.ToGrafeasV1beta1IntotoArtifactResponseOutputWithContext(context.Background())
}

func (i GrafeasV1beta1IntotoArtifactResponseArgs) ToGrafeasV1beta1IntotoArtifactResponseOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoArtifactResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1IntotoArtifactResponseOutput)
}

// GrafeasV1beta1IntotoArtifactResponseArrayInput is an input type that accepts GrafeasV1beta1IntotoArtifactResponseArray and GrafeasV1beta1IntotoArtifactResponseArrayOutput values.
// You can construct a concrete instance of `GrafeasV1beta1IntotoArtifactResponseArrayInput` via:
//
//          GrafeasV1beta1IntotoArtifactResponseArray{ GrafeasV1beta1IntotoArtifactResponseArgs{...} }
type GrafeasV1beta1IntotoArtifactResponseArrayInput interface {
	pulumi.Input

	ToGrafeasV1beta1IntotoArtifactResponseArrayOutput() GrafeasV1beta1IntotoArtifactResponseArrayOutput
	ToGrafeasV1beta1IntotoArtifactResponseArrayOutputWithContext(context.Context) GrafeasV1beta1IntotoArtifactResponseArrayOutput
}

type GrafeasV1beta1IntotoArtifactResponseArray []GrafeasV1beta1IntotoArtifactResponseInput

func (GrafeasV1beta1IntotoArtifactResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GrafeasV1beta1IntotoArtifactResponse)(nil)).Elem()
}

func (i GrafeasV1beta1IntotoArtifactResponseArray) ToGrafeasV1beta1IntotoArtifactResponseArrayOutput() GrafeasV1beta1IntotoArtifactResponseArrayOutput {
	return i.ToGrafeasV1beta1IntotoArtifactResponseArrayOutputWithContext(context.Background())
}

func (i GrafeasV1beta1IntotoArtifactResponseArray) ToGrafeasV1beta1IntotoArtifactResponseArrayOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoArtifactResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1IntotoArtifactResponseArrayOutput)
}

type GrafeasV1beta1IntotoArtifactResponseOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1IntotoArtifactResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1IntotoArtifactResponse)(nil)).Elem()
}

func (o GrafeasV1beta1IntotoArtifactResponseOutput) ToGrafeasV1beta1IntotoArtifactResponseOutput() GrafeasV1beta1IntotoArtifactResponseOutput {
	return o
}

func (o GrafeasV1beta1IntotoArtifactResponseOutput) ToGrafeasV1beta1IntotoArtifactResponseOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoArtifactResponseOutput {
	return o
}

func (o GrafeasV1beta1IntotoArtifactResponseOutput) Hashes() ArtifactHashesResponseOutput {
	return o.ApplyT(func(v GrafeasV1beta1IntotoArtifactResponse) ArtifactHashesResponse { return v.Hashes }).(ArtifactHashesResponseOutput)
}

func (o GrafeasV1beta1IntotoArtifactResponseOutput) ResourceUri() pulumi.StringOutput {
	return o.ApplyT(func(v GrafeasV1beta1IntotoArtifactResponse) string { return v.ResourceUri }).(pulumi.StringOutput)
}

type GrafeasV1beta1IntotoArtifactResponseArrayOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1IntotoArtifactResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GrafeasV1beta1IntotoArtifactResponse)(nil)).Elem()
}

func (o GrafeasV1beta1IntotoArtifactResponseArrayOutput) ToGrafeasV1beta1IntotoArtifactResponseArrayOutput() GrafeasV1beta1IntotoArtifactResponseArrayOutput {
	return o
}

func (o GrafeasV1beta1IntotoArtifactResponseArrayOutput) ToGrafeasV1beta1IntotoArtifactResponseArrayOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoArtifactResponseArrayOutput {
	return o
}

func (o GrafeasV1beta1IntotoArtifactResponseArrayOutput) Index(i pulumi.IntInput) GrafeasV1beta1IntotoArtifactResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GrafeasV1beta1IntotoArtifactResponse {
		return vs[0].([]GrafeasV1beta1IntotoArtifactResponse)[vs[1].(int)]
	}).(GrafeasV1beta1IntotoArtifactResponseOutput)
}

// This corresponds to a signed in-toto link - it is made up of one or more signatures and the in-toto link itself. This is used for occurrences of a Grafeas in-toto note.
type GrafeasV1beta1IntotoDetails struct {
	Signatures []GrafeasV1beta1IntotoSignature `pulumi:"signatures"`
	Signed     *Link                           `pulumi:"signed"`
}

// GrafeasV1beta1IntotoDetailsInput is an input type that accepts GrafeasV1beta1IntotoDetailsArgs and GrafeasV1beta1IntotoDetailsOutput values.
// You can construct a concrete instance of `GrafeasV1beta1IntotoDetailsInput` via:
//
//          GrafeasV1beta1IntotoDetailsArgs{...}
type GrafeasV1beta1IntotoDetailsInput interface {
	pulumi.Input

	ToGrafeasV1beta1IntotoDetailsOutput() GrafeasV1beta1IntotoDetailsOutput
	ToGrafeasV1beta1IntotoDetailsOutputWithContext(context.Context) GrafeasV1beta1IntotoDetailsOutput
}

// This corresponds to a signed in-toto link - it is made up of one or more signatures and the in-toto link itself. This is used for occurrences of a Grafeas in-toto note.
type GrafeasV1beta1IntotoDetailsArgs struct {
	Signatures GrafeasV1beta1IntotoSignatureArrayInput `pulumi:"signatures"`
	Signed     LinkPtrInput                            `pulumi:"signed"`
}

func (GrafeasV1beta1IntotoDetailsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1IntotoDetails)(nil)).Elem()
}

func (i GrafeasV1beta1IntotoDetailsArgs) ToGrafeasV1beta1IntotoDetailsOutput() GrafeasV1beta1IntotoDetailsOutput {
	return i.ToGrafeasV1beta1IntotoDetailsOutputWithContext(context.Background())
}

func (i GrafeasV1beta1IntotoDetailsArgs) ToGrafeasV1beta1IntotoDetailsOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoDetailsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1IntotoDetailsOutput)
}

func (i GrafeasV1beta1IntotoDetailsArgs) ToGrafeasV1beta1IntotoDetailsPtrOutput() GrafeasV1beta1IntotoDetailsPtrOutput {
	return i.ToGrafeasV1beta1IntotoDetailsPtrOutputWithContext(context.Background())
}

func (i GrafeasV1beta1IntotoDetailsArgs) ToGrafeasV1beta1IntotoDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoDetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1IntotoDetailsOutput).ToGrafeasV1beta1IntotoDetailsPtrOutputWithContext(ctx)
}

// GrafeasV1beta1IntotoDetailsPtrInput is an input type that accepts GrafeasV1beta1IntotoDetailsArgs, GrafeasV1beta1IntotoDetailsPtr and GrafeasV1beta1IntotoDetailsPtrOutput values.
// You can construct a concrete instance of `GrafeasV1beta1IntotoDetailsPtrInput` via:
//
//          GrafeasV1beta1IntotoDetailsArgs{...}
//
//  or:
//
//          nil
type GrafeasV1beta1IntotoDetailsPtrInput interface {
	pulumi.Input

	ToGrafeasV1beta1IntotoDetailsPtrOutput() GrafeasV1beta1IntotoDetailsPtrOutput
	ToGrafeasV1beta1IntotoDetailsPtrOutputWithContext(context.Context) GrafeasV1beta1IntotoDetailsPtrOutput
}

type grafeasV1beta1IntotoDetailsPtrType GrafeasV1beta1IntotoDetailsArgs

func GrafeasV1beta1IntotoDetailsPtr(v *GrafeasV1beta1IntotoDetailsArgs) GrafeasV1beta1IntotoDetailsPtrInput {
	return (*grafeasV1beta1IntotoDetailsPtrType)(v)
}

func (*grafeasV1beta1IntotoDetailsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1IntotoDetails)(nil)).Elem()
}

func (i *grafeasV1beta1IntotoDetailsPtrType) ToGrafeasV1beta1IntotoDetailsPtrOutput() GrafeasV1beta1IntotoDetailsPtrOutput {
	return i.ToGrafeasV1beta1IntotoDetailsPtrOutputWithContext(context.Background())
}

func (i *grafeasV1beta1IntotoDetailsPtrType) ToGrafeasV1beta1IntotoDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoDetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1IntotoDetailsPtrOutput)
}

// This corresponds to a signed in-toto link - it is made up of one or more signatures and the in-toto link itself. This is used for occurrences of a Grafeas in-toto note.
type GrafeasV1beta1IntotoDetailsOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1IntotoDetailsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1IntotoDetails)(nil)).Elem()
}

func (o GrafeasV1beta1IntotoDetailsOutput) ToGrafeasV1beta1IntotoDetailsOutput() GrafeasV1beta1IntotoDetailsOutput {
	return o
}

func (o GrafeasV1beta1IntotoDetailsOutput) ToGrafeasV1beta1IntotoDetailsOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoDetailsOutput {
	return o
}

func (o GrafeasV1beta1IntotoDetailsOutput) ToGrafeasV1beta1IntotoDetailsPtrOutput() GrafeasV1beta1IntotoDetailsPtrOutput {
	return o.ToGrafeasV1beta1IntotoDetailsPtrOutputWithContext(context.Background())
}

func (o GrafeasV1beta1IntotoDetailsOutput) ToGrafeasV1beta1IntotoDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoDetailsPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1IntotoDetails) *GrafeasV1beta1IntotoDetails {
		return &v
	}).(GrafeasV1beta1IntotoDetailsPtrOutput)
}
func (o GrafeasV1beta1IntotoDetailsOutput) Signatures() GrafeasV1beta1IntotoSignatureArrayOutput {
	return o.ApplyT(func(v GrafeasV1beta1IntotoDetails) []GrafeasV1beta1IntotoSignature { return v.Signatures }).(GrafeasV1beta1IntotoSignatureArrayOutput)
}

func (o GrafeasV1beta1IntotoDetailsOutput) Signed() LinkPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1IntotoDetails) *Link { return v.Signed }).(LinkPtrOutput)
}

type GrafeasV1beta1IntotoDetailsPtrOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1IntotoDetailsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1IntotoDetails)(nil)).Elem()
}

func (o GrafeasV1beta1IntotoDetailsPtrOutput) ToGrafeasV1beta1IntotoDetailsPtrOutput() GrafeasV1beta1IntotoDetailsPtrOutput {
	return o
}

func (o GrafeasV1beta1IntotoDetailsPtrOutput) ToGrafeasV1beta1IntotoDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoDetailsPtrOutput {
	return o
}

func (o GrafeasV1beta1IntotoDetailsPtrOutput) Elem() GrafeasV1beta1IntotoDetailsOutput {
	return o.ApplyT(func(v *GrafeasV1beta1IntotoDetails) GrafeasV1beta1IntotoDetails { return *v }).(GrafeasV1beta1IntotoDetailsOutput)
}

func (o GrafeasV1beta1IntotoDetailsPtrOutput) Signatures() GrafeasV1beta1IntotoSignatureArrayOutput {
	return o.ApplyT(func(v *GrafeasV1beta1IntotoDetails) []GrafeasV1beta1IntotoSignature {
		if v == nil {
			return nil
		}
		return v.Signatures
	}).(GrafeasV1beta1IntotoSignatureArrayOutput)
}

func (o GrafeasV1beta1IntotoDetailsPtrOutput) Signed() LinkPtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1IntotoDetails) *Link {
		if v == nil {
			return nil
		}
		return v.Signed
	}).(LinkPtrOutput)
}

// This corresponds to a signed in-toto link - it is made up of one or more signatures and the in-toto link itself. This is used for occurrences of a Grafeas in-toto note.
type GrafeasV1beta1IntotoDetailsResponse struct {
	Signatures []GrafeasV1beta1IntotoSignatureResponse `pulumi:"signatures"`
	Signed     LinkResponse                            `pulumi:"signed"`
}

// GrafeasV1beta1IntotoDetailsResponseInput is an input type that accepts GrafeasV1beta1IntotoDetailsResponseArgs and GrafeasV1beta1IntotoDetailsResponseOutput values.
// You can construct a concrete instance of `GrafeasV1beta1IntotoDetailsResponseInput` via:
//
//          GrafeasV1beta1IntotoDetailsResponseArgs{...}
type GrafeasV1beta1IntotoDetailsResponseInput interface {
	pulumi.Input

	ToGrafeasV1beta1IntotoDetailsResponseOutput() GrafeasV1beta1IntotoDetailsResponseOutput
	ToGrafeasV1beta1IntotoDetailsResponseOutputWithContext(context.Context) GrafeasV1beta1IntotoDetailsResponseOutput
}

// This corresponds to a signed in-toto link - it is made up of one or more signatures and the in-toto link itself. This is used for occurrences of a Grafeas in-toto note.
type GrafeasV1beta1IntotoDetailsResponseArgs struct {
	Signatures GrafeasV1beta1IntotoSignatureResponseArrayInput `pulumi:"signatures"`
	Signed     LinkResponseInput                               `pulumi:"signed"`
}

func (GrafeasV1beta1IntotoDetailsResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1IntotoDetailsResponse)(nil)).Elem()
}

func (i GrafeasV1beta1IntotoDetailsResponseArgs) ToGrafeasV1beta1IntotoDetailsResponseOutput() GrafeasV1beta1IntotoDetailsResponseOutput {
	return i.ToGrafeasV1beta1IntotoDetailsResponseOutputWithContext(context.Background())
}

func (i GrafeasV1beta1IntotoDetailsResponseArgs) ToGrafeasV1beta1IntotoDetailsResponseOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoDetailsResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1IntotoDetailsResponseOutput)
}

func (i GrafeasV1beta1IntotoDetailsResponseArgs) ToGrafeasV1beta1IntotoDetailsResponsePtrOutput() GrafeasV1beta1IntotoDetailsResponsePtrOutput {
	return i.ToGrafeasV1beta1IntotoDetailsResponsePtrOutputWithContext(context.Background())
}

func (i GrafeasV1beta1IntotoDetailsResponseArgs) ToGrafeasV1beta1IntotoDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoDetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1IntotoDetailsResponseOutput).ToGrafeasV1beta1IntotoDetailsResponsePtrOutputWithContext(ctx)
}

// GrafeasV1beta1IntotoDetailsResponsePtrInput is an input type that accepts GrafeasV1beta1IntotoDetailsResponseArgs, GrafeasV1beta1IntotoDetailsResponsePtr and GrafeasV1beta1IntotoDetailsResponsePtrOutput values.
// You can construct a concrete instance of `GrafeasV1beta1IntotoDetailsResponsePtrInput` via:
//
//          GrafeasV1beta1IntotoDetailsResponseArgs{...}
//
//  or:
//
//          nil
type GrafeasV1beta1IntotoDetailsResponsePtrInput interface {
	pulumi.Input

	ToGrafeasV1beta1IntotoDetailsResponsePtrOutput() GrafeasV1beta1IntotoDetailsResponsePtrOutput
	ToGrafeasV1beta1IntotoDetailsResponsePtrOutputWithContext(context.Context) GrafeasV1beta1IntotoDetailsResponsePtrOutput
}

type grafeasV1beta1IntotoDetailsResponsePtrType GrafeasV1beta1IntotoDetailsResponseArgs

func GrafeasV1beta1IntotoDetailsResponsePtr(v *GrafeasV1beta1IntotoDetailsResponseArgs) GrafeasV1beta1IntotoDetailsResponsePtrInput {
	return (*grafeasV1beta1IntotoDetailsResponsePtrType)(v)
}

func (*grafeasV1beta1IntotoDetailsResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1IntotoDetailsResponse)(nil)).Elem()
}

func (i *grafeasV1beta1IntotoDetailsResponsePtrType) ToGrafeasV1beta1IntotoDetailsResponsePtrOutput() GrafeasV1beta1IntotoDetailsResponsePtrOutput {
	return i.ToGrafeasV1beta1IntotoDetailsResponsePtrOutputWithContext(context.Background())
}

func (i *grafeasV1beta1IntotoDetailsResponsePtrType) ToGrafeasV1beta1IntotoDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoDetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1IntotoDetailsResponsePtrOutput)
}

// This corresponds to a signed in-toto link - it is made up of one or more signatures and the in-toto link itself. This is used for occurrences of a Grafeas in-toto note.
type GrafeasV1beta1IntotoDetailsResponseOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1IntotoDetailsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1IntotoDetailsResponse)(nil)).Elem()
}

func (o GrafeasV1beta1IntotoDetailsResponseOutput) ToGrafeasV1beta1IntotoDetailsResponseOutput() GrafeasV1beta1IntotoDetailsResponseOutput {
	return o
}

func (o GrafeasV1beta1IntotoDetailsResponseOutput) ToGrafeasV1beta1IntotoDetailsResponseOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoDetailsResponseOutput {
	return o
}

func (o GrafeasV1beta1IntotoDetailsResponseOutput) ToGrafeasV1beta1IntotoDetailsResponsePtrOutput() GrafeasV1beta1IntotoDetailsResponsePtrOutput {
	return o.ToGrafeasV1beta1IntotoDetailsResponsePtrOutputWithContext(context.Background())
}

func (o GrafeasV1beta1IntotoDetailsResponseOutput) ToGrafeasV1beta1IntotoDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoDetailsResponsePtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1IntotoDetailsResponse) *GrafeasV1beta1IntotoDetailsResponse {
		return &v
	}).(GrafeasV1beta1IntotoDetailsResponsePtrOutput)
}
func (o GrafeasV1beta1IntotoDetailsResponseOutput) Signatures() GrafeasV1beta1IntotoSignatureResponseArrayOutput {
	return o.ApplyT(func(v GrafeasV1beta1IntotoDetailsResponse) []GrafeasV1beta1IntotoSignatureResponse {
		return v.Signatures
	}).(GrafeasV1beta1IntotoSignatureResponseArrayOutput)
}

func (o GrafeasV1beta1IntotoDetailsResponseOutput) Signed() LinkResponseOutput {
	return o.ApplyT(func(v GrafeasV1beta1IntotoDetailsResponse) LinkResponse { return v.Signed }).(LinkResponseOutput)
}

type GrafeasV1beta1IntotoDetailsResponsePtrOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1IntotoDetailsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1IntotoDetailsResponse)(nil)).Elem()
}

func (o GrafeasV1beta1IntotoDetailsResponsePtrOutput) ToGrafeasV1beta1IntotoDetailsResponsePtrOutput() GrafeasV1beta1IntotoDetailsResponsePtrOutput {
	return o
}

func (o GrafeasV1beta1IntotoDetailsResponsePtrOutput) ToGrafeasV1beta1IntotoDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoDetailsResponsePtrOutput {
	return o
}

func (o GrafeasV1beta1IntotoDetailsResponsePtrOutput) Elem() GrafeasV1beta1IntotoDetailsResponseOutput {
	return o.ApplyT(func(v *GrafeasV1beta1IntotoDetailsResponse) GrafeasV1beta1IntotoDetailsResponse { return *v }).(GrafeasV1beta1IntotoDetailsResponseOutput)
}

func (o GrafeasV1beta1IntotoDetailsResponsePtrOutput) Signatures() GrafeasV1beta1IntotoSignatureResponseArrayOutput {
	return o.ApplyT(func(v *GrafeasV1beta1IntotoDetailsResponse) []GrafeasV1beta1IntotoSignatureResponse {
		if v == nil {
			return nil
		}
		return v.Signatures
	}).(GrafeasV1beta1IntotoSignatureResponseArrayOutput)
}

func (o GrafeasV1beta1IntotoDetailsResponsePtrOutput) Signed() LinkResponsePtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1IntotoDetailsResponse) *LinkResponse {
		if v == nil {
			return nil
		}
		return &v.Signed
	}).(LinkResponsePtrOutput)
}

// A signature object consists of the KeyID used and the signature itself.
type GrafeasV1beta1IntotoSignature struct {
	Keyid *string `pulumi:"keyid"`
	Sig   *string `pulumi:"sig"`
}

// GrafeasV1beta1IntotoSignatureInput is an input type that accepts GrafeasV1beta1IntotoSignatureArgs and GrafeasV1beta1IntotoSignatureOutput values.
// You can construct a concrete instance of `GrafeasV1beta1IntotoSignatureInput` via:
//
//          GrafeasV1beta1IntotoSignatureArgs{...}
type GrafeasV1beta1IntotoSignatureInput interface {
	pulumi.Input

	ToGrafeasV1beta1IntotoSignatureOutput() GrafeasV1beta1IntotoSignatureOutput
	ToGrafeasV1beta1IntotoSignatureOutputWithContext(context.Context) GrafeasV1beta1IntotoSignatureOutput
}

// A signature object consists of the KeyID used and the signature itself.
type GrafeasV1beta1IntotoSignatureArgs struct {
	Keyid pulumi.StringPtrInput `pulumi:"keyid"`
	Sig   pulumi.StringPtrInput `pulumi:"sig"`
}

func (GrafeasV1beta1IntotoSignatureArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1IntotoSignature)(nil)).Elem()
}

func (i GrafeasV1beta1IntotoSignatureArgs) ToGrafeasV1beta1IntotoSignatureOutput() GrafeasV1beta1IntotoSignatureOutput {
	return i.ToGrafeasV1beta1IntotoSignatureOutputWithContext(context.Background())
}

func (i GrafeasV1beta1IntotoSignatureArgs) ToGrafeasV1beta1IntotoSignatureOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoSignatureOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1IntotoSignatureOutput)
}

// GrafeasV1beta1IntotoSignatureArrayInput is an input type that accepts GrafeasV1beta1IntotoSignatureArray and GrafeasV1beta1IntotoSignatureArrayOutput values.
// You can construct a concrete instance of `GrafeasV1beta1IntotoSignatureArrayInput` via:
//
//          GrafeasV1beta1IntotoSignatureArray{ GrafeasV1beta1IntotoSignatureArgs{...} }
type GrafeasV1beta1IntotoSignatureArrayInput interface {
	pulumi.Input

	ToGrafeasV1beta1IntotoSignatureArrayOutput() GrafeasV1beta1IntotoSignatureArrayOutput
	ToGrafeasV1beta1IntotoSignatureArrayOutputWithContext(context.Context) GrafeasV1beta1IntotoSignatureArrayOutput
}

type GrafeasV1beta1IntotoSignatureArray []GrafeasV1beta1IntotoSignatureInput

func (GrafeasV1beta1IntotoSignatureArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GrafeasV1beta1IntotoSignature)(nil)).Elem()
}

func (i GrafeasV1beta1IntotoSignatureArray) ToGrafeasV1beta1IntotoSignatureArrayOutput() GrafeasV1beta1IntotoSignatureArrayOutput {
	return i.ToGrafeasV1beta1IntotoSignatureArrayOutputWithContext(context.Background())
}

func (i GrafeasV1beta1IntotoSignatureArray) ToGrafeasV1beta1IntotoSignatureArrayOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoSignatureArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1IntotoSignatureArrayOutput)
}

// A signature object consists of the KeyID used and the signature itself.
type GrafeasV1beta1IntotoSignatureOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1IntotoSignatureOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1IntotoSignature)(nil)).Elem()
}

func (o GrafeasV1beta1IntotoSignatureOutput) ToGrafeasV1beta1IntotoSignatureOutput() GrafeasV1beta1IntotoSignatureOutput {
	return o
}

func (o GrafeasV1beta1IntotoSignatureOutput) ToGrafeasV1beta1IntotoSignatureOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoSignatureOutput {
	return o
}

func (o GrafeasV1beta1IntotoSignatureOutput) Keyid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1IntotoSignature) *string { return v.Keyid }).(pulumi.StringPtrOutput)
}

func (o GrafeasV1beta1IntotoSignatureOutput) Sig() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1IntotoSignature) *string { return v.Sig }).(pulumi.StringPtrOutput)
}

type GrafeasV1beta1IntotoSignatureArrayOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1IntotoSignatureArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GrafeasV1beta1IntotoSignature)(nil)).Elem()
}

func (o GrafeasV1beta1IntotoSignatureArrayOutput) ToGrafeasV1beta1IntotoSignatureArrayOutput() GrafeasV1beta1IntotoSignatureArrayOutput {
	return o
}

func (o GrafeasV1beta1IntotoSignatureArrayOutput) ToGrafeasV1beta1IntotoSignatureArrayOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoSignatureArrayOutput {
	return o
}

func (o GrafeasV1beta1IntotoSignatureArrayOutput) Index(i pulumi.IntInput) GrafeasV1beta1IntotoSignatureOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GrafeasV1beta1IntotoSignature {
		return vs[0].([]GrafeasV1beta1IntotoSignature)[vs[1].(int)]
	}).(GrafeasV1beta1IntotoSignatureOutput)
}

// A signature object consists of the KeyID used and the signature itself.
type GrafeasV1beta1IntotoSignatureResponse struct {
	Keyid string `pulumi:"keyid"`
	Sig   string `pulumi:"sig"`
}

// GrafeasV1beta1IntotoSignatureResponseInput is an input type that accepts GrafeasV1beta1IntotoSignatureResponseArgs and GrafeasV1beta1IntotoSignatureResponseOutput values.
// You can construct a concrete instance of `GrafeasV1beta1IntotoSignatureResponseInput` via:
//
//          GrafeasV1beta1IntotoSignatureResponseArgs{...}
type GrafeasV1beta1IntotoSignatureResponseInput interface {
	pulumi.Input

	ToGrafeasV1beta1IntotoSignatureResponseOutput() GrafeasV1beta1IntotoSignatureResponseOutput
	ToGrafeasV1beta1IntotoSignatureResponseOutputWithContext(context.Context) GrafeasV1beta1IntotoSignatureResponseOutput
}

// A signature object consists of the KeyID used and the signature itself.
type GrafeasV1beta1IntotoSignatureResponseArgs struct {
	Keyid pulumi.StringInput `pulumi:"keyid"`
	Sig   pulumi.StringInput `pulumi:"sig"`
}

func (GrafeasV1beta1IntotoSignatureResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1IntotoSignatureResponse)(nil)).Elem()
}

func (i GrafeasV1beta1IntotoSignatureResponseArgs) ToGrafeasV1beta1IntotoSignatureResponseOutput() GrafeasV1beta1IntotoSignatureResponseOutput {
	return i.ToGrafeasV1beta1IntotoSignatureResponseOutputWithContext(context.Background())
}

func (i GrafeasV1beta1IntotoSignatureResponseArgs) ToGrafeasV1beta1IntotoSignatureResponseOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoSignatureResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1IntotoSignatureResponseOutput)
}

// GrafeasV1beta1IntotoSignatureResponseArrayInput is an input type that accepts GrafeasV1beta1IntotoSignatureResponseArray and GrafeasV1beta1IntotoSignatureResponseArrayOutput values.
// You can construct a concrete instance of `GrafeasV1beta1IntotoSignatureResponseArrayInput` via:
//
//          GrafeasV1beta1IntotoSignatureResponseArray{ GrafeasV1beta1IntotoSignatureResponseArgs{...} }
type GrafeasV1beta1IntotoSignatureResponseArrayInput interface {
	pulumi.Input

	ToGrafeasV1beta1IntotoSignatureResponseArrayOutput() GrafeasV1beta1IntotoSignatureResponseArrayOutput
	ToGrafeasV1beta1IntotoSignatureResponseArrayOutputWithContext(context.Context) GrafeasV1beta1IntotoSignatureResponseArrayOutput
}

type GrafeasV1beta1IntotoSignatureResponseArray []GrafeasV1beta1IntotoSignatureResponseInput

func (GrafeasV1beta1IntotoSignatureResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GrafeasV1beta1IntotoSignatureResponse)(nil)).Elem()
}

func (i GrafeasV1beta1IntotoSignatureResponseArray) ToGrafeasV1beta1IntotoSignatureResponseArrayOutput() GrafeasV1beta1IntotoSignatureResponseArrayOutput {
	return i.ToGrafeasV1beta1IntotoSignatureResponseArrayOutputWithContext(context.Background())
}

func (i GrafeasV1beta1IntotoSignatureResponseArray) ToGrafeasV1beta1IntotoSignatureResponseArrayOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoSignatureResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1IntotoSignatureResponseArrayOutput)
}

// A signature object consists of the KeyID used and the signature itself.
type GrafeasV1beta1IntotoSignatureResponseOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1IntotoSignatureResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1IntotoSignatureResponse)(nil)).Elem()
}

func (o GrafeasV1beta1IntotoSignatureResponseOutput) ToGrafeasV1beta1IntotoSignatureResponseOutput() GrafeasV1beta1IntotoSignatureResponseOutput {
	return o
}

func (o GrafeasV1beta1IntotoSignatureResponseOutput) ToGrafeasV1beta1IntotoSignatureResponseOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoSignatureResponseOutput {
	return o
}

func (o GrafeasV1beta1IntotoSignatureResponseOutput) Keyid() pulumi.StringOutput {
	return o.ApplyT(func(v GrafeasV1beta1IntotoSignatureResponse) string { return v.Keyid }).(pulumi.StringOutput)
}

func (o GrafeasV1beta1IntotoSignatureResponseOutput) Sig() pulumi.StringOutput {
	return o.ApplyT(func(v GrafeasV1beta1IntotoSignatureResponse) string { return v.Sig }).(pulumi.StringOutput)
}

type GrafeasV1beta1IntotoSignatureResponseArrayOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1IntotoSignatureResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GrafeasV1beta1IntotoSignatureResponse)(nil)).Elem()
}

func (o GrafeasV1beta1IntotoSignatureResponseArrayOutput) ToGrafeasV1beta1IntotoSignatureResponseArrayOutput() GrafeasV1beta1IntotoSignatureResponseArrayOutput {
	return o
}

func (o GrafeasV1beta1IntotoSignatureResponseArrayOutput) ToGrafeasV1beta1IntotoSignatureResponseArrayOutputWithContext(ctx context.Context) GrafeasV1beta1IntotoSignatureResponseArrayOutput {
	return o
}

func (o GrafeasV1beta1IntotoSignatureResponseArrayOutput) Index(i pulumi.IntInput) GrafeasV1beta1IntotoSignatureResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GrafeasV1beta1IntotoSignatureResponse {
		return vs[0].([]GrafeasV1beta1IntotoSignatureResponse)[vs[1].(int)]
	}).(GrafeasV1beta1IntotoSignatureResponseOutput)
}

// Details of a package occurrence.
type GrafeasV1beta1PackageDetails struct {
	// Where the package was installed.
	Installation Installation `pulumi:"installation"`
}

// GrafeasV1beta1PackageDetailsInput is an input type that accepts GrafeasV1beta1PackageDetailsArgs and GrafeasV1beta1PackageDetailsOutput values.
// You can construct a concrete instance of `GrafeasV1beta1PackageDetailsInput` via:
//
//          GrafeasV1beta1PackageDetailsArgs{...}
type GrafeasV1beta1PackageDetailsInput interface {
	pulumi.Input

	ToGrafeasV1beta1PackageDetailsOutput() GrafeasV1beta1PackageDetailsOutput
	ToGrafeasV1beta1PackageDetailsOutputWithContext(context.Context) GrafeasV1beta1PackageDetailsOutput
}

// Details of a package occurrence.
type GrafeasV1beta1PackageDetailsArgs struct {
	// Where the package was installed.
	Installation InstallationInput `pulumi:"installation"`
}

func (GrafeasV1beta1PackageDetailsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1PackageDetails)(nil)).Elem()
}

func (i GrafeasV1beta1PackageDetailsArgs) ToGrafeasV1beta1PackageDetailsOutput() GrafeasV1beta1PackageDetailsOutput {
	return i.ToGrafeasV1beta1PackageDetailsOutputWithContext(context.Background())
}

func (i GrafeasV1beta1PackageDetailsArgs) ToGrafeasV1beta1PackageDetailsOutputWithContext(ctx context.Context) GrafeasV1beta1PackageDetailsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1PackageDetailsOutput)
}

func (i GrafeasV1beta1PackageDetailsArgs) ToGrafeasV1beta1PackageDetailsPtrOutput() GrafeasV1beta1PackageDetailsPtrOutput {
	return i.ToGrafeasV1beta1PackageDetailsPtrOutputWithContext(context.Background())
}

func (i GrafeasV1beta1PackageDetailsArgs) ToGrafeasV1beta1PackageDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1PackageDetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1PackageDetailsOutput).ToGrafeasV1beta1PackageDetailsPtrOutputWithContext(ctx)
}

// GrafeasV1beta1PackageDetailsPtrInput is an input type that accepts GrafeasV1beta1PackageDetailsArgs, GrafeasV1beta1PackageDetailsPtr and GrafeasV1beta1PackageDetailsPtrOutput values.
// You can construct a concrete instance of `GrafeasV1beta1PackageDetailsPtrInput` via:
//
//          GrafeasV1beta1PackageDetailsArgs{...}
//
//  or:
//
//          nil
type GrafeasV1beta1PackageDetailsPtrInput interface {
	pulumi.Input

	ToGrafeasV1beta1PackageDetailsPtrOutput() GrafeasV1beta1PackageDetailsPtrOutput
	ToGrafeasV1beta1PackageDetailsPtrOutputWithContext(context.Context) GrafeasV1beta1PackageDetailsPtrOutput
}

type grafeasV1beta1PackageDetailsPtrType GrafeasV1beta1PackageDetailsArgs

func GrafeasV1beta1PackageDetailsPtr(v *GrafeasV1beta1PackageDetailsArgs) GrafeasV1beta1PackageDetailsPtrInput {
	return (*grafeasV1beta1PackageDetailsPtrType)(v)
}

func (*grafeasV1beta1PackageDetailsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1PackageDetails)(nil)).Elem()
}

func (i *grafeasV1beta1PackageDetailsPtrType) ToGrafeasV1beta1PackageDetailsPtrOutput() GrafeasV1beta1PackageDetailsPtrOutput {
	return i.ToGrafeasV1beta1PackageDetailsPtrOutputWithContext(context.Background())
}

func (i *grafeasV1beta1PackageDetailsPtrType) ToGrafeasV1beta1PackageDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1PackageDetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1PackageDetailsPtrOutput)
}

// Details of a package occurrence.
type GrafeasV1beta1PackageDetailsOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1PackageDetailsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1PackageDetails)(nil)).Elem()
}

func (o GrafeasV1beta1PackageDetailsOutput) ToGrafeasV1beta1PackageDetailsOutput() GrafeasV1beta1PackageDetailsOutput {
	return o
}

func (o GrafeasV1beta1PackageDetailsOutput) ToGrafeasV1beta1PackageDetailsOutputWithContext(ctx context.Context) GrafeasV1beta1PackageDetailsOutput {
	return o
}

func (o GrafeasV1beta1PackageDetailsOutput) ToGrafeasV1beta1PackageDetailsPtrOutput() GrafeasV1beta1PackageDetailsPtrOutput {
	return o.ToGrafeasV1beta1PackageDetailsPtrOutputWithContext(context.Background())
}

func (o GrafeasV1beta1PackageDetailsOutput) ToGrafeasV1beta1PackageDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1PackageDetailsPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1PackageDetails) *GrafeasV1beta1PackageDetails {
		return &v
	}).(GrafeasV1beta1PackageDetailsPtrOutput)
}

// Where the package was installed.
func (o GrafeasV1beta1PackageDetailsOutput) Installation() InstallationOutput {
	return o.ApplyT(func(v GrafeasV1beta1PackageDetails) Installation { return v.Installation }).(InstallationOutput)
}

type GrafeasV1beta1PackageDetailsPtrOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1PackageDetailsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1PackageDetails)(nil)).Elem()
}

func (o GrafeasV1beta1PackageDetailsPtrOutput) ToGrafeasV1beta1PackageDetailsPtrOutput() GrafeasV1beta1PackageDetailsPtrOutput {
	return o
}

func (o GrafeasV1beta1PackageDetailsPtrOutput) ToGrafeasV1beta1PackageDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1PackageDetailsPtrOutput {
	return o
}

func (o GrafeasV1beta1PackageDetailsPtrOutput) Elem() GrafeasV1beta1PackageDetailsOutput {
	return o.ApplyT(func(v *GrafeasV1beta1PackageDetails) GrafeasV1beta1PackageDetails { return *v }).(GrafeasV1beta1PackageDetailsOutput)
}

// Where the package was installed.
func (o GrafeasV1beta1PackageDetailsPtrOutput) Installation() InstallationPtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1PackageDetails) *Installation {
		if v == nil {
			return nil
		}
		return &v.Installation
	}).(InstallationPtrOutput)
}

// Details of a package occurrence.
type GrafeasV1beta1PackageDetailsResponse struct {
	// Where the package was installed.
	Installation InstallationResponse `pulumi:"installation"`
}

// GrafeasV1beta1PackageDetailsResponseInput is an input type that accepts GrafeasV1beta1PackageDetailsResponseArgs and GrafeasV1beta1PackageDetailsResponseOutput values.
// You can construct a concrete instance of `GrafeasV1beta1PackageDetailsResponseInput` via:
//
//          GrafeasV1beta1PackageDetailsResponseArgs{...}
type GrafeasV1beta1PackageDetailsResponseInput interface {
	pulumi.Input

	ToGrafeasV1beta1PackageDetailsResponseOutput() GrafeasV1beta1PackageDetailsResponseOutput
	ToGrafeasV1beta1PackageDetailsResponseOutputWithContext(context.Context) GrafeasV1beta1PackageDetailsResponseOutput
}

// Details of a package occurrence.
type GrafeasV1beta1PackageDetailsResponseArgs struct {
	// Where the package was installed.
	Installation InstallationResponseInput `pulumi:"installation"`
}

func (GrafeasV1beta1PackageDetailsResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1PackageDetailsResponse)(nil)).Elem()
}

func (i GrafeasV1beta1PackageDetailsResponseArgs) ToGrafeasV1beta1PackageDetailsResponseOutput() GrafeasV1beta1PackageDetailsResponseOutput {
	return i.ToGrafeasV1beta1PackageDetailsResponseOutputWithContext(context.Background())
}

func (i GrafeasV1beta1PackageDetailsResponseArgs) ToGrafeasV1beta1PackageDetailsResponseOutputWithContext(ctx context.Context) GrafeasV1beta1PackageDetailsResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1PackageDetailsResponseOutput)
}

func (i GrafeasV1beta1PackageDetailsResponseArgs) ToGrafeasV1beta1PackageDetailsResponsePtrOutput() GrafeasV1beta1PackageDetailsResponsePtrOutput {
	return i.ToGrafeasV1beta1PackageDetailsResponsePtrOutputWithContext(context.Background())
}

func (i GrafeasV1beta1PackageDetailsResponseArgs) ToGrafeasV1beta1PackageDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1PackageDetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1PackageDetailsResponseOutput).ToGrafeasV1beta1PackageDetailsResponsePtrOutputWithContext(ctx)
}

// GrafeasV1beta1PackageDetailsResponsePtrInput is an input type that accepts GrafeasV1beta1PackageDetailsResponseArgs, GrafeasV1beta1PackageDetailsResponsePtr and GrafeasV1beta1PackageDetailsResponsePtrOutput values.
// You can construct a concrete instance of `GrafeasV1beta1PackageDetailsResponsePtrInput` via:
//
//          GrafeasV1beta1PackageDetailsResponseArgs{...}
//
//  or:
//
//          nil
type GrafeasV1beta1PackageDetailsResponsePtrInput interface {
	pulumi.Input

	ToGrafeasV1beta1PackageDetailsResponsePtrOutput() GrafeasV1beta1PackageDetailsResponsePtrOutput
	ToGrafeasV1beta1PackageDetailsResponsePtrOutputWithContext(context.Context) GrafeasV1beta1PackageDetailsResponsePtrOutput
}

type grafeasV1beta1PackageDetailsResponsePtrType GrafeasV1beta1PackageDetailsResponseArgs

func GrafeasV1beta1PackageDetailsResponsePtr(v *GrafeasV1beta1PackageDetailsResponseArgs) GrafeasV1beta1PackageDetailsResponsePtrInput {
	return (*grafeasV1beta1PackageDetailsResponsePtrType)(v)
}

func (*grafeasV1beta1PackageDetailsResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1PackageDetailsResponse)(nil)).Elem()
}

func (i *grafeasV1beta1PackageDetailsResponsePtrType) ToGrafeasV1beta1PackageDetailsResponsePtrOutput() GrafeasV1beta1PackageDetailsResponsePtrOutput {
	return i.ToGrafeasV1beta1PackageDetailsResponsePtrOutputWithContext(context.Background())
}

func (i *grafeasV1beta1PackageDetailsResponsePtrType) ToGrafeasV1beta1PackageDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1PackageDetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1PackageDetailsResponsePtrOutput)
}

// Details of a package occurrence.
type GrafeasV1beta1PackageDetailsResponseOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1PackageDetailsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1PackageDetailsResponse)(nil)).Elem()
}

func (o GrafeasV1beta1PackageDetailsResponseOutput) ToGrafeasV1beta1PackageDetailsResponseOutput() GrafeasV1beta1PackageDetailsResponseOutput {
	return o
}

func (o GrafeasV1beta1PackageDetailsResponseOutput) ToGrafeasV1beta1PackageDetailsResponseOutputWithContext(ctx context.Context) GrafeasV1beta1PackageDetailsResponseOutput {
	return o
}

func (o GrafeasV1beta1PackageDetailsResponseOutput) ToGrafeasV1beta1PackageDetailsResponsePtrOutput() GrafeasV1beta1PackageDetailsResponsePtrOutput {
	return o.ToGrafeasV1beta1PackageDetailsResponsePtrOutputWithContext(context.Background())
}

func (o GrafeasV1beta1PackageDetailsResponseOutput) ToGrafeasV1beta1PackageDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1PackageDetailsResponsePtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1PackageDetailsResponse) *GrafeasV1beta1PackageDetailsResponse {
		return &v
	}).(GrafeasV1beta1PackageDetailsResponsePtrOutput)
}

// Where the package was installed.
func (o GrafeasV1beta1PackageDetailsResponseOutput) Installation() InstallationResponseOutput {
	return o.ApplyT(func(v GrafeasV1beta1PackageDetailsResponse) InstallationResponse { return v.Installation }).(InstallationResponseOutput)
}

type GrafeasV1beta1PackageDetailsResponsePtrOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1PackageDetailsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1PackageDetailsResponse)(nil)).Elem()
}

func (o GrafeasV1beta1PackageDetailsResponsePtrOutput) ToGrafeasV1beta1PackageDetailsResponsePtrOutput() GrafeasV1beta1PackageDetailsResponsePtrOutput {
	return o
}

func (o GrafeasV1beta1PackageDetailsResponsePtrOutput) ToGrafeasV1beta1PackageDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1PackageDetailsResponsePtrOutput {
	return o
}

func (o GrafeasV1beta1PackageDetailsResponsePtrOutput) Elem() GrafeasV1beta1PackageDetailsResponseOutput {
	return o.ApplyT(func(v *GrafeasV1beta1PackageDetailsResponse) GrafeasV1beta1PackageDetailsResponse { return *v }).(GrafeasV1beta1PackageDetailsResponseOutput)
}

// Where the package was installed.
func (o GrafeasV1beta1PackageDetailsResponsePtrOutput) Installation() InstallationResponsePtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1PackageDetailsResponse) *InstallationResponse {
		if v == nil {
			return nil
		}
		return &v.Installation
	}).(InstallationResponsePtrOutput)
}

// Details of a vulnerability Occurrence.
type GrafeasV1beta1VulnerabilityDetails struct {
	// The distro assigned severity for this vulnerability when it is available, and note provider assigned severity when distro has not yet assigned a severity for this vulnerability. When there are multiple PackageIssues for this vulnerability, they can have different effective severities because some might be provided by the distro while others are provided by the language ecosystem for a language pack. For this reason, it is advised to use the effective severity on the PackageIssue level. In the case where multiple PackageIssues have differing effective severities, this field should be the highest severity for any of the PackageIssues.
	EffectiveSeverity *GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity `pulumi:"effectiveSeverity"`
	// The set of affected locations and their fixes (if available) within the associated resource.
	PackageIssue []PackageIssue `pulumi:"packageIssue"`
	// The type of package; whether native or non native(ruby gems, node.js packages etc)
	Type *string `pulumi:"type"`
}

// GrafeasV1beta1VulnerabilityDetailsInput is an input type that accepts GrafeasV1beta1VulnerabilityDetailsArgs and GrafeasV1beta1VulnerabilityDetailsOutput values.
// You can construct a concrete instance of `GrafeasV1beta1VulnerabilityDetailsInput` via:
//
//          GrafeasV1beta1VulnerabilityDetailsArgs{...}
type GrafeasV1beta1VulnerabilityDetailsInput interface {
	pulumi.Input

	ToGrafeasV1beta1VulnerabilityDetailsOutput() GrafeasV1beta1VulnerabilityDetailsOutput
	ToGrafeasV1beta1VulnerabilityDetailsOutputWithContext(context.Context) GrafeasV1beta1VulnerabilityDetailsOutput
}

// Details of a vulnerability Occurrence.
type GrafeasV1beta1VulnerabilityDetailsArgs struct {
	// The distro assigned severity for this vulnerability when it is available, and note provider assigned severity when distro has not yet assigned a severity for this vulnerability. When there are multiple PackageIssues for this vulnerability, they can have different effective severities because some might be provided by the distro while others are provided by the language ecosystem for a language pack. For this reason, it is advised to use the effective severity on the PackageIssue level. In the case where multiple PackageIssues have differing effective severities, this field should be the highest severity for any of the PackageIssues.
	EffectiveSeverity GrafeasV1beta1VulnerabilityDetailsEffectiveSeverityPtrInput `pulumi:"effectiveSeverity"`
	// The set of affected locations and their fixes (if available) within the associated resource.
	PackageIssue PackageIssueArrayInput `pulumi:"packageIssue"`
	// The type of package; whether native or non native(ruby gems, node.js packages etc)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (GrafeasV1beta1VulnerabilityDetailsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1VulnerabilityDetails)(nil)).Elem()
}

func (i GrafeasV1beta1VulnerabilityDetailsArgs) ToGrafeasV1beta1VulnerabilityDetailsOutput() GrafeasV1beta1VulnerabilityDetailsOutput {
	return i.ToGrafeasV1beta1VulnerabilityDetailsOutputWithContext(context.Background())
}

func (i GrafeasV1beta1VulnerabilityDetailsArgs) ToGrafeasV1beta1VulnerabilityDetailsOutputWithContext(ctx context.Context) GrafeasV1beta1VulnerabilityDetailsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1VulnerabilityDetailsOutput)
}

func (i GrafeasV1beta1VulnerabilityDetailsArgs) ToGrafeasV1beta1VulnerabilityDetailsPtrOutput() GrafeasV1beta1VulnerabilityDetailsPtrOutput {
	return i.ToGrafeasV1beta1VulnerabilityDetailsPtrOutputWithContext(context.Background())
}

func (i GrafeasV1beta1VulnerabilityDetailsArgs) ToGrafeasV1beta1VulnerabilityDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1VulnerabilityDetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1VulnerabilityDetailsOutput).ToGrafeasV1beta1VulnerabilityDetailsPtrOutputWithContext(ctx)
}

// GrafeasV1beta1VulnerabilityDetailsPtrInput is an input type that accepts GrafeasV1beta1VulnerabilityDetailsArgs, GrafeasV1beta1VulnerabilityDetailsPtr and GrafeasV1beta1VulnerabilityDetailsPtrOutput values.
// You can construct a concrete instance of `GrafeasV1beta1VulnerabilityDetailsPtrInput` via:
//
//          GrafeasV1beta1VulnerabilityDetailsArgs{...}
//
//  or:
//
//          nil
type GrafeasV1beta1VulnerabilityDetailsPtrInput interface {
	pulumi.Input

	ToGrafeasV1beta1VulnerabilityDetailsPtrOutput() GrafeasV1beta1VulnerabilityDetailsPtrOutput
	ToGrafeasV1beta1VulnerabilityDetailsPtrOutputWithContext(context.Context) GrafeasV1beta1VulnerabilityDetailsPtrOutput
}

type grafeasV1beta1VulnerabilityDetailsPtrType GrafeasV1beta1VulnerabilityDetailsArgs

func GrafeasV1beta1VulnerabilityDetailsPtr(v *GrafeasV1beta1VulnerabilityDetailsArgs) GrafeasV1beta1VulnerabilityDetailsPtrInput {
	return (*grafeasV1beta1VulnerabilityDetailsPtrType)(v)
}

func (*grafeasV1beta1VulnerabilityDetailsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1VulnerabilityDetails)(nil)).Elem()
}

func (i *grafeasV1beta1VulnerabilityDetailsPtrType) ToGrafeasV1beta1VulnerabilityDetailsPtrOutput() GrafeasV1beta1VulnerabilityDetailsPtrOutput {
	return i.ToGrafeasV1beta1VulnerabilityDetailsPtrOutputWithContext(context.Background())
}

func (i *grafeasV1beta1VulnerabilityDetailsPtrType) ToGrafeasV1beta1VulnerabilityDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1VulnerabilityDetailsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1VulnerabilityDetailsPtrOutput)
}

// Details of a vulnerability Occurrence.
type GrafeasV1beta1VulnerabilityDetailsOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1VulnerabilityDetailsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1VulnerabilityDetails)(nil)).Elem()
}

func (o GrafeasV1beta1VulnerabilityDetailsOutput) ToGrafeasV1beta1VulnerabilityDetailsOutput() GrafeasV1beta1VulnerabilityDetailsOutput {
	return o
}

func (o GrafeasV1beta1VulnerabilityDetailsOutput) ToGrafeasV1beta1VulnerabilityDetailsOutputWithContext(ctx context.Context) GrafeasV1beta1VulnerabilityDetailsOutput {
	return o
}

func (o GrafeasV1beta1VulnerabilityDetailsOutput) ToGrafeasV1beta1VulnerabilityDetailsPtrOutput() GrafeasV1beta1VulnerabilityDetailsPtrOutput {
	return o.ToGrafeasV1beta1VulnerabilityDetailsPtrOutputWithContext(context.Background())
}

func (o GrafeasV1beta1VulnerabilityDetailsOutput) ToGrafeasV1beta1VulnerabilityDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1VulnerabilityDetailsPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1VulnerabilityDetails) *GrafeasV1beta1VulnerabilityDetails {
		return &v
	}).(GrafeasV1beta1VulnerabilityDetailsPtrOutput)
}

// The distro assigned severity for this vulnerability when it is available, and note provider assigned severity when distro has not yet assigned a severity for this vulnerability. When there are multiple PackageIssues for this vulnerability, they can have different effective severities because some might be provided by the distro while others are provided by the language ecosystem for a language pack. For this reason, it is advised to use the effective severity on the PackageIssue level. In the case where multiple PackageIssues have differing effective severities, this field should be the highest severity for any of the PackageIssues.
func (o GrafeasV1beta1VulnerabilityDetailsOutput) EffectiveSeverity() GrafeasV1beta1VulnerabilityDetailsEffectiveSeverityPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1VulnerabilityDetails) *GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity {
		return v.EffectiveSeverity
	}).(GrafeasV1beta1VulnerabilityDetailsEffectiveSeverityPtrOutput)
}

// The set of affected locations and their fixes (if available) within the associated resource.
func (o GrafeasV1beta1VulnerabilityDetailsOutput) PackageIssue() PackageIssueArrayOutput {
	return o.ApplyT(func(v GrafeasV1beta1VulnerabilityDetails) []PackageIssue { return v.PackageIssue }).(PackageIssueArrayOutput)
}

// The type of package; whether native or non native(ruby gems, node.js packages etc)
func (o GrafeasV1beta1VulnerabilityDetailsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1VulnerabilityDetails) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GrafeasV1beta1VulnerabilityDetailsPtrOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1VulnerabilityDetailsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1VulnerabilityDetails)(nil)).Elem()
}

func (o GrafeasV1beta1VulnerabilityDetailsPtrOutput) ToGrafeasV1beta1VulnerabilityDetailsPtrOutput() GrafeasV1beta1VulnerabilityDetailsPtrOutput {
	return o
}

func (o GrafeasV1beta1VulnerabilityDetailsPtrOutput) ToGrafeasV1beta1VulnerabilityDetailsPtrOutputWithContext(ctx context.Context) GrafeasV1beta1VulnerabilityDetailsPtrOutput {
	return o
}

func (o GrafeasV1beta1VulnerabilityDetailsPtrOutput) Elem() GrafeasV1beta1VulnerabilityDetailsOutput {
	return o.ApplyT(func(v *GrafeasV1beta1VulnerabilityDetails) GrafeasV1beta1VulnerabilityDetails { return *v }).(GrafeasV1beta1VulnerabilityDetailsOutput)
}

// The distro assigned severity for this vulnerability when it is available, and note provider assigned severity when distro has not yet assigned a severity for this vulnerability. When there are multiple PackageIssues for this vulnerability, they can have different effective severities because some might be provided by the distro while others are provided by the language ecosystem for a language pack. For this reason, it is advised to use the effective severity on the PackageIssue level. In the case where multiple PackageIssues have differing effective severities, this field should be the highest severity for any of the PackageIssues.
func (o GrafeasV1beta1VulnerabilityDetailsPtrOutput) EffectiveSeverity() GrafeasV1beta1VulnerabilityDetailsEffectiveSeverityPtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1VulnerabilityDetails) *GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity {
		if v == nil {
			return nil
		}
		return v.EffectiveSeverity
	}).(GrafeasV1beta1VulnerabilityDetailsEffectiveSeverityPtrOutput)
}

// The set of affected locations and their fixes (if available) within the associated resource.
func (o GrafeasV1beta1VulnerabilityDetailsPtrOutput) PackageIssue() PackageIssueArrayOutput {
	return o.ApplyT(func(v *GrafeasV1beta1VulnerabilityDetails) []PackageIssue {
		if v == nil {
			return nil
		}
		return v.PackageIssue
	}).(PackageIssueArrayOutput)
}

// The type of package; whether native or non native(ruby gems, node.js packages etc)
func (o GrafeasV1beta1VulnerabilityDetailsPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1VulnerabilityDetails) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Details of a vulnerability Occurrence.
type GrafeasV1beta1VulnerabilityDetailsResponse struct {
	// The CVSS score of this vulnerability. CVSS score is on a scale of 0-10 where 0 indicates low severity and 10 indicates high severity.
	CvssScore float64 `pulumi:"cvssScore"`
	// The distro assigned severity for this vulnerability when it is available, and note provider assigned severity when distro has not yet assigned a severity for this vulnerability. When there are multiple PackageIssues for this vulnerability, they can have different effective severities because some might be provided by the distro while others are provided by the language ecosystem for a language pack. For this reason, it is advised to use the effective severity on the PackageIssue level. In the case where multiple PackageIssues have differing effective severities, this field should be the highest severity for any of the PackageIssues.
	EffectiveSeverity string `pulumi:"effectiveSeverity"`
	// A detailed description of this vulnerability.
	LongDescription string `pulumi:"longDescription"`
	// The set of affected locations and their fixes (if available) within the associated resource.
	PackageIssue []PackageIssueResponse `pulumi:"packageIssue"`
	// URLs related to this vulnerability.
	RelatedUrls []RelatedUrlResponse `pulumi:"relatedUrls"`
	// The note provider assigned Severity of the vulnerability.
	Severity string `pulumi:"severity"`
	// A one sentence description of this vulnerability.
	ShortDescription string `pulumi:"shortDescription"`
	// The type of package; whether native or non native(ruby gems, node.js packages etc)
	Type string `pulumi:"type"`
}

// GrafeasV1beta1VulnerabilityDetailsResponseInput is an input type that accepts GrafeasV1beta1VulnerabilityDetailsResponseArgs and GrafeasV1beta1VulnerabilityDetailsResponseOutput values.
// You can construct a concrete instance of `GrafeasV1beta1VulnerabilityDetailsResponseInput` via:
//
//          GrafeasV1beta1VulnerabilityDetailsResponseArgs{...}
type GrafeasV1beta1VulnerabilityDetailsResponseInput interface {
	pulumi.Input

	ToGrafeasV1beta1VulnerabilityDetailsResponseOutput() GrafeasV1beta1VulnerabilityDetailsResponseOutput
	ToGrafeasV1beta1VulnerabilityDetailsResponseOutputWithContext(context.Context) GrafeasV1beta1VulnerabilityDetailsResponseOutput
}

// Details of a vulnerability Occurrence.
type GrafeasV1beta1VulnerabilityDetailsResponseArgs struct {
	// The CVSS score of this vulnerability. CVSS score is on a scale of 0-10 where 0 indicates low severity and 10 indicates high severity.
	CvssScore pulumi.Float64Input `pulumi:"cvssScore"`
	// The distro assigned severity for this vulnerability when it is available, and note provider assigned severity when distro has not yet assigned a severity for this vulnerability. When there are multiple PackageIssues for this vulnerability, they can have different effective severities because some might be provided by the distro while others are provided by the language ecosystem for a language pack. For this reason, it is advised to use the effective severity on the PackageIssue level. In the case where multiple PackageIssues have differing effective severities, this field should be the highest severity for any of the PackageIssues.
	EffectiveSeverity pulumi.StringInput `pulumi:"effectiveSeverity"`
	// A detailed description of this vulnerability.
	LongDescription pulumi.StringInput `pulumi:"longDescription"`
	// The set of affected locations and their fixes (if available) within the associated resource.
	PackageIssue PackageIssueResponseArrayInput `pulumi:"packageIssue"`
	// URLs related to this vulnerability.
	RelatedUrls RelatedUrlResponseArrayInput `pulumi:"relatedUrls"`
	// The note provider assigned Severity of the vulnerability.
	Severity pulumi.StringInput `pulumi:"severity"`
	// A one sentence description of this vulnerability.
	ShortDescription pulumi.StringInput `pulumi:"shortDescription"`
	// The type of package; whether native or non native(ruby gems, node.js packages etc)
	Type pulumi.StringInput `pulumi:"type"`
}

func (GrafeasV1beta1VulnerabilityDetailsResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1VulnerabilityDetailsResponse)(nil)).Elem()
}

func (i GrafeasV1beta1VulnerabilityDetailsResponseArgs) ToGrafeasV1beta1VulnerabilityDetailsResponseOutput() GrafeasV1beta1VulnerabilityDetailsResponseOutput {
	return i.ToGrafeasV1beta1VulnerabilityDetailsResponseOutputWithContext(context.Background())
}

func (i GrafeasV1beta1VulnerabilityDetailsResponseArgs) ToGrafeasV1beta1VulnerabilityDetailsResponseOutputWithContext(ctx context.Context) GrafeasV1beta1VulnerabilityDetailsResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1VulnerabilityDetailsResponseOutput)
}

func (i GrafeasV1beta1VulnerabilityDetailsResponseArgs) ToGrafeasV1beta1VulnerabilityDetailsResponsePtrOutput() GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput {
	return i.ToGrafeasV1beta1VulnerabilityDetailsResponsePtrOutputWithContext(context.Background())
}

func (i GrafeasV1beta1VulnerabilityDetailsResponseArgs) ToGrafeasV1beta1VulnerabilityDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1VulnerabilityDetailsResponseOutput).ToGrafeasV1beta1VulnerabilityDetailsResponsePtrOutputWithContext(ctx)
}

// GrafeasV1beta1VulnerabilityDetailsResponsePtrInput is an input type that accepts GrafeasV1beta1VulnerabilityDetailsResponseArgs, GrafeasV1beta1VulnerabilityDetailsResponsePtr and GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput values.
// You can construct a concrete instance of `GrafeasV1beta1VulnerabilityDetailsResponsePtrInput` via:
//
//          GrafeasV1beta1VulnerabilityDetailsResponseArgs{...}
//
//  or:
//
//          nil
type GrafeasV1beta1VulnerabilityDetailsResponsePtrInput interface {
	pulumi.Input

	ToGrafeasV1beta1VulnerabilityDetailsResponsePtrOutput() GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput
	ToGrafeasV1beta1VulnerabilityDetailsResponsePtrOutputWithContext(context.Context) GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput
}

type grafeasV1beta1VulnerabilityDetailsResponsePtrType GrafeasV1beta1VulnerabilityDetailsResponseArgs

func GrafeasV1beta1VulnerabilityDetailsResponsePtr(v *GrafeasV1beta1VulnerabilityDetailsResponseArgs) GrafeasV1beta1VulnerabilityDetailsResponsePtrInput {
	return (*grafeasV1beta1VulnerabilityDetailsResponsePtrType)(v)
}

func (*grafeasV1beta1VulnerabilityDetailsResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1VulnerabilityDetailsResponse)(nil)).Elem()
}

func (i *grafeasV1beta1VulnerabilityDetailsResponsePtrType) ToGrafeasV1beta1VulnerabilityDetailsResponsePtrOutput() GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput {
	return i.ToGrafeasV1beta1VulnerabilityDetailsResponsePtrOutputWithContext(context.Background())
}

func (i *grafeasV1beta1VulnerabilityDetailsResponsePtrType) ToGrafeasV1beta1VulnerabilityDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput)
}

// Details of a vulnerability Occurrence.
type GrafeasV1beta1VulnerabilityDetailsResponseOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1VulnerabilityDetailsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GrafeasV1beta1VulnerabilityDetailsResponse)(nil)).Elem()
}

func (o GrafeasV1beta1VulnerabilityDetailsResponseOutput) ToGrafeasV1beta1VulnerabilityDetailsResponseOutput() GrafeasV1beta1VulnerabilityDetailsResponseOutput {
	return o
}

func (o GrafeasV1beta1VulnerabilityDetailsResponseOutput) ToGrafeasV1beta1VulnerabilityDetailsResponseOutputWithContext(ctx context.Context) GrafeasV1beta1VulnerabilityDetailsResponseOutput {
	return o
}

func (o GrafeasV1beta1VulnerabilityDetailsResponseOutput) ToGrafeasV1beta1VulnerabilityDetailsResponsePtrOutput() GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput {
	return o.ToGrafeasV1beta1VulnerabilityDetailsResponsePtrOutputWithContext(context.Background())
}

func (o GrafeasV1beta1VulnerabilityDetailsResponseOutput) ToGrafeasV1beta1VulnerabilityDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput {
	return o.ApplyT(func(v GrafeasV1beta1VulnerabilityDetailsResponse) *GrafeasV1beta1VulnerabilityDetailsResponse {
		return &v
	}).(GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput)
}

// The CVSS score of this vulnerability. CVSS score is on a scale of 0-10 where 0 indicates low severity and 10 indicates high severity.
func (o GrafeasV1beta1VulnerabilityDetailsResponseOutput) CvssScore() pulumi.Float64Output {
	return o.ApplyT(func(v GrafeasV1beta1VulnerabilityDetailsResponse) float64 { return v.CvssScore }).(pulumi.Float64Output)
}

// The distro assigned severity for this vulnerability when it is available, and note provider assigned severity when distro has not yet assigned a severity for this vulnerability. When there are multiple PackageIssues for this vulnerability, they can have different effective severities because some might be provided by the distro while others are provided by the language ecosystem for a language pack. For this reason, it is advised to use the effective severity on the PackageIssue level. In the case where multiple PackageIssues have differing effective severities, this field should be the highest severity for any of the PackageIssues.
func (o GrafeasV1beta1VulnerabilityDetailsResponseOutput) EffectiveSeverity() pulumi.StringOutput {
	return o.ApplyT(func(v GrafeasV1beta1VulnerabilityDetailsResponse) string { return v.EffectiveSeverity }).(pulumi.StringOutput)
}

// A detailed description of this vulnerability.
func (o GrafeasV1beta1VulnerabilityDetailsResponseOutput) LongDescription() pulumi.StringOutput {
	return o.ApplyT(func(v GrafeasV1beta1VulnerabilityDetailsResponse) string { return v.LongDescription }).(pulumi.StringOutput)
}

// The set of affected locations and their fixes (if available) within the associated resource.
func (o GrafeasV1beta1VulnerabilityDetailsResponseOutput) PackageIssue() PackageIssueResponseArrayOutput {
	return o.ApplyT(func(v GrafeasV1beta1VulnerabilityDetailsResponse) []PackageIssueResponse { return v.PackageIssue }).(PackageIssueResponseArrayOutput)
}

// URLs related to this vulnerability.
func (o GrafeasV1beta1VulnerabilityDetailsResponseOutput) RelatedUrls() RelatedUrlResponseArrayOutput {
	return o.ApplyT(func(v GrafeasV1beta1VulnerabilityDetailsResponse) []RelatedUrlResponse { return v.RelatedUrls }).(RelatedUrlResponseArrayOutput)
}

// The note provider assigned Severity of the vulnerability.
func (o GrafeasV1beta1VulnerabilityDetailsResponseOutput) Severity() pulumi.StringOutput {
	return o.ApplyT(func(v GrafeasV1beta1VulnerabilityDetailsResponse) string { return v.Severity }).(pulumi.StringOutput)
}

// A one sentence description of this vulnerability.
func (o GrafeasV1beta1VulnerabilityDetailsResponseOutput) ShortDescription() pulumi.StringOutput {
	return o.ApplyT(func(v GrafeasV1beta1VulnerabilityDetailsResponse) string { return v.ShortDescription }).(pulumi.StringOutput)
}

// The type of package; whether native or non native(ruby gems, node.js packages etc)
func (o GrafeasV1beta1VulnerabilityDetailsResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GrafeasV1beta1VulnerabilityDetailsResponse) string { return v.Type }).(pulumi.StringOutput)
}

type GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput struct{ *pulumi.OutputState }

func (GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GrafeasV1beta1VulnerabilityDetailsResponse)(nil)).Elem()
}

func (o GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput) ToGrafeasV1beta1VulnerabilityDetailsResponsePtrOutput() GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput {
	return o
}

func (o GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput) ToGrafeasV1beta1VulnerabilityDetailsResponsePtrOutputWithContext(ctx context.Context) GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput {
	return o
}

func (o GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput) Elem() GrafeasV1beta1VulnerabilityDetailsResponseOutput {
	return o.ApplyT(func(v *GrafeasV1beta1VulnerabilityDetailsResponse) GrafeasV1beta1VulnerabilityDetailsResponse {
		return *v
	}).(GrafeasV1beta1VulnerabilityDetailsResponseOutput)
}

// The CVSS score of this vulnerability. CVSS score is on a scale of 0-10 where 0 indicates low severity and 10 indicates high severity.
func (o GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput) CvssScore() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1VulnerabilityDetailsResponse) *float64 {
		if v == nil {
			return nil
		}
		return &v.CvssScore
	}).(pulumi.Float64PtrOutput)
}

// The distro assigned severity for this vulnerability when it is available, and note provider assigned severity when distro has not yet assigned a severity for this vulnerability. When there are multiple PackageIssues for this vulnerability, they can have different effective severities because some might be provided by the distro while others are provided by the language ecosystem for a language pack. For this reason, it is advised to use the effective severity on the PackageIssue level. In the case where multiple PackageIssues have differing effective severities, this field should be the highest severity for any of the PackageIssues.
func (o GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput) EffectiveSeverity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1VulnerabilityDetailsResponse) *string {
		if v == nil {
			return nil
		}
		return &v.EffectiveSeverity
	}).(pulumi.StringPtrOutput)
}

// A detailed description of this vulnerability.
func (o GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput) LongDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1VulnerabilityDetailsResponse) *string {
		if v == nil {
			return nil
		}
		return &v.LongDescription
	}).(pulumi.StringPtrOutput)
}

// The set of affected locations and their fixes (if available) within the associated resource.
func (o GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput) PackageIssue() PackageIssueResponseArrayOutput {
	return o.ApplyT(func(v *GrafeasV1beta1VulnerabilityDetailsResponse) []PackageIssueResponse {
		if v == nil {
			return nil
		}
		return v.PackageIssue
	}).(PackageIssueResponseArrayOutput)
}

// URLs related to this vulnerability.
func (o GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput) RelatedUrls() RelatedUrlResponseArrayOutput {
	return o.ApplyT(func(v *GrafeasV1beta1VulnerabilityDetailsResponse) []RelatedUrlResponse {
		if v == nil {
			return nil
		}
		return v.RelatedUrls
	}).(RelatedUrlResponseArrayOutput)
}

// The note provider assigned Severity of the vulnerability.
func (o GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput) Severity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1VulnerabilityDetailsResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Severity
	}).(pulumi.StringPtrOutput)
}

// A one sentence description of this vulnerability.
func (o GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput) ShortDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1VulnerabilityDetailsResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ShortDescription
	}).(pulumi.StringPtrOutput)
}

// The type of package; whether native or non native(ruby gems, node.js packages etc)
func (o GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GrafeasV1beta1VulnerabilityDetailsResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// This submessage provides human-readable hints about the purpose of the authority. Because the name of a note acts as its resource reference, it is important to disambiguate the canonical name of the Note (which might be a UUID for security purposes) from "readable" names more suitable for debug output. Note that these hints should not be used to look up authorities in security sensitive contexts, such as when looking up attestations to verify.
type Hint struct {
	// The human readable name of this attestation authority, for example "qa".
	HumanReadableName string `pulumi:"humanReadableName"`
}

// HintInput is an input type that accepts HintArgs and HintOutput values.
// You can construct a concrete instance of `HintInput` via:
//
//          HintArgs{...}
type HintInput interface {
	pulumi.Input

	ToHintOutput() HintOutput
	ToHintOutputWithContext(context.Context) HintOutput
}

// This submessage provides human-readable hints about the purpose of the authority. Because the name of a note acts as its resource reference, it is important to disambiguate the canonical name of the Note (which might be a UUID for security purposes) from "readable" names more suitable for debug output. Note that these hints should not be used to look up authorities in security sensitive contexts, such as when looking up attestations to verify.
type HintArgs struct {
	// The human readable name of this attestation authority, for example "qa".
	HumanReadableName pulumi.StringInput `pulumi:"humanReadableName"`
}

func (HintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Hint)(nil)).Elem()
}

func (i HintArgs) ToHintOutput() HintOutput {
	return i.ToHintOutputWithContext(context.Background())
}

func (i HintArgs) ToHintOutputWithContext(ctx context.Context) HintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HintOutput)
}

func (i HintArgs) ToHintPtrOutput() HintPtrOutput {
	return i.ToHintPtrOutputWithContext(context.Background())
}

func (i HintArgs) ToHintPtrOutputWithContext(ctx context.Context) HintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HintOutput).ToHintPtrOutputWithContext(ctx)
}

// HintPtrInput is an input type that accepts HintArgs, HintPtr and HintPtrOutput values.
// You can construct a concrete instance of `HintPtrInput` via:
//
//          HintArgs{...}
//
//  or:
//
//          nil
type HintPtrInput interface {
	pulumi.Input

	ToHintPtrOutput() HintPtrOutput
	ToHintPtrOutputWithContext(context.Context) HintPtrOutput
}

type hintPtrType HintArgs

func HintPtr(v *HintArgs) HintPtrInput {
	return (*hintPtrType)(v)
}

func (*hintPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Hint)(nil)).Elem()
}

func (i *hintPtrType) ToHintPtrOutput() HintPtrOutput {
	return i.ToHintPtrOutputWithContext(context.Background())
}

func (i *hintPtrType) ToHintPtrOutputWithContext(ctx context.Context) HintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HintPtrOutput)
}

// This submessage provides human-readable hints about the purpose of the authority. Because the name of a note acts as its resource reference, it is important to disambiguate the canonical name of the Note (which might be a UUID for security purposes) from "readable" names more suitable for debug output. Note that these hints should not be used to look up authorities in security sensitive contexts, such as when looking up attestations to verify.
type HintOutput struct{ *pulumi.OutputState }

func (HintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hint)(nil)).Elem()
}

func (o HintOutput) ToHintOutput() HintOutput {
	return o
}

func (o HintOutput) ToHintOutputWithContext(ctx context.Context) HintOutput {
	return o
}

func (o HintOutput) ToHintPtrOutput() HintPtrOutput {
	return o.ToHintPtrOutputWithContext(context.Background())
}

func (o HintOutput) ToHintPtrOutputWithContext(ctx context.Context) HintPtrOutput {
	return o.ApplyT(func(v Hint) *Hint {
		return &v
	}).(HintPtrOutput)
}

// The human readable name of this attestation authority, for example "qa".
func (o HintOutput) HumanReadableName() pulumi.StringOutput {
	return o.ApplyT(func(v Hint) string { return v.HumanReadableName }).(pulumi.StringOutput)
}

type HintPtrOutput struct{ *pulumi.OutputState }

func (HintPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Hint)(nil)).Elem()
}

func (o HintPtrOutput) ToHintPtrOutput() HintPtrOutput {
	return o
}

func (o HintPtrOutput) ToHintPtrOutputWithContext(ctx context.Context) HintPtrOutput {
	return o
}

func (o HintPtrOutput) Elem() HintOutput {
	return o.ApplyT(func(v *Hint) Hint { return *v }).(HintOutput)
}

// The human readable name of this attestation authority, for example "qa".
func (o HintPtrOutput) HumanReadableName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Hint) *string {
		if v == nil {
			return nil
		}
		return &v.HumanReadableName
	}).(pulumi.StringPtrOutput)
}

// This submessage provides human-readable hints about the purpose of the authority. Because the name of a note acts as its resource reference, it is important to disambiguate the canonical name of the Note (which might be a UUID for security purposes) from "readable" names more suitable for debug output. Note that these hints should not be used to look up authorities in security sensitive contexts, such as when looking up attestations to verify.
type HintResponse struct {
	// The human readable name of this attestation authority, for example "qa".
	HumanReadableName string `pulumi:"humanReadableName"`
}

// HintResponseInput is an input type that accepts HintResponseArgs and HintResponseOutput values.
// You can construct a concrete instance of `HintResponseInput` via:
//
//          HintResponseArgs{...}
type HintResponseInput interface {
	pulumi.Input

	ToHintResponseOutput() HintResponseOutput
	ToHintResponseOutputWithContext(context.Context) HintResponseOutput
}

// This submessage provides human-readable hints about the purpose of the authority. Because the name of a note acts as its resource reference, it is important to disambiguate the canonical name of the Note (which might be a UUID for security purposes) from "readable" names more suitable for debug output. Note that these hints should not be used to look up authorities in security sensitive contexts, such as when looking up attestations to verify.
type HintResponseArgs struct {
	// The human readable name of this attestation authority, for example "qa".
	HumanReadableName pulumi.StringInput `pulumi:"humanReadableName"`
}

func (HintResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HintResponse)(nil)).Elem()
}

func (i HintResponseArgs) ToHintResponseOutput() HintResponseOutput {
	return i.ToHintResponseOutputWithContext(context.Background())
}

func (i HintResponseArgs) ToHintResponseOutputWithContext(ctx context.Context) HintResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HintResponseOutput)
}

func (i HintResponseArgs) ToHintResponsePtrOutput() HintResponsePtrOutput {
	return i.ToHintResponsePtrOutputWithContext(context.Background())
}

func (i HintResponseArgs) ToHintResponsePtrOutputWithContext(ctx context.Context) HintResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HintResponseOutput).ToHintResponsePtrOutputWithContext(ctx)
}

// HintResponsePtrInput is an input type that accepts HintResponseArgs, HintResponsePtr and HintResponsePtrOutput values.
// You can construct a concrete instance of `HintResponsePtrInput` via:
//
//          HintResponseArgs{...}
//
//  or:
//
//          nil
type HintResponsePtrInput interface {
	pulumi.Input

	ToHintResponsePtrOutput() HintResponsePtrOutput
	ToHintResponsePtrOutputWithContext(context.Context) HintResponsePtrOutput
}

type hintResponsePtrType HintResponseArgs

func HintResponsePtr(v *HintResponseArgs) HintResponsePtrInput {
	return (*hintResponsePtrType)(v)
}

func (*hintResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HintResponse)(nil)).Elem()
}

func (i *hintResponsePtrType) ToHintResponsePtrOutput() HintResponsePtrOutput {
	return i.ToHintResponsePtrOutputWithContext(context.Background())
}

func (i *hintResponsePtrType) ToHintResponsePtrOutputWithContext(ctx context.Context) HintResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HintResponsePtrOutput)
}

// This submessage provides human-readable hints about the purpose of the authority. Because the name of a note acts as its resource reference, it is important to disambiguate the canonical name of the Note (which might be a UUID for security purposes) from "readable" names more suitable for debug output. Note that these hints should not be used to look up authorities in security sensitive contexts, such as when looking up attestations to verify.
type HintResponseOutput struct{ *pulumi.OutputState }

func (HintResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HintResponse)(nil)).Elem()
}

func (o HintResponseOutput) ToHintResponseOutput() HintResponseOutput {
	return o
}

func (o HintResponseOutput) ToHintResponseOutputWithContext(ctx context.Context) HintResponseOutput {
	return o
}

func (o HintResponseOutput) ToHintResponsePtrOutput() HintResponsePtrOutput {
	return o.ToHintResponsePtrOutputWithContext(context.Background())
}

func (o HintResponseOutput) ToHintResponsePtrOutputWithContext(ctx context.Context) HintResponsePtrOutput {
	return o.ApplyT(func(v HintResponse) *HintResponse {
		return &v
	}).(HintResponsePtrOutput)
}

// The human readable name of this attestation authority, for example "qa".
func (o HintResponseOutput) HumanReadableName() pulumi.StringOutput {
	return o.ApplyT(func(v HintResponse) string { return v.HumanReadableName }).(pulumi.StringOutput)
}

type HintResponsePtrOutput struct{ *pulumi.OutputState }

func (HintResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HintResponse)(nil)).Elem()
}

func (o HintResponsePtrOutput) ToHintResponsePtrOutput() HintResponsePtrOutput {
	return o
}

func (o HintResponsePtrOutput) ToHintResponsePtrOutputWithContext(ctx context.Context) HintResponsePtrOutput {
	return o
}

func (o HintResponsePtrOutput) Elem() HintResponseOutput {
	return o.ApplyT(func(v *HintResponse) HintResponse { return *v }).(HintResponseOutput)
}

// The human readable name of this attestation authority, for example "qa".
func (o HintResponsePtrOutput) HumanReadableName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HintResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HumanReadableName
	}).(pulumi.StringPtrOutput)
}

// This contains the fields corresponding to the definition of a software supply chain step in an in-toto layout. This information goes into a Grafeas note.
type InToto struct {
	// This field contains the expected command used to perform the step.
	ExpectedCommand []string `pulumi:"expectedCommand"`
	// The following fields contain in-toto artifact rules identifying the artifacts that enter this supply chain step, and exit the supply chain step, i.e. materials and products of the step.
	ExpectedMaterials []ArtifactRule `pulumi:"expectedMaterials"`
	ExpectedProducts  []ArtifactRule `pulumi:"expectedProducts"`
	// This field contains the public keys that can be used to verify the signatures on the step metadata.
	SigningKeys []SigningKey `pulumi:"signingKeys"`
	// This field identifies the name of the step in the supply chain.
	StepName *string `pulumi:"stepName"`
	// This field contains a value that indicates the minimum number of keys that need to be used to sign the step's in-toto link.
	Threshold *string `pulumi:"threshold"`
}

// InTotoInput is an input type that accepts InTotoArgs and InTotoOutput values.
// You can construct a concrete instance of `InTotoInput` via:
//
//          InTotoArgs{...}
type InTotoInput interface {
	pulumi.Input

	ToInTotoOutput() InTotoOutput
	ToInTotoOutputWithContext(context.Context) InTotoOutput
}

// This contains the fields corresponding to the definition of a software supply chain step in an in-toto layout. This information goes into a Grafeas note.
type InTotoArgs struct {
	// This field contains the expected command used to perform the step.
	ExpectedCommand pulumi.StringArrayInput `pulumi:"expectedCommand"`
	// The following fields contain in-toto artifact rules identifying the artifacts that enter this supply chain step, and exit the supply chain step, i.e. materials and products of the step.
	ExpectedMaterials ArtifactRuleArrayInput `pulumi:"expectedMaterials"`
	ExpectedProducts  ArtifactRuleArrayInput `pulumi:"expectedProducts"`
	// This field contains the public keys that can be used to verify the signatures on the step metadata.
	SigningKeys SigningKeyArrayInput `pulumi:"signingKeys"`
	// This field identifies the name of the step in the supply chain.
	StepName pulumi.StringPtrInput `pulumi:"stepName"`
	// This field contains a value that indicates the minimum number of keys that need to be used to sign the step's in-toto link.
	Threshold pulumi.StringPtrInput `pulumi:"threshold"`
}

func (InTotoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InToto)(nil)).Elem()
}

func (i InTotoArgs) ToInTotoOutput() InTotoOutput {
	return i.ToInTotoOutputWithContext(context.Background())
}

func (i InTotoArgs) ToInTotoOutputWithContext(ctx context.Context) InTotoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InTotoOutput)
}

func (i InTotoArgs) ToInTotoPtrOutput() InTotoPtrOutput {
	return i.ToInTotoPtrOutputWithContext(context.Background())
}

func (i InTotoArgs) ToInTotoPtrOutputWithContext(ctx context.Context) InTotoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InTotoOutput).ToInTotoPtrOutputWithContext(ctx)
}

// InTotoPtrInput is an input type that accepts InTotoArgs, InTotoPtr and InTotoPtrOutput values.
// You can construct a concrete instance of `InTotoPtrInput` via:
//
//          InTotoArgs{...}
//
//  or:
//
//          nil
type InTotoPtrInput interface {
	pulumi.Input

	ToInTotoPtrOutput() InTotoPtrOutput
	ToInTotoPtrOutputWithContext(context.Context) InTotoPtrOutput
}

type inTotoPtrType InTotoArgs

func InTotoPtr(v *InTotoArgs) InTotoPtrInput {
	return (*inTotoPtrType)(v)
}

func (*inTotoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InToto)(nil)).Elem()
}

func (i *inTotoPtrType) ToInTotoPtrOutput() InTotoPtrOutput {
	return i.ToInTotoPtrOutputWithContext(context.Background())
}

func (i *inTotoPtrType) ToInTotoPtrOutputWithContext(ctx context.Context) InTotoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InTotoPtrOutput)
}

// This contains the fields corresponding to the definition of a software supply chain step in an in-toto layout. This information goes into a Grafeas note.
type InTotoOutput struct{ *pulumi.OutputState }

func (InTotoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InToto)(nil)).Elem()
}

func (o InTotoOutput) ToInTotoOutput() InTotoOutput {
	return o
}

func (o InTotoOutput) ToInTotoOutputWithContext(ctx context.Context) InTotoOutput {
	return o
}

func (o InTotoOutput) ToInTotoPtrOutput() InTotoPtrOutput {
	return o.ToInTotoPtrOutputWithContext(context.Background())
}

func (o InTotoOutput) ToInTotoPtrOutputWithContext(ctx context.Context) InTotoPtrOutput {
	return o.ApplyT(func(v InToto) *InToto {
		return &v
	}).(InTotoPtrOutput)
}

// This field contains the expected command used to perform the step.
func (o InTotoOutput) ExpectedCommand() pulumi.StringArrayOutput {
	return o.ApplyT(func(v InToto) []string { return v.ExpectedCommand }).(pulumi.StringArrayOutput)
}

// The following fields contain in-toto artifact rules identifying the artifacts that enter this supply chain step, and exit the supply chain step, i.e. materials and products of the step.
func (o InTotoOutput) ExpectedMaterials() ArtifactRuleArrayOutput {
	return o.ApplyT(func(v InToto) []ArtifactRule { return v.ExpectedMaterials }).(ArtifactRuleArrayOutput)
}

func (o InTotoOutput) ExpectedProducts() ArtifactRuleArrayOutput {
	return o.ApplyT(func(v InToto) []ArtifactRule { return v.ExpectedProducts }).(ArtifactRuleArrayOutput)
}

// This field contains the public keys that can be used to verify the signatures on the step metadata.
func (o InTotoOutput) SigningKeys() SigningKeyArrayOutput {
	return o.ApplyT(func(v InToto) []SigningKey { return v.SigningKeys }).(SigningKeyArrayOutput)
}

// This field identifies the name of the step in the supply chain.
func (o InTotoOutput) StepName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InToto) *string { return v.StepName }).(pulumi.StringPtrOutput)
}

// This field contains a value that indicates the minimum number of keys that need to be used to sign the step's in-toto link.
func (o InTotoOutput) Threshold() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InToto) *string { return v.Threshold }).(pulumi.StringPtrOutput)
}

type InTotoPtrOutput struct{ *pulumi.OutputState }

func (InTotoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InToto)(nil)).Elem()
}

func (o InTotoPtrOutput) ToInTotoPtrOutput() InTotoPtrOutput {
	return o
}

func (o InTotoPtrOutput) ToInTotoPtrOutputWithContext(ctx context.Context) InTotoPtrOutput {
	return o
}

func (o InTotoPtrOutput) Elem() InTotoOutput {
	return o.ApplyT(func(v *InToto) InToto { return *v }).(InTotoOutput)
}

// This field contains the expected command used to perform the step.
func (o InTotoPtrOutput) ExpectedCommand() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *InToto) []string {
		if v == nil {
			return nil
		}
		return v.ExpectedCommand
	}).(pulumi.StringArrayOutput)
}

// The following fields contain in-toto artifact rules identifying the artifacts that enter this supply chain step, and exit the supply chain step, i.e. materials and products of the step.
func (o InTotoPtrOutput) ExpectedMaterials() ArtifactRuleArrayOutput {
	return o.ApplyT(func(v *InToto) []ArtifactRule {
		if v == nil {
			return nil
		}
		return v.ExpectedMaterials
	}).(ArtifactRuleArrayOutput)
}

func (o InTotoPtrOutput) ExpectedProducts() ArtifactRuleArrayOutput {
	return o.ApplyT(func(v *InToto) []ArtifactRule {
		if v == nil {
			return nil
		}
		return v.ExpectedProducts
	}).(ArtifactRuleArrayOutput)
}

// This field contains the public keys that can be used to verify the signatures on the step metadata.
func (o InTotoPtrOutput) SigningKeys() SigningKeyArrayOutput {
	return o.ApplyT(func(v *InToto) []SigningKey {
		if v == nil {
			return nil
		}
		return v.SigningKeys
	}).(SigningKeyArrayOutput)
}

// This field identifies the name of the step in the supply chain.
func (o InTotoPtrOutput) StepName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InToto) *string {
		if v == nil {
			return nil
		}
		return v.StepName
	}).(pulumi.StringPtrOutput)
}

// This field contains a value that indicates the minimum number of keys that need to be used to sign the step's in-toto link.
func (o InTotoPtrOutput) Threshold() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InToto) *string {
		if v == nil {
			return nil
		}
		return v.Threshold
	}).(pulumi.StringPtrOutput)
}

// This contains the fields corresponding to the definition of a software supply chain step in an in-toto layout. This information goes into a Grafeas note.
type InTotoResponse struct {
	// This field contains the expected command used to perform the step.
	ExpectedCommand []string `pulumi:"expectedCommand"`
	// The following fields contain in-toto artifact rules identifying the artifacts that enter this supply chain step, and exit the supply chain step, i.e. materials and products of the step.
	ExpectedMaterials []ArtifactRuleResponse `pulumi:"expectedMaterials"`
	ExpectedProducts  []ArtifactRuleResponse `pulumi:"expectedProducts"`
	// This field contains the public keys that can be used to verify the signatures on the step metadata.
	SigningKeys []SigningKeyResponse `pulumi:"signingKeys"`
	// This field identifies the name of the step in the supply chain.
	StepName string `pulumi:"stepName"`
	// This field contains a value that indicates the minimum number of keys that need to be used to sign the step's in-toto link.
	Threshold string `pulumi:"threshold"`
}

// InTotoResponseInput is an input type that accepts InTotoResponseArgs and InTotoResponseOutput values.
// You can construct a concrete instance of `InTotoResponseInput` via:
//
//          InTotoResponseArgs{...}
type InTotoResponseInput interface {
	pulumi.Input

	ToInTotoResponseOutput() InTotoResponseOutput
	ToInTotoResponseOutputWithContext(context.Context) InTotoResponseOutput
}

// This contains the fields corresponding to the definition of a software supply chain step in an in-toto layout. This information goes into a Grafeas note.
type InTotoResponseArgs struct {
	// This field contains the expected command used to perform the step.
	ExpectedCommand pulumi.StringArrayInput `pulumi:"expectedCommand"`
	// The following fields contain in-toto artifact rules identifying the artifacts that enter this supply chain step, and exit the supply chain step, i.e. materials and products of the step.
	ExpectedMaterials ArtifactRuleResponseArrayInput `pulumi:"expectedMaterials"`
	ExpectedProducts  ArtifactRuleResponseArrayInput `pulumi:"expectedProducts"`
	// This field contains the public keys that can be used to verify the signatures on the step metadata.
	SigningKeys SigningKeyResponseArrayInput `pulumi:"signingKeys"`
	// This field identifies the name of the step in the supply chain.
	StepName pulumi.StringInput `pulumi:"stepName"`
	// This field contains a value that indicates the minimum number of keys that need to be used to sign the step's in-toto link.
	Threshold pulumi.StringInput `pulumi:"threshold"`
}

func (InTotoResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InTotoResponse)(nil)).Elem()
}

func (i InTotoResponseArgs) ToInTotoResponseOutput() InTotoResponseOutput {
	return i.ToInTotoResponseOutputWithContext(context.Background())
}

func (i InTotoResponseArgs) ToInTotoResponseOutputWithContext(ctx context.Context) InTotoResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InTotoResponseOutput)
}

func (i InTotoResponseArgs) ToInTotoResponsePtrOutput() InTotoResponsePtrOutput {
	return i.ToInTotoResponsePtrOutputWithContext(context.Background())
}

func (i InTotoResponseArgs) ToInTotoResponsePtrOutputWithContext(ctx context.Context) InTotoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InTotoResponseOutput).ToInTotoResponsePtrOutputWithContext(ctx)
}

// InTotoResponsePtrInput is an input type that accepts InTotoResponseArgs, InTotoResponsePtr and InTotoResponsePtrOutput values.
// You can construct a concrete instance of `InTotoResponsePtrInput` via:
//
//          InTotoResponseArgs{...}
//
//  or:
//
//          nil
type InTotoResponsePtrInput interface {
	pulumi.Input

	ToInTotoResponsePtrOutput() InTotoResponsePtrOutput
	ToInTotoResponsePtrOutputWithContext(context.Context) InTotoResponsePtrOutput
}

type inTotoResponsePtrType InTotoResponseArgs

func InTotoResponsePtr(v *InTotoResponseArgs) InTotoResponsePtrInput {
	return (*inTotoResponsePtrType)(v)
}

func (*inTotoResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InTotoResponse)(nil)).Elem()
}

func (i *inTotoResponsePtrType) ToInTotoResponsePtrOutput() InTotoResponsePtrOutput {
	return i.ToInTotoResponsePtrOutputWithContext(context.Background())
}

func (i *inTotoResponsePtrType) ToInTotoResponsePtrOutputWithContext(ctx context.Context) InTotoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InTotoResponsePtrOutput)
}

// This contains the fields corresponding to the definition of a software supply chain step in an in-toto layout. This information goes into a Grafeas note.
type InTotoResponseOutput struct{ *pulumi.OutputState }

func (InTotoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InTotoResponse)(nil)).Elem()
}

func (o InTotoResponseOutput) ToInTotoResponseOutput() InTotoResponseOutput {
	return o
}

func (o InTotoResponseOutput) ToInTotoResponseOutputWithContext(ctx context.Context) InTotoResponseOutput {
	return o
}

func (o InTotoResponseOutput) ToInTotoResponsePtrOutput() InTotoResponsePtrOutput {
	return o.ToInTotoResponsePtrOutputWithContext(context.Background())
}

func (o InTotoResponseOutput) ToInTotoResponsePtrOutputWithContext(ctx context.Context) InTotoResponsePtrOutput {
	return o.ApplyT(func(v InTotoResponse) *InTotoResponse {
		return &v
	}).(InTotoResponsePtrOutput)
}

// This field contains the expected command used to perform the step.
func (o InTotoResponseOutput) ExpectedCommand() pulumi.StringArrayOutput {
	return o.ApplyT(func(v InTotoResponse) []string { return v.ExpectedCommand }).(pulumi.StringArrayOutput)
}

// The following fields contain in-toto artifact rules identifying the artifacts that enter this supply chain step, and exit the supply chain step, i.e. materials and products of the step.
func (o InTotoResponseOutput) ExpectedMaterials() ArtifactRuleResponseArrayOutput {
	return o.ApplyT(func(v InTotoResponse) []ArtifactRuleResponse { return v.ExpectedMaterials }).(ArtifactRuleResponseArrayOutput)
}

func (o InTotoResponseOutput) ExpectedProducts() ArtifactRuleResponseArrayOutput {
	return o.ApplyT(func(v InTotoResponse) []ArtifactRuleResponse { return v.ExpectedProducts }).(ArtifactRuleResponseArrayOutput)
}

// This field contains the public keys that can be used to verify the signatures on the step metadata.
func (o InTotoResponseOutput) SigningKeys() SigningKeyResponseArrayOutput {
	return o.ApplyT(func(v InTotoResponse) []SigningKeyResponse { return v.SigningKeys }).(SigningKeyResponseArrayOutput)
}

// This field identifies the name of the step in the supply chain.
func (o InTotoResponseOutput) StepName() pulumi.StringOutput {
	return o.ApplyT(func(v InTotoResponse) string { return v.StepName }).(pulumi.StringOutput)
}

// This field contains a value that indicates the minimum number of keys that need to be used to sign the step's in-toto link.
func (o InTotoResponseOutput) Threshold() pulumi.StringOutput {
	return o.ApplyT(func(v InTotoResponse) string { return v.Threshold }).(pulumi.StringOutput)
}

type InTotoResponsePtrOutput struct{ *pulumi.OutputState }

func (InTotoResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InTotoResponse)(nil)).Elem()
}

func (o InTotoResponsePtrOutput) ToInTotoResponsePtrOutput() InTotoResponsePtrOutput {
	return o
}

func (o InTotoResponsePtrOutput) ToInTotoResponsePtrOutputWithContext(ctx context.Context) InTotoResponsePtrOutput {
	return o
}

func (o InTotoResponsePtrOutput) Elem() InTotoResponseOutput {
	return o.ApplyT(func(v *InTotoResponse) InTotoResponse { return *v }).(InTotoResponseOutput)
}

// This field contains the expected command used to perform the step.
func (o InTotoResponsePtrOutput) ExpectedCommand() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *InTotoResponse) []string {
		if v == nil {
			return nil
		}
		return v.ExpectedCommand
	}).(pulumi.StringArrayOutput)
}

// The following fields contain in-toto artifact rules identifying the artifacts that enter this supply chain step, and exit the supply chain step, i.e. materials and products of the step.
func (o InTotoResponsePtrOutput) ExpectedMaterials() ArtifactRuleResponseArrayOutput {
	return o.ApplyT(func(v *InTotoResponse) []ArtifactRuleResponse {
		if v == nil {
			return nil
		}
		return v.ExpectedMaterials
	}).(ArtifactRuleResponseArrayOutput)
}

func (o InTotoResponsePtrOutput) ExpectedProducts() ArtifactRuleResponseArrayOutput {
	return o.ApplyT(func(v *InTotoResponse) []ArtifactRuleResponse {
		if v == nil {
			return nil
		}
		return v.ExpectedProducts
	}).(ArtifactRuleResponseArrayOutput)
}

// This field contains the public keys that can be used to verify the signatures on the step metadata.
func (o InTotoResponsePtrOutput) SigningKeys() SigningKeyResponseArrayOutput {
	return o.ApplyT(func(v *InTotoResponse) []SigningKeyResponse {
		if v == nil {
			return nil
		}
		return v.SigningKeys
	}).(SigningKeyResponseArrayOutput)
}

// This field identifies the name of the step in the supply chain.
func (o InTotoResponsePtrOutput) StepName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InTotoResponse) *string {
		if v == nil {
			return nil
		}
		return &v.StepName
	}).(pulumi.StringPtrOutput)
}

// This field contains a value that indicates the minimum number of keys that need to be used to sign the step's in-toto link.
func (o InTotoResponsePtrOutput) Threshold() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InTotoResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Threshold
	}).(pulumi.StringPtrOutput)
}

// This represents how a particular software package may be installed on a system.
type Installation struct {
	// All of the places within the filesystem versions of this package have been found.
	Location []Location `pulumi:"location"`
}

// InstallationInput is an input type that accepts InstallationArgs and InstallationOutput values.
// You can construct a concrete instance of `InstallationInput` via:
//
//          InstallationArgs{...}
type InstallationInput interface {
	pulumi.Input

	ToInstallationOutput() InstallationOutput
	ToInstallationOutputWithContext(context.Context) InstallationOutput
}

// This represents how a particular software package may be installed on a system.
type InstallationArgs struct {
	// All of the places within the filesystem versions of this package have been found.
	Location LocationArrayInput `pulumi:"location"`
}

func (InstallationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Installation)(nil)).Elem()
}

func (i InstallationArgs) ToInstallationOutput() InstallationOutput {
	return i.ToInstallationOutputWithContext(context.Background())
}

func (i InstallationArgs) ToInstallationOutputWithContext(ctx context.Context) InstallationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstallationOutput)
}

func (i InstallationArgs) ToInstallationPtrOutput() InstallationPtrOutput {
	return i.ToInstallationPtrOutputWithContext(context.Background())
}

func (i InstallationArgs) ToInstallationPtrOutputWithContext(ctx context.Context) InstallationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstallationOutput).ToInstallationPtrOutputWithContext(ctx)
}

// InstallationPtrInput is an input type that accepts InstallationArgs, InstallationPtr and InstallationPtrOutput values.
// You can construct a concrete instance of `InstallationPtrInput` via:
//
//          InstallationArgs{...}
//
//  or:
//
//          nil
type InstallationPtrInput interface {
	pulumi.Input

	ToInstallationPtrOutput() InstallationPtrOutput
	ToInstallationPtrOutputWithContext(context.Context) InstallationPtrOutput
}

type installationPtrType InstallationArgs

func InstallationPtr(v *InstallationArgs) InstallationPtrInput {
	return (*installationPtrType)(v)
}

func (*installationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Installation)(nil)).Elem()
}

func (i *installationPtrType) ToInstallationPtrOutput() InstallationPtrOutput {
	return i.ToInstallationPtrOutputWithContext(context.Background())
}

func (i *installationPtrType) ToInstallationPtrOutputWithContext(ctx context.Context) InstallationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstallationPtrOutput)
}

// This represents how a particular software package may be installed on a system.
type InstallationOutput struct{ *pulumi.OutputState }

func (InstallationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Installation)(nil)).Elem()
}

func (o InstallationOutput) ToInstallationOutput() InstallationOutput {
	return o
}

func (o InstallationOutput) ToInstallationOutputWithContext(ctx context.Context) InstallationOutput {
	return o
}

func (o InstallationOutput) ToInstallationPtrOutput() InstallationPtrOutput {
	return o.ToInstallationPtrOutputWithContext(context.Background())
}

func (o InstallationOutput) ToInstallationPtrOutputWithContext(ctx context.Context) InstallationPtrOutput {
	return o.ApplyT(func(v Installation) *Installation {
		return &v
	}).(InstallationPtrOutput)
}

// All of the places within the filesystem versions of this package have been found.
func (o InstallationOutput) Location() LocationArrayOutput {
	return o.ApplyT(func(v Installation) []Location { return v.Location }).(LocationArrayOutput)
}

type InstallationPtrOutput struct{ *pulumi.OutputState }

func (InstallationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Installation)(nil)).Elem()
}

func (o InstallationPtrOutput) ToInstallationPtrOutput() InstallationPtrOutput {
	return o
}

func (o InstallationPtrOutput) ToInstallationPtrOutputWithContext(ctx context.Context) InstallationPtrOutput {
	return o
}

func (o InstallationPtrOutput) Elem() InstallationOutput {
	return o.ApplyT(func(v *Installation) Installation { return *v }).(InstallationOutput)
}

// All of the places within the filesystem versions of this package have been found.
func (o InstallationPtrOutput) Location() LocationArrayOutput {
	return o.ApplyT(func(v *Installation) []Location {
		if v == nil {
			return nil
		}
		return v.Location
	}).(LocationArrayOutput)
}

// This represents how a particular software package may be installed on a system.
type InstallationResponse struct {
	// All of the places within the filesystem versions of this package have been found.
	Location []LocationResponse `pulumi:"location"`
	// The name of the installed package.
	Name string `pulumi:"name"`
}

// InstallationResponseInput is an input type that accepts InstallationResponseArgs and InstallationResponseOutput values.
// You can construct a concrete instance of `InstallationResponseInput` via:
//
//          InstallationResponseArgs{...}
type InstallationResponseInput interface {
	pulumi.Input

	ToInstallationResponseOutput() InstallationResponseOutput
	ToInstallationResponseOutputWithContext(context.Context) InstallationResponseOutput
}

// This represents how a particular software package may be installed on a system.
type InstallationResponseArgs struct {
	// All of the places within the filesystem versions of this package have been found.
	Location LocationResponseArrayInput `pulumi:"location"`
	// The name of the installed package.
	Name pulumi.StringInput `pulumi:"name"`
}

func (InstallationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstallationResponse)(nil)).Elem()
}

func (i InstallationResponseArgs) ToInstallationResponseOutput() InstallationResponseOutput {
	return i.ToInstallationResponseOutputWithContext(context.Background())
}

func (i InstallationResponseArgs) ToInstallationResponseOutputWithContext(ctx context.Context) InstallationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstallationResponseOutput)
}

func (i InstallationResponseArgs) ToInstallationResponsePtrOutput() InstallationResponsePtrOutput {
	return i.ToInstallationResponsePtrOutputWithContext(context.Background())
}

func (i InstallationResponseArgs) ToInstallationResponsePtrOutputWithContext(ctx context.Context) InstallationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstallationResponseOutput).ToInstallationResponsePtrOutputWithContext(ctx)
}

// InstallationResponsePtrInput is an input type that accepts InstallationResponseArgs, InstallationResponsePtr and InstallationResponsePtrOutput values.
// You can construct a concrete instance of `InstallationResponsePtrInput` via:
//
//          InstallationResponseArgs{...}
//
//  or:
//
//          nil
type InstallationResponsePtrInput interface {
	pulumi.Input

	ToInstallationResponsePtrOutput() InstallationResponsePtrOutput
	ToInstallationResponsePtrOutputWithContext(context.Context) InstallationResponsePtrOutput
}

type installationResponsePtrType InstallationResponseArgs

func InstallationResponsePtr(v *InstallationResponseArgs) InstallationResponsePtrInput {
	return (*installationResponsePtrType)(v)
}

func (*installationResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InstallationResponse)(nil)).Elem()
}

func (i *installationResponsePtrType) ToInstallationResponsePtrOutput() InstallationResponsePtrOutput {
	return i.ToInstallationResponsePtrOutputWithContext(context.Background())
}

func (i *installationResponsePtrType) ToInstallationResponsePtrOutputWithContext(ctx context.Context) InstallationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstallationResponsePtrOutput)
}

// This represents how a particular software package may be installed on a system.
type InstallationResponseOutput struct{ *pulumi.OutputState }

func (InstallationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstallationResponse)(nil)).Elem()
}

func (o InstallationResponseOutput) ToInstallationResponseOutput() InstallationResponseOutput {
	return o
}

func (o InstallationResponseOutput) ToInstallationResponseOutputWithContext(ctx context.Context) InstallationResponseOutput {
	return o
}

func (o InstallationResponseOutput) ToInstallationResponsePtrOutput() InstallationResponsePtrOutput {
	return o.ToInstallationResponsePtrOutputWithContext(context.Background())
}

func (o InstallationResponseOutput) ToInstallationResponsePtrOutputWithContext(ctx context.Context) InstallationResponsePtrOutput {
	return o.ApplyT(func(v InstallationResponse) *InstallationResponse {
		return &v
	}).(InstallationResponsePtrOutput)
}

// All of the places within the filesystem versions of this package have been found.
func (o InstallationResponseOutput) Location() LocationResponseArrayOutput {
	return o.ApplyT(func(v InstallationResponse) []LocationResponse { return v.Location }).(LocationResponseArrayOutput)
}

// The name of the installed package.
func (o InstallationResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v InstallationResponse) string { return v.Name }).(pulumi.StringOutput)
}

type InstallationResponsePtrOutput struct{ *pulumi.OutputState }

func (InstallationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InstallationResponse)(nil)).Elem()
}

func (o InstallationResponsePtrOutput) ToInstallationResponsePtrOutput() InstallationResponsePtrOutput {
	return o
}

func (o InstallationResponsePtrOutput) ToInstallationResponsePtrOutputWithContext(ctx context.Context) InstallationResponsePtrOutput {
	return o
}

func (o InstallationResponsePtrOutput) Elem() InstallationResponseOutput {
	return o.ApplyT(func(v *InstallationResponse) InstallationResponse { return *v }).(InstallationResponseOutput)
}

// All of the places within the filesystem versions of this package have been found.
func (o InstallationResponsePtrOutput) Location() LocationResponseArrayOutput {
	return o.ApplyT(func(v *InstallationResponse) []LocationResponse {
		if v == nil {
			return nil
		}
		return v.Location
	}).(LocationResponseArrayOutput)
}

// The name of the installed package.
func (o InstallationResponsePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InstallationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

type KnowledgeBase struct {
	// The KB name (generally of the form KB[0-9]+ i.e. KB123456).
	Name *string `pulumi:"name"`
	// A link to the KB in the Windows update catalog - https://www.catalog.update.microsoft.com/
	Url *string `pulumi:"url"`
}

// KnowledgeBaseInput is an input type that accepts KnowledgeBaseArgs and KnowledgeBaseOutput values.
// You can construct a concrete instance of `KnowledgeBaseInput` via:
//
//          KnowledgeBaseArgs{...}
type KnowledgeBaseInput interface {
	pulumi.Input

	ToKnowledgeBaseOutput() KnowledgeBaseOutput
	ToKnowledgeBaseOutputWithContext(context.Context) KnowledgeBaseOutput
}

type KnowledgeBaseArgs struct {
	// The KB name (generally of the form KB[0-9]+ i.e. KB123456).
	Name pulumi.StringPtrInput `pulumi:"name"`
	// A link to the KB in the Windows update catalog - https://www.catalog.update.microsoft.com/
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (KnowledgeBaseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KnowledgeBase)(nil)).Elem()
}

func (i KnowledgeBaseArgs) ToKnowledgeBaseOutput() KnowledgeBaseOutput {
	return i.ToKnowledgeBaseOutputWithContext(context.Background())
}

func (i KnowledgeBaseArgs) ToKnowledgeBaseOutputWithContext(ctx context.Context) KnowledgeBaseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KnowledgeBaseOutput)
}

// KnowledgeBaseArrayInput is an input type that accepts KnowledgeBaseArray and KnowledgeBaseArrayOutput values.
// You can construct a concrete instance of `KnowledgeBaseArrayInput` via:
//
//          KnowledgeBaseArray{ KnowledgeBaseArgs{...} }
type KnowledgeBaseArrayInput interface {
	pulumi.Input

	ToKnowledgeBaseArrayOutput() KnowledgeBaseArrayOutput
	ToKnowledgeBaseArrayOutputWithContext(context.Context) KnowledgeBaseArrayOutput
}

type KnowledgeBaseArray []KnowledgeBaseInput

func (KnowledgeBaseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KnowledgeBase)(nil)).Elem()
}

func (i KnowledgeBaseArray) ToKnowledgeBaseArrayOutput() KnowledgeBaseArrayOutput {
	return i.ToKnowledgeBaseArrayOutputWithContext(context.Background())
}

func (i KnowledgeBaseArray) ToKnowledgeBaseArrayOutputWithContext(ctx context.Context) KnowledgeBaseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KnowledgeBaseArrayOutput)
}

type KnowledgeBaseOutput struct{ *pulumi.OutputState }

func (KnowledgeBaseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KnowledgeBase)(nil)).Elem()
}

func (o KnowledgeBaseOutput) ToKnowledgeBaseOutput() KnowledgeBaseOutput {
	return o
}

func (o KnowledgeBaseOutput) ToKnowledgeBaseOutputWithContext(ctx context.Context) KnowledgeBaseOutput {
	return o
}

// The KB name (generally of the form KB[0-9]+ i.e. KB123456).
func (o KnowledgeBaseOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KnowledgeBase) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// A link to the KB in the Windows update catalog - https://www.catalog.update.microsoft.com/
func (o KnowledgeBaseOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KnowledgeBase) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type KnowledgeBaseArrayOutput struct{ *pulumi.OutputState }

func (KnowledgeBaseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KnowledgeBase)(nil)).Elem()
}

func (o KnowledgeBaseArrayOutput) ToKnowledgeBaseArrayOutput() KnowledgeBaseArrayOutput {
	return o
}

func (o KnowledgeBaseArrayOutput) ToKnowledgeBaseArrayOutputWithContext(ctx context.Context) KnowledgeBaseArrayOutput {
	return o
}

func (o KnowledgeBaseArrayOutput) Index(i pulumi.IntInput) KnowledgeBaseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KnowledgeBase {
		return vs[0].([]KnowledgeBase)[vs[1].(int)]
	}).(KnowledgeBaseOutput)
}

type KnowledgeBaseResponse struct {
	// The KB name (generally of the form KB[0-9]+ i.e. KB123456).
	Name string `pulumi:"name"`
	// A link to the KB in the Windows update catalog - https://www.catalog.update.microsoft.com/
	Url string `pulumi:"url"`
}

// KnowledgeBaseResponseInput is an input type that accepts KnowledgeBaseResponseArgs and KnowledgeBaseResponseOutput values.
// You can construct a concrete instance of `KnowledgeBaseResponseInput` via:
//
//          KnowledgeBaseResponseArgs{...}
type KnowledgeBaseResponseInput interface {
	pulumi.Input

	ToKnowledgeBaseResponseOutput() KnowledgeBaseResponseOutput
	ToKnowledgeBaseResponseOutputWithContext(context.Context) KnowledgeBaseResponseOutput
}

type KnowledgeBaseResponseArgs struct {
	// The KB name (generally of the form KB[0-9]+ i.e. KB123456).
	Name pulumi.StringInput `pulumi:"name"`
	// A link to the KB in the Windows update catalog - https://www.catalog.update.microsoft.com/
	Url pulumi.StringInput `pulumi:"url"`
}

func (KnowledgeBaseResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KnowledgeBaseResponse)(nil)).Elem()
}

func (i KnowledgeBaseResponseArgs) ToKnowledgeBaseResponseOutput() KnowledgeBaseResponseOutput {
	return i.ToKnowledgeBaseResponseOutputWithContext(context.Background())
}

func (i KnowledgeBaseResponseArgs) ToKnowledgeBaseResponseOutputWithContext(ctx context.Context) KnowledgeBaseResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KnowledgeBaseResponseOutput)
}

// KnowledgeBaseResponseArrayInput is an input type that accepts KnowledgeBaseResponseArray and KnowledgeBaseResponseArrayOutput values.
// You can construct a concrete instance of `KnowledgeBaseResponseArrayInput` via:
//
//          KnowledgeBaseResponseArray{ KnowledgeBaseResponseArgs{...} }
type KnowledgeBaseResponseArrayInput interface {
	pulumi.Input

	ToKnowledgeBaseResponseArrayOutput() KnowledgeBaseResponseArrayOutput
	ToKnowledgeBaseResponseArrayOutputWithContext(context.Context) KnowledgeBaseResponseArrayOutput
}

type KnowledgeBaseResponseArray []KnowledgeBaseResponseInput

func (KnowledgeBaseResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KnowledgeBaseResponse)(nil)).Elem()
}

func (i KnowledgeBaseResponseArray) ToKnowledgeBaseResponseArrayOutput() KnowledgeBaseResponseArrayOutput {
	return i.ToKnowledgeBaseResponseArrayOutputWithContext(context.Background())
}

func (i KnowledgeBaseResponseArray) ToKnowledgeBaseResponseArrayOutputWithContext(ctx context.Context) KnowledgeBaseResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KnowledgeBaseResponseArrayOutput)
}

type KnowledgeBaseResponseOutput struct{ *pulumi.OutputState }

func (KnowledgeBaseResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KnowledgeBaseResponse)(nil)).Elem()
}

func (o KnowledgeBaseResponseOutput) ToKnowledgeBaseResponseOutput() KnowledgeBaseResponseOutput {
	return o
}

func (o KnowledgeBaseResponseOutput) ToKnowledgeBaseResponseOutputWithContext(ctx context.Context) KnowledgeBaseResponseOutput {
	return o
}

// The KB name (generally of the form KB[0-9]+ i.e. KB123456).
func (o KnowledgeBaseResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v KnowledgeBaseResponse) string { return v.Name }).(pulumi.StringOutput)
}

// A link to the KB in the Windows update catalog - https://www.catalog.update.microsoft.com/
func (o KnowledgeBaseResponseOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v KnowledgeBaseResponse) string { return v.Url }).(pulumi.StringOutput)
}

type KnowledgeBaseResponseArrayOutput struct{ *pulumi.OutputState }

func (KnowledgeBaseResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KnowledgeBaseResponse)(nil)).Elem()
}

func (o KnowledgeBaseResponseArrayOutput) ToKnowledgeBaseResponseArrayOutput() KnowledgeBaseResponseArrayOutput {
	return o
}

func (o KnowledgeBaseResponseArrayOutput) ToKnowledgeBaseResponseArrayOutputWithContext(ctx context.Context) KnowledgeBaseResponseArrayOutput {
	return o
}

func (o KnowledgeBaseResponseArrayOutput) Index(i pulumi.IntInput) KnowledgeBaseResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KnowledgeBaseResponse {
		return vs[0].([]KnowledgeBaseResponse)[vs[1].(int)]
	}).(KnowledgeBaseResponseOutput)
}

// Layer holds metadata specific to a layer of a Docker image.
type Layer struct {
	// The recovered arguments to the Dockerfile directive.
	Arguments *string `pulumi:"arguments"`
	// The recovered Dockerfile directive used to construct this layer.
	Directive LayerDirective `pulumi:"directive"`
}

// LayerInput is an input type that accepts LayerArgs and LayerOutput values.
// You can construct a concrete instance of `LayerInput` via:
//
//          LayerArgs{...}
type LayerInput interface {
	pulumi.Input

	ToLayerOutput() LayerOutput
	ToLayerOutputWithContext(context.Context) LayerOutput
}

// Layer holds metadata specific to a layer of a Docker image.
type LayerArgs struct {
	// The recovered arguments to the Dockerfile directive.
	Arguments pulumi.StringPtrInput `pulumi:"arguments"`
	// The recovered Dockerfile directive used to construct this layer.
	Directive LayerDirectiveInput `pulumi:"directive"`
}

func (LayerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Layer)(nil)).Elem()
}

func (i LayerArgs) ToLayerOutput() LayerOutput {
	return i.ToLayerOutputWithContext(context.Background())
}

func (i LayerArgs) ToLayerOutputWithContext(ctx context.Context) LayerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LayerOutput)
}

// LayerArrayInput is an input type that accepts LayerArray and LayerArrayOutput values.
// You can construct a concrete instance of `LayerArrayInput` via:
//
//          LayerArray{ LayerArgs{...} }
type LayerArrayInput interface {
	pulumi.Input

	ToLayerArrayOutput() LayerArrayOutput
	ToLayerArrayOutputWithContext(context.Context) LayerArrayOutput
}

type LayerArray []LayerInput

func (LayerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Layer)(nil)).Elem()
}

func (i LayerArray) ToLayerArrayOutput() LayerArrayOutput {
	return i.ToLayerArrayOutputWithContext(context.Background())
}

func (i LayerArray) ToLayerArrayOutputWithContext(ctx context.Context) LayerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LayerArrayOutput)
}

// Layer holds metadata specific to a layer of a Docker image.
type LayerOutput struct{ *pulumi.OutputState }

func (LayerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Layer)(nil)).Elem()
}

func (o LayerOutput) ToLayerOutput() LayerOutput {
	return o
}

func (o LayerOutput) ToLayerOutputWithContext(ctx context.Context) LayerOutput {
	return o
}

// The recovered arguments to the Dockerfile directive.
func (o LayerOutput) Arguments() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Layer) *string { return v.Arguments }).(pulumi.StringPtrOutput)
}

// The recovered Dockerfile directive used to construct this layer.
func (o LayerOutput) Directive() LayerDirectiveOutput {
	return o.ApplyT(func(v Layer) LayerDirective { return v.Directive }).(LayerDirectiveOutput)
}

type LayerArrayOutput struct{ *pulumi.OutputState }

func (LayerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Layer)(nil)).Elem()
}

func (o LayerArrayOutput) ToLayerArrayOutput() LayerArrayOutput {
	return o
}

func (o LayerArrayOutput) ToLayerArrayOutputWithContext(ctx context.Context) LayerArrayOutput {
	return o
}

func (o LayerArrayOutput) Index(i pulumi.IntInput) LayerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Layer {
		return vs[0].([]Layer)[vs[1].(int)]
	}).(LayerOutput)
}

// Layer holds metadata specific to a layer of a Docker image.
type LayerResponse struct {
	// The recovered arguments to the Dockerfile directive.
	Arguments string `pulumi:"arguments"`
	// The recovered Dockerfile directive used to construct this layer.
	Directive string `pulumi:"directive"`
}

// LayerResponseInput is an input type that accepts LayerResponseArgs and LayerResponseOutput values.
// You can construct a concrete instance of `LayerResponseInput` via:
//
//          LayerResponseArgs{...}
type LayerResponseInput interface {
	pulumi.Input

	ToLayerResponseOutput() LayerResponseOutput
	ToLayerResponseOutputWithContext(context.Context) LayerResponseOutput
}

// Layer holds metadata specific to a layer of a Docker image.
type LayerResponseArgs struct {
	// The recovered arguments to the Dockerfile directive.
	Arguments pulumi.StringInput `pulumi:"arguments"`
	// The recovered Dockerfile directive used to construct this layer.
	Directive pulumi.StringInput `pulumi:"directive"`
}

func (LayerResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LayerResponse)(nil)).Elem()
}

func (i LayerResponseArgs) ToLayerResponseOutput() LayerResponseOutput {
	return i.ToLayerResponseOutputWithContext(context.Background())
}

func (i LayerResponseArgs) ToLayerResponseOutputWithContext(ctx context.Context) LayerResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LayerResponseOutput)
}

// LayerResponseArrayInput is an input type that accepts LayerResponseArray and LayerResponseArrayOutput values.
// You can construct a concrete instance of `LayerResponseArrayInput` via:
//
//          LayerResponseArray{ LayerResponseArgs{...} }
type LayerResponseArrayInput interface {
	pulumi.Input

	ToLayerResponseArrayOutput() LayerResponseArrayOutput
	ToLayerResponseArrayOutputWithContext(context.Context) LayerResponseArrayOutput
}

type LayerResponseArray []LayerResponseInput

func (LayerResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LayerResponse)(nil)).Elem()
}

func (i LayerResponseArray) ToLayerResponseArrayOutput() LayerResponseArrayOutput {
	return i.ToLayerResponseArrayOutputWithContext(context.Background())
}

func (i LayerResponseArray) ToLayerResponseArrayOutputWithContext(ctx context.Context) LayerResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LayerResponseArrayOutput)
}

// Layer holds metadata specific to a layer of a Docker image.
type LayerResponseOutput struct{ *pulumi.OutputState }

func (LayerResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LayerResponse)(nil)).Elem()
}

func (o LayerResponseOutput) ToLayerResponseOutput() LayerResponseOutput {
	return o
}

func (o LayerResponseOutput) ToLayerResponseOutputWithContext(ctx context.Context) LayerResponseOutput {
	return o
}

// The recovered arguments to the Dockerfile directive.
func (o LayerResponseOutput) Arguments() pulumi.StringOutput {
	return o.ApplyT(func(v LayerResponse) string { return v.Arguments }).(pulumi.StringOutput)
}

// The recovered Dockerfile directive used to construct this layer.
func (o LayerResponseOutput) Directive() pulumi.StringOutput {
	return o.ApplyT(func(v LayerResponse) string { return v.Directive }).(pulumi.StringOutput)
}

type LayerResponseArrayOutput struct{ *pulumi.OutputState }

func (LayerResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LayerResponse)(nil)).Elem()
}

func (o LayerResponseArrayOutput) ToLayerResponseArrayOutput() LayerResponseArrayOutput {
	return o
}

func (o LayerResponseArrayOutput) ToLayerResponseArrayOutputWithContext(ctx context.Context) LayerResponseArrayOutput {
	return o
}

func (o LayerResponseArrayOutput) Index(i pulumi.IntInput) LayerResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LayerResponse {
		return vs[0].([]LayerResponse)[vs[1].(int)]
	}).(LayerResponseOutput)
}

// This corresponds to an in-toto link.
type Link struct {
	// ByProducts are data generated as part of a software supply chain step, but are not the actual result of the step.
	Byproducts *ByProducts `pulumi:"byproducts"`
	// This field contains the full command executed for the step. This can also be empty if links are generated for operations that aren't directly mapped to a specific command. Each term in the command is an independent string in the list. An example of a command in the in-toto metadata field is: "command": ["git", "clone", "https://github.com/in-toto/demo-project.git"]
	Command []string `pulumi:"command"`
	// This is a field that can be used to capture information about the environment. It is suggested for this field to contain information that details environment variables, filesystem information, and the present working directory. The recommended structure of this field is: "environment": { "custom_values": { "variables": "", "filesystem": "", "workdir": "", "": "..." } }
	Environment *Environment `pulumi:"environment"`
	// Materials are the supply chain artifacts that go into the step and are used for the operation performed. The key of the map is the path of the artifact and the structure contains the recorded hash information. An example is: "materials": [ { "resource_uri": "foo/bar", "hashes": { "sha256": "ebebf...", : } } ]
	Materials []GrafeasV1beta1IntotoArtifact `pulumi:"materials"`
	// Products are the supply chain artifacts generated as a result of the step. The structure is identical to that of materials.
	Products []GrafeasV1beta1IntotoArtifact `pulumi:"products"`
}

// LinkInput is an input type that accepts LinkArgs and LinkOutput values.
// You can construct a concrete instance of `LinkInput` via:
//
//          LinkArgs{...}
type LinkInput interface {
	pulumi.Input

	ToLinkOutput() LinkOutput
	ToLinkOutputWithContext(context.Context) LinkOutput
}

// This corresponds to an in-toto link.
type LinkArgs struct {
	// ByProducts are data generated as part of a software supply chain step, but are not the actual result of the step.
	Byproducts ByProductsPtrInput `pulumi:"byproducts"`
	// This field contains the full command executed for the step. This can also be empty if links are generated for operations that aren't directly mapped to a specific command. Each term in the command is an independent string in the list. An example of a command in the in-toto metadata field is: "command": ["git", "clone", "https://github.com/in-toto/demo-project.git"]
	Command pulumi.StringArrayInput `pulumi:"command"`
	// This is a field that can be used to capture information about the environment. It is suggested for this field to contain information that details environment variables, filesystem information, and the present working directory. The recommended structure of this field is: "environment": { "custom_values": { "variables": "", "filesystem": "", "workdir": "", "": "..." } }
	Environment EnvironmentPtrInput `pulumi:"environment"`
	// Materials are the supply chain artifacts that go into the step and are used for the operation performed. The key of the map is the path of the artifact and the structure contains the recorded hash information. An example is: "materials": [ { "resource_uri": "foo/bar", "hashes": { "sha256": "ebebf...", : } } ]
	Materials GrafeasV1beta1IntotoArtifactArrayInput `pulumi:"materials"`
	// Products are the supply chain artifacts generated as a result of the step. The structure is identical to that of materials.
	Products GrafeasV1beta1IntotoArtifactArrayInput `pulumi:"products"`
}

func (LinkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Link)(nil)).Elem()
}

func (i LinkArgs) ToLinkOutput() LinkOutput {
	return i.ToLinkOutputWithContext(context.Background())
}

func (i LinkArgs) ToLinkOutputWithContext(ctx context.Context) LinkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LinkOutput)
}

func (i LinkArgs) ToLinkPtrOutput() LinkPtrOutput {
	return i.ToLinkPtrOutputWithContext(context.Background())
}

func (i LinkArgs) ToLinkPtrOutputWithContext(ctx context.Context) LinkPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LinkOutput).ToLinkPtrOutputWithContext(ctx)
}

// LinkPtrInput is an input type that accepts LinkArgs, LinkPtr and LinkPtrOutput values.
// You can construct a concrete instance of `LinkPtrInput` via:
//
//          LinkArgs{...}
//
//  or:
//
//          nil
type LinkPtrInput interface {
	pulumi.Input

	ToLinkPtrOutput() LinkPtrOutput
	ToLinkPtrOutputWithContext(context.Context) LinkPtrOutput
}

type linkPtrType LinkArgs

func LinkPtr(v *LinkArgs) LinkPtrInput {
	return (*linkPtrType)(v)
}

func (*linkPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Link)(nil)).Elem()
}

func (i *linkPtrType) ToLinkPtrOutput() LinkPtrOutput {
	return i.ToLinkPtrOutputWithContext(context.Background())
}

func (i *linkPtrType) ToLinkPtrOutputWithContext(ctx context.Context) LinkPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LinkPtrOutput)
}

// This corresponds to an in-toto link.
type LinkOutput struct{ *pulumi.OutputState }

func (LinkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Link)(nil)).Elem()
}

func (o LinkOutput) ToLinkOutput() LinkOutput {
	return o
}

func (o LinkOutput) ToLinkOutputWithContext(ctx context.Context) LinkOutput {
	return o
}

func (o LinkOutput) ToLinkPtrOutput() LinkPtrOutput {
	return o.ToLinkPtrOutputWithContext(context.Background())
}

func (o LinkOutput) ToLinkPtrOutputWithContext(ctx context.Context) LinkPtrOutput {
	return o.ApplyT(func(v Link) *Link {
		return &v
	}).(LinkPtrOutput)
}

// ByProducts are data generated as part of a software supply chain step, but are not the actual result of the step.
func (o LinkOutput) Byproducts() ByProductsPtrOutput {
	return o.ApplyT(func(v Link) *ByProducts { return v.Byproducts }).(ByProductsPtrOutput)
}

// This field contains the full command executed for the step. This can also be empty if links are generated for operations that aren't directly mapped to a specific command. Each term in the command is an independent string in the list. An example of a command in the in-toto metadata field is: "command": ["git", "clone", "https://github.com/in-toto/demo-project.git"]
func (o LinkOutput) Command() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Link) []string { return v.Command }).(pulumi.StringArrayOutput)
}

// This is a field that can be used to capture information about the environment. It is suggested for this field to contain information that details environment variables, filesystem information, and the present working directory. The recommended structure of this field is: "environment": { "custom_values": { "variables": "", "filesystem": "", "workdir": "", "": "..." } }
func (o LinkOutput) Environment() EnvironmentPtrOutput {
	return o.ApplyT(func(v Link) *Environment { return v.Environment }).(EnvironmentPtrOutput)
}

// Materials are the supply chain artifacts that go into the step and are used for the operation performed. The key of the map is the path of the artifact and the structure contains the recorded hash information. An example is: "materials": [ { "resource_uri": "foo/bar", "hashes": { "sha256": "ebebf...", : } } ]
func (o LinkOutput) Materials() GrafeasV1beta1IntotoArtifactArrayOutput {
	return o.ApplyT(func(v Link) []GrafeasV1beta1IntotoArtifact { return v.Materials }).(GrafeasV1beta1IntotoArtifactArrayOutput)
}

// Products are the supply chain artifacts generated as a result of the step. The structure is identical to that of materials.
func (o LinkOutput) Products() GrafeasV1beta1IntotoArtifactArrayOutput {
	return o.ApplyT(func(v Link) []GrafeasV1beta1IntotoArtifact { return v.Products }).(GrafeasV1beta1IntotoArtifactArrayOutput)
}

type LinkPtrOutput struct{ *pulumi.OutputState }

func (LinkPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Link)(nil)).Elem()
}

func (o LinkPtrOutput) ToLinkPtrOutput() LinkPtrOutput {
	return o
}

func (o LinkPtrOutput) ToLinkPtrOutputWithContext(ctx context.Context) LinkPtrOutput {
	return o
}

func (o LinkPtrOutput) Elem() LinkOutput {
	return o.ApplyT(func(v *Link) Link { return *v }).(LinkOutput)
}

// ByProducts are data generated as part of a software supply chain step, but are not the actual result of the step.
func (o LinkPtrOutput) Byproducts() ByProductsPtrOutput {
	return o.ApplyT(func(v *Link) *ByProducts {
		if v == nil {
			return nil
		}
		return v.Byproducts
	}).(ByProductsPtrOutput)
}

// This field contains the full command executed for the step. This can also be empty if links are generated for operations that aren't directly mapped to a specific command. Each term in the command is an independent string in the list. An example of a command in the in-toto metadata field is: "command": ["git", "clone", "https://github.com/in-toto/demo-project.git"]
func (o LinkPtrOutput) Command() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Link) []string {
		if v == nil {
			return nil
		}
		return v.Command
	}).(pulumi.StringArrayOutput)
}

// This is a field that can be used to capture information about the environment. It is suggested for this field to contain information that details environment variables, filesystem information, and the present working directory. The recommended structure of this field is: "environment": { "custom_values": { "variables": "", "filesystem": "", "workdir": "", "": "..." } }
func (o LinkPtrOutput) Environment() EnvironmentPtrOutput {
	return o.ApplyT(func(v *Link) *Environment {
		if v == nil {
			return nil
		}
		return v.Environment
	}).(EnvironmentPtrOutput)
}

// Materials are the supply chain artifacts that go into the step and are used for the operation performed. The key of the map is the path of the artifact and the structure contains the recorded hash information. An example is: "materials": [ { "resource_uri": "foo/bar", "hashes": { "sha256": "ebebf...", : } } ]
func (o LinkPtrOutput) Materials() GrafeasV1beta1IntotoArtifactArrayOutput {
	return o.ApplyT(func(v *Link) []GrafeasV1beta1IntotoArtifact {
		if v == nil {
			return nil
		}
		return v.Materials
	}).(GrafeasV1beta1IntotoArtifactArrayOutput)
}

// Products are the supply chain artifacts generated as a result of the step. The structure is identical to that of materials.
func (o LinkPtrOutput) Products() GrafeasV1beta1IntotoArtifactArrayOutput {
	return o.ApplyT(func(v *Link) []GrafeasV1beta1IntotoArtifact {
		if v == nil {
			return nil
		}
		return v.Products
	}).(GrafeasV1beta1IntotoArtifactArrayOutput)
}

// This corresponds to an in-toto link.
type LinkResponse struct {
	// ByProducts are data generated as part of a software supply chain step, but are not the actual result of the step.
	Byproducts ByProductsResponse `pulumi:"byproducts"`
	// This field contains the full command executed for the step. This can also be empty if links are generated for operations that aren't directly mapped to a specific command. Each term in the command is an independent string in the list. An example of a command in the in-toto metadata field is: "command": ["git", "clone", "https://github.com/in-toto/demo-project.git"]
	Command []string `pulumi:"command"`
	// This is a field that can be used to capture information about the environment. It is suggested for this field to contain information that details environment variables, filesystem information, and the present working directory. The recommended structure of this field is: "environment": { "custom_values": { "variables": "", "filesystem": "", "workdir": "", "": "..." } }
	Environment EnvironmentResponse `pulumi:"environment"`
	// Materials are the supply chain artifacts that go into the step and are used for the operation performed. The key of the map is the path of the artifact and the structure contains the recorded hash information. An example is: "materials": [ { "resource_uri": "foo/bar", "hashes": { "sha256": "ebebf...", : } } ]
	Materials []GrafeasV1beta1IntotoArtifactResponse `pulumi:"materials"`
	// Products are the supply chain artifacts generated as a result of the step. The structure is identical to that of materials.
	Products []GrafeasV1beta1IntotoArtifactResponse `pulumi:"products"`
}

// LinkResponseInput is an input type that accepts LinkResponseArgs and LinkResponseOutput values.
// You can construct a concrete instance of `LinkResponseInput` via:
//
//          LinkResponseArgs{...}
type LinkResponseInput interface {
	pulumi.Input

	ToLinkResponseOutput() LinkResponseOutput
	ToLinkResponseOutputWithContext(context.Context) LinkResponseOutput
}

// This corresponds to an in-toto link.
type LinkResponseArgs struct {
	// ByProducts are data generated as part of a software supply chain step, but are not the actual result of the step.
	Byproducts ByProductsResponseInput `pulumi:"byproducts"`
	// This field contains the full command executed for the step. This can also be empty if links are generated for operations that aren't directly mapped to a specific command. Each term in the command is an independent string in the list. An example of a command in the in-toto metadata field is: "command": ["git", "clone", "https://github.com/in-toto/demo-project.git"]
	Command pulumi.StringArrayInput `pulumi:"command"`
	// This is a field that can be used to capture information about the environment. It is suggested for this field to contain information that details environment variables, filesystem information, and the present working directory. The recommended structure of this field is: "environment": { "custom_values": { "variables": "", "filesystem": "", "workdir": "", "": "..." } }
	Environment EnvironmentResponseInput `pulumi:"environment"`
	// Materials are the supply chain artifacts that go into the step and are used for the operation performed. The key of the map is the path of the artifact and the structure contains the recorded hash information. An example is: "materials": [ { "resource_uri": "foo/bar", "hashes": { "sha256": "ebebf...", : } } ]
	Materials GrafeasV1beta1IntotoArtifactResponseArrayInput `pulumi:"materials"`
	// Products are the supply chain artifacts generated as a result of the step. The structure is identical to that of materials.
	Products GrafeasV1beta1IntotoArtifactResponseArrayInput `pulumi:"products"`
}

func (LinkResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LinkResponse)(nil)).Elem()
}

func (i LinkResponseArgs) ToLinkResponseOutput() LinkResponseOutput {
	return i.ToLinkResponseOutputWithContext(context.Background())
}

func (i LinkResponseArgs) ToLinkResponseOutputWithContext(ctx context.Context) LinkResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LinkResponseOutput)
}

func (i LinkResponseArgs) ToLinkResponsePtrOutput() LinkResponsePtrOutput {
	return i.ToLinkResponsePtrOutputWithContext(context.Background())
}

func (i LinkResponseArgs) ToLinkResponsePtrOutputWithContext(ctx context.Context) LinkResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LinkResponseOutput).ToLinkResponsePtrOutputWithContext(ctx)
}

// LinkResponsePtrInput is an input type that accepts LinkResponseArgs, LinkResponsePtr and LinkResponsePtrOutput values.
// You can construct a concrete instance of `LinkResponsePtrInput` via:
//
//          LinkResponseArgs{...}
//
//  or:
//
//          nil
type LinkResponsePtrInput interface {
	pulumi.Input

	ToLinkResponsePtrOutput() LinkResponsePtrOutput
	ToLinkResponsePtrOutputWithContext(context.Context) LinkResponsePtrOutput
}

type linkResponsePtrType LinkResponseArgs

func LinkResponsePtr(v *LinkResponseArgs) LinkResponsePtrInput {
	return (*linkResponsePtrType)(v)
}

func (*linkResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LinkResponse)(nil)).Elem()
}

func (i *linkResponsePtrType) ToLinkResponsePtrOutput() LinkResponsePtrOutput {
	return i.ToLinkResponsePtrOutputWithContext(context.Background())
}

func (i *linkResponsePtrType) ToLinkResponsePtrOutputWithContext(ctx context.Context) LinkResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LinkResponsePtrOutput)
}

// This corresponds to an in-toto link.
type LinkResponseOutput struct{ *pulumi.OutputState }

func (LinkResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LinkResponse)(nil)).Elem()
}

func (o LinkResponseOutput) ToLinkResponseOutput() LinkResponseOutput {
	return o
}

func (o LinkResponseOutput) ToLinkResponseOutputWithContext(ctx context.Context) LinkResponseOutput {
	return o
}

func (o LinkResponseOutput) ToLinkResponsePtrOutput() LinkResponsePtrOutput {
	return o.ToLinkResponsePtrOutputWithContext(context.Background())
}

func (o LinkResponseOutput) ToLinkResponsePtrOutputWithContext(ctx context.Context) LinkResponsePtrOutput {
	return o.ApplyT(func(v LinkResponse) *LinkResponse {
		return &v
	}).(LinkResponsePtrOutput)
}

// ByProducts are data generated as part of a software supply chain step, but are not the actual result of the step.
func (o LinkResponseOutput) Byproducts() ByProductsResponseOutput {
	return o.ApplyT(func(v LinkResponse) ByProductsResponse { return v.Byproducts }).(ByProductsResponseOutput)
}

// This field contains the full command executed for the step. This can also be empty if links are generated for operations that aren't directly mapped to a specific command. Each term in the command is an independent string in the list. An example of a command in the in-toto metadata field is: "command": ["git", "clone", "https://github.com/in-toto/demo-project.git"]
func (o LinkResponseOutput) Command() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LinkResponse) []string { return v.Command }).(pulumi.StringArrayOutput)
}

// This is a field that can be used to capture information about the environment. It is suggested for this field to contain information that details environment variables, filesystem information, and the present working directory. The recommended structure of this field is: "environment": { "custom_values": { "variables": "", "filesystem": "", "workdir": "", "": "..." } }
func (o LinkResponseOutput) Environment() EnvironmentResponseOutput {
	return o.ApplyT(func(v LinkResponse) EnvironmentResponse { return v.Environment }).(EnvironmentResponseOutput)
}

// Materials are the supply chain artifacts that go into the step and are used for the operation performed. The key of the map is the path of the artifact and the structure contains the recorded hash information. An example is: "materials": [ { "resource_uri": "foo/bar", "hashes": { "sha256": "ebebf...", : } } ]
func (o LinkResponseOutput) Materials() GrafeasV1beta1IntotoArtifactResponseArrayOutput {
	return o.ApplyT(func(v LinkResponse) []GrafeasV1beta1IntotoArtifactResponse { return v.Materials }).(GrafeasV1beta1IntotoArtifactResponseArrayOutput)
}

// Products are the supply chain artifacts generated as a result of the step. The structure is identical to that of materials.
func (o LinkResponseOutput) Products() GrafeasV1beta1IntotoArtifactResponseArrayOutput {
	return o.ApplyT(func(v LinkResponse) []GrafeasV1beta1IntotoArtifactResponse { return v.Products }).(GrafeasV1beta1IntotoArtifactResponseArrayOutput)
}

type LinkResponsePtrOutput struct{ *pulumi.OutputState }

func (LinkResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LinkResponse)(nil)).Elem()
}

func (o LinkResponsePtrOutput) ToLinkResponsePtrOutput() LinkResponsePtrOutput {
	return o
}

func (o LinkResponsePtrOutput) ToLinkResponsePtrOutputWithContext(ctx context.Context) LinkResponsePtrOutput {
	return o
}

func (o LinkResponsePtrOutput) Elem() LinkResponseOutput {
	return o.ApplyT(func(v *LinkResponse) LinkResponse { return *v }).(LinkResponseOutput)
}

// ByProducts are data generated as part of a software supply chain step, but are not the actual result of the step.
func (o LinkResponsePtrOutput) Byproducts() ByProductsResponsePtrOutput {
	return o.ApplyT(func(v *LinkResponse) *ByProductsResponse {
		if v == nil {
			return nil
		}
		return &v.Byproducts
	}).(ByProductsResponsePtrOutput)
}

// This field contains the full command executed for the step. This can also be empty if links are generated for operations that aren't directly mapped to a specific command. Each term in the command is an independent string in the list. An example of a command in the in-toto metadata field is: "command": ["git", "clone", "https://github.com/in-toto/demo-project.git"]
func (o LinkResponsePtrOutput) Command() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LinkResponse) []string {
		if v == nil {
			return nil
		}
		return v.Command
	}).(pulumi.StringArrayOutput)
}

// This is a field that can be used to capture information about the environment. It is suggested for this field to contain information that details environment variables, filesystem information, and the present working directory. The recommended structure of this field is: "environment": { "custom_values": { "variables": "", "filesystem": "", "workdir": "", "": "..." } }
func (o LinkResponsePtrOutput) Environment() EnvironmentResponsePtrOutput {
	return o.ApplyT(func(v *LinkResponse) *EnvironmentResponse {
		if v == nil {
			return nil
		}
		return &v.Environment
	}).(EnvironmentResponsePtrOutput)
}

// Materials are the supply chain artifacts that go into the step and are used for the operation performed. The key of the map is the path of the artifact and the structure contains the recorded hash information. An example is: "materials": [ { "resource_uri": "foo/bar", "hashes": { "sha256": "ebebf...", : } } ]
func (o LinkResponsePtrOutput) Materials() GrafeasV1beta1IntotoArtifactResponseArrayOutput {
	return o.ApplyT(func(v *LinkResponse) []GrafeasV1beta1IntotoArtifactResponse {
		if v == nil {
			return nil
		}
		return v.Materials
	}).(GrafeasV1beta1IntotoArtifactResponseArrayOutput)
}

// Products are the supply chain artifacts generated as a result of the step. The structure is identical to that of materials.
func (o LinkResponsePtrOutput) Products() GrafeasV1beta1IntotoArtifactResponseArrayOutput {
	return o.ApplyT(func(v *LinkResponse) []GrafeasV1beta1IntotoArtifactResponse {
		if v == nil {
			return nil
		}
		return v.Products
	}).(GrafeasV1beta1IntotoArtifactResponseArrayOutput)
}

// An occurrence of a particular package installation found within a system's filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
type Location struct {
	// The CPE URI in [CPE format](https://cpe.mitre.org/specification/) denoting the package manager version distributing a package.
	CpeUri string `pulumi:"cpeUri"`
	// The path from which we gathered that this package/version is installed.
	Path *string `pulumi:"path"`
	// The version installed at this location.
	Version *Version `pulumi:"version"`
}

// LocationInput is an input type that accepts LocationArgs and LocationOutput values.
// You can construct a concrete instance of `LocationInput` via:
//
//          LocationArgs{...}
type LocationInput interface {
	pulumi.Input

	ToLocationOutput() LocationOutput
	ToLocationOutputWithContext(context.Context) LocationOutput
}

// An occurrence of a particular package installation found within a system's filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
type LocationArgs struct {
	// The CPE URI in [CPE format](https://cpe.mitre.org/specification/) denoting the package manager version distributing a package.
	CpeUri pulumi.StringInput `pulumi:"cpeUri"`
	// The path from which we gathered that this package/version is installed.
	Path pulumi.StringPtrInput `pulumi:"path"`
	// The version installed at this location.
	Version VersionPtrInput `pulumi:"version"`
}

func (LocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Location)(nil)).Elem()
}

func (i LocationArgs) ToLocationOutput() LocationOutput {
	return i.ToLocationOutputWithContext(context.Background())
}

func (i LocationArgs) ToLocationOutputWithContext(ctx context.Context) LocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationOutput)
}

// LocationArrayInput is an input type that accepts LocationArray and LocationArrayOutput values.
// You can construct a concrete instance of `LocationArrayInput` via:
//
//          LocationArray{ LocationArgs{...} }
type LocationArrayInput interface {
	pulumi.Input

	ToLocationArrayOutput() LocationArrayOutput
	ToLocationArrayOutputWithContext(context.Context) LocationArrayOutput
}

type LocationArray []LocationInput

func (LocationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Location)(nil)).Elem()
}

func (i LocationArray) ToLocationArrayOutput() LocationArrayOutput {
	return i.ToLocationArrayOutputWithContext(context.Background())
}

func (i LocationArray) ToLocationArrayOutputWithContext(ctx context.Context) LocationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationArrayOutput)
}

// An occurrence of a particular package installation found within a system's filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
type LocationOutput struct{ *pulumi.OutputState }

func (LocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Location)(nil)).Elem()
}

func (o LocationOutput) ToLocationOutput() LocationOutput {
	return o
}

func (o LocationOutput) ToLocationOutputWithContext(ctx context.Context) LocationOutput {
	return o
}

// The CPE URI in [CPE format](https://cpe.mitre.org/specification/) denoting the package manager version distributing a package.
func (o LocationOutput) CpeUri() pulumi.StringOutput {
	return o.ApplyT(func(v Location) string { return v.CpeUri }).(pulumi.StringOutput)
}

// The path from which we gathered that this package/version is installed.
func (o LocationOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Location) *string { return v.Path }).(pulumi.StringPtrOutput)
}

// The version installed at this location.
func (o LocationOutput) Version() VersionPtrOutput {
	return o.ApplyT(func(v Location) *Version { return v.Version }).(VersionPtrOutput)
}

type LocationArrayOutput struct{ *pulumi.OutputState }

func (LocationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Location)(nil)).Elem()
}

func (o LocationArrayOutput) ToLocationArrayOutput() LocationArrayOutput {
	return o
}

func (o LocationArrayOutput) ToLocationArrayOutputWithContext(ctx context.Context) LocationArrayOutput {
	return o
}

func (o LocationArrayOutput) Index(i pulumi.IntInput) LocationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Location {
		return vs[0].([]Location)[vs[1].(int)]
	}).(LocationOutput)
}

// An occurrence of a particular package installation found within a system's filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
type LocationResponse struct {
	// The CPE URI in [CPE format](https://cpe.mitre.org/specification/) denoting the package manager version distributing a package.
	CpeUri string `pulumi:"cpeUri"`
	// The path from which we gathered that this package/version is installed.
	Path string `pulumi:"path"`
	// The version installed at this location.
	Version VersionResponse `pulumi:"version"`
}

// LocationResponseInput is an input type that accepts LocationResponseArgs and LocationResponseOutput values.
// You can construct a concrete instance of `LocationResponseInput` via:
//
//          LocationResponseArgs{...}
type LocationResponseInput interface {
	pulumi.Input

	ToLocationResponseOutput() LocationResponseOutput
	ToLocationResponseOutputWithContext(context.Context) LocationResponseOutput
}

// An occurrence of a particular package installation found within a system's filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
type LocationResponseArgs struct {
	// The CPE URI in [CPE format](https://cpe.mitre.org/specification/) denoting the package manager version distributing a package.
	CpeUri pulumi.StringInput `pulumi:"cpeUri"`
	// The path from which we gathered that this package/version is installed.
	Path pulumi.StringInput `pulumi:"path"`
	// The version installed at this location.
	Version VersionResponseInput `pulumi:"version"`
}

func (LocationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationResponse)(nil)).Elem()
}

func (i LocationResponseArgs) ToLocationResponseOutput() LocationResponseOutput {
	return i.ToLocationResponseOutputWithContext(context.Background())
}

func (i LocationResponseArgs) ToLocationResponseOutputWithContext(ctx context.Context) LocationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationResponseOutput)
}

// LocationResponseArrayInput is an input type that accepts LocationResponseArray and LocationResponseArrayOutput values.
// You can construct a concrete instance of `LocationResponseArrayInput` via:
//
//          LocationResponseArray{ LocationResponseArgs{...} }
type LocationResponseArrayInput interface {
	pulumi.Input

	ToLocationResponseArrayOutput() LocationResponseArrayOutput
	ToLocationResponseArrayOutputWithContext(context.Context) LocationResponseArrayOutput
}

type LocationResponseArray []LocationResponseInput

func (LocationResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LocationResponse)(nil)).Elem()
}

func (i LocationResponseArray) ToLocationResponseArrayOutput() LocationResponseArrayOutput {
	return i.ToLocationResponseArrayOutputWithContext(context.Background())
}

func (i LocationResponseArray) ToLocationResponseArrayOutputWithContext(ctx context.Context) LocationResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationResponseArrayOutput)
}

// An occurrence of a particular package installation found within a system's filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
type LocationResponseOutput struct{ *pulumi.OutputState }

func (LocationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationResponse)(nil)).Elem()
}

func (o LocationResponseOutput) ToLocationResponseOutput() LocationResponseOutput {
	return o
}

func (o LocationResponseOutput) ToLocationResponseOutputWithContext(ctx context.Context) LocationResponseOutput {
	return o
}

// The CPE URI in [CPE format](https://cpe.mitre.org/specification/) denoting the package manager version distributing a package.
func (o LocationResponseOutput) CpeUri() pulumi.StringOutput {
	return o.ApplyT(func(v LocationResponse) string { return v.CpeUri }).(pulumi.StringOutput)
}

// The path from which we gathered that this package/version is installed.
func (o LocationResponseOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v LocationResponse) string { return v.Path }).(pulumi.StringOutput)
}

// The version installed at this location.
func (o LocationResponseOutput) Version() VersionResponseOutput {
	return o.ApplyT(func(v LocationResponse) VersionResponse { return v.Version }).(VersionResponseOutput)
}

type LocationResponseArrayOutput struct{ *pulumi.OutputState }

func (LocationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LocationResponse)(nil)).Elem()
}

func (o LocationResponseArrayOutput) ToLocationResponseArrayOutput() LocationResponseArrayOutput {
	return o
}

func (o LocationResponseArrayOutput) ToLocationResponseArrayOutputWithContext(ctx context.Context) LocationResponseArrayOutput {
	return o
}

func (o LocationResponseArrayOutput) Index(i pulumi.IntInput) LocationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LocationResponse {
		return vs[0].([]LocationResponse)[vs[1].(int)]
	}).(LocationResponseOutput)
}

// This represents a particular package that is distributed over various channels. E.g., glibc (aka libc6) is distributed by many, at various versions.
type Package struct {
	// The various channels by which a package is distributed.
	Distribution []Distribution `pulumi:"distribution"`
	// Immutable. The name of the package.
	Name string `pulumi:"name"`
}

// PackageInput is an input type that accepts PackageArgs and PackageOutput values.
// You can construct a concrete instance of `PackageInput` via:
//
//          PackageArgs{...}
type PackageInput interface {
	pulumi.Input

	ToPackageOutput() PackageOutput
	ToPackageOutputWithContext(context.Context) PackageOutput
}

// This represents a particular package that is distributed over various channels. E.g., glibc (aka libc6) is distributed by many, at various versions.
type PackageArgs struct {
	// The various channels by which a package is distributed.
	Distribution DistributionArrayInput `pulumi:"distribution"`
	// Immutable. The name of the package.
	Name pulumi.StringInput `pulumi:"name"`
}

func (PackageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Package)(nil)).Elem()
}

func (i PackageArgs) ToPackageOutput() PackageOutput {
	return i.ToPackageOutputWithContext(context.Background())
}

func (i PackageArgs) ToPackageOutputWithContext(ctx context.Context) PackageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageOutput)
}

func (i PackageArgs) ToPackagePtrOutput() PackagePtrOutput {
	return i.ToPackagePtrOutputWithContext(context.Background())
}

func (i PackageArgs) ToPackagePtrOutputWithContext(ctx context.Context) PackagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageOutput).ToPackagePtrOutputWithContext(ctx)
}

// PackagePtrInput is an input type that accepts PackageArgs, PackagePtr and PackagePtrOutput values.
// You can construct a concrete instance of `PackagePtrInput` via:
//
//          PackageArgs{...}
//
//  or:
//
//          nil
type PackagePtrInput interface {
	pulumi.Input

	ToPackagePtrOutput() PackagePtrOutput
	ToPackagePtrOutputWithContext(context.Context) PackagePtrOutput
}

type packagePtrType PackageArgs

func PackagePtr(v *PackageArgs) PackagePtrInput {
	return (*packagePtrType)(v)
}

func (*packagePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Package)(nil)).Elem()
}

func (i *packagePtrType) ToPackagePtrOutput() PackagePtrOutput {
	return i.ToPackagePtrOutputWithContext(context.Background())
}

func (i *packagePtrType) ToPackagePtrOutputWithContext(ctx context.Context) PackagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackagePtrOutput)
}

// This represents a particular package that is distributed over various channels. E.g., glibc (aka libc6) is distributed by many, at various versions.
type PackageOutput struct{ *pulumi.OutputState }

func (PackageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Package)(nil)).Elem()
}

func (o PackageOutput) ToPackageOutput() PackageOutput {
	return o
}

func (o PackageOutput) ToPackageOutputWithContext(ctx context.Context) PackageOutput {
	return o
}

func (o PackageOutput) ToPackagePtrOutput() PackagePtrOutput {
	return o.ToPackagePtrOutputWithContext(context.Background())
}

func (o PackageOutput) ToPackagePtrOutputWithContext(ctx context.Context) PackagePtrOutput {
	return o.ApplyT(func(v Package) *Package {
		return &v
	}).(PackagePtrOutput)
}

// The various channels by which a package is distributed.
func (o PackageOutput) Distribution() DistributionArrayOutput {
	return o.ApplyT(func(v Package) []Distribution { return v.Distribution }).(DistributionArrayOutput)
}

// Immutable. The name of the package.
func (o PackageOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v Package) string { return v.Name }).(pulumi.StringOutput)
}

type PackagePtrOutput struct{ *pulumi.OutputState }

func (PackagePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Package)(nil)).Elem()
}

func (o PackagePtrOutput) ToPackagePtrOutput() PackagePtrOutput {
	return o
}

func (o PackagePtrOutput) ToPackagePtrOutputWithContext(ctx context.Context) PackagePtrOutput {
	return o
}

func (o PackagePtrOutput) Elem() PackageOutput {
	return o.ApplyT(func(v *Package) Package { return *v }).(PackageOutput)
}

// The various channels by which a package is distributed.
func (o PackagePtrOutput) Distribution() DistributionArrayOutput {
	return o.ApplyT(func(v *Package) []Distribution {
		if v == nil {
			return nil
		}
		return v.Distribution
	}).(DistributionArrayOutput)
}

// Immutable. The name of the package.
func (o PackagePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Package) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// This message wraps a location affected by a vulnerability and its associated fix (if one is available).
type PackageIssue struct {
	// The location of the vulnerability.
	AffectedLocation VulnerabilityLocation `pulumi:"affectedLocation"`
	// The location of the available fix for vulnerability.
	FixedLocation *VulnerabilityLocation `pulumi:"fixedLocation"`
	// The type of package (e.g. OS, MAVEN, GO).
	PackageType *string `pulumi:"packageType"`
}

// PackageIssueInput is an input type that accepts PackageIssueArgs and PackageIssueOutput values.
// You can construct a concrete instance of `PackageIssueInput` via:
//
//          PackageIssueArgs{...}
type PackageIssueInput interface {
	pulumi.Input

	ToPackageIssueOutput() PackageIssueOutput
	ToPackageIssueOutputWithContext(context.Context) PackageIssueOutput
}

// This message wraps a location affected by a vulnerability and its associated fix (if one is available).
type PackageIssueArgs struct {
	// The location of the vulnerability.
	AffectedLocation VulnerabilityLocationInput `pulumi:"affectedLocation"`
	// The location of the available fix for vulnerability.
	FixedLocation VulnerabilityLocationPtrInput `pulumi:"fixedLocation"`
	// The type of package (e.g. OS, MAVEN, GO).
	PackageType pulumi.StringPtrInput `pulumi:"packageType"`
}

func (PackageIssueArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PackageIssue)(nil)).Elem()
}

func (i PackageIssueArgs) ToPackageIssueOutput() PackageIssueOutput {
	return i.ToPackageIssueOutputWithContext(context.Background())
}

func (i PackageIssueArgs) ToPackageIssueOutputWithContext(ctx context.Context) PackageIssueOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageIssueOutput)
}

// PackageIssueArrayInput is an input type that accepts PackageIssueArray and PackageIssueArrayOutput values.
// You can construct a concrete instance of `PackageIssueArrayInput` via:
//
//          PackageIssueArray{ PackageIssueArgs{...} }
type PackageIssueArrayInput interface {
	pulumi.Input

	ToPackageIssueArrayOutput() PackageIssueArrayOutput
	ToPackageIssueArrayOutputWithContext(context.Context) PackageIssueArrayOutput
}

type PackageIssueArray []PackageIssueInput

func (PackageIssueArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PackageIssue)(nil)).Elem()
}

func (i PackageIssueArray) ToPackageIssueArrayOutput() PackageIssueArrayOutput {
	return i.ToPackageIssueArrayOutputWithContext(context.Background())
}

func (i PackageIssueArray) ToPackageIssueArrayOutputWithContext(ctx context.Context) PackageIssueArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageIssueArrayOutput)
}

// This message wraps a location affected by a vulnerability and its associated fix (if one is available).
type PackageIssueOutput struct{ *pulumi.OutputState }

func (PackageIssueOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PackageIssue)(nil)).Elem()
}

func (o PackageIssueOutput) ToPackageIssueOutput() PackageIssueOutput {
	return o
}

func (o PackageIssueOutput) ToPackageIssueOutputWithContext(ctx context.Context) PackageIssueOutput {
	return o
}

// The location of the vulnerability.
func (o PackageIssueOutput) AffectedLocation() VulnerabilityLocationOutput {
	return o.ApplyT(func(v PackageIssue) VulnerabilityLocation { return v.AffectedLocation }).(VulnerabilityLocationOutput)
}

// The location of the available fix for vulnerability.
func (o PackageIssueOutput) FixedLocation() VulnerabilityLocationPtrOutput {
	return o.ApplyT(func(v PackageIssue) *VulnerabilityLocation { return v.FixedLocation }).(VulnerabilityLocationPtrOutput)
}

// The type of package (e.g. OS, MAVEN, GO).
func (o PackageIssueOutput) PackageType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageIssue) *string { return v.PackageType }).(pulumi.StringPtrOutput)
}

type PackageIssueArrayOutput struct{ *pulumi.OutputState }

func (PackageIssueArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PackageIssue)(nil)).Elem()
}

func (o PackageIssueArrayOutput) ToPackageIssueArrayOutput() PackageIssueArrayOutput {
	return o
}

func (o PackageIssueArrayOutput) ToPackageIssueArrayOutputWithContext(ctx context.Context) PackageIssueArrayOutput {
	return o
}

func (o PackageIssueArrayOutput) Index(i pulumi.IntInput) PackageIssueOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PackageIssue {
		return vs[0].([]PackageIssue)[vs[1].(int)]
	}).(PackageIssueOutput)
}

// This message wraps a location affected by a vulnerability and its associated fix (if one is available).
type PackageIssueResponse struct {
	// The location of the vulnerability.
	AffectedLocation VulnerabilityLocationResponse `pulumi:"affectedLocation"`
	// The distro or language system assigned severity for this vulnerability when that is available and note provider assigned severity when it is not available.
	EffectiveSeverity string `pulumi:"effectiveSeverity"`
	// The location of the available fix for vulnerability.
	FixedLocation VulnerabilityLocationResponse `pulumi:"fixedLocation"`
	// The type of package (e.g. OS, MAVEN, GO).
	PackageType string `pulumi:"packageType"`
}

// PackageIssueResponseInput is an input type that accepts PackageIssueResponseArgs and PackageIssueResponseOutput values.
// You can construct a concrete instance of `PackageIssueResponseInput` via:
//
//          PackageIssueResponseArgs{...}
type PackageIssueResponseInput interface {
	pulumi.Input

	ToPackageIssueResponseOutput() PackageIssueResponseOutput
	ToPackageIssueResponseOutputWithContext(context.Context) PackageIssueResponseOutput
}

// This message wraps a location affected by a vulnerability and its associated fix (if one is available).
type PackageIssueResponseArgs struct {
	// The location of the vulnerability.
	AffectedLocation VulnerabilityLocationResponseInput `pulumi:"affectedLocation"`
	// The distro or language system assigned severity for this vulnerability when that is available and note provider assigned severity when it is not available.
	EffectiveSeverity pulumi.StringInput `pulumi:"effectiveSeverity"`
	// The location of the available fix for vulnerability.
	FixedLocation VulnerabilityLocationResponseInput `pulumi:"fixedLocation"`
	// The type of package (e.g. OS, MAVEN, GO).
	PackageType pulumi.StringInput `pulumi:"packageType"`
}

func (PackageIssueResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PackageIssueResponse)(nil)).Elem()
}

func (i PackageIssueResponseArgs) ToPackageIssueResponseOutput() PackageIssueResponseOutput {
	return i.ToPackageIssueResponseOutputWithContext(context.Background())
}

func (i PackageIssueResponseArgs) ToPackageIssueResponseOutputWithContext(ctx context.Context) PackageIssueResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageIssueResponseOutput)
}

// PackageIssueResponseArrayInput is an input type that accepts PackageIssueResponseArray and PackageIssueResponseArrayOutput values.
// You can construct a concrete instance of `PackageIssueResponseArrayInput` via:
//
//          PackageIssueResponseArray{ PackageIssueResponseArgs{...} }
type PackageIssueResponseArrayInput interface {
	pulumi.Input

	ToPackageIssueResponseArrayOutput() PackageIssueResponseArrayOutput
	ToPackageIssueResponseArrayOutputWithContext(context.Context) PackageIssueResponseArrayOutput
}

type PackageIssueResponseArray []PackageIssueResponseInput

func (PackageIssueResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PackageIssueResponse)(nil)).Elem()
}

func (i PackageIssueResponseArray) ToPackageIssueResponseArrayOutput() PackageIssueResponseArrayOutput {
	return i.ToPackageIssueResponseArrayOutputWithContext(context.Background())
}

func (i PackageIssueResponseArray) ToPackageIssueResponseArrayOutputWithContext(ctx context.Context) PackageIssueResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageIssueResponseArrayOutput)
}

// This message wraps a location affected by a vulnerability and its associated fix (if one is available).
type PackageIssueResponseOutput struct{ *pulumi.OutputState }

func (PackageIssueResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PackageIssueResponse)(nil)).Elem()
}

func (o PackageIssueResponseOutput) ToPackageIssueResponseOutput() PackageIssueResponseOutput {
	return o
}

func (o PackageIssueResponseOutput) ToPackageIssueResponseOutputWithContext(ctx context.Context) PackageIssueResponseOutput {
	return o
}

// The location of the vulnerability.
func (o PackageIssueResponseOutput) AffectedLocation() VulnerabilityLocationResponseOutput {
	return o.ApplyT(func(v PackageIssueResponse) VulnerabilityLocationResponse { return v.AffectedLocation }).(VulnerabilityLocationResponseOutput)
}

// The distro or language system assigned severity for this vulnerability when that is available and note provider assigned severity when it is not available.
func (o PackageIssueResponseOutput) EffectiveSeverity() pulumi.StringOutput {
	return o.ApplyT(func(v PackageIssueResponse) string { return v.EffectiveSeverity }).(pulumi.StringOutput)
}

// The location of the available fix for vulnerability.
func (o PackageIssueResponseOutput) FixedLocation() VulnerabilityLocationResponseOutput {
	return o.ApplyT(func(v PackageIssueResponse) VulnerabilityLocationResponse { return v.FixedLocation }).(VulnerabilityLocationResponseOutput)
}

// The type of package (e.g. OS, MAVEN, GO).
func (o PackageIssueResponseOutput) PackageType() pulumi.StringOutput {
	return o.ApplyT(func(v PackageIssueResponse) string { return v.PackageType }).(pulumi.StringOutput)
}

type PackageIssueResponseArrayOutput struct{ *pulumi.OutputState }

func (PackageIssueResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PackageIssueResponse)(nil)).Elem()
}

func (o PackageIssueResponseArrayOutput) ToPackageIssueResponseArrayOutput() PackageIssueResponseArrayOutput {
	return o
}

func (o PackageIssueResponseArrayOutput) ToPackageIssueResponseArrayOutputWithContext(ctx context.Context) PackageIssueResponseArrayOutput {
	return o
}

func (o PackageIssueResponseArrayOutput) Index(i pulumi.IntInput) PackageIssueResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PackageIssueResponse {
		return vs[0].([]PackageIssueResponse)[vs[1].(int)]
	}).(PackageIssueResponseOutput)
}

// PackageNote represents an SPDX Package Information section: https://spdx.github.io/spdx-spec/3-package-information/
type PackageNote struct {
	// Indicates whether the file content of this package has been available for or subjected to analysis when creating the SPDX document
	Analyzed *bool `pulumi:"analyzed"`
	// A place for the SPDX data creator to record, at the package level, acknowledgements that may be needed to be communicated in some contexts
	Attribution *string `pulumi:"attribution"`
	// Provide an independently reproducible mechanism that permits unique identification of a specific package that correlates to the data in this SPDX file
	Checksum *string `pulumi:"checksum"`
	// Identify the copyright holders of the package, as well as any dates present
	Copyright *string `pulumi:"copyright"`
	// A more detailed description of the package
	DetailedDescription *string `pulumi:"detailedDescription"`
	// This section identifies the download Universal Resource Locator (URL), or a specific location within a version control system (VCS) for the package at the time that the SPDX file was created
	DownloadLocation *string `pulumi:"downloadLocation"`
	// ExternalRef
	ExternalRefs []ExternalRef `pulumi:"externalRefs"`
	// Contain the license the SPDX file creator has concluded as governing the This field is to contain a list of all licenses found in the package. The relationship between licenses (i.e., conjunctive, disjunctive) is not specified in this field – it is simply a listing of all licenses found
	FilesLicenseInfo []string `pulumi:"filesLicenseInfo"`
	// Provide a place for the SPDX file creator to record a web site that serves as the package's home page
	HomePage *string `pulumi:"homePage"`
	// List the licenses that have been declared by the authors of the package
	LicenseDeclared *string `pulumi:"licenseDeclared"`
	// If the package identified in the SPDX file originated from a different person or organization than identified as Package Supplier, this field identifies from where or whom the package originally came
	Originator *string `pulumi:"originator"`
	// A short description of the package
	SummaryDescription *string `pulumi:"summaryDescription"`
	// Identify the actual distribution source for the package/directory identified in the SPDX file
	Supplier *string `pulumi:"supplier"`
	// Identify the full name of the package as given by the Package Originator
	Title *string `pulumi:"title"`
	// This field provides an independently reproducible mechanism identifying specific contents of a package based on the actual files (except the SPDX file itself, if it is included in the package) that make up each package and that correlates to the data in this SPDX file
	VerificationCode *string `pulumi:"verificationCode"`
	// Identify the version of the package
	Version *string `pulumi:"version"`
}

// PackageNoteInput is an input type that accepts PackageNoteArgs and PackageNoteOutput values.
// You can construct a concrete instance of `PackageNoteInput` via:
//
//          PackageNoteArgs{...}
type PackageNoteInput interface {
	pulumi.Input

	ToPackageNoteOutput() PackageNoteOutput
	ToPackageNoteOutputWithContext(context.Context) PackageNoteOutput
}

// PackageNote represents an SPDX Package Information section: https://spdx.github.io/spdx-spec/3-package-information/
type PackageNoteArgs struct {
	// Indicates whether the file content of this package has been available for or subjected to analysis when creating the SPDX document
	Analyzed pulumi.BoolPtrInput `pulumi:"analyzed"`
	// A place for the SPDX data creator to record, at the package level, acknowledgements that may be needed to be communicated in some contexts
	Attribution pulumi.StringPtrInput `pulumi:"attribution"`
	// Provide an independently reproducible mechanism that permits unique identification of a specific package that correlates to the data in this SPDX file
	Checksum pulumi.StringPtrInput `pulumi:"checksum"`
	// Identify the copyright holders of the package, as well as any dates present
	Copyright pulumi.StringPtrInput `pulumi:"copyright"`
	// A more detailed description of the package
	DetailedDescription pulumi.StringPtrInput `pulumi:"detailedDescription"`
	// This section identifies the download Universal Resource Locator (URL), or a specific location within a version control system (VCS) for the package at the time that the SPDX file was created
	DownloadLocation pulumi.StringPtrInput `pulumi:"downloadLocation"`
	// ExternalRef
	ExternalRefs ExternalRefArrayInput `pulumi:"externalRefs"`
	// Contain the license the SPDX file creator has concluded as governing the This field is to contain a list of all licenses found in the package. The relationship between licenses (i.e., conjunctive, disjunctive) is not specified in this field – it is simply a listing of all licenses found
	FilesLicenseInfo pulumi.StringArrayInput `pulumi:"filesLicenseInfo"`
	// Provide a place for the SPDX file creator to record a web site that serves as the package's home page
	HomePage pulumi.StringPtrInput `pulumi:"homePage"`
	// List the licenses that have been declared by the authors of the package
	LicenseDeclared pulumi.StringPtrInput `pulumi:"licenseDeclared"`
	// If the package identified in the SPDX file originated from a different person or organization than identified as Package Supplier, this field identifies from where or whom the package originally came
	Originator pulumi.StringPtrInput `pulumi:"originator"`
	// A short description of the package
	SummaryDescription pulumi.StringPtrInput `pulumi:"summaryDescription"`
	// Identify the actual distribution source for the package/directory identified in the SPDX file
	Supplier pulumi.StringPtrInput `pulumi:"supplier"`
	// Identify the full name of the package as given by the Package Originator
	Title pulumi.StringPtrInput `pulumi:"title"`
	// This field provides an independently reproducible mechanism identifying specific contents of a package based on the actual files (except the SPDX file itself, if it is included in the package) that make up each package and that correlates to the data in this SPDX file
	VerificationCode pulumi.StringPtrInput `pulumi:"verificationCode"`
	// Identify the version of the package
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (PackageNoteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PackageNote)(nil)).Elem()
}

func (i PackageNoteArgs) ToPackageNoteOutput() PackageNoteOutput {
	return i.ToPackageNoteOutputWithContext(context.Background())
}

func (i PackageNoteArgs) ToPackageNoteOutputWithContext(ctx context.Context) PackageNoteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageNoteOutput)
}

func (i PackageNoteArgs) ToPackageNotePtrOutput() PackageNotePtrOutput {
	return i.ToPackageNotePtrOutputWithContext(context.Background())
}

func (i PackageNoteArgs) ToPackageNotePtrOutputWithContext(ctx context.Context) PackageNotePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageNoteOutput).ToPackageNotePtrOutputWithContext(ctx)
}

// PackageNotePtrInput is an input type that accepts PackageNoteArgs, PackageNotePtr and PackageNotePtrOutput values.
// You can construct a concrete instance of `PackageNotePtrInput` via:
//
//          PackageNoteArgs{...}
//
//  or:
//
//          nil
type PackageNotePtrInput interface {
	pulumi.Input

	ToPackageNotePtrOutput() PackageNotePtrOutput
	ToPackageNotePtrOutputWithContext(context.Context) PackageNotePtrOutput
}

type packageNotePtrType PackageNoteArgs

func PackageNotePtr(v *PackageNoteArgs) PackageNotePtrInput {
	return (*packageNotePtrType)(v)
}

func (*packageNotePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageNote)(nil)).Elem()
}

func (i *packageNotePtrType) ToPackageNotePtrOutput() PackageNotePtrOutput {
	return i.ToPackageNotePtrOutputWithContext(context.Background())
}

func (i *packageNotePtrType) ToPackageNotePtrOutputWithContext(ctx context.Context) PackageNotePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageNotePtrOutput)
}

// PackageNote represents an SPDX Package Information section: https://spdx.github.io/spdx-spec/3-package-information/
type PackageNoteOutput struct{ *pulumi.OutputState }

func (PackageNoteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PackageNote)(nil)).Elem()
}

func (o PackageNoteOutput) ToPackageNoteOutput() PackageNoteOutput {
	return o
}

func (o PackageNoteOutput) ToPackageNoteOutputWithContext(ctx context.Context) PackageNoteOutput {
	return o
}

func (o PackageNoteOutput) ToPackageNotePtrOutput() PackageNotePtrOutput {
	return o.ToPackageNotePtrOutputWithContext(context.Background())
}

func (o PackageNoteOutput) ToPackageNotePtrOutputWithContext(ctx context.Context) PackageNotePtrOutput {
	return o.ApplyT(func(v PackageNote) *PackageNote {
		return &v
	}).(PackageNotePtrOutput)
}

// Indicates whether the file content of this package has been available for or subjected to analysis when creating the SPDX document
func (o PackageNoteOutput) Analyzed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v PackageNote) *bool { return v.Analyzed }).(pulumi.BoolPtrOutput)
}

// A place for the SPDX data creator to record, at the package level, acknowledgements that may be needed to be communicated in some contexts
func (o PackageNoteOutput) Attribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageNote) *string { return v.Attribution }).(pulumi.StringPtrOutput)
}

// Provide an independently reproducible mechanism that permits unique identification of a specific package that correlates to the data in this SPDX file
func (o PackageNoteOutput) Checksum() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageNote) *string { return v.Checksum }).(pulumi.StringPtrOutput)
}

// Identify the copyright holders of the package, as well as any dates present
func (o PackageNoteOutput) Copyright() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageNote) *string { return v.Copyright }).(pulumi.StringPtrOutput)
}

// A more detailed description of the package
func (o PackageNoteOutput) DetailedDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageNote) *string { return v.DetailedDescription }).(pulumi.StringPtrOutput)
}

// This section identifies the download Universal Resource Locator (URL), or a specific location within a version control system (VCS) for the package at the time that the SPDX file was created
func (o PackageNoteOutput) DownloadLocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageNote) *string { return v.DownloadLocation }).(pulumi.StringPtrOutput)
}

// ExternalRef
func (o PackageNoteOutput) ExternalRefs() ExternalRefArrayOutput {
	return o.ApplyT(func(v PackageNote) []ExternalRef { return v.ExternalRefs }).(ExternalRefArrayOutput)
}

// Contain the license the SPDX file creator has concluded as governing the This field is to contain a list of all licenses found in the package. The relationship between licenses (i.e., conjunctive, disjunctive) is not specified in this field – it is simply a listing of all licenses found
func (o PackageNoteOutput) FilesLicenseInfo() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PackageNote) []string { return v.FilesLicenseInfo }).(pulumi.StringArrayOutput)
}

// Provide a place for the SPDX file creator to record a web site that serves as the package's home page
func (o PackageNoteOutput) HomePage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageNote) *string { return v.HomePage }).(pulumi.StringPtrOutput)
}

// List the licenses that have been declared by the authors of the package
func (o PackageNoteOutput) LicenseDeclared() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageNote) *string { return v.LicenseDeclared }).(pulumi.StringPtrOutput)
}

// If the package identified in the SPDX file originated from a different person or organization than identified as Package Supplier, this field identifies from where or whom the package originally came
func (o PackageNoteOutput) Originator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageNote) *string { return v.Originator }).(pulumi.StringPtrOutput)
}

// A short description of the package
func (o PackageNoteOutput) SummaryDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageNote) *string { return v.SummaryDescription }).(pulumi.StringPtrOutput)
}

// Identify the actual distribution source for the package/directory identified in the SPDX file
func (o PackageNoteOutput) Supplier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageNote) *string { return v.Supplier }).(pulumi.StringPtrOutput)
}

// Identify the full name of the package as given by the Package Originator
func (o PackageNoteOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageNote) *string { return v.Title }).(pulumi.StringPtrOutput)
}

// This field provides an independently reproducible mechanism identifying specific contents of a package based on the actual files (except the SPDX file itself, if it is included in the package) that make up each package and that correlates to the data in this SPDX file
func (o PackageNoteOutput) VerificationCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageNote) *string { return v.VerificationCode }).(pulumi.StringPtrOutput)
}

// Identify the version of the package
func (o PackageNoteOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageNote) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type PackageNotePtrOutput struct{ *pulumi.OutputState }

func (PackageNotePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageNote)(nil)).Elem()
}

func (o PackageNotePtrOutput) ToPackageNotePtrOutput() PackageNotePtrOutput {
	return o
}

func (o PackageNotePtrOutput) ToPackageNotePtrOutputWithContext(ctx context.Context) PackageNotePtrOutput {
	return o
}

func (o PackageNotePtrOutput) Elem() PackageNoteOutput {
	return o.ApplyT(func(v *PackageNote) PackageNote { return *v }).(PackageNoteOutput)
}

// Indicates whether the file content of this package has been available for or subjected to analysis when creating the SPDX document
func (o PackageNotePtrOutput) Analyzed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *PackageNote) *bool {
		if v == nil {
			return nil
		}
		return v.Analyzed
	}).(pulumi.BoolPtrOutput)
}

// A place for the SPDX data creator to record, at the package level, acknowledgements that may be needed to be communicated in some contexts
func (o PackageNotePtrOutput) Attribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNote) *string {
		if v == nil {
			return nil
		}
		return v.Attribution
	}).(pulumi.StringPtrOutput)
}

// Provide an independently reproducible mechanism that permits unique identification of a specific package that correlates to the data in this SPDX file
func (o PackageNotePtrOutput) Checksum() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNote) *string {
		if v == nil {
			return nil
		}
		return v.Checksum
	}).(pulumi.StringPtrOutput)
}

// Identify the copyright holders of the package, as well as any dates present
func (o PackageNotePtrOutput) Copyright() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNote) *string {
		if v == nil {
			return nil
		}
		return v.Copyright
	}).(pulumi.StringPtrOutput)
}

// A more detailed description of the package
func (o PackageNotePtrOutput) DetailedDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNote) *string {
		if v == nil {
			return nil
		}
		return v.DetailedDescription
	}).(pulumi.StringPtrOutput)
}

// This section identifies the download Universal Resource Locator (URL), or a specific location within a version control system (VCS) for the package at the time that the SPDX file was created
func (o PackageNotePtrOutput) DownloadLocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNote) *string {
		if v == nil {
			return nil
		}
		return v.DownloadLocation
	}).(pulumi.StringPtrOutput)
}

// ExternalRef
func (o PackageNotePtrOutput) ExternalRefs() ExternalRefArrayOutput {
	return o.ApplyT(func(v *PackageNote) []ExternalRef {
		if v == nil {
			return nil
		}
		return v.ExternalRefs
	}).(ExternalRefArrayOutput)
}

// Contain the license the SPDX file creator has concluded as governing the This field is to contain a list of all licenses found in the package. The relationship between licenses (i.e., conjunctive, disjunctive) is not specified in this field – it is simply a listing of all licenses found
func (o PackageNotePtrOutput) FilesLicenseInfo() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PackageNote) []string {
		if v == nil {
			return nil
		}
		return v.FilesLicenseInfo
	}).(pulumi.StringArrayOutput)
}

// Provide a place for the SPDX file creator to record a web site that serves as the package's home page
func (o PackageNotePtrOutput) HomePage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNote) *string {
		if v == nil {
			return nil
		}
		return v.HomePage
	}).(pulumi.StringPtrOutput)
}

// List the licenses that have been declared by the authors of the package
func (o PackageNotePtrOutput) LicenseDeclared() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNote) *string {
		if v == nil {
			return nil
		}
		return v.LicenseDeclared
	}).(pulumi.StringPtrOutput)
}

// If the package identified in the SPDX file originated from a different person or organization than identified as Package Supplier, this field identifies from where or whom the package originally came
func (o PackageNotePtrOutput) Originator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNote) *string {
		if v == nil {
			return nil
		}
		return v.Originator
	}).(pulumi.StringPtrOutput)
}

// A short description of the package
func (o PackageNotePtrOutput) SummaryDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNote) *string {
		if v == nil {
			return nil
		}
		return v.SummaryDescription
	}).(pulumi.StringPtrOutput)
}

// Identify the actual distribution source for the package/directory identified in the SPDX file
func (o PackageNotePtrOutput) Supplier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNote) *string {
		if v == nil {
			return nil
		}
		return v.Supplier
	}).(pulumi.StringPtrOutput)
}

// Identify the full name of the package as given by the Package Originator
func (o PackageNotePtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNote) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// This field provides an independently reproducible mechanism identifying specific contents of a package based on the actual files (except the SPDX file itself, if it is included in the package) that make up each package and that correlates to the data in this SPDX file
func (o PackageNotePtrOutput) VerificationCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNote) *string {
		if v == nil {
			return nil
		}
		return v.VerificationCode
	}).(pulumi.StringPtrOutput)
}

// Identify the version of the package
func (o PackageNotePtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNote) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// PackageNote represents an SPDX Package Information section: https://spdx.github.io/spdx-spec/3-package-information/
type PackageNoteResponse struct {
	// Indicates whether the file content of this package has been available for or subjected to analysis when creating the SPDX document
	Analyzed bool `pulumi:"analyzed"`
	// A place for the SPDX data creator to record, at the package level, acknowledgements that may be needed to be communicated in some contexts
	Attribution string `pulumi:"attribution"`
	// Provide an independently reproducible mechanism that permits unique identification of a specific package that correlates to the data in this SPDX file
	Checksum string `pulumi:"checksum"`
	// Identify the copyright holders of the package, as well as any dates present
	Copyright string `pulumi:"copyright"`
	// A more detailed description of the package
	DetailedDescription string `pulumi:"detailedDescription"`
	// This section identifies the download Universal Resource Locator (URL), or a specific location within a version control system (VCS) for the package at the time that the SPDX file was created
	DownloadLocation string `pulumi:"downloadLocation"`
	// ExternalRef
	ExternalRefs []ExternalRefResponse `pulumi:"externalRefs"`
	// Contain the license the SPDX file creator has concluded as governing the This field is to contain a list of all licenses found in the package. The relationship between licenses (i.e., conjunctive, disjunctive) is not specified in this field – it is simply a listing of all licenses found
	FilesLicenseInfo []string `pulumi:"filesLicenseInfo"`
	// Provide a place for the SPDX file creator to record a web site that serves as the package's home page
	HomePage string `pulumi:"homePage"`
	// List the licenses that have been declared by the authors of the package
	LicenseDeclared string `pulumi:"licenseDeclared"`
	// If the package identified in the SPDX file originated from a different person or organization than identified as Package Supplier, this field identifies from where or whom the package originally came
	Originator string `pulumi:"originator"`
	// A short description of the package
	SummaryDescription string `pulumi:"summaryDescription"`
	// Identify the actual distribution source for the package/directory identified in the SPDX file
	Supplier string `pulumi:"supplier"`
	// Identify the full name of the package as given by the Package Originator
	Title string `pulumi:"title"`
	// This field provides an independently reproducible mechanism identifying specific contents of a package based on the actual files (except the SPDX file itself, if it is included in the package) that make up each package and that correlates to the data in this SPDX file
	VerificationCode string `pulumi:"verificationCode"`
	// Identify the version of the package
	Version string `pulumi:"version"`
}

// PackageNoteResponseInput is an input type that accepts PackageNoteResponseArgs and PackageNoteResponseOutput values.
// You can construct a concrete instance of `PackageNoteResponseInput` via:
//
//          PackageNoteResponseArgs{...}
type PackageNoteResponseInput interface {
	pulumi.Input

	ToPackageNoteResponseOutput() PackageNoteResponseOutput
	ToPackageNoteResponseOutputWithContext(context.Context) PackageNoteResponseOutput
}

// PackageNote represents an SPDX Package Information section: https://spdx.github.io/spdx-spec/3-package-information/
type PackageNoteResponseArgs struct {
	// Indicates whether the file content of this package has been available for or subjected to analysis when creating the SPDX document
	Analyzed pulumi.BoolInput `pulumi:"analyzed"`
	// A place for the SPDX data creator to record, at the package level, acknowledgements that may be needed to be communicated in some contexts
	Attribution pulumi.StringInput `pulumi:"attribution"`
	// Provide an independently reproducible mechanism that permits unique identification of a specific package that correlates to the data in this SPDX file
	Checksum pulumi.StringInput `pulumi:"checksum"`
	// Identify the copyright holders of the package, as well as any dates present
	Copyright pulumi.StringInput `pulumi:"copyright"`
	// A more detailed description of the package
	DetailedDescription pulumi.StringInput `pulumi:"detailedDescription"`
	// This section identifies the download Universal Resource Locator (URL), or a specific location within a version control system (VCS) for the package at the time that the SPDX file was created
	DownloadLocation pulumi.StringInput `pulumi:"downloadLocation"`
	// ExternalRef
	ExternalRefs ExternalRefResponseArrayInput `pulumi:"externalRefs"`
	// Contain the license the SPDX file creator has concluded as governing the This field is to contain a list of all licenses found in the package. The relationship between licenses (i.e., conjunctive, disjunctive) is not specified in this field – it is simply a listing of all licenses found
	FilesLicenseInfo pulumi.StringArrayInput `pulumi:"filesLicenseInfo"`
	// Provide a place for the SPDX file creator to record a web site that serves as the package's home page
	HomePage pulumi.StringInput `pulumi:"homePage"`
	// List the licenses that have been declared by the authors of the package
	LicenseDeclared pulumi.StringInput `pulumi:"licenseDeclared"`
	// If the package identified in the SPDX file originated from a different person or organization than identified as Package Supplier, this field identifies from where or whom the package originally came
	Originator pulumi.StringInput `pulumi:"originator"`
	// A short description of the package
	SummaryDescription pulumi.StringInput `pulumi:"summaryDescription"`
	// Identify the actual distribution source for the package/directory identified in the SPDX file
	Supplier pulumi.StringInput `pulumi:"supplier"`
	// Identify the full name of the package as given by the Package Originator
	Title pulumi.StringInput `pulumi:"title"`
	// This field provides an independently reproducible mechanism identifying specific contents of a package based on the actual files (except the SPDX file itself, if it is included in the package) that make up each package and that correlates to the data in this SPDX file
	VerificationCode pulumi.StringInput `pulumi:"verificationCode"`
	// Identify the version of the package
	Version pulumi.StringInput `pulumi:"version"`
}

func (PackageNoteResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PackageNoteResponse)(nil)).Elem()
}

func (i PackageNoteResponseArgs) ToPackageNoteResponseOutput() PackageNoteResponseOutput {
	return i.ToPackageNoteResponseOutputWithContext(context.Background())
}

func (i PackageNoteResponseArgs) ToPackageNoteResponseOutputWithContext(ctx context.Context) PackageNoteResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageNoteResponseOutput)
}

func (i PackageNoteResponseArgs) ToPackageNoteResponsePtrOutput() PackageNoteResponsePtrOutput {
	return i.ToPackageNoteResponsePtrOutputWithContext(context.Background())
}

func (i PackageNoteResponseArgs) ToPackageNoteResponsePtrOutputWithContext(ctx context.Context) PackageNoteResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageNoteResponseOutput).ToPackageNoteResponsePtrOutputWithContext(ctx)
}

// PackageNoteResponsePtrInput is an input type that accepts PackageNoteResponseArgs, PackageNoteResponsePtr and PackageNoteResponsePtrOutput values.
// You can construct a concrete instance of `PackageNoteResponsePtrInput` via:
//
//          PackageNoteResponseArgs{...}
//
//  or:
//
//          nil
type PackageNoteResponsePtrInput interface {
	pulumi.Input

	ToPackageNoteResponsePtrOutput() PackageNoteResponsePtrOutput
	ToPackageNoteResponsePtrOutputWithContext(context.Context) PackageNoteResponsePtrOutput
}

type packageNoteResponsePtrType PackageNoteResponseArgs

func PackageNoteResponsePtr(v *PackageNoteResponseArgs) PackageNoteResponsePtrInput {
	return (*packageNoteResponsePtrType)(v)
}

func (*packageNoteResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageNoteResponse)(nil)).Elem()
}

func (i *packageNoteResponsePtrType) ToPackageNoteResponsePtrOutput() PackageNoteResponsePtrOutput {
	return i.ToPackageNoteResponsePtrOutputWithContext(context.Background())
}

func (i *packageNoteResponsePtrType) ToPackageNoteResponsePtrOutputWithContext(ctx context.Context) PackageNoteResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageNoteResponsePtrOutput)
}

// PackageNote represents an SPDX Package Information section: https://spdx.github.io/spdx-spec/3-package-information/
type PackageNoteResponseOutput struct{ *pulumi.OutputState }

func (PackageNoteResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PackageNoteResponse)(nil)).Elem()
}

func (o PackageNoteResponseOutput) ToPackageNoteResponseOutput() PackageNoteResponseOutput {
	return o
}

func (o PackageNoteResponseOutput) ToPackageNoteResponseOutputWithContext(ctx context.Context) PackageNoteResponseOutput {
	return o
}

func (o PackageNoteResponseOutput) ToPackageNoteResponsePtrOutput() PackageNoteResponsePtrOutput {
	return o.ToPackageNoteResponsePtrOutputWithContext(context.Background())
}

func (o PackageNoteResponseOutput) ToPackageNoteResponsePtrOutputWithContext(ctx context.Context) PackageNoteResponsePtrOutput {
	return o.ApplyT(func(v PackageNoteResponse) *PackageNoteResponse {
		return &v
	}).(PackageNoteResponsePtrOutput)
}

// Indicates whether the file content of this package has been available for or subjected to analysis when creating the SPDX document
func (o PackageNoteResponseOutput) Analyzed() pulumi.BoolOutput {
	return o.ApplyT(func(v PackageNoteResponse) bool { return v.Analyzed }).(pulumi.BoolOutput)
}

// A place for the SPDX data creator to record, at the package level, acknowledgements that may be needed to be communicated in some contexts
func (o PackageNoteResponseOutput) Attribution() pulumi.StringOutput {
	return o.ApplyT(func(v PackageNoteResponse) string { return v.Attribution }).(pulumi.StringOutput)
}

// Provide an independently reproducible mechanism that permits unique identification of a specific package that correlates to the data in this SPDX file
func (o PackageNoteResponseOutput) Checksum() pulumi.StringOutput {
	return o.ApplyT(func(v PackageNoteResponse) string { return v.Checksum }).(pulumi.StringOutput)
}

// Identify the copyright holders of the package, as well as any dates present
func (o PackageNoteResponseOutput) Copyright() pulumi.StringOutput {
	return o.ApplyT(func(v PackageNoteResponse) string { return v.Copyright }).(pulumi.StringOutput)
}

// A more detailed description of the package
func (o PackageNoteResponseOutput) DetailedDescription() pulumi.StringOutput {
	return o.ApplyT(func(v PackageNoteResponse) string { return v.DetailedDescription }).(pulumi.StringOutput)
}

// This section identifies the download Universal Resource Locator (URL), or a specific location within a version control system (VCS) for the package at the time that the SPDX file was created
func (o PackageNoteResponseOutput) DownloadLocation() pulumi.StringOutput {
	return o.ApplyT(func(v PackageNoteResponse) string { return v.DownloadLocation }).(pulumi.StringOutput)
}

// ExternalRef
func (o PackageNoteResponseOutput) ExternalRefs() ExternalRefResponseArrayOutput {
	return o.ApplyT(func(v PackageNoteResponse) []ExternalRefResponse { return v.ExternalRefs }).(ExternalRefResponseArrayOutput)
}

// Contain the license the SPDX file creator has concluded as governing the This field is to contain a list of all licenses found in the package. The relationship between licenses (i.e., conjunctive, disjunctive) is not specified in this field – it is simply a listing of all licenses found
func (o PackageNoteResponseOutput) FilesLicenseInfo() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PackageNoteResponse) []string { return v.FilesLicenseInfo }).(pulumi.StringArrayOutput)
}

// Provide a place for the SPDX file creator to record a web site that serves as the package's home page
func (o PackageNoteResponseOutput) HomePage() pulumi.StringOutput {
	return o.ApplyT(func(v PackageNoteResponse) string { return v.HomePage }).(pulumi.StringOutput)
}

// List the licenses that have been declared by the authors of the package
func (o PackageNoteResponseOutput) LicenseDeclared() pulumi.StringOutput {
	return o.ApplyT(func(v PackageNoteResponse) string { return v.LicenseDeclared }).(pulumi.StringOutput)
}

// If the package identified in the SPDX file originated from a different person or organization than identified as Package Supplier, this field identifies from where or whom the package originally came
func (o PackageNoteResponseOutput) Originator() pulumi.StringOutput {
	return o.ApplyT(func(v PackageNoteResponse) string { return v.Originator }).(pulumi.StringOutput)
}

// A short description of the package
func (o PackageNoteResponseOutput) SummaryDescription() pulumi.StringOutput {
	return o.ApplyT(func(v PackageNoteResponse) string { return v.SummaryDescription }).(pulumi.StringOutput)
}

// Identify the actual distribution source for the package/directory identified in the SPDX file
func (o PackageNoteResponseOutput) Supplier() pulumi.StringOutput {
	return o.ApplyT(func(v PackageNoteResponse) string { return v.Supplier }).(pulumi.StringOutput)
}

// Identify the full name of the package as given by the Package Originator
func (o PackageNoteResponseOutput) Title() pulumi.StringOutput {
	return o.ApplyT(func(v PackageNoteResponse) string { return v.Title }).(pulumi.StringOutput)
}

// This field provides an independently reproducible mechanism identifying specific contents of a package based on the actual files (except the SPDX file itself, if it is included in the package) that make up each package and that correlates to the data in this SPDX file
func (o PackageNoteResponseOutput) VerificationCode() pulumi.StringOutput {
	return o.ApplyT(func(v PackageNoteResponse) string { return v.VerificationCode }).(pulumi.StringOutput)
}

// Identify the version of the package
func (o PackageNoteResponseOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v PackageNoteResponse) string { return v.Version }).(pulumi.StringOutput)
}

type PackageNoteResponsePtrOutput struct{ *pulumi.OutputState }

func (PackageNoteResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageNoteResponse)(nil)).Elem()
}

func (o PackageNoteResponsePtrOutput) ToPackageNoteResponsePtrOutput() PackageNoteResponsePtrOutput {
	return o
}

func (o PackageNoteResponsePtrOutput) ToPackageNoteResponsePtrOutputWithContext(ctx context.Context) PackageNoteResponsePtrOutput {
	return o
}

func (o PackageNoteResponsePtrOutput) Elem() PackageNoteResponseOutput {
	return o.ApplyT(func(v *PackageNoteResponse) PackageNoteResponse { return *v }).(PackageNoteResponseOutput)
}

// Indicates whether the file content of this package has been available for or subjected to analysis when creating the SPDX document
func (o PackageNoteResponsePtrOutput) Analyzed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *PackageNoteResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.Analyzed
	}).(pulumi.BoolPtrOutput)
}

// A place for the SPDX data creator to record, at the package level, acknowledgements that may be needed to be communicated in some contexts
func (o PackageNoteResponsePtrOutput) Attribution() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Attribution
	}).(pulumi.StringPtrOutput)
}

// Provide an independently reproducible mechanism that permits unique identification of a specific package that correlates to the data in this SPDX file
func (o PackageNoteResponsePtrOutput) Checksum() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Checksum
	}).(pulumi.StringPtrOutput)
}

// Identify the copyright holders of the package, as well as any dates present
func (o PackageNoteResponsePtrOutput) Copyright() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Copyright
	}).(pulumi.StringPtrOutput)
}

// A more detailed description of the package
func (o PackageNoteResponsePtrOutput) DetailedDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.DetailedDescription
	}).(pulumi.StringPtrOutput)
}

// This section identifies the download Universal Resource Locator (URL), or a specific location within a version control system (VCS) for the package at the time that the SPDX file was created
func (o PackageNoteResponsePtrOutput) DownloadLocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.DownloadLocation
	}).(pulumi.StringPtrOutput)
}

// ExternalRef
func (o PackageNoteResponsePtrOutput) ExternalRefs() ExternalRefResponseArrayOutput {
	return o.ApplyT(func(v *PackageNoteResponse) []ExternalRefResponse {
		if v == nil {
			return nil
		}
		return v.ExternalRefs
	}).(ExternalRefResponseArrayOutput)
}

// Contain the license the SPDX file creator has concluded as governing the This field is to contain a list of all licenses found in the package. The relationship between licenses (i.e., conjunctive, disjunctive) is not specified in this field – it is simply a listing of all licenses found
func (o PackageNoteResponsePtrOutput) FilesLicenseInfo() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PackageNoteResponse) []string {
		if v == nil {
			return nil
		}
		return v.FilesLicenseInfo
	}).(pulumi.StringArrayOutput)
}

// Provide a place for the SPDX file creator to record a web site that serves as the package's home page
func (o PackageNoteResponsePtrOutput) HomePage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HomePage
	}).(pulumi.StringPtrOutput)
}

// List the licenses that have been declared by the authors of the package
func (o PackageNoteResponsePtrOutput) LicenseDeclared() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.LicenseDeclared
	}).(pulumi.StringPtrOutput)
}

// If the package identified in the SPDX file originated from a different person or organization than identified as Package Supplier, this field identifies from where or whom the package originally came
func (o PackageNoteResponsePtrOutput) Originator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Originator
	}).(pulumi.StringPtrOutput)
}

// A short description of the package
func (o PackageNoteResponsePtrOutput) SummaryDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.SummaryDescription
	}).(pulumi.StringPtrOutput)
}

// Identify the actual distribution source for the package/directory identified in the SPDX file
func (o PackageNoteResponsePtrOutput) Supplier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Supplier
	}).(pulumi.StringPtrOutput)
}

// Identify the full name of the package as given by the Package Originator
func (o PackageNoteResponsePtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Title
	}).(pulumi.StringPtrOutput)
}

// This field provides an independently reproducible mechanism identifying specific contents of a package based on the actual files (except the SPDX file itself, if it is included in the package) that make up each package and that correlates to the data in this SPDX file
func (o PackageNoteResponsePtrOutput) VerificationCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.VerificationCode
	}).(pulumi.StringPtrOutput)
}

// Identify the version of the package
func (o PackageNoteResponsePtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageNoteResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Version
	}).(pulumi.StringPtrOutput)
}

// PackageOccurrence represents an SPDX Package Information section: https://spdx.github.io/spdx-spec/3-package-information/
type PackageOccurrence struct {
	// A place for the SPDX file creator to record any general comments about the package being described
	Comment *string `pulumi:"comment"`
	// Provide the actual file name of the package, or path of the directory being treated as a package
	Filename *string `pulumi:"filename"`
	// Uniquely identify any element in an SPDX document which may be referenced by other elements
	Id *string `pulumi:"id"`
	// This field provides a place for the SPDX file creator to record any relevant background information or analysis that went in to arriving at the Concluded License for a package
	LicenseComments *string `pulumi:"licenseComments"`
	// package or alternative values, if the governing license cannot be determined
	LicenseConcluded *string `pulumi:"licenseConcluded"`
	// Provide a place for the SPDX file creator to record any relevant background information or additional comments about the origin of the package
	SourceInfo *string `pulumi:"sourceInfo"`
}

// PackageOccurrenceInput is an input type that accepts PackageOccurrenceArgs and PackageOccurrenceOutput values.
// You can construct a concrete instance of `PackageOccurrenceInput` via:
//
//          PackageOccurrenceArgs{...}
type PackageOccurrenceInput interface {
	pulumi.Input

	ToPackageOccurrenceOutput() PackageOccurrenceOutput
	ToPackageOccurrenceOutputWithContext(context.Context) PackageOccurrenceOutput
}

// PackageOccurrence represents an SPDX Package Information section: https://spdx.github.io/spdx-spec/3-package-information/
type PackageOccurrenceArgs struct {
	// A place for the SPDX file creator to record any general comments about the package being described
	Comment pulumi.StringPtrInput `pulumi:"comment"`
	// Provide the actual file name of the package, or path of the directory being treated as a package
	Filename pulumi.StringPtrInput `pulumi:"filename"`
	// Uniquely identify any element in an SPDX document which may be referenced by other elements
	Id pulumi.StringPtrInput `pulumi:"id"`
	// This field provides a place for the SPDX file creator to record any relevant background information or analysis that went in to arriving at the Concluded License for a package
	LicenseComments pulumi.StringPtrInput `pulumi:"licenseComments"`
	// package or alternative values, if the governing license cannot be determined
	LicenseConcluded pulumi.StringPtrInput `pulumi:"licenseConcluded"`
	// Provide a place for the SPDX file creator to record any relevant background information or additional comments about the origin of the package
	SourceInfo pulumi.StringPtrInput `pulumi:"sourceInfo"`
}

func (PackageOccurrenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PackageOccurrence)(nil)).Elem()
}

func (i PackageOccurrenceArgs) ToPackageOccurrenceOutput() PackageOccurrenceOutput {
	return i.ToPackageOccurrenceOutputWithContext(context.Background())
}

func (i PackageOccurrenceArgs) ToPackageOccurrenceOutputWithContext(ctx context.Context) PackageOccurrenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageOccurrenceOutput)
}

func (i PackageOccurrenceArgs) ToPackageOccurrencePtrOutput() PackageOccurrencePtrOutput {
	return i.ToPackageOccurrencePtrOutputWithContext(context.Background())
}

func (i PackageOccurrenceArgs) ToPackageOccurrencePtrOutputWithContext(ctx context.Context) PackageOccurrencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageOccurrenceOutput).ToPackageOccurrencePtrOutputWithContext(ctx)
}

// PackageOccurrencePtrInput is an input type that accepts PackageOccurrenceArgs, PackageOccurrencePtr and PackageOccurrencePtrOutput values.
// You can construct a concrete instance of `PackageOccurrencePtrInput` via:
//
//          PackageOccurrenceArgs{...}
//
//  or:
//
//          nil
type PackageOccurrencePtrInput interface {
	pulumi.Input

	ToPackageOccurrencePtrOutput() PackageOccurrencePtrOutput
	ToPackageOccurrencePtrOutputWithContext(context.Context) PackageOccurrencePtrOutput
}

type packageOccurrencePtrType PackageOccurrenceArgs

func PackageOccurrencePtr(v *PackageOccurrenceArgs) PackageOccurrencePtrInput {
	return (*packageOccurrencePtrType)(v)
}

func (*packageOccurrencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageOccurrence)(nil)).Elem()
}

func (i *packageOccurrencePtrType) ToPackageOccurrencePtrOutput() PackageOccurrencePtrOutput {
	return i.ToPackageOccurrencePtrOutputWithContext(context.Background())
}

func (i *packageOccurrencePtrType) ToPackageOccurrencePtrOutputWithContext(ctx context.Context) PackageOccurrencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageOccurrencePtrOutput)
}

// PackageOccurrence represents an SPDX Package Information section: https://spdx.github.io/spdx-spec/3-package-information/
type PackageOccurrenceOutput struct{ *pulumi.OutputState }

func (PackageOccurrenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PackageOccurrence)(nil)).Elem()
}

func (o PackageOccurrenceOutput) ToPackageOccurrenceOutput() PackageOccurrenceOutput {
	return o
}

func (o PackageOccurrenceOutput) ToPackageOccurrenceOutputWithContext(ctx context.Context) PackageOccurrenceOutput {
	return o
}

func (o PackageOccurrenceOutput) ToPackageOccurrencePtrOutput() PackageOccurrencePtrOutput {
	return o.ToPackageOccurrencePtrOutputWithContext(context.Background())
}

func (o PackageOccurrenceOutput) ToPackageOccurrencePtrOutputWithContext(ctx context.Context) PackageOccurrencePtrOutput {
	return o.ApplyT(func(v PackageOccurrence) *PackageOccurrence {
		return &v
	}).(PackageOccurrencePtrOutput)
}

// A place for the SPDX file creator to record any general comments about the package being described
func (o PackageOccurrenceOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageOccurrence) *string { return v.Comment }).(pulumi.StringPtrOutput)
}

// Provide the actual file name of the package, or path of the directory being treated as a package
func (o PackageOccurrenceOutput) Filename() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageOccurrence) *string { return v.Filename }).(pulumi.StringPtrOutput)
}

// Uniquely identify any element in an SPDX document which may be referenced by other elements
func (o PackageOccurrenceOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageOccurrence) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// This field provides a place for the SPDX file creator to record any relevant background information or analysis that went in to arriving at the Concluded License for a package
func (o PackageOccurrenceOutput) LicenseComments() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageOccurrence) *string { return v.LicenseComments }).(pulumi.StringPtrOutput)
}

// package or alternative values, if the governing license cannot be determined
func (o PackageOccurrenceOutput) LicenseConcluded() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageOccurrence) *string { return v.LicenseConcluded }).(pulumi.StringPtrOutput)
}

// Provide a place for the SPDX file creator to record any relevant background information or additional comments about the origin of the package
func (o PackageOccurrenceOutput) SourceInfo() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PackageOccurrence) *string { return v.SourceInfo }).(pulumi.StringPtrOutput)
}

type PackageOccurrencePtrOutput struct{ *pulumi.OutputState }

func (PackageOccurrencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageOccurrence)(nil)).Elem()
}

func (o PackageOccurrencePtrOutput) ToPackageOccurrencePtrOutput() PackageOccurrencePtrOutput {
	return o
}

func (o PackageOccurrencePtrOutput) ToPackageOccurrencePtrOutputWithContext(ctx context.Context) PackageOccurrencePtrOutput {
	return o
}

func (o PackageOccurrencePtrOutput) Elem() PackageOccurrenceOutput {
	return o.ApplyT(func(v *PackageOccurrence) PackageOccurrence { return *v }).(PackageOccurrenceOutput)
}

// A place for the SPDX file creator to record any general comments about the package being described
func (o PackageOccurrencePtrOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.Comment
	}).(pulumi.StringPtrOutput)
}

// Provide the actual file name of the package, or path of the directory being treated as a package
func (o PackageOccurrencePtrOutput) Filename() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.Filename
	}).(pulumi.StringPtrOutput)
}

// Uniquely identify any element in an SPDX document which may be referenced by other elements
func (o PackageOccurrencePtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

// This field provides a place for the SPDX file creator to record any relevant background information or analysis that went in to arriving at the Concluded License for a package
func (o PackageOccurrencePtrOutput) LicenseComments() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.LicenseComments
	}).(pulumi.StringPtrOutput)
}

// package or alternative values, if the governing license cannot be determined
func (o PackageOccurrencePtrOutput) LicenseConcluded() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.LicenseConcluded
	}).(pulumi.StringPtrOutput)
}

// Provide a place for the SPDX file creator to record any relevant background information or additional comments about the origin of the package
func (o PackageOccurrencePtrOutput) SourceInfo() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.SourceInfo
	}).(pulumi.StringPtrOutput)
}

// PackageOccurrence represents an SPDX Package Information section: https://spdx.github.io/spdx-spec/3-package-information/
type PackageOccurrenceResponse struct {
	// A place for the SPDX file creator to record any general comments about the package being described
	Comment string `pulumi:"comment"`
	// Provide the actual file name of the package, or path of the directory being treated as a package
	Filename string `pulumi:"filename"`
	// This field provides a place for the SPDX file creator to record any relevant background information or analysis that went in to arriving at the Concluded License for a package
	LicenseComments string `pulumi:"licenseComments"`
	// package or alternative values, if the governing license cannot be determined
	LicenseConcluded string `pulumi:"licenseConcluded"`
	// Provide a place for the SPDX file creator to record any relevant background information or additional comments about the origin of the package
	SourceInfo string `pulumi:"sourceInfo"`
}

// PackageOccurrenceResponseInput is an input type that accepts PackageOccurrenceResponseArgs and PackageOccurrenceResponseOutput values.
// You can construct a concrete instance of `PackageOccurrenceResponseInput` via:
//
//          PackageOccurrenceResponseArgs{...}
type PackageOccurrenceResponseInput interface {
	pulumi.Input

	ToPackageOccurrenceResponseOutput() PackageOccurrenceResponseOutput
	ToPackageOccurrenceResponseOutputWithContext(context.Context) PackageOccurrenceResponseOutput
}

// PackageOccurrence represents an SPDX Package Information section: https://spdx.github.io/spdx-spec/3-package-information/
type PackageOccurrenceResponseArgs struct {
	// A place for the SPDX file creator to record any general comments about the package being described
	Comment pulumi.StringInput `pulumi:"comment"`
	// Provide the actual file name of the package, or path of the directory being treated as a package
	Filename pulumi.StringInput `pulumi:"filename"`
	// This field provides a place for the SPDX file creator to record any relevant background information or analysis that went in to arriving at the Concluded License for a package
	LicenseComments pulumi.StringInput `pulumi:"licenseComments"`
	// package or alternative values, if the governing license cannot be determined
	LicenseConcluded pulumi.StringInput `pulumi:"licenseConcluded"`
	// Provide a place for the SPDX file creator to record any relevant background information or additional comments about the origin of the package
	SourceInfo pulumi.StringInput `pulumi:"sourceInfo"`
}

func (PackageOccurrenceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PackageOccurrenceResponse)(nil)).Elem()
}

func (i PackageOccurrenceResponseArgs) ToPackageOccurrenceResponseOutput() PackageOccurrenceResponseOutput {
	return i.ToPackageOccurrenceResponseOutputWithContext(context.Background())
}

func (i PackageOccurrenceResponseArgs) ToPackageOccurrenceResponseOutputWithContext(ctx context.Context) PackageOccurrenceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageOccurrenceResponseOutput)
}

func (i PackageOccurrenceResponseArgs) ToPackageOccurrenceResponsePtrOutput() PackageOccurrenceResponsePtrOutput {
	return i.ToPackageOccurrenceResponsePtrOutputWithContext(context.Background())
}

func (i PackageOccurrenceResponseArgs) ToPackageOccurrenceResponsePtrOutputWithContext(ctx context.Context) PackageOccurrenceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageOccurrenceResponseOutput).ToPackageOccurrenceResponsePtrOutputWithContext(ctx)
}

// PackageOccurrenceResponsePtrInput is an input type that accepts PackageOccurrenceResponseArgs, PackageOccurrenceResponsePtr and PackageOccurrenceResponsePtrOutput values.
// You can construct a concrete instance of `PackageOccurrenceResponsePtrInput` via:
//
//          PackageOccurrenceResponseArgs{...}
//
//  or:
//
//          nil
type PackageOccurrenceResponsePtrInput interface {
	pulumi.Input

	ToPackageOccurrenceResponsePtrOutput() PackageOccurrenceResponsePtrOutput
	ToPackageOccurrenceResponsePtrOutputWithContext(context.Context) PackageOccurrenceResponsePtrOutput
}

type packageOccurrenceResponsePtrType PackageOccurrenceResponseArgs

func PackageOccurrenceResponsePtr(v *PackageOccurrenceResponseArgs) PackageOccurrenceResponsePtrInput {
	return (*packageOccurrenceResponsePtrType)(v)
}

func (*packageOccurrenceResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageOccurrenceResponse)(nil)).Elem()
}

func (i *packageOccurrenceResponsePtrType) ToPackageOccurrenceResponsePtrOutput() PackageOccurrenceResponsePtrOutput {
	return i.ToPackageOccurrenceResponsePtrOutputWithContext(context.Background())
}

func (i *packageOccurrenceResponsePtrType) ToPackageOccurrenceResponsePtrOutputWithContext(ctx context.Context) PackageOccurrenceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageOccurrenceResponsePtrOutput)
}

// PackageOccurrence represents an SPDX Package Information section: https://spdx.github.io/spdx-spec/3-package-information/
type PackageOccurrenceResponseOutput struct{ *pulumi.OutputState }

func (PackageOccurrenceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PackageOccurrenceResponse)(nil)).Elem()
}

func (o PackageOccurrenceResponseOutput) ToPackageOccurrenceResponseOutput() PackageOccurrenceResponseOutput {
	return o
}

func (o PackageOccurrenceResponseOutput) ToPackageOccurrenceResponseOutputWithContext(ctx context.Context) PackageOccurrenceResponseOutput {
	return o
}

func (o PackageOccurrenceResponseOutput) ToPackageOccurrenceResponsePtrOutput() PackageOccurrenceResponsePtrOutput {
	return o.ToPackageOccurrenceResponsePtrOutputWithContext(context.Background())
}

func (o PackageOccurrenceResponseOutput) ToPackageOccurrenceResponsePtrOutputWithContext(ctx context.Context) PackageOccurrenceResponsePtrOutput {
	return o.ApplyT(func(v PackageOccurrenceResponse) *PackageOccurrenceResponse {
		return &v
	}).(PackageOccurrenceResponsePtrOutput)
}

// A place for the SPDX file creator to record any general comments about the package being described
func (o PackageOccurrenceResponseOutput) Comment() pulumi.StringOutput {
	return o.ApplyT(func(v PackageOccurrenceResponse) string { return v.Comment }).(pulumi.StringOutput)
}

// Provide the actual file name of the package, or path of the directory being treated as a package
func (o PackageOccurrenceResponseOutput) Filename() pulumi.StringOutput {
	return o.ApplyT(func(v PackageOccurrenceResponse) string { return v.Filename }).(pulumi.StringOutput)
}

// This field provides a place for the SPDX file creator to record any relevant background information or analysis that went in to arriving at the Concluded License for a package
func (o PackageOccurrenceResponseOutput) LicenseComments() pulumi.StringOutput {
	return o.ApplyT(func(v PackageOccurrenceResponse) string { return v.LicenseComments }).(pulumi.StringOutput)
}

// package or alternative values, if the governing license cannot be determined
func (o PackageOccurrenceResponseOutput) LicenseConcluded() pulumi.StringOutput {
	return o.ApplyT(func(v PackageOccurrenceResponse) string { return v.LicenseConcluded }).(pulumi.StringOutput)
}

// Provide a place for the SPDX file creator to record any relevant background information or additional comments about the origin of the package
func (o PackageOccurrenceResponseOutput) SourceInfo() pulumi.StringOutput {
	return o.ApplyT(func(v PackageOccurrenceResponse) string { return v.SourceInfo }).(pulumi.StringOutput)
}

type PackageOccurrenceResponsePtrOutput struct{ *pulumi.OutputState }

func (PackageOccurrenceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageOccurrenceResponse)(nil)).Elem()
}

func (o PackageOccurrenceResponsePtrOutput) ToPackageOccurrenceResponsePtrOutput() PackageOccurrenceResponsePtrOutput {
	return o
}

func (o PackageOccurrenceResponsePtrOutput) ToPackageOccurrenceResponsePtrOutputWithContext(ctx context.Context) PackageOccurrenceResponsePtrOutput {
	return o
}

func (o PackageOccurrenceResponsePtrOutput) Elem() PackageOccurrenceResponseOutput {
	return o.ApplyT(func(v *PackageOccurrenceResponse) PackageOccurrenceResponse { return *v }).(PackageOccurrenceResponseOutput)
}

// A place for the SPDX file creator to record any general comments about the package being described
func (o PackageOccurrenceResponsePtrOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Comment
	}).(pulumi.StringPtrOutput)
}

// Provide the actual file name of the package, or path of the directory being treated as a package
func (o PackageOccurrenceResponsePtrOutput) Filename() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Filename
	}).(pulumi.StringPtrOutput)
}

// This field provides a place for the SPDX file creator to record any relevant background information or analysis that went in to arriving at the Concluded License for a package
func (o PackageOccurrenceResponsePtrOutput) LicenseComments() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.LicenseComments
	}).(pulumi.StringPtrOutput)
}

// package or alternative values, if the governing license cannot be determined
func (o PackageOccurrenceResponsePtrOutput) LicenseConcluded() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.LicenseConcluded
	}).(pulumi.StringPtrOutput)
}

// Provide a place for the SPDX file creator to record any relevant background information or additional comments about the origin of the package
func (o PackageOccurrenceResponsePtrOutput) SourceInfo() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.SourceInfo
	}).(pulumi.StringPtrOutput)
}

// This represents a particular package that is distributed over various channels. E.g., glibc (aka libc6) is distributed by many, at various versions.
type PackageResponse struct {
	// The various channels by which a package is distributed.
	Distribution []DistributionResponse `pulumi:"distribution"`
	// Immutable. The name of the package.
	Name string `pulumi:"name"`
}

// PackageResponseInput is an input type that accepts PackageResponseArgs and PackageResponseOutput values.
// You can construct a concrete instance of `PackageResponseInput` via:
//
//          PackageResponseArgs{...}
type PackageResponseInput interface {
	pulumi.Input

	ToPackageResponseOutput() PackageResponseOutput
	ToPackageResponseOutputWithContext(context.Context) PackageResponseOutput
}

// This represents a particular package that is distributed over various channels. E.g., glibc (aka libc6) is distributed by many, at various versions.
type PackageResponseArgs struct {
	// The various channels by which a package is distributed.
	Distribution DistributionResponseArrayInput `pulumi:"distribution"`
	// Immutable. The name of the package.
	Name pulumi.StringInput `pulumi:"name"`
}

func (PackageResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PackageResponse)(nil)).Elem()
}

func (i PackageResponseArgs) ToPackageResponseOutput() PackageResponseOutput {
	return i.ToPackageResponseOutputWithContext(context.Background())
}

func (i PackageResponseArgs) ToPackageResponseOutputWithContext(ctx context.Context) PackageResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageResponseOutput)
}

func (i PackageResponseArgs) ToPackageResponsePtrOutput() PackageResponsePtrOutput {
	return i.ToPackageResponsePtrOutputWithContext(context.Background())
}

func (i PackageResponseArgs) ToPackageResponsePtrOutputWithContext(ctx context.Context) PackageResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageResponseOutput).ToPackageResponsePtrOutputWithContext(ctx)
}

// PackageResponsePtrInput is an input type that accepts PackageResponseArgs, PackageResponsePtr and PackageResponsePtrOutput values.
// You can construct a concrete instance of `PackageResponsePtrInput` via:
//
//          PackageResponseArgs{...}
//
//  or:
//
//          nil
type PackageResponsePtrInput interface {
	pulumi.Input

	ToPackageResponsePtrOutput() PackageResponsePtrOutput
	ToPackageResponsePtrOutputWithContext(context.Context) PackageResponsePtrOutput
}

type packageResponsePtrType PackageResponseArgs

func PackageResponsePtr(v *PackageResponseArgs) PackageResponsePtrInput {
	return (*packageResponsePtrType)(v)
}

func (*packageResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageResponse)(nil)).Elem()
}

func (i *packageResponsePtrType) ToPackageResponsePtrOutput() PackageResponsePtrOutput {
	return i.ToPackageResponsePtrOutputWithContext(context.Background())
}

func (i *packageResponsePtrType) ToPackageResponsePtrOutputWithContext(ctx context.Context) PackageResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageResponsePtrOutput)
}

// This represents a particular package that is distributed over various channels. E.g., glibc (aka libc6) is distributed by many, at various versions.
type PackageResponseOutput struct{ *pulumi.OutputState }

func (PackageResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PackageResponse)(nil)).Elem()
}

func (o PackageResponseOutput) ToPackageResponseOutput() PackageResponseOutput {
	return o
}

func (o PackageResponseOutput) ToPackageResponseOutputWithContext(ctx context.Context) PackageResponseOutput {
	return o
}

func (o PackageResponseOutput) ToPackageResponsePtrOutput() PackageResponsePtrOutput {
	return o.ToPackageResponsePtrOutputWithContext(context.Background())
}

func (o PackageResponseOutput) ToPackageResponsePtrOutputWithContext(ctx context.Context) PackageResponsePtrOutput {
	return o.ApplyT(func(v PackageResponse) *PackageResponse {
		return &v
	}).(PackageResponsePtrOutput)
}

// The various channels by which a package is distributed.
func (o PackageResponseOutput) Distribution() DistributionResponseArrayOutput {
	return o.ApplyT(func(v PackageResponse) []DistributionResponse { return v.Distribution }).(DistributionResponseArrayOutput)
}

// Immutable. The name of the package.
func (o PackageResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v PackageResponse) string { return v.Name }).(pulumi.StringOutput)
}

type PackageResponsePtrOutput struct{ *pulumi.OutputState }

func (PackageResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageResponse)(nil)).Elem()
}

func (o PackageResponsePtrOutput) ToPackageResponsePtrOutput() PackageResponsePtrOutput {
	return o
}

func (o PackageResponsePtrOutput) ToPackageResponsePtrOutputWithContext(ctx context.Context) PackageResponsePtrOutput {
	return o
}

func (o PackageResponsePtrOutput) Elem() PackageResponseOutput {
	return o.ApplyT(func(v *PackageResponse) PackageResponse { return *v }).(PackageResponseOutput)
}

// The various channels by which a package is distributed.
func (o PackageResponsePtrOutput) Distribution() DistributionResponseArrayOutput {
	return o.ApplyT(func(v *PackageResponse) []DistributionResponse {
		if v == nil {
			return nil
		}
		return v.Distribution
	}).(DistributionResponseArrayOutput)
}

// Immutable. The name of the package.
func (o PackageResponsePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// An attestation wrapper with a PGP-compatible signature. This message only supports `ATTACHED` signatures, where the payload that is signed is included alongside the signature itself in the same file.
type PgpSignedAttestation struct {
	// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
	ContentType *PgpSignedAttestationContentType `pulumi:"contentType"`
	// The cryptographic fingerprint of the key used to generate the signature, as output by, e.g. `gpg --list-keys`. This should be the version 4, full 160-bit fingerprint, expressed as a 40 character hexidecimal string. See https://tools.ietf.org/html/rfc4880#section-12.2 for details. Implementations may choose to acknowledge "LONG", "SHORT", or other abbreviated key IDs, but only the full fingerprint is guaranteed to work. In gpg, the full fingerprint can be retrieved from the `fpr` field returned when calling --list-keys with --with-colons. For example: ```gpg --with-colons --with-fingerprint --force-v4-certs \ --list-keys attester@example.com tru::1:1513631572:0:3:1:5 pub:...... fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:``` Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
	PgpKeyId *string `pulumi:"pgpKeyId"`
	// The raw content of the signature, as output by GNU Privacy Guard (GPG) or equivalent. Since this message only supports attached signatures, the payload that was signed must be attached. While the signature format supported is dependent on the verification implementation, currently only ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor --output=signature.gpg payload.json` will create the signature content expected in this field in `signature.gpg` for the `payload.json` attestation payload.
	Signature string `pulumi:"signature"`
}

// PgpSignedAttestationInput is an input type that accepts PgpSignedAttestationArgs and PgpSignedAttestationOutput values.
// You can construct a concrete instance of `PgpSignedAttestationInput` via:
//
//          PgpSignedAttestationArgs{...}
type PgpSignedAttestationInput interface {
	pulumi.Input

	ToPgpSignedAttestationOutput() PgpSignedAttestationOutput
	ToPgpSignedAttestationOutputWithContext(context.Context) PgpSignedAttestationOutput
}

// An attestation wrapper with a PGP-compatible signature. This message only supports `ATTACHED` signatures, where the payload that is signed is included alongside the signature itself in the same file.
type PgpSignedAttestationArgs struct {
	// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
	ContentType PgpSignedAttestationContentTypePtrInput `pulumi:"contentType"`
	// The cryptographic fingerprint of the key used to generate the signature, as output by, e.g. `gpg --list-keys`. This should be the version 4, full 160-bit fingerprint, expressed as a 40 character hexidecimal string. See https://tools.ietf.org/html/rfc4880#section-12.2 for details. Implementations may choose to acknowledge "LONG", "SHORT", or other abbreviated key IDs, but only the full fingerprint is guaranteed to work. In gpg, the full fingerprint can be retrieved from the `fpr` field returned when calling --list-keys with --with-colons. For example: ```gpg --with-colons --with-fingerprint --force-v4-certs \ --list-keys attester@example.com tru::1:1513631572:0:3:1:5 pub:...... fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:``` Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
	PgpKeyId pulumi.StringPtrInput `pulumi:"pgpKeyId"`
	// The raw content of the signature, as output by GNU Privacy Guard (GPG) or equivalent. Since this message only supports attached signatures, the payload that was signed must be attached. While the signature format supported is dependent on the verification implementation, currently only ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor --output=signature.gpg payload.json` will create the signature content expected in this field in `signature.gpg` for the `payload.json` attestation payload.
	Signature pulumi.StringInput `pulumi:"signature"`
}

func (PgpSignedAttestationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PgpSignedAttestation)(nil)).Elem()
}

func (i PgpSignedAttestationArgs) ToPgpSignedAttestationOutput() PgpSignedAttestationOutput {
	return i.ToPgpSignedAttestationOutputWithContext(context.Background())
}

func (i PgpSignedAttestationArgs) ToPgpSignedAttestationOutputWithContext(ctx context.Context) PgpSignedAttestationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PgpSignedAttestationOutput)
}

func (i PgpSignedAttestationArgs) ToPgpSignedAttestationPtrOutput() PgpSignedAttestationPtrOutput {
	return i.ToPgpSignedAttestationPtrOutputWithContext(context.Background())
}

func (i PgpSignedAttestationArgs) ToPgpSignedAttestationPtrOutputWithContext(ctx context.Context) PgpSignedAttestationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PgpSignedAttestationOutput).ToPgpSignedAttestationPtrOutputWithContext(ctx)
}

// PgpSignedAttestationPtrInput is an input type that accepts PgpSignedAttestationArgs, PgpSignedAttestationPtr and PgpSignedAttestationPtrOutput values.
// You can construct a concrete instance of `PgpSignedAttestationPtrInput` via:
//
//          PgpSignedAttestationArgs{...}
//
//  or:
//
//          nil
type PgpSignedAttestationPtrInput interface {
	pulumi.Input

	ToPgpSignedAttestationPtrOutput() PgpSignedAttestationPtrOutput
	ToPgpSignedAttestationPtrOutputWithContext(context.Context) PgpSignedAttestationPtrOutput
}

type pgpSignedAttestationPtrType PgpSignedAttestationArgs

func PgpSignedAttestationPtr(v *PgpSignedAttestationArgs) PgpSignedAttestationPtrInput {
	return (*pgpSignedAttestationPtrType)(v)
}

func (*pgpSignedAttestationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PgpSignedAttestation)(nil)).Elem()
}

func (i *pgpSignedAttestationPtrType) ToPgpSignedAttestationPtrOutput() PgpSignedAttestationPtrOutput {
	return i.ToPgpSignedAttestationPtrOutputWithContext(context.Background())
}

func (i *pgpSignedAttestationPtrType) ToPgpSignedAttestationPtrOutputWithContext(ctx context.Context) PgpSignedAttestationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PgpSignedAttestationPtrOutput)
}

// An attestation wrapper with a PGP-compatible signature. This message only supports `ATTACHED` signatures, where the payload that is signed is included alongside the signature itself in the same file.
type PgpSignedAttestationOutput struct{ *pulumi.OutputState }

func (PgpSignedAttestationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PgpSignedAttestation)(nil)).Elem()
}

func (o PgpSignedAttestationOutput) ToPgpSignedAttestationOutput() PgpSignedAttestationOutput {
	return o
}

func (o PgpSignedAttestationOutput) ToPgpSignedAttestationOutputWithContext(ctx context.Context) PgpSignedAttestationOutput {
	return o
}

func (o PgpSignedAttestationOutput) ToPgpSignedAttestationPtrOutput() PgpSignedAttestationPtrOutput {
	return o.ToPgpSignedAttestationPtrOutputWithContext(context.Background())
}

func (o PgpSignedAttestationOutput) ToPgpSignedAttestationPtrOutputWithContext(ctx context.Context) PgpSignedAttestationPtrOutput {
	return o.ApplyT(func(v PgpSignedAttestation) *PgpSignedAttestation {
		return &v
	}).(PgpSignedAttestationPtrOutput)
}

// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
func (o PgpSignedAttestationOutput) ContentType() PgpSignedAttestationContentTypePtrOutput {
	return o.ApplyT(func(v PgpSignedAttestation) *PgpSignedAttestationContentType { return v.ContentType }).(PgpSignedAttestationContentTypePtrOutput)
}

// The cryptographic fingerprint of the key used to generate the signature, as output by, e.g. `gpg --list-keys`. This should be the version 4, full 160-bit fingerprint, expressed as a 40 character hexidecimal string. See https://tools.ietf.org/html/rfc4880#section-12.2 for details. Implementations may choose to acknowledge "LONG", "SHORT", or other abbreviated key IDs, but only the full fingerprint is guaranteed to work. In gpg, the full fingerprint can be retrieved from the `fpr` field returned when calling --list-keys with --with-colons. For example: ```gpg --with-colons --with-fingerprint --force-v4-certs \ --list-keys attester@example.com tru::1:1513631572:0:3:1:5 pub:...... fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:``` Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
func (o PgpSignedAttestationOutput) PgpKeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PgpSignedAttestation) *string { return v.PgpKeyId }).(pulumi.StringPtrOutput)
}

// The raw content of the signature, as output by GNU Privacy Guard (GPG) or equivalent. Since this message only supports attached signatures, the payload that was signed must be attached. While the signature format supported is dependent on the verification implementation, currently only ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor --output=signature.gpg payload.json` will create the signature content expected in this field in `signature.gpg` for the `payload.json` attestation payload.
func (o PgpSignedAttestationOutput) Signature() pulumi.StringOutput {
	return o.ApplyT(func(v PgpSignedAttestation) string { return v.Signature }).(pulumi.StringOutput)
}

type PgpSignedAttestationPtrOutput struct{ *pulumi.OutputState }

func (PgpSignedAttestationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PgpSignedAttestation)(nil)).Elem()
}

func (o PgpSignedAttestationPtrOutput) ToPgpSignedAttestationPtrOutput() PgpSignedAttestationPtrOutput {
	return o
}

func (o PgpSignedAttestationPtrOutput) ToPgpSignedAttestationPtrOutputWithContext(ctx context.Context) PgpSignedAttestationPtrOutput {
	return o
}

func (o PgpSignedAttestationPtrOutput) Elem() PgpSignedAttestationOutput {
	return o.ApplyT(func(v *PgpSignedAttestation) PgpSignedAttestation { return *v }).(PgpSignedAttestationOutput)
}

// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
func (o PgpSignedAttestationPtrOutput) ContentType() PgpSignedAttestationContentTypePtrOutput {
	return o.ApplyT(func(v *PgpSignedAttestation) *PgpSignedAttestationContentType {
		if v == nil {
			return nil
		}
		return v.ContentType
	}).(PgpSignedAttestationContentTypePtrOutput)
}

// The cryptographic fingerprint of the key used to generate the signature, as output by, e.g. `gpg --list-keys`. This should be the version 4, full 160-bit fingerprint, expressed as a 40 character hexidecimal string. See https://tools.ietf.org/html/rfc4880#section-12.2 for details. Implementations may choose to acknowledge "LONG", "SHORT", or other abbreviated key IDs, but only the full fingerprint is guaranteed to work. In gpg, the full fingerprint can be retrieved from the `fpr` field returned when calling --list-keys with --with-colons. For example: ```gpg --with-colons --with-fingerprint --force-v4-certs \ --list-keys attester@example.com tru::1:1513631572:0:3:1:5 pub:...... fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:``` Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
func (o PgpSignedAttestationPtrOutput) PgpKeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PgpSignedAttestation) *string {
		if v == nil {
			return nil
		}
		return v.PgpKeyId
	}).(pulumi.StringPtrOutput)
}

// The raw content of the signature, as output by GNU Privacy Guard (GPG) or equivalent. Since this message only supports attached signatures, the payload that was signed must be attached. While the signature format supported is dependent on the verification implementation, currently only ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor --output=signature.gpg payload.json` will create the signature content expected in this field in `signature.gpg` for the `payload.json` attestation payload.
func (o PgpSignedAttestationPtrOutput) Signature() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PgpSignedAttestation) *string {
		if v == nil {
			return nil
		}
		return &v.Signature
	}).(pulumi.StringPtrOutput)
}

// An attestation wrapper with a PGP-compatible signature. This message only supports `ATTACHED` signatures, where the payload that is signed is included alongside the signature itself in the same file.
type PgpSignedAttestationResponse struct {
	// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
	ContentType string `pulumi:"contentType"`
	// The cryptographic fingerprint of the key used to generate the signature, as output by, e.g. `gpg --list-keys`. This should be the version 4, full 160-bit fingerprint, expressed as a 40 character hexidecimal string. See https://tools.ietf.org/html/rfc4880#section-12.2 for details. Implementations may choose to acknowledge "LONG", "SHORT", or other abbreviated key IDs, but only the full fingerprint is guaranteed to work. In gpg, the full fingerprint can be retrieved from the `fpr` field returned when calling --list-keys with --with-colons. For example: ```gpg --with-colons --with-fingerprint --force-v4-certs \ --list-keys attester@example.com tru::1:1513631572:0:3:1:5 pub:...... fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:``` Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
	PgpKeyId string `pulumi:"pgpKeyId"`
	// The raw content of the signature, as output by GNU Privacy Guard (GPG) or equivalent. Since this message only supports attached signatures, the payload that was signed must be attached. While the signature format supported is dependent on the verification implementation, currently only ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor --output=signature.gpg payload.json` will create the signature content expected in this field in `signature.gpg` for the `payload.json` attestation payload.
	Signature string `pulumi:"signature"`
}

// PgpSignedAttestationResponseInput is an input type that accepts PgpSignedAttestationResponseArgs and PgpSignedAttestationResponseOutput values.
// You can construct a concrete instance of `PgpSignedAttestationResponseInput` via:
//
//          PgpSignedAttestationResponseArgs{...}
type PgpSignedAttestationResponseInput interface {
	pulumi.Input

	ToPgpSignedAttestationResponseOutput() PgpSignedAttestationResponseOutput
	ToPgpSignedAttestationResponseOutputWithContext(context.Context) PgpSignedAttestationResponseOutput
}

// An attestation wrapper with a PGP-compatible signature. This message only supports `ATTACHED` signatures, where the payload that is signed is included alongside the signature itself in the same file.
type PgpSignedAttestationResponseArgs struct {
	// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
	ContentType pulumi.StringInput `pulumi:"contentType"`
	// The cryptographic fingerprint of the key used to generate the signature, as output by, e.g. `gpg --list-keys`. This should be the version 4, full 160-bit fingerprint, expressed as a 40 character hexidecimal string. See https://tools.ietf.org/html/rfc4880#section-12.2 for details. Implementations may choose to acknowledge "LONG", "SHORT", or other abbreviated key IDs, but only the full fingerprint is guaranteed to work. In gpg, the full fingerprint can be retrieved from the `fpr` field returned when calling --list-keys with --with-colons. For example: ```gpg --with-colons --with-fingerprint --force-v4-certs \ --list-keys attester@example.com tru::1:1513631572:0:3:1:5 pub:...... fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:``` Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
	PgpKeyId pulumi.StringInput `pulumi:"pgpKeyId"`
	// The raw content of the signature, as output by GNU Privacy Guard (GPG) or equivalent. Since this message only supports attached signatures, the payload that was signed must be attached. While the signature format supported is dependent on the verification implementation, currently only ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor --output=signature.gpg payload.json` will create the signature content expected in this field in `signature.gpg` for the `payload.json` attestation payload.
	Signature pulumi.StringInput `pulumi:"signature"`
}

func (PgpSignedAttestationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PgpSignedAttestationResponse)(nil)).Elem()
}

func (i PgpSignedAttestationResponseArgs) ToPgpSignedAttestationResponseOutput() PgpSignedAttestationResponseOutput {
	return i.ToPgpSignedAttestationResponseOutputWithContext(context.Background())
}

func (i PgpSignedAttestationResponseArgs) ToPgpSignedAttestationResponseOutputWithContext(ctx context.Context) PgpSignedAttestationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PgpSignedAttestationResponseOutput)
}

func (i PgpSignedAttestationResponseArgs) ToPgpSignedAttestationResponsePtrOutput() PgpSignedAttestationResponsePtrOutput {
	return i.ToPgpSignedAttestationResponsePtrOutputWithContext(context.Background())
}

func (i PgpSignedAttestationResponseArgs) ToPgpSignedAttestationResponsePtrOutputWithContext(ctx context.Context) PgpSignedAttestationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PgpSignedAttestationResponseOutput).ToPgpSignedAttestationResponsePtrOutputWithContext(ctx)
}

// PgpSignedAttestationResponsePtrInput is an input type that accepts PgpSignedAttestationResponseArgs, PgpSignedAttestationResponsePtr and PgpSignedAttestationResponsePtrOutput values.
// You can construct a concrete instance of `PgpSignedAttestationResponsePtrInput` via:
//
//          PgpSignedAttestationResponseArgs{...}
//
//  or:
//
//          nil
type PgpSignedAttestationResponsePtrInput interface {
	pulumi.Input

	ToPgpSignedAttestationResponsePtrOutput() PgpSignedAttestationResponsePtrOutput
	ToPgpSignedAttestationResponsePtrOutputWithContext(context.Context) PgpSignedAttestationResponsePtrOutput
}

type pgpSignedAttestationResponsePtrType PgpSignedAttestationResponseArgs

func PgpSignedAttestationResponsePtr(v *PgpSignedAttestationResponseArgs) PgpSignedAttestationResponsePtrInput {
	return (*pgpSignedAttestationResponsePtrType)(v)
}

func (*pgpSignedAttestationResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PgpSignedAttestationResponse)(nil)).Elem()
}

func (i *pgpSignedAttestationResponsePtrType) ToPgpSignedAttestationResponsePtrOutput() PgpSignedAttestationResponsePtrOutput {
	return i.ToPgpSignedAttestationResponsePtrOutputWithContext(context.Background())
}

func (i *pgpSignedAttestationResponsePtrType) ToPgpSignedAttestationResponsePtrOutputWithContext(ctx context.Context) PgpSignedAttestationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PgpSignedAttestationResponsePtrOutput)
}

// An attestation wrapper with a PGP-compatible signature. This message only supports `ATTACHED` signatures, where the payload that is signed is included alongside the signature itself in the same file.
type PgpSignedAttestationResponseOutput struct{ *pulumi.OutputState }

func (PgpSignedAttestationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PgpSignedAttestationResponse)(nil)).Elem()
}

func (o PgpSignedAttestationResponseOutput) ToPgpSignedAttestationResponseOutput() PgpSignedAttestationResponseOutput {
	return o
}

func (o PgpSignedAttestationResponseOutput) ToPgpSignedAttestationResponseOutputWithContext(ctx context.Context) PgpSignedAttestationResponseOutput {
	return o
}

func (o PgpSignedAttestationResponseOutput) ToPgpSignedAttestationResponsePtrOutput() PgpSignedAttestationResponsePtrOutput {
	return o.ToPgpSignedAttestationResponsePtrOutputWithContext(context.Background())
}

func (o PgpSignedAttestationResponseOutput) ToPgpSignedAttestationResponsePtrOutputWithContext(ctx context.Context) PgpSignedAttestationResponsePtrOutput {
	return o.ApplyT(func(v PgpSignedAttestationResponse) *PgpSignedAttestationResponse {
		return &v
	}).(PgpSignedAttestationResponsePtrOutput)
}

// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
func (o PgpSignedAttestationResponseOutput) ContentType() pulumi.StringOutput {
	return o.ApplyT(func(v PgpSignedAttestationResponse) string { return v.ContentType }).(pulumi.StringOutput)
}

// The cryptographic fingerprint of the key used to generate the signature, as output by, e.g. `gpg --list-keys`. This should be the version 4, full 160-bit fingerprint, expressed as a 40 character hexidecimal string. See https://tools.ietf.org/html/rfc4880#section-12.2 for details. Implementations may choose to acknowledge "LONG", "SHORT", or other abbreviated key IDs, but only the full fingerprint is guaranteed to work. In gpg, the full fingerprint can be retrieved from the `fpr` field returned when calling --list-keys with --with-colons. For example: ```gpg --with-colons --with-fingerprint --force-v4-certs \ --list-keys attester@example.com tru::1:1513631572:0:3:1:5 pub:...... fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:``` Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
func (o PgpSignedAttestationResponseOutput) PgpKeyId() pulumi.StringOutput {
	return o.ApplyT(func(v PgpSignedAttestationResponse) string { return v.PgpKeyId }).(pulumi.StringOutput)
}

// The raw content of the signature, as output by GNU Privacy Guard (GPG) or equivalent. Since this message only supports attached signatures, the payload that was signed must be attached. While the signature format supported is dependent on the verification implementation, currently only ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor --output=signature.gpg payload.json` will create the signature content expected in this field in `signature.gpg` for the `payload.json` attestation payload.
func (o PgpSignedAttestationResponseOutput) Signature() pulumi.StringOutput {
	return o.ApplyT(func(v PgpSignedAttestationResponse) string { return v.Signature }).(pulumi.StringOutput)
}

type PgpSignedAttestationResponsePtrOutput struct{ *pulumi.OutputState }

func (PgpSignedAttestationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PgpSignedAttestationResponse)(nil)).Elem()
}

func (o PgpSignedAttestationResponsePtrOutput) ToPgpSignedAttestationResponsePtrOutput() PgpSignedAttestationResponsePtrOutput {
	return o
}

func (o PgpSignedAttestationResponsePtrOutput) ToPgpSignedAttestationResponsePtrOutputWithContext(ctx context.Context) PgpSignedAttestationResponsePtrOutput {
	return o
}

func (o PgpSignedAttestationResponsePtrOutput) Elem() PgpSignedAttestationResponseOutput {
	return o.ApplyT(func(v *PgpSignedAttestationResponse) PgpSignedAttestationResponse { return *v }).(PgpSignedAttestationResponseOutput)
}

// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
func (o PgpSignedAttestationResponsePtrOutput) ContentType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PgpSignedAttestationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ContentType
	}).(pulumi.StringPtrOutput)
}

// The cryptographic fingerprint of the key used to generate the signature, as output by, e.g. `gpg --list-keys`. This should be the version 4, full 160-bit fingerprint, expressed as a 40 character hexidecimal string. See https://tools.ietf.org/html/rfc4880#section-12.2 for details. Implementations may choose to acknowledge "LONG", "SHORT", or other abbreviated key IDs, but only the full fingerprint is guaranteed to work. In gpg, the full fingerprint can be retrieved from the `fpr` field returned when calling --list-keys with --with-colons. For example: ```gpg --with-colons --with-fingerprint --force-v4-certs \ --list-keys attester@example.com tru::1:1513631572:0:3:1:5 pub:...... fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:``` Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
func (o PgpSignedAttestationResponsePtrOutput) PgpKeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PgpSignedAttestationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.PgpKeyId
	}).(pulumi.StringPtrOutput)
}

// The raw content of the signature, as output by GNU Privacy Guard (GPG) or equivalent. Since this message only supports attached signatures, the payload that was signed must be attached. While the signature format supported is dependent on the verification implementation, currently only ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor --output=signature.gpg payload.json` will create the signature content expected in this field in `signature.gpg` for the `payload.json` attestation payload.
func (o PgpSignedAttestationResponsePtrOutput) Signature() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PgpSignedAttestationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Signature
	}).(pulumi.StringPtrOutput)
}

// Selects a repo using a Google Cloud Platform project ID (e.g., winged-cargo-31) and a repo name within that project.
type ProjectRepoId struct {
	// The ID of the project.
	Project *string `pulumi:"project"`
	// The name of the repo. Leave empty for the default repo.
	RepoName *string `pulumi:"repoName"`
}

// ProjectRepoIdInput is an input type that accepts ProjectRepoIdArgs and ProjectRepoIdOutput values.
// You can construct a concrete instance of `ProjectRepoIdInput` via:
//
//          ProjectRepoIdArgs{...}
type ProjectRepoIdInput interface {
	pulumi.Input

	ToProjectRepoIdOutput() ProjectRepoIdOutput
	ToProjectRepoIdOutputWithContext(context.Context) ProjectRepoIdOutput
}

// Selects a repo using a Google Cloud Platform project ID (e.g., winged-cargo-31) and a repo name within that project.
type ProjectRepoIdArgs struct {
	// The ID of the project.
	Project pulumi.StringPtrInput `pulumi:"project"`
	// The name of the repo. Leave empty for the default repo.
	RepoName pulumi.StringPtrInput `pulumi:"repoName"`
}

func (ProjectRepoIdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ProjectRepoId)(nil)).Elem()
}

func (i ProjectRepoIdArgs) ToProjectRepoIdOutput() ProjectRepoIdOutput {
	return i.ToProjectRepoIdOutputWithContext(context.Background())
}

func (i ProjectRepoIdArgs) ToProjectRepoIdOutputWithContext(ctx context.Context) ProjectRepoIdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectRepoIdOutput)
}

func (i ProjectRepoIdArgs) ToProjectRepoIdPtrOutput() ProjectRepoIdPtrOutput {
	return i.ToProjectRepoIdPtrOutputWithContext(context.Background())
}

func (i ProjectRepoIdArgs) ToProjectRepoIdPtrOutputWithContext(ctx context.Context) ProjectRepoIdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectRepoIdOutput).ToProjectRepoIdPtrOutputWithContext(ctx)
}

// ProjectRepoIdPtrInput is an input type that accepts ProjectRepoIdArgs, ProjectRepoIdPtr and ProjectRepoIdPtrOutput values.
// You can construct a concrete instance of `ProjectRepoIdPtrInput` via:
//
//          ProjectRepoIdArgs{...}
//
//  or:
//
//          nil
type ProjectRepoIdPtrInput interface {
	pulumi.Input

	ToProjectRepoIdPtrOutput() ProjectRepoIdPtrOutput
	ToProjectRepoIdPtrOutputWithContext(context.Context) ProjectRepoIdPtrOutput
}

type projectRepoIdPtrType ProjectRepoIdArgs

func ProjectRepoIdPtr(v *ProjectRepoIdArgs) ProjectRepoIdPtrInput {
	return (*projectRepoIdPtrType)(v)
}

func (*projectRepoIdPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ProjectRepoId)(nil)).Elem()
}

func (i *projectRepoIdPtrType) ToProjectRepoIdPtrOutput() ProjectRepoIdPtrOutput {
	return i.ToProjectRepoIdPtrOutputWithContext(context.Background())
}

func (i *projectRepoIdPtrType) ToProjectRepoIdPtrOutputWithContext(ctx context.Context) ProjectRepoIdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectRepoIdPtrOutput)
}

// Selects a repo using a Google Cloud Platform project ID (e.g., winged-cargo-31) and a repo name within that project.
type ProjectRepoIdOutput struct{ *pulumi.OutputState }

func (ProjectRepoIdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ProjectRepoId)(nil)).Elem()
}

func (o ProjectRepoIdOutput) ToProjectRepoIdOutput() ProjectRepoIdOutput {
	return o
}

func (o ProjectRepoIdOutput) ToProjectRepoIdOutputWithContext(ctx context.Context) ProjectRepoIdOutput {
	return o
}

func (o ProjectRepoIdOutput) ToProjectRepoIdPtrOutput() ProjectRepoIdPtrOutput {
	return o.ToProjectRepoIdPtrOutputWithContext(context.Background())
}

func (o ProjectRepoIdOutput) ToProjectRepoIdPtrOutputWithContext(ctx context.Context) ProjectRepoIdPtrOutput {
	return o.ApplyT(func(v ProjectRepoId) *ProjectRepoId {
		return &v
	}).(ProjectRepoIdPtrOutput)
}

// The ID of the project.
func (o ProjectRepoIdOutput) Project() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ProjectRepoId) *string { return v.Project }).(pulumi.StringPtrOutput)
}

// The name of the repo. Leave empty for the default repo.
func (o ProjectRepoIdOutput) RepoName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ProjectRepoId) *string { return v.RepoName }).(pulumi.StringPtrOutput)
}

type ProjectRepoIdPtrOutput struct{ *pulumi.OutputState }

func (ProjectRepoIdPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProjectRepoId)(nil)).Elem()
}

func (o ProjectRepoIdPtrOutput) ToProjectRepoIdPtrOutput() ProjectRepoIdPtrOutput {
	return o
}

func (o ProjectRepoIdPtrOutput) ToProjectRepoIdPtrOutputWithContext(ctx context.Context) ProjectRepoIdPtrOutput {
	return o
}

func (o ProjectRepoIdPtrOutput) Elem() ProjectRepoIdOutput {
	return o.ApplyT(func(v *ProjectRepoId) ProjectRepoId { return *v }).(ProjectRepoIdOutput)
}

// The ID of the project.
func (o ProjectRepoIdPtrOutput) Project() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProjectRepoId) *string {
		if v == nil {
			return nil
		}
		return v.Project
	}).(pulumi.StringPtrOutput)
}

// The name of the repo. Leave empty for the default repo.
func (o ProjectRepoIdPtrOutput) RepoName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProjectRepoId) *string {
		if v == nil {
			return nil
		}
		return v.RepoName
	}).(pulumi.StringPtrOutput)
}

// Selects a repo using a Google Cloud Platform project ID (e.g., winged-cargo-31) and a repo name within that project.
type ProjectRepoIdResponse struct {
	// The ID of the project.
	Project string `pulumi:"project"`
	// The name of the repo. Leave empty for the default repo.
	RepoName string `pulumi:"repoName"`
}

// ProjectRepoIdResponseInput is an input type that accepts ProjectRepoIdResponseArgs and ProjectRepoIdResponseOutput values.
// You can construct a concrete instance of `ProjectRepoIdResponseInput` via:
//
//          ProjectRepoIdResponseArgs{...}
type ProjectRepoIdResponseInput interface {
	pulumi.Input

	ToProjectRepoIdResponseOutput() ProjectRepoIdResponseOutput
	ToProjectRepoIdResponseOutputWithContext(context.Context) ProjectRepoIdResponseOutput
}

// Selects a repo using a Google Cloud Platform project ID (e.g., winged-cargo-31) and a repo name within that project.
type ProjectRepoIdResponseArgs struct {
	// The ID of the project.
	Project pulumi.StringInput `pulumi:"project"`
	// The name of the repo. Leave empty for the default repo.
	RepoName pulumi.StringInput `pulumi:"repoName"`
}

func (ProjectRepoIdResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ProjectRepoIdResponse)(nil)).Elem()
}

func (i ProjectRepoIdResponseArgs) ToProjectRepoIdResponseOutput() ProjectRepoIdResponseOutput {
	return i.ToProjectRepoIdResponseOutputWithContext(context.Background())
}

func (i ProjectRepoIdResponseArgs) ToProjectRepoIdResponseOutputWithContext(ctx context.Context) ProjectRepoIdResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectRepoIdResponseOutput)
}

func (i ProjectRepoIdResponseArgs) ToProjectRepoIdResponsePtrOutput() ProjectRepoIdResponsePtrOutput {
	return i.ToProjectRepoIdResponsePtrOutputWithContext(context.Background())
}

func (i ProjectRepoIdResponseArgs) ToProjectRepoIdResponsePtrOutputWithContext(ctx context.Context) ProjectRepoIdResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectRepoIdResponseOutput).ToProjectRepoIdResponsePtrOutputWithContext(ctx)
}

// ProjectRepoIdResponsePtrInput is an input type that accepts ProjectRepoIdResponseArgs, ProjectRepoIdResponsePtr and ProjectRepoIdResponsePtrOutput values.
// You can construct a concrete instance of `ProjectRepoIdResponsePtrInput` via:
//
//          ProjectRepoIdResponseArgs{...}
//
//  or:
//
//          nil
type ProjectRepoIdResponsePtrInput interface {
	pulumi.Input

	ToProjectRepoIdResponsePtrOutput() ProjectRepoIdResponsePtrOutput
	ToProjectRepoIdResponsePtrOutputWithContext(context.Context) ProjectRepoIdResponsePtrOutput
}

type projectRepoIdResponsePtrType ProjectRepoIdResponseArgs

func ProjectRepoIdResponsePtr(v *ProjectRepoIdResponseArgs) ProjectRepoIdResponsePtrInput {
	return (*projectRepoIdResponsePtrType)(v)
}

func (*projectRepoIdResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ProjectRepoIdResponse)(nil)).Elem()
}

func (i *projectRepoIdResponsePtrType) ToProjectRepoIdResponsePtrOutput() ProjectRepoIdResponsePtrOutput {
	return i.ToProjectRepoIdResponsePtrOutputWithContext(context.Background())
}

func (i *projectRepoIdResponsePtrType) ToProjectRepoIdResponsePtrOutputWithContext(ctx context.Context) ProjectRepoIdResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectRepoIdResponsePtrOutput)
}

// Selects a repo using a Google Cloud Platform project ID (e.g., winged-cargo-31) and a repo name within that project.
type ProjectRepoIdResponseOutput struct{ *pulumi.OutputState }

func (ProjectRepoIdResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ProjectRepoIdResponse)(nil)).Elem()
}

func (o ProjectRepoIdResponseOutput) ToProjectRepoIdResponseOutput() ProjectRepoIdResponseOutput {
	return o
}

func (o ProjectRepoIdResponseOutput) ToProjectRepoIdResponseOutputWithContext(ctx context.Context) ProjectRepoIdResponseOutput {
	return o
}

func (o ProjectRepoIdResponseOutput) ToProjectRepoIdResponsePtrOutput() ProjectRepoIdResponsePtrOutput {
	return o.ToProjectRepoIdResponsePtrOutputWithContext(context.Background())
}

func (o ProjectRepoIdResponseOutput) ToProjectRepoIdResponsePtrOutputWithContext(ctx context.Context) ProjectRepoIdResponsePtrOutput {
	return o.ApplyT(func(v ProjectRepoIdResponse) *ProjectRepoIdResponse {
		return &v
	}).(ProjectRepoIdResponsePtrOutput)
}

// The ID of the project.
func (o ProjectRepoIdResponseOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectRepoIdResponse) string { return v.Project }).(pulumi.StringOutput)
}

// The name of the repo. Leave empty for the default repo.
func (o ProjectRepoIdResponseOutput) RepoName() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectRepoIdResponse) string { return v.RepoName }).(pulumi.StringOutput)
}

type ProjectRepoIdResponsePtrOutput struct{ *pulumi.OutputState }

func (ProjectRepoIdResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProjectRepoIdResponse)(nil)).Elem()
}

func (o ProjectRepoIdResponsePtrOutput) ToProjectRepoIdResponsePtrOutput() ProjectRepoIdResponsePtrOutput {
	return o
}

func (o ProjectRepoIdResponsePtrOutput) ToProjectRepoIdResponsePtrOutputWithContext(ctx context.Context) ProjectRepoIdResponsePtrOutput {
	return o
}

func (o ProjectRepoIdResponsePtrOutput) Elem() ProjectRepoIdResponseOutput {
	return o.ApplyT(func(v *ProjectRepoIdResponse) ProjectRepoIdResponse { return *v }).(ProjectRepoIdResponseOutput)
}

// The ID of the project.
func (o ProjectRepoIdResponsePtrOutput) Project() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProjectRepoIdResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Project
	}).(pulumi.StringPtrOutput)
}

// The name of the repo. Leave empty for the default repo.
func (o ProjectRepoIdResponsePtrOutput) RepoName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProjectRepoIdResponse) *string {
		if v == nil {
			return nil
		}
		return &v.RepoName
	}).(pulumi.StringPtrOutput)
}

// Metadata for any related URL information.
type RelatedUrl struct {
	// Label to describe usage of the URL.
	Label *string `pulumi:"label"`
	// Specific URL associated with the resource.
	Url *string `pulumi:"url"`
}

// RelatedUrlInput is an input type that accepts RelatedUrlArgs and RelatedUrlOutput values.
// You can construct a concrete instance of `RelatedUrlInput` via:
//
//          RelatedUrlArgs{...}
type RelatedUrlInput interface {
	pulumi.Input

	ToRelatedUrlOutput() RelatedUrlOutput
	ToRelatedUrlOutputWithContext(context.Context) RelatedUrlOutput
}

// Metadata for any related URL information.
type RelatedUrlArgs struct {
	// Label to describe usage of the URL.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// Specific URL associated with the resource.
	Url pulumi.StringPtrInput `pulumi:"url"`
}

func (RelatedUrlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RelatedUrl)(nil)).Elem()
}

func (i RelatedUrlArgs) ToRelatedUrlOutput() RelatedUrlOutput {
	return i.ToRelatedUrlOutputWithContext(context.Background())
}

func (i RelatedUrlArgs) ToRelatedUrlOutputWithContext(ctx context.Context) RelatedUrlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelatedUrlOutput)
}

// RelatedUrlArrayInput is an input type that accepts RelatedUrlArray and RelatedUrlArrayOutput values.
// You can construct a concrete instance of `RelatedUrlArrayInput` via:
//
//          RelatedUrlArray{ RelatedUrlArgs{...} }
type RelatedUrlArrayInput interface {
	pulumi.Input

	ToRelatedUrlArrayOutput() RelatedUrlArrayOutput
	ToRelatedUrlArrayOutputWithContext(context.Context) RelatedUrlArrayOutput
}

type RelatedUrlArray []RelatedUrlInput

func (RelatedUrlArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RelatedUrl)(nil)).Elem()
}

func (i RelatedUrlArray) ToRelatedUrlArrayOutput() RelatedUrlArrayOutput {
	return i.ToRelatedUrlArrayOutputWithContext(context.Background())
}

func (i RelatedUrlArray) ToRelatedUrlArrayOutputWithContext(ctx context.Context) RelatedUrlArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelatedUrlArrayOutput)
}

// Metadata for any related URL information.
type RelatedUrlOutput struct{ *pulumi.OutputState }

func (RelatedUrlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RelatedUrl)(nil)).Elem()
}

func (o RelatedUrlOutput) ToRelatedUrlOutput() RelatedUrlOutput {
	return o
}

func (o RelatedUrlOutput) ToRelatedUrlOutputWithContext(ctx context.Context) RelatedUrlOutput {
	return o
}

// Label to describe usage of the URL.
func (o RelatedUrlOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RelatedUrl) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// Specific URL associated with the resource.
func (o RelatedUrlOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RelatedUrl) *string { return v.Url }).(pulumi.StringPtrOutput)
}

type RelatedUrlArrayOutput struct{ *pulumi.OutputState }

func (RelatedUrlArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RelatedUrl)(nil)).Elem()
}

func (o RelatedUrlArrayOutput) ToRelatedUrlArrayOutput() RelatedUrlArrayOutput {
	return o
}

func (o RelatedUrlArrayOutput) ToRelatedUrlArrayOutputWithContext(ctx context.Context) RelatedUrlArrayOutput {
	return o
}

func (o RelatedUrlArrayOutput) Index(i pulumi.IntInput) RelatedUrlOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RelatedUrl {
		return vs[0].([]RelatedUrl)[vs[1].(int)]
	}).(RelatedUrlOutput)
}

// Metadata for any related URL information.
type RelatedUrlResponse struct {
	// Label to describe usage of the URL.
	Label string `pulumi:"label"`
	// Specific URL associated with the resource.
	Url string `pulumi:"url"`
}

// RelatedUrlResponseInput is an input type that accepts RelatedUrlResponseArgs and RelatedUrlResponseOutput values.
// You can construct a concrete instance of `RelatedUrlResponseInput` via:
//
//          RelatedUrlResponseArgs{...}
type RelatedUrlResponseInput interface {
	pulumi.Input

	ToRelatedUrlResponseOutput() RelatedUrlResponseOutput
	ToRelatedUrlResponseOutputWithContext(context.Context) RelatedUrlResponseOutput
}

// Metadata for any related URL information.
type RelatedUrlResponseArgs struct {
	// Label to describe usage of the URL.
	Label pulumi.StringInput `pulumi:"label"`
	// Specific URL associated with the resource.
	Url pulumi.StringInput `pulumi:"url"`
}

func (RelatedUrlResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RelatedUrlResponse)(nil)).Elem()
}

func (i RelatedUrlResponseArgs) ToRelatedUrlResponseOutput() RelatedUrlResponseOutput {
	return i.ToRelatedUrlResponseOutputWithContext(context.Background())
}

func (i RelatedUrlResponseArgs) ToRelatedUrlResponseOutputWithContext(ctx context.Context) RelatedUrlResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelatedUrlResponseOutput)
}

// RelatedUrlResponseArrayInput is an input type that accepts RelatedUrlResponseArray and RelatedUrlResponseArrayOutput values.
// You can construct a concrete instance of `RelatedUrlResponseArrayInput` via:
//
//          RelatedUrlResponseArray{ RelatedUrlResponseArgs{...} }
type RelatedUrlResponseArrayInput interface {
	pulumi.Input

	ToRelatedUrlResponseArrayOutput() RelatedUrlResponseArrayOutput
	ToRelatedUrlResponseArrayOutputWithContext(context.Context) RelatedUrlResponseArrayOutput
}

type RelatedUrlResponseArray []RelatedUrlResponseInput

func (RelatedUrlResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RelatedUrlResponse)(nil)).Elem()
}

func (i RelatedUrlResponseArray) ToRelatedUrlResponseArrayOutput() RelatedUrlResponseArrayOutput {
	return i.ToRelatedUrlResponseArrayOutputWithContext(context.Background())
}

func (i RelatedUrlResponseArray) ToRelatedUrlResponseArrayOutputWithContext(ctx context.Context) RelatedUrlResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelatedUrlResponseArrayOutput)
}

// Metadata for any related URL information.
type RelatedUrlResponseOutput struct{ *pulumi.OutputState }

func (RelatedUrlResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RelatedUrlResponse)(nil)).Elem()
}

func (o RelatedUrlResponseOutput) ToRelatedUrlResponseOutput() RelatedUrlResponseOutput {
	return o
}

func (o RelatedUrlResponseOutput) ToRelatedUrlResponseOutputWithContext(ctx context.Context) RelatedUrlResponseOutput {
	return o
}

// Label to describe usage of the URL.
func (o RelatedUrlResponseOutput) Label() pulumi.StringOutput {
	return o.ApplyT(func(v RelatedUrlResponse) string { return v.Label }).(pulumi.StringOutput)
}

// Specific URL associated with the resource.
func (o RelatedUrlResponseOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v RelatedUrlResponse) string { return v.Url }).(pulumi.StringOutput)
}

type RelatedUrlResponseArrayOutput struct{ *pulumi.OutputState }

func (RelatedUrlResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RelatedUrlResponse)(nil)).Elem()
}

func (o RelatedUrlResponseArrayOutput) ToRelatedUrlResponseArrayOutput() RelatedUrlResponseArrayOutput {
	return o
}

func (o RelatedUrlResponseArrayOutput) ToRelatedUrlResponseArrayOutputWithContext(ctx context.Context) RelatedUrlResponseArrayOutput {
	return o
}

func (o RelatedUrlResponseArrayOutput) Index(i pulumi.IntInput) RelatedUrlResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RelatedUrlResponse {
		return vs[0].([]RelatedUrlResponse)[vs[1].(int)]
	}).(RelatedUrlResponseOutput)
}

// RelationshipNote represents an SPDX Relationship section: https://spdx.github.io/spdx-spec/7-relationships-between-SPDX-elements/
type RelationshipNote struct {
}

// RelationshipNoteInput is an input type that accepts RelationshipNoteArgs and RelationshipNoteOutput values.
// You can construct a concrete instance of `RelationshipNoteInput` via:
//
//          RelationshipNoteArgs{...}
type RelationshipNoteInput interface {
	pulumi.Input

	ToRelationshipNoteOutput() RelationshipNoteOutput
	ToRelationshipNoteOutputWithContext(context.Context) RelationshipNoteOutput
}

// RelationshipNote represents an SPDX Relationship section: https://spdx.github.io/spdx-spec/7-relationships-between-SPDX-elements/
type RelationshipNoteArgs struct {
}

func (RelationshipNoteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RelationshipNote)(nil)).Elem()
}

func (i RelationshipNoteArgs) ToRelationshipNoteOutput() RelationshipNoteOutput {
	return i.ToRelationshipNoteOutputWithContext(context.Background())
}

func (i RelationshipNoteArgs) ToRelationshipNoteOutputWithContext(ctx context.Context) RelationshipNoteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelationshipNoteOutput)
}

func (i RelationshipNoteArgs) ToRelationshipNotePtrOutput() RelationshipNotePtrOutput {
	return i.ToRelationshipNotePtrOutputWithContext(context.Background())
}

func (i RelationshipNoteArgs) ToRelationshipNotePtrOutputWithContext(ctx context.Context) RelationshipNotePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelationshipNoteOutput).ToRelationshipNotePtrOutputWithContext(ctx)
}

// RelationshipNotePtrInput is an input type that accepts RelationshipNoteArgs, RelationshipNotePtr and RelationshipNotePtrOutput values.
// You can construct a concrete instance of `RelationshipNotePtrInput` via:
//
//          RelationshipNoteArgs{...}
//
//  or:
//
//          nil
type RelationshipNotePtrInput interface {
	pulumi.Input

	ToRelationshipNotePtrOutput() RelationshipNotePtrOutput
	ToRelationshipNotePtrOutputWithContext(context.Context) RelationshipNotePtrOutput
}

type relationshipNotePtrType RelationshipNoteArgs

func RelationshipNotePtr(v *RelationshipNoteArgs) RelationshipNotePtrInput {
	return (*relationshipNotePtrType)(v)
}

func (*relationshipNotePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RelationshipNote)(nil)).Elem()
}

func (i *relationshipNotePtrType) ToRelationshipNotePtrOutput() RelationshipNotePtrOutput {
	return i.ToRelationshipNotePtrOutputWithContext(context.Background())
}

func (i *relationshipNotePtrType) ToRelationshipNotePtrOutputWithContext(ctx context.Context) RelationshipNotePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelationshipNotePtrOutput)
}

// RelationshipNote represents an SPDX Relationship section: https://spdx.github.io/spdx-spec/7-relationships-between-SPDX-elements/
type RelationshipNoteOutput struct{ *pulumi.OutputState }

func (RelationshipNoteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RelationshipNote)(nil)).Elem()
}

func (o RelationshipNoteOutput) ToRelationshipNoteOutput() RelationshipNoteOutput {
	return o
}

func (o RelationshipNoteOutput) ToRelationshipNoteOutputWithContext(ctx context.Context) RelationshipNoteOutput {
	return o
}

func (o RelationshipNoteOutput) ToRelationshipNotePtrOutput() RelationshipNotePtrOutput {
	return o.ToRelationshipNotePtrOutputWithContext(context.Background())
}

func (o RelationshipNoteOutput) ToRelationshipNotePtrOutputWithContext(ctx context.Context) RelationshipNotePtrOutput {
	return o.ApplyT(func(v RelationshipNote) *RelationshipNote {
		return &v
	}).(RelationshipNotePtrOutput)
}

type RelationshipNotePtrOutput struct{ *pulumi.OutputState }

func (RelationshipNotePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RelationshipNote)(nil)).Elem()
}

func (o RelationshipNotePtrOutput) ToRelationshipNotePtrOutput() RelationshipNotePtrOutput {
	return o
}

func (o RelationshipNotePtrOutput) ToRelationshipNotePtrOutputWithContext(ctx context.Context) RelationshipNotePtrOutput {
	return o
}

func (o RelationshipNotePtrOutput) Elem() RelationshipNoteOutput {
	return o.ApplyT(func(v *RelationshipNote) RelationshipNote { return *v }).(RelationshipNoteOutput)
}

// RelationshipNote represents an SPDX Relationship section: https://spdx.github.io/spdx-spec/7-relationships-between-SPDX-elements/
type RelationshipNoteResponse struct {
}

// RelationshipNoteResponseInput is an input type that accepts RelationshipNoteResponseArgs and RelationshipNoteResponseOutput values.
// You can construct a concrete instance of `RelationshipNoteResponseInput` via:
//
//          RelationshipNoteResponseArgs{...}
type RelationshipNoteResponseInput interface {
	pulumi.Input

	ToRelationshipNoteResponseOutput() RelationshipNoteResponseOutput
	ToRelationshipNoteResponseOutputWithContext(context.Context) RelationshipNoteResponseOutput
}

// RelationshipNote represents an SPDX Relationship section: https://spdx.github.io/spdx-spec/7-relationships-between-SPDX-elements/
type RelationshipNoteResponseArgs struct {
}

func (RelationshipNoteResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RelationshipNoteResponse)(nil)).Elem()
}

func (i RelationshipNoteResponseArgs) ToRelationshipNoteResponseOutput() RelationshipNoteResponseOutput {
	return i.ToRelationshipNoteResponseOutputWithContext(context.Background())
}

func (i RelationshipNoteResponseArgs) ToRelationshipNoteResponseOutputWithContext(ctx context.Context) RelationshipNoteResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelationshipNoteResponseOutput)
}

func (i RelationshipNoteResponseArgs) ToRelationshipNoteResponsePtrOutput() RelationshipNoteResponsePtrOutput {
	return i.ToRelationshipNoteResponsePtrOutputWithContext(context.Background())
}

func (i RelationshipNoteResponseArgs) ToRelationshipNoteResponsePtrOutputWithContext(ctx context.Context) RelationshipNoteResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelationshipNoteResponseOutput).ToRelationshipNoteResponsePtrOutputWithContext(ctx)
}

// RelationshipNoteResponsePtrInput is an input type that accepts RelationshipNoteResponseArgs, RelationshipNoteResponsePtr and RelationshipNoteResponsePtrOutput values.
// You can construct a concrete instance of `RelationshipNoteResponsePtrInput` via:
//
//          RelationshipNoteResponseArgs{...}
//
//  or:
//
//          nil
type RelationshipNoteResponsePtrInput interface {
	pulumi.Input

	ToRelationshipNoteResponsePtrOutput() RelationshipNoteResponsePtrOutput
	ToRelationshipNoteResponsePtrOutputWithContext(context.Context) RelationshipNoteResponsePtrOutput
}

type relationshipNoteResponsePtrType RelationshipNoteResponseArgs

func RelationshipNoteResponsePtr(v *RelationshipNoteResponseArgs) RelationshipNoteResponsePtrInput {
	return (*relationshipNoteResponsePtrType)(v)
}

func (*relationshipNoteResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RelationshipNoteResponse)(nil)).Elem()
}

func (i *relationshipNoteResponsePtrType) ToRelationshipNoteResponsePtrOutput() RelationshipNoteResponsePtrOutput {
	return i.ToRelationshipNoteResponsePtrOutputWithContext(context.Background())
}

func (i *relationshipNoteResponsePtrType) ToRelationshipNoteResponsePtrOutputWithContext(ctx context.Context) RelationshipNoteResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelationshipNoteResponsePtrOutput)
}

// RelationshipNote represents an SPDX Relationship section: https://spdx.github.io/spdx-spec/7-relationships-between-SPDX-elements/
type RelationshipNoteResponseOutput struct{ *pulumi.OutputState }

func (RelationshipNoteResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RelationshipNoteResponse)(nil)).Elem()
}

func (o RelationshipNoteResponseOutput) ToRelationshipNoteResponseOutput() RelationshipNoteResponseOutput {
	return o
}

func (o RelationshipNoteResponseOutput) ToRelationshipNoteResponseOutputWithContext(ctx context.Context) RelationshipNoteResponseOutput {
	return o
}

func (o RelationshipNoteResponseOutput) ToRelationshipNoteResponsePtrOutput() RelationshipNoteResponsePtrOutput {
	return o.ToRelationshipNoteResponsePtrOutputWithContext(context.Background())
}

func (o RelationshipNoteResponseOutput) ToRelationshipNoteResponsePtrOutputWithContext(ctx context.Context) RelationshipNoteResponsePtrOutput {
	return o.ApplyT(func(v RelationshipNoteResponse) *RelationshipNoteResponse {
		return &v
	}).(RelationshipNoteResponsePtrOutput)
}

type RelationshipNoteResponsePtrOutput struct{ *pulumi.OutputState }

func (RelationshipNoteResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RelationshipNoteResponse)(nil)).Elem()
}

func (o RelationshipNoteResponsePtrOutput) ToRelationshipNoteResponsePtrOutput() RelationshipNoteResponsePtrOutput {
	return o
}

func (o RelationshipNoteResponsePtrOutput) ToRelationshipNoteResponsePtrOutputWithContext(ctx context.Context) RelationshipNoteResponsePtrOutput {
	return o
}

func (o RelationshipNoteResponsePtrOutput) Elem() RelationshipNoteResponseOutput {
	return o.ApplyT(func(v *RelationshipNoteResponse) RelationshipNoteResponse { return *v }).(RelationshipNoteResponseOutput)
}

// RelationshipOccurrence represents an SPDX Relationship section: https://spdx.github.io/spdx-spec/7-relationships-between-SPDX-elements/
type RelationshipOccurrence struct {
	// A place for the SPDX file creator to record any general comments about the relationship
	Comment *string `pulumi:"comment"`
	// Also referred to as SPDXRef-A The source SPDX element (file, package, etc)
	Source *string `pulumi:"source"`
	// Also referred to as SPDXRef-B The target SPDC element (file, package, etc) In cases where there are "known unknowns", the use of the keyword NOASSERTION can be used The keywords NONE can be used to indicate that an SPDX element (package/file/snippet) has no other elements connected by some relationship to it
	Target *string `pulumi:"target"`
	// The type of relationship between the source and target SPDX elements
	Type *RelationshipOccurrenceType `pulumi:"type"`
}

// RelationshipOccurrenceInput is an input type that accepts RelationshipOccurrenceArgs and RelationshipOccurrenceOutput values.
// You can construct a concrete instance of `RelationshipOccurrenceInput` via:
//
//          RelationshipOccurrenceArgs{...}
type RelationshipOccurrenceInput interface {
	pulumi.Input

	ToRelationshipOccurrenceOutput() RelationshipOccurrenceOutput
	ToRelationshipOccurrenceOutputWithContext(context.Context) RelationshipOccurrenceOutput
}

// RelationshipOccurrence represents an SPDX Relationship section: https://spdx.github.io/spdx-spec/7-relationships-between-SPDX-elements/
type RelationshipOccurrenceArgs struct {
	// A place for the SPDX file creator to record any general comments about the relationship
	Comment pulumi.StringPtrInput `pulumi:"comment"`
	// Also referred to as SPDXRef-A The source SPDX element (file, package, etc)
	Source pulumi.StringPtrInput `pulumi:"source"`
	// Also referred to as SPDXRef-B The target SPDC element (file, package, etc) In cases where there are "known unknowns", the use of the keyword NOASSERTION can be used The keywords NONE can be used to indicate that an SPDX element (package/file/snippet) has no other elements connected by some relationship to it
	Target pulumi.StringPtrInput `pulumi:"target"`
	// The type of relationship between the source and target SPDX elements
	Type RelationshipOccurrenceTypePtrInput `pulumi:"type"`
}

func (RelationshipOccurrenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RelationshipOccurrence)(nil)).Elem()
}

func (i RelationshipOccurrenceArgs) ToRelationshipOccurrenceOutput() RelationshipOccurrenceOutput {
	return i.ToRelationshipOccurrenceOutputWithContext(context.Background())
}

func (i RelationshipOccurrenceArgs) ToRelationshipOccurrenceOutputWithContext(ctx context.Context) RelationshipOccurrenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelationshipOccurrenceOutput)
}

func (i RelationshipOccurrenceArgs) ToRelationshipOccurrencePtrOutput() RelationshipOccurrencePtrOutput {
	return i.ToRelationshipOccurrencePtrOutputWithContext(context.Background())
}

func (i RelationshipOccurrenceArgs) ToRelationshipOccurrencePtrOutputWithContext(ctx context.Context) RelationshipOccurrencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelationshipOccurrenceOutput).ToRelationshipOccurrencePtrOutputWithContext(ctx)
}

// RelationshipOccurrencePtrInput is an input type that accepts RelationshipOccurrenceArgs, RelationshipOccurrencePtr and RelationshipOccurrencePtrOutput values.
// You can construct a concrete instance of `RelationshipOccurrencePtrInput` via:
//
//          RelationshipOccurrenceArgs{...}
//
//  or:
//
//          nil
type RelationshipOccurrencePtrInput interface {
	pulumi.Input

	ToRelationshipOccurrencePtrOutput() RelationshipOccurrencePtrOutput
	ToRelationshipOccurrencePtrOutputWithContext(context.Context) RelationshipOccurrencePtrOutput
}

type relationshipOccurrencePtrType RelationshipOccurrenceArgs

func RelationshipOccurrencePtr(v *RelationshipOccurrenceArgs) RelationshipOccurrencePtrInput {
	return (*relationshipOccurrencePtrType)(v)
}

func (*relationshipOccurrencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RelationshipOccurrence)(nil)).Elem()
}

func (i *relationshipOccurrencePtrType) ToRelationshipOccurrencePtrOutput() RelationshipOccurrencePtrOutput {
	return i.ToRelationshipOccurrencePtrOutputWithContext(context.Background())
}

func (i *relationshipOccurrencePtrType) ToRelationshipOccurrencePtrOutputWithContext(ctx context.Context) RelationshipOccurrencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelationshipOccurrencePtrOutput)
}

// RelationshipOccurrence represents an SPDX Relationship section: https://spdx.github.io/spdx-spec/7-relationships-between-SPDX-elements/
type RelationshipOccurrenceOutput struct{ *pulumi.OutputState }

func (RelationshipOccurrenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RelationshipOccurrence)(nil)).Elem()
}

func (o RelationshipOccurrenceOutput) ToRelationshipOccurrenceOutput() RelationshipOccurrenceOutput {
	return o
}

func (o RelationshipOccurrenceOutput) ToRelationshipOccurrenceOutputWithContext(ctx context.Context) RelationshipOccurrenceOutput {
	return o
}

func (o RelationshipOccurrenceOutput) ToRelationshipOccurrencePtrOutput() RelationshipOccurrencePtrOutput {
	return o.ToRelationshipOccurrencePtrOutputWithContext(context.Background())
}

func (o RelationshipOccurrenceOutput) ToRelationshipOccurrencePtrOutputWithContext(ctx context.Context) RelationshipOccurrencePtrOutput {
	return o.ApplyT(func(v RelationshipOccurrence) *RelationshipOccurrence {
		return &v
	}).(RelationshipOccurrencePtrOutput)
}

// A place for the SPDX file creator to record any general comments about the relationship
func (o RelationshipOccurrenceOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RelationshipOccurrence) *string { return v.Comment }).(pulumi.StringPtrOutput)
}

// Also referred to as SPDXRef-A The source SPDX element (file, package, etc)
func (o RelationshipOccurrenceOutput) Source() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RelationshipOccurrence) *string { return v.Source }).(pulumi.StringPtrOutput)
}

// Also referred to as SPDXRef-B The target SPDC element (file, package, etc) In cases where there are "known unknowns", the use of the keyword NOASSERTION can be used The keywords NONE can be used to indicate that an SPDX element (package/file/snippet) has no other elements connected by some relationship to it
func (o RelationshipOccurrenceOutput) Target() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RelationshipOccurrence) *string { return v.Target }).(pulumi.StringPtrOutput)
}

// The type of relationship between the source and target SPDX elements
func (o RelationshipOccurrenceOutput) Type() RelationshipOccurrenceTypePtrOutput {
	return o.ApplyT(func(v RelationshipOccurrence) *RelationshipOccurrenceType { return v.Type }).(RelationshipOccurrenceTypePtrOutput)
}

type RelationshipOccurrencePtrOutput struct{ *pulumi.OutputState }

func (RelationshipOccurrencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RelationshipOccurrence)(nil)).Elem()
}

func (o RelationshipOccurrencePtrOutput) ToRelationshipOccurrencePtrOutput() RelationshipOccurrencePtrOutput {
	return o
}

func (o RelationshipOccurrencePtrOutput) ToRelationshipOccurrencePtrOutputWithContext(ctx context.Context) RelationshipOccurrencePtrOutput {
	return o
}

func (o RelationshipOccurrencePtrOutput) Elem() RelationshipOccurrenceOutput {
	return o.ApplyT(func(v *RelationshipOccurrence) RelationshipOccurrence { return *v }).(RelationshipOccurrenceOutput)
}

// A place for the SPDX file creator to record any general comments about the relationship
func (o RelationshipOccurrencePtrOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RelationshipOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.Comment
	}).(pulumi.StringPtrOutput)
}

// Also referred to as SPDXRef-A The source SPDX element (file, package, etc)
func (o RelationshipOccurrencePtrOutput) Source() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RelationshipOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.Source
	}).(pulumi.StringPtrOutput)
}

// Also referred to as SPDXRef-B The target SPDC element (file, package, etc) In cases where there are "known unknowns", the use of the keyword NOASSERTION can be used The keywords NONE can be used to indicate that an SPDX element (package/file/snippet) has no other elements connected by some relationship to it
func (o RelationshipOccurrencePtrOutput) Target() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RelationshipOccurrence) *string {
		if v == nil {
			return nil
		}
		return v.Target
	}).(pulumi.StringPtrOutput)
}

// The type of relationship between the source and target SPDX elements
func (o RelationshipOccurrencePtrOutput) Type() RelationshipOccurrenceTypePtrOutput {
	return o.ApplyT(func(v *RelationshipOccurrence) *RelationshipOccurrenceType {
		if v == nil {
			return nil
		}
		return v.Type
	}).(RelationshipOccurrenceTypePtrOutput)
}

// RelationshipOccurrence represents an SPDX Relationship section: https://spdx.github.io/spdx-spec/7-relationships-between-SPDX-elements/
type RelationshipOccurrenceResponse struct {
	// A place for the SPDX file creator to record any general comments about the relationship
	Comment string `pulumi:"comment"`
	// Also referred to as SPDXRef-A The source SPDX element (file, package, etc)
	Source string `pulumi:"source"`
	// Also referred to as SPDXRef-B The target SPDC element (file, package, etc) In cases where there are "known unknowns", the use of the keyword NOASSERTION can be used The keywords NONE can be used to indicate that an SPDX element (package/file/snippet) has no other elements connected by some relationship to it
	Target string `pulumi:"target"`
	// The type of relationship between the source and target SPDX elements
	Type string `pulumi:"type"`
}

// RelationshipOccurrenceResponseInput is an input type that accepts RelationshipOccurrenceResponseArgs and RelationshipOccurrenceResponseOutput values.
// You can construct a concrete instance of `RelationshipOccurrenceResponseInput` via:
//
//          RelationshipOccurrenceResponseArgs{...}
type RelationshipOccurrenceResponseInput interface {
	pulumi.Input

	ToRelationshipOccurrenceResponseOutput() RelationshipOccurrenceResponseOutput
	ToRelationshipOccurrenceResponseOutputWithContext(context.Context) RelationshipOccurrenceResponseOutput
}

// RelationshipOccurrence represents an SPDX Relationship section: https://spdx.github.io/spdx-spec/7-relationships-between-SPDX-elements/
type RelationshipOccurrenceResponseArgs struct {
	// A place for the SPDX file creator to record any general comments about the relationship
	Comment pulumi.StringInput `pulumi:"comment"`
	// Also referred to as SPDXRef-A The source SPDX element (file, package, etc)
	Source pulumi.StringInput `pulumi:"source"`
	// Also referred to as SPDXRef-B The target SPDC element (file, package, etc) In cases where there are "known unknowns", the use of the keyword NOASSERTION can be used The keywords NONE can be used to indicate that an SPDX element (package/file/snippet) has no other elements connected by some relationship to it
	Target pulumi.StringInput `pulumi:"target"`
	// The type of relationship between the source and target SPDX elements
	Type pulumi.StringInput `pulumi:"type"`
}

func (RelationshipOccurrenceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RelationshipOccurrenceResponse)(nil)).Elem()
}

func (i RelationshipOccurrenceResponseArgs) ToRelationshipOccurrenceResponseOutput() RelationshipOccurrenceResponseOutput {
	return i.ToRelationshipOccurrenceResponseOutputWithContext(context.Background())
}

func (i RelationshipOccurrenceResponseArgs) ToRelationshipOccurrenceResponseOutputWithContext(ctx context.Context) RelationshipOccurrenceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelationshipOccurrenceResponseOutput)
}

func (i RelationshipOccurrenceResponseArgs) ToRelationshipOccurrenceResponsePtrOutput() RelationshipOccurrenceResponsePtrOutput {
	return i.ToRelationshipOccurrenceResponsePtrOutputWithContext(context.Background())
}

func (i RelationshipOccurrenceResponseArgs) ToRelationshipOccurrenceResponsePtrOutputWithContext(ctx context.Context) RelationshipOccurrenceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelationshipOccurrenceResponseOutput).ToRelationshipOccurrenceResponsePtrOutputWithContext(ctx)
}

// RelationshipOccurrenceResponsePtrInput is an input type that accepts RelationshipOccurrenceResponseArgs, RelationshipOccurrenceResponsePtr and RelationshipOccurrenceResponsePtrOutput values.
// You can construct a concrete instance of `RelationshipOccurrenceResponsePtrInput` via:
//
//          RelationshipOccurrenceResponseArgs{...}
//
//  or:
//
//          nil
type RelationshipOccurrenceResponsePtrInput interface {
	pulumi.Input

	ToRelationshipOccurrenceResponsePtrOutput() RelationshipOccurrenceResponsePtrOutput
	ToRelationshipOccurrenceResponsePtrOutputWithContext(context.Context) RelationshipOccurrenceResponsePtrOutput
}

type relationshipOccurrenceResponsePtrType RelationshipOccurrenceResponseArgs

func RelationshipOccurrenceResponsePtr(v *RelationshipOccurrenceResponseArgs) RelationshipOccurrenceResponsePtrInput {
	return (*relationshipOccurrenceResponsePtrType)(v)
}

func (*relationshipOccurrenceResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RelationshipOccurrenceResponse)(nil)).Elem()
}

func (i *relationshipOccurrenceResponsePtrType) ToRelationshipOccurrenceResponsePtrOutput() RelationshipOccurrenceResponsePtrOutput {
	return i.ToRelationshipOccurrenceResponsePtrOutputWithContext(context.Background())
}

func (i *relationshipOccurrenceResponsePtrType) ToRelationshipOccurrenceResponsePtrOutputWithContext(ctx context.Context) RelationshipOccurrenceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RelationshipOccurrenceResponsePtrOutput)
}

// RelationshipOccurrence represents an SPDX Relationship section: https://spdx.github.io/spdx-spec/7-relationships-between-SPDX-elements/
type RelationshipOccurrenceResponseOutput struct{ *pulumi.OutputState }

func (RelationshipOccurrenceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RelationshipOccurrenceResponse)(nil)).Elem()
}

func (o RelationshipOccurrenceResponseOutput) ToRelationshipOccurrenceResponseOutput() RelationshipOccurrenceResponseOutput {
	return o
}

func (o RelationshipOccurrenceResponseOutput) ToRelationshipOccurrenceResponseOutputWithContext(ctx context.Context) RelationshipOccurrenceResponseOutput {
	return o
}

func (o RelationshipOccurrenceResponseOutput) ToRelationshipOccurrenceResponsePtrOutput() RelationshipOccurrenceResponsePtrOutput {
	return o.ToRelationshipOccurrenceResponsePtrOutputWithContext(context.Background())
}

func (o RelationshipOccurrenceResponseOutput) ToRelationshipOccurrenceResponsePtrOutputWithContext(ctx context.Context) RelationshipOccurrenceResponsePtrOutput {
	return o.ApplyT(func(v RelationshipOccurrenceResponse) *RelationshipOccurrenceResponse {
		return &v
	}).(RelationshipOccurrenceResponsePtrOutput)
}

// A place for the SPDX file creator to record any general comments about the relationship
func (o RelationshipOccurrenceResponseOutput) Comment() pulumi.StringOutput {
	return o.ApplyT(func(v RelationshipOccurrenceResponse) string { return v.Comment }).(pulumi.StringOutput)
}

// Also referred to as SPDXRef-A The source SPDX element (file, package, etc)
func (o RelationshipOccurrenceResponseOutput) Source() pulumi.StringOutput {
	return o.ApplyT(func(v RelationshipOccurrenceResponse) string { return v.Source }).(pulumi.StringOutput)
}

// Also referred to as SPDXRef-B The target SPDC element (file, package, etc) In cases where there are "known unknowns", the use of the keyword NOASSERTION can be used The keywords NONE can be used to indicate that an SPDX element (package/file/snippet) has no other elements connected by some relationship to it
func (o RelationshipOccurrenceResponseOutput) Target() pulumi.StringOutput {
	return o.ApplyT(func(v RelationshipOccurrenceResponse) string { return v.Target }).(pulumi.StringOutput)
}

// The type of relationship between the source and target SPDX elements
func (o RelationshipOccurrenceResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v RelationshipOccurrenceResponse) string { return v.Type }).(pulumi.StringOutput)
}

type RelationshipOccurrenceResponsePtrOutput struct{ *pulumi.OutputState }

func (RelationshipOccurrenceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RelationshipOccurrenceResponse)(nil)).Elem()
}

func (o RelationshipOccurrenceResponsePtrOutput) ToRelationshipOccurrenceResponsePtrOutput() RelationshipOccurrenceResponsePtrOutput {
	return o
}

func (o RelationshipOccurrenceResponsePtrOutput) ToRelationshipOccurrenceResponsePtrOutputWithContext(ctx context.Context) RelationshipOccurrenceResponsePtrOutput {
	return o
}

func (o RelationshipOccurrenceResponsePtrOutput) Elem() RelationshipOccurrenceResponseOutput {
	return o.ApplyT(func(v *RelationshipOccurrenceResponse) RelationshipOccurrenceResponse { return *v }).(RelationshipOccurrenceResponseOutput)
}

// A place for the SPDX file creator to record any general comments about the relationship
func (o RelationshipOccurrenceResponsePtrOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RelationshipOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Comment
	}).(pulumi.StringPtrOutput)
}

// Also referred to as SPDXRef-A The source SPDX element (file, package, etc)
func (o RelationshipOccurrenceResponsePtrOutput) Source() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RelationshipOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Source
	}).(pulumi.StringPtrOutput)
}

// Also referred to as SPDXRef-B The target SPDC element (file, package, etc) In cases where there are "known unknowns", the use of the keyword NOASSERTION can be used The keywords NONE can be used to indicate that an SPDX element (package/file/snippet) has no other elements connected by some relationship to it
func (o RelationshipOccurrenceResponsePtrOutput) Target() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RelationshipOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Target
	}).(pulumi.StringPtrOutput)
}

// The type of relationship between the source and target SPDX elements
func (o RelationshipOccurrenceResponsePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RelationshipOccurrenceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// A unique identifier for a Cloud Repo.
type RepoId struct {
	// A combination of a project ID and a repo name.
	ProjectRepoId *ProjectRepoId `pulumi:"projectRepoId"`
	// A server-assigned, globally unique identifier.
	Uid *string `pulumi:"uid"`
}

// RepoIdInput is an input type that accepts RepoIdArgs and RepoIdOutput values.
// You can construct a concrete instance of `RepoIdInput` via:
//
//          RepoIdArgs{...}
type RepoIdInput interface {
	pulumi.Input

	ToRepoIdOutput() RepoIdOutput
	ToRepoIdOutputWithContext(context.Context) RepoIdOutput
}

// A unique identifier for a Cloud Repo.
type RepoIdArgs struct {
	// A combination of a project ID and a repo name.
	ProjectRepoId ProjectRepoIdPtrInput `pulumi:"projectRepoId"`
	// A server-assigned, globally unique identifier.
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (RepoIdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RepoId)(nil)).Elem()
}

func (i RepoIdArgs) ToRepoIdOutput() RepoIdOutput {
	return i.ToRepoIdOutputWithContext(context.Background())
}

func (i RepoIdArgs) ToRepoIdOutputWithContext(ctx context.Context) RepoIdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepoIdOutput)
}

func (i RepoIdArgs) ToRepoIdPtrOutput() RepoIdPtrOutput {
	return i.ToRepoIdPtrOutputWithContext(context.Background())
}

func (i RepoIdArgs) ToRepoIdPtrOutputWithContext(ctx context.Context) RepoIdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepoIdOutput).ToRepoIdPtrOutputWithContext(ctx)
}

// RepoIdPtrInput is an input type that accepts RepoIdArgs, RepoIdPtr and RepoIdPtrOutput values.
// You can construct a concrete instance of `RepoIdPtrInput` via:
//
//          RepoIdArgs{...}
//
//  or:
//
//          nil
type RepoIdPtrInput interface {
	pulumi.Input

	ToRepoIdPtrOutput() RepoIdPtrOutput
	ToRepoIdPtrOutputWithContext(context.Context) RepoIdPtrOutput
}

type repoIdPtrType RepoIdArgs

func RepoIdPtr(v *RepoIdArgs) RepoIdPtrInput {
	return (*repoIdPtrType)(v)
}

func (*repoIdPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RepoId)(nil)).Elem()
}

func (i *repoIdPtrType) ToRepoIdPtrOutput() RepoIdPtrOutput {
	return i.ToRepoIdPtrOutputWithContext(context.Background())
}

func (i *repoIdPtrType) ToRepoIdPtrOutputWithContext(ctx context.Context) RepoIdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepoIdPtrOutput)
}

// A unique identifier for a Cloud Repo.
type RepoIdOutput struct{ *pulumi.OutputState }

func (RepoIdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RepoId)(nil)).Elem()
}

func (o RepoIdOutput) ToRepoIdOutput() RepoIdOutput {
	return o
}

func (o RepoIdOutput) ToRepoIdOutputWithContext(ctx context.Context) RepoIdOutput {
	return o
}

func (o RepoIdOutput) ToRepoIdPtrOutput() RepoIdPtrOutput {
	return o.ToRepoIdPtrOutputWithContext(context.Background())
}

func (o RepoIdOutput) ToRepoIdPtrOutputWithContext(ctx context.Context) RepoIdPtrOutput {
	return o.ApplyT(func(v RepoId) *RepoId {
		return &v
	}).(RepoIdPtrOutput)
}

// A combination of a project ID and a repo name.
func (o RepoIdOutput) ProjectRepoId() ProjectRepoIdPtrOutput {
	return o.ApplyT(func(v RepoId) *ProjectRepoId { return v.ProjectRepoId }).(ProjectRepoIdPtrOutput)
}

// A server-assigned, globally unique identifier.
func (o RepoIdOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RepoId) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type RepoIdPtrOutput struct{ *pulumi.OutputState }

func (RepoIdPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RepoId)(nil)).Elem()
}

func (o RepoIdPtrOutput) ToRepoIdPtrOutput() RepoIdPtrOutput {
	return o
}

func (o RepoIdPtrOutput) ToRepoIdPtrOutputWithContext(ctx context.Context) RepoIdPtrOutput {
	return o
}

func (o RepoIdPtrOutput) Elem() RepoIdOutput {
	return o.ApplyT(func(v *RepoId) RepoId { return *v }).(RepoIdOutput)
}

// A combination of a project ID and a repo name.
func (o RepoIdPtrOutput) ProjectRepoId() ProjectRepoIdPtrOutput {
	return o.ApplyT(func(v *RepoId) *ProjectRepoId {
		if v == nil {
			return nil
		}
		return v.ProjectRepoId
	}).(ProjectRepoIdPtrOutput)
}

// A server-assigned, globally unique identifier.
func (o RepoIdPtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RepoId) *string {
		if v == nil {
			return nil
		}
		return v.Uid
	}).(pulumi.StringPtrOutput)
}

// A unique identifier for a Cloud Repo.
type RepoIdResponse struct {
	// A combination of a project ID and a repo name.
	ProjectRepoId ProjectRepoIdResponse `pulumi:"projectRepoId"`
	// A server-assigned, globally unique identifier.
	Uid string `pulumi:"uid"`
}

// RepoIdResponseInput is an input type that accepts RepoIdResponseArgs and RepoIdResponseOutput values.
// You can construct a concrete instance of `RepoIdResponseInput` via:
//
//          RepoIdResponseArgs{...}
type RepoIdResponseInput interface {
	pulumi.Input

	ToRepoIdResponseOutput() RepoIdResponseOutput
	ToRepoIdResponseOutputWithContext(context.Context) RepoIdResponseOutput
}

// A unique identifier for a Cloud Repo.
type RepoIdResponseArgs struct {
	// A combination of a project ID and a repo name.
	ProjectRepoId ProjectRepoIdResponseInput `pulumi:"projectRepoId"`
	// A server-assigned, globally unique identifier.
	Uid pulumi.StringInput `pulumi:"uid"`
}

func (RepoIdResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RepoIdResponse)(nil)).Elem()
}

func (i RepoIdResponseArgs) ToRepoIdResponseOutput() RepoIdResponseOutput {
	return i.ToRepoIdResponseOutputWithContext(context.Background())
}

func (i RepoIdResponseArgs) ToRepoIdResponseOutputWithContext(ctx context.Context) RepoIdResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepoIdResponseOutput)
}

func (i RepoIdResponseArgs) ToRepoIdResponsePtrOutput() RepoIdResponsePtrOutput {
	return i.ToRepoIdResponsePtrOutputWithContext(context.Background())
}

func (i RepoIdResponseArgs) ToRepoIdResponsePtrOutputWithContext(ctx context.Context) RepoIdResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepoIdResponseOutput).ToRepoIdResponsePtrOutputWithContext(ctx)
}

// RepoIdResponsePtrInput is an input type that accepts RepoIdResponseArgs, RepoIdResponsePtr and RepoIdResponsePtrOutput values.
// You can construct a concrete instance of `RepoIdResponsePtrInput` via:
//
//          RepoIdResponseArgs{...}
//
//  or:
//
//          nil
type RepoIdResponsePtrInput interface {
	pulumi.Input

	ToRepoIdResponsePtrOutput() RepoIdResponsePtrOutput
	ToRepoIdResponsePtrOutputWithContext(context.Context) RepoIdResponsePtrOutput
}

type repoIdResponsePtrType RepoIdResponseArgs

func RepoIdResponsePtr(v *RepoIdResponseArgs) RepoIdResponsePtrInput {
	return (*repoIdResponsePtrType)(v)
}

func (*repoIdResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RepoIdResponse)(nil)).Elem()
}

func (i *repoIdResponsePtrType) ToRepoIdResponsePtrOutput() RepoIdResponsePtrOutput {
	return i.ToRepoIdResponsePtrOutputWithContext(context.Background())
}

func (i *repoIdResponsePtrType) ToRepoIdResponsePtrOutputWithContext(ctx context.Context) RepoIdResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepoIdResponsePtrOutput)
}

// A unique identifier for a Cloud Repo.
type RepoIdResponseOutput struct{ *pulumi.OutputState }

func (RepoIdResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RepoIdResponse)(nil)).Elem()
}

func (o RepoIdResponseOutput) ToRepoIdResponseOutput() RepoIdResponseOutput {
	return o
}

func (o RepoIdResponseOutput) ToRepoIdResponseOutputWithContext(ctx context.Context) RepoIdResponseOutput {
	return o
}

func (o RepoIdResponseOutput) ToRepoIdResponsePtrOutput() RepoIdResponsePtrOutput {
	return o.ToRepoIdResponsePtrOutputWithContext(context.Background())
}

func (o RepoIdResponseOutput) ToRepoIdResponsePtrOutputWithContext(ctx context.Context) RepoIdResponsePtrOutput {
	return o.ApplyT(func(v RepoIdResponse) *RepoIdResponse {
		return &v
	}).(RepoIdResponsePtrOutput)
}

// A combination of a project ID and a repo name.
func (o RepoIdResponseOutput) ProjectRepoId() ProjectRepoIdResponseOutput {
	return o.ApplyT(func(v RepoIdResponse) ProjectRepoIdResponse { return v.ProjectRepoId }).(ProjectRepoIdResponseOutput)
}

// A server-assigned, globally unique identifier.
func (o RepoIdResponseOutput) Uid() pulumi.StringOutput {
	return o.ApplyT(func(v RepoIdResponse) string { return v.Uid }).(pulumi.StringOutput)
}

type RepoIdResponsePtrOutput struct{ *pulumi.OutputState }

func (RepoIdResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RepoIdResponse)(nil)).Elem()
}

func (o RepoIdResponsePtrOutput) ToRepoIdResponsePtrOutput() RepoIdResponsePtrOutput {
	return o
}

func (o RepoIdResponsePtrOutput) ToRepoIdResponsePtrOutputWithContext(ctx context.Context) RepoIdResponsePtrOutput {
	return o
}

func (o RepoIdResponsePtrOutput) Elem() RepoIdResponseOutput {
	return o.ApplyT(func(v *RepoIdResponse) RepoIdResponse { return *v }).(RepoIdResponseOutput)
}

// A combination of a project ID and a repo name.
func (o RepoIdResponsePtrOutput) ProjectRepoId() ProjectRepoIdResponsePtrOutput {
	return o.ApplyT(func(v *RepoIdResponse) *ProjectRepoIdResponse {
		if v == nil {
			return nil
		}
		return &v.ProjectRepoId
	}).(ProjectRepoIdResponsePtrOutput)
}

// A server-assigned, globally unique identifier.
func (o RepoIdResponsePtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RepoIdResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Uid
	}).(pulumi.StringPtrOutput)
}

// An entity that can have metadata. For example, a Docker image.
type Resource struct {
	// The unique URI of the resource. For example, `https://gcr.io/project/image@sha256:foo` for a Docker image.
	Uri string `pulumi:"uri"`
}

// ResourceInput is an input type that accepts ResourceArgs and ResourceOutput values.
// You can construct a concrete instance of `ResourceInput` via:
//
//          ResourceArgs{...}
type ResourceInput interface {
	pulumi.Input

	ToResourceOutput() ResourceOutput
	ToResourceOutputWithContext(context.Context) ResourceOutput
}

// An entity that can have metadata. For example, a Docker image.
type ResourceArgs struct {
	// The unique URI of the resource. For example, `https://gcr.io/project/image@sha256:foo` for a Docker image.
	Uri pulumi.StringInput `pulumi:"uri"`
}

func (ResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Resource)(nil)).Elem()
}

func (i ResourceArgs) ToResourceOutput() ResourceOutput {
	return i.ToResourceOutputWithContext(context.Background())
}

func (i ResourceArgs) ToResourceOutputWithContext(ctx context.Context) ResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceOutput)
}

func (i ResourceArgs) ToResourcePtrOutput() ResourcePtrOutput {
	return i.ToResourcePtrOutputWithContext(context.Background())
}

func (i ResourceArgs) ToResourcePtrOutputWithContext(ctx context.Context) ResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceOutput).ToResourcePtrOutputWithContext(ctx)
}

// ResourcePtrInput is an input type that accepts ResourceArgs, ResourcePtr and ResourcePtrOutput values.
// You can construct a concrete instance of `ResourcePtrInput` via:
//
//          ResourceArgs{...}
//
//  or:
//
//          nil
type ResourcePtrInput interface {
	pulumi.Input

	ToResourcePtrOutput() ResourcePtrOutput
	ToResourcePtrOutputWithContext(context.Context) ResourcePtrOutput
}

type resourcePtrType ResourceArgs

func ResourcePtr(v *ResourceArgs) ResourcePtrInput {
	return (*resourcePtrType)(v)
}

func (*resourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Resource)(nil)).Elem()
}

func (i *resourcePtrType) ToResourcePtrOutput() ResourcePtrOutput {
	return i.ToResourcePtrOutputWithContext(context.Background())
}

func (i *resourcePtrType) ToResourcePtrOutputWithContext(ctx context.Context) ResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourcePtrOutput)
}

// An entity that can have metadata. For example, a Docker image.
type ResourceOutput struct{ *pulumi.OutputState }

func (ResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Resource)(nil)).Elem()
}

func (o ResourceOutput) ToResourceOutput() ResourceOutput {
	return o
}

func (o ResourceOutput) ToResourceOutputWithContext(ctx context.Context) ResourceOutput {
	return o
}

func (o ResourceOutput) ToResourcePtrOutput() ResourcePtrOutput {
	return o.ToResourcePtrOutputWithContext(context.Background())
}

func (o ResourceOutput) ToResourcePtrOutputWithContext(ctx context.Context) ResourcePtrOutput {
	return o.ApplyT(func(v Resource) *Resource {
		return &v
	}).(ResourcePtrOutput)
}

// The unique URI of the resource. For example, `https://gcr.io/project/image@sha256:foo` for a Docker image.
func (o ResourceOutput) Uri() pulumi.StringOutput {
	return o.ApplyT(func(v Resource) string { return v.Uri }).(pulumi.StringOutput)
}

type ResourcePtrOutput struct{ *pulumi.OutputState }

func (ResourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Resource)(nil)).Elem()
}

func (o ResourcePtrOutput) ToResourcePtrOutput() ResourcePtrOutput {
	return o
}

func (o ResourcePtrOutput) ToResourcePtrOutputWithContext(ctx context.Context) ResourcePtrOutput {
	return o
}

func (o ResourcePtrOutput) Elem() ResourceOutput {
	return o.ApplyT(func(v *Resource) Resource { return *v }).(ResourceOutput)
}

// The unique URI of the resource. For example, `https://gcr.io/project/image@sha256:foo` for a Docker image.
func (o ResourcePtrOutput) Uri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Resource) *string {
		if v == nil {
			return nil
		}
		return &v.Uri
	}).(pulumi.StringPtrOutput)
}

// An entity that can have metadata. For example, a Docker image.
type ResourceResponse struct {
	// The unique URI of the resource. For example, `https://gcr.io/project/image@sha256:foo` for a Docker image.
	Uri string `pulumi:"uri"`
}

// ResourceResponseInput is an input type that accepts ResourceResponseArgs and ResourceResponseOutput values.
// You can construct a concrete instance of `ResourceResponseInput` via:
//
//          ResourceResponseArgs{...}
type ResourceResponseInput interface {
	pulumi.Input

	ToResourceResponseOutput() ResourceResponseOutput
	ToResourceResponseOutputWithContext(context.Context) ResourceResponseOutput
}

// An entity that can have metadata. For example, a Docker image.
type ResourceResponseArgs struct {
	// The unique URI of the resource. For example, `https://gcr.io/project/image@sha256:foo` for a Docker image.
	Uri pulumi.StringInput `pulumi:"uri"`
}

func (ResourceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceResponse)(nil)).Elem()
}

func (i ResourceResponseArgs) ToResourceResponseOutput() ResourceResponseOutput {
	return i.ToResourceResponseOutputWithContext(context.Background())
}

func (i ResourceResponseArgs) ToResourceResponseOutputWithContext(ctx context.Context) ResourceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceResponseOutput)
}

func (i ResourceResponseArgs) ToResourceResponsePtrOutput() ResourceResponsePtrOutput {
	return i.ToResourceResponsePtrOutputWithContext(context.Background())
}

func (i ResourceResponseArgs) ToResourceResponsePtrOutputWithContext(ctx context.Context) ResourceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceResponseOutput).ToResourceResponsePtrOutputWithContext(ctx)
}

// ResourceResponsePtrInput is an input type that accepts ResourceResponseArgs, ResourceResponsePtr and ResourceResponsePtrOutput values.
// You can construct a concrete instance of `ResourceResponsePtrInput` via:
//
//          ResourceResponseArgs{...}
//
//  or:
//
//          nil
type ResourceResponsePtrInput interface {
	pulumi.Input

	ToResourceResponsePtrOutput() ResourceResponsePtrOutput
	ToResourceResponsePtrOutputWithContext(context.Context) ResourceResponsePtrOutput
}

type resourceResponsePtrType ResourceResponseArgs

func ResourceResponsePtr(v *ResourceResponseArgs) ResourceResponsePtrInput {
	return (*resourceResponsePtrType)(v)
}

func (*resourceResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceResponse)(nil)).Elem()
}

func (i *resourceResponsePtrType) ToResourceResponsePtrOutput() ResourceResponsePtrOutput {
	return i.ToResourceResponsePtrOutputWithContext(context.Background())
}

func (i *resourceResponsePtrType) ToResourceResponsePtrOutputWithContext(ctx context.Context) ResourceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceResponsePtrOutput)
}

// An entity that can have metadata. For example, a Docker image.
type ResourceResponseOutput struct{ *pulumi.OutputState }

func (ResourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceResponse)(nil)).Elem()
}

func (o ResourceResponseOutput) ToResourceResponseOutput() ResourceResponseOutput {
	return o
}

func (o ResourceResponseOutput) ToResourceResponseOutputWithContext(ctx context.Context) ResourceResponseOutput {
	return o
}

func (o ResourceResponseOutput) ToResourceResponsePtrOutput() ResourceResponsePtrOutput {
	return o.ToResourceResponsePtrOutputWithContext(context.Background())
}

func (o ResourceResponseOutput) ToResourceResponsePtrOutputWithContext(ctx context.Context) ResourceResponsePtrOutput {
	return o.ApplyT(func(v ResourceResponse) *ResourceResponse {
		return &v
	}).(ResourceResponsePtrOutput)
}

// The unique URI of the resource. For example, `https://gcr.io/project/image@sha256:foo` for a Docker image.
func (o ResourceResponseOutput) Uri() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceResponse) string { return v.Uri }).(pulumi.StringOutput)
}

type ResourceResponsePtrOutput struct{ *pulumi.OutputState }

func (ResourceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceResponse)(nil)).Elem()
}

func (o ResourceResponsePtrOutput) ToResourceResponsePtrOutput() ResourceResponsePtrOutput {
	return o
}

func (o ResourceResponsePtrOutput) ToResourceResponsePtrOutputWithContext(ctx context.Context) ResourceResponsePtrOutput {
	return o
}

func (o ResourceResponsePtrOutput) Elem() ResourceResponseOutput {
	return o.ApplyT(func(v *ResourceResponse) ResourceResponse { return *v }).(ResourceResponseOutput)
}

// The unique URI of the resource. For example, `https://gcr.io/project/image@sha256:foo` for a Docker image.
func (o ResourceResponsePtrOutput) Uri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Uri
	}).(pulumi.StringPtrOutput)
}

// Verifiers (e.g. Kritis implementations) MUST verify signatures with respect to the trust anchors defined in policy (e.g. a Kritis policy). Typically this means that the verifier has been configured with a map from `public_key_id` to public key material (and any required parameters, e.g. signing algorithm). In particular, verification implementations MUST NOT treat the signature `public_key_id` as anything more than a key lookup hint. The `public_key_id` DOES NOT validate or authenticate a public key; it only provides a mechanism for quickly selecting a public key ALREADY CONFIGURED on the verifier through a trusted channel. Verification implementations MUST reject signatures in any of the following circumstances: * The `public_key_id` is not recognized by the verifier. * The public key that `public_key_id` refers to does not verify the signature with respect to the payload. The `signature` contents SHOULD NOT be "attached" (where the payload is included with the serialized `signature` bytes). Verifiers MUST ignore any "attached" payload and only verify signatures with respect to explicitly provided payload (e.g. a `payload` field on the proto message that holds this Signature, or the canonical serialization of the proto message that holds this signature).
type Signature struct {
	// The identifier for the public key that verifies this signature. * The `public_key_id` is required. * The `public_key_id` SHOULD be an RFC3986 conformant URI. * When possible, the `public_key_id` SHOULD be an immutable reference, such as a cryptographic digest. Examples of valid `public_key_id`s: OpenPGP V4 public key fingerprint: * "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA" See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more details on this scheme. RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER serialization): * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU" * "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
	PublicKeyId *string `pulumi:"publicKeyId"`
	// The content of the signature, an opaque bytestring. The payload that this signature verifies MUST be unambiguously provided with the Signature during verification. A wrapper message might provide the payload explicitly. Alternatively, a message might have a canonical serialization that can always be unambiguously computed to derive the payload.
	Signature *string `pulumi:"signature"`
}

// SignatureInput is an input type that accepts SignatureArgs and SignatureOutput values.
// You can construct a concrete instance of `SignatureInput` via:
//
//          SignatureArgs{...}
type SignatureInput interface {
	pulumi.Input

	ToSignatureOutput() SignatureOutput
	ToSignatureOutputWithContext(context.Context) SignatureOutput
}

// Verifiers (e.g. Kritis implementations) MUST verify signatures with respect to the trust anchors defined in policy (e.g. a Kritis policy). Typically this means that the verifier has been configured with a map from `public_key_id` to public key material (and any required parameters, e.g. signing algorithm). In particular, verification implementations MUST NOT treat the signature `public_key_id` as anything more than a key lookup hint. The `public_key_id` DOES NOT validate or authenticate a public key; it only provides a mechanism for quickly selecting a public key ALREADY CONFIGURED on the verifier through a trusted channel. Verification implementations MUST reject signatures in any of the following circumstances: * The `public_key_id` is not recognized by the verifier. * The public key that `public_key_id` refers to does not verify the signature with respect to the payload. The `signature` contents SHOULD NOT be "attached" (where the payload is included with the serialized `signature` bytes). Verifiers MUST ignore any "attached" payload and only verify signatures with respect to explicitly provided payload (e.g. a `payload` field on the proto message that holds this Signature, or the canonical serialization of the proto message that holds this signature).
type SignatureArgs struct {
	// The identifier for the public key that verifies this signature. * The `public_key_id` is required. * The `public_key_id` SHOULD be an RFC3986 conformant URI. * When possible, the `public_key_id` SHOULD be an immutable reference, such as a cryptographic digest. Examples of valid `public_key_id`s: OpenPGP V4 public key fingerprint: * "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA" See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more details on this scheme. RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER serialization): * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU" * "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
	PublicKeyId pulumi.StringPtrInput `pulumi:"publicKeyId"`
	// The content of the signature, an opaque bytestring. The payload that this signature verifies MUST be unambiguously provided with the Signature during verification. A wrapper message might provide the payload explicitly. Alternatively, a message might have a canonical serialization that can always be unambiguously computed to derive the payload.
	Signature pulumi.StringPtrInput `pulumi:"signature"`
}

func (SignatureArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Signature)(nil)).Elem()
}

func (i SignatureArgs) ToSignatureOutput() SignatureOutput {
	return i.ToSignatureOutputWithContext(context.Background())
}

func (i SignatureArgs) ToSignatureOutputWithContext(ctx context.Context) SignatureOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignatureOutput)
}

// SignatureArrayInput is an input type that accepts SignatureArray and SignatureArrayOutput values.
// You can construct a concrete instance of `SignatureArrayInput` via:
//
//          SignatureArray{ SignatureArgs{...} }
type SignatureArrayInput interface {
	pulumi.Input

	ToSignatureArrayOutput() SignatureArrayOutput
	ToSignatureArrayOutputWithContext(context.Context) SignatureArrayOutput
}

type SignatureArray []SignatureInput

func (SignatureArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Signature)(nil)).Elem()
}

func (i SignatureArray) ToSignatureArrayOutput() SignatureArrayOutput {
	return i.ToSignatureArrayOutputWithContext(context.Background())
}

func (i SignatureArray) ToSignatureArrayOutputWithContext(ctx context.Context) SignatureArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignatureArrayOutput)
}

// Verifiers (e.g. Kritis implementations) MUST verify signatures with respect to the trust anchors defined in policy (e.g. a Kritis policy). Typically this means that the verifier has been configured with a map from `public_key_id` to public key material (and any required parameters, e.g. signing algorithm). In particular, verification implementations MUST NOT treat the signature `public_key_id` as anything more than a key lookup hint. The `public_key_id` DOES NOT validate or authenticate a public key; it only provides a mechanism for quickly selecting a public key ALREADY CONFIGURED on the verifier through a trusted channel. Verification implementations MUST reject signatures in any of the following circumstances: * The `public_key_id` is not recognized by the verifier. * The public key that `public_key_id` refers to does not verify the signature with respect to the payload. The `signature` contents SHOULD NOT be "attached" (where the payload is included with the serialized `signature` bytes). Verifiers MUST ignore any "attached" payload and only verify signatures with respect to explicitly provided payload (e.g. a `payload` field on the proto message that holds this Signature, or the canonical serialization of the proto message that holds this signature).
type SignatureOutput struct{ *pulumi.OutputState }

func (SignatureOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Signature)(nil)).Elem()
}

func (o SignatureOutput) ToSignatureOutput() SignatureOutput {
	return o
}

func (o SignatureOutput) ToSignatureOutputWithContext(ctx context.Context) SignatureOutput {
	return o
}

// The identifier for the public key that verifies this signature. * The `public_key_id` is required. * The `public_key_id` SHOULD be an RFC3986 conformant URI. * When possible, the `public_key_id` SHOULD be an immutable reference, such as a cryptographic digest. Examples of valid `public_key_id`s: OpenPGP V4 public key fingerprint: * "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA" See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more details on this scheme. RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER serialization): * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU" * "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
func (o SignatureOutput) PublicKeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Signature) *string { return v.PublicKeyId }).(pulumi.StringPtrOutput)
}

// The content of the signature, an opaque bytestring. The payload that this signature verifies MUST be unambiguously provided with the Signature during verification. A wrapper message might provide the payload explicitly. Alternatively, a message might have a canonical serialization that can always be unambiguously computed to derive the payload.
func (o SignatureOutput) Signature() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Signature) *string { return v.Signature }).(pulumi.StringPtrOutput)
}

type SignatureArrayOutput struct{ *pulumi.OutputState }

func (SignatureArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Signature)(nil)).Elem()
}

func (o SignatureArrayOutput) ToSignatureArrayOutput() SignatureArrayOutput {
	return o
}

func (o SignatureArrayOutput) ToSignatureArrayOutputWithContext(ctx context.Context) SignatureArrayOutput {
	return o
}

func (o SignatureArrayOutput) Index(i pulumi.IntInput) SignatureOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Signature {
		return vs[0].([]Signature)[vs[1].(int)]
	}).(SignatureOutput)
}

// Verifiers (e.g. Kritis implementations) MUST verify signatures with respect to the trust anchors defined in policy (e.g. a Kritis policy). Typically this means that the verifier has been configured with a map from `public_key_id` to public key material (and any required parameters, e.g. signing algorithm). In particular, verification implementations MUST NOT treat the signature `public_key_id` as anything more than a key lookup hint. The `public_key_id` DOES NOT validate or authenticate a public key; it only provides a mechanism for quickly selecting a public key ALREADY CONFIGURED on the verifier through a trusted channel. Verification implementations MUST reject signatures in any of the following circumstances: * The `public_key_id` is not recognized by the verifier. * The public key that `public_key_id` refers to does not verify the signature with respect to the payload. The `signature` contents SHOULD NOT be "attached" (where the payload is included with the serialized `signature` bytes). Verifiers MUST ignore any "attached" payload and only verify signatures with respect to explicitly provided payload (e.g. a `payload` field on the proto message that holds this Signature, or the canonical serialization of the proto message that holds this signature).
type SignatureResponse struct {
	// The identifier for the public key that verifies this signature. * The `public_key_id` is required. * The `public_key_id` SHOULD be an RFC3986 conformant URI. * When possible, the `public_key_id` SHOULD be an immutable reference, such as a cryptographic digest. Examples of valid `public_key_id`s: OpenPGP V4 public key fingerprint: * "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA" See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more details on this scheme. RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER serialization): * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU" * "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
	PublicKeyId string `pulumi:"publicKeyId"`
	// The content of the signature, an opaque bytestring. The payload that this signature verifies MUST be unambiguously provided with the Signature during verification. A wrapper message might provide the payload explicitly. Alternatively, a message might have a canonical serialization that can always be unambiguously computed to derive the payload.
	Signature string `pulumi:"signature"`
}

// SignatureResponseInput is an input type that accepts SignatureResponseArgs and SignatureResponseOutput values.
// You can construct a concrete instance of `SignatureResponseInput` via:
//
//          SignatureResponseArgs{...}
type SignatureResponseInput interface {
	pulumi.Input

	ToSignatureResponseOutput() SignatureResponseOutput
	ToSignatureResponseOutputWithContext(context.Context) SignatureResponseOutput
}

// Verifiers (e.g. Kritis implementations) MUST verify signatures with respect to the trust anchors defined in policy (e.g. a Kritis policy). Typically this means that the verifier has been configured with a map from `public_key_id` to public key material (and any required parameters, e.g. signing algorithm). In particular, verification implementations MUST NOT treat the signature `public_key_id` as anything more than a key lookup hint. The `public_key_id` DOES NOT validate or authenticate a public key; it only provides a mechanism for quickly selecting a public key ALREADY CONFIGURED on the verifier through a trusted channel. Verification implementations MUST reject signatures in any of the following circumstances: * The `public_key_id` is not recognized by the verifier. * The public key that `public_key_id` refers to does not verify the signature with respect to the payload. The `signature` contents SHOULD NOT be "attached" (where the payload is included with the serialized `signature` bytes). Verifiers MUST ignore any "attached" payload and only verify signatures with respect to explicitly provided payload (e.g. a `payload` field on the proto message that holds this Signature, or the canonical serialization of the proto message that holds this signature).
type SignatureResponseArgs struct {
	// The identifier for the public key that verifies this signature. * The `public_key_id` is required. * The `public_key_id` SHOULD be an RFC3986 conformant URI. * When possible, the `public_key_id` SHOULD be an immutable reference, such as a cryptographic digest. Examples of valid `public_key_id`s: OpenPGP V4 public key fingerprint: * "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA" See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more details on this scheme. RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER serialization): * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU" * "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
	PublicKeyId pulumi.StringInput `pulumi:"publicKeyId"`
	// The content of the signature, an opaque bytestring. The payload that this signature verifies MUST be unambiguously provided with the Signature during verification. A wrapper message might provide the payload explicitly. Alternatively, a message might have a canonical serialization that can always be unambiguously computed to derive the payload.
	Signature pulumi.StringInput `pulumi:"signature"`
}

func (SignatureResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SignatureResponse)(nil)).Elem()
}

func (i SignatureResponseArgs) ToSignatureResponseOutput() SignatureResponseOutput {
	return i.ToSignatureResponseOutputWithContext(context.Background())
}

func (i SignatureResponseArgs) ToSignatureResponseOutputWithContext(ctx context.Context) SignatureResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignatureResponseOutput)
}

// SignatureResponseArrayInput is an input type that accepts SignatureResponseArray and SignatureResponseArrayOutput values.
// You can construct a concrete instance of `SignatureResponseArrayInput` via:
//
//          SignatureResponseArray{ SignatureResponseArgs{...} }
type SignatureResponseArrayInput interface {
	pulumi.Input

	ToSignatureResponseArrayOutput() SignatureResponseArrayOutput
	ToSignatureResponseArrayOutputWithContext(context.Context) SignatureResponseArrayOutput
}

type SignatureResponseArray []SignatureResponseInput

func (SignatureResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SignatureResponse)(nil)).Elem()
}

func (i SignatureResponseArray) ToSignatureResponseArrayOutput() SignatureResponseArrayOutput {
	return i.ToSignatureResponseArrayOutputWithContext(context.Background())
}

func (i SignatureResponseArray) ToSignatureResponseArrayOutputWithContext(ctx context.Context) SignatureResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignatureResponseArrayOutput)
}

// Verifiers (e.g. Kritis implementations) MUST verify signatures with respect to the trust anchors defined in policy (e.g. a Kritis policy). Typically this means that the verifier has been configured with a map from `public_key_id` to public key material (and any required parameters, e.g. signing algorithm). In particular, verification implementations MUST NOT treat the signature `public_key_id` as anything more than a key lookup hint. The `public_key_id` DOES NOT validate or authenticate a public key; it only provides a mechanism for quickly selecting a public key ALREADY CONFIGURED on the verifier through a trusted channel. Verification implementations MUST reject signatures in any of the following circumstances: * The `public_key_id` is not recognized by the verifier. * The public key that `public_key_id` refers to does not verify the signature with respect to the payload. The `signature` contents SHOULD NOT be "attached" (where the payload is included with the serialized `signature` bytes). Verifiers MUST ignore any "attached" payload and only verify signatures with respect to explicitly provided payload (e.g. a `payload` field on the proto message that holds this Signature, or the canonical serialization of the proto message that holds this signature).
type SignatureResponseOutput struct{ *pulumi.OutputState }

func (SignatureResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SignatureResponse)(nil)).Elem()
}

func (o SignatureResponseOutput) ToSignatureResponseOutput() SignatureResponseOutput {
	return o
}

func (o SignatureResponseOutput) ToSignatureResponseOutputWithContext(ctx context.Context) SignatureResponseOutput {
	return o
}

// The identifier for the public key that verifies this signature. * The `public_key_id` is required. * The `public_key_id` SHOULD be an RFC3986 conformant URI. * When possible, the `public_key_id` SHOULD be an immutable reference, such as a cryptographic digest. Examples of valid `public_key_id`s: OpenPGP V4 public key fingerprint: * "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA" See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more details on this scheme. RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER serialization): * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU" * "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
func (o SignatureResponseOutput) PublicKeyId() pulumi.StringOutput {
	return o.ApplyT(func(v SignatureResponse) string { return v.PublicKeyId }).(pulumi.StringOutput)
}

// The content of the signature, an opaque bytestring. The payload that this signature verifies MUST be unambiguously provided with the Signature during verification. A wrapper message might provide the payload explicitly. Alternatively, a message might have a canonical serialization that can always be unambiguously computed to derive the payload.
func (o SignatureResponseOutput) Signature() pulumi.StringOutput {
	return o.ApplyT(func(v SignatureResponse) string { return v.Signature }).(pulumi.StringOutput)
}

type SignatureResponseArrayOutput struct{ *pulumi.OutputState }

func (SignatureResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SignatureResponse)(nil)).Elem()
}

func (o SignatureResponseArrayOutput) ToSignatureResponseArrayOutput() SignatureResponseArrayOutput {
	return o
}

func (o SignatureResponseArrayOutput) ToSignatureResponseArrayOutputWithContext(ctx context.Context) SignatureResponseArrayOutput {
	return o
}

func (o SignatureResponseArrayOutput) Index(i pulumi.IntInput) SignatureResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SignatureResponse {
		return vs[0].([]SignatureResponse)[vs[1].(int)]
	}).(SignatureResponseOutput)
}

// This defines the format used to record keys used in the software supply chain. An in-toto link is attested using one or more keys defined in the in-toto layout. An example of this is: { "key_id": "776a00e29f3559e0141b3b096f696abc6cfb0c657ab40f441132b345b0...", "key_type": "rsa", "public_key_value": "-----BEGIN PUBLIC KEY-----\nMIIBojANBgkqhkiG9w0B...", "key_scheme": "rsassa-pss-sha256" } The format for in-toto's key definition can be found in section 4.2 of the in-toto specification.
type SigningKey struct {
	// key_id is an identifier for the signing key.
	KeyId *string `pulumi:"keyId"`
	// This field contains the corresponding signature scheme. Eg: "rsassa-pss-sha256".
	KeyScheme *string `pulumi:"keyScheme"`
	// This field identifies the specific signing method. Eg: "rsa", "ed25519", and "ecdsa".
	KeyType *string `pulumi:"keyType"`
	// This field contains the actual public key.
	PublicKeyValue *string `pulumi:"publicKeyValue"`
}

// SigningKeyInput is an input type that accepts SigningKeyArgs and SigningKeyOutput values.
// You can construct a concrete instance of `SigningKeyInput` via:
//
//          SigningKeyArgs{...}
type SigningKeyInput interface {
	pulumi.Input

	ToSigningKeyOutput() SigningKeyOutput
	ToSigningKeyOutputWithContext(context.Context) SigningKeyOutput
}

// This defines the format used to record keys used in the software supply chain. An in-toto link is attested using one or more keys defined in the in-toto layout. An example of this is: { "key_id": "776a00e29f3559e0141b3b096f696abc6cfb0c657ab40f441132b345b0...", "key_type": "rsa", "public_key_value": "-----BEGIN PUBLIC KEY-----\nMIIBojANBgkqhkiG9w0B...", "key_scheme": "rsassa-pss-sha256" } The format for in-toto's key definition can be found in section 4.2 of the in-toto specification.
type SigningKeyArgs struct {
	// key_id is an identifier for the signing key.
	KeyId pulumi.StringPtrInput `pulumi:"keyId"`
	// This field contains the corresponding signature scheme. Eg: "rsassa-pss-sha256".
	KeyScheme pulumi.StringPtrInput `pulumi:"keyScheme"`
	// This field identifies the specific signing method. Eg: "rsa", "ed25519", and "ecdsa".
	KeyType pulumi.StringPtrInput `pulumi:"keyType"`
	// This field contains the actual public key.
	PublicKeyValue pulumi.StringPtrInput `pulumi:"publicKeyValue"`
}

func (SigningKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SigningKey)(nil)).Elem()
}

func (i SigningKeyArgs) ToSigningKeyOutput() SigningKeyOutput {
	return i.ToSigningKeyOutputWithContext(context.Background())
}

func (i SigningKeyArgs) ToSigningKeyOutputWithContext(ctx context.Context) SigningKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SigningKeyOutput)
}

// SigningKeyArrayInput is an input type that accepts SigningKeyArray and SigningKeyArrayOutput values.
// You can construct a concrete instance of `SigningKeyArrayInput` via:
//
//          SigningKeyArray{ SigningKeyArgs{...} }
type SigningKeyArrayInput interface {
	pulumi.Input

	ToSigningKeyArrayOutput() SigningKeyArrayOutput
	ToSigningKeyArrayOutputWithContext(context.Context) SigningKeyArrayOutput
}

type SigningKeyArray []SigningKeyInput

func (SigningKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SigningKey)(nil)).Elem()
}

func (i SigningKeyArray) ToSigningKeyArrayOutput() SigningKeyArrayOutput {
	return i.ToSigningKeyArrayOutputWithContext(context.Background())
}

func (i SigningKeyArray) ToSigningKeyArrayOutputWithContext(ctx context.Context) SigningKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SigningKeyArrayOutput)
}

// This defines the format used to record keys used in the software supply chain. An in-toto link is attested using one or more keys defined in the in-toto layout. An example of this is: { "key_id": "776a00e29f3559e0141b3b096f696abc6cfb0c657ab40f441132b345b0...", "key_type": "rsa", "public_key_value": "-----BEGIN PUBLIC KEY-----\nMIIBojANBgkqhkiG9w0B...", "key_scheme": "rsassa-pss-sha256" } The format for in-toto's key definition can be found in section 4.2 of the in-toto specification.
type SigningKeyOutput struct{ *pulumi.OutputState }

func (SigningKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SigningKey)(nil)).Elem()
}

func (o SigningKeyOutput) ToSigningKeyOutput() SigningKeyOutput {
	return o
}

func (o SigningKeyOutput) ToSigningKeyOutputWithContext(ctx context.Context) SigningKeyOutput {
	return o
}

// key_id is an identifier for the signing key.
func (o SigningKeyOutput) KeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SigningKey) *string { return v.KeyId }).(pulumi.StringPtrOutput)
}

// This field contains the corresponding signature scheme. Eg: "rsassa-pss-sha256".
func (o SigningKeyOutput) KeyScheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SigningKey) *string { return v.KeyScheme }).(pulumi.StringPtrOutput)
}

// This field identifies the specific signing method. Eg: "rsa", "ed25519", and "ecdsa".
func (o SigningKeyOutput) KeyType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SigningKey) *string { return v.KeyType }).(pulumi.StringPtrOutput)
}

// This field contains the actual public key.
func (o SigningKeyOutput) PublicKeyValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SigningKey) *string { return v.PublicKeyValue }).(pulumi.StringPtrOutput)
}

type SigningKeyArrayOutput struct{ *pulumi.OutputState }

func (SigningKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SigningKey)(nil)).Elem()
}

func (o SigningKeyArrayOutput) ToSigningKeyArrayOutput() SigningKeyArrayOutput {
	return o
}

func (o SigningKeyArrayOutput) ToSigningKeyArrayOutputWithContext(ctx context.Context) SigningKeyArrayOutput {
	return o
}

func (o SigningKeyArrayOutput) Index(i pulumi.IntInput) SigningKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SigningKey {
		return vs[0].([]SigningKey)[vs[1].(int)]
	}).(SigningKeyOutput)
}

// This defines the format used to record keys used in the software supply chain. An in-toto link is attested using one or more keys defined in the in-toto layout. An example of this is: { "key_id": "776a00e29f3559e0141b3b096f696abc6cfb0c657ab40f441132b345b0...", "key_type": "rsa", "public_key_value": "-----BEGIN PUBLIC KEY-----\nMIIBojANBgkqhkiG9w0B...", "key_scheme": "rsassa-pss-sha256" } The format for in-toto's key definition can be found in section 4.2 of the in-toto specification.
type SigningKeyResponse struct {
	// key_id is an identifier for the signing key.
	KeyId string `pulumi:"keyId"`
	// This field contains the corresponding signature scheme. Eg: "rsassa-pss-sha256".
	KeyScheme string `pulumi:"keyScheme"`
	// This field identifies the specific signing method. Eg: "rsa", "ed25519", and "ecdsa".
	KeyType string `pulumi:"keyType"`
	// This field contains the actual public key.
	PublicKeyValue string `pulumi:"publicKeyValue"`
}

// SigningKeyResponseInput is an input type that accepts SigningKeyResponseArgs and SigningKeyResponseOutput values.
// You can construct a concrete instance of `SigningKeyResponseInput` via:
//
//          SigningKeyResponseArgs{...}
type SigningKeyResponseInput interface {
	pulumi.Input

	ToSigningKeyResponseOutput() SigningKeyResponseOutput
	ToSigningKeyResponseOutputWithContext(context.Context) SigningKeyResponseOutput
}

// This defines the format used to record keys used in the software supply chain. An in-toto link is attested using one or more keys defined in the in-toto layout. An example of this is: { "key_id": "776a00e29f3559e0141b3b096f696abc6cfb0c657ab40f441132b345b0...", "key_type": "rsa", "public_key_value": "-----BEGIN PUBLIC KEY-----\nMIIBojANBgkqhkiG9w0B...", "key_scheme": "rsassa-pss-sha256" } The format for in-toto's key definition can be found in section 4.2 of the in-toto specification.
type SigningKeyResponseArgs struct {
	// key_id is an identifier for the signing key.
	KeyId pulumi.StringInput `pulumi:"keyId"`
	// This field contains the corresponding signature scheme. Eg: "rsassa-pss-sha256".
	KeyScheme pulumi.StringInput `pulumi:"keyScheme"`
	// This field identifies the specific signing method. Eg: "rsa", "ed25519", and "ecdsa".
	KeyType pulumi.StringInput `pulumi:"keyType"`
	// This field contains the actual public key.
	PublicKeyValue pulumi.StringInput `pulumi:"publicKeyValue"`
}

func (SigningKeyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SigningKeyResponse)(nil)).Elem()
}

func (i SigningKeyResponseArgs) ToSigningKeyResponseOutput() SigningKeyResponseOutput {
	return i.ToSigningKeyResponseOutputWithContext(context.Background())
}

func (i SigningKeyResponseArgs) ToSigningKeyResponseOutputWithContext(ctx context.Context) SigningKeyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SigningKeyResponseOutput)
}

// SigningKeyResponseArrayInput is an input type that accepts SigningKeyResponseArray and SigningKeyResponseArrayOutput values.
// You can construct a concrete instance of `SigningKeyResponseArrayInput` via:
//
//          SigningKeyResponseArray{ SigningKeyResponseArgs{...} }
type SigningKeyResponseArrayInput interface {
	pulumi.Input

	ToSigningKeyResponseArrayOutput() SigningKeyResponseArrayOutput
	ToSigningKeyResponseArrayOutputWithContext(context.Context) SigningKeyResponseArrayOutput
}

type SigningKeyResponseArray []SigningKeyResponseInput

func (SigningKeyResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SigningKeyResponse)(nil)).Elem()
}

func (i SigningKeyResponseArray) ToSigningKeyResponseArrayOutput() SigningKeyResponseArrayOutput {
	return i.ToSigningKeyResponseArrayOutputWithContext(context.Background())
}

func (i SigningKeyResponseArray) ToSigningKeyResponseArrayOutputWithContext(ctx context.Context) SigningKeyResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SigningKeyResponseArrayOutput)
}

// This defines the format used to record keys used in the software supply chain. An in-toto link is attested using one or more keys defined in the in-toto layout. An example of this is: { "key_id": "776a00e29f3559e0141b3b096f696abc6cfb0c657ab40f441132b345b0...", "key_type": "rsa", "public_key_value": "-----BEGIN PUBLIC KEY-----\nMIIBojANBgkqhkiG9w0B...", "key_scheme": "rsassa-pss-sha256" } The format for in-toto's key definition can be found in section 4.2 of the in-toto specification.
type SigningKeyResponseOutput struct{ *pulumi.OutputState }

func (SigningKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SigningKeyResponse)(nil)).Elem()
}

func (o SigningKeyResponseOutput) ToSigningKeyResponseOutput() SigningKeyResponseOutput {
	return o
}

func (o SigningKeyResponseOutput) ToSigningKeyResponseOutputWithContext(ctx context.Context) SigningKeyResponseOutput {
	return o
}

// key_id is an identifier for the signing key.
func (o SigningKeyResponseOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v SigningKeyResponse) string { return v.KeyId }).(pulumi.StringOutput)
}

// This field contains the corresponding signature scheme. Eg: "rsassa-pss-sha256".
func (o SigningKeyResponseOutput) KeyScheme() pulumi.StringOutput {
	return o.ApplyT(func(v SigningKeyResponse) string { return v.KeyScheme }).(pulumi.StringOutput)
}

// This field identifies the specific signing method. Eg: "rsa", "ed25519", and "ecdsa".
func (o SigningKeyResponseOutput) KeyType() pulumi.StringOutput {
	return o.ApplyT(func(v SigningKeyResponse) string { return v.KeyType }).(pulumi.StringOutput)
}

// This field contains the actual public key.
func (o SigningKeyResponseOutput) PublicKeyValue() pulumi.StringOutput {
	return o.ApplyT(func(v SigningKeyResponse) string { return v.PublicKeyValue }).(pulumi.StringOutput)
}

type SigningKeyResponseArrayOutput struct{ *pulumi.OutputState }

func (SigningKeyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SigningKeyResponse)(nil)).Elem()
}

func (o SigningKeyResponseArrayOutput) ToSigningKeyResponseArrayOutput() SigningKeyResponseArrayOutput {
	return o
}

func (o SigningKeyResponseArrayOutput) ToSigningKeyResponseArrayOutputWithContext(ctx context.Context) SigningKeyResponseArrayOutput {
	return o
}

func (o SigningKeyResponseArrayOutput) Index(i pulumi.IntInput) SigningKeyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SigningKeyResponse {
		return vs[0].([]SigningKeyResponse)[vs[1].(int)]
	}).(SigningKeyResponseOutput)
}

// Source describes the location of the source used for the build.
type Source struct {
	// If provided, some of the source code used for the build may be found in these locations, in the case where the source repository had multiple remotes or submodules. This list will not include the context specified in the context field.
	AdditionalContexts []SourceContext `pulumi:"additionalContexts"`
	// If provided, the input binary artifacts for the build came from this location.
	ArtifactStorageSourceUri *string `pulumi:"artifactStorageSourceUri"`
	// If provided, the source code used for the build came from this location.
	Context *SourceContext `pulumi:"context"`
	// Hash(es) of the build source, which can be used to verify that the original source integrity was maintained in the build. The keys to this map are file paths used as build source and the values contain the hash values for those files. If the build source came in a single package such as a gzipped tarfile (.tar.gz), the FileHash will be for the single path to that file.
	FileHashes map[string]string `pulumi:"fileHashes"`
}

// SourceInput is an input type that accepts SourceArgs and SourceOutput values.
// You can construct a concrete instance of `SourceInput` via:
//
//          SourceArgs{...}
type SourceInput interface {
	pulumi.Input

	ToSourceOutput() SourceOutput
	ToSourceOutputWithContext(context.Context) SourceOutput
}

// Source describes the location of the source used for the build.
type SourceArgs struct {
	// If provided, some of the source code used for the build may be found in these locations, in the case where the source repository had multiple remotes or submodules. This list will not include the context specified in the context field.
	AdditionalContexts SourceContextArrayInput `pulumi:"additionalContexts"`
	// If provided, the input binary artifacts for the build came from this location.
	ArtifactStorageSourceUri pulumi.StringPtrInput `pulumi:"artifactStorageSourceUri"`
	// If provided, the source code used for the build came from this location.
	Context SourceContextPtrInput `pulumi:"context"`
	// Hash(es) of the build source, which can be used to verify that the original source integrity was maintained in the build. The keys to this map are file paths used as build source and the values contain the hash values for those files. If the build source came in a single package such as a gzipped tarfile (.tar.gz), the FileHash will be for the single path to that file.
	FileHashes pulumi.StringMapInput `pulumi:"fileHashes"`
}

func (SourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Source)(nil)).Elem()
}

func (i SourceArgs) ToSourceOutput() SourceOutput {
	return i.ToSourceOutputWithContext(context.Background())
}

func (i SourceArgs) ToSourceOutputWithContext(ctx context.Context) SourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceOutput)
}

func (i SourceArgs) ToSourcePtrOutput() SourcePtrOutput {
	return i.ToSourcePtrOutputWithContext(context.Background())
}

func (i SourceArgs) ToSourcePtrOutputWithContext(ctx context.Context) SourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceOutput).ToSourcePtrOutputWithContext(ctx)
}

// SourcePtrInput is an input type that accepts SourceArgs, SourcePtr and SourcePtrOutput values.
// You can construct a concrete instance of `SourcePtrInput` via:
//
//          SourceArgs{...}
//
//  or:
//
//          nil
type SourcePtrInput interface {
	pulumi.Input

	ToSourcePtrOutput() SourcePtrOutput
	ToSourcePtrOutputWithContext(context.Context) SourcePtrOutput
}

type sourcePtrType SourceArgs

func SourcePtr(v *SourceArgs) SourcePtrInput {
	return (*sourcePtrType)(v)
}

func (*sourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Source)(nil)).Elem()
}

func (i *sourcePtrType) ToSourcePtrOutput() SourcePtrOutput {
	return i.ToSourcePtrOutputWithContext(context.Background())
}

func (i *sourcePtrType) ToSourcePtrOutputWithContext(ctx context.Context) SourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourcePtrOutput)
}

// Source describes the location of the source used for the build.
type SourceOutput struct{ *pulumi.OutputState }

func (SourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Source)(nil)).Elem()
}

func (o SourceOutput) ToSourceOutput() SourceOutput {
	return o
}

func (o SourceOutput) ToSourceOutputWithContext(ctx context.Context) SourceOutput {
	return o
}

func (o SourceOutput) ToSourcePtrOutput() SourcePtrOutput {
	return o.ToSourcePtrOutputWithContext(context.Background())
}

func (o SourceOutput) ToSourcePtrOutputWithContext(ctx context.Context) SourcePtrOutput {
	return o.ApplyT(func(v Source) *Source {
		return &v
	}).(SourcePtrOutput)
}

// If provided, some of the source code used for the build may be found in these locations, in the case where the source repository had multiple remotes or submodules. This list will not include the context specified in the context field.
func (o SourceOutput) AdditionalContexts() SourceContextArrayOutput {
	return o.ApplyT(func(v Source) []SourceContext { return v.AdditionalContexts }).(SourceContextArrayOutput)
}

// If provided, the input binary artifacts for the build came from this location.
func (o SourceOutput) ArtifactStorageSourceUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Source) *string { return v.ArtifactStorageSourceUri }).(pulumi.StringPtrOutput)
}

// If provided, the source code used for the build came from this location.
func (o SourceOutput) Context() SourceContextPtrOutput {
	return o.ApplyT(func(v Source) *SourceContext { return v.Context }).(SourceContextPtrOutput)
}

// Hash(es) of the build source, which can be used to verify that the original source integrity was maintained in the build. The keys to this map are file paths used as build source and the values contain the hash values for those files. If the build source came in a single package such as a gzipped tarfile (.tar.gz), the FileHash will be for the single path to that file.
func (o SourceOutput) FileHashes() pulumi.StringMapOutput {
	return o.ApplyT(func(v Source) map[string]string { return v.FileHashes }).(pulumi.StringMapOutput)
}

type SourcePtrOutput struct{ *pulumi.OutputState }

func (SourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Source)(nil)).Elem()
}

func (o SourcePtrOutput) ToSourcePtrOutput() SourcePtrOutput {
	return o
}

func (o SourcePtrOutput) ToSourcePtrOutputWithContext(ctx context.Context) SourcePtrOutput {
	return o
}

func (o SourcePtrOutput) Elem() SourceOutput {
	return o.ApplyT(func(v *Source) Source { return *v }).(SourceOutput)
}

// If provided, some of the source code used for the build may be found in these locations, in the case where the source repository had multiple remotes or submodules. This list will not include the context specified in the context field.
func (o SourcePtrOutput) AdditionalContexts() SourceContextArrayOutput {
	return o.ApplyT(func(v *Source) []SourceContext {
		if v == nil {
			return nil
		}
		return v.AdditionalContexts
	}).(SourceContextArrayOutput)
}

// If provided, the input binary artifacts for the build came from this location.
func (o SourcePtrOutput) ArtifactStorageSourceUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Source) *string {
		if v == nil {
			return nil
		}
		return v.ArtifactStorageSourceUri
	}).(pulumi.StringPtrOutput)
}

// If provided, the source code used for the build came from this location.
func (o SourcePtrOutput) Context() SourceContextPtrOutput {
	return o.ApplyT(func(v *Source) *SourceContext {
		if v == nil {
			return nil
		}
		return v.Context
	}).(SourceContextPtrOutput)
}

// Hash(es) of the build source, which can be used to verify that the original source integrity was maintained in the build. The keys to this map are file paths used as build source and the values contain the hash values for those files. If the build source came in a single package such as a gzipped tarfile (.tar.gz), the FileHash will be for the single path to that file.
func (o SourcePtrOutput) FileHashes() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Source) map[string]string {
		if v == nil {
			return nil
		}
		return v.FileHashes
	}).(pulumi.StringMapOutput)
}

// A SourceContext is a reference to a tree of files. A SourceContext together with a path point to a unique revision of a single file or directory.
type SourceContext struct {
	// A SourceContext referring to a revision in a Google Cloud Source Repo.
	CloudRepo *CloudRepoSourceContext `pulumi:"cloudRepo"`
	// A SourceContext referring to a Gerrit project.
	Gerrit *GerritSourceContext `pulumi:"gerrit"`
	// A SourceContext referring to any third party Git repo (e.g., GitHub).
	Git *GitSourceContext `pulumi:"git"`
	// Labels with user defined metadata.
	Labels map[string]string `pulumi:"labels"`
}

// SourceContextInput is an input type that accepts SourceContextArgs and SourceContextOutput values.
// You can construct a concrete instance of `SourceContextInput` via:
//
//          SourceContextArgs{...}
type SourceContextInput interface {
	pulumi.Input

	ToSourceContextOutput() SourceContextOutput
	ToSourceContextOutputWithContext(context.Context) SourceContextOutput
}

// A SourceContext is a reference to a tree of files. A SourceContext together with a path point to a unique revision of a single file or directory.
type SourceContextArgs struct {
	// A SourceContext referring to a revision in a Google Cloud Source Repo.
	CloudRepo CloudRepoSourceContextPtrInput `pulumi:"cloudRepo"`
	// A SourceContext referring to a Gerrit project.
	Gerrit GerritSourceContextPtrInput `pulumi:"gerrit"`
	// A SourceContext referring to any third party Git repo (e.g., GitHub).
	Git GitSourceContextPtrInput `pulumi:"git"`
	// Labels with user defined metadata.
	Labels pulumi.StringMapInput `pulumi:"labels"`
}

func (SourceContextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SourceContext)(nil)).Elem()
}

func (i SourceContextArgs) ToSourceContextOutput() SourceContextOutput {
	return i.ToSourceContextOutputWithContext(context.Background())
}

func (i SourceContextArgs) ToSourceContextOutputWithContext(ctx context.Context) SourceContextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceContextOutput)
}

func (i SourceContextArgs) ToSourceContextPtrOutput() SourceContextPtrOutput {
	return i.ToSourceContextPtrOutputWithContext(context.Background())
}

func (i SourceContextArgs) ToSourceContextPtrOutputWithContext(ctx context.Context) SourceContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceContextOutput).ToSourceContextPtrOutputWithContext(ctx)
}

// SourceContextPtrInput is an input type that accepts SourceContextArgs, SourceContextPtr and SourceContextPtrOutput values.
// You can construct a concrete instance of `SourceContextPtrInput` via:
//
//          SourceContextArgs{...}
//
//  or:
//
//          nil
type SourceContextPtrInput interface {
	pulumi.Input

	ToSourceContextPtrOutput() SourceContextPtrOutput
	ToSourceContextPtrOutputWithContext(context.Context) SourceContextPtrOutput
}

type sourceContextPtrType SourceContextArgs

func SourceContextPtr(v *SourceContextArgs) SourceContextPtrInput {
	return (*sourceContextPtrType)(v)
}

func (*sourceContextPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SourceContext)(nil)).Elem()
}

func (i *sourceContextPtrType) ToSourceContextPtrOutput() SourceContextPtrOutput {
	return i.ToSourceContextPtrOutputWithContext(context.Background())
}

func (i *sourceContextPtrType) ToSourceContextPtrOutputWithContext(ctx context.Context) SourceContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceContextPtrOutput)
}

// SourceContextArrayInput is an input type that accepts SourceContextArray and SourceContextArrayOutput values.
// You can construct a concrete instance of `SourceContextArrayInput` via:
//
//          SourceContextArray{ SourceContextArgs{...} }
type SourceContextArrayInput interface {
	pulumi.Input

	ToSourceContextArrayOutput() SourceContextArrayOutput
	ToSourceContextArrayOutputWithContext(context.Context) SourceContextArrayOutput
}

type SourceContextArray []SourceContextInput

func (SourceContextArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SourceContext)(nil)).Elem()
}

func (i SourceContextArray) ToSourceContextArrayOutput() SourceContextArrayOutput {
	return i.ToSourceContextArrayOutputWithContext(context.Background())
}

func (i SourceContextArray) ToSourceContextArrayOutputWithContext(ctx context.Context) SourceContextArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceContextArrayOutput)
}

// A SourceContext is a reference to a tree of files. A SourceContext together with a path point to a unique revision of a single file or directory.
type SourceContextOutput struct{ *pulumi.OutputState }

func (SourceContextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SourceContext)(nil)).Elem()
}

func (o SourceContextOutput) ToSourceContextOutput() SourceContextOutput {
	return o
}

func (o SourceContextOutput) ToSourceContextOutputWithContext(ctx context.Context) SourceContextOutput {
	return o
}

func (o SourceContextOutput) ToSourceContextPtrOutput() SourceContextPtrOutput {
	return o.ToSourceContextPtrOutputWithContext(context.Background())
}

func (o SourceContextOutput) ToSourceContextPtrOutputWithContext(ctx context.Context) SourceContextPtrOutput {
	return o.ApplyT(func(v SourceContext) *SourceContext {
		return &v
	}).(SourceContextPtrOutput)
}

// A SourceContext referring to a revision in a Google Cloud Source Repo.
func (o SourceContextOutput) CloudRepo() CloudRepoSourceContextPtrOutput {
	return o.ApplyT(func(v SourceContext) *CloudRepoSourceContext { return v.CloudRepo }).(CloudRepoSourceContextPtrOutput)
}

// A SourceContext referring to a Gerrit project.
func (o SourceContextOutput) Gerrit() GerritSourceContextPtrOutput {
	return o.ApplyT(func(v SourceContext) *GerritSourceContext { return v.Gerrit }).(GerritSourceContextPtrOutput)
}

// A SourceContext referring to any third party Git repo (e.g., GitHub).
func (o SourceContextOutput) Git() GitSourceContextPtrOutput {
	return o.ApplyT(func(v SourceContext) *GitSourceContext { return v.Git }).(GitSourceContextPtrOutput)
}

// Labels with user defined metadata.
func (o SourceContextOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v SourceContext) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

type SourceContextPtrOutput struct{ *pulumi.OutputState }

func (SourceContextPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SourceContext)(nil)).Elem()
}

func (o SourceContextPtrOutput) ToSourceContextPtrOutput() SourceContextPtrOutput {
	return o
}

func (o SourceContextPtrOutput) ToSourceContextPtrOutputWithContext(ctx context.Context) SourceContextPtrOutput {
	return o
}

func (o SourceContextPtrOutput) Elem() SourceContextOutput {
	return o.ApplyT(func(v *SourceContext) SourceContext { return *v }).(SourceContextOutput)
}

// A SourceContext referring to a revision in a Google Cloud Source Repo.
func (o SourceContextPtrOutput) CloudRepo() CloudRepoSourceContextPtrOutput {
	return o.ApplyT(func(v *SourceContext) *CloudRepoSourceContext {
		if v == nil {
			return nil
		}
		return v.CloudRepo
	}).(CloudRepoSourceContextPtrOutput)
}

// A SourceContext referring to a Gerrit project.
func (o SourceContextPtrOutput) Gerrit() GerritSourceContextPtrOutput {
	return o.ApplyT(func(v *SourceContext) *GerritSourceContext {
		if v == nil {
			return nil
		}
		return v.Gerrit
	}).(GerritSourceContextPtrOutput)
}

// A SourceContext referring to any third party Git repo (e.g., GitHub).
func (o SourceContextPtrOutput) Git() GitSourceContextPtrOutput {
	return o.ApplyT(func(v *SourceContext) *GitSourceContext {
		if v == nil {
			return nil
		}
		return v.Git
	}).(GitSourceContextPtrOutput)
}

// Labels with user defined metadata.
func (o SourceContextPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SourceContext) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

type SourceContextArrayOutput struct{ *pulumi.OutputState }

func (SourceContextArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SourceContext)(nil)).Elem()
}

func (o SourceContextArrayOutput) ToSourceContextArrayOutput() SourceContextArrayOutput {
	return o
}

func (o SourceContextArrayOutput) ToSourceContextArrayOutputWithContext(ctx context.Context) SourceContextArrayOutput {
	return o
}

func (o SourceContextArrayOutput) Index(i pulumi.IntInput) SourceContextOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SourceContext {
		return vs[0].([]SourceContext)[vs[1].(int)]
	}).(SourceContextOutput)
}

// A SourceContext is a reference to a tree of files. A SourceContext together with a path point to a unique revision of a single file or directory.
type SourceContextResponse struct {
	// A SourceContext referring to a revision in a Google Cloud Source Repo.
	CloudRepo CloudRepoSourceContextResponse `pulumi:"cloudRepo"`
	// A SourceContext referring to a Gerrit project.
	Gerrit GerritSourceContextResponse `pulumi:"gerrit"`
	// A SourceContext referring to any third party Git repo (e.g., GitHub).
	Git GitSourceContextResponse `pulumi:"git"`
	// Labels with user defined metadata.
	Labels map[string]string `pulumi:"labels"`
}

// SourceContextResponseInput is an input type that accepts SourceContextResponseArgs and SourceContextResponseOutput values.
// You can construct a concrete instance of `SourceContextResponseInput` via:
//
//          SourceContextResponseArgs{...}
type SourceContextResponseInput interface {
	pulumi.Input

	ToSourceContextResponseOutput() SourceContextResponseOutput
	ToSourceContextResponseOutputWithContext(context.Context) SourceContextResponseOutput
}

// A SourceContext is a reference to a tree of files. A SourceContext together with a path point to a unique revision of a single file or directory.
type SourceContextResponseArgs struct {
	// A SourceContext referring to a revision in a Google Cloud Source Repo.
	CloudRepo CloudRepoSourceContextResponseInput `pulumi:"cloudRepo"`
	// A SourceContext referring to a Gerrit project.
	Gerrit GerritSourceContextResponseInput `pulumi:"gerrit"`
	// A SourceContext referring to any third party Git repo (e.g., GitHub).
	Git GitSourceContextResponseInput `pulumi:"git"`
	// Labels with user defined metadata.
	Labels pulumi.StringMapInput `pulumi:"labels"`
}

func (SourceContextResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SourceContextResponse)(nil)).Elem()
}

func (i SourceContextResponseArgs) ToSourceContextResponseOutput() SourceContextResponseOutput {
	return i.ToSourceContextResponseOutputWithContext(context.Background())
}

func (i SourceContextResponseArgs) ToSourceContextResponseOutputWithContext(ctx context.Context) SourceContextResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceContextResponseOutput)
}

func (i SourceContextResponseArgs) ToSourceContextResponsePtrOutput() SourceContextResponsePtrOutput {
	return i.ToSourceContextResponsePtrOutputWithContext(context.Background())
}

func (i SourceContextResponseArgs) ToSourceContextResponsePtrOutputWithContext(ctx context.Context) SourceContextResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceContextResponseOutput).ToSourceContextResponsePtrOutputWithContext(ctx)
}

// SourceContextResponsePtrInput is an input type that accepts SourceContextResponseArgs, SourceContextResponsePtr and SourceContextResponsePtrOutput values.
// You can construct a concrete instance of `SourceContextResponsePtrInput` via:
//
//          SourceContextResponseArgs{...}
//
//  or:
//
//          nil
type SourceContextResponsePtrInput interface {
	pulumi.Input

	ToSourceContextResponsePtrOutput() SourceContextResponsePtrOutput
	ToSourceContextResponsePtrOutputWithContext(context.Context) SourceContextResponsePtrOutput
}

type sourceContextResponsePtrType SourceContextResponseArgs

func SourceContextResponsePtr(v *SourceContextResponseArgs) SourceContextResponsePtrInput {
	return (*sourceContextResponsePtrType)(v)
}

func (*sourceContextResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SourceContextResponse)(nil)).Elem()
}

func (i *sourceContextResponsePtrType) ToSourceContextResponsePtrOutput() SourceContextResponsePtrOutput {
	return i.ToSourceContextResponsePtrOutputWithContext(context.Background())
}

func (i *sourceContextResponsePtrType) ToSourceContextResponsePtrOutputWithContext(ctx context.Context) SourceContextResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceContextResponsePtrOutput)
}

// SourceContextResponseArrayInput is an input type that accepts SourceContextResponseArray and SourceContextResponseArrayOutput values.
// You can construct a concrete instance of `SourceContextResponseArrayInput` via:
//
//          SourceContextResponseArray{ SourceContextResponseArgs{...} }
type SourceContextResponseArrayInput interface {
	pulumi.Input

	ToSourceContextResponseArrayOutput() SourceContextResponseArrayOutput
	ToSourceContextResponseArrayOutputWithContext(context.Context) SourceContextResponseArrayOutput
}

type SourceContextResponseArray []SourceContextResponseInput

func (SourceContextResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SourceContextResponse)(nil)).Elem()
}

func (i SourceContextResponseArray) ToSourceContextResponseArrayOutput() SourceContextResponseArrayOutput {
	return i.ToSourceContextResponseArrayOutputWithContext(context.Background())
}

func (i SourceContextResponseArray) ToSourceContextResponseArrayOutputWithContext(ctx context.Context) SourceContextResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceContextResponseArrayOutput)
}

// A SourceContext is a reference to a tree of files. A SourceContext together with a path point to a unique revision of a single file or directory.
type SourceContextResponseOutput struct{ *pulumi.OutputState }

func (SourceContextResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SourceContextResponse)(nil)).Elem()
}

func (o SourceContextResponseOutput) ToSourceContextResponseOutput() SourceContextResponseOutput {
	return o
}

func (o SourceContextResponseOutput) ToSourceContextResponseOutputWithContext(ctx context.Context) SourceContextResponseOutput {
	return o
}

func (o SourceContextResponseOutput) ToSourceContextResponsePtrOutput() SourceContextResponsePtrOutput {
	return o.ToSourceContextResponsePtrOutputWithContext(context.Background())
}

func (o SourceContextResponseOutput) ToSourceContextResponsePtrOutputWithContext(ctx context.Context) SourceContextResponsePtrOutput {
	return o.ApplyT(func(v SourceContextResponse) *SourceContextResponse {
		return &v
	}).(SourceContextResponsePtrOutput)
}

// A SourceContext referring to a revision in a Google Cloud Source Repo.
func (o SourceContextResponseOutput) CloudRepo() CloudRepoSourceContextResponseOutput {
	return o.ApplyT(func(v SourceContextResponse) CloudRepoSourceContextResponse { return v.CloudRepo }).(CloudRepoSourceContextResponseOutput)
}

// A SourceContext referring to a Gerrit project.
func (o SourceContextResponseOutput) Gerrit() GerritSourceContextResponseOutput {
	return o.ApplyT(func(v SourceContextResponse) GerritSourceContextResponse { return v.Gerrit }).(GerritSourceContextResponseOutput)
}

// A SourceContext referring to any third party Git repo (e.g., GitHub).
func (o SourceContextResponseOutput) Git() GitSourceContextResponseOutput {
	return o.ApplyT(func(v SourceContextResponse) GitSourceContextResponse { return v.Git }).(GitSourceContextResponseOutput)
}

// Labels with user defined metadata.
func (o SourceContextResponseOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v SourceContextResponse) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

type SourceContextResponsePtrOutput struct{ *pulumi.OutputState }

func (SourceContextResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SourceContextResponse)(nil)).Elem()
}

func (o SourceContextResponsePtrOutput) ToSourceContextResponsePtrOutput() SourceContextResponsePtrOutput {
	return o
}

func (o SourceContextResponsePtrOutput) ToSourceContextResponsePtrOutputWithContext(ctx context.Context) SourceContextResponsePtrOutput {
	return o
}

func (o SourceContextResponsePtrOutput) Elem() SourceContextResponseOutput {
	return o.ApplyT(func(v *SourceContextResponse) SourceContextResponse { return *v }).(SourceContextResponseOutput)
}

// A SourceContext referring to a revision in a Google Cloud Source Repo.
func (o SourceContextResponsePtrOutput) CloudRepo() CloudRepoSourceContextResponsePtrOutput {
	return o.ApplyT(func(v *SourceContextResponse) *CloudRepoSourceContextResponse {
		if v == nil {
			return nil
		}
		return &v.CloudRepo
	}).(CloudRepoSourceContextResponsePtrOutput)
}

// A SourceContext referring to a Gerrit project.
func (o SourceContextResponsePtrOutput) Gerrit() GerritSourceContextResponsePtrOutput {
	return o.ApplyT(func(v *SourceContextResponse) *GerritSourceContextResponse {
		if v == nil {
			return nil
		}
		return &v.Gerrit
	}).(GerritSourceContextResponsePtrOutput)
}

// A SourceContext referring to any third party Git repo (e.g., GitHub).
func (o SourceContextResponsePtrOutput) Git() GitSourceContextResponsePtrOutput {
	return o.ApplyT(func(v *SourceContextResponse) *GitSourceContextResponse {
		if v == nil {
			return nil
		}
		return &v.Git
	}).(GitSourceContextResponsePtrOutput)
}

// Labels with user defined metadata.
func (o SourceContextResponsePtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SourceContextResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

type SourceContextResponseArrayOutput struct{ *pulumi.OutputState }

func (SourceContextResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SourceContextResponse)(nil)).Elem()
}

func (o SourceContextResponseArrayOutput) ToSourceContextResponseArrayOutput() SourceContextResponseArrayOutput {
	return o
}

func (o SourceContextResponseArrayOutput) ToSourceContextResponseArrayOutputWithContext(ctx context.Context) SourceContextResponseArrayOutput {
	return o
}

func (o SourceContextResponseArrayOutput) Index(i pulumi.IntInput) SourceContextResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SourceContextResponse {
		return vs[0].([]SourceContextResponse)[vs[1].(int)]
	}).(SourceContextResponseOutput)
}

// Source describes the location of the source used for the build.
type SourceResponse struct {
	// If provided, some of the source code used for the build may be found in these locations, in the case where the source repository had multiple remotes or submodules. This list will not include the context specified in the context field.
	AdditionalContexts []SourceContextResponse `pulumi:"additionalContexts"`
	// If provided, the input binary artifacts for the build came from this location.
	ArtifactStorageSourceUri string `pulumi:"artifactStorageSourceUri"`
	// If provided, the source code used for the build came from this location.
	Context SourceContextResponse `pulumi:"context"`
	// Hash(es) of the build source, which can be used to verify that the original source integrity was maintained in the build. The keys to this map are file paths used as build source and the values contain the hash values for those files. If the build source came in a single package such as a gzipped tarfile (.tar.gz), the FileHash will be for the single path to that file.
	FileHashes map[string]string `pulumi:"fileHashes"`
}

// SourceResponseInput is an input type that accepts SourceResponseArgs and SourceResponseOutput values.
// You can construct a concrete instance of `SourceResponseInput` via:
//
//          SourceResponseArgs{...}
type SourceResponseInput interface {
	pulumi.Input

	ToSourceResponseOutput() SourceResponseOutput
	ToSourceResponseOutputWithContext(context.Context) SourceResponseOutput
}

// Source describes the location of the source used for the build.
type SourceResponseArgs struct {
	// If provided, some of the source code used for the build may be found in these locations, in the case where the source repository had multiple remotes or submodules. This list will not include the context specified in the context field.
	AdditionalContexts SourceContextResponseArrayInput `pulumi:"additionalContexts"`
	// If provided, the input binary artifacts for the build came from this location.
	ArtifactStorageSourceUri pulumi.StringInput `pulumi:"artifactStorageSourceUri"`
	// If provided, the source code used for the build came from this location.
	Context SourceContextResponseInput `pulumi:"context"`
	// Hash(es) of the build source, which can be used to verify that the original source integrity was maintained in the build. The keys to this map are file paths used as build source and the values contain the hash values for those files. If the build source came in a single package such as a gzipped tarfile (.tar.gz), the FileHash will be for the single path to that file.
	FileHashes pulumi.StringMapInput `pulumi:"fileHashes"`
}

func (SourceResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SourceResponse)(nil)).Elem()
}

func (i SourceResponseArgs) ToSourceResponseOutput() SourceResponseOutput {
	return i.ToSourceResponseOutputWithContext(context.Background())
}

func (i SourceResponseArgs) ToSourceResponseOutputWithContext(ctx context.Context) SourceResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceResponseOutput)
}

func (i SourceResponseArgs) ToSourceResponsePtrOutput() SourceResponsePtrOutput {
	return i.ToSourceResponsePtrOutputWithContext(context.Background())
}

func (i SourceResponseArgs) ToSourceResponsePtrOutputWithContext(ctx context.Context) SourceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceResponseOutput).ToSourceResponsePtrOutputWithContext(ctx)
}

// SourceResponsePtrInput is an input type that accepts SourceResponseArgs, SourceResponsePtr and SourceResponsePtrOutput values.
// You can construct a concrete instance of `SourceResponsePtrInput` via:
//
//          SourceResponseArgs{...}
//
//  or:
//
//          nil
type SourceResponsePtrInput interface {
	pulumi.Input

	ToSourceResponsePtrOutput() SourceResponsePtrOutput
	ToSourceResponsePtrOutputWithContext(context.Context) SourceResponsePtrOutput
}

type sourceResponsePtrType SourceResponseArgs

func SourceResponsePtr(v *SourceResponseArgs) SourceResponsePtrInput {
	return (*sourceResponsePtrType)(v)
}

func (*sourceResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SourceResponse)(nil)).Elem()
}

func (i *sourceResponsePtrType) ToSourceResponsePtrOutput() SourceResponsePtrOutput {
	return i.ToSourceResponsePtrOutputWithContext(context.Background())
}

func (i *sourceResponsePtrType) ToSourceResponsePtrOutputWithContext(ctx context.Context) SourceResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SourceResponsePtrOutput)
}

// Source describes the location of the source used for the build.
type SourceResponseOutput struct{ *pulumi.OutputState }

func (SourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SourceResponse)(nil)).Elem()
}

func (o SourceResponseOutput) ToSourceResponseOutput() SourceResponseOutput {
	return o
}

func (o SourceResponseOutput) ToSourceResponseOutputWithContext(ctx context.Context) SourceResponseOutput {
	return o
}

func (o SourceResponseOutput) ToSourceResponsePtrOutput() SourceResponsePtrOutput {
	return o.ToSourceResponsePtrOutputWithContext(context.Background())
}

func (o SourceResponseOutput) ToSourceResponsePtrOutputWithContext(ctx context.Context) SourceResponsePtrOutput {
	return o.ApplyT(func(v SourceResponse) *SourceResponse {
		return &v
	}).(SourceResponsePtrOutput)
}

// If provided, some of the source code used for the build may be found in these locations, in the case where the source repository had multiple remotes or submodules. This list will not include the context specified in the context field.
func (o SourceResponseOutput) AdditionalContexts() SourceContextResponseArrayOutput {
	return o.ApplyT(func(v SourceResponse) []SourceContextResponse { return v.AdditionalContexts }).(SourceContextResponseArrayOutput)
}

// If provided, the input binary artifacts for the build came from this location.
func (o SourceResponseOutput) ArtifactStorageSourceUri() pulumi.StringOutput {
	return o.ApplyT(func(v SourceResponse) string { return v.ArtifactStorageSourceUri }).(pulumi.StringOutput)
}

// If provided, the source code used for the build came from this location.
func (o SourceResponseOutput) Context() SourceContextResponseOutput {
	return o.ApplyT(func(v SourceResponse) SourceContextResponse { return v.Context }).(SourceContextResponseOutput)
}

// Hash(es) of the build source, which can be used to verify that the original source integrity was maintained in the build. The keys to this map are file paths used as build source and the values contain the hash values for those files. If the build source came in a single package such as a gzipped tarfile (.tar.gz), the FileHash will be for the single path to that file.
func (o SourceResponseOutput) FileHashes() pulumi.StringMapOutput {
	return o.ApplyT(func(v SourceResponse) map[string]string { return v.FileHashes }).(pulumi.StringMapOutput)
}

type SourceResponsePtrOutput struct{ *pulumi.OutputState }

func (SourceResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SourceResponse)(nil)).Elem()
}

func (o SourceResponsePtrOutput) ToSourceResponsePtrOutput() SourceResponsePtrOutput {
	return o
}

func (o SourceResponsePtrOutput) ToSourceResponsePtrOutputWithContext(ctx context.Context) SourceResponsePtrOutput {
	return o
}

func (o SourceResponsePtrOutput) Elem() SourceResponseOutput {
	return o.ApplyT(func(v *SourceResponse) SourceResponse { return *v }).(SourceResponseOutput)
}

// If provided, some of the source code used for the build may be found in these locations, in the case where the source repository had multiple remotes or submodules. This list will not include the context specified in the context field.
func (o SourceResponsePtrOutput) AdditionalContexts() SourceContextResponseArrayOutput {
	return o.ApplyT(func(v *SourceResponse) []SourceContextResponse {
		if v == nil {
			return nil
		}
		return v.AdditionalContexts
	}).(SourceContextResponseArrayOutput)
}

// If provided, the input binary artifacts for the build came from this location.
func (o SourceResponsePtrOutput) ArtifactStorageSourceUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SourceResponse) *string {
		if v == nil {
			return nil
		}
		return &v.ArtifactStorageSourceUri
	}).(pulumi.StringPtrOutput)
}

// If provided, the source code used for the build came from this location.
func (o SourceResponsePtrOutput) Context() SourceContextResponsePtrOutput {
	return o.ApplyT(func(v *SourceResponse) *SourceContextResponse {
		if v == nil {
			return nil
		}
		return &v.Context
	}).(SourceContextResponsePtrOutput)
}

// Hash(es) of the build source, which can be used to verify that the original source integrity was maintained in the build. The keys to this map are file paths used as build source and the values contain the hash values for those files. If the build source came in a single package such as a gzipped tarfile (.tar.gz), the FileHash will be for the single path to that file.
func (o SourceResponsePtrOutput) FileHashes() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SourceResponse) map[string]string {
		if v == nil {
			return nil
		}
		return v.FileHashes
	}).(pulumi.StringMapOutput)
}

// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type Status struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code *int `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details []map[string]string `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message *string `pulumi:"message"`
}

// StatusInput is an input type that accepts StatusArgs and StatusOutput values.
// You can construct a concrete instance of `StatusInput` via:
//
//          StatusArgs{...}
type StatusInput interface {
	pulumi.Input

	ToStatusOutput() StatusOutput
	ToStatusOutputWithContext(context.Context) StatusOutput
}

// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type StatusArgs struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code pulumi.IntPtrInput `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details pulumi.StringMapArrayInput `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message pulumi.StringPtrInput `pulumi:"message"`
}

func (StatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Status)(nil)).Elem()
}

func (i StatusArgs) ToStatusOutput() StatusOutput {
	return i.ToStatusOutputWithContext(context.Background())
}

func (i StatusArgs) ToStatusOutputWithContext(ctx context.Context) StatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusOutput)
}

func (i StatusArgs) ToStatusPtrOutput() StatusPtrOutput {
	return i.ToStatusPtrOutputWithContext(context.Background())
}

func (i StatusArgs) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusOutput).ToStatusPtrOutputWithContext(ctx)
}

// StatusPtrInput is an input type that accepts StatusArgs, StatusPtr and StatusPtrOutput values.
// You can construct a concrete instance of `StatusPtrInput` via:
//
//          StatusArgs{...}
//
//  or:
//
//          nil
type StatusPtrInput interface {
	pulumi.Input

	ToStatusPtrOutput() StatusPtrOutput
	ToStatusPtrOutputWithContext(context.Context) StatusPtrOutput
}

type statusPtrType StatusArgs

func StatusPtr(v *StatusArgs) StatusPtrInput {
	return (*statusPtrType)(v)
}

func (*statusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Status)(nil)).Elem()
}

func (i *statusPtrType) ToStatusPtrOutput() StatusPtrOutput {
	return i.ToStatusPtrOutputWithContext(context.Background())
}

func (i *statusPtrType) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusPtrOutput)
}

// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type StatusOutput struct{ *pulumi.OutputState }

func (StatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Status)(nil)).Elem()
}

func (o StatusOutput) ToStatusOutput() StatusOutput {
	return o
}

func (o StatusOutput) ToStatusOutputWithContext(ctx context.Context) StatusOutput {
	return o
}

func (o StatusOutput) ToStatusPtrOutput() StatusPtrOutput {
	return o.ToStatusPtrOutputWithContext(context.Background())
}

func (o StatusOutput) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return o.ApplyT(func(v Status) *Status {
		return &v
	}).(StatusPtrOutput)
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusOutput) Code() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Status) *int { return v.Code }).(pulumi.IntPtrOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusOutput) Details() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v Status) []map[string]string { return v.Details }).(pulumi.StringMapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Status) *string { return v.Message }).(pulumi.StringPtrOutput)
}

type StatusPtrOutput struct{ *pulumi.OutputState }

func (StatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Status)(nil)).Elem()
}

func (o StatusPtrOutput) ToStatusPtrOutput() StatusPtrOutput {
	return o
}

func (o StatusPtrOutput) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return o
}

func (o StatusPtrOutput) Elem() StatusOutput {
	return o.ApplyT(func(v *Status) Status { return *v }).(StatusOutput)
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusPtrOutput) Code() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Status) *int {
		if v == nil {
			return nil
		}
		return v.Code
	}).(pulumi.IntPtrOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusPtrOutput) Details() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v *Status) []map[string]string {
		if v == nil {
			return nil
		}
		return v.Details
	}).(pulumi.StringMapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusPtrOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Status) *string {
		if v == nil {
			return nil
		}
		return v.Message
	}).(pulumi.StringPtrOutput)
}

// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type StatusResponse struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code int `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details []map[string]string `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message string `pulumi:"message"`
}

// StatusResponseInput is an input type that accepts StatusResponseArgs and StatusResponseOutput values.
// You can construct a concrete instance of `StatusResponseInput` via:
//
//          StatusResponseArgs{...}
type StatusResponseInput interface {
	pulumi.Input

	ToStatusResponseOutput() StatusResponseOutput
	ToStatusResponseOutputWithContext(context.Context) StatusResponseOutput
}

// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type StatusResponseArgs struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code pulumi.IntInput `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details pulumi.StringMapArrayInput `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message pulumi.StringInput `pulumi:"message"`
}

func (StatusResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatusResponse)(nil)).Elem()
}

func (i StatusResponseArgs) ToStatusResponseOutput() StatusResponseOutput {
	return i.ToStatusResponseOutputWithContext(context.Background())
}

func (i StatusResponseArgs) ToStatusResponseOutputWithContext(ctx context.Context) StatusResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusResponseOutput)
}

func (i StatusResponseArgs) ToStatusResponsePtrOutput() StatusResponsePtrOutput {
	return i.ToStatusResponsePtrOutputWithContext(context.Background())
}

func (i StatusResponseArgs) ToStatusResponsePtrOutputWithContext(ctx context.Context) StatusResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusResponseOutput).ToStatusResponsePtrOutputWithContext(ctx)
}

// StatusResponsePtrInput is an input type that accepts StatusResponseArgs, StatusResponsePtr and StatusResponsePtrOutput values.
// You can construct a concrete instance of `StatusResponsePtrInput` via:
//
//          StatusResponseArgs{...}
//
//  or:
//
//          nil
type StatusResponsePtrInput interface {
	pulumi.Input

	ToStatusResponsePtrOutput() StatusResponsePtrOutput
	ToStatusResponsePtrOutputWithContext(context.Context) StatusResponsePtrOutput
}

type statusResponsePtrType StatusResponseArgs

func StatusResponsePtr(v *StatusResponseArgs) StatusResponsePtrInput {
	return (*statusResponsePtrType)(v)
}

func (*statusResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StatusResponse)(nil)).Elem()
}

func (i *statusResponsePtrType) ToStatusResponsePtrOutput() StatusResponsePtrOutput {
	return i.ToStatusResponsePtrOutputWithContext(context.Background())
}

func (i *statusResponsePtrType) ToStatusResponsePtrOutputWithContext(ctx context.Context) StatusResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusResponsePtrOutput)
}

// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
type StatusResponseOutput struct{ *pulumi.OutputState }

func (StatusResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatusResponse)(nil)).Elem()
}

func (o StatusResponseOutput) ToStatusResponseOutput() StatusResponseOutput {
	return o
}

func (o StatusResponseOutput) ToStatusResponseOutputWithContext(ctx context.Context) StatusResponseOutput {
	return o
}

func (o StatusResponseOutput) ToStatusResponsePtrOutput() StatusResponsePtrOutput {
	return o.ToStatusResponsePtrOutputWithContext(context.Background())
}

func (o StatusResponseOutput) ToStatusResponsePtrOutputWithContext(ctx context.Context) StatusResponsePtrOutput {
	return o.ApplyT(func(v StatusResponse) *StatusResponse {
		return &v
	}).(StatusResponsePtrOutput)
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusResponseOutput) Code() pulumi.IntOutput {
	return o.ApplyT(func(v StatusResponse) int { return v.Code }).(pulumi.IntOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusResponseOutput) Details() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v StatusResponse) []map[string]string { return v.Details }).(pulumi.StringMapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusResponseOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v StatusResponse) string { return v.Message }).(pulumi.StringOutput)
}

type StatusResponsePtrOutput struct{ *pulumi.OutputState }

func (StatusResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StatusResponse)(nil)).Elem()
}

func (o StatusResponsePtrOutput) ToStatusResponsePtrOutput() StatusResponsePtrOutput {
	return o
}

func (o StatusResponsePtrOutput) ToStatusResponsePtrOutputWithContext(ctx context.Context) StatusResponsePtrOutput {
	return o
}

func (o StatusResponsePtrOutput) Elem() StatusResponseOutput {
	return o.ApplyT(func(v *StatusResponse) StatusResponse { return *v }).(StatusResponseOutput)
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusResponsePtrOutput) Code() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatusResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Code
	}).(pulumi.IntPtrOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusResponsePtrOutput) Details() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v *StatusResponse) []map[string]string {
		if v == nil {
			return nil
		}
		return v.Details
	}).(pulumi.StringMapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusResponsePtrOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StatusResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Message
	}).(pulumi.StringPtrOutput)
}

// Version contains structured information about the version of a package.
type Version struct {
	// Used to correct mistakes in the version numbering scheme.
	Epoch *int `pulumi:"epoch"`
	// Whether this version is specifying part of an inclusive range. Grafeas does not have the capability to specify version ranges; instead we have fields that specify start version and end versions. At times this is insufficient - we also need to specify whether the version is included in the range or is excluded from the range. This boolean is expected to be set to true when the version is included in a range.
	Inclusive *bool `pulumi:"inclusive"`
	// Distinguishes between sentinel MIN/MAX versions and normal versions.
	Kind VersionKind `pulumi:"kind"`
	// Required only when version kind is NORMAL. The main part of the version name.
	Name *string `pulumi:"name"`
	// The iteration of the package build from the above version.
	Revision *string `pulumi:"revision"`
}

// VersionInput is an input type that accepts VersionArgs and VersionOutput values.
// You can construct a concrete instance of `VersionInput` via:
//
//          VersionArgs{...}
type VersionInput interface {
	pulumi.Input

	ToVersionOutput() VersionOutput
	ToVersionOutputWithContext(context.Context) VersionOutput
}

// Version contains structured information about the version of a package.
type VersionArgs struct {
	// Used to correct mistakes in the version numbering scheme.
	Epoch pulumi.IntPtrInput `pulumi:"epoch"`
	// Whether this version is specifying part of an inclusive range. Grafeas does not have the capability to specify version ranges; instead we have fields that specify start version and end versions. At times this is insufficient - we also need to specify whether the version is included in the range or is excluded from the range. This boolean is expected to be set to true when the version is included in a range.
	Inclusive pulumi.BoolPtrInput `pulumi:"inclusive"`
	// Distinguishes between sentinel MIN/MAX versions and normal versions.
	Kind VersionKindInput `pulumi:"kind"`
	// Required only when version kind is NORMAL. The main part of the version name.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The iteration of the package build from the above version.
	Revision pulumi.StringPtrInput `pulumi:"revision"`
}

func (VersionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Version)(nil)).Elem()
}

func (i VersionArgs) ToVersionOutput() VersionOutput {
	return i.ToVersionOutputWithContext(context.Background())
}

func (i VersionArgs) ToVersionOutputWithContext(ctx context.Context) VersionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VersionOutput)
}

func (i VersionArgs) ToVersionPtrOutput() VersionPtrOutput {
	return i.ToVersionPtrOutputWithContext(context.Background())
}

func (i VersionArgs) ToVersionPtrOutputWithContext(ctx context.Context) VersionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VersionOutput).ToVersionPtrOutputWithContext(ctx)
}

// VersionPtrInput is an input type that accepts VersionArgs, VersionPtr and VersionPtrOutput values.
// You can construct a concrete instance of `VersionPtrInput` via:
//
//          VersionArgs{...}
//
//  or:
//
//          nil
type VersionPtrInput interface {
	pulumi.Input

	ToVersionPtrOutput() VersionPtrOutput
	ToVersionPtrOutputWithContext(context.Context) VersionPtrOutput
}

type versionPtrType VersionArgs

func VersionPtr(v *VersionArgs) VersionPtrInput {
	return (*versionPtrType)(v)
}

func (*versionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Version)(nil)).Elem()
}

func (i *versionPtrType) ToVersionPtrOutput() VersionPtrOutput {
	return i.ToVersionPtrOutputWithContext(context.Background())
}

func (i *versionPtrType) ToVersionPtrOutputWithContext(ctx context.Context) VersionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VersionPtrOutput)
}

// Version contains structured information about the version of a package.
type VersionOutput struct{ *pulumi.OutputState }

func (VersionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Version)(nil)).Elem()
}

func (o VersionOutput) ToVersionOutput() VersionOutput {
	return o
}

func (o VersionOutput) ToVersionOutputWithContext(ctx context.Context) VersionOutput {
	return o
}

func (o VersionOutput) ToVersionPtrOutput() VersionPtrOutput {
	return o.ToVersionPtrOutputWithContext(context.Background())
}

func (o VersionOutput) ToVersionPtrOutputWithContext(ctx context.Context) VersionPtrOutput {
	return o.ApplyT(func(v Version) *Version {
		return &v
	}).(VersionPtrOutput)
}

// Used to correct mistakes in the version numbering scheme.
func (o VersionOutput) Epoch() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Version) *int { return v.Epoch }).(pulumi.IntPtrOutput)
}

// Whether this version is specifying part of an inclusive range. Grafeas does not have the capability to specify version ranges; instead we have fields that specify start version and end versions. At times this is insufficient - we also need to specify whether the version is included in the range or is excluded from the range. This boolean is expected to be set to true when the version is included in a range.
func (o VersionOutput) Inclusive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Version) *bool { return v.Inclusive }).(pulumi.BoolPtrOutput)
}

// Distinguishes between sentinel MIN/MAX versions and normal versions.
func (o VersionOutput) Kind() VersionKindOutput {
	return o.ApplyT(func(v Version) VersionKind { return v.Kind }).(VersionKindOutput)
}

// Required only when version kind is NORMAL. The main part of the version name.
func (o VersionOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Version) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The iteration of the package build from the above version.
func (o VersionOutput) Revision() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Version) *string { return v.Revision }).(pulumi.StringPtrOutput)
}

type VersionPtrOutput struct{ *pulumi.OutputState }

func (VersionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Version)(nil)).Elem()
}

func (o VersionPtrOutput) ToVersionPtrOutput() VersionPtrOutput {
	return o
}

func (o VersionPtrOutput) ToVersionPtrOutputWithContext(ctx context.Context) VersionPtrOutput {
	return o
}

func (o VersionPtrOutput) Elem() VersionOutput {
	return o.ApplyT(func(v *Version) Version { return *v }).(VersionOutput)
}

// Used to correct mistakes in the version numbering scheme.
func (o VersionPtrOutput) Epoch() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Version) *int {
		if v == nil {
			return nil
		}
		return v.Epoch
	}).(pulumi.IntPtrOutput)
}

// Whether this version is specifying part of an inclusive range. Grafeas does not have the capability to specify version ranges; instead we have fields that specify start version and end versions. At times this is insufficient - we also need to specify whether the version is included in the range or is excluded from the range. This boolean is expected to be set to true when the version is included in a range.
func (o VersionPtrOutput) Inclusive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Version) *bool {
		if v == nil {
			return nil
		}
		return v.Inclusive
	}).(pulumi.BoolPtrOutput)
}

// Distinguishes between sentinel MIN/MAX versions and normal versions.
func (o VersionPtrOutput) Kind() VersionKindPtrOutput {
	return o.ApplyT(func(v *Version) *VersionKind {
		if v == nil {
			return nil
		}
		return &v.Kind
	}).(VersionKindPtrOutput)
}

// Required only when version kind is NORMAL. The main part of the version name.
func (o VersionPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Version) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// The iteration of the package build from the above version.
func (o VersionPtrOutput) Revision() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Version) *string {
		if v == nil {
			return nil
		}
		return v.Revision
	}).(pulumi.StringPtrOutput)
}

// Version contains structured information about the version of a package.
type VersionResponse struct {
	// Used to correct mistakes in the version numbering scheme.
	Epoch int `pulumi:"epoch"`
	// Whether this version is specifying part of an inclusive range. Grafeas does not have the capability to specify version ranges; instead we have fields that specify start version and end versions. At times this is insufficient - we also need to specify whether the version is included in the range or is excluded from the range. This boolean is expected to be set to true when the version is included in a range.
	Inclusive bool `pulumi:"inclusive"`
	// Distinguishes between sentinel MIN/MAX versions and normal versions.
	Kind string `pulumi:"kind"`
	// Required only when version kind is NORMAL. The main part of the version name.
	Name string `pulumi:"name"`
	// The iteration of the package build from the above version.
	Revision string `pulumi:"revision"`
}

// VersionResponseInput is an input type that accepts VersionResponseArgs and VersionResponseOutput values.
// You can construct a concrete instance of `VersionResponseInput` via:
//
//          VersionResponseArgs{...}
type VersionResponseInput interface {
	pulumi.Input

	ToVersionResponseOutput() VersionResponseOutput
	ToVersionResponseOutputWithContext(context.Context) VersionResponseOutput
}

// Version contains structured information about the version of a package.
type VersionResponseArgs struct {
	// Used to correct mistakes in the version numbering scheme.
	Epoch pulumi.IntInput `pulumi:"epoch"`
	// Whether this version is specifying part of an inclusive range. Grafeas does not have the capability to specify version ranges; instead we have fields that specify start version and end versions. At times this is insufficient - we also need to specify whether the version is included in the range or is excluded from the range. This boolean is expected to be set to true when the version is included in a range.
	Inclusive pulumi.BoolInput `pulumi:"inclusive"`
	// Distinguishes between sentinel MIN/MAX versions and normal versions.
	Kind pulumi.StringInput `pulumi:"kind"`
	// Required only when version kind is NORMAL. The main part of the version name.
	Name pulumi.StringInput `pulumi:"name"`
	// The iteration of the package build from the above version.
	Revision pulumi.StringInput `pulumi:"revision"`
}

func (VersionResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VersionResponse)(nil)).Elem()
}

func (i VersionResponseArgs) ToVersionResponseOutput() VersionResponseOutput {
	return i.ToVersionResponseOutputWithContext(context.Background())
}

func (i VersionResponseArgs) ToVersionResponseOutputWithContext(ctx context.Context) VersionResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VersionResponseOutput)
}

// Version contains structured information about the version of a package.
type VersionResponseOutput struct{ *pulumi.OutputState }

func (VersionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VersionResponse)(nil)).Elem()
}

func (o VersionResponseOutput) ToVersionResponseOutput() VersionResponseOutput {
	return o
}

func (o VersionResponseOutput) ToVersionResponseOutputWithContext(ctx context.Context) VersionResponseOutput {
	return o
}

// Used to correct mistakes in the version numbering scheme.
func (o VersionResponseOutput) Epoch() pulumi.IntOutput {
	return o.ApplyT(func(v VersionResponse) int { return v.Epoch }).(pulumi.IntOutput)
}

// Whether this version is specifying part of an inclusive range. Grafeas does not have the capability to specify version ranges; instead we have fields that specify start version and end versions. At times this is insufficient - we also need to specify whether the version is included in the range or is excluded from the range. This boolean is expected to be set to true when the version is included in a range.
func (o VersionResponseOutput) Inclusive() pulumi.BoolOutput {
	return o.ApplyT(func(v VersionResponse) bool { return v.Inclusive }).(pulumi.BoolOutput)
}

// Distinguishes between sentinel MIN/MAX versions and normal versions.
func (o VersionResponseOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v VersionResponse) string { return v.Kind }).(pulumi.StringOutput)
}

// Required only when version kind is NORMAL. The main part of the version name.
func (o VersionResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v VersionResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The iteration of the package build from the above version.
func (o VersionResponseOutput) Revision() pulumi.StringOutput {
	return o.ApplyT(func(v VersionResponse) string { return v.Revision }).(pulumi.StringOutput)
}

// Vulnerability provides metadata about a security vulnerability in a Note.
type Vulnerability struct {
	// The CVSS score for this vulnerability.
	CvssScore *float64 `pulumi:"cvssScore"`
	// The full description of the CVSSv3.
	CvssV3 *CVSSv3 `pulumi:"cvssV3"`
	// All information about the package to specifically identify this vulnerability. One entry per (version range and cpe_uri) the package vulnerability has manifested in.
	Details []Detail `pulumi:"details"`
	// Note provider assigned impact of the vulnerability.
	Severity *VulnerabilitySeverity `pulumi:"severity"`
	// The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.
	SourceUpdateTime *string `pulumi:"sourceUpdateTime"`
	// Windows details get their own format because the information format and model don't match a normal detail. Specifically Windows updates are done as patches, thus Windows vulnerabilities really are a missing package, rather than a package being at an incorrect version.
	WindowsDetails []WindowsDetail `pulumi:"windowsDetails"`
}

// VulnerabilityInput is an input type that accepts VulnerabilityArgs and VulnerabilityOutput values.
// You can construct a concrete instance of `VulnerabilityInput` via:
//
//          VulnerabilityArgs{...}
type VulnerabilityInput interface {
	pulumi.Input

	ToVulnerabilityOutput() VulnerabilityOutput
	ToVulnerabilityOutputWithContext(context.Context) VulnerabilityOutput
}

// Vulnerability provides metadata about a security vulnerability in a Note.
type VulnerabilityArgs struct {
	// The CVSS score for this vulnerability.
	CvssScore pulumi.Float64PtrInput `pulumi:"cvssScore"`
	// The full description of the CVSSv3.
	CvssV3 CVSSv3PtrInput `pulumi:"cvssV3"`
	// All information about the package to specifically identify this vulnerability. One entry per (version range and cpe_uri) the package vulnerability has manifested in.
	Details DetailArrayInput `pulumi:"details"`
	// Note provider assigned impact of the vulnerability.
	Severity VulnerabilitySeverityPtrInput `pulumi:"severity"`
	// The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.
	SourceUpdateTime pulumi.StringPtrInput `pulumi:"sourceUpdateTime"`
	// Windows details get their own format because the information format and model don't match a normal detail. Specifically Windows updates are done as patches, thus Windows vulnerabilities really are a missing package, rather than a package being at an incorrect version.
	WindowsDetails WindowsDetailArrayInput `pulumi:"windowsDetails"`
}

func (VulnerabilityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Vulnerability)(nil)).Elem()
}

func (i VulnerabilityArgs) ToVulnerabilityOutput() VulnerabilityOutput {
	return i.ToVulnerabilityOutputWithContext(context.Background())
}

func (i VulnerabilityArgs) ToVulnerabilityOutputWithContext(ctx context.Context) VulnerabilityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VulnerabilityOutput)
}

func (i VulnerabilityArgs) ToVulnerabilityPtrOutput() VulnerabilityPtrOutput {
	return i.ToVulnerabilityPtrOutputWithContext(context.Background())
}

func (i VulnerabilityArgs) ToVulnerabilityPtrOutputWithContext(ctx context.Context) VulnerabilityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VulnerabilityOutput).ToVulnerabilityPtrOutputWithContext(ctx)
}

// VulnerabilityPtrInput is an input type that accepts VulnerabilityArgs, VulnerabilityPtr and VulnerabilityPtrOutput values.
// You can construct a concrete instance of `VulnerabilityPtrInput` via:
//
//          VulnerabilityArgs{...}
//
//  or:
//
//          nil
type VulnerabilityPtrInput interface {
	pulumi.Input

	ToVulnerabilityPtrOutput() VulnerabilityPtrOutput
	ToVulnerabilityPtrOutputWithContext(context.Context) VulnerabilityPtrOutput
}

type vulnerabilityPtrType VulnerabilityArgs

func VulnerabilityPtr(v *VulnerabilityArgs) VulnerabilityPtrInput {
	return (*vulnerabilityPtrType)(v)
}

func (*vulnerabilityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Vulnerability)(nil)).Elem()
}

func (i *vulnerabilityPtrType) ToVulnerabilityPtrOutput() VulnerabilityPtrOutput {
	return i.ToVulnerabilityPtrOutputWithContext(context.Background())
}

func (i *vulnerabilityPtrType) ToVulnerabilityPtrOutputWithContext(ctx context.Context) VulnerabilityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VulnerabilityPtrOutput)
}

// Vulnerability provides metadata about a security vulnerability in a Note.
type VulnerabilityOutput struct{ *pulumi.OutputState }

func (VulnerabilityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Vulnerability)(nil)).Elem()
}

func (o VulnerabilityOutput) ToVulnerabilityOutput() VulnerabilityOutput {
	return o
}

func (o VulnerabilityOutput) ToVulnerabilityOutputWithContext(ctx context.Context) VulnerabilityOutput {
	return o
}

func (o VulnerabilityOutput) ToVulnerabilityPtrOutput() VulnerabilityPtrOutput {
	return o.ToVulnerabilityPtrOutputWithContext(context.Background())
}

func (o VulnerabilityOutput) ToVulnerabilityPtrOutputWithContext(ctx context.Context) VulnerabilityPtrOutput {
	return o.ApplyT(func(v Vulnerability) *Vulnerability {
		return &v
	}).(VulnerabilityPtrOutput)
}

// The CVSS score for this vulnerability.
func (o VulnerabilityOutput) CvssScore() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Vulnerability) *float64 { return v.CvssScore }).(pulumi.Float64PtrOutput)
}

// The full description of the CVSSv3.
func (o VulnerabilityOutput) CvssV3() CVSSv3PtrOutput {
	return o.ApplyT(func(v Vulnerability) *CVSSv3 { return v.CvssV3 }).(CVSSv3PtrOutput)
}

// All information about the package to specifically identify this vulnerability. One entry per (version range and cpe_uri) the package vulnerability has manifested in.
func (o VulnerabilityOutput) Details() DetailArrayOutput {
	return o.ApplyT(func(v Vulnerability) []Detail { return v.Details }).(DetailArrayOutput)
}

// Note provider assigned impact of the vulnerability.
func (o VulnerabilityOutput) Severity() VulnerabilitySeverityPtrOutput {
	return o.ApplyT(func(v Vulnerability) *VulnerabilitySeverity { return v.Severity }).(VulnerabilitySeverityPtrOutput)
}

// The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.
func (o VulnerabilityOutput) SourceUpdateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Vulnerability) *string { return v.SourceUpdateTime }).(pulumi.StringPtrOutput)
}

// Windows details get their own format because the information format and model don't match a normal detail. Specifically Windows updates are done as patches, thus Windows vulnerabilities really are a missing package, rather than a package being at an incorrect version.
func (o VulnerabilityOutput) WindowsDetails() WindowsDetailArrayOutput {
	return o.ApplyT(func(v Vulnerability) []WindowsDetail { return v.WindowsDetails }).(WindowsDetailArrayOutput)
}

type VulnerabilityPtrOutput struct{ *pulumi.OutputState }

func (VulnerabilityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Vulnerability)(nil)).Elem()
}

func (o VulnerabilityPtrOutput) ToVulnerabilityPtrOutput() VulnerabilityPtrOutput {
	return o
}

func (o VulnerabilityPtrOutput) ToVulnerabilityPtrOutputWithContext(ctx context.Context) VulnerabilityPtrOutput {
	return o
}

func (o VulnerabilityPtrOutput) Elem() VulnerabilityOutput {
	return o.ApplyT(func(v *Vulnerability) Vulnerability { return *v }).(VulnerabilityOutput)
}

// The CVSS score for this vulnerability.
func (o VulnerabilityPtrOutput) CvssScore() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Vulnerability) *float64 {
		if v == nil {
			return nil
		}
		return v.CvssScore
	}).(pulumi.Float64PtrOutput)
}

// The full description of the CVSSv3.
func (o VulnerabilityPtrOutput) CvssV3() CVSSv3PtrOutput {
	return o.ApplyT(func(v *Vulnerability) *CVSSv3 {
		if v == nil {
			return nil
		}
		return v.CvssV3
	}).(CVSSv3PtrOutput)
}

// All information about the package to specifically identify this vulnerability. One entry per (version range and cpe_uri) the package vulnerability has manifested in.
func (o VulnerabilityPtrOutput) Details() DetailArrayOutput {
	return o.ApplyT(func(v *Vulnerability) []Detail {
		if v == nil {
			return nil
		}
		return v.Details
	}).(DetailArrayOutput)
}

// Note provider assigned impact of the vulnerability.
func (o VulnerabilityPtrOutput) Severity() VulnerabilitySeverityPtrOutput {
	return o.ApplyT(func(v *Vulnerability) *VulnerabilitySeverity {
		if v == nil {
			return nil
		}
		return v.Severity
	}).(VulnerabilitySeverityPtrOutput)
}

// The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.
func (o VulnerabilityPtrOutput) SourceUpdateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Vulnerability) *string {
		if v == nil {
			return nil
		}
		return v.SourceUpdateTime
	}).(pulumi.StringPtrOutput)
}

// Windows details get their own format because the information format and model don't match a normal detail. Specifically Windows updates are done as patches, thus Windows vulnerabilities really are a missing package, rather than a package being at an incorrect version.
func (o VulnerabilityPtrOutput) WindowsDetails() WindowsDetailArrayOutput {
	return o.ApplyT(func(v *Vulnerability) []WindowsDetail {
		if v == nil {
			return nil
		}
		return v.WindowsDetails
	}).(WindowsDetailArrayOutput)
}

// The location of the vulnerability.
type VulnerabilityLocation struct {
	// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) format. Examples include distro or storage location for vulnerable jar.
	CpeUri string `pulumi:"cpeUri"`
	// The package being described.
	Package string `pulumi:"package"`
	// The version of the package being described.
	Version Version `pulumi:"version"`
}

// VulnerabilityLocationInput is an input type that accepts VulnerabilityLocationArgs and VulnerabilityLocationOutput values.
// You can construct a concrete instance of `VulnerabilityLocationInput` via:
//
//          VulnerabilityLocationArgs{...}
type VulnerabilityLocationInput interface {
	pulumi.Input

	ToVulnerabilityLocationOutput() VulnerabilityLocationOutput
	ToVulnerabilityLocationOutputWithContext(context.Context) VulnerabilityLocationOutput
}

// The location of the vulnerability.
type VulnerabilityLocationArgs struct {
	// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) format. Examples include distro or storage location for vulnerable jar.
	CpeUri pulumi.StringInput `pulumi:"cpeUri"`
	// The package being described.
	Package pulumi.StringInput `pulumi:"package"`
	// The version of the package being described.
	Version VersionInput `pulumi:"version"`
}

func (VulnerabilityLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VulnerabilityLocation)(nil)).Elem()
}

func (i VulnerabilityLocationArgs) ToVulnerabilityLocationOutput() VulnerabilityLocationOutput {
	return i.ToVulnerabilityLocationOutputWithContext(context.Background())
}

func (i VulnerabilityLocationArgs) ToVulnerabilityLocationOutputWithContext(ctx context.Context) VulnerabilityLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VulnerabilityLocationOutput)
}

func (i VulnerabilityLocationArgs) ToVulnerabilityLocationPtrOutput() VulnerabilityLocationPtrOutput {
	return i.ToVulnerabilityLocationPtrOutputWithContext(context.Background())
}

func (i VulnerabilityLocationArgs) ToVulnerabilityLocationPtrOutputWithContext(ctx context.Context) VulnerabilityLocationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VulnerabilityLocationOutput).ToVulnerabilityLocationPtrOutputWithContext(ctx)
}

// VulnerabilityLocationPtrInput is an input type that accepts VulnerabilityLocationArgs, VulnerabilityLocationPtr and VulnerabilityLocationPtrOutput values.
// You can construct a concrete instance of `VulnerabilityLocationPtrInput` via:
//
//          VulnerabilityLocationArgs{...}
//
//  or:
//
//          nil
type VulnerabilityLocationPtrInput interface {
	pulumi.Input

	ToVulnerabilityLocationPtrOutput() VulnerabilityLocationPtrOutput
	ToVulnerabilityLocationPtrOutputWithContext(context.Context) VulnerabilityLocationPtrOutput
}

type vulnerabilityLocationPtrType VulnerabilityLocationArgs

func VulnerabilityLocationPtr(v *VulnerabilityLocationArgs) VulnerabilityLocationPtrInput {
	return (*vulnerabilityLocationPtrType)(v)
}

func (*vulnerabilityLocationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VulnerabilityLocation)(nil)).Elem()
}

func (i *vulnerabilityLocationPtrType) ToVulnerabilityLocationPtrOutput() VulnerabilityLocationPtrOutput {
	return i.ToVulnerabilityLocationPtrOutputWithContext(context.Background())
}

func (i *vulnerabilityLocationPtrType) ToVulnerabilityLocationPtrOutputWithContext(ctx context.Context) VulnerabilityLocationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VulnerabilityLocationPtrOutput)
}

// The location of the vulnerability.
type VulnerabilityLocationOutput struct{ *pulumi.OutputState }

func (VulnerabilityLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VulnerabilityLocation)(nil)).Elem()
}

func (o VulnerabilityLocationOutput) ToVulnerabilityLocationOutput() VulnerabilityLocationOutput {
	return o
}

func (o VulnerabilityLocationOutput) ToVulnerabilityLocationOutputWithContext(ctx context.Context) VulnerabilityLocationOutput {
	return o
}

func (o VulnerabilityLocationOutput) ToVulnerabilityLocationPtrOutput() VulnerabilityLocationPtrOutput {
	return o.ToVulnerabilityLocationPtrOutputWithContext(context.Background())
}

func (o VulnerabilityLocationOutput) ToVulnerabilityLocationPtrOutputWithContext(ctx context.Context) VulnerabilityLocationPtrOutput {
	return o.ApplyT(func(v VulnerabilityLocation) *VulnerabilityLocation {
		return &v
	}).(VulnerabilityLocationPtrOutput)
}

// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) format. Examples include distro or storage location for vulnerable jar.
func (o VulnerabilityLocationOutput) CpeUri() pulumi.StringOutput {
	return o.ApplyT(func(v VulnerabilityLocation) string { return v.CpeUri }).(pulumi.StringOutput)
}

// The package being described.
func (o VulnerabilityLocationOutput) Package() pulumi.StringOutput {
	return o.ApplyT(func(v VulnerabilityLocation) string { return v.Package }).(pulumi.StringOutput)
}

// The version of the package being described.
func (o VulnerabilityLocationOutput) Version() VersionOutput {
	return o.ApplyT(func(v VulnerabilityLocation) Version { return v.Version }).(VersionOutput)
}

type VulnerabilityLocationPtrOutput struct{ *pulumi.OutputState }

func (VulnerabilityLocationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VulnerabilityLocation)(nil)).Elem()
}

func (o VulnerabilityLocationPtrOutput) ToVulnerabilityLocationPtrOutput() VulnerabilityLocationPtrOutput {
	return o
}

func (o VulnerabilityLocationPtrOutput) ToVulnerabilityLocationPtrOutputWithContext(ctx context.Context) VulnerabilityLocationPtrOutput {
	return o
}

func (o VulnerabilityLocationPtrOutput) Elem() VulnerabilityLocationOutput {
	return o.ApplyT(func(v *VulnerabilityLocation) VulnerabilityLocation { return *v }).(VulnerabilityLocationOutput)
}

// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) format. Examples include distro or storage location for vulnerable jar.
func (o VulnerabilityLocationPtrOutput) CpeUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VulnerabilityLocation) *string {
		if v == nil {
			return nil
		}
		return &v.CpeUri
	}).(pulumi.StringPtrOutput)
}

// The package being described.
func (o VulnerabilityLocationPtrOutput) Package() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VulnerabilityLocation) *string {
		if v == nil {
			return nil
		}
		return &v.Package
	}).(pulumi.StringPtrOutput)
}

// The version of the package being described.
func (o VulnerabilityLocationPtrOutput) Version() VersionPtrOutput {
	return o.ApplyT(func(v *VulnerabilityLocation) *Version {
		if v == nil {
			return nil
		}
		return &v.Version
	}).(VersionPtrOutput)
}

// The location of the vulnerability.
type VulnerabilityLocationResponse struct {
	// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) format. Examples include distro or storage location for vulnerable jar.
	CpeUri string `pulumi:"cpeUri"`
	// The package being described.
	Package string `pulumi:"package"`
	// The version of the package being described.
	Version VersionResponse `pulumi:"version"`
}

// VulnerabilityLocationResponseInput is an input type that accepts VulnerabilityLocationResponseArgs and VulnerabilityLocationResponseOutput values.
// You can construct a concrete instance of `VulnerabilityLocationResponseInput` via:
//
//          VulnerabilityLocationResponseArgs{...}
type VulnerabilityLocationResponseInput interface {
	pulumi.Input

	ToVulnerabilityLocationResponseOutput() VulnerabilityLocationResponseOutput
	ToVulnerabilityLocationResponseOutputWithContext(context.Context) VulnerabilityLocationResponseOutput
}

// The location of the vulnerability.
type VulnerabilityLocationResponseArgs struct {
	// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) format. Examples include distro or storage location for vulnerable jar.
	CpeUri pulumi.StringInput `pulumi:"cpeUri"`
	// The package being described.
	Package pulumi.StringInput `pulumi:"package"`
	// The version of the package being described.
	Version VersionResponseInput `pulumi:"version"`
}

func (VulnerabilityLocationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VulnerabilityLocationResponse)(nil)).Elem()
}

func (i VulnerabilityLocationResponseArgs) ToVulnerabilityLocationResponseOutput() VulnerabilityLocationResponseOutput {
	return i.ToVulnerabilityLocationResponseOutputWithContext(context.Background())
}

func (i VulnerabilityLocationResponseArgs) ToVulnerabilityLocationResponseOutputWithContext(ctx context.Context) VulnerabilityLocationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VulnerabilityLocationResponseOutput)
}

// The location of the vulnerability.
type VulnerabilityLocationResponseOutput struct{ *pulumi.OutputState }

func (VulnerabilityLocationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VulnerabilityLocationResponse)(nil)).Elem()
}

func (o VulnerabilityLocationResponseOutput) ToVulnerabilityLocationResponseOutput() VulnerabilityLocationResponseOutput {
	return o
}

func (o VulnerabilityLocationResponseOutput) ToVulnerabilityLocationResponseOutputWithContext(ctx context.Context) VulnerabilityLocationResponseOutput {
	return o
}

// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) format. Examples include distro or storage location for vulnerable jar.
func (o VulnerabilityLocationResponseOutput) CpeUri() pulumi.StringOutput {
	return o.ApplyT(func(v VulnerabilityLocationResponse) string { return v.CpeUri }).(pulumi.StringOutput)
}

// The package being described.
func (o VulnerabilityLocationResponseOutput) Package() pulumi.StringOutput {
	return o.ApplyT(func(v VulnerabilityLocationResponse) string { return v.Package }).(pulumi.StringOutput)
}

// The version of the package being described.
func (o VulnerabilityLocationResponseOutput) Version() VersionResponseOutput {
	return o.ApplyT(func(v VulnerabilityLocationResponse) VersionResponse { return v.Version }).(VersionResponseOutput)
}

// Vulnerability provides metadata about a security vulnerability in a Note.
type VulnerabilityResponse struct {
	// The CVSS score for this vulnerability.
	CvssScore float64 `pulumi:"cvssScore"`
	// The full description of the CVSSv3.
	CvssV3 CVSSv3Response `pulumi:"cvssV3"`
	// All information about the package to specifically identify this vulnerability. One entry per (version range and cpe_uri) the package vulnerability has manifested in.
	Details []DetailResponse `pulumi:"details"`
	// Note provider assigned impact of the vulnerability.
	Severity string `pulumi:"severity"`
	// The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.
	SourceUpdateTime string `pulumi:"sourceUpdateTime"`
	// Windows details get their own format because the information format and model don't match a normal detail. Specifically Windows updates are done as patches, thus Windows vulnerabilities really are a missing package, rather than a package being at an incorrect version.
	WindowsDetails []WindowsDetailResponse `pulumi:"windowsDetails"`
}

// VulnerabilityResponseInput is an input type that accepts VulnerabilityResponseArgs and VulnerabilityResponseOutput values.
// You can construct a concrete instance of `VulnerabilityResponseInput` via:
//
//          VulnerabilityResponseArgs{...}
type VulnerabilityResponseInput interface {
	pulumi.Input

	ToVulnerabilityResponseOutput() VulnerabilityResponseOutput
	ToVulnerabilityResponseOutputWithContext(context.Context) VulnerabilityResponseOutput
}

// Vulnerability provides metadata about a security vulnerability in a Note.
type VulnerabilityResponseArgs struct {
	// The CVSS score for this vulnerability.
	CvssScore pulumi.Float64Input `pulumi:"cvssScore"`
	// The full description of the CVSSv3.
	CvssV3 CVSSv3ResponseInput `pulumi:"cvssV3"`
	// All information about the package to specifically identify this vulnerability. One entry per (version range and cpe_uri) the package vulnerability has manifested in.
	Details DetailResponseArrayInput `pulumi:"details"`
	// Note provider assigned impact of the vulnerability.
	Severity pulumi.StringInput `pulumi:"severity"`
	// The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.
	SourceUpdateTime pulumi.StringInput `pulumi:"sourceUpdateTime"`
	// Windows details get their own format because the information format and model don't match a normal detail. Specifically Windows updates are done as patches, thus Windows vulnerabilities really are a missing package, rather than a package being at an incorrect version.
	WindowsDetails WindowsDetailResponseArrayInput `pulumi:"windowsDetails"`
}

func (VulnerabilityResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VulnerabilityResponse)(nil)).Elem()
}

func (i VulnerabilityResponseArgs) ToVulnerabilityResponseOutput() VulnerabilityResponseOutput {
	return i.ToVulnerabilityResponseOutputWithContext(context.Background())
}

func (i VulnerabilityResponseArgs) ToVulnerabilityResponseOutputWithContext(ctx context.Context) VulnerabilityResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VulnerabilityResponseOutput)
}

func (i VulnerabilityResponseArgs) ToVulnerabilityResponsePtrOutput() VulnerabilityResponsePtrOutput {
	return i.ToVulnerabilityResponsePtrOutputWithContext(context.Background())
}

func (i VulnerabilityResponseArgs) ToVulnerabilityResponsePtrOutputWithContext(ctx context.Context) VulnerabilityResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VulnerabilityResponseOutput).ToVulnerabilityResponsePtrOutputWithContext(ctx)
}

// VulnerabilityResponsePtrInput is an input type that accepts VulnerabilityResponseArgs, VulnerabilityResponsePtr and VulnerabilityResponsePtrOutput values.
// You can construct a concrete instance of `VulnerabilityResponsePtrInput` via:
//
//          VulnerabilityResponseArgs{...}
//
//  or:
//
//          nil
type VulnerabilityResponsePtrInput interface {
	pulumi.Input

	ToVulnerabilityResponsePtrOutput() VulnerabilityResponsePtrOutput
	ToVulnerabilityResponsePtrOutputWithContext(context.Context) VulnerabilityResponsePtrOutput
}

type vulnerabilityResponsePtrType VulnerabilityResponseArgs

func VulnerabilityResponsePtr(v *VulnerabilityResponseArgs) VulnerabilityResponsePtrInput {
	return (*vulnerabilityResponsePtrType)(v)
}

func (*vulnerabilityResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VulnerabilityResponse)(nil)).Elem()
}

func (i *vulnerabilityResponsePtrType) ToVulnerabilityResponsePtrOutput() VulnerabilityResponsePtrOutput {
	return i.ToVulnerabilityResponsePtrOutputWithContext(context.Background())
}

func (i *vulnerabilityResponsePtrType) ToVulnerabilityResponsePtrOutputWithContext(ctx context.Context) VulnerabilityResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VulnerabilityResponsePtrOutput)
}

// Vulnerability provides metadata about a security vulnerability in a Note.
type VulnerabilityResponseOutput struct{ *pulumi.OutputState }

func (VulnerabilityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VulnerabilityResponse)(nil)).Elem()
}

func (o VulnerabilityResponseOutput) ToVulnerabilityResponseOutput() VulnerabilityResponseOutput {
	return o
}

func (o VulnerabilityResponseOutput) ToVulnerabilityResponseOutputWithContext(ctx context.Context) VulnerabilityResponseOutput {
	return o
}

func (o VulnerabilityResponseOutput) ToVulnerabilityResponsePtrOutput() VulnerabilityResponsePtrOutput {
	return o.ToVulnerabilityResponsePtrOutputWithContext(context.Background())
}

func (o VulnerabilityResponseOutput) ToVulnerabilityResponsePtrOutputWithContext(ctx context.Context) VulnerabilityResponsePtrOutput {
	return o.ApplyT(func(v VulnerabilityResponse) *VulnerabilityResponse {
		return &v
	}).(VulnerabilityResponsePtrOutput)
}

// The CVSS score for this vulnerability.
func (o VulnerabilityResponseOutput) CvssScore() pulumi.Float64Output {
	return o.ApplyT(func(v VulnerabilityResponse) float64 { return v.CvssScore }).(pulumi.Float64Output)
}

// The full description of the CVSSv3.
func (o VulnerabilityResponseOutput) CvssV3() CVSSv3ResponseOutput {
	return o.ApplyT(func(v VulnerabilityResponse) CVSSv3Response { return v.CvssV3 }).(CVSSv3ResponseOutput)
}

// All information about the package to specifically identify this vulnerability. One entry per (version range and cpe_uri) the package vulnerability has manifested in.
func (o VulnerabilityResponseOutput) Details() DetailResponseArrayOutput {
	return o.ApplyT(func(v VulnerabilityResponse) []DetailResponse { return v.Details }).(DetailResponseArrayOutput)
}

// Note provider assigned impact of the vulnerability.
func (o VulnerabilityResponseOutput) Severity() pulumi.StringOutput {
	return o.ApplyT(func(v VulnerabilityResponse) string { return v.Severity }).(pulumi.StringOutput)
}

// The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.
func (o VulnerabilityResponseOutput) SourceUpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v VulnerabilityResponse) string { return v.SourceUpdateTime }).(pulumi.StringOutput)
}

// Windows details get their own format because the information format and model don't match a normal detail. Specifically Windows updates are done as patches, thus Windows vulnerabilities really are a missing package, rather than a package being at an incorrect version.
func (o VulnerabilityResponseOutput) WindowsDetails() WindowsDetailResponseArrayOutput {
	return o.ApplyT(func(v VulnerabilityResponse) []WindowsDetailResponse { return v.WindowsDetails }).(WindowsDetailResponseArrayOutput)
}

type VulnerabilityResponsePtrOutput struct{ *pulumi.OutputState }

func (VulnerabilityResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VulnerabilityResponse)(nil)).Elem()
}

func (o VulnerabilityResponsePtrOutput) ToVulnerabilityResponsePtrOutput() VulnerabilityResponsePtrOutput {
	return o
}

func (o VulnerabilityResponsePtrOutput) ToVulnerabilityResponsePtrOutputWithContext(ctx context.Context) VulnerabilityResponsePtrOutput {
	return o
}

func (o VulnerabilityResponsePtrOutput) Elem() VulnerabilityResponseOutput {
	return o.ApplyT(func(v *VulnerabilityResponse) VulnerabilityResponse { return *v }).(VulnerabilityResponseOutput)
}

// The CVSS score for this vulnerability.
func (o VulnerabilityResponsePtrOutput) CvssScore() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *VulnerabilityResponse) *float64 {
		if v == nil {
			return nil
		}
		return &v.CvssScore
	}).(pulumi.Float64PtrOutput)
}

// The full description of the CVSSv3.
func (o VulnerabilityResponsePtrOutput) CvssV3() CVSSv3ResponsePtrOutput {
	return o.ApplyT(func(v *VulnerabilityResponse) *CVSSv3Response {
		if v == nil {
			return nil
		}
		return &v.CvssV3
	}).(CVSSv3ResponsePtrOutput)
}

// All information about the package to specifically identify this vulnerability. One entry per (version range and cpe_uri) the package vulnerability has manifested in.
func (o VulnerabilityResponsePtrOutput) Details() DetailResponseArrayOutput {
	return o.ApplyT(func(v *VulnerabilityResponse) []DetailResponse {
		if v == nil {
			return nil
		}
		return v.Details
	}).(DetailResponseArrayOutput)
}

// Note provider assigned impact of the vulnerability.
func (o VulnerabilityResponsePtrOutput) Severity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VulnerabilityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Severity
	}).(pulumi.StringPtrOutput)
}

// The time this information was last changed at the source. This is an upstream timestamp from the underlying information source - e.g. Ubuntu security tracker.
func (o VulnerabilityResponsePtrOutput) SourceUpdateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VulnerabilityResponse) *string {
		if v == nil {
			return nil
		}
		return &v.SourceUpdateTime
	}).(pulumi.StringPtrOutput)
}

// Windows details get their own format because the information format and model don't match a normal detail. Specifically Windows updates are done as patches, thus Windows vulnerabilities really are a missing package, rather than a package being at an incorrect version.
func (o VulnerabilityResponsePtrOutput) WindowsDetails() WindowsDetailResponseArrayOutput {
	return o.ApplyT(func(v *VulnerabilityResponse) []WindowsDetailResponse {
		if v == nil {
			return nil
		}
		return v.WindowsDetails
	}).(WindowsDetailResponseArrayOutput)
}

type WindowsDetail struct {
	// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) in which the vulnerability manifests. Examples include distro or storage location for vulnerable jar.
	CpeUri string `pulumi:"cpeUri"`
	// The description of the vulnerability.
	Description *string `pulumi:"description"`
	// The names of the KBs which have hotfixes to mitigate this vulnerability. Note that there may be multiple hotfixes (and thus multiple KBs) that mitigate a given vulnerability. Currently any listed kb's presence is considered a fix.
	FixingKbs []KnowledgeBase `pulumi:"fixingKbs"`
	// The name of the vulnerability.
	Name string `pulumi:"name"`
}

// WindowsDetailInput is an input type that accepts WindowsDetailArgs and WindowsDetailOutput values.
// You can construct a concrete instance of `WindowsDetailInput` via:
//
//          WindowsDetailArgs{...}
type WindowsDetailInput interface {
	pulumi.Input

	ToWindowsDetailOutput() WindowsDetailOutput
	ToWindowsDetailOutputWithContext(context.Context) WindowsDetailOutput
}

type WindowsDetailArgs struct {
	// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) in which the vulnerability manifests. Examples include distro or storage location for vulnerable jar.
	CpeUri pulumi.StringInput `pulumi:"cpeUri"`
	// The description of the vulnerability.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// The names of the KBs which have hotfixes to mitigate this vulnerability. Note that there may be multiple hotfixes (and thus multiple KBs) that mitigate a given vulnerability. Currently any listed kb's presence is considered a fix.
	FixingKbs KnowledgeBaseArrayInput `pulumi:"fixingKbs"`
	// The name of the vulnerability.
	Name pulumi.StringInput `pulumi:"name"`
}

func (WindowsDetailArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsDetail)(nil)).Elem()
}

func (i WindowsDetailArgs) ToWindowsDetailOutput() WindowsDetailOutput {
	return i.ToWindowsDetailOutputWithContext(context.Background())
}

func (i WindowsDetailArgs) ToWindowsDetailOutputWithContext(ctx context.Context) WindowsDetailOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsDetailOutput)
}

// WindowsDetailArrayInput is an input type that accepts WindowsDetailArray and WindowsDetailArrayOutput values.
// You can construct a concrete instance of `WindowsDetailArrayInput` via:
//
//          WindowsDetailArray{ WindowsDetailArgs{...} }
type WindowsDetailArrayInput interface {
	pulumi.Input

	ToWindowsDetailArrayOutput() WindowsDetailArrayOutput
	ToWindowsDetailArrayOutputWithContext(context.Context) WindowsDetailArrayOutput
}

type WindowsDetailArray []WindowsDetailInput

func (WindowsDetailArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WindowsDetail)(nil)).Elem()
}

func (i WindowsDetailArray) ToWindowsDetailArrayOutput() WindowsDetailArrayOutput {
	return i.ToWindowsDetailArrayOutputWithContext(context.Background())
}

func (i WindowsDetailArray) ToWindowsDetailArrayOutputWithContext(ctx context.Context) WindowsDetailArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsDetailArrayOutput)
}

type WindowsDetailOutput struct{ *pulumi.OutputState }

func (WindowsDetailOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsDetail)(nil)).Elem()
}

func (o WindowsDetailOutput) ToWindowsDetailOutput() WindowsDetailOutput {
	return o
}

func (o WindowsDetailOutput) ToWindowsDetailOutputWithContext(ctx context.Context) WindowsDetailOutput {
	return o
}

// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) in which the vulnerability manifests. Examples include distro or storage location for vulnerable jar.
func (o WindowsDetailOutput) CpeUri() pulumi.StringOutput {
	return o.ApplyT(func(v WindowsDetail) string { return v.CpeUri }).(pulumi.StringOutput)
}

// The description of the vulnerability.
func (o WindowsDetailOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WindowsDetail) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The names of the KBs which have hotfixes to mitigate this vulnerability. Note that there may be multiple hotfixes (and thus multiple KBs) that mitigate a given vulnerability. Currently any listed kb's presence is considered a fix.
func (o WindowsDetailOutput) FixingKbs() KnowledgeBaseArrayOutput {
	return o.ApplyT(func(v WindowsDetail) []KnowledgeBase { return v.FixingKbs }).(KnowledgeBaseArrayOutput)
}

// The name of the vulnerability.
func (o WindowsDetailOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v WindowsDetail) string { return v.Name }).(pulumi.StringOutput)
}

type WindowsDetailArrayOutput struct{ *pulumi.OutputState }

func (WindowsDetailArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WindowsDetail)(nil)).Elem()
}

func (o WindowsDetailArrayOutput) ToWindowsDetailArrayOutput() WindowsDetailArrayOutput {
	return o
}

func (o WindowsDetailArrayOutput) ToWindowsDetailArrayOutputWithContext(ctx context.Context) WindowsDetailArrayOutput {
	return o
}

func (o WindowsDetailArrayOutput) Index(i pulumi.IntInput) WindowsDetailOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WindowsDetail {
		return vs[0].([]WindowsDetail)[vs[1].(int)]
	}).(WindowsDetailOutput)
}

type WindowsDetailResponse struct {
	// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) in which the vulnerability manifests. Examples include distro or storage location for vulnerable jar.
	CpeUri string `pulumi:"cpeUri"`
	// The description of the vulnerability.
	Description string `pulumi:"description"`
	// The names of the KBs which have hotfixes to mitigate this vulnerability. Note that there may be multiple hotfixes (and thus multiple KBs) that mitigate a given vulnerability. Currently any listed kb's presence is considered a fix.
	FixingKbs []KnowledgeBaseResponse `pulumi:"fixingKbs"`
	// The name of the vulnerability.
	Name string `pulumi:"name"`
}

// WindowsDetailResponseInput is an input type that accepts WindowsDetailResponseArgs and WindowsDetailResponseOutput values.
// You can construct a concrete instance of `WindowsDetailResponseInput` via:
//
//          WindowsDetailResponseArgs{...}
type WindowsDetailResponseInput interface {
	pulumi.Input

	ToWindowsDetailResponseOutput() WindowsDetailResponseOutput
	ToWindowsDetailResponseOutputWithContext(context.Context) WindowsDetailResponseOutput
}

type WindowsDetailResponseArgs struct {
	// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) in which the vulnerability manifests. Examples include distro or storage location for vulnerable jar.
	CpeUri pulumi.StringInput `pulumi:"cpeUri"`
	// The description of the vulnerability.
	Description pulumi.StringInput `pulumi:"description"`
	// The names of the KBs which have hotfixes to mitigate this vulnerability. Note that there may be multiple hotfixes (and thus multiple KBs) that mitigate a given vulnerability. Currently any listed kb's presence is considered a fix.
	FixingKbs KnowledgeBaseResponseArrayInput `pulumi:"fixingKbs"`
	// The name of the vulnerability.
	Name pulumi.StringInput `pulumi:"name"`
}

func (WindowsDetailResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsDetailResponse)(nil)).Elem()
}

func (i WindowsDetailResponseArgs) ToWindowsDetailResponseOutput() WindowsDetailResponseOutput {
	return i.ToWindowsDetailResponseOutputWithContext(context.Background())
}

func (i WindowsDetailResponseArgs) ToWindowsDetailResponseOutputWithContext(ctx context.Context) WindowsDetailResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsDetailResponseOutput)
}

// WindowsDetailResponseArrayInput is an input type that accepts WindowsDetailResponseArray and WindowsDetailResponseArrayOutput values.
// You can construct a concrete instance of `WindowsDetailResponseArrayInput` via:
//
//          WindowsDetailResponseArray{ WindowsDetailResponseArgs{...} }
type WindowsDetailResponseArrayInput interface {
	pulumi.Input

	ToWindowsDetailResponseArrayOutput() WindowsDetailResponseArrayOutput
	ToWindowsDetailResponseArrayOutputWithContext(context.Context) WindowsDetailResponseArrayOutput
}

type WindowsDetailResponseArray []WindowsDetailResponseInput

func (WindowsDetailResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WindowsDetailResponse)(nil)).Elem()
}

func (i WindowsDetailResponseArray) ToWindowsDetailResponseArrayOutput() WindowsDetailResponseArrayOutput {
	return i.ToWindowsDetailResponseArrayOutputWithContext(context.Background())
}

func (i WindowsDetailResponseArray) ToWindowsDetailResponseArrayOutputWithContext(ctx context.Context) WindowsDetailResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsDetailResponseArrayOutput)
}

type WindowsDetailResponseOutput struct{ *pulumi.OutputState }

func (WindowsDetailResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsDetailResponse)(nil)).Elem()
}

func (o WindowsDetailResponseOutput) ToWindowsDetailResponseOutput() WindowsDetailResponseOutput {
	return o
}

func (o WindowsDetailResponseOutput) ToWindowsDetailResponseOutputWithContext(ctx context.Context) WindowsDetailResponseOutput {
	return o
}

// The CPE URI in [cpe format](https://cpe.mitre.org/specification/) in which the vulnerability manifests. Examples include distro or storage location for vulnerable jar.
func (o WindowsDetailResponseOutput) CpeUri() pulumi.StringOutput {
	return o.ApplyT(func(v WindowsDetailResponse) string { return v.CpeUri }).(pulumi.StringOutput)
}

// The description of the vulnerability.
func (o WindowsDetailResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v WindowsDetailResponse) string { return v.Description }).(pulumi.StringOutput)
}

// The names of the KBs which have hotfixes to mitigate this vulnerability. Note that there may be multiple hotfixes (and thus multiple KBs) that mitigate a given vulnerability. Currently any listed kb's presence is considered a fix.
func (o WindowsDetailResponseOutput) FixingKbs() KnowledgeBaseResponseArrayOutput {
	return o.ApplyT(func(v WindowsDetailResponse) []KnowledgeBaseResponse { return v.FixingKbs }).(KnowledgeBaseResponseArrayOutput)
}

// The name of the vulnerability.
func (o WindowsDetailResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v WindowsDetailResponse) string { return v.Name }).(pulumi.StringOutput)
}

type WindowsDetailResponseArrayOutput struct{ *pulumi.OutputState }

func (WindowsDetailResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WindowsDetailResponse)(nil)).Elem()
}

func (o WindowsDetailResponseArrayOutput) ToWindowsDetailResponseArrayOutput() WindowsDetailResponseArrayOutput {
	return o
}

func (o WindowsDetailResponseArrayOutput) ToWindowsDetailResponseArrayOutputWithContext(ctx context.Context) WindowsDetailResponseArrayOutput {
	return o
}

func (o WindowsDetailResponseArrayOutput) Index(i pulumi.IntInput) WindowsDetailResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WindowsDetailResponse {
		return vs[0].([]WindowsDetailResponse)[vs[1].(int)]
	}).(WindowsDetailResponseOutput)
}

func init() {
	pulumi.RegisterOutputType(AliasContextOutput{})
	pulumi.RegisterOutputType(AliasContextPtrOutput{})
	pulumi.RegisterOutputType(AliasContextResponseOutput{})
	pulumi.RegisterOutputType(AliasContextResponsePtrOutput{})
	pulumi.RegisterOutputType(ArtifactOutput{})
	pulumi.RegisterOutputType(ArtifactArrayOutput{})
	pulumi.RegisterOutputType(ArtifactHashesOutput{})
	pulumi.RegisterOutputType(ArtifactHashesPtrOutput{})
	pulumi.RegisterOutputType(ArtifactHashesResponseOutput{})
	pulumi.RegisterOutputType(ArtifactResponseOutput{})
	pulumi.RegisterOutputType(ArtifactResponseArrayOutput{})
	pulumi.RegisterOutputType(ArtifactRuleOutput{})
	pulumi.RegisterOutputType(ArtifactRuleArrayOutput{})
	pulumi.RegisterOutputType(ArtifactRuleResponseOutput{})
	pulumi.RegisterOutputType(ArtifactRuleResponseArrayOutput{})
	pulumi.RegisterOutputType(AttestationOutput{})
	pulumi.RegisterOutputType(AttestationPtrOutput{})
	pulumi.RegisterOutputType(AttestationResponseOutput{})
	pulumi.RegisterOutputType(AttestationResponsePtrOutput{})
	pulumi.RegisterOutputType(AuthorityOutput{})
	pulumi.RegisterOutputType(AuthorityPtrOutput{})
	pulumi.RegisterOutputType(AuthorityResponseOutput{})
	pulumi.RegisterOutputType(AuthorityResponsePtrOutput{})
	pulumi.RegisterOutputType(BasisOutput{})
	pulumi.RegisterOutputType(BasisPtrOutput{})
	pulumi.RegisterOutputType(BasisResponseOutput{})
	pulumi.RegisterOutputType(BasisResponsePtrOutput{})
	pulumi.RegisterOutputType(BindingOutput{})
	pulumi.RegisterOutputType(BindingArrayOutput{})
	pulumi.RegisterOutputType(BindingResponseOutput{})
	pulumi.RegisterOutputType(BindingResponseArrayOutput{})
	pulumi.RegisterOutputType(BuildOutput{})
	pulumi.RegisterOutputType(BuildPtrOutput{})
	pulumi.RegisterOutputType(BuildProvenanceOutput{})
	pulumi.RegisterOutputType(BuildProvenancePtrOutput{})
	pulumi.RegisterOutputType(BuildProvenanceResponseOutput{})
	pulumi.RegisterOutputType(BuildProvenanceResponsePtrOutput{})
	pulumi.RegisterOutputType(BuildResponseOutput{})
	pulumi.RegisterOutputType(BuildResponsePtrOutput{})
	pulumi.RegisterOutputType(BuildSignatureOutput{})
	pulumi.RegisterOutputType(BuildSignaturePtrOutput{})
	pulumi.RegisterOutputType(BuildSignatureResponseOutput{})
	pulumi.RegisterOutputType(BuildSignatureResponsePtrOutput{})
	pulumi.RegisterOutputType(ByProductsOutput{})
	pulumi.RegisterOutputType(ByProductsPtrOutput{})
	pulumi.RegisterOutputType(ByProductsResponseOutput{})
	pulumi.RegisterOutputType(ByProductsResponsePtrOutput{})
	pulumi.RegisterOutputType(CVSSv3Output{})
	pulumi.RegisterOutputType(CVSSv3PtrOutput{})
	pulumi.RegisterOutputType(CVSSv3ResponseOutput{})
	pulumi.RegisterOutputType(CVSSv3ResponsePtrOutput{})
	pulumi.RegisterOutputType(CloudRepoSourceContextOutput{})
	pulumi.RegisterOutputType(CloudRepoSourceContextPtrOutput{})
	pulumi.RegisterOutputType(CloudRepoSourceContextResponseOutput{})
	pulumi.RegisterOutputType(CloudRepoSourceContextResponsePtrOutput{})
	pulumi.RegisterOutputType(CommandOutput{})
	pulumi.RegisterOutputType(CommandArrayOutput{})
	pulumi.RegisterOutputType(CommandResponseOutput{})
	pulumi.RegisterOutputType(CommandResponseArrayOutput{})
	pulumi.RegisterOutputType(DeployableOutput{})
	pulumi.RegisterOutputType(DeployablePtrOutput{})
	pulumi.RegisterOutputType(DeployableResponseOutput{})
	pulumi.RegisterOutputType(DeployableResponsePtrOutput{})
	pulumi.RegisterOutputType(DeploymentOutput{})
	pulumi.RegisterOutputType(DeploymentPtrOutput{})
	pulumi.RegisterOutputType(DeploymentResponseOutput{})
	pulumi.RegisterOutputType(DeploymentResponsePtrOutput{})
	pulumi.RegisterOutputType(DerivedOutput{})
	pulumi.RegisterOutputType(DerivedPtrOutput{})
	pulumi.RegisterOutputType(DerivedResponseOutput{})
	pulumi.RegisterOutputType(DerivedResponsePtrOutput{})
	pulumi.RegisterOutputType(DetailOutput{})
	pulumi.RegisterOutputType(DetailArrayOutput{})
	pulumi.RegisterOutputType(DetailResponseOutput{})
	pulumi.RegisterOutputType(DetailResponseArrayOutput{})
	pulumi.RegisterOutputType(DetailsOutput{})
	pulumi.RegisterOutputType(DetailsPtrOutput{})
	pulumi.RegisterOutputType(DetailsResponseOutput{})
	pulumi.RegisterOutputType(DetailsResponsePtrOutput{})
	pulumi.RegisterOutputType(DiscoveredOutput{})
	pulumi.RegisterOutputType(DiscoveredPtrOutput{})
	pulumi.RegisterOutputType(DiscoveredResponseOutput{})
	pulumi.RegisterOutputType(DiscoveredResponsePtrOutput{})
	pulumi.RegisterOutputType(DiscoveryOutput{})
	pulumi.RegisterOutputType(DiscoveryPtrOutput{})
	pulumi.RegisterOutputType(DiscoveryResponseOutput{})
	pulumi.RegisterOutputType(DiscoveryResponsePtrOutput{})
	pulumi.RegisterOutputType(DistributionOutput{})
	pulumi.RegisterOutputType(DistributionArrayOutput{})
	pulumi.RegisterOutputType(DistributionResponseOutput{})
	pulumi.RegisterOutputType(DistributionResponseArrayOutput{})
	pulumi.RegisterOutputType(DocumentNoteOutput{})
	pulumi.RegisterOutputType(DocumentNotePtrOutput{})
	pulumi.RegisterOutputType(DocumentNoteResponseOutput{})
	pulumi.RegisterOutputType(DocumentNoteResponsePtrOutput{})
	pulumi.RegisterOutputType(DocumentOccurrenceOutput{})
	pulumi.RegisterOutputType(DocumentOccurrencePtrOutput{})
	pulumi.RegisterOutputType(DocumentOccurrenceResponseOutput{})
	pulumi.RegisterOutputType(DocumentOccurrenceResponsePtrOutput{})
	pulumi.RegisterOutputType(EnvironmentOutput{})
	pulumi.RegisterOutputType(EnvironmentPtrOutput{})
	pulumi.RegisterOutputType(EnvironmentResponseOutput{})
	pulumi.RegisterOutputType(EnvironmentResponsePtrOutput{})
	pulumi.RegisterOutputType(ExprOutput{})
	pulumi.RegisterOutputType(ExprPtrOutput{})
	pulumi.RegisterOutputType(ExprResponseOutput{})
	pulumi.RegisterOutputType(ExternalRefOutput{})
	pulumi.RegisterOutputType(ExternalRefArrayOutput{})
	pulumi.RegisterOutputType(ExternalRefResponseOutput{})
	pulumi.RegisterOutputType(ExternalRefResponseArrayOutput{})
	pulumi.RegisterOutputType(FileNoteOutput{})
	pulumi.RegisterOutputType(FileNotePtrOutput{})
	pulumi.RegisterOutputType(FileNoteResponseOutput{})
	pulumi.RegisterOutputType(FileNoteResponsePtrOutput{})
	pulumi.RegisterOutputType(FileOccurrenceOutput{})
	pulumi.RegisterOutputType(FileOccurrencePtrOutput{})
	pulumi.RegisterOutputType(FileOccurrenceResponseOutput{})
	pulumi.RegisterOutputType(FileOccurrenceResponsePtrOutput{})
	pulumi.RegisterOutputType(FingerprintOutput{})
	pulumi.RegisterOutputType(FingerprintPtrOutput{})
	pulumi.RegisterOutputType(FingerprintResponseOutput{})
	pulumi.RegisterOutputType(FingerprintResponsePtrOutput{})
	pulumi.RegisterOutputType(GenericSignedAttestationOutput{})
	pulumi.RegisterOutputType(GenericSignedAttestationPtrOutput{})
	pulumi.RegisterOutputType(GenericSignedAttestationResponseOutput{})
	pulumi.RegisterOutputType(GenericSignedAttestationResponsePtrOutput{})
	pulumi.RegisterOutputType(GerritSourceContextOutput{})
	pulumi.RegisterOutputType(GerritSourceContextPtrOutput{})
	pulumi.RegisterOutputType(GerritSourceContextResponseOutput{})
	pulumi.RegisterOutputType(GerritSourceContextResponsePtrOutput{})
	pulumi.RegisterOutputType(GitSourceContextOutput{})
	pulumi.RegisterOutputType(GitSourceContextPtrOutput{})
	pulumi.RegisterOutputType(GitSourceContextResponseOutput{})
	pulumi.RegisterOutputType(GitSourceContextResponsePtrOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1BuildDetailsOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1BuildDetailsPtrOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1BuildDetailsResponseOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1BuildDetailsResponsePtrOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1DeploymentDetailsOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1DeploymentDetailsPtrOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1DeploymentDetailsResponseOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1DeploymentDetailsResponsePtrOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1DiscoveryDetailsOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1DiscoveryDetailsPtrOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1DiscoveryDetailsResponseOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1DiscoveryDetailsResponsePtrOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1ImageDetailsOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1ImageDetailsPtrOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1ImageDetailsResponseOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1ImageDetailsResponsePtrOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1IntotoArtifactOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1IntotoArtifactArrayOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1IntotoArtifactResponseOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1IntotoArtifactResponseArrayOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1IntotoDetailsOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1IntotoDetailsPtrOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1IntotoDetailsResponseOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1IntotoDetailsResponsePtrOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1IntotoSignatureOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1IntotoSignatureArrayOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1IntotoSignatureResponseOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1IntotoSignatureResponseArrayOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1PackageDetailsOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1PackageDetailsPtrOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1PackageDetailsResponseOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1PackageDetailsResponsePtrOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1VulnerabilityDetailsOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1VulnerabilityDetailsPtrOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1VulnerabilityDetailsResponseOutput{})
	pulumi.RegisterOutputType(GrafeasV1beta1VulnerabilityDetailsResponsePtrOutput{})
	pulumi.RegisterOutputType(HintOutput{})
	pulumi.RegisterOutputType(HintPtrOutput{})
	pulumi.RegisterOutputType(HintResponseOutput{})
	pulumi.RegisterOutputType(HintResponsePtrOutput{})
	pulumi.RegisterOutputType(InTotoOutput{})
	pulumi.RegisterOutputType(InTotoPtrOutput{})
	pulumi.RegisterOutputType(InTotoResponseOutput{})
	pulumi.RegisterOutputType(InTotoResponsePtrOutput{})
	pulumi.RegisterOutputType(InstallationOutput{})
	pulumi.RegisterOutputType(InstallationPtrOutput{})
	pulumi.RegisterOutputType(InstallationResponseOutput{})
	pulumi.RegisterOutputType(InstallationResponsePtrOutput{})
	pulumi.RegisterOutputType(KnowledgeBaseOutput{})
	pulumi.RegisterOutputType(KnowledgeBaseArrayOutput{})
	pulumi.RegisterOutputType(KnowledgeBaseResponseOutput{})
	pulumi.RegisterOutputType(KnowledgeBaseResponseArrayOutput{})
	pulumi.RegisterOutputType(LayerOutput{})
	pulumi.RegisterOutputType(LayerArrayOutput{})
	pulumi.RegisterOutputType(LayerResponseOutput{})
	pulumi.RegisterOutputType(LayerResponseArrayOutput{})
	pulumi.RegisterOutputType(LinkOutput{})
	pulumi.RegisterOutputType(LinkPtrOutput{})
	pulumi.RegisterOutputType(LinkResponseOutput{})
	pulumi.RegisterOutputType(LinkResponsePtrOutput{})
	pulumi.RegisterOutputType(LocationOutput{})
	pulumi.RegisterOutputType(LocationArrayOutput{})
	pulumi.RegisterOutputType(LocationResponseOutput{})
	pulumi.RegisterOutputType(LocationResponseArrayOutput{})
	pulumi.RegisterOutputType(PackageOutput{})
	pulumi.RegisterOutputType(PackagePtrOutput{})
	pulumi.RegisterOutputType(PackageIssueOutput{})
	pulumi.RegisterOutputType(PackageIssueArrayOutput{})
	pulumi.RegisterOutputType(PackageIssueResponseOutput{})
	pulumi.RegisterOutputType(PackageIssueResponseArrayOutput{})
	pulumi.RegisterOutputType(PackageNoteOutput{})
	pulumi.RegisterOutputType(PackageNotePtrOutput{})
	pulumi.RegisterOutputType(PackageNoteResponseOutput{})
	pulumi.RegisterOutputType(PackageNoteResponsePtrOutput{})
	pulumi.RegisterOutputType(PackageOccurrenceOutput{})
	pulumi.RegisterOutputType(PackageOccurrencePtrOutput{})
	pulumi.RegisterOutputType(PackageOccurrenceResponseOutput{})
	pulumi.RegisterOutputType(PackageOccurrenceResponsePtrOutput{})
	pulumi.RegisterOutputType(PackageResponseOutput{})
	pulumi.RegisterOutputType(PackageResponsePtrOutput{})
	pulumi.RegisterOutputType(PgpSignedAttestationOutput{})
	pulumi.RegisterOutputType(PgpSignedAttestationPtrOutput{})
	pulumi.RegisterOutputType(PgpSignedAttestationResponseOutput{})
	pulumi.RegisterOutputType(PgpSignedAttestationResponsePtrOutput{})
	pulumi.RegisterOutputType(ProjectRepoIdOutput{})
	pulumi.RegisterOutputType(ProjectRepoIdPtrOutput{})
	pulumi.RegisterOutputType(ProjectRepoIdResponseOutput{})
	pulumi.RegisterOutputType(ProjectRepoIdResponsePtrOutput{})
	pulumi.RegisterOutputType(RelatedUrlOutput{})
	pulumi.RegisterOutputType(RelatedUrlArrayOutput{})
	pulumi.RegisterOutputType(RelatedUrlResponseOutput{})
	pulumi.RegisterOutputType(RelatedUrlResponseArrayOutput{})
	pulumi.RegisterOutputType(RelationshipNoteOutput{})
	pulumi.RegisterOutputType(RelationshipNotePtrOutput{})
	pulumi.RegisterOutputType(RelationshipNoteResponseOutput{})
	pulumi.RegisterOutputType(RelationshipNoteResponsePtrOutput{})
	pulumi.RegisterOutputType(RelationshipOccurrenceOutput{})
	pulumi.RegisterOutputType(RelationshipOccurrencePtrOutput{})
	pulumi.RegisterOutputType(RelationshipOccurrenceResponseOutput{})
	pulumi.RegisterOutputType(RelationshipOccurrenceResponsePtrOutput{})
	pulumi.RegisterOutputType(RepoIdOutput{})
	pulumi.RegisterOutputType(RepoIdPtrOutput{})
	pulumi.RegisterOutputType(RepoIdResponseOutput{})
	pulumi.RegisterOutputType(RepoIdResponsePtrOutput{})
	pulumi.RegisterOutputType(ResourceOutput{})
	pulumi.RegisterOutputType(ResourcePtrOutput{})
	pulumi.RegisterOutputType(ResourceResponseOutput{})
	pulumi.RegisterOutputType(ResourceResponsePtrOutput{})
	pulumi.RegisterOutputType(SignatureOutput{})
	pulumi.RegisterOutputType(SignatureArrayOutput{})
	pulumi.RegisterOutputType(SignatureResponseOutput{})
	pulumi.RegisterOutputType(SignatureResponseArrayOutput{})
	pulumi.RegisterOutputType(SigningKeyOutput{})
	pulumi.RegisterOutputType(SigningKeyArrayOutput{})
	pulumi.RegisterOutputType(SigningKeyResponseOutput{})
	pulumi.RegisterOutputType(SigningKeyResponseArrayOutput{})
	pulumi.RegisterOutputType(SourceOutput{})
	pulumi.RegisterOutputType(SourcePtrOutput{})
	pulumi.RegisterOutputType(SourceContextOutput{})
	pulumi.RegisterOutputType(SourceContextPtrOutput{})
	pulumi.RegisterOutputType(SourceContextArrayOutput{})
	pulumi.RegisterOutputType(SourceContextResponseOutput{})
	pulumi.RegisterOutputType(SourceContextResponsePtrOutput{})
	pulumi.RegisterOutputType(SourceContextResponseArrayOutput{})
	pulumi.RegisterOutputType(SourceResponseOutput{})
	pulumi.RegisterOutputType(SourceResponsePtrOutput{})
	pulumi.RegisterOutputType(StatusOutput{})
	pulumi.RegisterOutputType(StatusPtrOutput{})
	pulumi.RegisterOutputType(StatusResponseOutput{})
	pulumi.RegisterOutputType(StatusResponsePtrOutput{})
	pulumi.RegisterOutputType(VersionOutput{})
	pulumi.RegisterOutputType(VersionPtrOutput{})
	pulumi.RegisterOutputType(VersionResponseOutput{})
	pulumi.RegisterOutputType(VulnerabilityOutput{})
	pulumi.RegisterOutputType(VulnerabilityPtrOutput{})
	pulumi.RegisterOutputType(VulnerabilityLocationOutput{})
	pulumi.RegisterOutputType(VulnerabilityLocationPtrOutput{})
	pulumi.RegisterOutputType(VulnerabilityLocationResponseOutput{})
	pulumi.RegisterOutputType(VulnerabilityResponseOutput{})
	pulumi.RegisterOutputType(VulnerabilityResponsePtrOutput{})
	pulumi.RegisterOutputType(WindowsDetailOutput{})
	pulumi.RegisterOutputType(WindowsDetailArrayOutput{})
	pulumi.RegisterOutputType(WindowsDetailResponseOutput{})
	pulumi.RegisterOutputType(WindowsDetailResponseArrayOutput{})
}

// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v3

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The Google Cloud Storage location for the input content.
type GcsSource struct {
	// Source data URI. For example, `gs://my_bucket/my_object`.
	InputUri string `pulumi:"inputUri"`
}

// GcsSourceInput is an input type that accepts GcsSourceArgs and GcsSourceOutput values.
// You can construct a concrete instance of `GcsSourceInput` via:
//
//          GcsSourceArgs{...}
type GcsSourceInput interface {
	pulumi.Input

	ToGcsSourceOutput() GcsSourceOutput
	ToGcsSourceOutputWithContext(context.Context) GcsSourceOutput
}

// The Google Cloud Storage location for the input content.
type GcsSourceArgs struct {
	// Source data URI. For example, `gs://my_bucket/my_object`.
	InputUri pulumi.StringInput `pulumi:"inputUri"`
}

func (GcsSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GcsSource)(nil)).Elem()
}

func (i GcsSourceArgs) ToGcsSourceOutput() GcsSourceOutput {
	return i.ToGcsSourceOutputWithContext(context.Background())
}

func (i GcsSourceArgs) ToGcsSourceOutputWithContext(ctx context.Context) GcsSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GcsSourceOutput)
}

// The Google Cloud Storage location for the input content.
type GcsSourceOutput struct{ *pulumi.OutputState }

func (GcsSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GcsSource)(nil)).Elem()
}

func (o GcsSourceOutput) ToGcsSourceOutput() GcsSourceOutput {
	return o
}

func (o GcsSourceOutput) ToGcsSourceOutputWithContext(ctx context.Context) GcsSourceOutput {
	return o
}

// Source data URI. For example, `gs://my_bucket/my_object`.
func (o GcsSourceOutput) InputUri() pulumi.StringOutput {
	return o.ApplyT(func(v GcsSource) string { return v.InputUri }).(pulumi.StringOutput)
}

// The Google Cloud Storage location for the input content.
type GcsSourceResponse struct {
	// Source data URI. For example, `gs://my_bucket/my_object`.
	InputUri string `pulumi:"inputUri"`
}

// The Google Cloud Storage location for the input content.
type GcsSourceResponseOutput struct{ *pulumi.OutputState }

func (GcsSourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GcsSourceResponse)(nil)).Elem()
}

func (o GcsSourceResponseOutput) ToGcsSourceResponseOutput() GcsSourceResponseOutput {
	return o
}

func (o GcsSourceResponseOutput) ToGcsSourceResponseOutputWithContext(ctx context.Context) GcsSourceResponseOutput {
	return o
}

// Source data URI. For example, `gs://my_bucket/my_object`.
func (o GcsSourceResponseOutput) InputUri() pulumi.StringOutput {
	return o.ApplyT(func(v GcsSourceResponse) string { return v.InputUri }).(pulumi.StringOutput)
}

// Input configuration for glossaries.
type GlossaryInputConfig struct {
	// Google Cloud Storage location of glossary data. File format is determined based on the filename extension. API returns [google.rpc.Code.INVALID_ARGUMENT] for unsupported URI-s and file formats. Wildcards are not allowed. This must be a single file in one of the following formats: For unidirectional glossaries: - TSV/CSV (`.tsv`/`.csv`): 2 column file, tab- or comma-separated. The first column is source text. The second column is target text. The file must not contain headers. That is, the first row is data, not column names. - TMX (`.tmx`): TMX file with parallel data defining source/target term pairs. For equivalent term sets glossaries: - CSV (`.csv`): Multi-column CSV file defining equivalent glossary terms in multiple languages. See documentation for more information - [glossaries](https://cloud.google.com/translate/docs/advanced/glossary).
	GcsSource GcsSource `pulumi:"gcsSource"`
}

// GlossaryInputConfigInput is an input type that accepts GlossaryInputConfigArgs and GlossaryInputConfigOutput values.
// You can construct a concrete instance of `GlossaryInputConfigInput` via:
//
//          GlossaryInputConfigArgs{...}
type GlossaryInputConfigInput interface {
	pulumi.Input

	ToGlossaryInputConfigOutput() GlossaryInputConfigOutput
	ToGlossaryInputConfigOutputWithContext(context.Context) GlossaryInputConfigOutput
}

// Input configuration for glossaries.
type GlossaryInputConfigArgs struct {
	// Google Cloud Storage location of glossary data. File format is determined based on the filename extension. API returns [google.rpc.Code.INVALID_ARGUMENT] for unsupported URI-s and file formats. Wildcards are not allowed. This must be a single file in one of the following formats: For unidirectional glossaries: - TSV/CSV (`.tsv`/`.csv`): 2 column file, tab- or comma-separated. The first column is source text. The second column is target text. The file must not contain headers. That is, the first row is data, not column names. - TMX (`.tmx`): TMX file with parallel data defining source/target term pairs. For equivalent term sets glossaries: - CSV (`.csv`): Multi-column CSV file defining equivalent glossary terms in multiple languages. See documentation for more information - [glossaries](https://cloud.google.com/translate/docs/advanced/glossary).
	GcsSource GcsSourceInput `pulumi:"gcsSource"`
}

func (GlossaryInputConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GlossaryInputConfig)(nil)).Elem()
}

func (i GlossaryInputConfigArgs) ToGlossaryInputConfigOutput() GlossaryInputConfigOutput {
	return i.ToGlossaryInputConfigOutputWithContext(context.Background())
}

func (i GlossaryInputConfigArgs) ToGlossaryInputConfigOutputWithContext(ctx context.Context) GlossaryInputConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GlossaryInputConfigOutput)
}

// Input configuration for glossaries.
type GlossaryInputConfigOutput struct{ *pulumi.OutputState }

func (GlossaryInputConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GlossaryInputConfig)(nil)).Elem()
}

func (o GlossaryInputConfigOutput) ToGlossaryInputConfigOutput() GlossaryInputConfigOutput {
	return o
}

func (o GlossaryInputConfigOutput) ToGlossaryInputConfigOutputWithContext(ctx context.Context) GlossaryInputConfigOutput {
	return o
}

// Google Cloud Storage location of glossary data. File format is determined based on the filename extension. API returns [google.rpc.Code.INVALID_ARGUMENT] for unsupported URI-s and file formats. Wildcards are not allowed. This must be a single file in one of the following formats: For unidirectional glossaries: - TSV/CSV (`.tsv`/`.csv`): 2 column file, tab- or comma-separated. The first column is source text. The second column is target text. The file must not contain headers. That is, the first row is data, not column names. - TMX (`.tmx`): TMX file with parallel data defining source/target term pairs. For equivalent term sets glossaries: - CSV (`.csv`): Multi-column CSV file defining equivalent glossary terms in multiple languages. See documentation for more information - [glossaries](https://cloud.google.com/translate/docs/advanced/glossary).
func (o GlossaryInputConfigOutput) GcsSource() GcsSourceOutput {
	return o.ApplyT(func(v GlossaryInputConfig) GcsSource { return v.GcsSource }).(GcsSourceOutput)
}

// Input configuration for glossaries.
type GlossaryInputConfigResponse struct {
	// Google Cloud Storage location of glossary data. File format is determined based on the filename extension. API returns [google.rpc.Code.INVALID_ARGUMENT] for unsupported URI-s and file formats. Wildcards are not allowed. This must be a single file in one of the following formats: For unidirectional glossaries: - TSV/CSV (`.tsv`/`.csv`): 2 column file, tab- or comma-separated. The first column is source text. The second column is target text. The file must not contain headers. That is, the first row is data, not column names. - TMX (`.tmx`): TMX file with parallel data defining source/target term pairs. For equivalent term sets glossaries: - CSV (`.csv`): Multi-column CSV file defining equivalent glossary terms in multiple languages. See documentation for more information - [glossaries](https://cloud.google.com/translate/docs/advanced/glossary).
	GcsSource GcsSourceResponse `pulumi:"gcsSource"`
}

// Input configuration for glossaries.
type GlossaryInputConfigResponseOutput struct{ *pulumi.OutputState }

func (GlossaryInputConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GlossaryInputConfigResponse)(nil)).Elem()
}

func (o GlossaryInputConfigResponseOutput) ToGlossaryInputConfigResponseOutput() GlossaryInputConfigResponseOutput {
	return o
}

func (o GlossaryInputConfigResponseOutput) ToGlossaryInputConfigResponseOutputWithContext(ctx context.Context) GlossaryInputConfigResponseOutput {
	return o
}

// Google Cloud Storage location of glossary data. File format is determined based on the filename extension. API returns [google.rpc.Code.INVALID_ARGUMENT] for unsupported URI-s and file formats. Wildcards are not allowed. This must be a single file in one of the following formats: For unidirectional glossaries: - TSV/CSV (`.tsv`/`.csv`): 2 column file, tab- or comma-separated. The first column is source text. The second column is target text. The file must not contain headers. That is, the first row is data, not column names. - TMX (`.tmx`): TMX file with parallel data defining source/target term pairs. For equivalent term sets glossaries: - CSV (`.csv`): Multi-column CSV file defining equivalent glossary terms in multiple languages. See documentation for more information - [glossaries](https://cloud.google.com/translate/docs/advanced/glossary).
func (o GlossaryInputConfigResponseOutput) GcsSource() GcsSourceResponseOutput {
	return o.ApplyT(func(v GlossaryInputConfigResponse) GcsSourceResponse { return v.GcsSource }).(GcsSourceResponseOutput)
}

// Used with unidirectional glossaries.
type LanguageCodePair struct {
	// The BCP-47 language code of the input text, for example, "en-US". Expected to be an exact match for GlossaryTerm.language_code.
	SourceLanguageCode string `pulumi:"sourceLanguageCode"`
	// The BCP-47 language code for translation output, for example, "zh-CN". Expected to be an exact match for GlossaryTerm.language_code.
	TargetLanguageCode string `pulumi:"targetLanguageCode"`
}

// LanguageCodePairInput is an input type that accepts LanguageCodePairArgs and LanguageCodePairOutput values.
// You can construct a concrete instance of `LanguageCodePairInput` via:
//
//          LanguageCodePairArgs{...}
type LanguageCodePairInput interface {
	pulumi.Input

	ToLanguageCodePairOutput() LanguageCodePairOutput
	ToLanguageCodePairOutputWithContext(context.Context) LanguageCodePairOutput
}

// Used with unidirectional glossaries.
type LanguageCodePairArgs struct {
	// The BCP-47 language code of the input text, for example, "en-US". Expected to be an exact match for GlossaryTerm.language_code.
	SourceLanguageCode pulumi.StringInput `pulumi:"sourceLanguageCode"`
	// The BCP-47 language code for translation output, for example, "zh-CN". Expected to be an exact match for GlossaryTerm.language_code.
	TargetLanguageCode pulumi.StringInput `pulumi:"targetLanguageCode"`
}

func (LanguageCodePairArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LanguageCodePair)(nil)).Elem()
}

func (i LanguageCodePairArgs) ToLanguageCodePairOutput() LanguageCodePairOutput {
	return i.ToLanguageCodePairOutputWithContext(context.Background())
}

func (i LanguageCodePairArgs) ToLanguageCodePairOutputWithContext(ctx context.Context) LanguageCodePairOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LanguageCodePairOutput)
}

func (i LanguageCodePairArgs) ToLanguageCodePairPtrOutput() LanguageCodePairPtrOutput {
	return i.ToLanguageCodePairPtrOutputWithContext(context.Background())
}

func (i LanguageCodePairArgs) ToLanguageCodePairPtrOutputWithContext(ctx context.Context) LanguageCodePairPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LanguageCodePairOutput).ToLanguageCodePairPtrOutputWithContext(ctx)
}

// LanguageCodePairPtrInput is an input type that accepts LanguageCodePairArgs, LanguageCodePairPtr and LanguageCodePairPtrOutput values.
// You can construct a concrete instance of `LanguageCodePairPtrInput` via:
//
//          LanguageCodePairArgs{...}
//
//  or:
//
//          nil
type LanguageCodePairPtrInput interface {
	pulumi.Input

	ToLanguageCodePairPtrOutput() LanguageCodePairPtrOutput
	ToLanguageCodePairPtrOutputWithContext(context.Context) LanguageCodePairPtrOutput
}

type languageCodePairPtrType LanguageCodePairArgs

func LanguageCodePairPtr(v *LanguageCodePairArgs) LanguageCodePairPtrInput {
	return (*languageCodePairPtrType)(v)
}

func (*languageCodePairPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LanguageCodePair)(nil)).Elem()
}

func (i *languageCodePairPtrType) ToLanguageCodePairPtrOutput() LanguageCodePairPtrOutput {
	return i.ToLanguageCodePairPtrOutputWithContext(context.Background())
}

func (i *languageCodePairPtrType) ToLanguageCodePairPtrOutputWithContext(ctx context.Context) LanguageCodePairPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LanguageCodePairPtrOutput)
}

// Used with unidirectional glossaries.
type LanguageCodePairOutput struct{ *pulumi.OutputState }

func (LanguageCodePairOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LanguageCodePair)(nil)).Elem()
}

func (o LanguageCodePairOutput) ToLanguageCodePairOutput() LanguageCodePairOutput {
	return o
}

func (o LanguageCodePairOutput) ToLanguageCodePairOutputWithContext(ctx context.Context) LanguageCodePairOutput {
	return o
}

func (o LanguageCodePairOutput) ToLanguageCodePairPtrOutput() LanguageCodePairPtrOutput {
	return o.ToLanguageCodePairPtrOutputWithContext(context.Background())
}

func (o LanguageCodePairOutput) ToLanguageCodePairPtrOutputWithContext(ctx context.Context) LanguageCodePairPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LanguageCodePair) *LanguageCodePair {
		return &v
	}).(LanguageCodePairPtrOutput)
}

// The BCP-47 language code of the input text, for example, "en-US". Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodePairOutput) SourceLanguageCode() pulumi.StringOutput {
	return o.ApplyT(func(v LanguageCodePair) string { return v.SourceLanguageCode }).(pulumi.StringOutput)
}

// The BCP-47 language code for translation output, for example, "zh-CN". Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodePairOutput) TargetLanguageCode() pulumi.StringOutput {
	return o.ApplyT(func(v LanguageCodePair) string { return v.TargetLanguageCode }).(pulumi.StringOutput)
}

type LanguageCodePairPtrOutput struct{ *pulumi.OutputState }

func (LanguageCodePairPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LanguageCodePair)(nil)).Elem()
}

func (o LanguageCodePairPtrOutput) ToLanguageCodePairPtrOutput() LanguageCodePairPtrOutput {
	return o
}

func (o LanguageCodePairPtrOutput) ToLanguageCodePairPtrOutputWithContext(ctx context.Context) LanguageCodePairPtrOutput {
	return o
}

func (o LanguageCodePairPtrOutput) Elem() LanguageCodePairOutput {
	return o.ApplyT(func(v *LanguageCodePair) LanguageCodePair {
		if v != nil {
			return *v
		}
		var ret LanguageCodePair
		return ret
	}).(LanguageCodePairOutput)
}

// The BCP-47 language code of the input text, for example, "en-US". Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodePairPtrOutput) SourceLanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LanguageCodePair) *string {
		if v == nil {
			return nil
		}
		return &v.SourceLanguageCode
	}).(pulumi.StringPtrOutput)
}

// The BCP-47 language code for translation output, for example, "zh-CN". Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodePairPtrOutput) TargetLanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LanguageCodePair) *string {
		if v == nil {
			return nil
		}
		return &v.TargetLanguageCode
	}).(pulumi.StringPtrOutput)
}

// Used with unidirectional glossaries.
type LanguageCodePairResponse struct {
	// The BCP-47 language code of the input text, for example, "en-US". Expected to be an exact match for GlossaryTerm.language_code.
	SourceLanguageCode string `pulumi:"sourceLanguageCode"`
	// The BCP-47 language code for translation output, for example, "zh-CN". Expected to be an exact match for GlossaryTerm.language_code.
	TargetLanguageCode string `pulumi:"targetLanguageCode"`
}

// Used with unidirectional glossaries.
type LanguageCodePairResponseOutput struct{ *pulumi.OutputState }

func (LanguageCodePairResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LanguageCodePairResponse)(nil)).Elem()
}

func (o LanguageCodePairResponseOutput) ToLanguageCodePairResponseOutput() LanguageCodePairResponseOutput {
	return o
}

func (o LanguageCodePairResponseOutput) ToLanguageCodePairResponseOutputWithContext(ctx context.Context) LanguageCodePairResponseOutput {
	return o
}

// The BCP-47 language code of the input text, for example, "en-US". Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodePairResponseOutput) SourceLanguageCode() pulumi.StringOutput {
	return o.ApplyT(func(v LanguageCodePairResponse) string { return v.SourceLanguageCode }).(pulumi.StringOutput)
}

// The BCP-47 language code for translation output, for example, "zh-CN". Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodePairResponseOutput) TargetLanguageCode() pulumi.StringOutput {
	return o.ApplyT(func(v LanguageCodePairResponse) string { return v.TargetLanguageCode }).(pulumi.StringOutput)
}

// Used with equivalent term set glossaries.
type LanguageCodesSet struct {
	// The BCP-47 language code(s) for terms defined in the glossary. All entries are unique. The list contains at least two entries. Expected to be an exact match for GlossaryTerm.language_code.
	LanguageCodes []string `pulumi:"languageCodes"`
}

// LanguageCodesSetInput is an input type that accepts LanguageCodesSetArgs and LanguageCodesSetOutput values.
// You can construct a concrete instance of `LanguageCodesSetInput` via:
//
//          LanguageCodesSetArgs{...}
type LanguageCodesSetInput interface {
	pulumi.Input

	ToLanguageCodesSetOutput() LanguageCodesSetOutput
	ToLanguageCodesSetOutputWithContext(context.Context) LanguageCodesSetOutput
}

// Used with equivalent term set glossaries.
type LanguageCodesSetArgs struct {
	// The BCP-47 language code(s) for terms defined in the glossary. All entries are unique. The list contains at least two entries. Expected to be an exact match for GlossaryTerm.language_code.
	LanguageCodes pulumi.StringArrayInput `pulumi:"languageCodes"`
}

func (LanguageCodesSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LanguageCodesSet)(nil)).Elem()
}

func (i LanguageCodesSetArgs) ToLanguageCodesSetOutput() LanguageCodesSetOutput {
	return i.ToLanguageCodesSetOutputWithContext(context.Background())
}

func (i LanguageCodesSetArgs) ToLanguageCodesSetOutputWithContext(ctx context.Context) LanguageCodesSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LanguageCodesSetOutput)
}

func (i LanguageCodesSetArgs) ToLanguageCodesSetPtrOutput() LanguageCodesSetPtrOutput {
	return i.ToLanguageCodesSetPtrOutputWithContext(context.Background())
}

func (i LanguageCodesSetArgs) ToLanguageCodesSetPtrOutputWithContext(ctx context.Context) LanguageCodesSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LanguageCodesSetOutput).ToLanguageCodesSetPtrOutputWithContext(ctx)
}

// LanguageCodesSetPtrInput is an input type that accepts LanguageCodesSetArgs, LanguageCodesSetPtr and LanguageCodesSetPtrOutput values.
// You can construct a concrete instance of `LanguageCodesSetPtrInput` via:
//
//          LanguageCodesSetArgs{...}
//
//  or:
//
//          nil
type LanguageCodesSetPtrInput interface {
	pulumi.Input

	ToLanguageCodesSetPtrOutput() LanguageCodesSetPtrOutput
	ToLanguageCodesSetPtrOutputWithContext(context.Context) LanguageCodesSetPtrOutput
}

type languageCodesSetPtrType LanguageCodesSetArgs

func LanguageCodesSetPtr(v *LanguageCodesSetArgs) LanguageCodesSetPtrInput {
	return (*languageCodesSetPtrType)(v)
}

func (*languageCodesSetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LanguageCodesSet)(nil)).Elem()
}

func (i *languageCodesSetPtrType) ToLanguageCodesSetPtrOutput() LanguageCodesSetPtrOutput {
	return i.ToLanguageCodesSetPtrOutputWithContext(context.Background())
}

func (i *languageCodesSetPtrType) ToLanguageCodesSetPtrOutputWithContext(ctx context.Context) LanguageCodesSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LanguageCodesSetPtrOutput)
}

// Used with equivalent term set glossaries.
type LanguageCodesSetOutput struct{ *pulumi.OutputState }

func (LanguageCodesSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LanguageCodesSet)(nil)).Elem()
}

func (o LanguageCodesSetOutput) ToLanguageCodesSetOutput() LanguageCodesSetOutput {
	return o
}

func (o LanguageCodesSetOutput) ToLanguageCodesSetOutputWithContext(ctx context.Context) LanguageCodesSetOutput {
	return o
}

func (o LanguageCodesSetOutput) ToLanguageCodesSetPtrOutput() LanguageCodesSetPtrOutput {
	return o.ToLanguageCodesSetPtrOutputWithContext(context.Background())
}

func (o LanguageCodesSetOutput) ToLanguageCodesSetPtrOutputWithContext(ctx context.Context) LanguageCodesSetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LanguageCodesSet) *LanguageCodesSet {
		return &v
	}).(LanguageCodesSetPtrOutput)
}

// The BCP-47 language code(s) for terms defined in the glossary. All entries are unique. The list contains at least two entries. Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodesSetOutput) LanguageCodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LanguageCodesSet) []string { return v.LanguageCodes }).(pulumi.StringArrayOutput)
}

type LanguageCodesSetPtrOutput struct{ *pulumi.OutputState }

func (LanguageCodesSetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LanguageCodesSet)(nil)).Elem()
}

func (o LanguageCodesSetPtrOutput) ToLanguageCodesSetPtrOutput() LanguageCodesSetPtrOutput {
	return o
}

func (o LanguageCodesSetPtrOutput) ToLanguageCodesSetPtrOutputWithContext(ctx context.Context) LanguageCodesSetPtrOutput {
	return o
}

func (o LanguageCodesSetPtrOutput) Elem() LanguageCodesSetOutput {
	return o.ApplyT(func(v *LanguageCodesSet) LanguageCodesSet {
		if v != nil {
			return *v
		}
		var ret LanguageCodesSet
		return ret
	}).(LanguageCodesSetOutput)
}

// The BCP-47 language code(s) for terms defined in the glossary. All entries are unique. The list contains at least two entries. Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodesSetPtrOutput) LanguageCodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LanguageCodesSet) []string {
		if v == nil {
			return nil
		}
		return v.LanguageCodes
	}).(pulumi.StringArrayOutput)
}

// Used with equivalent term set glossaries.
type LanguageCodesSetResponse struct {
	// The BCP-47 language code(s) for terms defined in the glossary. All entries are unique. The list contains at least two entries. Expected to be an exact match for GlossaryTerm.language_code.
	LanguageCodes []string `pulumi:"languageCodes"`
}

// Used with equivalent term set glossaries.
type LanguageCodesSetResponseOutput struct{ *pulumi.OutputState }

func (LanguageCodesSetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LanguageCodesSetResponse)(nil)).Elem()
}

func (o LanguageCodesSetResponseOutput) ToLanguageCodesSetResponseOutput() LanguageCodesSetResponseOutput {
	return o
}

func (o LanguageCodesSetResponseOutput) ToLanguageCodesSetResponseOutputWithContext(ctx context.Context) LanguageCodesSetResponseOutput {
	return o
}

// The BCP-47 language code(s) for terms defined in the glossary. All entries are unique. The list contains at least two entries. Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodesSetResponseOutput) LanguageCodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LanguageCodesSetResponse) []string { return v.LanguageCodes }).(pulumi.StringArrayOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GcsSourceInput)(nil)).Elem(), GcsSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GlossaryInputConfigInput)(nil)).Elem(), GlossaryInputConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LanguageCodePairInput)(nil)).Elem(), LanguageCodePairArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LanguageCodePairPtrInput)(nil)).Elem(), LanguageCodePairArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LanguageCodesSetInput)(nil)).Elem(), LanguageCodesSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LanguageCodesSetPtrInput)(nil)).Elem(), LanguageCodesSetArgs{})
	pulumi.RegisterOutputType(GcsSourceOutput{})
	pulumi.RegisterOutputType(GcsSourceResponseOutput{})
	pulumi.RegisterOutputType(GlossaryInputConfigOutput{})
	pulumi.RegisterOutputType(GlossaryInputConfigResponseOutput{})
	pulumi.RegisterOutputType(LanguageCodePairOutput{})
	pulumi.RegisterOutputType(LanguageCodePairPtrOutput{})
	pulumi.RegisterOutputType(LanguageCodePairResponseOutput{})
	pulumi.RegisterOutputType(LanguageCodesSetOutput{})
	pulumi.RegisterOutputType(LanguageCodesSetPtrOutput{})
	pulumi.RegisterOutputType(LanguageCodesSetResponseOutput{})
}

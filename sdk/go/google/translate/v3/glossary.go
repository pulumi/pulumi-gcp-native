// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v3

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates a glossary and returns the long-running operation. Returns NOT_FOUND, if the project doesn't exist.
type Glossary struct {
	pulumi.CustomResourceState

	// Optional. The display name of the glossary.
	DisplayName pulumi.StringOutput `pulumi:"displayName"`
	// When the glossary creation was finished.
	EndTime pulumi.StringOutput `pulumi:"endTime"`
	// The number of entries defined in the glossary.
	EntryCount pulumi.IntOutput `pulumi:"entryCount"`
	// Provides examples to build the glossary from. Total glossary must not exceed 10M Unicode codepoints.
	InputConfig GlossaryInputConfigResponseOutput `pulumi:"inputConfig"`
	// Used with equivalent term set glossaries.
	LanguageCodesSet LanguageCodesSetResponseOutput `pulumi:"languageCodesSet"`
	// Used with unidirectional glossaries.
	LanguagePair LanguageCodePairResponseOutput `pulumi:"languagePair"`
	Location     pulumi.StringOutput            `pulumi:"location"`
	// The resource name of the glossary. Glossary names have the form `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`.
	Name    pulumi.StringOutput `pulumi:"name"`
	Project pulumi.StringOutput `pulumi:"project"`
	// When CreateGlossary was called.
	SubmitTime pulumi.StringOutput `pulumi:"submitTime"`
}

// NewGlossary registers a new resource with the given unique name, arguments, and options.
func NewGlossary(ctx *pulumi.Context,
	name string, args *GlossaryArgs, opts ...pulumi.ResourceOption) (*Glossary, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InputConfig == nil {
		return nil, errors.New("invalid value for required argument 'InputConfig'")
	}
	replaceOnChanges := pulumi.ReplaceOnChanges([]string{
		"location",
		"project",
	})
	opts = append(opts, replaceOnChanges)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Glossary
	err := ctx.RegisterResource("google-native:translate/v3:Glossary", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGlossary gets an existing Glossary resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGlossary(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GlossaryState, opts ...pulumi.ResourceOption) (*Glossary, error) {
	var resource Glossary
	err := ctx.ReadResource("google-native:translate/v3:Glossary", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Glossary resources.
type glossaryState struct {
}

type GlossaryState struct {
}

func (GlossaryState) ElementType() reflect.Type {
	return reflect.TypeOf((*glossaryState)(nil)).Elem()
}

type glossaryArgs struct {
	// Optional. The display name of the glossary.
	DisplayName *string `pulumi:"displayName"`
	// Provides examples to build the glossary from. Total glossary must not exceed 10M Unicode codepoints.
	InputConfig GlossaryInputConfig `pulumi:"inputConfig"`
	// Used with equivalent term set glossaries.
	LanguageCodesSet *LanguageCodesSet `pulumi:"languageCodesSet"`
	// Used with unidirectional glossaries.
	LanguagePair *LanguageCodePair `pulumi:"languagePair"`
	Location     *string           `pulumi:"location"`
	// The resource name of the glossary. Glossary names have the form `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`.
	Name    *string `pulumi:"name"`
	Project *string `pulumi:"project"`
}

// The set of arguments for constructing a Glossary resource.
type GlossaryArgs struct {
	// Optional. The display name of the glossary.
	DisplayName pulumi.StringPtrInput
	// Provides examples to build the glossary from. Total glossary must not exceed 10M Unicode codepoints.
	InputConfig GlossaryInputConfigInput
	// Used with equivalent term set glossaries.
	LanguageCodesSet LanguageCodesSetPtrInput
	// Used with unidirectional glossaries.
	LanguagePair LanguageCodePairPtrInput
	Location     pulumi.StringPtrInput
	// The resource name of the glossary. Glossary names have the form `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`.
	Name    pulumi.StringPtrInput
	Project pulumi.StringPtrInput
}

func (GlossaryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*glossaryArgs)(nil)).Elem()
}

type GlossaryInput interface {
	pulumi.Input

	ToGlossaryOutput() GlossaryOutput
	ToGlossaryOutputWithContext(ctx context.Context) GlossaryOutput
}

func (*Glossary) ElementType() reflect.Type {
	return reflect.TypeOf((**Glossary)(nil)).Elem()
}

func (i *Glossary) ToGlossaryOutput() GlossaryOutput {
	return i.ToGlossaryOutputWithContext(context.Background())
}

func (i *Glossary) ToGlossaryOutputWithContext(ctx context.Context) GlossaryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GlossaryOutput)
}

type GlossaryOutput struct{ *pulumi.OutputState }

func (GlossaryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Glossary)(nil)).Elem()
}

func (o GlossaryOutput) ToGlossaryOutput() GlossaryOutput {
	return o
}

func (o GlossaryOutput) ToGlossaryOutputWithContext(ctx context.Context) GlossaryOutput {
	return o
}

// Optional. The display name of the glossary.
func (o GlossaryOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v *Glossary) pulumi.StringOutput { return v.DisplayName }).(pulumi.StringOutput)
}

// When the glossary creation was finished.
func (o GlossaryOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Glossary) pulumi.StringOutput { return v.EndTime }).(pulumi.StringOutput)
}

// The number of entries defined in the glossary.
func (o GlossaryOutput) EntryCount() pulumi.IntOutput {
	return o.ApplyT(func(v *Glossary) pulumi.IntOutput { return v.EntryCount }).(pulumi.IntOutput)
}

// Provides examples to build the glossary from. Total glossary must not exceed 10M Unicode codepoints.
func (o GlossaryOutput) InputConfig() GlossaryInputConfigResponseOutput {
	return o.ApplyT(func(v *Glossary) GlossaryInputConfigResponseOutput { return v.InputConfig }).(GlossaryInputConfigResponseOutput)
}

// Used with equivalent term set glossaries.
func (o GlossaryOutput) LanguageCodesSet() LanguageCodesSetResponseOutput {
	return o.ApplyT(func(v *Glossary) LanguageCodesSetResponseOutput { return v.LanguageCodesSet }).(LanguageCodesSetResponseOutput)
}

// Used with unidirectional glossaries.
func (o GlossaryOutput) LanguagePair() LanguageCodePairResponseOutput {
	return o.ApplyT(func(v *Glossary) LanguageCodePairResponseOutput { return v.LanguagePair }).(LanguageCodePairResponseOutput)
}

func (o GlossaryOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *Glossary) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// The resource name of the glossary. Glossary names have the form `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`.
func (o GlossaryOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Glossary) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o GlossaryOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Glossary) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// When CreateGlossary was called.
func (o GlossaryOutput) SubmitTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Glossary) pulumi.StringOutput { return v.SubmitTime }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GlossaryInput)(nil)).Elem(), &Glossary{})
	pulumi.RegisterOutputType(GlossaryOutput{})
}

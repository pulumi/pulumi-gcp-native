// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates a spoke in the specified project and location.
type Spoke struct {
	pulumi.CustomResourceState

	// The time the spoke was created.
	CreateTime pulumi.StringOutput `pulumi:"createTime"`
	// An optional description of the spoke.
	Description pulumi.StringOutput `pulumi:"description"`
	// Immutable. The name of the hub that this spoke is attached to.
	Hub pulumi.StringOutput `pulumi:"hub"`
	// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// VLAN attachments that are associated with the spoke.
	LinkedInterconnectAttachments LinkedInterconnectAttachmentsResponseOutput `pulumi:"linkedInterconnectAttachments"`
	// Router appliance instances that are associated with the spoke.
	LinkedRouterApplianceInstances LinkedRouterApplianceInstancesResponseOutput `pulumi:"linkedRouterApplianceInstances"`
	// VPN tunnels that are associated with the spoke.
	LinkedVpnTunnels LinkedVpnTunnelsResponseOutput `pulumi:"linkedVpnTunnels"`
	Location         pulumi.StringOutput            `pulumi:"location"`
	// Immutable. The name of the spoke. Spoke names must be unique. They use the following form: `projects/{project_number}/locations/{region}/spokes/{spoke_id}`
	Name    pulumi.StringOutput `pulumi:"name"`
	Project pulumi.StringOutput `pulumi:"project"`
	// Optional. A unique request ID (optional). If you specify this ID, you can use it in cases when you need to retry your request. When you need to retry, this ID lets the server know that it can ignore the request if it has already been completed. The server guarantees that for at least 60 minutes after the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check to see whether the original operation was received. If it was, the server ignores the second request. This behavior prevents clients from mistakenly creating duplicate commitments. The request ID must be a valid UUID, with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
	RequestId pulumi.StringPtrOutput `pulumi:"requestId"`
	// Required. Unique id for the spoke to create.
	SpokeId pulumi.StringOutput `pulumi:"spokeId"`
	// The current lifecycle state of this spoke.
	State pulumi.StringOutput `pulumi:"state"`
	// The Google-generated UUID for the spoke. This value is unique across all spoke resources. If a spoke is deleted and another with the same name is created, the new spoke is assigned a different unique_id.
	UniqueId pulumi.StringOutput `pulumi:"uniqueId"`
	// The time the spoke was last updated.
	UpdateTime pulumi.StringOutput `pulumi:"updateTime"`
}

// NewSpoke registers a new resource with the given unique name, arguments, and options.
func NewSpoke(ctx *pulumi.Context,
	name string, args *SpokeArgs, opts ...pulumi.ResourceOption) (*Spoke, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.SpokeId == nil {
		return nil, errors.New("invalid value for required argument 'SpokeId'")
	}
	replaceOnChanges := pulumi.ReplaceOnChanges([]string{
		"location",
		"project",
		"spokeId",
	})
	opts = append(opts, replaceOnChanges)
	var resource Spoke
	err := ctx.RegisterResource("google-native:networkconnectivity/v1:Spoke", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSpoke gets an existing Spoke resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSpoke(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SpokeState, opts ...pulumi.ResourceOption) (*Spoke, error) {
	var resource Spoke
	err := ctx.ReadResource("google-native:networkconnectivity/v1:Spoke", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Spoke resources.
type spokeState struct {
}

type SpokeState struct {
}

func (SpokeState) ElementType() reflect.Type {
	return reflect.TypeOf((*spokeState)(nil)).Elem()
}

type spokeArgs struct {
	// An optional description of the spoke.
	Description *string `pulumi:"description"`
	// Immutable. The name of the hub that this spoke is attached to.
	Hub *string `pulumi:"hub"`
	// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
	Labels map[string]string `pulumi:"labels"`
	// VLAN attachments that are associated with the spoke.
	LinkedInterconnectAttachments *LinkedInterconnectAttachments `pulumi:"linkedInterconnectAttachments"`
	// Router appliance instances that are associated with the spoke.
	LinkedRouterApplianceInstances *LinkedRouterApplianceInstances `pulumi:"linkedRouterApplianceInstances"`
	// VPN tunnels that are associated with the spoke.
	LinkedVpnTunnels *LinkedVpnTunnels `pulumi:"linkedVpnTunnels"`
	Location         *string           `pulumi:"location"`
	// Immutable. The name of the spoke. Spoke names must be unique. They use the following form: `projects/{project_number}/locations/{region}/spokes/{spoke_id}`
	Name    *string `pulumi:"name"`
	Project *string `pulumi:"project"`
	// Optional. A unique request ID (optional). If you specify this ID, you can use it in cases when you need to retry your request. When you need to retry, this ID lets the server know that it can ignore the request if it has already been completed. The server guarantees that for at least 60 minutes after the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check to see whether the original operation was received. If it was, the server ignores the second request. This behavior prevents clients from mistakenly creating duplicate commitments. The request ID must be a valid UUID, with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
	RequestId *string `pulumi:"requestId"`
	// Required. Unique id for the spoke to create.
	SpokeId string `pulumi:"spokeId"`
}

// The set of arguments for constructing a Spoke resource.
type SpokeArgs struct {
	// An optional description of the spoke.
	Description pulumi.StringPtrInput
	// Immutable. The name of the hub that this spoke is attached to.
	Hub pulumi.StringPtrInput
	// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
	Labels pulumi.StringMapInput
	// VLAN attachments that are associated with the spoke.
	LinkedInterconnectAttachments LinkedInterconnectAttachmentsPtrInput
	// Router appliance instances that are associated with the spoke.
	LinkedRouterApplianceInstances LinkedRouterApplianceInstancesPtrInput
	// VPN tunnels that are associated with the spoke.
	LinkedVpnTunnels LinkedVpnTunnelsPtrInput
	Location         pulumi.StringPtrInput
	// Immutable. The name of the spoke. Spoke names must be unique. They use the following form: `projects/{project_number}/locations/{region}/spokes/{spoke_id}`
	Name    pulumi.StringPtrInput
	Project pulumi.StringPtrInput
	// Optional. A unique request ID (optional). If you specify this ID, you can use it in cases when you need to retry your request. When you need to retry, this ID lets the server know that it can ignore the request if it has already been completed. The server guarantees that for at least 60 minutes after the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check to see whether the original operation was received. If it was, the server ignores the second request. This behavior prevents clients from mistakenly creating duplicate commitments. The request ID must be a valid UUID, with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
	RequestId pulumi.StringPtrInput
	// Required. Unique id for the spoke to create.
	SpokeId pulumi.StringInput
}

func (SpokeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*spokeArgs)(nil)).Elem()
}

type SpokeInput interface {
	pulumi.Input

	ToSpokeOutput() SpokeOutput
	ToSpokeOutputWithContext(ctx context.Context) SpokeOutput
}

func (*Spoke) ElementType() reflect.Type {
	return reflect.TypeOf((**Spoke)(nil)).Elem()
}

func (i *Spoke) ToSpokeOutput() SpokeOutput {
	return i.ToSpokeOutputWithContext(context.Background())
}

func (i *Spoke) ToSpokeOutputWithContext(ctx context.Context) SpokeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpokeOutput)
}

type SpokeOutput struct{ *pulumi.OutputState }

func (SpokeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Spoke)(nil)).Elem()
}

func (o SpokeOutput) ToSpokeOutput() SpokeOutput {
	return o
}

func (o SpokeOutput) ToSpokeOutputWithContext(ctx context.Context) SpokeOutput {
	return o
}

// The time the spoke was created.
func (o SpokeOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.CreateTime }).(pulumi.StringOutput)
}

// An optional description of the spoke.
func (o SpokeOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.Description }).(pulumi.StringOutput)
}

// Immutable. The name of the hub that this spoke is attached to.
func (o SpokeOutput) Hub() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.Hub }).(pulumi.StringOutput)
}

// Optional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
func (o SpokeOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// VLAN attachments that are associated with the spoke.
func (o SpokeOutput) LinkedInterconnectAttachments() LinkedInterconnectAttachmentsResponseOutput {
	return o.ApplyT(func(v *Spoke) LinkedInterconnectAttachmentsResponseOutput { return v.LinkedInterconnectAttachments }).(LinkedInterconnectAttachmentsResponseOutput)
}

// Router appliance instances that are associated with the spoke.
func (o SpokeOutput) LinkedRouterApplianceInstances() LinkedRouterApplianceInstancesResponseOutput {
	return o.ApplyT(func(v *Spoke) LinkedRouterApplianceInstancesResponseOutput { return v.LinkedRouterApplianceInstances }).(LinkedRouterApplianceInstancesResponseOutput)
}

// VPN tunnels that are associated with the spoke.
func (o SpokeOutput) LinkedVpnTunnels() LinkedVpnTunnelsResponseOutput {
	return o.ApplyT(func(v *Spoke) LinkedVpnTunnelsResponseOutput { return v.LinkedVpnTunnels }).(LinkedVpnTunnelsResponseOutput)
}

func (o SpokeOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// Immutable. The name of the spoke. Spoke names must be unique. They use the following form: `projects/{project_number}/locations/{region}/spokes/{spoke_id}`
func (o SpokeOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o SpokeOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// Optional. A unique request ID (optional). If you specify this ID, you can use it in cases when you need to retry your request. When you need to retry, this ID lets the server know that it can ignore the request if it has already been completed. The server guarantees that for at least 60 minutes after the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check to see whether the original operation was received. If it was, the server ignores the second request. This behavior prevents clients from mistakenly creating duplicate commitments. The request ID must be a valid UUID, with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
func (o SpokeOutput) RequestId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringPtrOutput { return v.RequestId }).(pulumi.StringPtrOutput)
}

// Required. Unique id for the spoke to create.
func (o SpokeOutput) SpokeId() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.SpokeId }).(pulumi.StringOutput)
}

// The current lifecycle state of this spoke.
func (o SpokeOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// The Google-generated UUID for the spoke. This value is unique across all spoke resources. If a spoke is deleted and another with the same name is created, the new spoke is assigned a different unique_id.
func (o SpokeOutput) UniqueId() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.UniqueId }).(pulumi.StringOutput)
}

// The time the spoke was last updated.
func (o SpokeOutput) UpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Spoke) pulumi.StringOutput { return v.UpdateTime }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SpokeInput)(nil)).Elem(), &Spoke{})
	pulumi.RegisterOutputType(SpokeOutput{})
}

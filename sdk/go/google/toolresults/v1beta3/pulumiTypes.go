// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta3

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

var _ = internal.GetEnvOrDefault

// Android app information.
type AndroidAppInfo struct {
	// The name of the app. Optional
	Name *string `pulumi:"name"`
	// The package name of the app. Required.
	PackageName *string `pulumi:"packageName"`
	// The internal version code of the app. Optional.
	VersionCode *string `pulumi:"versionCode"`
	// The version name of the app. Optional.
	VersionName *string `pulumi:"versionName"`
}

// AndroidAppInfoInput is an input type that accepts AndroidAppInfoArgs and AndroidAppInfoOutput values.
// You can construct a concrete instance of `AndroidAppInfoInput` via:
//
//	AndroidAppInfoArgs{...}
type AndroidAppInfoInput interface {
	pulumi.Input

	ToAndroidAppInfoOutput() AndroidAppInfoOutput
	ToAndroidAppInfoOutputWithContext(context.Context) AndroidAppInfoOutput
}

// Android app information.
type AndroidAppInfoArgs struct {
	// The name of the app. Optional
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The package name of the app. Required.
	PackageName pulumi.StringPtrInput `pulumi:"packageName"`
	// The internal version code of the app. Optional.
	VersionCode pulumi.StringPtrInput `pulumi:"versionCode"`
	// The version name of the app. Optional.
	VersionName pulumi.StringPtrInput `pulumi:"versionName"`
}

func (AndroidAppInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidAppInfo)(nil)).Elem()
}

func (i AndroidAppInfoArgs) ToAndroidAppInfoOutput() AndroidAppInfoOutput {
	return i.ToAndroidAppInfoOutputWithContext(context.Background())
}

func (i AndroidAppInfoArgs) ToAndroidAppInfoOutputWithContext(ctx context.Context) AndroidAppInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidAppInfoOutput)
}

func (i AndroidAppInfoArgs) ToOutput(ctx context.Context) pulumix.Output[AndroidAppInfo] {
	return pulumix.Output[AndroidAppInfo]{
		OutputState: i.ToAndroidAppInfoOutputWithContext(ctx).OutputState,
	}
}

func (i AndroidAppInfoArgs) ToAndroidAppInfoPtrOutput() AndroidAppInfoPtrOutput {
	return i.ToAndroidAppInfoPtrOutputWithContext(context.Background())
}

func (i AndroidAppInfoArgs) ToAndroidAppInfoPtrOutputWithContext(ctx context.Context) AndroidAppInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidAppInfoOutput).ToAndroidAppInfoPtrOutputWithContext(ctx)
}

// AndroidAppInfoPtrInput is an input type that accepts AndroidAppInfoArgs, AndroidAppInfoPtr and AndroidAppInfoPtrOutput values.
// You can construct a concrete instance of `AndroidAppInfoPtrInput` via:
//
//	        AndroidAppInfoArgs{...}
//
//	or:
//
//	        nil
type AndroidAppInfoPtrInput interface {
	pulumi.Input

	ToAndroidAppInfoPtrOutput() AndroidAppInfoPtrOutput
	ToAndroidAppInfoPtrOutputWithContext(context.Context) AndroidAppInfoPtrOutput
}

type androidAppInfoPtrType AndroidAppInfoArgs

func AndroidAppInfoPtr(v *AndroidAppInfoArgs) AndroidAppInfoPtrInput {
	return (*androidAppInfoPtrType)(v)
}

func (*androidAppInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AndroidAppInfo)(nil)).Elem()
}

func (i *androidAppInfoPtrType) ToAndroidAppInfoPtrOutput() AndroidAppInfoPtrOutput {
	return i.ToAndroidAppInfoPtrOutputWithContext(context.Background())
}

func (i *androidAppInfoPtrType) ToAndroidAppInfoPtrOutputWithContext(ctx context.Context) AndroidAppInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidAppInfoPtrOutput)
}

func (i *androidAppInfoPtrType) ToOutput(ctx context.Context) pulumix.Output[*AndroidAppInfo] {
	return pulumix.Output[*AndroidAppInfo]{
		OutputState: i.ToAndroidAppInfoPtrOutputWithContext(ctx).OutputState,
	}
}

// Android app information.
type AndroidAppInfoOutput struct{ *pulumi.OutputState }

func (AndroidAppInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidAppInfo)(nil)).Elem()
}

func (o AndroidAppInfoOutput) ToAndroidAppInfoOutput() AndroidAppInfoOutput {
	return o
}

func (o AndroidAppInfoOutput) ToAndroidAppInfoOutputWithContext(ctx context.Context) AndroidAppInfoOutput {
	return o
}

func (o AndroidAppInfoOutput) ToAndroidAppInfoPtrOutput() AndroidAppInfoPtrOutput {
	return o.ToAndroidAppInfoPtrOutputWithContext(context.Background())
}

func (o AndroidAppInfoOutput) ToAndroidAppInfoPtrOutputWithContext(ctx context.Context) AndroidAppInfoPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AndroidAppInfo) *AndroidAppInfo {
		return &v
	}).(AndroidAppInfoPtrOutput)
}

func (o AndroidAppInfoOutput) ToOutput(ctx context.Context) pulumix.Output[AndroidAppInfo] {
	return pulumix.Output[AndroidAppInfo]{
		OutputState: o.OutputState,
	}
}

// The name of the app. Optional
func (o AndroidAppInfoOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AndroidAppInfo) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The package name of the app. Required.
func (o AndroidAppInfoOutput) PackageName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AndroidAppInfo) *string { return v.PackageName }).(pulumi.StringPtrOutput)
}

// The internal version code of the app. Optional.
func (o AndroidAppInfoOutput) VersionCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AndroidAppInfo) *string { return v.VersionCode }).(pulumi.StringPtrOutput)
}

// The version name of the app. Optional.
func (o AndroidAppInfoOutput) VersionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AndroidAppInfo) *string { return v.VersionName }).(pulumi.StringPtrOutput)
}

type AndroidAppInfoPtrOutput struct{ *pulumi.OutputState }

func (AndroidAppInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AndroidAppInfo)(nil)).Elem()
}

func (o AndroidAppInfoPtrOutput) ToAndroidAppInfoPtrOutput() AndroidAppInfoPtrOutput {
	return o
}

func (o AndroidAppInfoPtrOutput) ToAndroidAppInfoPtrOutputWithContext(ctx context.Context) AndroidAppInfoPtrOutput {
	return o
}

func (o AndroidAppInfoPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*AndroidAppInfo] {
	return pulumix.Output[*AndroidAppInfo]{
		OutputState: o.OutputState,
	}
}

func (o AndroidAppInfoPtrOutput) Elem() AndroidAppInfoOutput {
	return o.ApplyT(func(v *AndroidAppInfo) AndroidAppInfo {
		if v != nil {
			return *v
		}
		var ret AndroidAppInfo
		return ret
	}).(AndroidAppInfoOutput)
}

// The name of the app. Optional
func (o AndroidAppInfoPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AndroidAppInfo) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// The package name of the app. Required.
func (o AndroidAppInfoPtrOutput) PackageName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AndroidAppInfo) *string {
		if v == nil {
			return nil
		}
		return v.PackageName
	}).(pulumi.StringPtrOutput)
}

// The internal version code of the app. Optional.
func (o AndroidAppInfoPtrOutput) VersionCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AndroidAppInfo) *string {
		if v == nil {
			return nil
		}
		return v.VersionCode
	}).(pulumi.StringPtrOutput)
}

// The version name of the app. Optional.
func (o AndroidAppInfoPtrOutput) VersionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AndroidAppInfo) *string {
		if v == nil {
			return nil
		}
		return v.VersionName
	}).(pulumi.StringPtrOutput)
}

// Android app information.
type AndroidAppInfoResponse struct {
	// The name of the app. Optional
	Name string `pulumi:"name"`
	// The package name of the app. Required.
	PackageName string `pulumi:"packageName"`
	// The internal version code of the app. Optional.
	VersionCode string `pulumi:"versionCode"`
	// The version name of the app. Optional.
	VersionName string `pulumi:"versionName"`
}

// Android app information.
type AndroidAppInfoResponseOutput struct{ *pulumi.OutputState }

func (AndroidAppInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidAppInfoResponse)(nil)).Elem()
}

func (o AndroidAppInfoResponseOutput) ToAndroidAppInfoResponseOutput() AndroidAppInfoResponseOutput {
	return o
}

func (o AndroidAppInfoResponseOutput) ToAndroidAppInfoResponseOutputWithContext(ctx context.Context) AndroidAppInfoResponseOutput {
	return o
}

func (o AndroidAppInfoResponseOutput) ToOutput(ctx context.Context) pulumix.Output[AndroidAppInfoResponse] {
	return pulumix.Output[AndroidAppInfoResponse]{
		OutputState: o.OutputState,
	}
}

// The name of the app. Optional
func (o AndroidAppInfoResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v AndroidAppInfoResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The package name of the app. Required.
func (o AndroidAppInfoResponseOutput) PackageName() pulumi.StringOutput {
	return o.ApplyT(func(v AndroidAppInfoResponse) string { return v.PackageName }).(pulumi.StringOutput)
}

// The internal version code of the app. Optional.
func (o AndroidAppInfoResponseOutput) VersionCode() pulumi.StringOutput {
	return o.ApplyT(func(v AndroidAppInfoResponse) string { return v.VersionCode }).(pulumi.StringOutput)
}

// The version name of the app. Optional.
func (o AndroidAppInfoResponseOutput) VersionName() pulumi.StringOutput {
	return o.ApplyT(func(v AndroidAppInfoResponse) string { return v.VersionName }).(pulumi.StringOutput)
}

// A test of an Android application that can control an Android component independently of its normal lifecycle. See for more information on types of Android tests.
type AndroidInstrumentationTest struct {
	// The java package for the test to be executed. Required
	TestPackageId *string `pulumi:"testPackageId"`
	// The InstrumentationTestRunner class. Required
	TestRunnerClass *string `pulumi:"testRunnerClass"`
	// Each target must be fully qualified with the package name or class name, in one of these formats: - "package package_name" - "class package_name.class_name" - "class package_name.class_name#method_name" If empty, all targets in the module will be run.
	TestTargets []string `pulumi:"testTargets"`
	// The flag indicates whether Android Test Orchestrator will be used to run test or not.
	UseOrchestrator *bool `pulumi:"useOrchestrator"`
}

// AndroidInstrumentationTestInput is an input type that accepts AndroidInstrumentationTestArgs and AndroidInstrumentationTestOutput values.
// You can construct a concrete instance of `AndroidInstrumentationTestInput` via:
//
//	AndroidInstrumentationTestArgs{...}
type AndroidInstrumentationTestInput interface {
	pulumi.Input

	ToAndroidInstrumentationTestOutput() AndroidInstrumentationTestOutput
	ToAndroidInstrumentationTestOutputWithContext(context.Context) AndroidInstrumentationTestOutput
}

// A test of an Android application that can control an Android component independently of its normal lifecycle. See for more information on types of Android tests.
type AndroidInstrumentationTestArgs struct {
	// The java package for the test to be executed. Required
	TestPackageId pulumi.StringPtrInput `pulumi:"testPackageId"`
	// The InstrumentationTestRunner class. Required
	TestRunnerClass pulumi.StringPtrInput `pulumi:"testRunnerClass"`
	// Each target must be fully qualified with the package name or class name, in one of these formats: - "package package_name" - "class package_name.class_name" - "class package_name.class_name#method_name" If empty, all targets in the module will be run.
	TestTargets pulumi.StringArrayInput `pulumi:"testTargets"`
	// The flag indicates whether Android Test Orchestrator will be used to run test or not.
	UseOrchestrator pulumi.BoolPtrInput `pulumi:"useOrchestrator"`
}

func (AndroidInstrumentationTestArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidInstrumentationTest)(nil)).Elem()
}

func (i AndroidInstrumentationTestArgs) ToAndroidInstrumentationTestOutput() AndroidInstrumentationTestOutput {
	return i.ToAndroidInstrumentationTestOutputWithContext(context.Background())
}

func (i AndroidInstrumentationTestArgs) ToAndroidInstrumentationTestOutputWithContext(ctx context.Context) AndroidInstrumentationTestOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidInstrumentationTestOutput)
}

func (i AndroidInstrumentationTestArgs) ToOutput(ctx context.Context) pulumix.Output[AndroidInstrumentationTest] {
	return pulumix.Output[AndroidInstrumentationTest]{
		OutputState: i.ToAndroidInstrumentationTestOutputWithContext(ctx).OutputState,
	}
}

func (i AndroidInstrumentationTestArgs) ToAndroidInstrumentationTestPtrOutput() AndroidInstrumentationTestPtrOutput {
	return i.ToAndroidInstrumentationTestPtrOutputWithContext(context.Background())
}

func (i AndroidInstrumentationTestArgs) ToAndroidInstrumentationTestPtrOutputWithContext(ctx context.Context) AndroidInstrumentationTestPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidInstrumentationTestOutput).ToAndroidInstrumentationTestPtrOutputWithContext(ctx)
}

// AndroidInstrumentationTestPtrInput is an input type that accepts AndroidInstrumentationTestArgs, AndroidInstrumentationTestPtr and AndroidInstrumentationTestPtrOutput values.
// You can construct a concrete instance of `AndroidInstrumentationTestPtrInput` via:
//
//	        AndroidInstrumentationTestArgs{...}
//
//	or:
//
//	        nil
type AndroidInstrumentationTestPtrInput interface {
	pulumi.Input

	ToAndroidInstrumentationTestPtrOutput() AndroidInstrumentationTestPtrOutput
	ToAndroidInstrumentationTestPtrOutputWithContext(context.Context) AndroidInstrumentationTestPtrOutput
}

type androidInstrumentationTestPtrType AndroidInstrumentationTestArgs

func AndroidInstrumentationTestPtr(v *AndroidInstrumentationTestArgs) AndroidInstrumentationTestPtrInput {
	return (*androidInstrumentationTestPtrType)(v)
}

func (*androidInstrumentationTestPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AndroidInstrumentationTest)(nil)).Elem()
}

func (i *androidInstrumentationTestPtrType) ToAndroidInstrumentationTestPtrOutput() AndroidInstrumentationTestPtrOutput {
	return i.ToAndroidInstrumentationTestPtrOutputWithContext(context.Background())
}

func (i *androidInstrumentationTestPtrType) ToAndroidInstrumentationTestPtrOutputWithContext(ctx context.Context) AndroidInstrumentationTestPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidInstrumentationTestPtrOutput)
}

func (i *androidInstrumentationTestPtrType) ToOutput(ctx context.Context) pulumix.Output[*AndroidInstrumentationTest] {
	return pulumix.Output[*AndroidInstrumentationTest]{
		OutputState: i.ToAndroidInstrumentationTestPtrOutputWithContext(ctx).OutputState,
	}
}

// A test of an Android application that can control an Android component independently of its normal lifecycle. See for more information on types of Android tests.
type AndroidInstrumentationTestOutput struct{ *pulumi.OutputState }

func (AndroidInstrumentationTestOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidInstrumentationTest)(nil)).Elem()
}

func (o AndroidInstrumentationTestOutput) ToAndroidInstrumentationTestOutput() AndroidInstrumentationTestOutput {
	return o
}

func (o AndroidInstrumentationTestOutput) ToAndroidInstrumentationTestOutputWithContext(ctx context.Context) AndroidInstrumentationTestOutput {
	return o
}

func (o AndroidInstrumentationTestOutput) ToAndroidInstrumentationTestPtrOutput() AndroidInstrumentationTestPtrOutput {
	return o.ToAndroidInstrumentationTestPtrOutputWithContext(context.Background())
}

func (o AndroidInstrumentationTestOutput) ToAndroidInstrumentationTestPtrOutputWithContext(ctx context.Context) AndroidInstrumentationTestPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AndroidInstrumentationTest) *AndroidInstrumentationTest {
		return &v
	}).(AndroidInstrumentationTestPtrOutput)
}

func (o AndroidInstrumentationTestOutput) ToOutput(ctx context.Context) pulumix.Output[AndroidInstrumentationTest] {
	return pulumix.Output[AndroidInstrumentationTest]{
		OutputState: o.OutputState,
	}
}

// The java package for the test to be executed. Required
func (o AndroidInstrumentationTestOutput) TestPackageId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AndroidInstrumentationTest) *string { return v.TestPackageId }).(pulumi.StringPtrOutput)
}

// The InstrumentationTestRunner class. Required
func (o AndroidInstrumentationTestOutput) TestRunnerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AndroidInstrumentationTest) *string { return v.TestRunnerClass }).(pulumi.StringPtrOutput)
}

// Each target must be fully qualified with the package name or class name, in one of these formats: - "package package_name" - "class package_name.class_name" - "class package_name.class_name#method_name" If empty, all targets in the module will be run.
func (o AndroidInstrumentationTestOutput) TestTargets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AndroidInstrumentationTest) []string { return v.TestTargets }).(pulumi.StringArrayOutput)
}

// The flag indicates whether Android Test Orchestrator will be used to run test or not.
func (o AndroidInstrumentationTestOutput) UseOrchestrator() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v AndroidInstrumentationTest) *bool { return v.UseOrchestrator }).(pulumi.BoolPtrOutput)
}

type AndroidInstrumentationTestPtrOutput struct{ *pulumi.OutputState }

func (AndroidInstrumentationTestPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AndroidInstrumentationTest)(nil)).Elem()
}

func (o AndroidInstrumentationTestPtrOutput) ToAndroidInstrumentationTestPtrOutput() AndroidInstrumentationTestPtrOutput {
	return o
}

func (o AndroidInstrumentationTestPtrOutput) ToAndroidInstrumentationTestPtrOutputWithContext(ctx context.Context) AndroidInstrumentationTestPtrOutput {
	return o
}

func (o AndroidInstrumentationTestPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*AndroidInstrumentationTest] {
	return pulumix.Output[*AndroidInstrumentationTest]{
		OutputState: o.OutputState,
	}
}

func (o AndroidInstrumentationTestPtrOutput) Elem() AndroidInstrumentationTestOutput {
	return o.ApplyT(func(v *AndroidInstrumentationTest) AndroidInstrumentationTest {
		if v != nil {
			return *v
		}
		var ret AndroidInstrumentationTest
		return ret
	}).(AndroidInstrumentationTestOutput)
}

// The java package for the test to be executed. Required
func (o AndroidInstrumentationTestPtrOutput) TestPackageId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AndroidInstrumentationTest) *string {
		if v == nil {
			return nil
		}
		return v.TestPackageId
	}).(pulumi.StringPtrOutput)
}

// The InstrumentationTestRunner class. Required
func (o AndroidInstrumentationTestPtrOutput) TestRunnerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AndroidInstrumentationTest) *string {
		if v == nil {
			return nil
		}
		return v.TestRunnerClass
	}).(pulumi.StringPtrOutput)
}

// Each target must be fully qualified with the package name or class name, in one of these formats: - "package package_name" - "class package_name.class_name" - "class package_name.class_name#method_name" If empty, all targets in the module will be run.
func (o AndroidInstrumentationTestPtrOutput) TestTargets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AndroidInstrumentationTest) []string {
		if v == nil {
			return nil
		}
		return v.TestTargets
	}).(pulumi.StringArrayOutput)
}

// The flag indicates whether Android Test Orchestrator will be used to run test or not.
func (o AndroidInstrumentationTestPtrOutput) UseOrchestrator() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AndroidInstrumentationTest) *bool {
		if v == nil {
			return nil
		}
		return v.UseOrchestrator
	}).(pulumi.BoolPtrOutput)
}

// A test of an Android application that can control an Android component independently of its normal lifecycle. See for more information on types of Android tests.
type AndroidInstrumentationTestResponse struct {
	// The java package for the test to be executed. Required
	TestPackageId string `pulumi:"testPackageId"`
	// The InstrumentationTestRunner class. Required
	TestRunnerClass string `pulumi:"testRunnerClass"`
	// Each target must be fully qualified with the package name or class name, in one of these formats: - "package package_name" - "class package_name.class_name" - "class package_name.class_name#method_name" If empty, all targets in the module will be run.
	TestTargets []string `pulumi:"testTargets"`
	// The flag indicates whether Android Test Orchestrator will be used to run test or not.
	UseOrchestrator bool `pulumi:"useOrchestrator"`
}

// A test of an Android application that can control an Android component independently of its normal lifecycle. See for more information on types of Android tests.
type AndroidInstrumentationTestResponseOutput struct{ *pulumi.OutputState }

func (AndroidInstrumentationTestResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidInstrumentationTestResponse)(nil)).Elem()
}

func (o AndroidInstrumentationTestResponseOutput) ToAndroidInstrumentationTestResponseOutput() AndroidInstrumentationTestResponseOutput {
	return o
}

func (o AndroidInstrumentationTestResponseOutput) ToAndroidInstrumentationTestResponseOutputWithContext(ctx context.Context) AndroidInstrumentationTestResponseOutput {
	return o
}

func (o AndroidInstrumentationTestResponseOutput) ToOutput(ctx context.Context) pulumix.Output[AndroidInstrumentationTestResponse] {
	return pulumix.Output[AndroidInstrumentationTestResponse]{
		OutputState: o.OutputState,
	}
}

// The java package for the test to be executed. Required
func (o AndroidInstrumentationTestResponseOutput) TestPackageId() pulumi.StringOutput {
	return o.ApplyT(func(v AndroidInstrumentationTestResponse) string { return v.TestPackageId }).(pulumi.StringOutput)
}

// The InstrumentationTestRunner class. Required
func (o AndroidInstrumentationTestResponseOutput) TestRunnerClass() pulumi.StringOutput {
	return o.ApplyT(func(v AndroidInstrumentationTestResponse) string { return v.TestRunnerClass }).(pulumi.StringOutput)
}

// Each target must be fully qualified with the package name or class name, in one of these formats: - "package package_name" - "class package_name.class_name" - "class package_name.class_name#method_name" If empty, all targets in the module will be run.
func (o AndroidInstrumentationTestResponseOutput) TestTargets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AndroidInstrumentationTestResponse) []string { return v.TestTargets }).(pulumi.StringArrayOutput)
}

// The flag indicates whether Android Test Orchestrator will be used to run test or not.
func (o AndroidInstrumentationTestResponseOutput) UseOrchestrator() pulumi.BoolOutput {
	return o.ApplyT(func(v AndroidInstrumentationTestResponse) bool { return v.UseOrchestrator }).(pulumi.BoolOutput)
}

// A test of an android application that explores the application on a virtual or physical Android device, finding culprits and crashes as it goes.
type AndroidRoboTest struct {
	// The initial activity that should be used to start the app. Optional
	AppInitialActivity *string `pulumi:"appInitialActivity"`
	// The java package for the bootstrap. Optional
	BootstrapPackageId *string `pulumi:"bootstrapPackageId"`
	// The runner class for the bootstrap. Optional
	BootstrapRunnerClass *string `pulumi:"bootstrapRunnerClass"`
	// The max depth of the traversal stack Robo can explore. Optional
	MaxDepth *int `pulumi:"maxDepth"`
	// The max number of steps/actions Robo can execute. Default is no limit (0). Optional
	MaxSteps *int `pulumi:"maxSteps"`
}

// AndroidRoboTestInput is an input type that accepts AndroidRoboTestArgs and AndroidRoboTestOutput values.
// You can construct a concrete instance of `AndroidRoboTestInput` via:
//
//	AndroidRoboTestArgs{...}
type AndroidRoboTestInput interface {
	pulumi.Input

	ToAndroidRoboTestOutput() AndroidRoboTestOutput
	ToAndroidRoboTestOutputWithContext(context.Context) AndroidRoboTestOutput
}

// A test of an android application that explores the application on a virtual or physical Android device, finding culprits and crashes as it goes.
type AndroidRoboTestArgs struct {
	// The initial activity that should be used to start the app. Optional
	AppInitialActivity pulumi.StringPtrInput `pulumi:"appInitialActivity"`
	// The java package for the bootstrap. Optional
	BootstrapPackageId pulumi.StringPtrInput `pulumi:"bootstrapPackageId"`
	// The runner class for the bootstrap. Optional
	BootstrapRunnerClass pulumi.StringPtrInput `pulumi:"bootstrapRunnerClass"`
	// The max depth of the traversal stack Robo can explore. Optional
	MaxDepth pulumi.IntPtrInput `pulumi:"maxDepth"`
	// The max number of steps/actions Robo can execute. Default is no limit (0). Optional
	MaxSteps pulumi.IntPtrInput `pulumi:"maxSteps"`
}

func (AndroidRoboTestArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidRoboTest)(nil)).Elem()
}

func (i AndroidRoboTestArgs) ToAndroidRoboTestOutput() AndroidRoboTestOutput {
	return i.ToAndroidRoboTestOutputWithContext(context.Background())
}

func (i AndroidRoboTestArgs) ToAndroidRoboTestOutputWithContext(ctx context.Context) AndroidRoboTestOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidRoboTestOutput)
}

func (i AndroidRoboTestArgs) ToOutput(ctx context.Context) pulumix.Output[AndroidRoboTest] {
	return pulumix.Output[AndroidRoboTest]{
		OutputState: i.ToAndroidRoboTestOutputWithContext(ctx).OutputState,
	}
}

func (i AndroidRoboTestArgs) ToAndroidRoboTestPtrOutput() AndroidRoboTestPtrOutput {
	return i.ToAndroidRoboTestPtrOutputWithContext(context.Background())
}

func (i AndroidRoboTestArgs) ToAndroidRoboTestPtrOutputWithContext(ctx context.Context) AndroidRoboTestPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidRoboTestOutput).ToAndroidRoboTestPtrOutputWithContext(ctx)
}

// AndroidRoboTestPtrInput is an input type that accepts AndroidRoboTestArgs, AndroidRoboTestPtr and AndroidRoboTestPtrOutput values.
// You can construct a concrete instance of `AndroidRoboTestPtrInput` via:
//
//	        AndroidRoboTestArgs{...}
//
//	or:
//
//	        nil
type AndroidRoboTestPtrInput interface {
	pulumi.Input

	ToAndroidRoboTestPtrOutput() AndroidRoboTestPtrOutput
	ToAndroidRoboTestPtrOutputWithContext(context.Context) AndroidRoboTestPtrOutput
}

type androidRoboTestPtrType AndroidRoboTestArgs

func AndroidRoboTestPtr(v *AndroidRoboTestArgs) AndroidRoboTestPtrInput {
	return (*androidRoboTestPtrType)(v)
}

func (*androidRoboTestPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AndroidRoboTest)(nil)).Elem()
}

func (i *androidRoboTestPtrType) ToAndroidRoboTestPtrOutput() AndroidRoboTestPtrOutput {
	return i.ToAndroidRoboTestPtrOutputWithContext(context.Background())
}

func (i *androidRoboTestPtrType) ToAndroidRoboTestPtrOutputWithContext(ctx context.Context) AndroidRoboTestPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidRoboTestPtrOutput)
}

func (i *androidRoboTestPtrType) ToOutput(ctx context.Context) pulumix.Output[*AndroidRoboTest] {
	return pulumix.Output[*AndroidRoboTest]{
		OutputState: i.ToAndroidRoboTestPtrOutputWithContext(ctx).OutputState,
	}
}

// A test of an android application that explores the application on a virtual or physical Android device, finding culprits and crashes as it goes.
type AndroidRoboTestOutput struct{ *pulumi.OutputState }

func (AndroidRoboTestOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidRoboTest)(nil)).Elem()
}

func (o AndroidRoboTestOutput) ToAndroidRoboTestOutput() AndroidRoboTestOutput {
	return o
}

func (o AndroidRoboTestOutput) ToAndroidRoboTestOutputWithContext(ctx context.Context) AndroidRoboTestOutput {
	return o
}

func (o AndroidRoboTestOutput) ToAndroidRoboTestPtrOutput() AndroidRoboTestPtrOutput {
	return o.ToAndroidRoboTestPtrOutputWithContext(context.Background())
}

func (o AndroidRoboTestOutput) ToAndroidRoboTestPtrOutputWithContext(ctx context.Context) AndroidRoboTestPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AndroidRoboTest) *AndroidRoboTest {
		return &v
	}).(AndroidRoboTestPtrOutput)
}

func (o AndroidRoboTestOutput) ToOutput(ctx context.Context) pulumix.Output[AndroidRoboTest] {
	return pulumix.Output[AndroidRoboTest]{
		OutputState: o.OutputState,
	}
}

// The initial activity that should be used to start the app. Optional
func (o AndroidRoboTestOutput) AppInitialActivity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AndroidRoboTest) *string { return v.AppInitialActivity }).(pulumi.StringPtrOutput)
}

// The java package for the bootstrap. Optional
func (o AndroidRoboTestOutput) BootstrapPackageId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AndroidRoboTest) *string { return v.BootstrapPackageId }).(pulumi.StringPtrOutput)
}

// The runner class for the bootstrap. Optional
func (o AndroidRoboTestOutput) BootstrapRunnerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AndroidRoboTest) *string { return v.BootstrapRunnerClass }).(pulumi.StringPtrOutput)
}

// The max depth of the traversal stack Robo can explore. Optional
func (o AndroidRoboTestOutput) MaxDepth() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AndroidRoboTest) *int { return v.MaxDepth }).(pulumi.IntPtrOutput)
}

// The max number of steps/actions Robo can execute. Default is no limit (0). Optional
func (o AndroidRoboTestOutput) MaxSteps() pulumi.IntPtrOutput {
	return o.ApplyT(func(v AndroidRoboTest) *int { return v.MaxSteps }).(pulumi.IntPtrOutput)
}

type AndroidRoboTestPtrOutput struct{ *pulumi.OutputState }

func (AndroidRoboTestPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AndroidRoboTest)(nil)).Elem()
}

func (o AndroidRoboTestPtrOutput) ToAndroidRoboTestPtrOutput() AndroidRoboTestPtrOutput {
	return o
}

func (o AndroidRoboTestPtrOutput) ToAndroidRoboTestPtrOutputWithContext(ctx context.Context) AndroidRoboTestPtrOutput {
	return o
}

func (o AndroidRoboTestPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*AndroidRoboTest] {
	return pulumix.Output[*AndroidRoboTest]{
		OutputState: o.OutputState,
	}
}

func (o AndroidRoboTestPtrOutput) Elem() AndroidRoboTestOutput {
	return o.ApplyT(func(v *AndroidRoboTest) AndroidRoboTest {
		if v != nil {
			return *v
		}
		var ret AndroidRoboTest
		return ret
	}).(AndroidRoboTestOutput)
}

// The initial activity that should be used to start the app. Optional
func (o AndroidRoboTestPtrOutput) AppInitialActivity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AndroidRoboTest) *string {
		if v == nil {
			return nil
		}
		return v.AppInitialActivity
	}).(pulumi.StringPtrOutput)
}

// The java package for the bootstrap. Optional
func (o AndroidRoboTestPtrOutput) BootstrapPackageId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AndroidRoboTest) *string {
		if v == nil {
			return nil
		}
		return v.BootstrapPackageId
	}).(pulumi.StringPtrOutput)
}

// The runner class for the bootstrap. Optional
func (o AndroidRoboTestPtrOutput) BootstrapRunnerClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AndroidRoboTest) *string {
		if v == nil {
			return nil
		}
		return v.BootstrapRunnerClass
	}).(pulumi.StringPtrOutput)
}

// The max depth of the traversal stack Robo can explore. Optional
func (o AndroidRoboTestPtrOutput) MaxDepth() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AndroidRoboTest) *int {
		if v == nil {
			return nil
		}
		return v.MaxDepth
	}).(pulumi.IntPtrOutput)
}

// The max number of steps/actions Robo can execute. Default is no limit (0). Optional
func (o AndroidRoboTestPtrOutput) MaxSteps() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AndroidRoboTest) *int {
		if v == nil {
			return nil
		}
		return v.MaxSteps
	}).(pulumi.IntPtrOutput)
}

// A test of an android application that explores the application on a virtual or physical Android device, finding culprits and crashes as it goes.
type AndroidRoboTestResponse struct {
	// The initial activity that should be used to start the app. Optional
	AppInitialActivity string `pulumi:"appInitialActivity"`
	// The java package for the bootstrap. Optional
	BootstrapPackageId string `pulumi:"bootstrapPackageId"`
	// The runner class for the bootstrap. Optional
	BootstrapRunnerClass string `pulumi:"bootstrapRunnerClass"`
	// The max depth of the traversal stack Robo can explore. Optional
	MaxDepth int `pulumi:"maxDepth"`
	// The max number of steps/actions Robo can execute. Default is no limit (0). Optional
	MaxSteps int `pulumi:"maxSteps"`
}

// A test of an android application that explores the application on a virtual or physical Android device, finding culprits and crashes as it goes.
type AndroidRoboTestResponseOutput struct{ *pulumi.OutputState }

func (AndroidRoboTestResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidRoboTestResponse)(nil)).Elem()
}

func (o AndroidRoboTestResponseOutput) ToAndroidRoboTestResponseOutput() AndroidRoboTestResponseOutput {
	return o
}

func (o AndroidRoboTestResponseOutput) ToAndroidRoboTestResponseOutputWithContext(ctx context.Context) AndroidRoboTestResponseOutput {
	return o
}

func (o AndroidRoboTestResponseOutput) ToOutput(ctx context.Context) pulumix.Output[AndroidRoboTestResponse] {
	return pulumix.Output[AndroidRoboTestResponse]{
		OutputState: o.OutputState,
	}
}

// The initial activity that should be used to start the app. Optional
func (o AndroidRoboTestResponseOutput) AppInitialActivity() pulumi.StringOutput {
	return o.ApplyT(func(v AndroidRoboTestResponse) string { return v.AppInitialActivity }).(pulumi.StringOutput)
}

// The java package for the bootstrap. Optional
func (o AndroidRoboTestResponseOutput) BootstrapPackageId() pulumi.StringOutput {
	return o.ApplyT(func(v AndroidRoboTestResponse) string { return v.BootstrapPackageId }).(pulumi.StringOutput)
}

// The runner class for the bootstrap. Optional
func (o AndroidRoboTestResponseOutput) BootstrapRunnerClass() pulumi.StringOutput {
	return o.ApplyT(func(v AndroidRoboTestResponse) string { return v.BootstrapRunnerClass }).(pulumi.StringOutput)
}

// The max depth of the traversal stack Robo can explore. Optional
func (o AndroidRoboTestResponseOutput) MaxDepth() pulumi.IntOutput {
	return o.ApplyT(func(v AndroidRoboTestResponse) int { return v.MaxDepth }).(pulumi.IntOutput)
}

// The max number of steps/actions Robo can execute. Default is no limit (0). Optional
func (o AndroidRoboTestResponseOutput) MaxSteps() pulumi.IntOutput {
	return o.ApplyT(func(v AndroidRoboTestResponse) int { return v.MaxSteps }).(pulumi.IntOutput)
}

// An Android mobile test specification.
type AndroidTest struct {
	// Information about the application under test.
	AndroidAppInfo *AndroidAppInfo `pulumi:"androidAppInfo"`
	// An Android instrumentation test.
	AndroidInstrumentationTest *AndroidInstrumentationTest `pulumi:"androidInstrumentationTest"`
	// An Android robo test.
	AndroidRoboTest *AndroidRoboTest `pulumi:"androidRoboTest"`
	// An Android test loop.
	AndroidTestLoop *AndroidTestLoop `pulumi:"androidTestLoop"`
	// Max time a test is allowed to run before it is automatically cancelled.
	TestTimeout *Duration `pulumi:"testTimeout"`
}

// AndroidTestInput is an input type that accepts AndroidTestArgs and AndroidTestOutput values.
// You can construct a concrete instance of `AndroidTestInput` via:
//
//	AndroidTestArgs{...}
type AndroidTestInput interface {
	pulumi.Input

	ToAndroidTestOutput() AndroidTestOutput
	ToAndroidTestOutputWithContext(context.Context) AndroidTestOutput
}

// An Android mobile test specification.
type AndroidTestArgs struct {
	// Information about the application under test.
	AndroidAppInfo AndroidAppInfoPtrInput `pulumi:"androidAppInfo"`
	// An Android instrumentation test.
	AndroidInstrumentationTest AndroidInstrumentationTestPtrInput `pulumi:"androidInstrumentationTest"`
	// An Android robo test.
	AndroidRoboTest AndroidRoboTestPtrInput `pulumi:"androidRoboTest"`
	// An Android test loop.
	AndroidTestLoop AndroidTestLoopPtrInput `pulumi:"androidTestLoop"`
	// Max time a test is allowed to run before it is automatically cancelled.
	TestTimeout DurationPtrInput `pulumi:"testTimeout"`
}

func (AndroidTestArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidTest)(nil)).Elem()
}

func (i AndroidTestArgs) ToAndroidTestOutput() AndroidTestOutput {
	return i.ToAndroidTestOutputWithContext(context.Background())
}

func (i AndroidTestArgs) ToAndroidTestOutputWithContext(ctx context.Context) AndroidTestOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidTestOutput)
}

func (i AndroidTestArgs) ToOutput(ctx context.Context) pulumix.Output[AndroidTest] {
	return pulumix.Output[AndroidTest]{
		OutputState: i.ToAndroidTestOutputWithContext(ctx).OutputState,
	}
}

func (i AndroidTestArgs) ToAndroidTestPtrOutput() AndroidTestPtrOutput {
	return i.ToAndroidTestPtrOutputWithContext(context.Background())
}

func (i AndroidTestArgs) ToAndroidTestPtrOutputWithContext(ctx context.Context) AndroidTestPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidTestOutput).ToAndroidTestPtrOutputWithContext(ctx)
}

// AndroidTestPtrInput is an input type that accepts AndroidTestArgs, AndroidTestPtr and AndroidTestPtrOutput values.
// You can construct a concrete instance of `AndroidTestPtrInput` via:
//
//	        AndroidTestArgs{...}
//
//	or:
//
//	        nil
type AndroidTestPtrInput interface {
	pulumi.Input

	ToAndroidTestPtrOutput() AndroidTestPtrOutput
	ToAndroidTestPtrOutputWithContext(context.Context) AndroidTestPtrOutput
}

type androidTestPtrType AndroidTestArgs

func AndroidTestPtr(v *AndroidTestArgs) AndroidTestPtrInput {
	return (*androidTestPtrType)(v)
}

func (*androidTestPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AndroidTest)(nil)).Elem()
}

func (i *androidTestPtrType) ToAndroidTestPtrOutput() AndroidTestPtrOutput {
	return i.ToAndroidTestPtrOutputWithContext(context.Background())
}

func (i *androidTestPtrType) ToAndroidTestPtrOutputWithContext(ctx context.Context) AndroidTestPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidTestPtrOutput)
}

func (i *androidTestPtrType) ToOutput(ctx context.Context) pulumix.Output[*AndroidTest] {
	return pulumix.Output[*AndroidTest]{
		OutputState: i.ToAndroidTestPtrOutputWithContext(ctx).OutputState,
	}
}

// An Android mobile test specification.
type AndroidTestOutput struct{ *pulumi.OutputState }

func (AndroidTestOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidTest)(nil)).Elem()
}

func (o AndroidTestOutput) ToAndroidTestOutput() AndroidTestOutput {
	return o
}

func (o AndroidTestOutput) ToAndroidTestOutputWithContext(ctx context.Context) AndroidTestOutput {
	return o
}

func (o AndroidTestOutput) ToAndroidTestPtrOutput() AndroidTestPtrOutput {
	return o.ToAndroidTestPtrOutputWithContext(context.Background())
}

func (o AndroidTestOutput) ToAndroidTestPtrOutputWithContext(ctx context.Context) AndroidTestPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AndroidTest) *AndroidTest {
		return &v
	}).(AndroidTestPtrOutput)
}

func (o AndroidTestOutput) ToOutput(ctx context.Context) pulumix.Output[AndroidTest] {
	return pulumix.Output[AndroidTest]{
		OutputState: o.OutputState,
	}
}

// Information about the application under test.
func (o AndroidTestOutput) AndroidAppInfo() AndroidAppInfoPtrOutput {
	return o.ApplyT(func(v AndroidTest) *AndroidAppInfo { return v.AndroidAppInfo }).(AndroidAppInfoPtrOutput)
}

// An Android instrumentation test.
func (o AndroidTestOutput) AndroidInstrumentationTest() AndroidInstrumentationTestPtrOutput {
	return o.ApplyT(func(v AndroidTest) *AndroidInstrumentationTest { return v.AndroidInstrumentationTest }).(AndroidInstrumentationTestPtrOutput)
}

// An Android robo test.
func (o AndroidTestOutput) AndroidRoboTest() AndroidRoboTestPtrOutput {
	return o.ApplyT(func(v AndroidTest) *AndroidRoboTest { return v.AndroidRoboTest }).(AndroidRoboTestPtrOutput)
}

// An Android test loop.
func (o AndroidTestOutput) AndroidTestLoop() AndroidTestLoopPtrOutput {
	return o.ApplyT(func(v AndroidTest) *AndroidTestLoop { return v.AndroidTestLoop }).(AndroidTestLoopPtrOutput)
}

// Max time a test is allowed to run before it is automatically cancelled.
func (o AndroidTestOutput) TestTimeout() DurationPtrOutput {
	return o.ApplyT(func(v AndroidTest) *Duration { return v.TestTimeout }).(DurationPtrOutput)
}

type AndroidTestPtrOutput struct{ *pulumi.OutputState }

func (AndroidTestPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AndroidTest)(nil)).Elem()
}

func (o AndroidTestPtrOutput) ToAndroidTestPtrOutput() AndroidTestPtrOutput {
	return o
}

func (o AndroidTestPtrOutput) ToAndroidTestPtrOutputWithContext(ctx context.Context) AndroidTestPtrOutput {
	return o
}

func (o AndroidTestPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*AndroidTest] {
	return pulumix.Output[*AndroidTest]{
		OutputState: o.OutputState,
	}
}

func (o AndroidTestPtrOutput) Elem() AndroidTestOutput {
	return o.ApplyT(func(v *AndroidTest) AndroidTest {
		if v != nil {
			return *v
		}
		var ret AndroidTest
		return ret
	}).(AndroidTestOutput)
}

// Information about the application under test.
func (o AndroidTestPtrOutput) AndroidAppInfo() AndroidAppInfoPtrOutput {
	return o.ApplyT(func(v *AndroidTest) *AndroidAppInfo {
		if v == nil {
			return nil
		}
		return v.AndroidAppInfo
	}).(AndroidAppInfoPtrOutput)
}

// An Android instrumentation test.
func (o AndroidTestPtrOutput) AndroidInstrumentationTest() AndroidInstrumentationTestPtrOutput {
	return o.ApplyT(func(v *AndroidTest) *AndroidInstrumentationTest {
		if v == nil {
			return nil
		}
		return v.AndroidInstrumentationTest
	}).(AndroidInstrumentationTestPtrOutput)
}

// An Android robo test.
func (o AndroidTestPtrOutput) AndroidRoboTest() AndroidRoboTestPtrOutput {
	return o.ApplyT(func(v *AndroidTest) *AndroidRoboTest {
		if v == nil {
			return nil
		}
		return v.AndroidRoboTest
	}).(AndroidRoboTestPtrOutput)
}

// An Android test loop.
func (o AndroidTestPtrOutput) AndroidTestLoop() AndroidTestLoopPtrOutput {
	return o.ApplyT(func(v *AndroidTest) *AndroidTestLoop {
		if v == nil {
			return nil
		}
		return v.AndroidTestLoop
	}).(AndroidTestLoopPtrOutput)
}

// Max time a test is allowed to run before it is automatically cancelled.
func (o AndroidTestPtrOutput) TestTimeout() DurationPtrOutput {
	return o.ApplyT(func(v *AndroidTest) *Duration {
		if v == nil {
			return nil
		}
		return v.TestTimeout
	}).(DurationPtrOutput)
}

// Test Loops are tests that can be launched by the app itself, determining when to run by listening for an intent.
type AndroidTestLoop struct {
}

// AndroidTestLoopInput is an input type that accepts AndroidTestLoopArgs and AndroidTestLoopOutput values.
// You can construct a concrete instance of `AndroidTestLoopInput` via:
//
//	AndroidTestLoopArgs{...}
type AndroidTestLoopInput interface {
	pulumi.Input

	ToAndroidTestLoopOutput() AndroidTestLoopOutput
	ToAndroidTestLoopOutputWithContext(context.Context) AndroidTestLoopOutput
}

// Test Loops are tests that can be launched by the app itself, determining when to run by listening for an intent.
type AndroidTestLoopArgs struct {
}

func (AndroidTestLoopArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidTestLoop)(nil)).Elem()
}

func (i AndroidTestLoopArgs) ToAndroidTestLoopOutput() AndroidTestLoopOutput {
	return i.ToAndroidTestLoopOutputWithContext(context.Background())
}

func (i AndroidTestLoopArgs) ToAndroidTestLoopOutputWithContext(ctx context.Context) AndroidTestLoopOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidTestLoopOutput)
}

func (i AndroidTestLoopArgs) ToOutput(ctx context.Context) pulumix.Output[AndroidTestLoop] {
	return pulumix.Output[AndroidTestLoop]{
		OutputState: i.ToAndroidTestLoopOutputWithContext(ctx).OutputState,
	}
}

func (i AndroidTestLoopArgs) ToAndroidTestLoopPtrOutput() AndroidTestLoopPtrOutput {
	return i.ToAndroidTestLoopPtrOutputWithContext(context.Background())
}

func (i AndroidTestLoopArgs) ToAndroidTestLoopPtrOutputWithContext(ctx context.Context) AndroidTestLoopPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidTestLoopOutput).ToAndroidTestLoopPtrOutputWithContext(ctx)
}

// AndroidTestLoopPtrInput is an input type that accepts AndroidTestLoopArgs, AndroidTestLoopPtr and AndroidTestLoopPtrOutput values.
// You can construct a concrete instance of `AndroidTestLoopPtrInput` via:
//
//	        AndroidTestLoopArgs{...}
//
//	or:
//
//	        nil
type AndroidTestLoopPtrInput interface {
	pulumi.Input

	ToAndroidTestLoopPtrOutput() AndroidTestLoopPtrOutput
	ToAndroidTestLoopPtrOutputWithContext(context.Context) AndroidTestLoopPtrOutput
}

type androidTestLoopPtrType AndroidTestLoopArgs

func AndroidTestLoopPtr(v *AndroidTestLoopArgs) AndroidTestLoopPtrInput {
	return (*androidTestLoopPtrType)(v)
}

func (*androidTestLoopPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AndroidTestLoop)(nil)).Elem()
}

func (i *androidTestLoopPtrType) ToAndroidTestLoopPtrOutput() AndroidTestLoopPtrOutput {
	return i.ToAndroidTestLoopPtrOutputWithContext(context.Background())
}

func (i *androidTestLoopPtrType) ToAndroidTestLoopPtrOutputWithContext(ctx context.Context) AndroidTestLoopPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AndroidTestLoopPtrOutput)
}

func (i *androidTestLoopPtrType) ToOutput(ctx context.Context) pulumix.Output[*AndroidTestLoop] {
	return pulumix.Output[*AndroidTestLoop]{
		OutputState: i.ToAndroidTestLoopPtrOutputWithContext(ctx).OutputState,
	}
}

// Test Loops are tests that can be launched by the app itself, determining when to run by listening for an intent.
type AndroidTestLoopOutput struct{ *pulumi.OutputState }

func (AndroidTestLoopOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidTestLoop)(nil)).Elem()
}

func (o AndroidTestLoopOutput) ToAndroidTestLoopOutput() AndroidTestLoopOutput {
	return o
}

func (o AndroidTestLoopOutput) ToAndroidTestLoopOutputWithContext(ctx context.Context) AndroidTestLoopOutput {
	return o
}

func (o AndroidTestLoopOutput) ToAndroidTestLoopPtrOutput() AndroidTestLoopPtrOutput {
	return o.ToAndroidTestLoopPtrOutputWithContext(context.Background())
}

func (o AndroidTestLoopOutput) ToAndroidTestLoopPtrOutputWithContext(ctx context.Context) AndroidTestLoopPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AndroidTestLoop) *AndroidTestLoop {
		return &v
	}).(AndroidTestLoopPtrOutput)
}

func (o AndroidTestLoopOutput) ToOutput(ctx context.Context) pulumix.Output[AndroidTestLoop] {
	return pulumix.Output[AndroidTestLoop]{
		OutputState: o.OutputState,
	}
}

type AndroidTestLoopPtrOutput struct{ *pulumi.OutputState }

func (AndroidTestLoopPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AndroidTestLoop)(nil)).Elem()
}

func (o AndroidTestLoopPtrOutput) ToAndroidTestLoopPtrOutput() AndroidTestLoopPtrOutput {
	return o
}

func (o AndroidTestLoopPtrOutput) ToAndroidTestLoopPtrOutputWithContext(ctx context.Context) AndroidTestLoopPtrOutput {
	return o
}

func (o AndroidTestLoopPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*AndroidTestLoop] {
	return pulumix.Output[*AndroidTestLoop]{
		OutputState: o.OutputState,
	}
}

func (o AndroidTestLoopPtrOutput) Elem() AndroidTestLoopOutput {
	return o.ApplyT(func(v *AndroidTestLoop) AndroidTestLoop {
		if v != nil {
			return *v
		}
		var ret AndroidTestLoop
		return ret
	}).(AndroidTestLoopOutput)
}

// Test Loops are tests that can be launched by the app itself, determining when to run by listening for an intent.
type AndroidTestLoopResponse struct {
}

// Test Loops are tests that can be launched by the app itself, determining when to run by listening for an intent.
type AndroidTestLoopResponseOutput struct{ *pulumi.OutputState }

func (AndroidTestLoopResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidTestLoopResponse)(nil)).Elem()
}

func (o AndroidTestLoopResponseOutput) ToAndroidTestLoopResponseOutput() AndroidTestLoopResponseOutput {
	return o
}

func (o AndroidTestLoopResponseOutput) ToAndroidTestLoopResponseOutputWithContext(ctx context.Context) AndroidTestLoopResponseOutput {
	return o
}

func (o AndroidTestLoopResponseOutput) ToOutput(ctx context.Context) pulumix.Output[AndroidTestLoopResponse] {
	return pulumix.Output[AndroidTestLoopResponse]{
		OutputState: o.OutputState,
	}
}

// An Android mobile test specification.
type AndroidTestResponse struct {
	// Information about the application under test.
	AndroidAppInfo AndroidAppInfoResponse `pulumi:"androidAppInfo"`
	// An Android instrumentation test.
	AndroidInstrumentationTest AndroidInstrumentationTestResponse `pulumi:"androidInstrumentationTest"`
	// An Android robo test.
	AndroidRoboTest AndroidRoboTestResponse `pulumi:"androidRoboTest"`
	// An Android test loop.
	AndroidTestLoop AndroidTestLoopResponse `pulumi:"androidTestLoop"`
	// Max time a test is allowed to run before it is automatically cancelled.
	TestTimeout DurationResponse `pulumi:"testTimeout"`
}

// An Android mobile test specification.
type AndroidTestResponseOutput struct{ *pulumi.OutputState }

func (AndroidTestResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AndroidTestResponse)(nil)).Elem()
}

func (o AndroidTestResponseOutput) ToAndroidTestResponseOutput() AndroidTestResponseOutput {
	return o
}

func (o AndroidTestResponseOutput) ToAndroidTestResponseOutputWithContext(ctx context.Context) AndroidTestResponseOutput {
	return o
}

func (o AndroidTestResponseOutput) ToOutput(ctx context.Context) pulumix.Output[AndroidTestResponse] {
	return pulumix.Output[AndroidTestResponse]{
		OutputState: o.OutputState,
	}
}

// Information about the application under test.
func (o AndroidTestResponseOutput) AndroidAppInfo() AndroidAppInfoResponseOutput {
	return o.ApplyT(func(v AndroidTestResponse) AndroidAppInfoResponse { return v.AndroidAppInfo }).(AndroidAppInfoResponseOutput)
}

// An Android instrumentation test.
func (o AndroidTestResponseOutput) AndroidInstrumentationTest() AndroidInstrumentationTestResponseOutput {
	return o.ApplyT(func(v AndroidTestResponse) AndroidInstrumentationTestResponse { return v.AndroidInstrumentationTest }).(AndroidInstrumentationTestResponseOutput)
}

// An Android robo test.
func (o AndroidTestResponseOutput) AndroidRoboTest() AndroidRoboTestResponseOutput {
	return o.ApplyT(func(v AndroidTestResponse) AndroidRoboTestResponse { return v.AndroidRoboTest }).(AndroidRoboTestResponseOutput)
}

// An Android test loop.
func (o AndroidTestResponseOutput) AndroidTestLoop() AndroidTestLoopResponseOutput {
	return o.ApplyT(func(v AndroidTestResponse) AndroidTestLoopResponse { return v.AndroidTestLoop }).(AndroidTestLoopResponseOutput)
}

// Max time a test is allowed to run before it is automatically cancelled.
func (o AndroidTestResponseOutput) TestTimeout() DurationResponseOutput {
	return o.ApplyT(func(v AndroidTestResponse) DurationResponse { return v.TestTimeout }).(DurationResponseOutput)
}

// `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++. Foo foo = ...; Any any; any.PackFrom(foo); ... if (any.UnpackTo(&foo)) { ... } Example 2: Pack and unpack a message in Java. Foo foo = ...; Any any = Any.pack(foo); ... if (any.is(Foo.class)) { foo = any.unpack(Foo.class); } Example 3: Pack and unpack a message in Python. foo = Foo(...) any = Any() any.Pack(foo) ... if any.Is(Foo.DESCRIPTOR): any.Unpack(foo) ... Example 4: Pack and unpack a message in Go foo := &pb.Foo{...} any, err := ptypes.MarshalAny(foo) ... foo := &pb.Foo{} if err := ptypes.UnmarshalAny(any, foo); err != nil { ... } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example "foo.bar.com/x/y.z" will yield type name "y.z". # JSON The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example: package google.profile; message Person { string first_name = 1; string last_name = 2; } { "@type": "type.googleapis.com/google.profile.Person", "firstName": , "lastName": } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message google.protobuf.Duration): { "@type": "type.googleapis.com/google.protobuf.Duration", "value": "1.212s" }
type Any struct {
	// A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one "/" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading "." is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a google.protobuf.Type value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the URL, or have them precompiled into a binary to avoid any lookup. Therefore, binary compatibility needs to be preserved on changes to types. (Use versioned type names to manage breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
	TypeUrl *string `pulumi:"typeUrl"`
	// Must be a valid serialized protocol buffer of the above specified type.
	Value *string `pulumi:"value"`
}

// AnyInput is an input type that accepts AnyArgs and AnyOutput values.
// You can construct a concrete instance of `AnyInput` via:
//
//	AnyArgs{...}
type AnyInput interface {
	pulumi.Input

	ToAnyOutput() AnyOutput
	ToAnyOutputWithContext(context.Context) AnyOutput
}

// `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++. Foo foo = ...; Any any; any.PackFrom(foo); ... if (any.UnpackTo(&foo)) { ... } Example 2: Pack and unpack a message in Java. Foo foo = ...; Any any = Any.pack(foo); ... if (any.is(Foo.class)) { foo = any.unpack(Foo.class); } Example 3: Pack and unpack a message in Python. foo = Foo(...) any = Any() any.Pack(foo) ... if any.Is(Foo.DESCRIPTOR): any.Unpack(foo) ... Example 4: Pack and unpack a message in Go foo := &pb.Foo{...} any, err := ptypes.MarshalAny(foo) ... foo := &pb.Foo{} if err := ptypes.UnmarshalAny(any, foo); err != nil { ... } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example "foo.bar.com/x/y.z" will yield type name "y.z". # JSON The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example: package google.profile; message Person { string first_name = 1; string last_name = 2; } { "@type": "type.googleapis.com/google.profile.Person", "firstName": , "lastName": } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message google.protobuf.Duration): { "@type": "type.googleapis.com/google.protobuf.Duration", "value": "1.212s" }
type AnyArgs struct {
	// A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one "/" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading "." is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a google.protobuf.Type value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the URL, or have them precompiled into a binary to avoid any lookup. Therefore, binary compatibility needs to be preserved on changes to types. (Use versioned type names to manage breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
	TypeUrl pulumi.StringPtrInput `pulumi:"typeUrl"`
	// Must be a valid serialized protocol buffer of the above specified type.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (AnyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Any)(nil)).Elem()
}

func (i AnyArgs) ToAnyOutput() AnyOutput {
	return i.ToAnyOutputWithContext(context.Background())
}

func (i AnyArgs) ToAnyOutputWithContext(ctx context.Context) AnyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnyOutput)
}

func (i AnyArgs) ToOutput(ctx context.Context) pulumix.Output[Any] {
	return pulumix.Output[Any]{
		OutputState: i.ToAnyOutputWithContext(ctx).OutputState,
	}
}

func (i AnyArgs) ToAnyPtrOutput() AnyPtrOutput {
	return i.ToAnyPtrOutputWithContext(context.Background())
}

func (i AnyArgs) ToAnyPtrOutputWithContext(ctx context.Context) AnyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnyOutput).ToAnyPtrOutputWithContext(ctx)
}

// AnyPtrInput is an input type that accepts AnyArgs, AnyPtr and AnyPtrOutput values.
// You can construct a concrete instance of `AnyPtrInput` via:
//
//	        AnyArgs{...}
//
//	or:
//
//	        nil
type AnyPtrInput interface {
	pulumi.Input

	ToAnyPtrOutput() AnyPtrOutput
	ToAnyPtrOutputWithContext(context.Context) AnyPtrOutput
}

type anyPtrType AnyArgs

func AnyPtr(v *AnyArgs) AnyPtrInput {
	return (*anyPtrType)(v)
}

func (*anyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Any)(nil)).Elem()
}

func (i *anyPtrType) ToAnyPtrOutput() AnyPtrOutput {
	return i.ToAnyPtrOutputWithContext(context.Background())
}

func (i *anyPtrType) ToAnyPtrOutputWithContext(ctx context.Context) AnyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnyPtrOutput)
}

func (i *anyPtrType) ToOutput(ctx context.Context) pulumix.Output[*Any] {
	return pulumix.Output[*Any]{
		OutputState: i.ToAnyPtrOutputWithContext(ctx).OutputState,
	}
}

// `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++. Foo foo = ...; Any any; any.PackFrom(foo); ... if (any.UnpackTo(&foo)) { ... } Example 2: Pack and unpack a message in Java. Foo foo = ...; Any any = Any.pack(foo); ... if (any.is(Foo.class)) { foo = any.unpack(Foo.class); } Example 3: Pack and unpack a message in Python. foo = Foo(...) any = Any() any.Pack(foo) ... if any.Is(Foo.DESCRIPTOR): any.Unpack(foo) ... Example 4: Pack and unpack a message in Go foo := &pb.Foo{...} any, err := ptypes.MarshalAny(foo) ... foo := &pb.Foo{} if err := ptypes.UnmarshalAny(any, foo); err != nil { ... } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example "foo.bar.com/x/y.z" will yield type name "y.z". # JSON The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example: package google.profile; message Person { string first_name = 1; string last_name = 2; } { "@type": "type.googleapis.com/google.profile.Person", "firstName": , "lastName": } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message google.protobuf.Duration): { "@type": "type.googleapis.com/google.protobuf.Duration", "value": "1.212s" }
type AnyOutput struct{ *pulumi.OutputState }

func (AnyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Any)(nil)).Elem()
}

func (o AnyOutput) ToAnyOutput() AnyOutput {
	return o
}

func (o AnyOutput) ToAnyOutputWithContext(ctx context.Context) AnyOutput {
	return o
}

func (o AnyOutput) ToAnyPtrOutput() AnyPtrOutput {
	return o.ToAnyPtrOutputWithContext(context.Background())
}

func (o AnyOutput) ToAnyPtrOutputWithContext(ctx context.Context) AnyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Any) *Any {
		return &v
	}).(AnyPtrOutput)
}

func (o AnyOutput) ToOutput(ctx context.Context) pulumix.Output[Any] {
	return pulumix.Output[Any]{
		OutputState: o.OutputState,
	}
}

// A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one "/" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading "." is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a google.protobuf.Type value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the URL, or have them precompiled into a binary to avoid any lookup. Therefore, binary compatibility needs to be preserved on changes to types. (Use versioned type names to manage breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
func (o AnyOutput) TypeUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Any) *string { return v.TypeUrl }).(pulumi.StringPtrOutput)
}

// Must be a valid serialized protocol buffer of the above specified type.
func (o AnyOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Any) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type AnyPtrOutput struct{ *pulumi.OutputState }

func (AnyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Any)(nil)).Elem()
}

func (o AnyPtrOutput) ToAnyPtrOutput() AnyPtrOutput {
	return o
}

func (o AnyPtrOutput) ToAnyPtrOutputWithContext(ctx context.Context) AnyPtrOutput {
	return o
}

func (o AnyPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*Any] {
	return pulumix.Output[*Any]{
		OutputState: o.OutputState,
	}
}

func (o AnyPtrOutput) Elem() AnyOutput {
	return o.ApplyT(func(v *Any) Any {
		if v != nil {
			return *v
		}
		var ret Any
		return ret
	}).(AnyOutput)
}

// A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one "/" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading "." is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a google.protobuf.Type value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the URL, or have them precompiled into a binary to avoid any lookup. Therefore, binary compatibility needs to be preserved on changes to types. (Use versioned type names to manage breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
func (o AnyPtrOutput) TypeUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Any) *string {
		if v == nil {
			return nil
		}
		return v.TypeUrl
	}).(pulumi.StringPtrOutput)
}

// Must be a valid serialized protocol buffer of the above specified type.
func (o AnyPtrOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Any) *string {
		if v == nil {
			return nil
		}
		return v.Value
	}).(pulumi.StringPtrOutput)
}

// `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++. Foo foo = ...; Any any; any.PackFrom(foo); ... if (any.UnpackTo(&foo)) { ... } Example 2: Pack and unpack a message in Java. Foo foo = ...; Any any = Any.pack(foo); ... if (any.is(Foo.class)) { foo = any.unpack(Foo.class); } Example 3: Pack and unpack a message in Python. foo = Foo(...) any = Any() any.Pack(foo) ... if any.Is(Foo.DESCRIPTOR): any.Unpack(foo) ... Example 4: Pack and unpack a message in Go foo := &pb.Foo{...} any, err := ptypes.MarshalAny(foo) ... foo := &pb.Foo{} if err := ptypes.UnmarshalAny(any, foo); err != nil { ... } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example "foo.bar.com/x/y.z" will yield type name "y.z". # JSON The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example: package google.profile; message Person { string first_name = 1; string last_name = 2; } { "@type": "type.googleapis.com/google.profile.Person", "firstName": , "lastName": } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message google.protobuf.Duration): { "@type": "type.googleapis.com/google.protobuf.Duration", "value": "1.212s" }
type AnyResponse struct {
	// A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one "/" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading "." is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a google.protobuf.Type value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the URL, or have them precompiled into a binary to avoid any lookup. Therefore, binary compatibility needs to be preserved on changes to types. (Use versioned type names to manage breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
	TypeUrl string `pulumi:"typeUrl"`
	// Must be a valid serialized protocol buffer of the above specified type.
	Value string `pulumi:"value"`
}

// `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++. Foo foo = ...; Any any; any.PackFrom(foo); ... if (any.UnpackTo(&foo)) { ... } Example 2: Pack and unpack a message in Java. Foo foo = ...; Any any = Any.pack(foo); ... if (any.is(Foo.class)) { foo = any.unpack(Foo.class); } Example 3: Pack and unpack a message in Python. foo = Foo(...) any = Any() any.Pack(foo) ... if any.Is(Foo.DESCRIPTOR): any.Unpack(foo) ... Example 4: Pack and unpack a message in Go foo := &pb.Foo{...} any, err := ptypes.MarshalAny(foo) ... foo := &pb.Foo{} if err := ptypes.UnmarshalAny(any, foo); err != nil { ... } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example "foo.bar.com/x/y.z" will yield type name "y.z". # JSON The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example: package google.profile; message Person { string first_name = 1; string last_name = 2; } { "@type": "type.googleapis.com/google.profile.Person", "firstName": , "lastName": } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message google.protobuf.Duration): { "@type": "type.googleapis.com/google.protobuf.Duration", "value": "1.212s" }
type AnyResponseOutput struct{ *pulumi.OutputState }

func (AnyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AnyResponse)(nil)).Elem()
}

func (o AnyResponseOutput) ToAnyResponseOutput() AnyResponseOutput {
	return o
}

func (o AnyResponseOutput) ToAnyResponseOutputWithContext(ctx context.Context) AnyResponseOutput {
	return o
}

func (o AnyResponseOutput) ToOutput(ctx context.Context) pulumix.Output[AnyResponse] {
	return pulumix.Output[AnyResponse]{
		OutputState: o.OutputState,
	}
}

// A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one "/" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading "." is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a google.protobuf.Type value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the URL, or have them precompiled into a binary to avoid any lookup. Therefore, binary compatibility needs to be preserved on changes to types. (Use versioned type names to manage breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
func (o AnyResponseOutput) TypeUrl() pulumi.StringOutput {
	return o.ApplyT(func(v AnyResponse) string { return v.TypeUrl }).(pulumi.StringOutput)
}

// Must be a valid serialized protocol buffer of the above specified type.
func (o AnyResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v AnyResponse) string { return v.Value }).(pulumi.StringOutput)
}

// Encapsulates the metadata for basic sample series represented by a line chart
type BasicPerfSampleSeries struct {
	PerfMetricType    *BasicPerfSampleSeriesPerfMetricType    `pulumi:"perfMetricType"`
	PerfUnit          *BasicPerfSampleSeriesPerfUnit          `pulumi:"perfUnit"`
	SampleSeriesLabel *BasicPerfSampleSeriesSampleSeriesLabel `pulumi:"sampleSeriesLabel"`
}

// BasicPerfSampleSeriesInput is an input type that accepts BasicPerfSampleSeriesArgs and BasicPerfSampleSeriesOutput values.
// You can construct a concrete instance of `BasicPerfSampleSeriesInput` via:
//
//	BasicPerfSampleSeriesArgs{...}
type BasicPerfSampleSeriesInput interface {
	pulumi.Input

	ToBasicPerfSampleSeriesOutput() BasicPerfSampleSeriesOutput
	ToBasicPerfSampleSeriesOutputWithContext(context.Context) BasicPerfSampleSeriesOutput
}

// Encapsulates the metadata for basic sample series represented by a line chart
type BasicPerfSampleSeriesArgs struct {
	PerfMetricType    BasicPerfSampleSeriesPerfMetricTypePtrInput    `pulumi:"perfMetricType"`
	PerfUnit          BasicPerfSampleSeriesPerfUnitPtrInput          `pulumi:"perfUnit"`
	SampleSeriesLabel BasicPerfSampleSeriesSampleSeriesLabelPtrInput `pulumi:"sampleSeriesLabel"`
}

func (BasicPerfSampleSeriesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicPerfSampleSeries)(nil)).Elem()
}

func (i BasicPerfSampleSeriesArgs) ToBasicPerfSampleSeriesOutput() BasicPerfSampleSeriesOutput {
	return i.ToBasicPerfSampleSeriesOutputWithContext(context.Background())
}

func (i BasicPerfSampleSeriesArgs) ToBasicPerfSampleSeriesOutputWithContext(ctx context.Context) BasicPerfSampleSeriesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicPerfSampleSeriesOutput)
}

func (i BasicPerfSampleSeriesArgs) ToOutput(ctx context.Context) pulumix.Output[BasicPerfSampleSeries] {
	return pulumix.Output[BasicPerfSampleSeries]{
		OutputState: i.ToBasicPerfSampleSeriesOutputWithContext(ctx).OutputState,
	}
}

func (i BasicPerfSampleSeriesArgs) ToBasicPerfSampleSeriesPtrOutput() BasicPerfSampleSeriesPtrOutput {
	return i.ToBasicPerfSampleSeriesPtrOutputWithContext(context.Background())
}

func (i BasicPerfSampleSeriesArgs) ToBasicPerfSampleSeriesPtrOutputWithContext(ctx context.Context) BasicPerfSampleSeriesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicPerfSampleSeriesOutput).ToBasicPerfSampleSeriesPtrOutputWithContext(ctx)
}

// BasicPerfSampleSeriesPtrInput is an input type that accepts BasicPerfSampleSeriesArgs, BasicPerfSampleSeriesPtr and BasicPerfSampleSeriesPtrOutput values.
// You can construct a concrete instance of `BasicPerfSampleSeriesPtrInput` via:
//
//	        BasicPerfSampleSeriesArgs{...}
//
//	or:
//
//	        nil
type BasicPerfSampleSeriesPtrInput interface {
	pulumi.Input

	ToBasicPerfSampleSeriesPtrOutput() BasicPerfSampleSeriesPtrOutput
	ToBasicPerfSampleSeriesPtrOutputWithContext(context.Context) BasicPerfSampleSeriesPtrOutput
}

type basicPerfSampleSeriesPtrType BasicPerfSampleSeriesArgs

func BasicPerfSampleSeriesPtr(v *BasicPerfSampleSeriesArgs) BasicPerfSampleSeriesPtrInput {
	return (*basicPerfSampleSeriesPtrType)(v)
}

func (*basicPerfSampleSeriesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicPerfSampleSeries)(nil)).Elem()
}

func (i *basicPerfSampleSeriesPtrType) ToBasicPerfSampleSeriesPtrOutput() BasicPerfSampleSeriesPtrOutput {
	return i.ToBasicPerfSampleSeriesPtrOutputWithContext(context.Background())
}

func (i *basicPerfSampleSeriesPtrType) ToBasicPerfSampleSeriesPtrOutputWithContext(ctx context.Context) BasicPerfSampleSeriesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicPerfSampleSeriesPtrOutput)
}

func (i *basicPerfSampleSeriesPtrType) ToOutput(ctx context.Context) pulumix.Output[*BasicPerfSampleSeries] {
	return pulumix.Output[*BasicPerfSampleSeries]{
		OutputState: i.ToBasicPerfSampleSeriesPtrOutputWithContext(ctx).OutputState,
	}
}

// Encapsulates the metadata for basic sample series represented by a line chart
type BasicPerfSampleSeriesOutput struct{ *pulumi.OutputState }

func (BasicPerfSampleSeriesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicPerfSampleSeries)(nil)).Elem()
}

func (o BasicPerfSampleSeriesOutput) ToBasicPerfSampleSeriesOutput() BasicPerfSampleSeriesOutput {
	return o
}

func (o BasicPerfSampleSeriesOutput) ToBasicPerfSampleSeriesOutputWithContext(ctx context.Context) BasicPerfSampleSeriesOutput {
	return o
}

func (o BasicPerfSampleSeriesOutput) ToBasicPerfSampleSeriesPtrOutput() BasicPerfSampleSeriesPtrOutput {
	return o.ToBasicPerfSampleSeriesPtrOutputWithContext(context.Background())
}

func (o BasicPerfSampleSeriesOutput) ToBasicPerfSampleSeriesPtrOutputWithContext(ctx context.Context) BasicPerfSampleSeriesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BasicPerfSampleSeries) *BasicPerfSampleSeries {
		return &v
	}).(BasicPerfSampleSeriesPtrOutput)
}

func (o BasicPerfSampleSeriesOutput) ToOutput(ctx context.Context) pulumix.Output[BasicPerfSampleSeries] {
	return pulumix.Output[BasicPerfSampleSeries]{
		OutputState: o.OutputState,
	}
}

func (o BasicPerfSampleSeriesOutput) PerfMetricType() BasicPerfSampleSeriesPerfMetricTypePtrOutput {
	return o.ApplyT(func(v BasicPerfSampleSeries) *BasicPerfSampleSeriesPerfMetricType { return v.PerfMetricType }).(BasicPerfSampleSeriesPerfMetricTypePtrOutput)
}

func (o BasicPerfSampleSeriesOutput) PerfUnit() BasicPerfSampleSeriesPerfUnitPtrOutput {
	return o.ApplyT(func(v BasicPerfSampleSeries) *BasicPerfSampleSeriesPerfUnit { return v.PerfUnit }).(BasicPerfSampleSeriesPerfUnitPtrOutput)
}

func (o BasicPerfSampleSeriesOutput) SampleSeriesLabel() BasicPerfSampleSeriesSampleSeriesLabelPtrOutput {
	return o.ApplyT(func(v BasicPerfSampleSeries) *BasicPerfSampleSeriesSampleSeriesLabel { return v.SampleSeriesLabel }).(BasicPerfSampleSeriesSampleSeriesLabelPtrOutput)
}

type BasicPerfSampleSeriesPtrOutput struct{ *pulumi.OutputState }

func (BasicPerfSampleSeriesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicPerfSampleSeries)(nil)).Elem()
}

func (o BasicPerfSampleSeriesPtrOutput) ToBasicPerfSampleSeriesPtrOutput() BasicPerfSampleSeriesPtrOutput {
	return o
}

func (o BasicPerfSampleSeriesPtrOutput) ToBasicPerfSampleSeriesPtrOutputWithContext(ctx context.Context) BasicPerfSampleSeriesPtrOutput {
	return o
}

func (o BasicPerfSampleSeriesPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*BasicPerfSampleSeries] {
	return pulumix.Output[*BasicPerfSampleSeries]{
		OutputState: o.OutputState,
	}
}

func (o BasicPerfSampleSeriesPtrOutput) Elem() BasicPerfSampleSeriesOutput {
	return o.ApplyT(func(v *BasicPerfSampleSeries) BasicPerfSampleSeries {
		if v != nil {
			return *v
		}
		var ret BasicPerfSampleSeries
		return ret
	}).(BasicPerfSampleSeriesOutput)
}

func (o BasicPerfSampleSeriesPtrOutput) PerfMetricType() BasicPerfSampleSeriesPerfMetricTypePtrOutput {
	return o.ApplyT(func(v *BasicPerfSampleSeries) *BasicPerfSampleSeriesPerfMetricType {
		if v == nil {
			return nil
		}
		return v.PerfMetricType
	}).(BasicPerfSampleSeriesPerfMetricTypePtrOutput)
}

func (o BasicPerfSampleSeriesPtrOutput) PerfUnit() BasicPerfSampleSeriesPerfUnitPtrOutput {
	return o.ApplyT(func(v *BasicPerfSampleSeries) *BasicPerfSampleSeriesPerfUnit {
		if v == nil {
			return nil
		}
		return v.PerfUnit
	}).(BasicPerfSampleSeriesPerfUnitPtrOutput)
}

func (o BasicPerfSampleSeriesPtrOutput) SampleSeriesLabel() BasicPerfSampleSeriesSampleSeriesLabelPtrOutput {
	return o.ApplyT(func(v *BasicPerfSampleSeries) *BasicPerfSampleSeriesSampleSeriesLabel {
		if v == nil {
			return nil
		}
		return v.SampleSeriesLabel
	}).(BasicPerfSampleSeriesSampleSeriesLabelPtrOutput)
}

// Encapsulates the metadata for basic sample series represented by a line chart
type BasicPerfSampleSeriesResponse struct {
	PerfMetricType    string `pulumi:"perfMetricType"`
	PerfUnit          string `pulumi:"perfUnit"`
	SampleSeriesLabel string `pulumi:"sampleSeriesLabel"`
}

// Encapsulates the metadata for basic sample series represented by a line chart
type BasicPerfSampleSeriesResponseOutput struct{ *pulumi.OutputState }

func (BasicPerfSampleSeriesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicPerfSampleSeriesResponse)(nil)).Elem()
}

func (o BasicPerfSampleSeriesResponseOutput) ToBasicPerfSampleSeriesResponseOutput() BasicPerfSampleSeriesResponseOutput {
	return o
}

func (o BasicPerfSampleSeriesResponseOutput) ToBasicPerfSampleSeriesResponseOutputWithContext(ctx context.Context) BasicPerfSampleSeriesResponseOutput {
	return o
}

func (o BasicPerfSampleSeriesResponseOutput) ToOutput(ctx context.Context) pulumix.Output[BasicPerfSampleSeriesResponse] {
	return pulumix.Output[BasicPerfSampleSeriesResponse]{
		OutputState: o.OutputState,
	}
}

func (o BasicPerfSampleSeriesResponseOutput) PerfMetricType() pulumi.StringOutput {
	return o.ApplyT(func(v BasicPerfSampleSeriesResponse) string { return v.PerfMetricType }).(pulumi.StringOutput)
}

func (o BasicPerfSampleSeriesResponseOutput) PerfUnit() pulumi.StringOutput {
	return o.ApplyT(func(v BasicPerfSampleSeriesResponse) string { return v.PerfUnit }).(pulumi.StringOutput)
}

func (o BasicPerfSampleSeriesResponseOutput) SampleSeriesLabel() pulumi.StringOutput {
	return o.ApplyT(func(v BasicPerfSampleSeriesResponse) string { return v.SampleSeriesLabel }).(pulumi.StringOutput)
}

// A Duration represents a signed, fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". It is related to Timestamp in that the difference between two Timestamp values is a Duration and it can be added or subtracted from a Timestamp. Range is approximately +-10,000 years.
type Duration struct {
	// Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.
	Nanos *int `pulumi:"nanos"`
	// Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
	Seconds *string `pulumi:"seconds"`
}

// DurationInput is an input type that accepts DurationArgs and DurationOutput values.
// You can construct a concrete instance of `DurationInput` via:
//
//	DurationArgs{...}
type DurationInput interface {
	pulumi.Input

	ToDurationOutput() DurationOutput
	ToDurationOutputWithContext(context.Context) DurationOutput
}

// A Duration represents a signed, fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". It is related to Timestamp in that the difference between two Timestamp values is a Duration and it can be added or subtracted from a Timestamp. Range is approximately +-10,000 years.
type DurationArgs struct {
	// Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.
	Nanos pulumi.IntPtrInput `pulumi:"nanos"`
	// Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
	Seconds pulumi.StringPtrInput `pulumi:"seconds"`
}

func (DurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Duration)(nil)).Elem()
}

func (i DurationArgs) ToDurationOutput() DurationOutput {
	return i.ToDurationOutputWithContext(context.Background())
}

func (i DurationArgs) ToDurationOutputWithContext(ctx context.Context) DurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DurationOutput)
}

func (i DurationArgs) ToOutput(ctx context.Context) pulumix.Output[Duration] {
	return pulumix.Output[Duration]{
		OutputState: i.ToDurationOutputWithContext(ctx).OutputState,
	}
}

func (i DurationArgs) ToDurationPtrOutput() DurationPtrOutput {
	return i.ToDurationPtrOutputWithContext(context.Background())
}

func (i DurationArgs) ToDurationPtrOutputWithContext(ctx context.Context) DurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DurationOutput).ToDurationPtrOutputWithContext(ctx)
}

// DurationPtrInput is an input type that accepts DurationArgs, DurationPtr and DurationPtrOutput values.
// You can construct a concrete instance of `DurationPtrInput` via:
//
//	        DurationArgs{...}
//
//	or:
//
//	        nil
type DurationPtrInput interface {
	pulumi.Input

	ToDurationPtrOutput() DurationPtrOutput
	ToDurationPtrOutputWithContext(context.Context) DurationPtrOutput
}

type durationPtrType DurationArgs

func DurationPtr(v *DurationArgs) DurationPtrInput {
	return (*durationPtrType)(v)
}

func (*durationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Duration)(nil)).Elem()
}

func (i *durationPtrType) ToDurationPtrOutput() DurationPtrOutput {
	return i.ToDurationPtrOutputWithContext(context.Background())
}

func (i *durationPtrType) ToDurationPtrOutputWithContext(ctx context.Context) DurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DurationPtrOutput)
}

func (i *durationPtrType) ToOutput(ctx context.Context) pulumix.Output[*Duration] {
	return pulumix.Output[*Duration]{
		OutputState: i.ToDurationPtrOutputWithContext(ctx).OutputState,
	}
}

// A Duration represents a signed, fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". It is related to Timestamp in that the difference between two Timestamp values is a Duration and it can be added or subtracted from a Timestamp. Range is approximately +-10,000 years.
type DurationOutput struct{ *pulumi.OutputState }

func (DurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Duration)(nil)).Elem()
}

func (o DurationOutput) ToDurationOutput() DurationOutput {
	return o
}

func (o DurationOutput) ToDurationOutputWithContext(ctx context.Context) DurationOutput {
	return o
}

func (o DurationOutput) ToDurationPtrOutput() DurationPtrOutput {
	return o.ToDurationPtrOutputWithContext(context.Background())
}

func (o DurationOutput) ToDurationPtrOutputWithContext(ctx context.Context) DurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Duration) *Duration {
		return &v
	}).(DurationPtrOutput)
}

func (o DurationOutput) ToOutput(ctx context.Context) pulumix.Output[Duration] {
	return pulumix.Output[Duration]{
		OutputState: o.OutputState,
	}
}

// Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.
func (o DurationOutput) Nanos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Duration) *int { return v.Nanos }).(pulumi.IntPtrOutput)
}

// Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
func (o DurationOutput) Seconds() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Duration) *string { return v.Seconds }).(pulumi.StringPtrOutput)
}

type DurationPtrOutput struct{ *pulumi.OutputState }

func (DurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Duration)(nil)).Elem()
}

func (o DurationPtrOutput) ToDurationPtrOutput() DurationPtrOutput {
	return o
}

func (o DurationPtrOutput) ToDurationPtrOutputWithContext(ctx context.Context) DurationPtrOutput {
	return o
}

func (o DurationPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*Duration] {
	return pulumix.Output[*Duration]{
		OutputState: o.OutputState,
	}
}

func (o DurationPtrOutput) Elem() DurationOutput {
	return o.ApplyT(func(v *Duration) Duration {
		if v != nil {
			return *v
		}
		var ret Duration
		return ret
	}).(DurationOutput)
}

// Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.
func (o DurationPtrOutput) Nanos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Duration) *int {
		if v == nil {
			return nil
		}
		return v.Nanos
	}).(pulumi.IntPtrOutput)
}

// Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
func (o DurationPtrOutput) Seconds() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Duration) *string {
		if v == nil {
			return nil
		}
		return v.Seconds
	}).(pulumi.StringPtrOutput)
}

// A Duration represents a signed, fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". It is related to Timestamp in that the difference between two Timestamp values is a Duration and it can be added or subtracted from a Timestamp. Range is approximately +-10,000 years.
type DurationResponse struct {
	// Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.
	Nanos int `pulumi:"nanos"`
	// Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
	Seconds string `pulumi:"seconds"`
}

// A Duration represents a signed, fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". It is related to Timestamp in that the difference between two Timestamp values is a Duration and it can be added or subtracted from a Timestamp. Range is approximately +-10,000 years.
type DurationResponseOutput struct{ *pulumi.OutputState }

func (DurationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DurationResponse)(nil)).Elem()
}

func (o DurationResponseOutput) ToDurationResponseOutput() DurationResponseOutput {
	return o
}

func (o DurationResponseOutput) ToDurationResponseOutputWithContext(ctx context.Context) DurationResponseOutput {
	return o
}

func (o DurationResponseOutput) ToOutput(ctx context.Context) pulumix.Output[DurationResponse] {
	return pulumix.Output[DurationResponse]{
		OutputState: o.OutputState,
	}
}

// Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.
func (o DurationResponseOutput) Nanos() pulumi.IntOutput {
	return o.ApplyT(func(v DurationResponse) int { return v.Nanos }).(pulumi.IntOutput)
}

// Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
func (o DurationResponseOutput) Seconds() pulumi.StringOutput {
	return o.ApplyT(func(v DurationResponse) string { return v.Seconds }).(pulumi.StringOutput)
}

// Details for an outcome with a FAILURE outcome summary.
type FailureDetail struct {
	// If the failure was severe because the system (app) under test crashed.
	Crashed *bool `pulumi:"crashed"`
	// If the device ran out of memory during a test, causing the test to crash.
	DeviceOutOfMemory *bool `pulumi:"deviceOutOfMemory"`
	// If the Roboscript failed to complete successfully, e.g., because a Roboscript action or assertion failed or a Roboscript action could not be matched during the entire crawl.
	FailedRoboscript *bool `pulumi:"failedRoboscript"`
	// If an app is not installed and thus no test can be run with the app. This might be caused by trying to run a test on an unsupported platform.
	NotInstalled *bool `pulumi:"notInstalled"`
	// If a native process (including any other than the app) crashed.
	OtherNativeCrash *bool `pulumi:"otherNativeCrash"`
	// If the test overran some time limit, and that is why it failed.
	TimedOut *bool `pulumi:"timedOut"`
	// If the robo was unable to crawl the app; perhaps because the app did not start.
	UnableToCrawl *bool `pulumi:"unableToCrawl"`
}

// FailureDetailInput is an input type that accepts FailureDetailArgs and FailureDetailOutput values.
// You can construct a concrete instance of `FailureDetailInput` via:
//
//	FailureDetailArgs{...}
type FailureDetailInput interface {
	pulumi.Input

	ToFailureDetailOutput() FailureDetailOutput
	ToFailureDetailOutputWithContext(context.Context) FailureDetailOutput
}

// Details for an outcome with a FAILURE outcome summary.
type FailureDetailArgs struct {
	// If the failure was severe because the system (app) under test crashed.
	Crashed pulumi.BoolPtrInput `pulumi:"crashed"`
	// If the device ran out of memory during a test, causing the test to crash.
	DeviceOutOfMemory pulumi.BoolPtrInput `pulumi:"deviceOutOfMemory"`
	// If the Roboscript failed to complete successfully, e.g., because a Roboscript action or assertion failed or a Roboscript action could not be matched during the entire crawl.
	FailedRoboscript pulumi.BoolPtrInput `pulumi:"failedRoboscript"`
	// If an app is not installed and thus no test can be run with the app. This might be caused by trying to run a test on an unsupported platform.
	NotInstalled pulumi.BoolPtrInput `pulumi:"notInstalled"`
	// If a native process (including any other than the app) crashed.
	OtherNativeCrash pulumi.BoolPtrInput `pulumi:"otherNativeCrash"`
	// If the test overran some time limit, and that is why it failed.
	TimedOut pulumi.BoolPtrInput `pulumi:"timedOut"`
	// If the robo was unable to crawl the app; perhaps because the app did not start.
	UnableToCrawl pulumi.BoolPtrInput `pulumi:"unableToCrawl"`
}

func (FailureDetailArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FailureDetail)(nil)).Elem()
}

func (i FailureDetailArgs) ToFailureDetailOutput() FailureDetailOutput {
	return i.ToFailureDetailOutputWithContext(context.Background())
}

func (i FailureDetailArgs) ToFailureDetailOutputWithContext(ctx context.Context) FailureDetailOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FailureDetailOutput)
}

func (i FailureDetailArgs) ToOutput(ctx context.Context) pulumix.Output[FailureDetail] {
	return pulumix.Output[FailureDetail]{
		OutputState: i.ToFailureDetailOutputWithContext(ctx).OutputState,
	}
}

func (i FailureDetailArgs) ToFailureDetailPtrOutput() FailureDetailPtrOutput {
	return i.ToFailureDetailPtrOutputWithContext(context.Background())
}

func (i FailureDetailArgs) ToFailureDetailPtrOutputWithContext(ctx context.Context) FailureDetailPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FailureDetailOutput).ToFailureDetailPtrOutputWithContext(ctx)
}

// FailureDetailPtrInput is an input type that accepts FailureDetailArgs, FailureDetailPtr and FailureDetailPtrOutput values.
// You can construct a concrete instance of `FailureDetailPtrInput` via:
//
//	        FailureDetailArgs{...}
//
//	or:
//
//	        nil
type FailureDetailPtrInput interface {
	pulumi.Input

	ToFailureDetailPtrOutput() FailureDetailPtrOutput
	ToFailureDetailPtrOutputWithContext(context.Context) FailureDetailPtrOutput
}

type failureDetailPtrType FailureDetailArgs

func FailureDetailPtr(v *FailureDetailArgs) FailureDetailPtrInput {
	return (*failureDetailPtrType)(v)
}

func (*failureDetailPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FailureDetail)(nil)).Elem()
}

func (i *failureDetailPtrType) ToFailureDetailPtrOutput() FailureDetailPtrOutput {
	return i.ToFailureDetailPtrOutputWithContext(context.Background())
}

func (i *failureDetailPtrType) ToFailureDetailPtrOutputWithContext(ctx context.Context) FailureDetailPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FailureDetailPtrOutput)
}

func (i *failureDetailPtrType) ToOutput(ctx context.Context) pulumix.Output[*FailureDetail] {
	return pulumix.Output[*FailureDetail]{
		OutputState: i.ToFailureDetailPtrOutputWithContext(ctx).OutputState,
	}
}

// Details for an outcome with a FAILURE outcome summary.
type FailureDetailOutput struct{ *pulumi.OutputState }

func (FailureDetailOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FailureDetail)(nil)).Elem()
}

func (o FailureDetailOutput) ToFailureDetailOutput() FailureDetailOutput {
	return o
}

func (o FailureDetailOutput) ToFailureDetailOutputWithContext(ctx context.Context) FailureDetailOutput {
	return o
}

func (o FailureDetailOutput) ToFailureDetailPtrOutput() FailureDetailPtrOutput {
	return o.ToFailureDetailPtrOutputWithContext(context.Background())
}

func (o FailureDetailOutput) ToFailureDetailPtrOutputWithContext(ctx context.Context) FailureDetailPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FailureDetail) *FailureDetail {
		return &v
	}).(FailureDetailPtrOutput)
}

func (o FailureDetailOutput) ToOutput(ctx context.Context) pulumix.Output[FailureDetail] {
	return pulumix.Output[FailureDetail]{
		OutputState: o.OutputState,
	}
}

// If the failure was severe because the system (app) under test crashed.
func (o FailureDetailOutput) Crashed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FailureDetail) *bool { return v.Crashed }).(pulumi.BoolPtrOutput)
}

// If the device ran out of memory during a test, causing the test to crash.
func (o FailureDetailOutput) DeviceOutOfMemory() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FailureDetail) *bool { return v.DeviceOutOfMemory }).(pulumi.BoolPtrOutput)
}

// If the Roboscript failed to complete successfully, e.g., because a Roboscript action or assertion failed or a Roboscript action could not be matched during the entire crawl.
func (o FailureDetailOutput) FailedRoboscript() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FailureDetail) *bool { return v.FailedRoboscript }).(pulumi.BoolPtrOutput)
}

// If an app is not installed and thus no test can be run with the app. This might be caused by trying to run a test on an unsupported platform.
func (o FailureDetailOutput) NotInstalled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FailureDetail) *bool { return v.NotInstalled }).(pulumi.BoolPtrOutput)
}

// If a native process (including any other than the app) crashed.
func (o FailureDetailOutput) OtherNativeCrash() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FailureDetail) *bool { return v.OtherNativeCrash }).(pulumi.BoolPtrOutput)
}

// If the test overran some time limit, and that is why it failed.
func (o FailureDetailOutput) TimedOut() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FailureDetail) *bool { return v.TimedOut }).(pulumi.BoolPtrOutput)
}

// If the robo was unable to crawl the app; perhaps because the app did not start.
func (o FailureDetailOutput) UnableToCrawl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FailureDetail) *bool { return v.UnableToCrawl }).(pulumi.BoolPtrOutput)
}

type FailureDetailPtrOutput struct{ *pulumi.OutputState }

func (FailureDetailPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FailureDetail)(nil)).Elem()
}

func (o FailureDetailPtrOutput) ToFailureDetailPtrOutput() FailureDetailPtrOutput {
	return o
}

func (o FailureDetailPtrOutput) ToFailureDetailPtrOutputWithContext(ctx context.Context) FailureDetailPtrOutput {
	return o
}

func (o FailureDetailPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*FailureDetail] {
	return pulumix.Output[*FailureDetail]{
		OutputState: o.OutputState,
	}
}

func (o FailureDetailPtrOutput) Elem() FailureDetailOutput {
	return o.ApplyT(func(v *FailureDetail) FailureDetail {
		if v != nil {
			return *v
		}
		var ret FailureDetail
		return ret
	}).(FailureDetailOutput)
}

// If the failure was severe because the system (app) under test crashed.
func (o FailureDetailPtrOutput) Crashed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FailureDetail) *bool {
		if v == nil {
			return nil
		}
		return v.Crashed
	}).(pulumi.BoolPtrOutput)
}

// If the device ran out of memory during a test, causing the test to crash.
func (o FailureDetailPtrOutput) DeviceOutOfMemory() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FailureDetail) *bool {
		if v == nil {
			return nil
		}
		return v.DeviceOutOfMemory
	}).(pulumi.BoolPtrOutput)
}

// If the Roboscript failed to complete successfully, e.g., because a Roboscript action or assertion failed or a Roboscript action could not be matched during the entire crawl.
func (o FailureDetailPtrOutput) FailedRoboscript() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FailureDetail) *bool {
		if v == nil {
			return nil
		}
		return v.FailedRoboscript
	}).(pulumi.BoolPtrOutput)
}

// If an app is not installed and thus no test can be run with the app. This might be caused by trying to run a test on an unsupported platform.
func (o FailureDetailPtrOutput) NotInstalled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FailureDetail) *bool {
		if v == nil {
			return nil
		}
		return v.NotInstalled
	}).(pulumi.BoolPtrOutput)
}

// If a native process (including any other than the app) crashed.
func (o FailureDetailPtrOutput) OtherNativeCrash() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FailureDetail) *bool {
		if v == nil {
			return nil
		}
		return v.OtherNativeCrash
	}).(pulumi.BoolPtrOutput)
}

// If the test overran some time limit, and that is why it failed.
func (o FailureDetailPtrOutput) TimedOut() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FailureDetail) *bool {
		if v == nil {
			return nil
		}
		return v.TimedOut
	}).(pulumi.BoolPtrOutput)
}

// If the robo was unable to crawl the app; perhaps because the app did not start.
func (o FailureDetailPtrOutput) UnableToCrawl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FailureDetail) *bool {
		if v == nil {
			return nil
		}
		return v.UnableToCrawl
	}).(pulumi.BoolPtrOutput)
}

// Details for an outcome with a FAILURE outcome summary.
type FailureDetailResponse struct {
	// If the failure was severe because the system (app) under test crashed.
	Crashed bool `pulumi:"crashed"`
	// If the device ran out of memory during a test, causing the test to crash.
	DeviceOutOfMemory bool `pulumi:"deviceOutOfMemory"`
	// If the Roboscript failed to complete successfully, e.g., because a Roboscript action or assertion failed or a Roboscript action could not be matched during the entire crawl.
	FailedRoboscript bool `pulumi:"failedRoboscript"`
	// If an app is not installed and thus no test can be run with the app. This might be caused by trying to run a test on an unsupported platform.
	NotInstalled bool `pulumi:"notInstalled"`
	// If a native process (including any other than the app) crashed.
	OtherNativeCrash bool `pulumi:"otherNativeCrash"`
	// If the test overran some time limit, and that is why it failed.
	TimedOut bool `pulumi:"timedOut"`
	// If the robo was unable to crawl the app; perhaps because the app did not start.
	UnableToCrawl bool `pulumi:"unableToCrawl"`
}

// Details for an outcome with a FAILURE outcome summary.
type FailureDetailResponseOutput struct{ *pulumi.OutputState }

func (FailureDetailResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FailureDetailResponse)(nil)).Elem()
}

func (o FailureDetailResponseOutput) ToFailureDetailResponseOutput() FailureDetailResponseOutput {
	return o
}

func (o FailureDetailResponseOutput) ToFailureDetailResponseOutputWithContext(ctx context.Context) FailureDetailResponseOutput {
	return o
}

func (o FailureDetailResponseOutput) ToOutput(ctx context.Context) pulumix.Output[FailureDetailResponse] {
	return pulumix.Output[FailureDetailResponse]{
		OutputState: o.OutputState,
	}
}

// If the failure was severe because the system (app) under test crashed.
func (o FailureDetailResponseOutput) Crashed() pulumi.BoolOutput {
	return o.ApplyT(func(v FailureDetailResponse) bool { return v.Crashed }).(pulumi.BoolOutput)
}

// If the device ran out of memory during a test, causing the test to crash.
func (o FailureDetailResponseOutput) DeviceOutOfMemory() pulumi.BoolOutput {
	return o.ApplyT(func(v FailureDetailResponse) bool { return v.DeviceOutOfMemory }).(pulumi.BoolOutput)
}

// If the Roboscript failed to complete successfully, e.g., because a Roboscript action or assertion failed or a Roboscript action could not be matched during the entire crawl.
func (o FailureDetailResponseOutput) FailedRoboscript() pulumi.BoolOutput {
	return o.ApplyT(func(v FailureDetailResponse) bool { return v.FailedRoboscript }).(pulumi.BoolOutput)
}

// If an app is not installed and thus no test can be run with the app. This might be caused by trying to run a test on an unsupported platform.
func (o FailureDetailResponseOutput) NotInstalled() pulumi.BoolOutput {
	return o.ApplyT(func(v FailureDetailResponse) bool { return v.NotInstalled }).(pulumi.BoolOutput)
}

// If a native process (including any other than the app) crashed.
func (o FailureDetailResponseOutput) OtherNativeCrash() pulumi.BoolOutput {
	return o.ApplyT(func(v FailureDetailResponse) bool { return v.OtherNativeCrash }).(pulumi.BoolOutput)
}

// If the test overran some time limit, and that is why it failed.
func (o FailureDetailResponseOutput) TimedOut() pulumi.BoolOutput {
	return o.ApplyT(func(v FailureDetailResponse) bool { return v.TimedOut }).(pulumi.BoolOutput)
}

// If the robo was unable to crawl the app; perhaps because the app did not start.
func (o FailureDetailResponseOutput) UnableToCrawl() pulumi.BoolOutput {
	return o.ApplyT(func(v FailureDetailResponse) bool { return v.UnableToCrawl }).(pulumi.BoolOutput)
}

// A reference to a file.
type FileReference struct {
	// The URI of a file stored in Google Cloud Storage. For example: http://storage.googleapis.com/mybucket/path/to/test.xml or in gsutil format: gs://mybucket/path/to/test.xml with version-specific info, gs://mybucket/path/to/test.xml#1360383693690000 An INVALID_ARGUMENT error will be returned if the URI format is not supported. - In response: always set - In create/update request: always set
	FileUri *string `pulumi:"fileUri"`
}

// FileReferenceInput is an input type that accepts FileReferenceArgs and FileReferenceOutput values.
// You can construct a concrete instance of `FileReferenceInput` via:
//
//	FileReferenceArgs{...}
type FileReferenceInput interface {
	pulumi.Input

	ToFileReferenceOutput() FileReferenceOutput
	ToFileReferenceOutputWithContext(context.Context) FileReferenceOutput
}

// A reference to a file.
type FileReferenceArgs struct {
	// The URI of a file stored in Google Cloud Storage. For example: http://storage.googleapis.com/mybucket/path/to/test.xml or in gsutil format: gs://mybucket/path/to/test.xml with version-specific info, gs://mybucket/path/to/test.xml#1360383693690000 An INVALID_ARGUMENT error will be returned if the URI format is not supported. - In response: always set - In create/update request: always set
	FileUri pulumi.StringPtrInput `pulumi:"fileUri"`
}

func (FileReferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FileReference)(nil)).Elem()
}

func (i FileReferenceArgs) ToFileReferenceOutput() FileReferenceOutput {
	return i.ToFileReferenceOutputWithContext(context.Background())
}

func (i FileReferenceArgs) ToFileReferenceOutputWithContext(ctx context.Context) FileReferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileReferenceOutput)
}

func (i FileReferenceArgs) ToOutput(ctx context.Context) pulumix.Output[FileReference] {
	return pulumix.Output[FileReference]{
		OutputState: i.ToFileReferenceOutputWithContext(ctx).OutputState,
	}
}

func (i FileReferenceArgs) ToFileReferencePtrOutput() FileReferencePtrOutput {
	return i.ToFileReferencePtrOutputWithContext(context.Background())
}

func (i FileReferenceArgs) ToFileReferencePtrOutputWithContext(ctx context.Context) FileReferencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileReferenceOutput).ToFileReferencePtrOutputWithContext(ctx)
}

// FileReferencePtrInput is an input type that accepts FileReferenceArgs, FileReferencePtr and FileReferencePtrOutput values.
// You can construct a concrete instance of `FileReferencePtrInput` via:
//
//	        FileReferenceArgs{...}
//
//	or:
//
//	        nil
type FileReferencePtrInput interface {
	pulumi.Input

	ToFileReferencePtrOutput() FileReferencePtrOutput
	ToFileReferencePtrOutputWithContext(context.Context) FileReferencePtrOutput
}

type fileReferencePtrType FileReferenceArgs

func FileReferencePtr(v *FileReferenceArgs) FileReferencePtrInput {
	return (*fileReferencePtrType)(v)
}

func (*fileReferencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FileReference)(nil)).Elem()
}

func (i *fileReferencePtrType) ToFileReferencePtrOutput() FileReferencePtrOutput {
	return i.ToFileReferencePtrOutputWithContext(context.Background())
}

func (i *fileReferencePtrType) ToFileReferencePtrOutputWithContext(ctx context.Context) FileReferencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileReferencePtrOutput)
}

func (i *fileReferencePtrType) ToOutput(ctx context.Context) pulumix.Output[*FileReference] {
	return pulumix.Output[*FileReference]{
		OutputState: i.ToFileReferencePtrOutputWithContext(ctx).OutputState,
	}
}

// FileReferenceArrayInput is an input type that accepts FileReferenceArray and FileReferenceArrayOutput values.
// You can construct a concrete instance of `FileReferenceArrayInput` via:
//
//	FileReferenceArray{ FileReferenceArgs{...} }
type FileReferenceArrayInput interface {
	pulumi.Input

	ToFileReferenceArrayOutput() FileReferenceArrayOutput
	ToFileReferenceArrayOutputWithContext(context.Context) FileReferenceArrayOutput
}

type FileReferenceArray []FileReferenceInput

func (FileReferenceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FileReference)(nil)).Elem()
}

func (i FileReferenceArray) ToFileReferenceArrayOutput() FileReferenceArrayOutput {
	return i.ToFileReferenceArrayOutputWithContext(context.Background())
}

func (i FileReferenceArray) ToFileReferenceArrayOutputWithContext(ctx context.Context) FileReferenceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileReferenceArrayOutput)
}

func (i FileReferenceArray) ToOutput(ctx context.Context) pulumix.Output[[]FileReference] {
	return pulumix.Output[[]FileReference]{
		OutputState: i.ToFileReferenceArrayOutputWithContext(ctx).OutputState,
	}
}

// A reference to a file.
type FileReferenceOutput struct{ *pulumi.OutputState }

func (FileReferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FileReference)(nil)).Elem()
}

func (o FileReferenceOutput) ToFileReferenceOutput() FileReferenceOutput {
	return o
}

func (o FileReferenceOutput) ToFileReferenceOutputWithContext(ctx context.Context) FileReferenceOutput {
	return o
}

func (o FileReferenceOutput) ToFileReferencePtrOutput() FileReferencePtrOutput {
	return o.ToFileReferencePtrOutputWithContext(context.Background())
}

func (o FileReferenceOutput) ToFileReferencePtrOutputWithContext(ctx context.Context) FileReferencePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FileReference) *FileReference {
		return &v
	}).(FileReferencePtrOutput)
}

func (o FileReferenceOutput) ToOutput(ctx context.Context) pulumix.Output[FileReference] {
	return pulumix.Output[FileReference]{
		OutputState: o.OutputState,
	}
}

// The URI of a file stored in Google Cloud Storage. For example: http://storage.googleapis.com/mybucket/path/to/test.xml or in gsutil format: gs://mybucket/path/to/test.xml with version-specific info, gs://mybucket/path/to/test.xml#1360383693690000 An INVALID_ARGUMENT error will be returned if the URI format is not supported. - In response: always set - In create/update request: always set
func (o FileReferenceOutput) FileUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FileReference) *string { return v.FileUri }).(pulumi.StringPtrOutput)
}

type FileReferencePtrOutput struct{ *pulumi.OutputState }

func (FileReferencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FileReference)(nil)).Elem()
}

func (o FileReferencePtrOutput) ToFileReferencePtrOutput() FileReferencePtrOutput {
	return o
}

func (o FileReferencePtrOutput) ToFileReferencePtrOutputWithContext(ctx context.Context) FileReferencePtrOutput {
	return o
}

func (o FileReferencePtrOutput) ToOutput(ctx context.Context) pulumix.Output[*FileReference] {
	return pulumix.Output[*FileReference]{
		OutputState: o.OutputState,
	}
}

func (o FileReferencePtrOutput) Elem() FileReferenceOutput {
	return o.ApplyT(func(v *FileReference) FileReference {
		if v != nil {
			return *v
		}
		var ret FileReference
		return ret
	}).(FileReferenceOutput)
}

// The URI of a file stored in Google Cloud Storage. For example: http://storage.googleapis.com/mybucket/path/to/test.xml or in gsutil format: gs://mybucket/path/to/test.xml with version-specific info, gs://mybucket/path/to/test.xml#1360383693690000 An INVALID_ARGUMENT error will be returned if the URI format is not supported. - In response: always set - In create/update request: always set
func (o FileReferencePtrOutput) FileUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FileReference) *string {
		if v == nil {
			return nil
		}
		return v.FileUri
	}).(pulumi.StringPtrOutput)
}

type FileReferenceArrayOutput struct{ *pulumi.OutputState }

func (FileReferenceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FileReference)(nil)).Elem()
}

func (o FileReferenceArrayOutput) ToFileReferenceArrayOutput() FileReferenceArrayOutput {
	return o
}

func (o FileReferenceArrayOutput) ToFileReferenceArrayOutputWithContext(ctx context.Context) FileReferenceArrayOutput {
	return o
}

func (o FileReferenceArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]FileReference] {
	return pulumix.Output[[]FileReference]{
		OutputState: o.OutputState,
	}
}

func (o FileReferenceArrayOutput) Index(i pulumi.IntInput) FileReferenceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FileReference {
		return vs[0].([]FileReference)[vs[1].(int)]
	}).(FileReferenceOutput)
}

// A reference to a file.
type FileReferenceResponse struct {
	// The URI of a file stored in Google Cloud Storage. For example: http://storage.googleapis.com/mybucket/path/to/test.xml or in gsutil format: gs://mybucket/path/to/test.xml with version-specific info, gs://mybucket/path/to/test.xml#1360383693690000 An INVALID_ARGUMENT error will be returned if the URI format is not supported. - In response: always set - In create/update request: always set
	FileUri string `pulumi:"fileUri"`
}

// A reference to a file.
type FileReferenceResponseOutput struct{ *pulumi.OutputState }

func (FileReferenceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FileReferenceResponse)(nil)).Elem()
}

func (o FileReferenceResponseOutput) ToFileReferenceResponseOutput() FileReferenceResponseOutput {
	return o
}

func (o FileReferenceResponseOutput) ToFileReferenceResponseOutputWithContext(ctx context.Context) FileReferenceResponseOutput {
	return o
}

func (o FileReferenceResponseOutput) ToOutput(ctx context.Context) pulumix.Output[FileReferenceResponse] {
	return pulumix.Output[FileReferenceResponse]{
		OutputState: o.OutputState,
	}
}

// The URI of a file stored in Google Cloud Storage. For example: http://storage.googleapis.com/mybucket/path/to/test.xml or in gsutil format: gs://mybucket/path/to/test.xml with version-specific info, gs://mybucket/path/to/test.xml#1360383693690000 An INVALID_ARGUMENT error will be returned if the URI format is not supported. - In response: always set - In create/update request: always set
func (o FileReferenceResponseOutput) FileUri() pulumi.StringOutput {
	return o.ApplyT(func(v FileReferenceResponse) string { return v.FileUri }).(pulumi.StringOutput)
}

type FileReferenceResponseArrayOutput struct{ *pulumi.OutputState }

func (FileReferenceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FileReferenceResponse)(nil)).Elem()
}

func (o FileReferenceResponseArrayOutput) ToFileReferenceResponseArrayOutput() FileReferenceResponseArrayOutput {
	return o
}

func (o FileReferenceResponseArrayOutput) ToFileReferenceResponseArrayOutputWithContext(ctx context.Context) FileReferenceResponseArrayOutput {
	return o
}

func (o FileReferenceResponseArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]FileReferenceResponse] {
	return pulumix.Output[[]FileReferenceResponse]{
		OutputState: o.OutputState,
	}
}

func (o FileReferenceResponseArrayOutput) Index(i pulumi.IntInput) FileReferenceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FileReferenceResponse {
		return vs[0].([]FileReferenceResponse)[vs[1].(int)]
	}).(FileReferenceResponseOutput)
}

// Details for an outcome with an INCONCLUSIVE outcome summary.
type InconclusiveDetail struct {
	// If the end user aborted the test execution before a pass or fail could be determined. For example, the user pressed ctrl-c which sent a kill signal to the test runner while the test was running.
	AbortedByUser *bool `pulumi:"abortedByUser"`
	// If results are being provided to the user in certain cases of infrastructure failures
	HasErrorLogs *bool `pulumi:"hasErrorLogs"`
	// If the test runner could not determine success or failure because the test depends on a component other than the system under test which failed. For example, a mobile test requires provisioning a device where the test executes, and that provisioning can fail.
	InfrastructureFailure *bool `pulumi:"infrastructureFailure"`
}

// InconclusiveDetailInput is an input type that accepts InconclusiveDetailArgs and InconclusiveDetailOutput values.
// You can construct a concrete instance of `InconclusiveDetailInput` via:
//
//	InconclusiveDetailArgs{...}
type InconclusiveDetailInput interface {
	pulumi.Input

	ToInconclusiveDetailOutput() InconclusiveDetailOutput
	ToInconclusiveDetailOutputWithContext(context.Context) InconclusiveDetailOutput
}

// Details for an outcome with an INCONCLUSIVE outcome summary.
type InconclusiveDetailArgs struct {
	// If the end user aborted the test execution before a pass or fail could be determined. For example, the user pressed ctrl-c which sent a kill signal to the test runner while the test was running.
	AbortedByUser pulumi.BoolPtrInput `pulumi:"abortedByUser"`
	// If results are being provided to the user in certain cases of infrastructure failures
	HasErrorLogs pulumi.BoolPtrInput `pulumi:"hasErrorLogs"`
	// If the test runner could not determine success or failure because the test depends on a component other than the system under test which failed. For example, a mobile test requires provisioning a device where the test executes, and that provisioning can fail.
	InfrastructureFailure pulumi.BoolPtrInput `pulumi:"infrastructureFailure"`
}

func (InconclusiveDetailArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InconclusiveDetail)(nil)).Elem()
}

func (i InconclusiveDetailArgs) ToInconclusiveDetailOutput() InconclusiveDetailOutput {
	return i.ToInconclusiveDetailOutputWithContext(context.Background())
}

func (i InconclusiveDetailArgs) ToInconclusiveDetailOutputWithContext(ctx context.Context) InconclusiveDetailOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InconclusiveDetailOutput)
}

func (i InconclusiveDetailArgs) ToOutput(ctx context.Context) pulumix.Output[InconclusiveDetail] {
	return pulumix.Output[InconclusiveDetail]{
		OutputState: i.ToInconclusiveDetailOutputWithContext(ctx).OutputState,
	}
}

func (i InconclusiveDetailArgs) ToInconclusiveDetailPtrOutput() InconclusiveDetailPtrOutput {
	return i.ToInconclusiveDetailPtrOutputWithContext(context.Background())
}

func (i InconclusiveDetailArgs) ToInconclusiveDetailPtrOutputWithContext(ctx context.Context) InconclusiveDetailPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InconclusiveDetailOutput).ToInconclusiveDetailPtrOutputWithContext(ctx)
}

// InconclusiveDetailPtrInput is an input type that accepts InconclusiveDetailArgs, InconclusiveDetailPtr and InconclusiveDetailPtrOutput values.
// You can construct a concrete instance of `InconclusiveDetailPtrInput` via:
//
//	        InconclusiveDetailArgs{...}
//
//	or:
//
//	        nil
type InconclusiveDetailPtrInput interface {
	pulumi.Input

	ToInconclusiveDetailPtrOutput() InconclusiveDetailPtrOutput
	ToInconclusiveDetailPtrOutputWithContext(context.Context) InconclusiveDetailPtrOutput
}

type inconclusiveDetailPtrType InconclusiveDetailArgs

func InconclusiveDetailPtr(v *InconclusiveDetailArgs) InconclusiveDetailPtrInput {
	return (*inconclusiveDetailPtrType)(v)
}

func (*inconclusiveDetailPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InconclusiveDetail)(nil)).Elem()
}

func (i *inconclusiveDetailPtrType) ToInconclusiveDetailPtrOutput() InconclusiveDetailPtrOutput {
	return i.ToInconclusiveDetailPtrOutputWithContext(context.Background())
}

func (i *inconclusiveDetailPtrType) ToInconclusiveDetailPtrOutputWithContext(ctx context.Context) InconclusiveDetailPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InconclusiveDetailPtrOutput)
}

func (i *inconclusiveDetailPtrType) ToOutput(ctx context.Context) pulumix.Output[*InconclusiveDetail] {
	return pulumix.Output[*InconclusiveDetail]{
		OutputState: i.ToInconclusiveDetailPtrOutputWithContext(ctx).OutputState,
	}
}

// Details for an outcome with an INCONCLUSIVE outcome summary.
type InconclusiveDetailOutput struct{ *pulumi.OutputState }

func (InconclusiveDetailOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InconclusiveDetail)(nil)).Elem()
}

func (o InconclusiveDetailOutput) ToInconclusiveDetailOutput() InconclusiveDetailOutput {
	return o
}

func (o InconclusiveDetailOutput) ToInconclusiveDetailOutputWithContext(ctx context.Context) InconclusiveDetailOutput {
	return o
}

func (o InconclusiveDetailOutput) ToInconclusiveDetailPtrOutput() InconclusiveDetailPtrOutput {
	return o.ToInconclusiveDetailPtrOutputWithContext(context.Background())
}

func (o InconclusiveDetailOutput) ToInconclusiveDetailPtrOutputWithContext(ctx context.Context) InconclusiveDetailPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v InconclusiveDetail) *InconclusiveDetail {
		return &v
	}).(InconclusiveDetailPtrOutput)
}

func (o InconclusiveDetailOutput) ToOutput(ctx context.Context) pulumix.Output[InconclusiveDetail] {
	return pulumix.Output[InconclusiveDetail]{
		OutputState: o.OutputState,
	}
}

// If the end user aborted the test execution before a pass or fail could be determined. For example, the user pressed ctrl-c which sent a kill signal to the test runner while the test was running.
func (o InconclusiveDetailOutput) AbortedByUser() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v InconclusiveDetail) *bool { return v.AbortedByUser }).(pulumi.BoolPtrOutput)
}

// If results are being provided to the user in certain cases of infrastructure failures
func (o InconclusiveDetailOutput) HasErrorLogs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v InconclusiveDetail) *bool { return v.HasErrorLogs }).(pulumi.BoolPtrOutput)
}

// If the test runner could not determine success or failure because the test depends on a component other than the system under test which failed. For example, a mobile test requires provisioning a device where the test executes, and that provisioning can fail.
func (o InconclusiveDetailOutput) InfrastructureFailure() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v InconclusiveDetail) *bool { return v.InfrastructureFailure }).(pulumi.BoolPtrOutput)
}

type InconclusiveDetailPtrOutput struct{ *pulumi.OutputState }

func (InconclusiveDetailPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InconclusiveDetail)(nil)).Elem()
}

func (o InconclusiveDetailPtrOutput) ToInconclusiveDetailPtrOutput() InconclusiveDetailPtrOutput {
	return o
}

func (o InconclusiveDetailPtrOutput) ToInconclusiveDetailPtrOutputWithContext(ctx context.Context) InconclusiveDetailPtrOutput {
	return o
}

func (o InconclusiveDetailPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*InconclusiveDetail] {
	return pulumix.Output[*InconclusiveDetail]{
		OutputState: o.OutputState,
	}
}

func (o InconclusiveDetailPtrOutput) Elem() InconclusiveDetailOutput {
	return o.ApplyT(func(v *InconclusiveDetail) InconclusiveDetail {
		if v != nil {
			return *v
		}
		var ret InconclusiveDetail
		return ret
	}).(InconclusiveDetailOutput)
}

// If the end user aborted the test execution before a pass or fail could be determined. For example, the user pressed ctrl-c which sent a kill signal to the test runner while the test was running.
func (o InconclusiveDetailPtrOutput) AbortedByUser() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *InconclusiveDetail) *bool {
		if v == nil {
			return nil
		}
		return v.AbortedByUser
	}).(pulumi.BoolPtrOutput)
}

// If results are being provided to the user in certain cases of infrastructure failures
func (o InconclusiveDetailPtrOutput) HasErrorLogs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *InconclusiveDetail) *bool {
		if v == nil {
			return nil
		}
		return v.HasErrorLogs
	}).(pulumi.BoolPtrOutput)
}

// If the test runner could not determine success or failure because the test depends on a component other than the system under test which failed. For example, a mobile test requires provisioning a device where the test executes, and that provisioning can fail.
func (o InconclusiveDetailPtrOutput) InfrastructureFailure() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *InconclusiveDetail) *bool {
		if v == nil {
			return nil
		}
		return v.InfrastructureFailure
	}).(pulumi.BoolPtrOutput)
}

// Details for an outcome with an INCONCLUSIVE outcome summary.
type InconclusiveDetailResponse struct {
	// If the end user aborted the test execution before a pass or fail could be determined. For example, the user pressed ctrl-c which sent a kill signal to the test runner while the test was running.
	AbortedByUser bool `pulumi:"abortedByUser"`
	// If results are being provided to the user in certain cases of infrastructure failures
	HasErrorLogs bool `pulumi:"hasErrorLogs"`
	// If the test runner could not determine success or failure because the test depends on a component other than the system under test which failed. For example, a mobile test requires provisioning a device where the test executes, and that provisioning can fail.
	InfrastructureFailure bool `pulumi:"infrastructureFailure"`
}

// Details for an outcome with an INCONCLUSIVE outcome summary.
type InconclusiveDetailResponseOutput struct{ *pulumi.OutputState }

func (InconclusiveDetailResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InconclusiveDetailResponse)(nil)).Elem()
}

func (o InconclusiveDetailResponseOutput) ToInconclusiveDetailResponseOutput() InconclusiveDetailResponseOutput {
	return o
}

func (o InconclusiveDetailResponseOutput) ToInconclusiveDetailResponseOutputWithContext(ctx context.Context) InconclusiveDetailResponseOutput {
	return o
}

func (o InconclusiveDetailResponseOutput) ToOutput(ctx context.Context) pulumix.Output[InconclusiveDetailResponse] {
	return pulumix.Output[InconclusiveDetailResponse]{
		OutputState: o.OutputState,
	}
}

// If the end user aborted the test execution before a pass or fail could be determined. For example, the user pressed ctrl-c which sent a kill signal to the test runner while the test was running.
func (o InconclusiveDetailResponseOutput) AbortedByUser() pulumi.BoolOutput {
	return o.ApplyT(func(v InconclusiveDetailResponse) bool { return v.AbortedByUser }).(pulumi.BoolOutput)
}

// If results are being provided to the user in certain cases of infrastructure failures
func (o InconclusiveDetailResponseOutput) HasErrorLogs() pulumi.BoolOutput {
	return o.ApplyT(func(v InconclusiveDetailResponse) bool { return v.HasErrorLogs }).(pulumi.BoolOutput)
}

// If the test runner could not determine success or failure because the test depends on a component other than the system under test which failed. For example, a mobile test requires provisioning a device where the test executes, and that provisioning can fail.
func (o InconclusiveDetailResponseOutput) InfrastructureFailure() pulumi.BoolOutput {
	return o.ApplyT(func(v InconclusiveDetailResponse) bool { return v.InfrastructureFailure }).(pulumi.BoolOutput)
}

// Step Id and outcome of each individual step that was run as a group with other steps with the same configuration.
type IndividualOutcome struct {
	// Unique int given to each step. Ranges from 0(inclusive) to total number of steps(exclusive). The primary step is 0.
	MultistepNumber *int                             `pulumi:"multistepNumber"`
	OutcomeSummary  *IndividualOutcomeOutcomeSummary `pulumi:"outcomeSummary"`
	// How long it took for this step to run.
	RunDuration *Duration `pulumi:"runDuration"`
	StepId      *string   `pulumi:"stepId"`
}

// IndividualOutcomeInput is an input type that accepts IndividualOutcomeArgs and IndividualOutcomeOutput values.
// You can construct a concrete instance of `IndividualOutcomeInput` via:
//
//	IndividualOutcomeArgs{...}
type IndividualOutcomeInput interface {
	pulumi.Input

	ToIndividualOutcomeOutput() IndividualOutcomeOutput
	ToIndividualOutcomeOutputWithContext(context.Context) IndividualOutcomeOutput
}

// Step Id and outcome of each individual step that was run as a group with other steps with the same configuration.
type IndividualOutcomeArgs struct {
	// Unique int given to each step. Ranges from 0(inclusive) to total number of steps(exclusive). The primary step is 0.
	MultistepNumber pulumi.IntPtrInput                      `pulumi:"multistepNumber"`
	OutcomeSummary  IndividualOutcomeOutcomeSummaryPtrInput `pulumi:"outcomeSummary"`
	// How long it took for this step to run.
	RunDuration DurationPtrInput      `pulumi:"runDuration"`
	StepId      pulumi.StringPtrInput `pulumi:"stepId"`
}

func (IndividualOutcomeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndividualOutcome)(nil)).Elem()
}

func (i IndividualOutcomeArgs) ToIndividualOutcomeOutput() IndividualOutcomeOutput {
	return i.ToIndividualOutcomeOutputWithContext(context.Background())
}

func (i IndividualOutcomeArgs) ToIndividualOutcomeOutputWithContext(ctx context.Context) IndividualOutcomeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndividualOutcomeOutput)
}

func (i IndividualOutcomeArgs) ToOutput(ctx context.Context) pulumix.Output[IndividualOutcome] {
	return pulumix.Output[IndividualOutcome]{
		OutputState: i.ToIndividualOutcomeOutputWithContext(ctx).OutputState,
	}
}

// IndividualOutcomeArrayInput is an input type that accepts IndividualOutcomeArray and IndividualOutcomeArrayOutput values.
// You can construct a concrete instance of `IndividualOutcomeArrayInput` via:
//
//	IndividualOutcomeArray{ IndividualOutcomeArgs{...} }
type IndividualOutcomeArrayInput interface {
	pulumi.Input

	ToIndividualOutcomeArrayOutput() IndividualOutcomeArrayOutput
	ToIndividualOutcomeArrayOutputWithContext(context.Context) IndividualOutcomeArrayOutput
}

type IndividualOutcomeArray []IndividualOutcomeInput

func (IndividualOutcomeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndividualOutcome)(nil)).Elem()
}

func (i IndividualOutcomeArray) ToIndividualOutcomeArrayOutput() IndividualOutcomeArrayOutput {
	return i.ToIndividualOutcomeArrayOutputWithContext(context.Background())
}

func (i IndividualOutcomeArray) ToIndividualOutcomeArrayOutputWithContext(ctx context.Context) IndividualOutcomeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndividualOutcomeArrayOutput)
}

func (i IndividualOutcomeArray) ToOutput(ctx context.Context) pulumix.Output[[]IndividualOutcome] {
	return pulumix.Output[[]IndividualOutcome]{
		OutputState: i.ToIndividualOutcomeArrayOutputWithContext(ctx).OutputState,
	}
}

// Step Id and outcome of each individual step that was run as a group with other steps with the same configuration.
type IndividualOutcomeOutput struct{ *pulumi.OutputState }

func (IndividualOutcomeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndividualOutcome)(nil)).Elem()
}

func (o IndividualOutcomeOutput) ToIndividualOutcomeOutput() IndividualOutcomeOutput {
	return o
}

func (o IndividualOutcomeOutput) ToIndividualOutcomeOutputWithContext(ctx context.Context) IndividualOutcomeOutput {
	return o
}

func (o IndividualOutcomeOutput) ToOutput(ctx context.Context) pulumix.Output[IndividualOutcome] {
	return pulumix.Output[IndividualOutcome]{
		OutputState: o.OutputState,
	}
}

// Unique int given to each step. Ranges from 0(inclusive) to total number of steps(exclusive). The primary step is 0.
func (o IndividualOutcomeOutput) MultistepNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IndividualOutcome) *int { return v.MultistepNumber }).(pulumi.IntPtrOutput)
}

func (o IndividualOutcomeOutput) OutcomeSummary() IndividualOutcomeOutcomeSummaryPtrOutput {
	return o.ApplyT(func(v IndividualOutcome) *IndividualOutcomeOutcomeSummary { return v.OutcomeSummary }).(IndividualOutcomeOutcomeSummaryPtrOutput)
}

// How long it took for this step to run.
func (o IndividualOutcomeOutput) RunDuration() DurationPtrOutput {
	return o.ApplyT(func(v IndividualOutcome) *Duration { return v.RunDuration }).(DurationPtrOutput)
}

func (o IndividualOutcomeOutput) StepId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndividualOutcome) *string { return v.StepId }).(pulumi.StringPtrOutput)
}

type IndividualOutcomeArrayOutput struct{ *pulumi.OutputState }

func (IndividualOutcomeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndividualOutcome)(nil)).Elem()
}

func (o IndividualOutcomeArrayOutput) ToIndividualOutcomeArrayOutput() IndividualOutcomeArrayOutput {
	return o
}

func (o IndividualOutcomeArrayOutput) ToIndividualOutcomeArrayOutputWithContext(ctx context.Context) IndividualOutcomeArrayOutput {
	return o
}

func (o IndividualOutcomeArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]IndividualOutcome] {
	return pulumix.Output[[]IndividualOutcome]{
		OutputState: o.OutputState,
	}
}

func (o IndividualOutcomeArrayOutput) Index(i pulumi.IntInput) IndividualOutcomeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndividualOutcome {
		return vs[0].([]IndividualOutcome)[vs[1].(int)]
	}).(IndividualOutcomeOutput)
}

// Step Id and outcome of each individual step that was run as a group with other steps with the same configuration.
type IndividualOutcomeResponse struct {
	// Unique int given to each step. Ranges from 0(inclusive) to total number of steps(exclusive). The primary step is 0.
	MultistepNumber int    `pulumi:"multistepNumber"`
	OutcomeSummary  string `pulumi:"outcomeSummary"`
	// How long it took for this step to run.
	RunDuration DurationResponse `pulumi:"runDuration"`
	StepId      string           `pulumi:"stepId"`
}

// Step Id and outcome of each individual step that was run as a group with other steps with the same configuration.
type IndividualOutcomeResponseOutput struct{ *pulumi.OutputState }

func (IndividualOutcomeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndividualOutcomeResponse)(nil)).Elem()
}

func (o IndividualOutcomeResponseOutput) ToIndividualOutcomeResponseOutput() IndividualOutcomeResponseOutput {
	return o
}

func (o IndividualOutcomeResponseOutput) ToIndividualOutcomeResponseOutputWithContext(ctx context.Context) IndividualOutcomeResponseOutput {
	return o
}

func (o IndividualOutcomeResponseOutput) ToOutput(ctx context.Context) pulumix.Output[IndividualOutcomeResponse] {
	return pulumix.Output[IndividualOutcomeResponse]{
		OutputState: o.OutputState,
	}
}

// Unique int given to each step. Ranges from 0(inclusive) to total number of steps(exclusive). The primary step is 0.
func (o IndividualOutcomeResponseOutput) MultistepNumber() pulumi.IntOutput {
	return o.ApplyT(func(v IndividualOutcomeResponse) int { return v.MultistepNumber }).(pulumi.IntOutput)
}

func (o IndividualOutcomeResponseOutput) OutcomeSummary() pulumi.StringOutput {
	return o.ApplyT(func(v IndividualOutcomeResponse) string { return v.OutcomeSummary }).(pulumi.StringOutput)
}

// How long it took for this step to run.
func (o IndividualOutcomeResponseOutput) RunDuration() DurationResponseOutput {
	return o.ApplyT(func(v IndividualOutcomeResponse) DurationResponse { return v.RunDuration }).(DurationResponseOutput)
}

func (o IndividualOutcomeResponseOutput) StepId() pulumi.StringOutput {
	return o.ApplyT(func(v IndividualOutcomeResponse) string { return v.StepId }).(pulumi.StringOutput)
}

type IndividualOutcomeResponseArrayOutput struct{ *pulumi.OutputState }

func (IndividualOutcomeResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndividualOutcomeResponse)(nil)).Elem()
}

func (o IndividualOutcomeResponseArrayOutput) ToIndividualOutcomeResponseArrayOutput() IndividualOutcomeResponseArrayOutput {
	return o
}

func (o IndividualOutcomeResponseArrayOutput) ToIndividualOutcomeResponseArrayOutputWithContext(ctx context.Context) IndividualOutcomeResponseArrayOutput {
	return o
}

func (o IndividualOutcomeResponseArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]IndividualOutcomeResponse] {
	return pulumix.Output[[]IndividualOutcomeResponse]{
		OutputState: o.OutputState,
	}
}

func (o IndividualOutcomeResponseArrayOutput) Index(i pulumi.IntInput) IndividualOutcomeResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndividualOutcomeResponse {
		return vs[0].([]IndividualOutcomeResponse)[vs[1].(int)]
	}).(IndividualOutcomeResponseOutput)
}

// iOS app information
type IosAppInfo struct {
	// The name of the app. Required
	Name *string `pulumi:"name"`
}

// IosAppInfoInput is an input type that accepts IosAppInfoArgs and IosAppInfoOutput values.
// You can construct a concrete instance of `IosAppInfoInput` via:
//
//	IosAppInfoArgs{...}
type IosAppInfoInput interface {
	pulumi.Input

	ToIosAppInfoOutput() IosAppInfoOutput
	ToIosAppInfoOutputWithContext(context.Context) IosAppInfoOutput
}

// iOS app information
type IosAppInfoArgs struct {
	// The name of the app. Required
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (IosAppInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IosAppInfo)(nil)).Elem()
}

func (i IosAppInfoArgs) ToIosAppInfoOutput() IosAppInfoOutput {
	return i.ToIosAppInfoOutputWithContext(context.Background())
}

func (i IosAppInfoArgs) ToIosAppInfoOutputWithContext(ctx context.Context) IosAppInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosAppInfoOutput)
}

func (i IosAppInfoArgs) ToOutput(ctx context.Context) pulumix.Output[IosAppInfo] {
	return pulumix.Output[IosAppInfo]{
		OutputState: i.ToIosAppInfoOutputWithContext(ctx).OutputState,
	}
}

func (i IosAppInfoArgs) ToIosAppInfoPtrOutput() IosAppInfoPtrOutput {
	return i.ToIosAppInfoPtrOutputWithContext(context.Background())
}

func (i IosAppInfoArgs) ToIosAppInfoPtrOutputWithContext(ctx context.Context) IosAppInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosAppInfoOutput).ToIosAppInfoPtrOutputWithContext(ctx)
}

// IosAppInfoPtrInput is an input type that accepts IosAppInfoArgs, IosAppInfoPtr and IosAppInfoPtrOutput values.
// You can construct a concrete instance of `IosAppInfoPtrInput` via:
//
//	        IosAppInfoArgs{...}
//
//	or:
//
//	        nil
type IosAppInfoPtrInput interface {
	pulumi.Input

	ToIosAppInfoPtrOutput() IosAppInfoPtrOutput
	ToIosAppInfoPtrOutputWithContext(context.Context) IosAppInfoPtrOutput
}

type iosAppInfoPtrType IosAppInfoArgs

func IosAppInfoPtr(v *IosAppInfoArgs) IosAppInfoPtrInput {
	return (*iosAppInfoPtrType)(v)
}

func (*iosAppInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IosAppInfo)(nil)).Elem()
}

func (i *iosAppInfoPtrType) ToIosAppInfoPtrOutput() IosAppInfoPtrOutput {
	return i.ToIosAppInfoPtrOutputWithContext(context.Background())
}

func (i *iosAppInfoPtrType) ToIosAppInfoPtrOutputWithContext(ctx context.Context) IosAppInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosAppInfoPtrOutput)
}

func (i *iosAppInfoPtrType) ToOutput(ctx context.Context) pulumix.Output[*IosAppInfo] {
	return pulumix.Output[*IosAppInfo]{
		OutputState: i.ToIosAppInfoPtrOutputWithContext(ctx).OutputState,
	}
}

// iOS app information
type IosAppInfoOutput struct{ *pulumi.OutputState }

func (IosAppInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IosAppInfo)(nil)).Elem()
}

func (o IosAppInfoOutput) ToIosAppInfoOutput() IosAppInfoOutput {
	return o
}

func (o IosAppInfoOutput) ToIosAppInfoOutputWithContext(ctx context.Context) IosAppInfoOutput {
	return o
}

func (o IosAppInfoOutput) ToIosAppInfoPtrOutput() IosAppInfoPtrOutput {
	return o.ToIosAppInfoPtrOutputWithContext(context.Background())
}

func (o IosAppInfoOutput) ToIosAppInfoPtrOutputWithContext(ctx context.Context) IosAppInfoPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IosAppInfo) *IosAppInfo {
		return &v
	}).(IosAppInfoPtrOutput)
}

func (o IosAppInfoOutput) ToOutput(ctx context.Context) pulumix.Output[IosAppInfo] {
	return pulumix.Output[IosAppInfo]{
		OutputState: o.OutputState,
	}
}

// The name of the app. Required
func (o IosAppInfoOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IosAppInfo) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type IosAppInfoPtrOutput struct{ *pulumi.OutputState }

func (IosAppInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IosAppInfo)(nil)).Elem()
}

func (o IosAppInfoPtrOutput) ToIosAppInfoPtrOutput() IosAppInfoPtrOutput {
	return o
}

func (o IosAppInfoPtrOutput) ToIosAppInfoPtrOutputWithContext(ctx context.Context) IosAppInfoPtrOutput {
	return o
}

func (o IosAppInfoPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*IosAppInfo] {
	return pulumix.Output[*IosAppInfo]{
		OutputState: o.OutputState,
	}
}

func (o IosAppInfoPtrOutput) Elem() IosAppInfoOutput {
	return o.ApplyT(func(v *IosAppInfo) IosAppInfo {
		if v != nil {
			return *v
		}
		var ret IosAppInfo
		return ret
	}).(IosAppInfoOutput)
}

// The name of the app. Required
func (o IosAppInfoPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IosAppInfo) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// iOS app information
type IosAppInfoResponse struct {
	// The name of the app. Required
	Name string `pulumi:"name"`
}

// iOS app information
type IosAppInfoResponseOutput struct{ *pulumi.OutputState }

func (IosAppInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IosAppInfoResponse)(nil)).Elem()
}

func (o IosAppInfoResponseOutput) ToIosAppInfoResponseOutput() IosAppInfoResponseOutput {
	return o
}

func (o IosAppInfoResponseOutput) ToIosAppInfoResponseOutputWithContext(ctx context.Context) IosAppInfoResponseOutput {
	return o
}

func (o IosAppInfoResponseOutput) ToOutput(ctx context.Context) pulumix.Output[IosAppInfoResponse] {
	return pulumix.Output[IosAppInfoResponse]{
		OutputState: o.OutputState,
	}
}

// The name of the app. Required
func (o IosAppInfoResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v IosAppInfoResponse) string { return v.Name }).(pulumi.StringOutput)
}

// A Robo test for an iOS application.
type IosRoboTest struct {
}

// IosRoboTestInput is an input type that accepts IosRoboTestArgs and IosRoboTestOutput values.
// You can construct a concrete instance of `IosRoboTestInput` via:
//
//	IosRoboTestArgs{...}
type IosRoboTestInput interface {
	pulumi.Input

	ToIosRoboTestOutput() IosRoboTestOutput
	ToIosRoboTestOutputWithContext(context.Context) IosRoboTestOutput
}

// A Robo test for an iOS application.
type IosRoboTestArgs struct {
}

func (IosRoboTestArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IosRoboTest)(nil)).Elem()
}

func (i IosRoboTestArgs) ToIosRoboTestOutput() IosRoboTestOutput {
	return i.ToIosRoboTestOutputWithContext(context.Background())
}

func (i IosRoboTestArgs) ToIosRoboTestOutputWithContext(ctx context.Context) IosRoboTestOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosRoboTestOutput)
}

func (i IosRoboTestArgs) ToOutput(ctx context.Context) pulumix.Output[IosRoboTest] {
	return pulumix.Output[IosRoboTest]{
		OutputState: i.ToIosRoboTestOutputWithContext(ctx).OutputState,
	}
}

func (i IosRoboTestArgs) ToIosRoboTestPtrOutput() IosRoboTestPtrOutput {
	return i.ToIosRoboTestPtrOutputWithContext(context.Background())
}

func (i IosRoboTestArgs) ToIosRoboTestPtrOutputWithContext(ctx context.Context) IosRoboTestPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosRoboTestOutput).ToIosRoboTestPtrOutputWithContext(ctx)
}

// IosRoboTestPtrInput is an input type that accepts IosRoboTestArgs, IosRoboTestPtr and IosRoboTestPtrOutput values.
// You can construct a concrete instance of `IosRoboTestPtrInput` via:
//
//	        IosRoboTestArgs{...}
//
//	or:
//
//	        nil
type IosRoboTestPtrInput interface {
	pulumi.Input

	ToIosRoboTestPtrOutput() IosRoboTestPtrOutput
	ToIosRoboTestPtrOutputWithContext(context.Context) IosRoboTestPtrOutput
}

type iosRoboTestPtrType IosRoboTestArgs

func IosRoboTestPtr(v *IosRoboTestArgs) IosRoboTestPtrInput {
	return (*iosRoboTestPtrType)(v)
}

func (*iosRoboTestPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IosRoboTest)(nil)).Elem()
}

func (i *iosRoboTestPtrType) ToIosRoboTestPtrOutput() IosRoboTestPtrOutput {
	return i.ToIosRoboTestPtrOutputWithContext(context.Background())
}

func (i *iosRoboTestPtrType) ToIosRoboTestPtrOutputWithContext(ctx context.Context) IosRoboTestPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosRoboTestPtrOutput)
}

func (i *iosRoboTestPtrType) ToOutput(ctx context.Context) pulumix.Output[*IosRoboTest] {
	return pulumix.Output[*IosRoboTest]{
		OutputState: i.ToIosRoboTestPtrOutputWithContext(ctx).OutputState,
	}
}

// A Robo test for an iOS application.
type IosRoboTestOutput struct{ *pulumi.OutputState }

func (IosRoboTestOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IosRoboTest)(nil)).Elem()
}

func (o IosRoboTestOutput) ToIosRoboTestOutput() IosRoboTestOutput {
	return o
}

func (o IosRoboTestOutput) ToIosRoboTestOutputWithContext(ctx context.Context) IosRoboTestOutput {
	return o
}

func (o IosRoboTestOutput) ToIosRoboTestPtrOutput() IosRoboTestPtrOutput {
	return o.ToIosRoboTestPtrOutputWithContext(context.Background())
}

func (o IosRoboTestOutput) ToIosRoboTestPtrOutputWithContext(ctx context.Context) IosRoboTestPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IosRoboTest) *IosRoboTest {
		return &v
	}).(IosRoboTestPtrOutput)
}

func (o IosRoboTestOutput) ToOutput(ctx context.Context) pulumix.Output[IosRoboTest] {
	return pulumix.Output[IosRoboTest]{
		OutputState: o.OutputState,
	}
}

type IosRoboTestPtrOutput struct{ *pulumi.OutputState }

func (IosRoboTestPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IosRoboTest)(nil)).Elem()
}

func (o IosRoboTestPtrOutput) ToIosRoboTestPtrOutput() IosRoboTestPtrOutput {
	return o
}

func (o IosRoboTestPtrOutput) ToIosRoboTestPtrOutputWithContext(ctx context.Context) IosRoboTestPtrOutput {
	return o
}

func (o IosRoboTestPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*IosRoboTest] {
	return pulumix.Output[*IosRoboTest]{
		OutputState: o.OutputState,
	}
}

func (o IosRoboTestPtrOutput) Elem() IosRoboTestOutput {
	return o.ApplyT(func(v *IosRoboTest) IosRoboTest {
		if v != nil {
			return *v
		}
		var ret IosRoboTest
		return ret
	}).(IosRoboTestOutput)
}

// A Robo test for an iOS application.
type IosRoboTestResponse struct {
}

// A Robo test for an iOS application.
type IosRoboTestResponseOutput struct{ *pulumi.OutputState }

func (IosRoboTestResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IosRoboTestResponse)(nil)).Elem()
}

func (o IosRoboTestResponseOutput) ToIosRoboTestResponseOutput() IosRoboTestResponseOutput {
	return o
}

func (o IosRoboTestResponseOutput) ToIosRoboTestResponseOutputWithContext(ctx context.Context) IosRoboTestResponseOutput {
	return o
}

func (o IosRoboTestResponseOutput) ToOutput(ctx context.Context) pulumix.Output[IosRoboTestResponse] {
	return pulumix.Output[IosRoboTestResponse]{
		OutputState: o.OutputState,
	}
}

// A iOS mobile test specification
type IosTest struct {
	// Information about the application under test.
	IosAppInfo *IosAppInfo `pulumi:"iosAppInfo"`
	// An iOS Robo test.
	IosRoboTest *IosRoboTest `pulumi:"iosRoboTest"`
	// An iOS test loop.
	IosTestLoop *IosTestLoop `pulumi:"iosTestLoop"`
	// An iOS XCTest.
	IosXcTest *IosXcTest `pulumi:"iosXcTest"`
	// Max time a test is allowed to run before it is automatically cancelled.
	TestTimeout *Duration `pulumi:"testTimeout"`
}

// IosTestInput is an input type that accepts IosTestArgs and IosTestOutput values.
// You can construct a concrete instance of `IosTestInput` via:
//
//	IosTestArgs{...}
type IosTestInput interface {
	pulumi.Input

	ToIosTestOutput() IosTestOutput
	ToIosTestOutputWithContext(context.Context) IosTestOutput
}

// A iOS mobile test specification
type IosTestArgs struct {
	// Information about the application under test.
	IosAppInfo IosAppInfoPtrInput `pulumi:"iosAppInfo"`
	// An iOS Robo test.
	IosRoboTest IosRoboTestPtrInput `pulumi:"iosRoboTest"`
	// An iOS test loop.
	IosTestLoop IosTestLoopPtrInput `pulumi:"iosTestLoop"`
	// An iOS XCTest.
	IosXcTest IosXcTestPtrInput `pulumi:"iosXcTest"`
	// Max time a test is allowed to run before it is automatically cancelled.
	TestTimeout DurationPtrInput `pulumi:"testTimeout"`
}

func (IosTestArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IosTest)(nil)).Elem()
}

func (i IosTestArgs) ToIosTestOutput() IosTestOutput {
	return i.ToIosTestOutputWithContext(context.Background())
}

func (i IosTestArgs) ToIosTestOutputWithContext(ctx context.Context) IosTestOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosTestOutput)
}

func (i IosTestArgs) ToOutput(ctx context.Context) pulumix.Output[IosTest] {
	return pulumix.Output[IosTest]{
		OutputState: i.ToIosTestOutputWithContext(ctx).OutputState,
	}
}

func (i IosTestArgs) ToIosTestPtrOutput() IosTestPtrOutput {
	return i.ToIosTestPtrOutputWithContext(context.Background())
}

func (i IosTestArgs) ToIosTestPtrOutputWithContext(ctx context.Context) IosTestPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosTestOutput).ToIosTestPtrOutputWithContext(ctx)
}

// IosTestPtrInput is an input type that accepts IosTestArgs, IosTestPtr and IosTestPtrOutput values.
// You can construct a concrete instance of `IosTestPtrInput` via:
//
//	        IosTestArgs{...}
//
//	or:
//
//	        nil
type IosTestPtrInput interface {
	pulumi.Input

	ToIosTestPtrOutput() IosTestPtrOutput
	ToIosTestPtrOutputWithContext(context.Context) IosTestPtrOutput
}

type iosTestPtrType IosTestArgs

func IosTestPtr(v *IosTestArgs) IosTestPtrInput {
	return (*iosTestPtrType)(v)
}

func (*iosTestPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IosTest)(nil)).Elem()
}

func (i *iosTestPtrType) ToIosTestPtrOutput() IosTestPtrOutput {
	return i.ToIosTestPtrOutputWithContext(context.Background())
}

func (i *iosTestPtrType) ToIosTestPtrOutputWithContext(ctx context.Context) IosTestPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosTestPtrOutput)
}

func (i *iosTestPtrType) ToOutput(ctx context.Context) pulumix.Output[*IosTest] {
	return pulumix.Output[*IosTest]{
		OutputState: i.ToIosTestPtrOutputWithContext(ctx).OutputState,
	}
}

// A iOS mobile test specification
type IosTestOutput struct{ *pulumi.OutputState }

func (IosTestOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IosTest)(nil)).Elem()
}

func (o IosTestOutput) ToIosTestOutput() IosTestOutput {
	return o
}

func (o IosTestOutput) ToIosTestOutputWithContext(ctx context.Context) IosTestOutput {
	return o
}

func (o IosTestOutput) ToIosTestPtrOutput() IosTestPtrOutput {
	return o.ToIosTestPtrOutputWithContext(context.Background())
}

func (o IosTestOutput) ToIosTestPtrOutputWithContext(ctx context.Context) IosTestPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IosTest) *IosTest {
		return &v
	}).(IosTestPtrOutput)
}

func (o IosTestOutput) ToOutput(ctx context.Context) pulumix.Output[IosTest] {
	return pulumix.Output[IosTest]{
		OutputState: o.OutputState,
	}
}

// Information about the application under test.
func (o IosTestOutput) IosAppInfo() IosAppInfoPtrOutput {
	return o.ApplyT(func(v IosTest) *IosAppInfo { return v.IosAppInfo }).(IosAppInfoPtrOutput)
}

// An iOS Robo test.
func (o IosTestOutput) IosRoboTest() IosRoboTestPtrOutput {
	return o.ApplyT(func(v IosTest) *IosRoboTest { return v.IosRoboTest }).(IosRoboTestPtrOutput)
}

// An iOS test loop.
func (o IosTestOutput) IosTestLoop() IosTestLoopPtrOutput {
	return o.ApplyT(func(v IosTest) *IosTestLoop { return v.IosTestLoop }).(IosTestLoopPtrOutput)
}

// An iOS XCTest.
func (o IosTestOutput) IosXcTest() IosXcTestPtrOutput {
	return o.ApplyT(func(v IosTest) *IosXcTest { return v.IosXcTest }).(IosXcTestPtrOutput)
}

// Max time a test is allowed to run before it is automatically cancelled.
func (o IosTestOutput) TestTimeout() DurationPtrOutput {
	return o.ApplyT(func(v IosTest) *Duration { return v.TestTimeout }).(DurationPtrOutput)
}

type IosTestPtrOutput struct{ *pulumi.OutputState }

func (IosTestPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IosTest)(nil)).Elem()
}

func (o IosTestPtrOutput) ToIosTestPtrOutput() IosTestPtrOutput {
	return o
}

func (o IosTestPtrOutput) ToIosTestPtrOutputWithContext(ctx context.Context) IosTestPtrOutput {
	return o
}

func (o IosTestPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*IosTest] {
	return pulumix.Output[*IosTest]{
		OutputState: o.OutputState,
	}
}

func (o IosTestPtrOutput) Elem() IosTestOutput {
	return o.ApplyT(func(v *IosTest) IosTest {
		if v != nil {
			return *v
		}
		var ret IosTest
		return ret
	}).(IosTestOutput)
}

// Information about the application under test.
func (o IosTestPtrOutput) IosAppInfo() IosAppInfoPtrOutput {
	return o.ApplyT(func(v *IosTest) *IosAppInfo {
		if v == nil {
			return nil
		}
		return v.IosAppInfo
	}).(IosAppInfoPtrOutput)
}

// An iOS Robo test.
func (o IosTestPtrOutput) IosRoboTest() IosRoboTestPtrOutput {
	return o.ApplyT(func(v *IosTest) *IosRoboTest {
		if v == nil {
			return nil
		}
		return v.IosRoboTest
	}).(IosRoboTestPtrOutput)
}

// An iOS test loop.
func (o IosTestPtrOutput) IosTestLoop() IosTestLoopPtrOutput {
	return o.ApplyT(func(v *IosTest) *IosTestLoop {
		if v == nil {
			return nil
		}
		return v.IosTestLoop
	}).(IosTestLoopPtrOutput)
}

// An iOS XCTest.
func (o IosTestPtrOutput) IosXcTest() IosXcTestPtrOutput {
	return o.ApplyT(func(v *IosTest) *IosXcTest {
		if v == nil {
			return nil
		}
		return v.IosXcTest
	}).(IosXcTestPtrOutput)
}

// Max time a test is allowed to run before it is automatically cancelled.
func (o IosTestPtrOutput) TestTimeout() DurationPtrOutput {
	return o.ApplyT(func(v *IosTest) *Duration {
		if v == nil {
			return nil
		}
		return v.TestTimeout
	}).(DurationPtrOutput)
}

// A game loop test of an iOS application.
type IosTestLoop struct {
	// Bundle ID of the app.
	BundleId *string `pulumi:"bundleId"`
}

// IosTestLoopInput is an input type that accepts IosTestLoopArgs and IosTestLoopOutput values.
// You can construct a concrete instance of `IosTestLoopInput` via:
//
//	IosTestLoopArgs{...}
type IosTestLoopInput interface {
	pulumi.Input

	ToIosTestLoopOutput() IosTestLoopOutput
	ToIosTestLoopOutputWithContext(context.Context) IosTestLoopOutput
}

// A game loop test of an iOS application.
type IosTestLoopArgs struct {
	// Bundle ID of the app.
	BundleId pulumi.StringPtrInput `pulumi:"bundleId"`
}

func (IosTestLoopArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IosTestLoop)(nil)).Elem()
}

func (i IosTestLoopArgs) ToIosTestLoopOutput() IosTestLoopOutput {
	return i.ToIosTestLoopOutputWithContext(context.Background())
}

func (i IosTestLoopArgs) ToIosTestLoopOutputWithContext(ctx context.Context) IosTestLoopOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosTestLoopOutput)
}

func (i IosTestLoopArgs) ToOutput(ctx context.Context) pulumix.Output[IosTestLoop] {
	return pulumix.Output[IosTestLoop]{
		OutputState: i.ToIosTestLoopOutputWithContext(ctx).OutputState,
	}
}

func (i IosTestLoopArgs) ToIosTestLoopPtrOutput() IosTestLoopPtrOutput {
	return i.ToIosTestLoopPtrOutputWithContext(context.Background())
}

func (i IosTestLoopArgs) ToIosTestLoopPtrOutputWithContext(ctx context.Context) IosTestLoopPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosTestLoopOutput).ToIosTestLoopPtrOutputWithContext(ctx)
}

// IosTestLoopPtrInput is an input type that accepts IosTestLoopArgs, IosTestLoopPtr and IosTestLoopPtrOutput values.
// You can construct a concrete instance of `IosTestLoopPtrInput` via:
//
//	        IosTestLoopArgs{...}
//
//	or:
//
//	        nil
type IosTestLoopPtrInput interface {
	pulumi.Input

	ToIosTestLoopPtrOutput() IosTestLoopPtrOutput
	ToIosTestLoopPtrOutputWithContext(context.Context) IosTestLoopPtrOutput
}

type iosTestLoopPtrType IosTestLoopArgs

func IosTestLoopPtr(v *IosTestLoopArgs) IosTestLoopPtrInput {
	return (*iosTestLoopPtrType)(v)
}

func (*iosTestLoopPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IosTestLoop)(nil)).Elem()
}

func (i *iosTestLoopPtrType) ToIosTestLoopPtrOutput() IosTestLoopPtrOutput {
	return i.ToIosTestLoopPtrOutputWithContext(context.Background())
}

func (i *iosTestLoopPtrType) ToIosTestLoopPtrOutputWithContext(ctx context.Context) IosTestLoopPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosTestLoopPtrOutput)
}

func (i *iosTestLoopPtrType) ToOutput(ctx context.Context) pulumix.Output[*IosTestLoop] {
	return pulumix.Output[*IosTestLoop]{
		OutputState: i.ToIosTestLoopPtrOutputWithContext(ctx).OutputState,
	}
}

// A game loop test of an iOS application.
type IosTestLoopOutput struct{ *pulumi.OutputState }

func (IosTestLoopOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IosTestLoop)(nil)).Elem()
}

func (o IosTestLoopOutput) ToIosTestLoopOutput() IosTestLoopOutput {
	return o
}

func (o IosTestLoopOutput) ToIosTestLoopOutputWithContext(ctx context.Context) IosTestLoopOutput {
	return o
}

func (o IosTestLoopOutput) ToIosTestLoopPtrOutput() IosTestLoopPtrOutput {
	return o.ToIosTestLoopPtrOutputWithContext(context.Background())
}

func (o IosTestLoopOutput) ToIosTestLoopPtrOutputWithContext(ctx context.Context) IosTestLoopPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IosTestLoop) *IosTestLoop {
		return &v
	}).(IosTestLoopPtrOutput)
}

func (o IosTestLoopOutput) ToOutput(ctx context.Context) pulumix.Output[IosTestLoop] {
	return pulumix.Output[IosTestLoop]{
		OutputState: o.OutputState,
	}
}

// Bundle ID of the app.
func (o IosTestLoopOutput) BundleId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IosTestLoop) *string { return v.BundleId }).(pulumi.StringPtrOutput)
}

type IosTestLoopPtrOutput struct{ *pulumi.OutputState }

func (IosTestLoopPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IosTestLoop)(nil)).Elem()
}

func (o IosTestLoopPtrOutput) ToIosTestLoopPtrOutput() IosTestLoopPtrOutput {
	return o
}

func (o IosTestLoopPtrOutput) ToIosTestLoopPtrOutputWithContext(ctx context.Context) IosTestLoopPtrOutput {
	return o
}

func (o IosTestLoopPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*IosTestLoop] {
	return pulumix.Output[*IosTestLoop]{
		OutputState: o.OutputState,
	}
}

func (o IosTestLoopPtrOutput) Elem() IosTestLoopOutput {
	return o.ApplyT(func(v *IosTestLoop) IosTestLoop {
		if v != nil {
			return *v
		}
		var ret IosTestLoop
		return ret
	}).(IosTestLoopOutput)
}

// Bundle ID of the app.
func (o IosTestLoopPtrOutput) BundleId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IosTestLoop) *string {
		if v == nil {
			return nil
		}
		return v.BundleId
	}).(pulumi.StringPtrOutput)
}

// A game loop test of an iOS application.
type IosTestLoopResponse struct {
	// Bundle ID of the app.
	BundleId string `pulumi:"bundleId"`
}

// A game loop test of an iOS application.
type IosTestLoopResponseOutput struct{ *pulumi.OutputState }

func (IosTestLoopResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IosTestLoopResponse)(nil)).Elem()
}

func (o IosTestLoopResponseOutput) ToIosTestLoopResponseOutput() IosTestLoopResponseOutput {
	return o
}

func (o IosTestLoopResponseOutput) ToIosTestLoopResponseOutputWithContext(ctx context.Context) IosTestLoopResponseOutput {
	return o
}

func (o IosTestLoopResponseOutput) ToOutput(ctx context.Context) pulumix.Output[IosTestLoopResponse] {
	return pulumix.Output[IosTestLoopResponse]{
		OutputState: o.OutputState,
	}
}

// Bundle ID of the app.
func (o IosTestLoopResponseOutput) BundleId() pulumi.StringOutput {
	return o.ApplyT(func(v IosTestLoopResponse) string { return v.BundleId }).(pulumi.StringOutput)
}

// A iOS mobile test specification
type IosTestResponse struct {
	// Information about the application under test.
	IosAppInfo IosAppInfoResponse `pulumi:"iosAppInfo"`
	// An iOS Robo test.
	IosRoboTest IosRoboTestResponse `pulumi:"iosRoboTest"`
	// An iOS test loop.
	IosTestLoop IosTestLoopResponse `pulumi:"iosTestLoop"`
	// An iOS XCTest.
	IosXcTest IosXcTestResponse `pulumi:"iosXcTest"`
	// Max time a test is allowed to run before it is automatically cancelled.
	TestTimeout DurationResponse `pulumi:"testTimeout"`
}

// A iOS mobile test specification
type IosTestResponseOutput struct{ *pulumi.OutputState }

func (IosTestResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IosTestResponse)(nil)).Elem()
}

func (o IosTestResponseOutput) ToIosTestResponseOutput() IosTestResponseOutput {
	return o
}

func (o IosTestResponseOutput) ToIosTestResponseOutputWithContext(ctx context.Context) IosTestResponseOutput {
	return o
}

func (o IosTestResponseOutput) ToOutput(ctx context.Context) pulumix.Output[IosTestResponse] {
	return pulumix.Output[IosTestResponse]{
		OutputState: o.OutputState,
	}
}

// Information about the application under test.
func (o IosTestResponseOutput) IosAppInfo() IosAppInfoResponseOutput {
	return o.ApplyT(func(v IosTestResponse) IosAppInfoResponse { return v.IosAppInfo }).(IosAppInfoResponseOutput)
}

// An iOS Robo test.
func (o IosTestResponseOutput) IosRoboTest() IosRoboTestResponseOutput {
	return o.ApplyT(func(v IosTestResponse) IosRoboTestResponse { return v.IosRoboTest }).(IosRoboTestResponseOutput)
}

// An iOS test loop.
func (o IosTestResponseOutput) IosTestLoop() IosTestLoopResponseOutput {
	return o.ApplyT(func(v IosTestResponse) IosTestLoopResponse { return v.IosTestLoop }).(IosTestLoopResponseOutput)
}

// An iOS XCTest.
func (o IosTestResponseOutput) IosXcTest() IosXcTestResponseOutput {
	return o.ApplyT(func(v IosTestResponse) IosXcTestResponse { return v.IosXcTest }).(IosXcTestResponseOutput)
}

// Max time a test is allowed to run before it is automatically cancelled.
func (o IosTestResponseOutput) TestTimeout() DurationResponseOutput {
	return o.ApplyT(func(v IosTestResponse) DurationResponse { return v.TestTimeout }).(DurationResponseOutput)
}

// A test of an iOS application that uses the XCTest framework.
type IosXcTest struct {
	// Bundle ID of the app.
	BundleId *string `pulumi:"bundleId"`
	// Xcode version that the test was run with.
	XcodeVersion *string `pulumi:"xcodeVersion"`
}

// IosXcTestInput is an input type that accepts IosXcTestArgs and IosXcTestOutput values.
// You can construct a concrete instance of `IosXcTestInput` via:
//
//	IosXcTestArgs{...}
type IosXcTestInput interface {
	pulumi.Input

	ToIosXcTestOutput() IosXcTestOutput
	ToIosXcTestOutputWithContext(context.Context) IosXcTestOutput
}

// A test of an iOS application that uses the XCTest framework.
type IosXcTestArgs struct {
	// Bundle ID of the app.
	BundleId pulumi.StringPtrInput `pulumi:"bundleId"`
	// Xcode version that the test was run with.
	XcodeVersion pulumi.StringPtrInput `pulumi:"xcodeVersion"`
}

func (IosXcTestArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IosXcTest)(nil)).Elem()
}

func (i IosXcTestArgs) ToIosXcTestOutput() IosXcTestOutput {
	return i.ToIosXcTestOutputWithContext(context.Background())
}

func (i IosXcTestArgs) ToIosXcTestOutputWithContext(ctx context.Context) IosXcTestOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosXcTestOutput)
}

func (i IosXcTestArgs) ToOutput(ctx context.Context) pulumix.Output[IosXcTest] {
	return pulumix.Output[IosXcTest]{
		OutputState: i.ToIosXcTestOutputWithContext(ctx).OutputState,
	}
}

func (i IosXcTestArgs) ToIosXcTestPtrOutput() IosXcTestPtrOutput {
	return i.ToIosXcTestPtrOutputWithContext(context.Background())
}

func (i IosXcTestArgs) ToIosXcTestPtrOutputWithContext(ctx context.Context) IosXcTestPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosXcTestOutput).ToIosXcTestPtrOutputWithContext(ctx)
}

// IosXcTestPtrInput is an input type that accepts IosXcTestArgs, IosXcTestPtr and IosXcTestPtrOutput values.
// You can construct a concrete instance of `IosXcTestPtrInput` via:
//
//	        IosXcTestArgs{...}
//
//	or:
//
//	        nil
type IosXcTestPtrInput interface {
	pulumi.Input

	ToIosXcTestPtrOutput() IosXcTestPtrOutput
	ToIosXcTestPtrOutputWithContext(context.Context) IosXcTestPtrOutput
}

type iosXcTestPtrType IosXcTestArgs

func IosXcTestPtr(v *IosXcTestArgs) IosXcTestPtrInput {
	return (*iosXcTestPtrType)(v)
}

func (*iosXcTestPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IosXcTest)(nil)).Elem()
}

func (i *iosXcTestPtrType) ToIosXcTestPtrOutput() IosXcTestPtrOutput {
	return i.ToIosXcTestPtrOutputWithContext(context.Background())
}

func (i *iosXcTestPtrType) ToIosXcTestPtrOutputWithContext(ctx context.Context) IosXcTestPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IosXcTestPtrOutput)
}

func (i *iosXcTestPtrType) ToOutput(ctx context.Context) pulumix.Output[*IosXcTest] {
	return pulumix.Output[*IosXcTest]{
		OutputState: i.ToIosXcTestPtrOutputWithContext(ctx).OutputState,
	}
}

// A test of an iOS application that uses the XCTest framework.
type IosXcTestOutput struct{ *pulumi.OutputState }

func (IosXcTestOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IosXcTest)(nil)).Elem()
}

func (o IosXcTestOutput) ToIosXcTestOutput() IosXcTestOutput {
	return o
}

func (o IosXcTestOutput) ToIosXcTestOutputWithContext(ctx context.Context) IosXcTestOutput {
	return o
}

func (o IosXcTestOutput) ToIosXcTestPtrOutput() IosXcTestPtrOutput {
	return o.ToIosXcTestPtrOutputWithContext(context.Background())
}

func (o IosXcTestOutput) ToIosXcTestPtrOutputWithContext(ctx context.Context) IosXcTestPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IosXcTest) *IosXcTest {
		return &v
	}).(IosXcTestPtrOutput)
}

func (o IosXcTestOutput) ToOutput(ctx context.Context) pulumix.Output[IosXcTest] {
	return pulumix.Output[IosXcTest]{
		OutputState: o.OutputState,
	}
}

// Bundle ID of the app.
func (o IosXcTestOutput) BundleId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IosXcTest) *string { return v.BundleId }).(pulumi.StringPtrOutput)
}

// Xcode version that the test was run with.
func (o IosXcTestOutput) XcodeVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IosXcTest) *string { return v.XcodeVersion }).(pulumi.StringPtrOutput)
}

type IosXcTestPtrOutput struct{ *pulumi.OutputState }

func (IosXcTestPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IosXcTest)(nil)).Elem()
}

func (o IosXcTestPtrOutput) ToIosXcTestPtrOutput() IosXcTestPtrOutput {
	return o
}

func (o IosXcTestPtrOutput) ToIosXcTestPtrOutputWithContext(ctx context.Context) IosXcTestPtrOutput {
	return o
}

func (o IosXcTestPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*IosXcTest] {
	return pulumix.Output[*IosXcTest]{
		OutputState: o.OutputState,
	}
}

func (o IosXcTestPtrOutput) Elem() IosXcTestOutput {
	return o.ApplyT(func(v *IosXcTest) IosXcTest {
		if v != nil {
			return *v
		}
		var ret IosXcTest
		return ret
	}).(IosXcTestOutput)
}

// Bundle ID of the app.
func (o IosXcTestPtrOutput) BundleId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IosXcTest) *string {
		if v == nil {
			return nil
		}
		return v.BundleId
	}).(pulumi.StringPtrOutput)
}

// Xcode version that the test was run with.
func (o IosXcTestPtrOutput) XcodeVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IosXcTest) *string {
		if v == nil {
			return nil
		}
		return v.XcodeVersion
	}).(pulumi.StringPtrOutput)
}

// A test of an iOS application that uses the XCTest framework.
type IosXcTestResponse struct {
	// Bundle ID of the app.
	BundleId string `pulumi:"bundleId"`
	// Xcode version that the test was run with.
	XcodeVersion string `pulumi:"xcodeVersion"`
}

// A test of an iOS application that uses the XCTest framework.
type IosXcTestResponseOutput struct{ *pulumi.OutputState }

func (IosXcTestResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IosXcTestResponse)(nil)).Elem()
}

func (o IosXcTestResponseOutput) ToIosXcTestResponseOutput() IosXcTestResponseOutput {
	return o
}

func (o IosXcTestResponseOutput) ToIosXcTestResponseOutputWithContext(ctx context.Context) IosXcTestResponseOutput {
	return o
}

func (o IosXcTestResponseOutput) ToOutput(ctx context.Context) pulumix.Output[IosXcTestResponse] {
	return pulumix.Output[IosXcTestResponse]{
		OutputState: o.OutputState,
	}
}

// Bundle ID of the app.
func (o IosXcTestResponseOutput) BundleId() pulumi.StringOutput {
	return o.ApplyT(func(v IosXcTestResponse) string { return v.BundleId }).(pulumi.StringOutput)
}

// Xcode version that the test was run with.
func (o IosXcTestResponseOutput) XcodeVersion() pulumi.StringOutput {
	return o.ApplyT(func(v IosXcTestResponse) string { return v.XcodeVersion }).(pulumi.StringOutput)
}

// One dimension of the matrix of different runs of a step.
type MatrixDimensionDefinition struct {
}

// MatrixDimensionDefinitionInput is an input type that accepts MatrixDimensionDefinitionArgs and MatrixDimensionDefinitionOutput values.
// You can construct a concrete instance of `MatrixDimensionDefinitionInput` via:
//
//	MatrixDimensionDefinitionArgs{...}
type MatrixDimensionDefinitionInput interface {
	pulumi.Input

	ToMatrixDimensionDefinitionOutput() MatrixDimensionDefinitionOutput
	ToMatrixDimensionDefinitionOutputWithContext(context.Context) MatrixDimensionDefinitionOutput
}

// One dimension of the matrix of different runs of a step.
type MatrixDimensionDefinitionArgs struct {
}

func (MatrixDimensionDefinitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MatrixDimensionDefinition)(nil)).Elem()
}

func (i MatrixDimensionDefinitionArgs) ToMatrixDimensionDefinitionOutput() MatrixDimensionDefinitionOutput {
	return i.ToMatrixDimensionDefinitionOutputWithContext(context.Background())
}

func (i MatrixDimensionDefinitionArgs) ToMatrixDimensionDefinitionOutputWithContext(ctx context.Context) MatrixDimensionDefinitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MatrixDimensionDefinitionOutput)
}

func (i MatrixDimensionDefinitionArgs) ToOutput(ctx context.Context) pulumix.Output[MatrixDimensionDefinition] {
	return pulumix.Output[MatrixDimensionDefinition]{
		OutputState: i.ToMatrixDimensionDefinitionOutputWithContext(ctx).OutputState,
	}
}

// MatrixDimensionDefinitionArrayInput is an input type that accepts MatrixDimensionDefinitionArray and MatrixDimensionDefinitionArrayOutput values.
// You can construct a concrete instance of `MatrixDimensionDefinitionArrayInput` via:
//
//	MatrixDimensionDefinitionArray{ MatrixDimensionDefinitionArgs{...} }
type MatrixDimensionDefinitionArrayInput interface {
	pulumi.Input

	ToMatrixDimensionDefinitionArrayOutput() MatrixDimensionDefinitionArrayOutput
	ToMatrixDimensionDefinitionArrayOutputWithContext(context.Context) MatrixDimensionDefinitionArrayOutput
}

type MatrixDimensionDefinitionArray []MatrixDimensionDefinitionInput

func (MatrixDimensionDefinitionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MatrixDimensionDefinition)(nil)).Elem()
}

func (i MatrixDimensionDefinitionArray) ToMatrixDimensionDefinitionArrayOutput() MatrixDimensionDefinitionArrayOutput {
	return i.ToMatrixDimensionDefinitionArrayOutputWithContext(context.Background())
}

func (i MatrixDimensionDefinitionArray) ToMatrixDimensionDefinitionArrayOutputWithContext(ctx context.Context) MatrixDimensionDefinitionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MatrixDimensionDefinitionArrayOutput)
}

func (i MatrixDimensionDefinitionArray) ToOutput(ctx context.Context) pulumix.Output[[]MatrixDimensionDefinition] {
	return pulumix.Output[[]MatrixDimensionDefinition]{
		OutputState: i.ToMatrixDimensionDefinitionArrayOutputWithContext(ctx).OutputState,
	}
}

// One dimension of the matrix of different runs of a step.
type MatrixDimensionDefinitionOutput struct{ *pulumi.OutputState }

func (MatrixDimensionDefinitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MatrixDimensionDefinition)(nil)).Elem()
}

func (o MatrixDimensionDefinitionOutput) ToMatrixDimensionDefinitionOutput() MatrixDimensionDefinitionOutput {
	return o
}

func (o MatrixDimensionDefinitionOutput) ToMatrixDimensionDefinitionOutputWithContext(ctx context.Context) MatrixDimensionDefinitionOutput {
	return o
}

func (o MatrixDimensionDefinitionOutput) ToOutput(ctx context.Context) pulumix.Output[MatrixDimensionDefinition] {
	return pulumix.Output[MatrixDimensionDefinition]{
		OutputState: o.OutputState,
	}
}

type MatrixDimensionDefinitionArrayOutput struct{ *pulumi.OutputState }

func (MatrixDimensionDefinitionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MatrixDimensionDefinition)(nil)).Elem()
}

func (o MatrixDimensionDefinitionArrayOutput) ToMatrixDimensionDefinitionArrayOutput() MatrixDimensionDefinitionArrayOutput {
	return o
}

func (o MatrixDimensionDefinitionArrayOutput) ToMatrixDimensionDefinitionArrayOutputWithContext(ctx context.Context) MatrixDimensionDefinitionArrayOutput {
	return o
}

func (o MatrixDimensionDefinitionArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]MatrixDimensionDefinition] {
	return pulumix.Output[[]MatrixDimensionDefinition]{
		OutputState: o.OutputState,
	}
}

func (o MatrixDimensionDefinitionArrayOutput) Index(i pulumi.IntInput) MatrixDimensionDefinitionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MatrixDimensionDefinition {
		return vs[0].([]MatrixDimensionDefinition)[vs[1].(int)]
	}).(MatrixDimensionDefinitionOutput)
}

// One dimension of the matrix of different runs of a step.
type MatrixDimensionDefinitionResponse struct {
}

// One dimension of the matrix of different runs of a step.
type MatrixDimensionDefinitionResponseOutput struct{ *pulumi.OutputState }

func (MatrixDimensionDefinitionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MatrixDimensionDefinitionResponse)(nil)).Elem()
}

func (o MatrixDimensionDefinitionResponseOutput) ToMatrixDimensionDefinitionResponseOutput() MatrixDimensionDefinitionResponseOutput {
	return o
}

func (o MatrixDimensionDefinitionResponseOutput) ToMatrixDimensionDefinitionResponseOutputWithContext(ctx context.Context) MatrixDimensionDefinitionResponseOutput {
	return o
}

func (o MatrixDimensionDefinitionResponseOutput) ToOutput(ctx context.Context) pulumix.Output[MatrixDimensionDefinitionResponse] {
	return pulumix.Output[MatrixDimensionDefinitionResponse]{
		OutputState: o.OutputState,
	}
}

type MatrixDimensionDefinitionResponseArrayOutput struct{ *pulumi.OutputState }

func (MatrixDimensionDefinitionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MatrixDimensionDefinitionResponse)(nil)).Elem()
}

func (o MatrixDimensionDefinitionResponseArrayOutput) ToMatrixDimensionDefinitionResponseArrayOutput() MatrixDimensionDefinitionResponseArrayOutput {
	return o
}

func (o MatrixDimensionDefinitionResponseArrayOutput) ToMatrixDimensionDefinitionResponseArrayOutputWithContext(ctx context.Context) MatrixDimensionDefinitionResponseArrayOutput {
	return o
}

func (o MatrixDimensionDefinitionResponseArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]MatrixDimensionDefinitionResponse] {
	return pulumix.Output[[]MatrixDimensionDefinitionResponse]{
		OutputState: o.OutputState,
	}
}

func (o MatrixDimensionDefinitionResponseArrayOutput) Index(i pulumi.IntInput) MatrixDimensionDefinitionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MatrixDimensionDefinitionResponse {
		return vs[0].([]MatrixDimensionDefinitionResponse)[vs[1].(int)]
	}).(MatrixDimensionDefinitionResponseOutput)
}

// Details when multiple steps are run with the same configuration as a group.
type MultiStep struct {
	// Unique int given to each step. Ranges from 0(inclusive) to total number of steps(exclusive). The primary step is 0.
	MultistepNumber *int `pulumi:"multistepNumber"`
	// Present if it is a primary (original) step.
	PrimaryStep *PrimaryStep `pulumi:"primaryStep"`
	// Step Id of the primary (original) step, which might be this step.
	PrimaryStepId *string `pulumi:"primaryStepId"`
}

// MultiStepInput is an input type that accepts MultiStepArgs and MultiStepOutput values.
// You can construct a concrete instance of `MultiStepInput` via:
//
//	MultiStepArgs{...}
type MultiStepInput interface {
	pulumi.Input

	ToMultiStepOutput() MultiStepOutput
	ToMultiStepOutputWithContext(context.Context) MultiStepOutput
}

// Details when multiple steps are run with the same configuration as a group.
type MultiStepArgs struct {
	// Unique int given to each step. Ranges from 0(inclusive) to total number of steps(exclusive). The primary step is 0.
	MultistepNumber pulumi.IntPtrInput `pulumi:"multistepNumber"`
	// Present if it is a primary (original) step.
	PrimaryStep PrimaryStepPtrInput `pulumi:"primaryStep"`
	// Step Id of the primary (original) step, which might be this step.
	PrimaryStepId pulumi.StringPtrInput `pulumi:"primaryStepId"`
}

func (MultiStepArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MultiStep)(nil)).Elem()
}

func (i MultiStepArgs) ToMultiStepOutput() MultiStepOutput {
	return i.ToMultiStepOutputWithContext(context.Background())
}

func (i MultiStepArgs) ToMultiStepOutputWithContext(ctx context.Context) MultiStepOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MultiStepOutput)
}

func (i MultiStepArgs) ToOutput(ctx context.Context) pulumix.Output[MultiStep] {
	return pulumix.Output[MultiStep]{
		OutputState: i.ToMultiStepOutputWithContext(ctx).OutputState,
	}
}

func (i MultiStepArgs) ToMultiStepPtrOutput() MultiStepPtrOutput {
	return i.ToMultiStepPtrOutputWithContext(context.Background())
}

func (i MultiStepArgs) ToMultiStepPtrOutputWithContext(ctx context.Context) MultiStepPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MultiStepOutput).ToMultiStepPtrOutputWithContext(ctx)
}

// MultiStepPtrInput is an input type that accepts MultiStepArgs, MultiStepPtr and MultiStepPtrOutput values.
// You can construct a concrete instance of `MultiStepPtrInput` via:
//
//	        MultiStepArgs{...}
//
//	or:
//
//	        nil
type MultiStepPtrInput interface {
	pulumi.Input

	ToMultiStepPtrOutput() MultiStepPtrOutput
	ToMultiStepPtrOutputWithContext(context.Context) MultiStepPtrOutput
}

type multiStepPtrType MultiStepArgs

func MultiStepPtr(v *MultiStepArgs) MultiStepPtrInput {
	return (*multiStepPtrType)(v)
}

func (*multiStepPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MultiStep)(nil)).Elem()
}

func (i *multiStepPtrType) ToMultiStepPtrOutput() MultiStepPtrOutput {
	return i.ToMultiStepPtrOutputWithContext(context.Background())
}

func (i *multiStepPtrType) ToMultiStepPtrOutputWithContext(ctx context.Context) MultiStepPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MultiStepPtrOutput)
}

func (i *multiStepPtrType) ToOutput(ctx context.Context) pulumix.Output[*MultiStep] {
	return pulumix.Output[*MultiStep]{
		OutputState: i.ToMultiStepPtrOutputWithContext(ctx).OutputState,
	}
}

// Details when multiple steps are run with the same configuration as a group.
type MultiStepOutput struct{ *pulumi.OutputState }

func (MultiStepOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MultiStep)(nil)).Elem()
}

func (o MultiStepOutput) ToMultiStepOutput() MultiStepOutput {
	return o
}

func (o MultiStepOutput) ToMultiStepOutputWithContext(ctx context.Context) MultiStepOutput {
	return o
}

func (o MultiStepOutput) ToMultiStepPtrOutput() MultiStepPtrOutput {
	return o.ToMultiStepPtrOutputWithContext(context.Background())
}

func (o MultiStepOutput) ToMultiStepPtrOutputWithContext(ctx context.Context) MultiStepPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MultiStep) *MultiStep {
		return &v
	}).(MultiStepPtrOutput)
}

func (o MultiStepOutput) ToOutput(ctx context.Context) pulumix.Output[MultiStep] {
	return pulumix.Output[MultiStep]{
		OutputState: o.OutputState,
	}
}

// Unique int given to each step. Ranges from 0(inclusive) to total number of steps(exclusive). The primary step is 0.
func (o MultiStepOutput) MultistepNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v MultiStep) *int { return v.MultistepNumber }).(pulumi.IntPtrOutput)
}

// Present if it is a primary (original) step.
func (o MultiStepOutput) PrimaryStep() PrimaryStepPtrOutput {
	return o.ApplyT(func(v MultiStep) *PrimaryStep { return v.PrimaryStep }).(PrimaryStepPtrOutput)
}

// Step Id of the primary (original) step, which might be this step.
func (o MultiStepOutput) PrimaryStepId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MultiStep) *string { return v.PrimaryStepId }).(pulumi.StringPtrOutput)
}

type MultiStepPtrOutput struct{ *pulumi.OutputState }

func (MultiStepPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MultiStep)(nil)).Elem()
}

func (o MultiStepPtrOutput) ToMultiStepPtrOutput() MultiStepPtrOutput {
	return o
}

func (o MultiStepPtrOutput) ToMultiStepPtrOutputWithContext(ctx context.Context) MultiStepPtrOutput {
	return o
}

func (o MultiStepPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*MultiStep] {
	return pulumix.Output[*MultiStep]{
		OutputState: o.OutputState,
	}
}

func (o MultiStepPtrOutput) Elem() MultiStepOutput {
	return o.ApplyT(func(v *MultiStep) MultiStep {
		if v != nil {
			return *v
		}
		var ret MultiStep
		return ret
	}).(MultiStepOutput)
}

// Unique int given to each step. Ranges from 0(inclusive) to total number of steps(exclusive). The primary step is 0.
func (o MultiStepPtrOutput) MultistepNumber() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *MultiStep) *int {
		if v == nil {
			return nil
		}
		return v.MultistepNumber
	}).(pulumi.IntPtrOutput)
}

// Present if it is a primary (original) step.
func (o MultiStepPtrOutput) PrimaryStep() PrimaryStepPtrOutput {
	return o.ApplyT(func(v *MultiStep) *PrimaryStep {
		if v == nil {
			return nil
		}
		return v.PrimaryStep
	}).(PrimaryStepPtrOutput)
}

// Step Id of the primary (original) step, which might be this step.
func (o MultiStepPtrOutput) PrimaryStepId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MultiStep) *string {
		if v == nil {
			return nil
		}
		return v.PrimaryStepId
	}).(pulumi.StringPtrOutput)
}

// Details when multiple steps are run with the same configuration as a group.
type MultiStepResponse struct {
	// Unique int given to each step. Ranges from 0(inclusive) to total number of steps(exclusive). The primary step is 0.
	MultistepNumber int `pulumi:"multistepNumber"`
	// Present if it is a primary (original) step.
	PrimaryStep PrimaryStepResponse `pulumi:"primaryStep"`
	// Step Id of the primary (original) step, which might be this step.
	PrimaryStepId string `pulumi:"primaryStepId"`
}

// Details when multiple steps are run with the same configuration as a group.
type MultiStepResponseOutput struct{ *pulumi.OutputState }

func (MultiStepResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MultiStepResponse)(nil)).Elem()
}

func (o MultiStepResponseOutput) ToMultiStepResponseOutput() MultiStepResponseOutput {
	return o
}

func (o MultiStepResponseOutput) ToMultiStepResponseOutputWithContext(ctx context.Context) MultiStepResponseOutput {
	return o
}

func (o MultiStepResponseOutput) ToOutput(ctx context.Context) pulumix.Output[MultiStepResponse] {
	return pulumix.Output[MultiStepResponse]{
		OutputState: o.OutputState,
	}
}

// Unique int given to each step. Ranges from 0(inclusive) to total number of steps(exclusive). The primary step is 0.
func (o MultiStepResponseOutput) MultistepNumber() pulumi.IntOutput {
	return o.ApplyT(func(v MultiStepResponse) int { return v.MultistepNumber }).(pulumi.IntOutput)
}

// Present if it is a primary (original) step.
func (o MultiStepResponseOutput) PrimaryStep() PrimaryStepResponseOutput {
	return o.ApplyT(func(v MultiStepResponse) PrimaryStepResponse { return v.PrimaryStep }).(PrimaryStepResponseOutput)
}

// Step Id of the primary (original) step, which might be this step.
func (o MultiStepResponseOutput) PrimaryStepId() pulumi.StringOutput {
	return o.ApplyT(func(v MultiStepResponse) string { return v.PrimaryStepId }).(pulumi.StringOutput)
}

// Interprets a result so that humans and machines can act on it.
type Outcome struct {
	// More information about a FAILURE outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not FAILURE. Optional
	FailureDetail *FailureDetail `pulumi:"failureDetail"`
	// More information about an INCONCLUSIVE outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not INCONCLUSIVE. Optional
	InconclusiveDetail *InconclusiveDetail `pulumi:"inconclusiveDetail"`
	// More information about a SKIPPED outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not SKIPPED. Optional
	SkippedDetail *SkippedDetail `pulumi:"skippedDetail"`
	// More information about a SUCCESS outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not SUCCESS. Optional
	SuccessDetail *SuccessDetail `pulumi:"successDetail"`
	// The simplest way to interpret a result. Required
	Summary *OutcomeSummary `pulumi:"summary"`
}

// OutcomeInput is an input type that accepts OutcomeArgs and OutcomeOutput values.
// You can construct a concrete instance of `OutcomeInput` via:
//
//	OutcomeArgs{...}
type OutcomeInput interface {
	pulumi.Input

	ToOutcomeOutput() OutcomeOutput
	ToOutcomeOutputWithContext(context.Context) OutcomeOutput
}

// Interprets a result so that humans and machines can act on it.
type OutcomeArgs struct {
	// More information about a FAILURE outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not FAILURE. Optional
	FailureDetail FailureDetailPtrInput `pulumi:"failureDetail"`
	// More information about an INCONCLUSIVE outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not INCONCLUSIVE. Optional
	InconclusiveDetail InconclusiveDetailPtrInput `pulumi:"inconclusiveDetail"`
	// More information about a SKIPPED outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not SKIPPED. Optional
	SkippedDetail SkippedDetailPtrInput `pulumi:"skippedDetail"`
	// More information about a SUCCESS outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not SUCCESS. Optional
	SuccessDetail SuccessDetailPtrInput `pulumi:"successDetail"`
	// The simplest way to interpret a result. Required
	Summary OutcomeSummaryPtrInput `pulumi:"summary"`
}

func (OutcomeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Outcome)(nil)).Elem()
}

func (i OutcomeArgs) ToOutcomeOutput() OutcomeOutput {
	return i.ToOutcomeOutputWithContext(context.Background())
}

func (i OutcomeArgs) ToOutcomeOutputWithContext(ctx context.Context) OutcomeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OutcomeOutput)
}

func (i OutcomeArgs) ToOutput(ctx context.Context) pulumix.Output[Outcome] {
	return pulumix.Output[Outcome]{
		OutputState: i.ToOutcomeOutputWithContext(ctx).OutputState,
	}
}

func (i OutcomeArgs) ToOutcomePtrOutput() OutcomePtrOutput {
	return i.ToOutcomePtrOutputWithContext(context.Background())
}

func (i OutcomeArgs) ToOutcomePtrOutputWithContext(ctx context.Context) OutcomePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OutcomeOutput).ToOutcomePtrOutputWithContext(ctx)
}

// OutcomePtrInput is an input type that accepts OutcomeArgs, OutcomePtr and OutcomePtrOutput values.
// You can construct a concrete instance of `OutcomePtrInput` via:
//
//	        OutcomeArgs{...}
//
//	or:
//
//	        nil
type OutcomePtrInput interface {
	pulumi.Input

	ToOutcomePtrOutput() OutcomePtrOutput
	ToOutcomePtrOutputWithContext(context.Context) OutcomePtrOutput
}

type outcomePtrType OutcomeArgs

func OutcomePtr(v *OutcomeArgs) OutcomePtrInput {
	return (*outcomePtrType)(v)
}

func (*outcomePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Outcome)(nil)).Elem()
}

func (i *outcomePtrType) ToOutcomePtrOutput() OutcomePtrOutput {
	return i.ToOutcomePtrOutputWithContext(context.Background())
}

func (i *outcomePtrType) ToOutcomePtrOutputWithContext(ctx context.Context) OutcomePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OutcomePtrOutput)
}

func (i *outcomePtrType) ToOutput(ctx context.Context) pulumix.Output[*Outcome] {
	return pulumix.Output[*Outcome]{
		OutputState: i.ToOutcomePtrOutputWithContext(ctx).OutputState,
	}
}

// Interprets a result so that humans and machines can act on it.
type OutcomeOutput struct{ *pulumi.OutputState }

func (OutcomeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Outcome)(nil)).Elem()
}

func (o OutcomeOutput) ToOutcomeOutput() OutcomeOutput {
	return o
}

func (o OutcomeOutput) ToOutcomeOutputWithContext(ctx context.Context) OutcomeOutput {
	return o
}

func (o OutcomeOutput) ToOutcomePtrOutput() OutcomePtrOutput {
	return o.ToOutcomePtrOutputWithContext(context.Background())
}

func (o OutcomeOutput) ToOutcomePtrOutputWithContext(ctx context.Context) OutcomePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Outcome) *Outcome {
		return &v
	}).(OutcomePtrOutput)
}

func (o OutcomeOutput) ToOutput(ctx context.Context) pulumix.Output[Outcome] {
	return pulumix.Output[Outcome]{
		OutputState: o.OutputState,
	}
}

// More information about a FAILURE outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not FAILURE. Optional
func (o OutcomeOutput) FailureDetail() FailureDetailPtrOutput {
	return o.ApplyT(func(v Outcome) *FailureDetail { return v.FailureDetail }).(FailureDetailPtrOutput)
}

// More information about an INCONCLUSIVE outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not INCONCLUSIVE. Optional
func (o OutcomeOutput) InconclusiveDetail() InconclusiveDetailPtrOutput {
	return o.ApplyT(func(v Outcome) *InconclusiveDetail { return v.InconclusiveDetail }).(InconclusiveDetailPtrOutput)
}

// More information about a SKIPPED outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not SKIPPED. Optional
func (o OutcomeOutput) SkippedDetail() SkippedDetailPtrOutput {
	return o.ApplyT(func(v Outcome) *SkippedDetail { return v.SkippedDetail }).(SkippedDetailPtrOutput)
}

// More information about a SUCCESS outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not SUCCESS. Optional
func (o OutcomeOutput) SuccessDetail() SuccessDetailPtrOutput {
	return o.ApplyT(func(v Outcome) *SuccessDetail { return v.SuccessDetail }).(SuccessDetailPtrOutput)
}

// The simplest way to interpret a result. Required
func (o OutcomeOutput) Summary() OutcomeSummaryPtrOutput {
	return o.ApplyT(func(v Outcome) *OutcomeSummary { return v.Summary }).(OutcomeSummaryPtrOutput)
}

type OutcomePtrOutput struct{ *pulumi.OutputState }

func (OutcomePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Outcome)(nil)).Elem()
}

func (o OutcomePtrOutput) ToOutcomePtrOutput() OutcomePtrOutput {
	return o
}

func (o OutcomePtrOutput) ToOutcomePtrOutputWithContext(ctx context.Context) OutcomePtrOutput {
	return o
}

func (o OutcomePtrOutput) ToOutput(ctx context.Context) pulumix.Output[*Outcome] {
	return pulumix.Output[*Outcome]{
		OutputState: o.OutputState,
	}
}

func (o OutcomePtrOutput) Elem() OutcomeOutput {
	return o.ApplyT(func(v *Outcome) Outcome {
		if v != nil {
			return *v
		}
		var ret Outcome
		return ret
	}).(OutcomeOutput)
}

// More information about a FAILURE outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not FAILURE. Optional
func (o OutcomePtrOutput) FailureDetail() FailureDetailPtrOutput {
	return o.ApplyT(func(v *Outcome) *FailureDetail {
		if v == nil {
			return nil
		}
		return v.FailureDetail
	}).(FailureDetailPtrOutput)
}

// More information about an INCONCLUSIVE outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not INCONCLUSIVE. Optional
func (o OutcomePtrOutput) InconclusiveDetail() InconclusiveDetailPtrOutput {
	return o.ApplyT(func(v *Outcome) *InconclusiveDetail {
		if v == nil {
			return nil
		}
		return v.InconclusiveDetail
	}).(InconclusiveDetailPtrOutput)
}

// More information about a SKIPPED outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not SKIPPED. Optional
func (o OutcomePtrOutput) SkippedDetail() SkippedDetailPtrOutput {
	return o.ApplyT(func(v *Outcome) *SkippedDetail {
		if v == nil {
			return nil
		}
		return v.SkippedDetail
	}).(SkippedDetailPtrOutput)
}

// More information about a SUCCESS outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not SUCCESS. Optional
func (o OutcomePtrOutput) SuccessDetail() SuccessDetailPtrOutput {
	return o.ApplyT(func(v *Outcome) *SuccessDetail {
		if v == nil {
			return nil
		}
		return v.SuccessDetail
	}).(SuccessDetailPtrOutput)
}

// The simplest way to interpret a result. Required
func (o OutcomePtrOutput) Summary() OutcomeSummaryPtrOutput {
	return o.ApplyT(func(v *Outcome) *OutcomeSummary {
		if v == nil {
			return nil
		}
		return v.Summary
	}).(OutcomeSummaryPtrOutput)
}

// Interprets a result so that humans and machines can act on it.
type OutcomeResponse struct {
	// More information about a FAILURE outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not FAILURE. Optional
	FailureDetail FailureDetailResponse `pulumi:"failureDetail"`
	// More information about an INCONCLUSIVE outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not INCONCLUSIVE. Optional
	InconclusiveDetail InconclusiveDetailResponse `pulumi:"inconclusiveDetail"`
	// More information about a SKIPPED outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not SKIPPED. Optional
	SkippedDetail SkippedDetailResponse `pulumi:"skippedDetail"`
	// More information about a SUCCESS outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not SUCCESS. Optional
	SuccessDetail SuccessDetailResponse `pulumi:"successDetail"`
	// The simplest way to interpret a result. Required
	Summary string `pulumi:"summary"`
}

// Interprets a result so that humans and machines can act on it.
type OutcomeResponseOutput struct{ *pulumi.OutputState }

func (OutcomeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OutcomeResponse)(nil)).Elem()
}

func (o OutcomeResponseOutput) ToOutcomeResponseOutput() OutcomeResponseOutput {
	return o
}

func (o OutcomeResponseOutput) ToOutcomeResponseOutputWithContext(ctx context.Context) OutcomeResponseOutput {
	return o
}

func (o OutcomeResponseOutput) ToOutput(ctx context.Context) pulumix.Output[OutcomeResponse] {
	return pulumix.Output[OutcomeResponse]{
		OutputState: o.OutputState,
	}
}

// More information about a FAILURE outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not FAILURE. Optional
func (o OutcomeResponseOutput) FailureDetail() FailureDetailResponseOutput {
	return o.ApplyT(func(v OutcomeResponse) FailureDetailResponse { return v.FailureDetail }).(FailureDetailResponseOutput)
}

// More information about an INCONCLUSIVE outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not INCONCLUSIVE. Optional
func (o OutcomeResponseOutput) InconclusiveDetail() InconclusiveDetailResponseOutput {
	return o.ApplyT(func(v OutcomeResponse) InconclusiveDetailResponse { return v.InconclusiveDetail }).(InconclusiveDetailResponseOutput)
}

// More information about a SKIPPED outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not SKIPPED. Optional
func (o OutcomeResponseOutput) SkippedDetail() SkippedDetailResponseOutput {
	return o.ApplyT(func(v OutcomeResponse) SkippedDetailResponse { return v.SkippedDetail }).(SkippedDetailResponseOutput)
}

// More information about a SUCCESS outcome. Returns INVALID_ARGUMENT if this field is set but the summary is not SUCCESS. Optional
func (o OutcomeResponseOutput) SuccessDetail() SuccessDetailResponseOutput {
	return o.ApplyT(func(v OutcomeResponse) SuccessDetailResponse { return v.SuccessDetail }).(SuccessDetailResponseOutput)
}

// The simplest way to interpret a result. Required
func (o OutcomeResponseOutput) Summary() pulumi.StringOutput {
	return o.ApplyT(func(v OutcomeResponse) string { return v.Summary }).(pulumi.StringOutput)
}

// Stores rollup test status of multiple steps that were run as a group and outcome of each individual step.
type PrimaryStep struct {
	// Step Id and outcome of each individual step.
	IndividualOutcome []IndividualOutcome `pulumi:"individualOutcome"`
	// Rollup test status of multiple steps that were run with the same configuration as a group.
	RollUp *PrimaryStepRollUp `pulumi:"rollUp"`
}

// PrimaryStepInput is an input type that accepts PrimaryStepArgs and PrimaryStepOutput values.
// You can construct a concrete instance of `PrimaryStepInput` via:
//
//	PrimaryStepArgs{...}
type PrimaryStepInput interface {
	pulumi.Input

	ToPrimaryStepOutput() PrimaryStepOutput
	ToPrimaryStepOutputWithContext(context.Context) PrimaryStepOutput
}

// Stores rollup test status of multiple steps that were run as a group and outcome of each individual step.
type PrimaryStepArgs struct {
	// Step Id and outcome of each individual step.
	IndividualOutcome IndividualOutcomeArrayInput `pulumi:"individualOutcome"`
	// Rollup test status of multiple steps that were run with the same configuration as a group.
	RollUp PrimaryStepRollUpPtrInput `pulumi:"rollUp"`
}

func (PrimaryStepArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PrimaryStep)(nil)).Elem()
}

func (i PrimaryStepArgs) ToPrimaryStepOutput() PrimaryStepOutput {
	return i.ToPrimaryStepOutputWithContext(context.Background())
}

func (i PrimaryStepArgs) ToPrimaryStepOutputWithContext(ctx context.Context) PrimaryStepOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrimaryStepOutput)
}

func (i PrimaryStepArgs) ToOutput(ctx context.Context) pulumix.Output[PrimaryStep] {
	return pulumix.Output[PrimaryStep]{
		OutputState: i.ToPrimaryStepOutputWithContext(ctx).OutputState,
	}
}

func (i PrimaryStepArgs) ToPrimaryStepPtrOutput() PrimaryStepPtrOutput {
	return i.ToPrimaryStepPtrOutputWithContext(context.Background())
}

func (i PrimaryStepArgs) ToPrimaryStepPtrOutputWithContext(ctx context.Context) PrimaryStepPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrimaryStepOutput).ToPrimaryStepPtrOutputWithContext(ctx)
}

// PrimaryStepPtrInput is an input type that accepts PrimaryStepArgs, PrimaryStepPtr and PrimaryStepPtrOutput values.
// You can construct a concrete instance of `PrimaryStepPtrInput` via:
//
//	        PrimaryStepArgs{...}
//
//	or:
//
//	        nil
type PrimaryStepPtrInput interface {
	pulumi.Input

	ToPrimaryStepPtrOutput() PrimaryStepPtrOutput
	ToPrimaryStepPtrOutputWithContext(context.Context) PrimaryStepPtrOutput
}

type primaryStepPtrType PrimaryStepArgs

func PrimaryStepPtr(v *PrimaryStepArgs) PrimaryStepPtrInput {
	return (*primaryStepPtrType)(v)
}

func (*primaryStepPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PrimaryStep)(nil)).Elem()
}

func (i *primaryStepPtrType) ToPrimaryStepPtrOutput() PrimaryStepPtrOutput {
	return i.ToPrimaryStepPtrOutputWithContext(context.Background())
}

func (i *primaryStepPtrType) ToPrimaryStepPtrOutputWithContext(ctx context.Context) PrimaryStepPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PrimaryStepPtrOutput)
}

func (i *primaryStepPtrType) ToOutput(ctx context.Context) pulumix.Output[*PrimaryStep] {
	return pulumix.Output[*PrimaryStep]{
		OutputState: i.ToPrimaryStepPtrOutputWithContext(ctx).OutputState,
	}
}

// Stores rollup test status of multiple steps that were run as a group and outcome of each individual step.
type PrimaryStepOutput struct{ *pulumi.OutputState }

func (PrimaryStepOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrimaryStep)(nil)).Elem()
}

func (o PrimaryStepOutput) ToPrimaryStepOutput() PrimaryStepOutput {
	return o
}

func (o PrimaryStepOutput) ToPrimaryStepOutputWithContext(ctx context.Context) PrimaryStepOutput {
	return o
}

func (o PrimaryStepOutput) ToPrimaryStepPtrOutput() PrimaryStepPtrOutput {
	return o.ToPrimaryStepPtrOutputWithContext(context.Background())
}

func (o PrimaryStepOutput) ToPrimaryStepPtrOutputWithContext(ctx context.Context) PrimaryStepPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PrimaryStep) *PrimaryStep {
		return &v
	}).(PrimaryStepPtrOutput)
}

func (o PrimaryStepOutput) ToOutput(ctx context.Context) pulumix.Output[PrimaryStep] {
	return pulumix.Output[PrimaryStep]{
		OutputState: o.OutputState,
	}
}

// Step Id and outcome of each individual step.
func (o PrimaryStepOutput) IndividualOutcome() IndividualOutcomeArrayOutput {
	return o.ApplyT(func(v PrimaryStep) []IndividualOutcome { return v.IndividualOutcome }).(IndividualOutcomeArrayOutput)
}

// Rollup test status of multiple steps that were run with the same configuration as a group.
func (o PrimaryStepOutput) RollUp() PrimaryStepRollUpPtrOutput {
	return o.ApplyT(func(v PrimaryStep) *PrimaryStepRollUp { return v.RollUp }).(PrimaryStepRollUpPtrOutput)
}

type PrimaryStepPtrOutput struct{ *pulumi.OutputState }

func (PrimaryStepPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PrimaryStep)(nil)).Elem()
}

func (o PrimaryStepPtrOutput) ToPrimaryStepPtrOutput() PrimaryStepPtrOutput {
	return o
}

func (o PrimaryStepPtrOutput) ToPrimaryStepPtrOutputWithContext(ctx context.Context) PrimaryStepPtrOutput {
	return o
}

func (o PrimaryStepPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*PrimaryStep] {
	return pulumix.Output[*PrimaryStep]{
		OutputState: o.OutputState,
	}
}

func (o PrimaryStepPtrOutput) Elem() PrimaryStepOutput {
	return o.ApplyT(func(v *PrimaryStep) PrimaryStep {
		if v != nil {
			return *v
		}
		var ret PrimaryStep
		return ret
	}).(PrimaryStepOutput)
}

// Step Id and outcome of each individual step.
func (o PrimaryStepPtrOutput) IndividualOutcome() IndividualOutcomeArrayOutput {
	return o.ApplyT(func(v *PrimaryStep) []IndividualOutcome {
		if v == nil {
			return nil
		}
		return v.IndividualOutcome
	}).(IndividualOutcomeArrayOutput)
}

// Rollup test status of multiple steps that were run with the same configuration as a group.
func (o PrimaryStepPtrOutput) RollUp() PrimaryStepRollUpPtrOutput {
	return o.ApplyT(func(v *PrimaryStep) *PrimaryStepRollUp {
		if v == nil {
			return nil
		}
		return v.RollUp
	}).(PrimaryStepRollUpPtrOutput)
}

// Stores rollup test status of multiple steps that were run as a group and outcome of each individual step.
type PrimaryStepResponse struct {
	// Step Id and outcome of each individual step.
	IndividualOutcome []IndividualOutcomeResponse `pulumi:"individualOutcome"`
	// Rollup test status of multiple steps that were run with the same configuration as a group.
	RollUp string `pulumi:"rollUp"`
}

// Stores rollup test status of multiple steps that were run as a group and outcome of each individual step.
type PrimaryStepResponseOutput struct{ *pulumi.OutputState }

func (PrimaryStepResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PrimaryStepResponse)(nil)).Elem()
}

func (o PrimaryStepResponseOutput) ToPrimaryStepResponseOutput() PrimaryStepResponseOutput {
	return o
}

func (o PrimaryStepResponseOutput) ToPrimaryStepResponseOutputWithContext(ctx context.Context) PrimaryStepResponseOutput {
	return o
}

func (o PrimaryStepResponseOutput) ToOutput(ctx context.Context) pulumix.Output[PrimaryStepResponse] {
	return pulumix.Output[PrimaryStepResponse]{
		OutputState: o.OutputState,
	}
}

// Step Id and outcome of each individual step.
func (o PrimaryStepResponseOutput) IndividualOutcome() IndividualOutcomeResponseArrayOutput {
	return o.ApplyT(func(v PrimaryStepResponse) []IndividualOutcomeResponse { return v.IndividualOutcome }).(IndividualOutcomeResponseArrayOutput)
}

// Rollup test status of multiple steps that were run with the same configuration as a group.
func (o PrimaryStepResponseOutput) RollUp() pulumi.StringOutput {
	return o.ApplyT(func(v PrimaryStepResponse) string { return v.RollUp }).(pulumi.StringOutput)
}

// Details for an outcome with a SKIPPED outcome summary.
type SkippedDetail struct {
	// If the App doesn't support the specific API level.
	IncompatibleAppVersion *bool `pulumi:"incompatibleAppVersion"`
	// If the App doesn't run on the specific architecture, for example, x86.
	IncompatibleArchitecture *bool `pulumi:"incompatibleArchitecture"`
	// If the requested OS version doesn't run on the specific device model.
	IncompatibleDevice *bool `pulumi:"incompatibleDevice"`
}

// SkippedDetailInput is an input type that accepts SkippedDetailArgs and SkippedDetailOutput values.
// You can construct a concrete instance of `SkippedDetailInput` via:
//
//	SkippedDetailArgs{...}
type SkippedDetailInput interface {
	pulumi.Input

	ToSkippedDetailOutput() SkippedDetailOutput
	ToSkippedDetailOutputWithContext(context.Context) SkippedDetailOutput
}

// Details for an outcome with a SKIPPED outcome summary.
type SkippedDetailArgs struct {
	// If the App doesn't support the specific API level.
	IncompatibleAppVersion pulumi.BoolPtrInput `pulumi:"incompatibleAppVersion"`
	// If the App doesn't run on the specific architecture, for example, x86.
	IncompatibleArchitecture pulumi.BoolPtrInput `pulumi:"incompatibleArchitecture"`
	// If the requested OS version doesn't run on the specific device model.
	IncompatibleDevice pulumi.BoolPtrInput `pulumi:"incompatibleDevice"`
}

func (SkippedDetailArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SkippedDetail)(nil)).Elem()
}

func (i SkippedDetailArgs) ToSkippedDetailOutput() SkippedDetailOutput {
	return i.ToSkippedDetailOutputWithContext(context.Background())
}

func (i SkippedDetailArgs) ToSkippedDetailOutputWithContext(ctx context.Context) SkippedDetailOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkippedDetailOutput)
}

func (i SkippedDetailArgs) ToOutput(ctx context.Context) pulumix.Output[SkippedDetail] {
	return pulumix.Output[SkippedDetail]{
		OutputState: i.ToSkippedDetailOutputWithContext(ctx).OutputState,
	}
}

func (i SkippedDetailArgs) ToSkippedDetailPtrOutput() SkippedDetailPtrOutput {
	return i.ToSkippedDetailPtrOutputWithContext(context.Background())
}

func (i SkippedDetailArgs) ToSkippedDetailPtrOutputWithContext(ctx context.Context) SkippedDetailPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkippedDetailOutput).ToSkippedDetailPtrOutputWithContext(ctx)
}

// SkippedDetailPtrInput is an input type that accepts SkippedDetailArgs, SkippedDetailPtr and SkippedDetailPtrOutput values.
// You can construct a concrete instance of `SkippedDetailPtrInput` via:
//
//	        SkippedDetailArgs{...}
//
//	or:
//
//	        nil
type SkippedDetailPtrInput interface {
	pulumi.Input

	ToSkippedDetailPtrOutput() SkippedDetailPtrOutput
	ToSkippedDetailPtrOutputWithContext(context.Context) SkippedDetailPtrOutput
}

type skippedDetailPtrType SkippedDetailArgs

func SkippedDetailPtr(v *SkippedDetailArgs) SkippedDetailPtrInput {
	return (*skippedDetailPtrType)(v)
}

func (*skippedDetailPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SkippedDetail)(nil)).Elem()
}

func (i *skippedDetailPtrType) ToSkippedDetailPtrOutput() SkippedDetailPtrOutput {
	return i.ToSkippedDetailPtrOutputWithContext(context.Background())
}

func (i *skippedDetailPtrType) ToSkippedDetailPtrOutputWithContext(ctx context.Context) SkippedDetailPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SkippedDetailPtrOutput)
}

func (i *skippedDetailPtrType) ToOutput(ctx context.Context) pulumix.Output[*SkippedDetail] {
	return pulumix.Output[*SkippedDetail]{
		OutputState: i.ToSkippedDetailPtrOutputWithContext(ctx).OutputState,
	}
}

// Details for an outcome with a SKIPPED outcome summary.
type SkippedDetailOutput struct{ *pulumi.OutputState }

func (SkippedDetailOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SkippedDetail)(nil)).Elem()
}

func (o SkippedDetailOutput) ToSkippedDetailOutput() SkippedDetailOutput {
	return o
}

func (o SkippedDetailOutput) ToSkippedDetailOutputWithContext(ctx context.Context) SkippedDetailOutput {
	return o
}

func (o SkippedDetailOutput) ToSkippedDetailPtrOutput() SkippedDetailPtrOutput {
	return o.ToSkippedDetailPtrOutputWithContext(context.Background())
}

func (o SkippedDetailOutput) ToSkippedDetailPtrOutputWithContext(ctx context.Context) SkippedDetailPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SkippedDetail) *SkippedDetail {
		return &v
	}).(SkippedDetailPtrOutput)
}

func (o SkippedDetailOutput) ToOutput(ctx context.Context) pulumix.Output[SkippedDetail] {
	return pulumix.Output[SkippedDetail]{
		OutputState: o.OutputState,
	}
}

// If the App doesn't support the specific API level.
func (o SkippedDetailOutput) IncompatibleAppVersion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SkippedDetail) *bool { return v.IncompatibleAppVersion }).(pulumi.BoolPtrOutput)
}

// If the App doesn't run on the specific architecture, for example, x86.
func (o SkippedDetailOutput) IncompatibleArchitecture() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SkippedDetail) *bool { return v.IncompatibleArchitecture }).(pulumi.BoolPtrOutput)
}

// If the requested OS version doesn't run on the specific device model.
func (o SkippedDetailOutput) IncompatibleDevice() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SkippedDetail) *bool { return v.IncompatibleDevice }).(pulumi.BoolPtrOutput)
}

type SkippedDetailPtrOutput struct{ *pulumi.OutputState }

func (SkippedDetailPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SkippedDetail)(nil)).Elem()
}

func (o SkippedDetailPtrOutput) ToSkippedDetailPtrOutput() SkippedDetailPtrOutput {
	return o
}

func (o SkippedDetailPtrOutput) ToSkippedDetailPtrOutputWithContext(ctx context.Context) SkippedDetailPtrOutput {
	return o
}

func (o SkippedDetailPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*SkippedDetail] {
	return pulumix.Output[*SkippedDetail]{
		OutputState: o.OutputState,
	}
}

func (o SkippedDetailPtrOutput) Elem() SkippedDetailOutput {
	return o.ApplyT(func(v *SkippedDetail) SkippedDetail {
		if v != nil {
			return *v
		}
		var ret SkippedDetail
		return ret
	}).(SkippedDetailOutput)
}

// If the App doesn't support the specific API level.
func (o SkippedDetailPtrOutput) IncompatibleAppVersion() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SkippedDetail) *bool {
		if v == nil {
			return nil
		}
		return v.IncompatibleAppVersion
	}).(pulumi.BoolPtrOutput)
}

// If the App doesn't run on the specific architecture, for example, x86.
func (o SkippedDetailPtrOutput) IncompatibleArchitecture() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SkippedDetail) *bool {
		if v == nil {
			return nil
		}
		return v.IncompatibleArchitecture
	}).(pulumi.BoolPtrOutput)
}

// If the requested OS version doesn't run on the specific device model.
func (o SkippedDetailPtrOutput) IncompatibleDevice() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SkippedDetail) *bool {
		if v == nil {
			return nil
		}
		return v.IncompatibleDevice
	}).(pulumi.BoolPtrOutput)
}

// Details for an outcome with a SKIPPED outcome summary.
type SkippedDetailResponse struct {
	// If the App doesn't support the specific API level.
	IncompatibleAppVersion bool `pulumi:"incompatibleAppVersion"`
	// If the App doesn't run on the specific architecture, for example, x86.
	IncompatibleArchitecture bool `pulumi:"incompatibleArchitecture"`
	// If the requested OS version doesn't run on the specific device model.
	IncompatibleDevice bool `pulumi:"incompatibleDevice"`
}

// Details for an outcome with a SKIPPED outcome summary.
type SkippedDetailResponseOutput struct{ *pulumi.OutputState }

func (SkippedDetailResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SkippedDetailResponse)(nil)).Elem()
}

func (o SkippedDetailResponseOutput) ToSkippedDetailResponseOutput() SkippedDetailResponseOutput {
	return o
}

func (o SkippedDetailResponseOutput) ToSkippedDetailResponseOutputWithContext(ctx context.Context) SkippedDetailResponseOutput {
	return o
}

func (o SkippedDetailResponseOutput) ToOutput(ctx context.Context) pulumix.Output[SkippedDetailResponse] {
	return pulumix.Output[SkippedDetailResponse]{
		OutputState: o.OutputState,
	}
}

// If the App doesn't support the specific API level.
func (o SkippedDetailResponseOutput) IncompatibleAppVersion() pulumi.BoolOutput {
	return o.ApplyT(func(v SkippedDetailResponse) bool { return v.IncompatibleAppVersion }).(pulumi.BoolOutput)
}

// If the App doesn't run on the specific architecture, for example, x86.
func (o SkippedDetailResponseOutput) IncompatibleArchitecture() pulumi.BoolOutput {
	return o.ApplyT(func(v SkippedDetailResponse) bool { return v.IncompatibleArchitecture }).(pulumi.BoolOutput)
}

// If the requested OS version doesn't run on the specific device model.
func (o SkippedDetailResponseOutput) IncompatibleDevice() pulumi.BoolOutput {
	return o.ApplyT(func(v SkippedDetailResponse) bool { return v.IncompatibleDevice }).(pulumi.BoolOutput)
}

// The details about how to run the execution.
type Specification struct {
	// An Android mobile test execution specification.
	AndroidTest *AndroidTest `pulumi:"androidTest"`
	// An iOS mobile test execution specification.
	IosTest *IosTest `pulumi:"iosTest"`
}

// SpecificationInput is an input type that accepts SpecificationArgs and SpecificationOutput values.
// You can construct a concrete instance of `SpecificationInput` via:
//
//	SpecificationArgs{...}
type SpecificationInput interface {
	pulumi.Input

	ToSpecificationOutput() SpecificationOutput
	ToSpecificationOutputWithContext(context.Context) SpecificationOutput
}

// The details about how to run the execution.
type SpecificationArgs struct {
	// An Android mobile test execution specification.
	AndroidTest AndroidTestPtrInput `pulumi:"androidTest"`
	// An iOS mobile test execution specification.
	IosTest IosTestPtrInput `pulumi:"iosTest"`
}

func (SpecificationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Specification)(nil)).Elem()
}

func (i SpecificationArgs) ToSpecificationOutput() SpecificationOutput {
	return i.ToSpecificationOutputWithContext(context.Background())
}

func (i SpecificationArgs) ToSpecificationOutputWithContext(ctx context.Context) SpecificationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpecificationOutput)
}

func (i SpecificationArgs) ToOutput(ctx context.Context) pulumix.Output[Specification] {
	return pulumix.Output[Specification]{
		OutputState: i.ToSpecificationOutputWithContext(ctx).OutputState,
	}
}

func (i SpecificationArgs) ToSpecificationPtrOutput() SpecificationPtrOutput {
	return i.ToSpecificationPtrOutputWithContext(context.Background())
}

func (i SpecificationArgs) ToSpecificationPtrOutputWithContext(ctx context.Context) SpecificationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpecificationOutput).ToSpecificationPtrOutputWithContext(ctx)
}

// SpecificationPtrInput is an input type that accepts SpecificationArgs, SpecificationPtr and SpecificationPtrOutput values.
// You can construct a concrete instance of `SpecificationPtrInput` via:
//
//	        SpecificationArgs{...}
//
//	or:
//
//	        nil
type SpecificationPtrInput interface {
	pulumi.Input

	ToSpecificationPtrOutput() SpecificationPtrOutput
	ToSpecificationPtrOutputWithContext(context.Context) SpecificationPtrOutput
}

type specificationPtrType SpecificationArgs

func SpecificationPtr(v *SpecificationArgs) SpecificationPtrInput {
	return (*specificationPtrType)(v)
}

func (*specificationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Specification)(nil)).Elem()
}

func (i *specificationPtrType) ToSpecificationPtrOutput() SpecificationPtrOutput {
	return i.ToSpecificationPtrOutputWithContext(context.Background())
}

func (i *specificationPtrType) ToSpecificationPtrOutputWithContext(ctx context.Context) SpecificationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SpecificationPtrOutput)
}

func (i *specificationPtrType) ToOutput(ctx context.Context) pulumix.Output[*Specification] {
	return pulumix.Output[*Specification]{
		OutputState: i.ToSpecificationPtrOutputWithContext(ctx).OutputState,
	}
}

// The details about how to run the execution.
type SpecificationOutput struct{ *pulumi.OutputState }

func (SpecificationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Specification)(nil)).Elem()
}

func (o SpecificationOutput) ToSpecificationOutput() SpecificationOutput {
	return o
}

func (o SpecificationOutput) ToSpecificationOutputWithContext(ctx context.Context) SpecificationOutput {
	return o
}

func (o SpecificationOutput) ToSpecificationPtrOutput() SpecificationPtrOutput {
	return o.ToSpecificationPtrOutputWithContext(context.Background())
}

func (o SpecificationOutput) ToSpecificationPtrOutputWithContext(ctx context.Context) SpecificationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Specification) *Specification {
		return &v
	}).(SpecificationPtrOutput)
}

func (o SpecificationOutput) ToOutput(ctx context.Context) pulumix.Output[Specification] {
	return pulumix.Output[Specification]{
		OutputState: o.OutputState,
	}
}

// An Android mobile test execution specification.
func (o SpecificationOutput) AndroidTest() AndroidTestPtrOutput {
	return o.ApplyT(func(v Specification) *AndroidTest { return v.AndroidTest }).(AndroidTestPtrOutput)
}

// An iOS mobile test execution specification.
func (o SpecificationOutput) IosTest() IosTestPtrOutput {
	return o.ApplyT(func(v Specification) *IosTest { return v.IosTest }).(IosTestPtrOutput)
}

type SpecificationPtrOutput struct{ *pulumi.OutputState }

func (SpecificationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Specification)(nil)).Elem()
}

func (o SpecificationPtrOutput) ToSpecificationPtrOutput() SpecificationPtrOutput {
	return o
}

func (o SpecificationPtrOutput) ToSpecificationPtrOutputWithContext(ctx context.Context) SpecificationPtrOutput {
	return o
}

func (o SpecificationPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*Specification] {
	return pulumix.Output[*Specification]{
		OutputState: o.OutputState,
	}
}

func (o SpecificationPtrOutput) Elem() SpecificationOutput {
	return o.ApplyT(func(v *Specification) Specification {
		if v != nil {
			return *v
		}
		var ret Specification
		return ret
	}).(SpecificationOutput)
}

// An Android mobile test execution specification.
func (o SpecificationPtrOutput) AndroidTest() AndroidTestPtrOutput {
	return o.ApplyT(func(v *Specification) *AndroidTest {
		if v == nil {
			return nil
		}
		return v.AndroidTest
	}).(AndroidTestPtrOutput)
}

// An iOS mobile test execution specification.
func (o SpecificationPtrOutput) IosTest() IosTestPtrOutput {
	return o.ApplyT(func(v *Specification) *IosTest {
		if v == nil {
			return nil
		}
		return v.IosTest
	}).(IosTestPtrOutput)
}

// The details about how to run the execution.
type SpecificationResponse struct {
	// An Android mobile test execution specification.
	AndroidTest AndroidTestResponse `pulumi:"androidTest"`
	// An iOS mobile test execution specification.
	IosTest IosTestResponse `pulumi:"iosTest"`
}

// The details about how to run the execution.
type SpecificationResponseOutput struct{ *pulumi.OutputState }

func (SpecificationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SpecificationResponse)(nil)).Elem()
}

func (o SpecificationResponseOutput) ToSpecificationResponseOutput() SpecificationResponseOutput {
	return o
}

func (o SpecificationResponseOutput) ToSpecificationResponseOutputWithContext(ctx context.Context) SpecificationResponseOutput {
	return o
}

func (o SpecificationResponseOutput) ToOutput(ctx context.Context) pulumix.Output[SpecificationResponse] {
	return pulumix.Output[SpecificationResponse]{
		OutputState: o.OutputState,
	}
}

// An Android mobile test execution specification.
func (o SpecificationResponseOutput) AndroidTest() AndroidTestResponseOutput {
	return o.ApplyT(func(v SpecificationResponse) AndroidTestResponse { return v.AndroidTest }).(AndroidTestResponseOutput)
}

// An iOS mobile test execution specification.
func (o SpecificationResponseOutput) IosTest() IosTestResponseOutput {
	return o.ApplyT(func(v SpecificationResponse) IosTestResponse { return v.IosTest }).(IosTestResponseOutput)
}

// A stacktrace.
type StackTrace struct {
	// The stack trace message. Required
	Exception *string `pulumi:"exception"`
}

// StackTraceInput is an input type that accepts StackTraceArgs and StackTraceOutput values.
// You can construct a concrete instance of `StackTraceInput` via:
//
//	StackTraceArgs{...}
type StackTraceInput interface {
	pulumi.Input

	ToStackTraceOutput() StackTraceOutput
	ToStackTraceOutputWithContext(context.Context) StackTraceOutput
}

// A stacktrace.
type StackTraceArgs struct {
	// The stack trace message. Required
	Exception pulumi.StringPtrInput `pulumi:"exception"`
}

func (StackTraceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StackTrace)(nil)).Elem()
}

func (i StackTraceArgs) ToStackTraceOutput() StackTraceOutput {
	return i.ToStackTraceOutputWithContext(context.Background())
}

func (i StackTraceArgs) ToStackTraceOutputWithContext(ctx context.Context) StackTraceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StackTraceOutput)
}

func (i StackTraceArgs) ToOutput(ctx context.Context) pulumix.Output[StackTrace] {
	return pulumix.Output[StackTrace]{
		OutputState: i.ToStackTraceOutputWithContext(ctx).OutputState,
	}
}

func (i StackTraceArgs) ToStackTracePtrOutput() StackTracePtrOutput {
	return i.ToStackTracePtrOutputWithContext(context.Background())
}

func (i StackTraceArgs) ToStackTracePtrOutputWithContext(ctx context.Context) StackTracePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StackTraceOutput).ToStackTracePtrOutputWithContext(ctx)
}

// StackTracePtrInput is an input type that accepts StackTraceArgs, StackTracePtr and StackTracePtrOutput values.
// You can construct a concrete instance of `StackTracePtrInput` via:
//
//	        StackTraceArgs{...}
//
//	or:
//
//	        nil
type StackTracePtrInput interface {
	pulumi.Input

	ToStackTracePtrOutput() StackTracePtrOutput
	ToStackTracePtrOutputWithContext(context.Context) StackTracePtrOutput
}

type stackTracePtrType StackTraceArgs

func StackTracePtr(v *StackTraceArgs) StackTracePtrInput {
	return (*stackTracePtrType)(v)
}

func (*stackTracePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StackTrace)(nil)).Elem()
}

func (i *stackTracePtrType) ToStackTracePtrOutput() StackTracePtrOutput {
	return i.ToStackTracePtrOutputWithContext(context.Background())
}

func (i *stackTracePtrType) ToStackTracePtrOutputWithContext(ctx context.Context) StackTracePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StackTracePtrOutput)
}

func (i *stackTracePtrType) ToOutput(ctx context.Context) pulumix.Output[*StackTrace] {
	return pulumix.Output[*StackTrace]{
		OutputState: i.ToStackTracePtrOutputWithContext(ctx).OutputState,
	}
}

// A stacktrace.
type StackTraceOutput struct{ *pulumi.OutputState }

func (StackTraceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StackTrace)(nil)).Elem()
}

func (o StackTraceOutput) ToStackTraceOutput() StackTraceOutput {
	return o
}

func (o StackTraceOutput) ToStackTraceOutputWithContext(ctx context.Context) StackTraceOutput {
	return o
}

func (o StackTraceOutput) ToStackTracePtrOutput() StackTracePtrOutput {
	return o.ToStackTracePtrOutputWithContext(context.Background())
}

func (o StackTraceOutput) ToStackTracePtrOutputWithContext(ctx context.Context) StackTracePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StackTrace) *StackTrace {
		return &v
	}).(StackTracePtrOutput)
}

func (o StackTraceOutput) ToOutput(ctx context.Context) pulumix.Output[StackTrace] {
	return pulumix.Output[StackTrace]{
		OutputState: o.OutputState,
	}
}

// The stack trace message. Required
func (o StackTraceOutput) Exception() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StackTrace) *string { return v.Exception }).(pulumi.StringPtrOutput)
}

type StackTracePtrOutput struct{ *pulumi.OutputState }

func (StackTracePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StackTrace)(nil)).Elem()
}

func (o StackTracePtrOutput) ToStackTracePtrOutput() StackTracePtrOutput {
	return o
}

func (o StackTracePtrOutput) ToStackTracePtrOutputWithContext(ctx context.Context) StackTracePtrOutput {
	return o
}

func (o StackTracePtrOutput) ToOutput(ctx context.Context) pulumix.Output[*StackTrace] {
	return pulumix.Output[*StackTrace]{
		OutputState: o.OutputState,
	}
}

func (o StackTracePtrOutput) Elem() StackTraceOutput {
	return o.ApplyT(func(v *StackTrace) StackTrace {
		if v != nil {
			return *v
		}
		var ret StackTrace
		return ret
	}).(StackTraceOutput)
}

// The stack trace message. Required
func (o StackTracePtrOutput) Exception() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StackTrace) *string {
		if v == nil {
			return nil
		}
		return v.Exception
	}).(pulumi.StringPtrOutput)
}

// A stacktrace.
type StackTraceResponse struct {
	// The stack trace message. Required
	Exception string `pulumi:"exception"`
}

// A stacktrace.
type StackTraceResponseOutput struct{ *pulumi.OutputState }

func (StackTraceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StackTraceResponse)(nil)).Elem()
}

func (o StackTraceResponseOutput) ToStackTraceResponseOutput() StackTraceResponseOutput {
	return o
}

func (o StackTraceResponseOutput) ToStackTraceResponseOutputWithContext(ctx context.Context) StackTraceResponseOutput {
	return o
}

func (o StackTraceResponseOutput) ToOutput(ctx context.Context) pulumix.Output[StackTraceResponse] {
	return pulumix.Output[StackTraceResponse]{
		OutputState: o.OutputState,
	}
}

// The stack trace message. Required
func (o StackTraceResponseOutput) Exception() pulumi.StringOutput {
	return o.ApplyT(func(v StackTraceResponse) string { return v.Exception }).(pulumi.StringOutput)
}

type StepDimensionValueEntry struct {
	Key   *string `pulumi:"key"`
	Value *string `pulumi:"value"`
}

// StepDimensionValueEntryInput is an input type that accepts StepDimensionValueEntryArgs and StepDimensionValueEntryOutput values.
// You can construct a concrete instance of `StepDimensionValueEntryInput` via:
//
//	StepDimensionValueEntryArgs{...}
type StepDimensionValueEntryInput interface {
	pulumi.Input

	ToStepDimensionValueEntryOutput() StepDimensionValueEntryOutput
	ToStepDimensionValueEntryOutputWithContext(context.Context) StepDimensionValueEntryOutput
}

type StepDimensionValueEntryArgs struct {
	Key   pulumi.StringPtrInput `pulumi:"key"`
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (StepDimensionValueEntryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StepDimensionValueEntry)(nil)).Elem()
}

func (i StepDimensionValueEntryArgs) ToStepDimensionValueEntryOutput() StepDimensionValueEntryOutput {
	return i.ToStepDimensionValueEntryOutputWithContext(context.Background())
}

func (i StepDimensionValueEntryArgs) ToStepDimensionValueEntryOutputWithContext(ctx context.Context) StepDimensionValueEntryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StepDimensionValueEntryOutput)
}

func (i StepDimensionValueEntryArgs) ToOutput(ctx context.Context) pulumix.Output[StepDimensionValueEntry] {
	return pulumix.Output[StepDimensionValueEntry]{
		OutputState: i.ToStepDimensionValueEntryOutputWithContext(ctx).OutputState,
	}
}

// StepDimensionValueEntryArrayInput is an input type that accepts StepDimensionValueEntryArray and StepDimensionValueEntryArrayOutput values.
// You can construct a concrete instance of `StepDimensionValueEntryArrayInput` via:
//
//	StepDimensionValueEntryArray{ StepDimensionValueEntryArgs{...} }
type StepDimensionValueEntryArrayInput interface {
	pulumi.Input

	ToStepDimensionValueEntryArrayOutput() StepDimensionValueEntryArrayOutput
	ToStepDimensionValueEntryArrayOutputWithContext(context.Context) StepDimensionValueEntryArrayOutput
}

type StepDimensionValueEntryArray []StepDimensionValueEntryInput

func (StepDimensionValueEntryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StepDimensionValueEntry)(nil)).Elem()
}

func (i StepDimensionValueEntryArray) ToStepDimensionValueEntryArrayOutput() StepDimensionValueEntryArrayOutput {
	return i.ToStepDimensionValueEntryArrayOutputWithContext(context.Background())
}

func (i StepDimensionValueEntryArray) ToStepDimensionValueEntryArrayOutputWithContext(ctx context.Context) StepDimensionValueEntryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StepDimensionValueEntryArrayOutput)
}

func (i StepDimensionValueEntryArray) ToOutput(ctx context.Context) pulumix.Output[[]StepDimensionValueEntry] {
	return pulumix.Output[[]StepDimensionValueEntry]{
		OutputState: i.ToStepDimensionValueEntryArrayOutputWithContext(ctx).OutputState,
	}
}

type StepDimensionValueEntryOutput struct{ *pulumi.OutputState }

func (StepDimensionValueEntryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StepDimensionValueEntry)(nil)).Elem()
}

func (o StepDimensionValueEntryOutput) ToStepDimensionValueEntryOutput() StepDimensionValueEntryOutput {
	return o
}

func (o StepDimensionValueEntryOutput) ToStepDimensionValueEntryOutputWithContext(ctx context.Context) StepDimensionValueEntryOutput {
	return o
}

func (o StepDimensionValueEntryOutput) ToOutput(ctx context.Context) pulumix.Output[StepDimensionValueEntry] {
	return pulumix.Output[StepDimensionValueEntry]{
		OutputState: o.OutputState,
	}
}

func (o StepDimensionValueEntryOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StepDimensionValueEntry) *string { return v.Key }).(pulumi.StringPtrOutput)
}

func (o StepDimensionValueEntryOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StepDimensionValueEntry) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type StepDimensionValueEntryArrayOutput struct{ *pulumi.OutputState }

func (StepDimensionValueEntryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StepDimensionValueEntry)(nil)).Elem()
}

func (o StepDimensionValueEntryArrayOutput) ToStepDimensionValueEntryArrayOutput() StepDimensionValueEntryArrayOutput {
	return o
}

func (o StepDimensionValueEntryArrayOutput) ToStepDimensionValueEntryArrayOutputWithContext(ctx context.Context) StepDimensionValueEntryArrayOutput {
	return o
}

func (o StepDimensionValueEntryArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]StepDimensionValueEntry] {
	return pulumix.Output[[]StepDimensionValueEntry]{
		OutputState: o.OutputState,
	}
}

func (o StepDimensionValueEntryArrayOutput) Index(i pulumi.IntInput) StepDimensionValueEntryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StepDimensionValueEntry {
		return vs[0].([]StepDimensionValueEntry)[vs[1].(int)]
	}).(StepDimensionValueEntryOutput)
}

type StepDimensionValueEntryResponse struct {
	Key   string `pulumi:"key"`
	Value string `pulumi:"value"`
}

type StepDimensionValueEntryResponseOutput struct{ *pulumi.OutputState }

func (StepDimensionValueEntryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StepDimensionValueEntryResponse)(nil)).Elem()
}

func (o StepDimensionValueEntryResponseOutput) ToStepDimensionValueEntryResponseOutput() StepDimensionValueEntryResponseOutput {
	return o
}

func (o StepDimensionValueEntryResponseOutput) ToStepDimensionValueEntryResponseOutputWithContext(ctx context.Context) StepDimensionValueEntryResponseOutput {
	return o
}

func (o StepDimensionValueEntryResponseOutput) ToOutput(ctx context.Context) pulumix.Output[StepDimensionValueEntryResponse] {
	return pulumix.Output[StepDimensionValueEntryResponse]{
		OutputState: o.OutputState,
	}
}

func (o StepDimensionValueEntryResponseOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v StepDimensionValueEntryResponse) string { return v.Key }).(pulumi.StringOutput)
}

func (o StepDimensionValueEntryResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v StepDimensionValueEntryResponse) string { return v.Value }).(pulumi.StringOutput)
}

type StepDimensionValueEntryResponseArrayOutput struct{ *pulumi.OutputState }

func (StepDimensionValueEntryResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StepDimensionValueEntryResponse)(nil)).Elem()
}

func (o StepDimensionValueEntryResponseArrayOutput) ToStepDimensionValueEntryResponseArrayOutput() StepDimensionValueEntryResponseArrayOutput {
	return o
}

func (o StepDimensionValueEntryResponseArrayOutput) ToStepDimensionValueEntryResponseArrayOutputWithContext(ctx context.Context) StepDimensionValueEntryResponseArrayOutput {
	return o
}

func (o StepDimensionValueEntryResponseArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]StepDimensionValueEntryResponse] {
	return pulumix.Output[[]StepDimensionValueEntryResponse]{
		OutputState: o.OutputState,
	}
}

func (o StepDimensionValueEntryResponseArrayOutput) Index(i pulumi.IntInput) StepDimensionValueEntryResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StepDimensionValueEntryResponse {
		return vs[0].([]StepDimensionValueEntryResponse)[vs[1].(int)]
	}).(StepDimensionValueEntryResponseOutput)
}

type StepLabelsEntry struct {
	Key   *string `pulumi:"key"`
	Value *string `pulumi:"value"`
}

// StepLabelsEntryInput is an input type that accepts StepLabelsEntryArgs and StepLabelsEntryOutput values.
// You can construct a concrete instance of `StepLabelsEntryInput` via:
//
//	StepLabelsEntryArgs{...}
type StepLabelsEntryInput interface {
	pulumi.Input

	ToStepLabelsEntryOutput() StepLabelsEntryOutput
	ToStepLabelsEntryOutputWithContext(context.Context) StepLabelsEntryOutput
}

type StepLabelsEntryArgs struct {
	Key   pulumi.StringPtrInput `pulumi:"key"`
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (StepLabelsEntryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StepLabelsEntry)(nil)).Elem()
}

func (i StepLabelsEntryArgs) ToStepLabelsEntryOutput() StepLabelsEntryOutput {
	return i.ToStepLabelsEntryOutputWithContext(context.Background())
}

func (i StepLabelsEntryArgs) ToStepLabelsEntryOutputWithContext(ctx context.Context) StepLabelsEntryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StepLabelsEntryOutput)
}

func (i StepLabelsEntryArgs) ToOutput(ctx context.Context) pulumix.Output[StepLabelsEntry] {
	return pulumix.Output[StepLabelsEntry]{
		OutputState: i.ToStepLabelsEntryOutputWithContext(ctx).OutputState,
	}
}

// StepLabelsEntryArrayInput is an input type that accepts StepLabelsEntryArray and StepLabelsEntryArrayOutput values.
// You can construct a concrete instance of `StepLabelsEntryArrayInput` via:
//
//	StepLabelsEntryArray{ StepLabelsEntryArgs{...} }
type StepLabelsEntryArrayInput interface {
	pulumi.Input

	ToStepLabelsEntryArrayOutput() StepLabelsEntryArrayOutput
	ToStepLabelsEntryArrayOutputWithContext(context.Context) StepLabelsEntryArrayOutput
}

type StepLabelsEntryArray []StepLabelsEntryInput

func (StepLabelsEntryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StepLabelsEntry)(nil)).Elem()
}

func (i StepLabelsEntryArray) ToStepLabelsEntryArrayOutput() StepLabelsEntryArrayOutput {
	return i.ToStepLabelsEntryArrayOutputWithContext(context.Background())
}

func (i StepLabelsEntryArray) ToStepLabelsEntryArrayOutputWithContext(ctx context.Context) StepLabelsEntryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StepLabelsEntryArrayOutput)
}

func (i StepLabelsEntryArray) ToOutput(ctx context.Context) pulumix.Output[[]StepLabelsEntry] {
	return pulumix.Output[[]StepLabelsEntry]{
		OutputState: i.ToStepLabelsEntryArrayOutputWithContext(ctx).OutputState,
	}
}

type StepLabelsEntryOutput struct{ *pulumi.OutputState }

func (StepLabelsEntryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StepLabelsEntry)(nil)).Elem()
}

func (o StepLabelsEntryOutput) ToStepLabelsEntryOutput() StepLabelsEntryOutput {
	return o
}

func (o StepLabelsEntryOutput) ToStepLabelsEntryOutputWithContext(ctx context.Context) StepLabelsEntryOutput {
	return o
}

func (o StepLabelsEntryOutput) ToOutput(ctx context.Context) pulumix.Output[StepLabelsEntry] {
	return pulumix.Output[StepLabelsEntry]{
		OutputState: o.OutputState,
	}
}

func (o StepLabelsEntryOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StepLabelsEntry) *string { return v.Key }).(pulumi.StringPtrOutput)
}

func (o StepLabelsEntryOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v StepLabelsEntry) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type StepLabelsEntryArrayOutput struct{ *pulumi.OutputState }

func (StepLabelsEntryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StepLabelsEntry)(nil)).Elem()
}

func (o StepLabelsEntryArrayOutput) ToStepLabelsEntryArrayOutput() StepLabelsEntryArrayOutput {
	return o
}

func (o StepLabelsEntryArrayOutput) ToStepLabelsEntryArrayOutputWithContext(ctx context.Context) StepLabelsEntryArrayOutput {
	return o
}

func (o StepLabelsEntryArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]StepLabelsEntry] {
	return pulumix.Output[[]StepLabelsEntry]{
		OutputState: o.OutputState,
	}
}

func (o StepLabelsEntryArrayOutput) Index(i pulumi.IntInput) StepLabelsEntryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StepLabelsEntry {
		return vs[0].([]StepLabelsEntry)[vs[1].(int)]
	}).(StepLabelsEntryOutput)
}

type StepLabelsEntryResponse struct {
	Key   string `pulumi:"key"`
	Value string `pulumi:"value"`
}

type StepLabelsEntryResponseOutput struct{ *pulumi.OutputState }

func (StepLabelsEntryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StepLabelsEntryResponse)(nil)).Elem()
}

func (o StepLabelsEntryResponseOutput) ToStepLabelsEntryResponseOutput() StepLabelsEntryResponseOutput {
	return o
}

func (o StepLabelsEntryResponseOutput) ToStepLabelsEntryResponseOutputWithContext(ctx context.Context) StepLabelsEntryResponseOutput {
	return o
}

func (o StepLabelsEntryResponseOutput) ToOutput(ctx context.Context) pulumix.Output[StepLabelsEntryResponse] {
	return pulumix.Output[StepLabelsEntryResponse]{
		OutputState: o.OutputState,
	}
}

func (o StepLabelsEntryResponseOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v StepLabelsEntryResponse) string { return v.Key }).(pulumi.StringOutput)
}

func (o StepLabelsEntryResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v StepLabelsEntryResponse) string { return v.Value }).(pulumi.StringOutput)
}

type StepLabelsEntryResponseArrayOutput struct{ *pulumi.OutputState }

func (StepLabelsEntryResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StepLabelsEntryResponse)(nil)).Elem()
}

func (o StepLabelsEntryResponseArrayOutput) ToStepLabelsEntryResponseArrayOutput() StepLabelsEntryResponseArrayOutput {
	return o
}

func (o StepLabelsEntryResponseArrayOutput) ToStepLabelsEntryResponseArrayOutputWithContext(ctx context.Context) StepLabelsEntryResponseArrayOutput {
	return o
}

func (o StepLabelsEntryResponseArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]StepLabelsEntryResponse] {
	return pulumix.Output[[]StepLabelsEntryResponse]{
		OutputState: o.OutputState,
	}
}

func (o StepLabelsEntryResponseArrayOutput) Index(i pulumi.IntInput) StepLabelsEntryResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StepLabelsEntryResponse {
		return vs[0].([]StepLabelsEntryResponse)[vs[1].(int)]
	}).(StepLabelsEntryResponseOutput)
}

// Details for an outcome with a SUCCESS outcome summary. LINT.IfChange
type SuccessDetail struct {
	// If a native process other than the app crashed.
	OtherNativeCrash *bool `pulumi:"otherNativeCrash"`
}

// SuccessDetailInput is an input type that accepts SuccessDetailArgs and SuccessDetailOutput values.
// You can construct a concrete instance of `SuccessDetailInput` via:
//
//	SuccessDetailArgs{...}
type SuccessDetailInput interface {
	pulumi.Input

	ToSuccessDetailOutput() SuccessDetailOutput
	ToSuccessDetailOutputWithContext(context.Context) SuccessDetailOutput
}

// Details for an outcome with a SUCCESS outcome summary. LINT.IfChange
type SuccessDetailArgs struct {
	// If a native process other than the app crashed.
	OtherNativeCrash pulumi.BoolPtrInput `pulumi:"otherNativeCrash"`
}

func (SuccessDetailArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SuccessDetail)(nil)).Elem()
}

func (i SuccessDetailArgs) ToSuccessDetailOutput() SuccessDetailOutput {
	return i.ToSuccessDetailOutputWithContext(context.Background())
}

func (i SuccessDetailArgs) ToSuccessDetailOutputWithContext(ctx context.Context) SuccessDetailOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SuccessDetailOutput)
}

func (i SuccessDetailArgs) ToOutput(ctx context.Context) pulumix.Output[SuccessDetail] {
	return pulumix.Output[SuccessDetail]{
		OutputState: i.ToSuccessDetailOutputWithContext(ctx).OutputState,
	}
}

func (i SuccessDetailArgs) ToSuccessDetailPtrOutput() SuccessDetailPtrOutput {
	return i.ToSuccessDetailPtrOutputWithContext(context.Background())
}

func (i SuccessDetailArgs) ToSuccessDetailPtrOutputWithContext(ctx context.Context) SuccessDetailPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SuccessDetailOutput).ToSuccessDetailPtrOutputWithContext(ctx)
}

// SuccessDetailPtrInput is an input type that accepts SuccessDetailArgs, SuccessDetailPtr and SuccessDetailPtrOutput values.
// You can construct a concrete instance of `SuccessDetailPtrInput` via:
//
//	        SuccessDetailArgs{...}
//
//	or:
//
//	        nil
type SuccessDetailPtrInput interface {
	pulumi.Input

	ToSuccessDetailPtrOutput() SuccessDetailPtrOutput
	ToSuccessDetailPtrOutputWithContext(context.Context) SuccessDetailPtrOutput
}

type successDetailPtrType SuccessDetailArgs

func SuccessDetailPtr(v *SuccessDetailArgs) SuccessDetailPtrInput {
	return (*successDetailPtrType)(v)
}

func (*successDetailPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SuccessDetail)(nil)).Elem()
}

func (i *successDetailPtrType) ToSuccessDetailPtrOutput() SuccessDetailPtrOutput {
	return i.ToSuccessDetailPtrOutputWithContext(context.Background())
}

func (i *successDetailPtrType) ToSuccessDetailPtrOutputWithContext(ctx context.Context) SuccessDetailPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SuccessDetailPtrOutput)
}

func (i *successDetailPtrType) ToOutput(ctx context.Context) pulumix.Output[*SuccessDetail] {
	return pulumix.Output[*SuccessDetail]{
		OutputState: i.ToSuccessDetailPtrOutputWithContext(ctx).OutputState,
	}
}

// Details for an outcome with a SUCCESS outcome summary. LINT.IfChange
type SuccessDetailOutput struct{ *pulumi.OutputState }

func (SuccessDetailOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SuccessDetail)(nil)).Elem()
}

func (o SuccessDetailOutput) ToSuccessDetailOutput() SuccessDetailOutput {
	return o
}

func (o SuccessDetailOutput) ToSuccessDetailOutputWithContext(ctx context.Context) SuccessDetailOutput {
	return o
}

func (o SuccessDetailOutput) ToSuccessDetailPtrOutput() SuccessDetailPtrOutput {
	return o.ToSuccessDetailPtrOutputWithContext(context.Background())
}

func (o SuccessDetailOutput) ToSuccessDetailPtrOutputWithContext(ctx context.Context) SuccessDetailPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SuccessDetail) *SuccessDetail {
		return &v
	}).(SuccessDetailPtrOutput)
}

func (o SuccessDetailOutput) ToOutput(ctx context.Context) pulumix.Output[SuccessDetail] {
	return pulumix.Output[SuccessDetail]{
		OutputState: o.OutputState,
	}
}

// If a native process other than the app crashed.
func (o SuccessDetailOutput) OtherNativeCrash() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SuccessDetail) *bool { return v.OtherNativeCrash }).(pulumi.BoolPtrOutput)
}

type SuccessDetailPtrOutput struct{ *pulumi.OutputState }

func (SuccessDetailPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SuccessDetail)(nil)).Elem()
}

func (o SuccessDetailPtrOutput) ToSuccessDetailPtrOutput() SuccessDetailPtrOutput {
	return o
}

func (o SuccessDetailPtrOutput) ToSuccessDetailPtrOutputWithContext(ctx context.Context) SuccessDetailPtrOutput {
	return o
}

func (o SuccessDetailPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*SuccessDetail] {
	return pulumix.Output[*SuccessDetail]{
		OutputState: o.OutputState,
	}
}

func (o SuccessDetailPtrOutput) Elem() SuccessDetailOutput {
	return o.ApplyT(func(v *SuccessDetail) SuccessDetail {
		if v != nil {
			return *v
		}
		var ret SuccessDetail
		return ret
	}).(SuccessDetailOutput)
}

// If a native process other than the app crashed.
func (o SuccessDetailPtrOutput) OtherNativeCrash() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SuccessDetail) *bool {
		if v == nil {
			return nil
		}
		return v.OtherNativeCrash
	}).(pulumi.BoolPtrOutput)
}

// Details for an outcome with a SUCCESS outcome summary. LINT.IfChange
type SuccessDetailResponse struct {
	// If a native process other than the app crashed.
	OtherNativeCrash bool `pulumi:"otherNativeCrash"`
}

// Details for an outcome with a SUCCESS outcome summary. LINT.IfChange
type SuccessDetailResponseOutput struct{ *pulumi.OutputState }

func (SuccessDetailResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SuccessDetailResponse)(nil)).Elem()
}

func (o SuccessDetailResponseOutput) ToSuccessDetailResponseOutput() SuccessDetailResponseOutput {
	return o
}

func (o SuccessDetailResponseOutput) ToSuccessDetailResponseOutputWithContext(ctx context.Context) SuccessDetailResponseOutput {
	return o
}

func (o SuccessDetailResponseOutput) ToOutput(ctx context.Context) pulumix.Output[SuccessDetailResponse] {
	return pulumix.Output[SuccessDetailResponse]{
		OutputState: o.OutputState,
	}
}

// If a native process other than the app crashed.
func (o SuccessDetailResponseOutput) OtherNativeCrash() pulumi.BoolOutput {
	return o.ApplyT(func(v SuccessDetailResponse) bool { return v.OtherNativeCrash }).(pulumi.BoolOutput)
}

// A reference to a test case. Test case references are canonically ordered lexicographically by these three factors: * First, by test_suite_name. * Second, by class_name. * Third, by name.
type TestCaseReference struct {
	// The name of the class.
	ClassName *string `pulumi:"className"`
	// The name of the test case. Required.
	Name *string `pulumi:"name"`
	// The name of the test suite to which this test case belongs.
	TestSuiteName *string `pulumi:"testSuiteName"`
}

// TestCaseReferenceInput is an input type that accepts TestCaseReferenceArgs and TestCaseReferenceOutput values.
// You can construct a concrete instance of `TestCaseReferenceInput` via:
//
//	TestCaseReferenceArgs{...}
type TestCaseReferenceInput interface {
	pulumi.Input

	ToTestCaseReferenceOutput() TestCaseReferenceOutput
	ToTestCaseReferenceOutputWithContext(context.Context) TestCaseReferenceOutput
}

// A reference to a test case. Test case references are canonically ordered lexicographically by these three factors: * First, by test_suite_name. * Second, by class_name. * Third, by name.
type TestCaseReferenceArgs struct {
	// The name of the class.
	ClassName pulumi.StringPtrInput `pulumi:"className"`
	// The name of the test case. Required.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The name of the test suite to which this test case belongs.
	TestSuiteName pulumi.StringPtrInput `pulumi:"testSuiteName"`
}

func (TestCaseReferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TestCaseReference)(nil)).Elem()
}

func (i TestCaseReferenceArgs) ToTestCaseReferenceOutput() TestCaseReferenceOutput {
	return i.ToTestCaseReferenceOutputWithContext(context.Background())
}

func (i TestCaseReferenceArgs) ToTestCaseReferenceOutputWithContext(ctx context.Context) TestCaseReferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TestCaseReferenceOutput)
}

func (i TestCaseReferenceArgs) ToOutput(ctx context.Context) pulumix.Output[TestCaseReference] {
	return pulumix.Output[TestCaseReference]{
		OutputState: i.ToTestCaseReferenceOutputWithContext(ctx).OutputState,
	}
}

func (i TestCaseReferenceArgs) ToTestCaseReferencePtrOutput() TestCaseReferencePtrOutput {
	return i.ToTestCaseReferencePtrOutputWithContext(context.Background())
}

func (i TestCaseReferenceArgs) ToTestCaseReferencePtrOutputWithContext(ctx context.Context) TestCaseReferencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TestCaseReferenceOutput).ToTestCaseReferencePtrOutputWithContext(ctx)
}

// TestCaseReferencePtrInput is an input type that accepts TestCaseReferenceArgs, TestCaseReferencePtr and TestCaseReferencePtrOutput values.
// You can construct a concrete instance of `TestCaseReferencePtrInput` via:
//
//	        TestCaseReferenceArgs{...}
//
//	or:
//
//	        nil
type TestCaseReferencePtrInput interface {
	pulumi.Input

	ToTestCaseReferencePtrOutput() TestCaseReferencePtrOutput
	ToTestCaseReferencePtrOutputWithContext(context.Context) TestCaseReferencePtrOutput
}

type testCaseReferencePtrType TestCaseReferenceArgs

func TestCaseReferencePtr(v *TestCaseReferenceArgs) TestCaseReferencePtrInput {
	return (*testCaseReferencePtrType)(v)
}

func (*testCaseReferencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TestCaseReference)(nil)).Elem()
}

func (i *testCaseReferencePtrType) ToTestCaseReferencePtrOutput() TestCaseReferencePtrOutput {
	return i.ToTestCaseReferencePtrOutputWithContext(context.Background())
}

func (i *testCaseReferencePtrType) ToTestCaseReferencePtrOutputWithContext(ctx context.Context) TestCaseReferencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TestCaseReferencePtrOutput)
}

func (i *testCaseReferencePtrType) ToOutput(ctx context.Context) pulumix.Output[*TestCaseReference] {
	return pulumix.Output[*TestCaseReference]{
		OutputState: i.ToTestCaseReferencePtrOutputWithContext(ctx).OutputState,
	}
}

// A reference to a test case. Test case references are canonically ordered lexicographically by these three factors: * First, by test_suite_name. * Second, by class_name. * Third, by name.
type TestCaseReferenceOutput struct{ *pulumi.OutputState }

func (TestCaseReferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TestCaseReference)(nil)).Elem()
}

func (o TestCaseReferenceOutput) ToTestCaseReferenceOutput() TestCaseReferenceOutput {
	return o
}

func (o TestCaseReferenceOutput) ToTestCaseReferenceOutputWithContext(ctx context.Context) TestCaseReferenceOutput {
	return o
}

func (o TestCaseReferenceOutput) ToTestCaseReferencePtrOutput() TestCaseReferencePtrOutput {
	return o.ToTestCaseReferencePtrOutputWithContext(context.Background())
}

func (o TestCaseReferenceOutput) ToTestCaseReferencePtrOutputWithContext(ctx context.Context) TestCaseReferencePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TestCaseReference) *TestCaseReference {
		return &v
	}).(TestCaseReferencePtrOutput)
}

func (o TestCaseReferenceOutput) ToOutput(ctx context.Context) pulumix.Output[TestCaseReference] {
	return pulumix.Output[TestCaseReference]{
		OutputState: o.OutputState,
	}
}

// The name of the class.
func (o TestCaseReferenceOutput) ClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TestCaseReference) *string { return v.ClassName }).(pulumi.StringPtrOutput)
}

// The name of the test case. Required.
func (o TestCaseReferenceOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TestCaseReference) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The name of the test suite to which this test case belongs.
func (o TestCaseReferenceOutput) TestSuiteName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TestCaseReference) *string { return v.TestSuiteName }).(pulumi.StringPtrOutput)
}

type TestCaseReferencePtrOutput struct{ *pulumi.OutputState }

func (TestCaseReferencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TestCaseReference)(nil)).Elem()
}

func (o TestCaseReferencePtrOutput) ToTestCaseReferencePtrOutput() TestCaseReferencePtrOutput {
	return o
}

func (o TestCaseReferencePtrOutput) ToTestCaseReferencePtrOutputWithContext(ctx context.Context) TestCaseReferencePtrOutput {
	return o
}

func (o TestCaseReferencePtrOutput) ToOutput(ctx context.Context) pulumix.Output[*TestCaseReference] {
	return pulumix.Output[*TestCaseReference]{
		OutputState: o.OutputState,
	}
}

func (o TestCaseReferencePtrOutput) Elem() TestCaseReferenceOutput {
	return o.ApplyT(func(v *TestCaseReference) TestCaseReference {
		if v != nil {
			return *v
		}
		var ret TestCaseReference
		return ret
	}).(TestCaseReferenceOutput)
}

// The name of the class.
func (o TestCaseReferencePtrOutput) ClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TestCaseReference) *string {
		if v == nil {
			return nil
		}
		return v.ClassName
	}).(pulumi.StringPtrOutput)
}

// The name of the test case. Required.
func (o TestCaseReferencePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TestCaseReference) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// The name of the test suite to which this test case belongs.
func (o TestCaseReferencePtrOutput) TestSuiteName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TestCaseReference) *string {
		if v == nil {
			return nil
		}
		return v.TestSuiteName
	}).(pulumi.StringPtrOutput)
}

// A reference to a test case. Test case references are canonically ordered lexicographically by these three factors: * First, by test_suite_name. * Second, by class_name. * Third, by name.
type TestCaseReferenceResponse struct {
	// The name of the class.
	ClassName string `pulumi:"className"`
	// The name of the test case. Required.
	Name string `pulumi:"name"`
	// The name of the test suite to which this test case belongs.
	TestSuiteName string `pulumi:"testSuiteName"`
}

// A reference to a test case. Test case references are canonically ordered lexicographically by these three factors: * First, by test_suite_name. * Second, by class_name. * Third, by name.
type TestCaseReferenceResponseOutput struct{ *pulumi.OutputState }

func (TestCaseReferenceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TestCaseReferenceResponse)(nil)).Elem()
}

func (o TestCaseReferenceResponseOutput) ToTestCaseReferenceResponseOutput() TestCaseReferenceResponseOutput {
	return o
}

func (o TestCaseReferenceResponseOutput) ToTestCaseReferenceResponseOutputWithContext(ctx context.Context) TestCaseReferenceResponseOutput {
	return o
}

func (o TestCaseReferenceResponseOutput) ToOutput(ctx context.Context) pulumix.Output[TestCaseReferenceResponse] {
	return pulumix.Output[TestCaseReferenceResponse]{
		OutputState: o.OutputState,
	}
}

// The name of the class.
func (o TestCaseReferenceResponseOutput) ClassName() pulumi.StringOutput {
	return o.ApplyT(func(v TestCaseReferenceResponse) string { return v.ClassName }).(pulumi.StringOutput)
}

// The name of the test case. Required.
func (o TestCaseReferenceResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v TestCaseReferenceResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The name of the test suite to which this test case belongs.
func (o TestCaseReferenceResponseOutput) TestSuiteName() pulumi.StringOutput {
	return o.ApplyT(func(v TestCaseReferenceResponse) string { return v.TestSuiteName }).(pulumi.StringOutput)
}

// A step that represents running tests. It accepts ant-junit xml files which will be parsed into structured test results by the service. Xml file paths are updated in order to append more files, however they can't be deleted. Users can also add test results manually by using the test_result field.
type TestExecutionStep struct {
	// Issues observed during the test execution. For example, if the mobile app under test crashed during the test, the error message and the stack trace content can be recorded here to assist debugging. - In response: present if set by create or update - In create/update request: optional
	TestIssues []TestIssue `pulumi:"testIssues"`
	// List of test suite overview contents. This could be parsed from xUnit XML log by server, or uploaded directly by user. This references should only be called when test suites are fully parsed or uploaded. The maximum allowed number of test suite overviews per step is 1000. - In response: always set - In create request: optional - In update request: never (use publishXunitXmlFiles custom method instead)
	TestSuiteOverviews []TestSuiteOverview `pulumi:"testSuiteOverviews"`
	// The timing break down of the test execution. - In response: present if set by create or update - In create/update request: optional
	TestTiming *TestTiming `pulumi:"testTiming"`
	// Represents the execution of the test runner. The exit code of this tool will be used to determine if the test passed. - In response: always set - In create/update request: optional
	ToolExecution *ToolExecution `pulumi:"toolExecution"`
}

// TestExecutionStepInput is an input type that accepts TestExecutionStepArgs and TestExecutionStepOutput values.
// You can construct a concrete instance of `TestExecutionStepInput` via:
//
//	TestExecutionStepArgs{...}
type TestExecutionStepInput interface {
	pulumi.Input

	ToTestExecutionStepOutput() TestExecutionStepOutput
	ToTestExecutionStepOutputWithContext(context.Context) TestExecutionStepOutput
}

// A step that represents running tests. It accepts ant-junit xml files which will be parsed into structured test results by the service. Xml file paths are updated in order to append more files, however they can't be deleted. Users can also add test results manually by using the test_result field.
type TestExecutionStepArgs struct {
	// Issues observed during the test execution. For example, if the mobile app under test crashed during the test, the error message and the stack trace content can be recorded here to assist debugging. - In response: present if set by create or update - In create/update request: optional
	TestIssues TestIssueArrayInput `pulumi:"testIssues"`
	// List of test suite overview contents. This could be parsed from xUnit XML log by server, or uploaded directly by user. This references should only be called when test suites are fully parsed or uploaded. The maximum allowed number of test suite overviews per step is 1000. - In response: always set - In create request: optional - In update request: never (use publishXunitXmlFiles custom method instead)
	TestSuiteOverviews TestSuiteOverviewArrayInput `pulumi:"testSuiteOverviews"`
	// The timing break down of the test execution. - In response: present if set by create or update - In create/update request: optional
	TestTiming TestTimingPtrInput `pulumi:"testTiming"`
	// Represents the execution of the test runner. The exit code of this tool will be used to determine if the test passed. - In response: always set - In create/update request: optional
	ToolExecution ToolExecutionPtrInput `pulumi:"toolExecution"`
}

func (TestExecutionStepArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TestExecutionStep)(nil)).Elem()
}

func (i TestExecutionStepArgs) ToTestExecutionStepOutput() TestExecutionStepOutput {
	return i.ToTestExecutionStepOutputWithContext(context.Background())
}

func (i TestExecutionStepArgs) ToTestExecutionStepOutputWithContext(ctx context.Context) TestExecutionStepOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TestExecutionStepOutput)
}

func (i TestExecutionStepArgs) ToOutput(ctx context.Context) pulumix.Output[TestExecutionStep] {
	return pulumix.Output[TestExecutionStep]{
		OutputState: i.ToTestExecutionStepOutputWithContext(ctx).OutputState,
	}
}

func (i TestExecutionStepArgs) ToTestExecutionStepPtrOutput() TestExecutionStepPtrOutput {
	return i.ToTestExecutionStepPtrOutputWithContext(context.Background())
}

func (i TestExecutionStepArgs) ToTestExecutionStepPtrOutputWithContext(ctx context.Context) TestExecutionStepPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TestExecutionStepOutput).ToTestExecutionStepPtrOutputWithContext(ctx)
}

// TestExecutionStepPtrInput is an input type that accepts TestExecutionStepArgs, TestExecutionStepPtr and TestExecutionStepPtrOutput values.
// You can construct a concrete instance of `TestExecutionStepPtrInput` via:
//
//	        TestExecutionStepArgs{...}
//
//	or:
//
//	        nil
type TestExecutionStepPtrInput interface {
	pulumi.Input

	ToTestExecutionStepPtrOutput() TestExecutionStepPtrOutput
	ToTestExecutionStepPtrOutputWithContext(context.Context) TestExecutionStepPtrOutput
}

type testExecutionStepPtrType TestExecutionStepArgs

func TestExecutionStepPtr(v *TestExecutionStepArgs) TestExecutionStepPtrInput {
	return (*testExecutionStepPtrType)(v)
}

func (*testExecutionStepPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TestExecutionStep)(nil)).Elem()
}

func (i *testExecutionStepPtrType) ToTestExecutionStepPtrOutput() TestExecutionStepPtrOutput {
	return i.ToTestExecutionStepPtrOutputWithContext(context.Background())
}

func (i *testExecutionStepPtrType) ToTestExecutionStepPtrOutputWithContext(ctx context.Context) TestExecutionStepPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TestExecutionStepPtrOutput)
}

func (i *testExecutionStepPtrType) ToOutput(ctx context.Context) pulumix.Output[*TestExecutionStep] {
	return pulumix.Output[*TestExecutionStep]{
		OutputState: i.ToTestExecutionStepPtrOutputWithContext(ctx).OutputState,
	}
}

// A step that represents running tests. It accepts ant-junit xml files which will be parsed into structured test results by the service. Xml file paths are updated in order to append more files, however they can't be deleted. Users can also add test results manually by using the test_result field.
type TestExecutionStepOutput struct{ *pulumi.OutputState }

func (TestExecutionStepOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TestExecutionStep)(nil)).Elem()
}

func (o TestExecutionStepOutput) ToTestExecutionStepOutput() TestExecutionStepOutput {
	return o
}

func (o TestExecutionStepOutput) ToTestExecutionStepOutputWithContext(ctx context.Context) TestExecutionStepOutput {
	return o
}

func (o TestExecutionStepOutput) ToTestExecutionStepPtrOutput() TestExecutionStepPtrOutput {
	return o.ToTestExecutionStepPtrOutputWithContext(context.Background())
}

func (o TestExecutionStepOutput) ToTestExecutionStepPtrOutputWithContext(ctx context.Context) TestExecutionStepPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TestExecutionStep) *TestExecutionStep {
		return &v
	}).(TestExecutionStepPtrOutput)
}

func (o TestExecutionStepOutput) ToOutput(ctx context.Context) pulumix.Output[TestExecutionStep] {
	return pulumix.Output[TestExecutionStep]{
		OutputState: o.OutputState,
	}
}

// Issues observed during the test execution. For example, if the mobile app under test crashed during the test, the error message and the stack trace content can be recorded here to assist debugging. - In response: present if set by create or update - In create/update request: optional
func (o TestExecutionStepOutput) TestIssues() TestIssueArrayOutput {
	return o.ApplyT(func(v TestExecutionStep) []TestIssue { return v.TestIssues }).(TestIssueArrayOutput)
}

// List of test suite overview contents. This could be parsed from xUnit XML log by server, or uploaded directly by user. This references should only be called when test suites are fully parsed or uploaded. The maximum allowed number of test suite overviews per step is 1000. - In response: always set - In create request: optional - In update request: never (use publishXunitXmlFiles custom method instead)
func (o TestExecutionStepOutput) TestSuiteOverviews() TestSuiteOverviewArrayOutput {
	return o.ApplyT(func(v TestExecutionStep) []TestSuiteOverview { return v.TestSuiteOverviews }).(TestSuiteOverviewArrayOutput)
}

// The timing break down of the test execution. - In response: present if set by create or update - In create/update request: optional
func (o TestExecutionStepOutput) TestTiming() TestTimingPtrOutput {
	return o.ApplyT(func(v TestExecutionStep) *TestTiming { return v.TestTiming }).(TestTimingPtrOutput)
}

// Represents the execution of the test runner. The exit code of this tool will be used to determine if the test passed. - In response: always set - In create/update request: optional
func (o TestExecutionStepOutput) ToolExecution() ToolExecutionPtrOutput {
	return o.ApplyT(func(v TestExecutionStep) *ToolExecution { return v.ToolExecution }).(ToolExecutionPtrOutput)
}

type TestExecutionStepPtrOutput struct{ *pulumi.OutputState }

func (TestExecutionStepPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TestExecutionStep)(nil)).Elem()
}

func (o TestExecutionStepPtrOutput) ToTestExecutionStepPtrOutput() TestExecutionStepPtrOutput {
	return o
}

func (o TestExecutionStepPtrOutput) ToTestExecutionStepPtrOutputWithContext(ctx context.Context) TestExecutionStepPtrOutput {
	return o
}

func (o TestExecutionStepPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*TestExecutionStep] {
	return pulumix.Output[*TestExecutionStep]{
		OutputState: o.OutputState,
	}
}

func (o TestExecutionStepPtrOutput) Elem() TestExecutionStepOutput {
	return o.ApplyT(func(v *TestExecutionStep) TestExecutionStep {
		if v != nil {
			return *v
		}
		var ret TestExecutionStep
		return ret
	}).(TestExecutionStepOutput)
}

// Issues observed during the test execution. For example, if the mobile app under test crashed during the test, the error message and the stack trace content can be recorded here to assist debugging. - In response: present if set by create or update - In create/update request: optional
func (o TestExecutionStepPtrOutput) TestIssues() TestIssueArrayOutput {
	return o.ApplyT(func(v *TestExecutionStep) []TestIssue {
		if v == nil {
			return nil
		}
		return v.TestIssues
	}).(TestIssueArrayOutput)
}

// List of test suite overview contents. This could be parsed from xUnit XML log by server, or uploaded directly by user. This references should only be called when test suites are fully parsed or uploaded. The maximum allowed number of test suite overviews per step is 1000. - In response: always set - In create request: optional - In update request: never (use publishXunitXmlFiles custom method instead)
func (o TestExecutionStepPtrOutput) TestSuiteOverviews() TestSuiteOverviewArrayOutput {
	return o.ApplyT(func(v *TestExecutionStep) []TestSuiteOverview {
		if v == nil {
			return nil
		}
		return v.TestSuiteOverviews
	}).(TestSuiteOverviewArrayOutput)
}

// The timing break down of the test execution. - In response: present if set by create or update - In create/update request: optional
func (o TestExecutionStepPtrOutput) TestTiming() TestTimingPtrOutput {
	return o.ApplyT(func(v *TestExecutionStep) *TestTiming {
		if v == nil {
			return nil
		}
		return v.TestTiming
	}).(TestTimingPtrOutput)
}

// Represents the execution of the test runner. The exit code of this tool will be used to determine if the test passed. - In response: always set - In create/update request: optional
func (o TestExecutionStepPtrOutput) ToolExecution() ToolExecutionPtrOutput {
	return o.ApplyT(func(v *TestExecutionStep) *ToolExecution {
		if v == nil {
			return nil
		}
		return v.ToolExecution
	}).(ToolExecutionPtrOutput)
}

// A step that represents running tests. It accepts ant-junit xml files which will be parsed into structured test results by the service. Xml file paths are updated in order to append more files, however they can't be deleted. Users can also add test results manually by using the test_result field.
type TestExecutionStepResponse struct {
	// Issues observed during the test execution. For example, if the mobile app under test crashed during the test, the error message and the stack trace content can be recorded here to assist debugging. - In response: present if set by create or update - In create/update request: optional
	TestIssues []TestIssueResponse `pulumi:"testIssues"`
	// List of test suite overview contents. This could be parsed from xUnit XML log by server, or uploaded directly by user. This references should only be called when test suites are fully parsed or uploaded. The maximum allowed number of test suite overviews per step is 1000. - In response: always set - In create request: optional - In update request: never (use publishXunitXmlFiles custom method instead)
	TestSuiteOverviews []TestSuiteOverviewResponse `pulumi:"testSuiteOverviews"`
	// The timing break down of the test execution. - In response: present if set by create or update - In create/update request: optional
	TestTiming TestTimingResponse `pulumi:"testTiming"`
	// Represents the execution of the test runner. The exit code of this tool will be used to determine if the test passed. - In response: always set - In create/update request: optional
	ToolExecution ToolExecutionResponse `pulumi:"toolExecution"`
}

// A step that represents running tests. It accepts ant-junit xml files which will be parsed into structured test results by the service. Xml file paths are updated in order to append more files, however they can't be deleted. Users can also add test results manually by using the test_result field.
type TestExecutionStepResponseOutput struct{ *pulumi.OutputState }

func (TestExecutionStepResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TestExecutionStepResponse)(nil)).Elem()
}

func (o TestExecutionStepResponseOutput) ToTestExecutionStepResponseOutput() TestExecutionStepResponseOutput {
	return o
}

func (o TestExecutionStepResponseOutput) ToTestExecutionStepResponseOutputWithContext(ctx context.Context) TestExecutionStepResponseOutput {
	return o
}

func (o TestExecutionStepResponseOutput) ToOutput(ctx context.Context) pulumix.Output[TestExecutionStepResponse] {
	return pulumix.Output[TestExecutionStepResponse]{
		OutputState: o.OutputState,
	}
}

// Issues observed during the test execution. For example, if the mobile app under test crashed during the test, the error message and the stack trace content can be recorded here to assist debugging. - In response: present if set by create or update - In create/update request: optional
func (o TestExecutionStepResponseOutput) TestIssues() TestIssueResponseArrayOutput {
	return o.ApplyT(func(v TestExecutionStepResponse) []TestIssueResponse { return v.TestIssues }).(TestIssueResponseArrayOutput)
}

// List of test suite overview contents. This could be parsed from xUnit XML log by server, or uploaded directly by user. This references should only be called when test suites are fully parsed or uploaded. The maximum allowed number of test suite overviews per step is 1000. - In response: always set - In create request: optional - In update request: never (use publishXunitXmlFiles custom method instead)
func (o TestExecutionStepResponseOutput) TestSuiteOverviews() TestSuiteOverviewResponseArrayOutput {
	return o.ApplyT(func(v TestExecutionStepResponse) []TestSuiteOverviewResponse { return v.TestSuiteOverviews }).(TestSuiteOverviewResponseArrayOutput)
}

// The timing break down of the test execution. - In response: present if set by create or update - In create/update request: optional
func (o TestExecutionStepResponseOutput) TestTiming() TestTimingResponseOutput {
	return o.ApplyT(func(v TestExecutionStepResponse) TestTimingResponse { return v.TestTiming }).(TestTimingResponseOutput)
}

// Represents the execution of the test runner. The exit code of this tool will be used to determine if the test passed. - In response: always set - In create/update request: optional
func (o TestExecutionStepResponseOutput) ToolExecution() ToolExecutionResponseOutput {
	return o.ApplyT(func(v TestExecutionStepResponse) ToolExecutionResponse { return v.ToolExecution }).(ToolExecutionResponseOutput)
}

// An issue detected occurring during a test execution.
type TestIssue struct {
	// Category of issue. Required.
	Category *TestIssueCategory `pulumi:"category"`
	// A brief human-readable message describing the issue. Required.
	ErrorMessage *string `pulumi:"errorMessage"`
	// Severity of issue. Required.
	Severity *TestIssueSeverity `pulumi:"severity"`
	// Deprecated in favor of stack trace fields inside specific warnings.
	//
	// Deprecated: Deprecated in favor of stack trace fields inside specific warnings.
	StackTrace *StackTrace `pulumi:"stackTrace"`
	// Type of issue. Required.
	Type *TestIssueType `pulumi:"type"`
	// Warning message with additional details of the issue. Should always be a message from com.google.devtools.toolresults.v1.warnings
	Warning *Any `pulumi:"warning"`
}

// TestIssueInput is an input type that accepts TestIssueArgs and TestIssueOutput values.
// You can construct a concrete instance of `TestIssueInput` via:
//
//	TestIssueArgs{...}
type TestIssueInput interface {
	pulumi.Input

	ToTestIssueOutput() TestIssueOutput
	ToTestIssueOutputWithContext(context.Context) TestIssueOutput
}

// An issue detected occurring during a test execution.
type TestIssueArgs struct {
	// Category of issue. Required.
	Category TestIssueCategoryPtrInput `pulumi:"category"`
	// A brief human-readable message describing the issue. Required.
	ErrorMessage pulumi.StringPtrInput `pulumi:"errorMessage"`
	// Severity of issue. Required.
	Severity TestIssueSeverityPtrInput `pulumi:"severity"`
	// Deprecated in favor of stack trace fields inside specific warnings.
	//
	// Deprecated: Deprecated in favor of stack trace fields inside specific warnings.
	StackTrace StackTracePtrInput `pulumi:"stackTrace"`
	// Type of issue. Required.
	Type TestIssueTypePtrInput `pulumi:"type"`
	// Warning message with additional details of the issue. Should always be a message from com.google.devtools.toolresults.v1.warnings
	Warning AnyPtrInput `pulumi:"warning"`
}

func (TestIssueArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TestIssue)(nil)).Elem()
}

func (i TestIssueArgs) ToTestIssueOutput() TestIssueOutput {
	return i.ToTestIssueOutputWithContext(context.Background())
}

func (i TestIssueArgs) ToTestIssueOutputWithContext(ctx context.Context) TestIssueOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TestIssueOutput)
}

func (i TestIssueArgs) ToOutput(ctx context.Context) pulumix.Output[TestIssue] {
	return pulumix.Output[TestIssue]{
		OutputState: i.ToTestIssueOutputWithContext(ctx).OutputState,
	}
}

// TestIssueArrayInput is an input type that accepts TestIssueArray and TestIssueArrayOutput values.
// You can construct a concrete instance of `TestIssueArrayInput` via:
//
//	TestIssueArray{ TestIssueArgs{...} }
type TestIssueArrayInput interface {
	pulumi.Input

	ToTestIssueArrayOutput() TestIssueArrayOutput
	ToTestIssueArrayOutputWithContext(context.Context) TestIssueArrayOutput
}

type TestIssueArray []TestIssueInput

func (TestIssueArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TestIssue)(nil)).Elem()
}

func (i TestIssueArray) ToTestIssueArrayOutput() TestIssueArrayOutput {
	return i.ToTestIssueArrayOutputWithContext(context.Background())
}

func (i TestIssueArray) ToTestIssueArrayOutputWithContext(ctx context.Context) TestIssueArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TestIssueArrayOutput)
}

func (i TestIssueArray) ToOutput(ctx context.Context) pulumix.Output[[]TestIssue] {
	return pulumix.Output[[]TestIssue]{
		OutputState: i.ToTestIssueArrayOutputWithContext(ctx).OutputState,
	}
}

// An issue detected occurring during a test execution.
type TestIssueOutput struct{ *pulumi.OutputState }

func (TestIssueOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TestIssue)(nil)).Elem()
}

func (o TestIssueOutput) ToTestIssueOutput() TestIssueOutput {
	return o
}

func (o TestIssueOutput) ToTestIssueOutputWithContext(ctx context.Context) TestIssueOutput {
	return o
}

func (o TestIssueOutput) ToOutput(ctx context.Context) pulumix.Output[TestIssue] {
	return pulumix.Output[TestIssue]{
		OutputState: o.OutputState,
	}
}

// Category of issue. Required.
func (o TestIssueOutput) Category() TestIssueCategoryPtrOutput {
	return o.ApplyT(func(v TestIssue) *TestIssueCategory { return v.Category }).(TestIssueCategoryPtrOutput)
}

// A brief human-readable message describing the issue. Required.
func (o TestIssueOutput) ErrorMessage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TestIssue) *string { return v.ErrorMessage }).(pulumi.StringPtrOutput)
}

// Severity of issue. Required.
func (o TestIssueOutput) Severity() TestIssueSeverityPtrOutput {
	return o.ApplyT(func(v TestIssue) *TestIssueSeverity { return v.Severity }).(TestIssueSeverityPtrOutput)
}

// Deprecated in favor of stack trace fields inside specific warnings.
//
// Deprecated: Deprecated in favor of stack trace fields inside specific warnings.
func (o TestIssueOutput) StackTrace() StackTracePtrOutput {
	return o.ApplyT(func(v TestIssue) *StackTrace { return v.StackTrace }).(StackTracePtrOutput)
}

// Type of issue. Required.
func (o TestIssueOutput) Type() TestIssueTypePtrOutput {
	return o.ApplyT(func(v TestIssue) *TestIssueType { return v.Type }).(TestIssueTypePtrOutput)
}

// Warning message with additional details of the issue. Should always be a message from com.google.devtools.toolresults.v1.warnings
func (o TestIssueOutput) Warning() AnyPtrOutput {
	return o.ApplyT(func(v TestIssue) *Any { return v.Warning }).(AnyPtrOutput)
}

type TestIssueArrayOutput struct{ *pulumi.OutputState }

func (TestIssueArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TestIssue)(nil)).Elem()
}

func (o TestIssueArrayOutput) ToTestIssueArrayOutput() TestIssueArrayOutput {
	return o
}

func (o TestIssueArrayOutput) ToTestIssueArrayOutputWithContext(ctx context.Context) TestIssueArrayOutput {
	return o
}

func (o TestIssueArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]TestIssue] {
	return pulumix.Output[[]TestIssue]{
		OutputState: o.OutputState,
	}
}

func (o TestIssueArrayOutput) Index(i pulumi.IntInput) TestIssueOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TestIssue {
		return vs[0].([]TestIssue)[vs[1].(int)]
	}).(TestIssueOutput)
}

// An issue detected occurring during a test execution.
type TestIssueResponse struct {
	// Category of issue. Required.
	Category string `pulumi:"category"`
	// A brief human-readable message describing the issue. Required.
	ErrorMessage string `pulumi:"errorMessage"`
	// Severity of issue. Required.
	Severity string `pulumi:"severity"`
	// Deprecated in favor of stack trace fields inside specific warnings.
	//
	// Deprecated: Deprecated in favor of stack trace fields inside specific warnings.
	StackTrace StackTraceResponse `pulumi:"stackTrace"`
	// Type of issue. Required.
	Type string `pulumi:"type"`
	// Warning message with additional details of the issue. Should always be a message from com.google.devtools.toolresults.v1.warnings
	Warning AnyResponse `pulumi:"warning"`
}

// An issue detected occurring during a test execution.
type TestIssueResponseOutput struct{ *pulumi.OutputState }

func (TestIssueResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TestIssueResponse)(nil)).Elem()
}

func (o TestIssueResponseOutput) ToTestIssueResponseOutput() TestIssueResponseOutput {
	return o
}

func (o TestIssueResponseOutput) ToTestIssueResponseOutputWithContext(ctx context.Context) TestIssueResponseOutput {
	return o
}

func (o TestIssueResponseOutput) ToOutput(ctx context.Context) pulumix.Output[TestIssueResponse] {
	return pulumix.Output[TestIssueResponse]{
		OutputState: o.OutputState,
	}
}

// Category of issue. Required.
func (o TestIssueResponseOutput) Category() pulumi.StringOutput {
	return o.ApplyT(func(v TestIssueResponse) string { return v.Category }).(pulumi.StringOutput)
}

// A brief human-readable message describing the issue. Required.
func (o TestIssueResponseOutput) ErrorMessage() pulumi.StringOutput {
	return o.ApplyT(func(v TestIssueResponse) string { return v.ErrorMessage }).(pulumi.StringOutput)
}

// Severity of issue. Required.
func (o TestIssueResponseOutput) Severity() pulumi.StringOutput {
	return o.ApplyT(func(v TestIssueResponse) string { return v.Severity }).(pulumi.StringOutput)
}

// Deprecated in favor of stack trace fields inside specific warnings.
//
// Deprecated: Deprecated in favor of stack trace fields inside specific warnings.
func (o TestIssueResponseOutput) StackTrace() StackTraceResponseOutput {
	return o.ApplyT(func(v TestIssueResponse) StackTraceResponse { return v.StackTrace }).(StackTraceResponseOutput)
}

// Type of issue. Required.
func (o TestIssueResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v TestIssueResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Warning message with additional details of the issue. Should always be a message from com.google.devtools.toolresults.v1.warnings
func (o TestIssueResponseOutput) Warning() AnyResponseOutput {
	return o.ApplyT(func(v TestIssueResponse) AnyResponse { return v.Warning }).(AnyResponseOutput)
}

type TestIssueResponseArrayOutput struct{ *pulumi.OutputState }

func (TestIssueResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TestIssueResponse)(nil)).Elem()
}

func (o TestIssueResponseArrayOutput) ToTestIssueResponseArrayOutput() TestIssueResponseArrayOutput {
	return o
}

func (o TestIssueResponseArrayOutput) ToTestIssueResponseArrayOutputWithContext(ctx context.Context) TestIssueResponseArrayOutput {
	return o
}

func (o TestIssueResponseArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]TestIssueResponse] {
	return pulumix.Output[[]TestIssueResponse]{
		OutputState: o.OutputState,
	}
}

func (o TestIssueResponseArrayOutput) Index(i pulumi.IntInput) TestIssueResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TestIssueResponse {
		return vs[0].([]TestIssueResponse)[vs[1].(int)]
	}).(TestIssueResponseOutput)
}

// A summary of a test suite result either parsed from XML or uploaded directly by a user. Note: the API related comments are for StepService only. This message is also being used in ExecutionService in a read only mode for the corresponding step.
type TestSuiteOverview struct {
	// Elapsed time of test suite.
	ElapsedTime *Duration `pulumi:"elapsedTime"`
	// Number of test cases in error, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
	ErrorCount *int `pulumi:"errorCount"`
	// Number of failed test cases, typically set by the service by parsing the xml_source. May also be set by the user. - In create/response: always set - In update request: never
	FailureCount *int `pulumi:"failureCount"`
	// Number of flaky test cases, set by the service by rolling up flaky test attempts. Present only for rollup test suite overview at environment level. A step cannot have flaky test cases.
	FlakyCount *int `pulumi:"flakyCount"`
	// The name of the test suite. - In create/response: always set - In update request: never
	Name *string `pulumi:"name"`
	// Number of test cases not run, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
	SkippedCount *int `pulumi:"skippedCount"`
	// Number of test cases, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
	TotalCount *int `pulumi:"totalCount"`
	// If this test suite was parsed from XML, this is the URI where the original XML file is stored. Note: Multiple test suites can share the same xml_source Returns INVALID_ARGUMENT if the uri format is not supported. - In create/response: optional - In update request: never
	XmlSource *FileReference `pulumi:"xmlSource"`
}

// TestSuiteOverviewInput is an input type that accepts TestSuiteOverviewArgs and TestSuiteOverviewOutput values.
// You can construct a concrete instance of `TestSuiteOverviewInput` via:
//
//	TestSuiteOverviewArgs{...}
type TestSuiteOverviewInput interface {
	pulumi.Input

	ToTestSuiteOverviewOutput() TestSuiteOverviewOutput
	ToTestSuiteOverviewOutputWithContext(context.Context) TestSuiteOverviewOutput
}

// A summary of a test suite result either parsed from XML or uploaded directly by a user. Note: the API related comments are for StepService only. This message is also being used in ExecutionService in a read only mode for the corresponding step.
type TestSuiteOverviewArgs struct {
	// Elapsed time of test suite.
	ElapsedTime DurationPtrInput `pulumi:"elapsedTime"`
	// Number of test cases in error, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
	ErrorCount pulumi.IntPtrInput `pulumi:"errorCount"`
	// Number of failed test cases, typically set by the service by parsing the xml_source. May also be set by the user. - In create/response: always set - In update request: never
	FailureCount pulumi.IntPtrInput `pulumi:"failureCount"`
	// Number of flaky test cases, set by the service by rolling up flaky test attempts. Present only for rollup test suite overview at environment level. A step cannot have flaky test cases.
	FlakyCount pulumi.IntPtrInput `pulumi:"flakyCount"`
	// The name of the test suite. - In create/response: always set - In update request: never
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Number of test cases not run, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
	SkippedCount pulumi.IntPtrInput `pulumi:"skippedCount"`
	// Number of test cases, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
	TotalCount pulumi.IntPtrInput `pulumi:"totalCount"`
	// If this test suite was parsed from XML, this is the URI where the original XML file is stored. Note: Multiple test suites can share the same xml_source Returns INVALID_ARGUMENT if the uri format is not supported. - In create/response: optional - In update request: never
	XmlSource FileReferencePtrInput `pulumi:"xmlSource"`
}

func (TestSuiteOverviewArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TestSuiteOverview)(nil)).Elem()
}

func (i TestSuiteOverviewArgs) ToTestSuiteOverviewOutput() TestSuiteOverviewOutput {
	return i.ToTestSuiteOverviewOutputWithContext(context.Background())
}

func (i TestSuiteOverviewArgs) ToTestSuiteOverviewOutputWithContext(ctx context.Context) TestSuiteOverviewOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TestSuiteOverviewOutput)
}

func (i TestSuiteOverviewArgs) ToOutput(ctx context.Context) pulumix.Output[TestSuiteOverview] {
	return pulumix.Output[TestSuiteOverview]{
		OutputState: i.ToTestSuiteOverviewOutputWithContext(ctx).OutputState,
	}
}

// TestSuiteOverviewArrayInput is an input type that accepts TestSuiteOverviewArray and TestSuiteOverviewArrayOutput values.
// You can construct a concrete instance of `TestSuiteOverviewArrayInput` via:
//
//	TestSuiteOverviewArray{ TestSuiteOverviewArgs{...} }
type TestSuiteOverviewArrayInput interface {
	pulumi.Input

	ToTestSuiteOverviewArrayOutput() TestSuiteOverviewArrayOutput
	ToTestSuiteOverviewArrayOutputWithContext(context.Context) TestSuiteOverviewArrayOutput
}

type TestSuiteOverviewArray []TestSuiteOverviewInput

func (TestSuiteOverviewArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TestSuiteOverview)(nil)).Elem()
}

func (i TestSuiteOverviewArray) ToTestSuiteOverviewArrayOutput() TestSuiteOverviewArrayOutput {
	return i.ToTestSuiteOverviewArrayOutputWithContext(context.Background())
}

func (i TestSuiteOverviewArray) ToTestSuiteOverviewArrayOutputWithContext(ctx context.Context) TestSuiteOverviewArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TestSuiteOverviewArrayOutput)
}

func (i TestSuiteOverviewArray) ToOutput(ctx context.Context) pulumix.Output[[]TestSuiteOverview] {
	return pulumix.Output[[]TestSuiteOverview]{
		OutputState: i.ToTestSuiteOverviewArrayOutputWithContext(ctx).OutputState,
	}
}

// A summary of a test suite result either parsed from XML or uploaded directly by a user. Note: the API related comments are for StepService only. This message is also being used in ExecutionService in a read only mode for the corresponding step.
type TestSuiteOverviewOutput struct{ *pulumi.OutputState }

func (TestSuiteOverviewOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TestSuiteOverview)(nil)).Elem()
}

func (o TestSuiteOverviewOutput) ToTestSuiteOverviewOutput() TestSuiteOverviewOutput {
	return o
}

func (o TestSuiteOverviewOutput) ToTestSuiteOverviewOutputWithContext(ctx context.Context) TestSuiteOverviewOutput {
	return o
}

func (o TestSuiteOverviewOutput) ToOutput(ctx context.Context) pulumix.Output[TestSuiteOverview] {
	return pulumix.Output[TestSuiteOverview]{
		OutputState: o.OutputState,
	}
}

// Elapsed time of test suite.
func (o TestSuiteOverviewOutput) ElapsedTime() DurationPtrOutput {
	return o.ApplyT(func(v TestSuiteOverview) *Duration { return v.ElapsedTime }).(DurationPtrOutput)
}

// Number of test cases in error, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
func (o TestSuiteOverviewOutput) ErrorCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TestSuiteOverview) *int { return v.ErrorCount }).(pulumi.IntPtrOutput)
}

// Number of failed test cases, typically set by the service by parsing the xml_source. May also be set by the user. - In create/response: always set - In update request: never
func (o TestSuiteOverviewOutput) FailureCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TestSuiteOverview) *int { return v.FailureCount }).(pulumi.IntPtrOutput)
}

// Number of flaky test cases, set by the service by rolling up flaky test attempts. Present only for rollup test suite overview at environment level. A step cannot have flaky test cases.
func (o TestSuiteOverviewOutput) FlakyCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TestSuiteOverview) *int { return v.FlakyCount }).(pulumi.IntPtrOutput)
}

// The name of the test suite. - In create/response: always set - In update request: never
func (o TestSuiteOverviewOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TestSuiteOverview) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Number of test cases not run, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
func (o TestSuiteOverviewOutput) SkippedCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TestSuiteOverview) *int { return v.SkippedCount }).(pulumi.IntPtrOutput)
}

// Number of test cases, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
func (o TestSuiteOverviewOutput) TotalCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TestSuiteOverview) *int { return v.TotalCount }).(pulumi.IntPtrOutput)
}

// If this test suite was parsed from XML, this is the URI where the original XML file is stored. Note: Multiple test suites can share the same xml_source Returns INVALID_ARGUMENT if the uri format is not supported. - In create/response: optional - In update request: never
func (o TestSuiteOverviewOutput) XmlSource() FileReferencePtrOutput {
	return o.ApplyT(func(v TestSuiteOverview) *FileReference { return v.XmlSource }).(FileReferencePtrOutput)
}

type TestSuiteOverviewArrayOutput struct{ *pulumi.OutputState }

func (TestSuiteOverviewArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TestSuiteOverview)(nil)).Elem()
}

func (o TestSuiteOverviewArrayOutput) ToTestSuiteOverviewArrayOutput() TestSuiteOverviewArrayOutput {
	return o
}

func (o TestSuiteOverviewArrayOutput) ToTestSuiteOverviewArrayOutputWithContext(ctx context.Context) TestSuiteOverviewArrayOutput {
	return o
}

func (o TestSuiteOverviewArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]TestSuiteOverview] {
	return pulumix.Output[[]TestSuiteOverview]{
		OutputState: o.OutputState,
	}
}

func (o TestSuiteOverviewArrayOutput) Index(i pulumi.IntInput) TestSuiteOverviewOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TestSuiteOverview {
		return vs[0].([]TestSuiteOverview)[vs[1].(int)]
	}).(TestSuiteOverviewOutput)
}

// A summary of a test suite result either parsed from XML or uploaded directly by a user. Note: the API related comments are for StepService only. This message is also being used in ExecutionService in a read only mode for the corresponding step.
type TestSuiteOverviewResponse struct {
	// Elapsed time of test suite.
	ElapsedTime DurationResponse `pulumi:"elapsedTime"`
	// Number of test cases in error, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
	ErrorCount int `pulumi:"errorCount"`
	// Number of failed test cases, typically set by the service by parsing the xml_source. May also be set by the user. - In create/response: always set - In update request: never
	FailureCount int `pulumi:"failureCount"`
	// Number of flaky test cases, set by the service by rolling up flaky test attempts. Present only for rollup test suite overview at environment level. A step cannot have flaky test cases.
	FlakyCount int `pulumi:"flakyCount"`
	// The name of the test suite. - In create/response: always set - In update request: never
	Name string `pulumi:"name"`
	// Number of test cases not run, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
	SkippedCount int `pulumi:"skippedCount"`
	// Number of test cases, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
	TotalCount int `pulumi:"totalCount"`
	// If this test suite was parsed from XML, this is the URI where the original XML file is stored. Note: Multiple test suites can share the same xml_source Returns INVALID_ARGUMENT if the uri format is not supported. - In create/response: optional - In update request: never
	XmlSource FileReferenceResponse `pulumi:"xmlSource"`
}

// A summary of a test suite result either parsed from XML or uploaded directly by a user. Note: the API related comments are for StepService only. This message is also being used in ExecutionService in a read only mode for the corresponding step.
type TestSuiteOverviewResponseOutput struct{ *pulumi.OutputState }

func (TestSuiteOverviewResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TestSuiteOverviewResponse)(nil)).Elem()
}

func (o TestSuiteOverviewResponseOutput) ToTestSuiteOverviewResponseOutput() TestSuiteOverviewResponseOutput {
	return o
}

func (o TestSuiteOverviewResponseOutput) ToTestSuiteOverviewResponseOutputWithContext(ctx context.Context) TestSuiteOverviewResponseOutput {
	return o
}

func (o TestSuiteOverviewResponseOutput) ToOutput(ctx context.Context) pulumix.Output[TestSuiteOverviewResponse] {
	return pulumix.Output[TestSuiteOverviewResponse]{
		OutputState: o.OutputState,
	}
}

// Elapsed time of test suite.
func (o TestSuiteOverviewResponseOutput) ElapsedTime() DurationResponseOutput {
	return o.ApplyT(func(v TestSuiteOverviewResponse) DurationResponse { return v.ElapsedTime }).(DurationResponseOutput)
}

// Number of test cases in error, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
func (o TestSuiteOverviewResponseOutput) ErrorCount() pulumi.IntOutput {
	return o.ApplyT(func(v TestSuiteOverviewResponse) int { return v.ErrorCount }).(pulumi.IntOutput)
}

// Number of failed test cases, typically set by the service by parsing the xml_source. May also be set by the user. - In create/response: always set - In update request: never
func (o TestSuiteOverviewResponseOutput) FailureCount() pulumi.IntOutput {
	return o.ApplyT(func(v TestSuiteOverviewResponse) int { return v.FailureCount }).(pulumi.IntOutput)
}

// Number of flaky test cases, set by the service by rolling up flaky test attempts. Present only for rollup test suite overview at environment level. A step cannot have flaky test cases.
func (o TestSuiteOverviewResponseOutput) FlakyCount() pulumi.IntOutput {
	return o.ApplyT(func(v TestSuiteOverviewResponse) int { return v.FlakyCount }).(pulumi.IntOutput)
}

// The name of the test suite. - In create/response: always set - In update request: never
func (o TestSuiteOverviewResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v TestSuiteOverviewResponse) string { return v.Name }).(pulumi.StringOutput)
}

// Number of test cases not run, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
func (o TestSuiteOverviewResponseOutput) SkippedCount() pulumi.IntOutput {
	return o.ApplyT(func(v TestSuiteOverviewResponse) int { return v.SkippedCount }).(pulumi.IntOutput)
}

// Number of test cases, typically set by the service by parsing the xml_source. - In create/response: always set - In update request: never
func (o TestSuiteOverviewResponseOutput) TotalCount() pulumi.IntOutput {
	return o.ApplyT(func(v TestSuiteOverviewResponse) int { return v.TotalCount }).(pulumi.IntOutput)
}

// If this test suite was parsed from XML, this is the URI where the original XML file is stored. Note: Multiple test suites can share the same xml_source Returns INVALID_ARGUMENT if the uri format is not supported. - In create/response: optional - In update request: never
func (o TestSuiteOverviewResponseOutput) XmlSource() FileReferenceResponseOutput {
	return o.ApplyT(func(v TestSuiteOverviewResponse) FileReferenceResponse { return v.XmlSource }).(FileReferenceResponseOutput)
}

type TestSuiteOverviewResponseArrayOutput struct{ *pulumi.OutputState }

func (TestSuiteOverviewResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TestSuiteOverviewResponse)(nil)).Elem()
}

func (o TestSuiteOverviewResponseArrayOutput) ToTestSuiteOverviewResponseArrayOutput() TestSuiteOverviewResponseArrayOutput {
	return o
}

func (o TestSuiteOverviewResponseArrayOutput) ToTestSuiteOverviewResponseArrayOutputWithContext(ctx context.Context) TestSuiteOverviewResponseArrayOutput {
	return o
}

func (o TestSuiteOverviewResponseArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]TestSuiteOverviewResponse] {
	return pulumix.Output[[]TestSuiteOverviewResponse]{
		OutputState: o.OutputState,
	}
}

func (o TestSuiteOverviewResponseArrayOutput) Index(i pulumi.IntInput) TestSuiteOverviewResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TestSuiteOverviewResponse {
		return vs[0].([]TestSuiteOverviewResponse)[vs[1].(int)]
	}).(TestSuiteOverviewResponseOutput)
}

// Testing timing break down to know phases.
type TestTiming struct {
	// How long it took to run the test process. - In response: present if previously set. - In create/update request: optional
	TestProcessDuration *Duration `pulumi:"testProcessDuration"`
}

// TestTimingInput is an input type that accepts TestTimingArgs and TestTimingOutput values.
// You can construct a concrete instance of `TestTimingInput` via:
//
//	TestTimingArgs{...}
type TestTimingInput interface {
	pulumi.Input

	ToTestTimingOutput() TestTimingOutput
	ToTestTimingOutputWithContext(context.Context) TestTimingOutput
}

// Testing timing break down to know phases.
type TestTimingArgs struct {
	// How long it took to run the test process. - In response: present if previously set. - In create/update request: optional
	TestProcessDuration DurationPtrInput `pulumi:"testProcessDuration"`
}

func (TestTimingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TestTiming)(nil)).Elem()
}

func (i TestTimingArgs) ToTestTimingOutput() TestTimingOutput {
	return i.ToTestTimingOutputWithContext(context.Background())
}

func (i TestTimingArgs) ToTestTimingOutputWithContext(ctx context.Context) TestTimingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TestTimingOutput)
}

func (i TestTimingArgs) ToOutput(ctx context.Context) pulumix.Output[TestTiming] {
	return pulumix.Output[TestTiming]{
		OutputState: i.ToTestTimingOutputWithContext(ctx).OutputState,
	}
}

func (i TestTimingArgs) ToTestTimingPtrOutput() TestTimingPtrOutput {
	return i.ToTestTimingPtrOutputWithContext(context.Background())
}

func (i TestTimingArgs) ToTestTimingPtrOutputWithContext(ctx context.Context) TestTimingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TestTimingOutput).ToTestTimingPtrOutputWithContext(ctx)
}

// TestTimingPtrInput is an input type that accepts TestTimingArgs, TestTimingPtr and TestTimingPtrOutput values.
// You can construct a concrete instance of `TestTimingPtrInput` via:
//
//	        TestTimingArgs{...}
//
//	or:
//
//	        nil
type TestTimingPtrInput interface {
	pulumi.Input

	ToTestTimingPtrOutput() TestTimingPtrOutput
	ToTestTimingPtrOutputWithContext(context.Context) TestTimingPtrOutput
}

type testTimingPtrType TestTimingArgs

func TestTimingPtr(v *TestTimingArgs) TestTimingPtrInput {
	return (*testTimingPtrType)(v)
}

func (*testTimingPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TestTiming)(nil)).Elem()
}

func (i *testTimingPtrType) ToTestTimingPtrOutput() TestTimingPtrOutput {
	return i.ToTestTimingPtrOutputWithContext(context.Background())
}

func (i *testTimingPtrType) ToTestTimingPtrOutputWithContext(ctx context.Context) TestTimingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TestTimingPtrOutput)
}

func (i *testTimingPtrType) ToOutput(ctx context.Context) pulumix.Output[*TestTiming] {
	return pulumix.Output[*TestTiming]{
		OutputState: i.ToTestTimingPtrOutputWithContext(ctx).OutputState,
	}
}

// Testing timing break down to know phases.
type TestTimingOutput struct{ *pulumi.OutputState }

func (TestTimingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TestTiming)(nil)).Elem()
}

func (o TestTimingOutput) ToTestTimingOutput() TestTimingOutput {
	return o
}

func (o TestTimingOutput) ToTestTimingOutputWithContext(ctx context.Context) TestTimingOutput {
	return o
}

func (o TestTimingOutput) ToTestTimingPtrOutput() TestTimingPtrOutput {
	return o.ToTestTimingPtrOutputWithContext(context.Background())
}

func (o TestTimingOutput) ToTestTimingPtrOutputWithContext(ctx context.Context) TestTimingPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TestTiming) *TestTiming {
		return &v
	}).(TestTimingPtrOutput)
}

func (o TestTimingOutput) ToOutput(ctx context.Context) pulumix.Output[TestTiming] {
	return pulumix.Output[TestTiming]{
		OutputState: o.OutputState,
	}
}

// How long it took to run the test process. - In response: present if previously set. - In create/update request: optional
func (o TestTimingOutput) TestProcessDuration() DurationPtrOutput {
	return o.ApplyT(func(v TestTiming) *Duration { return v.TestProcessDuration }).(DurationPtrOutput)
}

type TestTimingPtrOutput struct{ *pulumi.OutputState }

func (TestTimingPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TestTiming)(nil)).Elem()
}

func (o TestTimingPtrOutput) ToTestTimingPtrOutput() TestTimingPtrOutput {
	return o
}

func (o TestTimingPtrOutput) ToTestTimingPtrOutputWithContext(ctx context.Context) TestTimingPtrOutput {
	return o
}

func (o TestTimingPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*TestTiming] {
	return pulumix.Output[*TestTiming]{
		OutputState: o.OutputState,
	}
}

func (o TestTimingPtrOutput) Elem() TestTimingOutput {
	return o.ApplyT(func(v *TestTiming) TestTiming {
		if v != nil {
			return *v
		}
		var ret TestTiming
		return ret
	}).(TestTimingOutput)
}

// How long it took to run the test process. - In response: present if previously set. - In create/update request: optional
func (o TestTimingPtrOutput) TestProcessDuration() DurationPtrOutput {
	return o.ApplyT(func(v *TestTiming) *Duration {
		if v == nil {
			return nil
		}
		return v.TestProcessDuration
	}).(DurationPtrOutput)
}

// Testing timing break down to know phases.
type TestTimingResponse struct {
	// How long it took to run the test process. - In response: present if previously set. - In create/update request: optional
	TestProcessDuration DurationResponse `pulumi:"testProcessDuration"`
}

// Testing timing break down to know phases.
type TestTimingResponseOutput struct{ *pulumi.OutputState }

func (TestTimingResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TestTimingResponse)(nil)).Elem()
}

func (o TestTimingResponseOutput) ToTestTimingResponseOutput() TestTimingResponseOutput {
	return o
}

func (o TestTimingResponseOutput) ToTestTimingResponseOutputWithContext(ctx context.Context) TestTimingResponseOutput {
	return o
}

func (o TestTimingResponseOutput) ToOutput(ctx context.Context) pulumix.Output[TestTimingResponse] {
	return pulumix.Output[TestTimingResponse]{
		OutputState: o.OutputState,
	}
}

// How long it took to run the test process. - In response: present if previously set. - In create/update request: optional
func (o TestTimingResponseOutput) TestProcessDuration() DurationResponseOutput {
	return o.ApplyT(func(v TestTimingResponse) DurationResponse { return v.TestProcessDuration }).(DurationResponseOutput)
}

// A Timestamp represents a point in time independent of any time zone or local calendar, encoded as a count of seconds and fractions of seconds at nanosecond resolution. The count is relative to an epoch at UTC midnight on January 1, 1970, in the proleptic Gregorian calendar which extends the Gregorian calendar backwards to year one. All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap second table is needed for interpretation, using a [24-hour linear smear](https://developers.google.com/time/smear). The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By restricting to that range, we ensure that we can convert to and from [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
type Timestamp struct {
	// Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive.
	Nanos *int `pulumi:"nanos"`
	// Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
	Seconds *string `pulumi:"seconds"`
}

// TimestampInput is an input type that accepts TimestampArgs and TimestampOutput values.
// You can construct a concrete instance of `TimestampInput` via:
//
//	TimestampArgs{...}
type TimestampInput interface {
	pulumi.Input

	ToTimestampOutput() TimestampOutput
	ToTimestampOutputWithContext(context.Context) TimestampOutput
}

// A Timestamp represents a point in time independent of any time zone or local calendar, encoded as a count of seconds and fractions of seconds at nanosecond resolution. The count is relative to an epoch at UTC midnight on January 1, 1970, in the proleptic Gregorian calendar which extends the Gregorian calendar backwards to year one. All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap second table is needed for interpretation, using a [24-hour linear smear](https://developers.google.com/time/smear). The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By restricting to that range, we ensure that we can convert to and from [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
type TimestampArgs struct {
	// Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive.
	Nanos pulumi.IntPtrInput `pulumi:"nanos"`
	// Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
	Seconds pulumi.StringPtrInput `pulumi:"seconds"`
}

func (TimestampArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Timestamp)(nil)).Elem()
}

func (i TimestampArgs) ToTimestampOutput() TimestampOutput {
	return i.ToTimestampOutputWithContext(context.Background())
}

func (i TimestampArgs) ToTimestampOutputWithContext(ctx context.Context) TimestampOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimestampOutput)
}

func (i TimestampArgs) ToOutput(ctx context.Context) pulumix.Output[Timestamp] {
	return pulumix.Output[Timestamp]{
		OutputState: i.ToTimestampOutputWithContext(ctx).OutputState,
	}
}

func (i TimestampArgs) ToTimestampPtrOutput() TimestampPtrOutput {
	return i.ToTimestampPtrOutputWithContext(context.Background())
}

func (i TimestampArgs) ToTimestampPtrOutputWithContext(ctx context.Context) TimestampPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimestampOutput).ToTimestampPtrOutputWithContext(ctx)
}

// TimestampPtrInput is an input type that accepts TimestampArgs, TimestampPtr and TimestampPtrOutput values.
// You can construct a concrete instance of `TimestampPtrInput` via:
//
//	        TimestampArgs{...}
//
//	or:
//
//	        nil
type TimestampPtrInput interface {
	pulumi.Input

	ToTimestampPtrOutput() TimestampPtrOutput
	ToTimestampPtrOutputWithContext(context.Context) TimestampPtrOutput
}

type timestampPtrType TimestampArgs

func TimestampPtr(v *TimestampArgs) TimestampPtrInput {
	return (*timestampPtrType)(v)
}

func (*timestampPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Timestamp)(nil)).Elem()
}

func (i *timestampPtrType) ToTimestampPtrOutput() TimestampPtrOutput {
	return i.ToTimestampPtrOutputWithContext(context.Background())
}

func (i *timestampPtrType) ToTimestampPtrOutputWithContext(ctx context.Context) TimestampPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimestampPtrOutput)
}

func (i *timestampPtrType) ToOutput(ctx context.Context) pulumix.Output[*Timestamp] {
	return pulumix.Output[*Timestamp]{
		OutputState: i.ToTimestampPtrOutputWithContext(ctx).OutputState,
	}
}

// A Timestamp represents a point in time independent of any time zone or local calendar, encoded as a count of seconds and fractions of seconds at nanosecond resolution. The count is relative to an epoch at UTC midnight on January 1, 1970, in the proleptic Gregorian calendar which extends the Gregorian calendar backwards to year one. All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap second table is needed for interpretation, using a [24-hour linear smear](https://developers.google.com/time/smear). The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By restricting to that range, we ensure that we can convert to and from [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
type TimestampOutput struct{ *pulumi.OutputState }

func (TimestampOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Timestamp)(nil)).Elem()
}

func (o TimestampOutput) ToTimestampOutput() TimestampOutput {
	return o
}

func (o TimestampOutput) ToTimestampOutputWithContext(ctx context.Context) TimestampOutput {
	return o
}

func (o TimestampOutput) ToTimestampPtrOutput() TimestampPtrOutput {
	return o.ToTimestampPtrOutputWithContext(context.Background())
}

func (o TimestampOutput) ToTimestampPtrOutputWithContext(ctx context.Context) TimestampPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Timestamp) *Timestamp {
		return &v
	}).(TimestampPtrOutput)
}

func (o TimestampOutput) ToOutput(ctx context.Context) pulumix.Output[Timestamp] {
	return pulumix.Output[Timestamp]{
		OutputState: o.OutputState,
	}
}

// Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive.
func (o TimestampOutput) Nanos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Timestamp) *int { return v.Nanos }).(pulumi.IntPtrOutput)
}

// Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
func (o TimestampOutput) Seconds() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Timestamp) *string { return v.Seconds }).(pulumi.StringPtrOutput)
}

type TimestampPtrOutput struct{ *pulumi.OutputState }

func (TimestampPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Timestamp)(nil)).Elem()
}

func (o TimestampPtrOutput) ToTimestampPtrOutput() TimestampPtrOutput {
	return o
}

func (o TimestampPtrOutput) ToTimestampPtrOutputWithContext(ctx context.Context) TimestampPtrOutput {
	return o
}

func (o TimestampPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*Timestamp] {
	return pulumix.Output[*Timestamp]{
		OutputState: o.OutputState,
	}
}

func (o TimestampPtrOutput) Elem() TimestampOutput {
	return o.ApplyT(func(v *Timestamp) Timestamp {
		if v != nil {
			return *v
		}
		var ret Timestamp
		return ret
	}).(TimestampOutput)
}

// Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive.
func (o TimestampPtrOutput) Nanos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Timestamp) *int {
		if v == nil {
			return nil
		}
		return v.Nanos
	}).(pulumi.IntPtrOutput)
}

// Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
func (o TimestampPtrOutput) Seconds() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Timestamp) *string {
		if v == nil {
			return nil
		}
		return v.Seconds
	}).(pulumi.StringPtrOutput)
}

// A Timestamp represents a point in time independent of any time zone or local calendar, encoded as a count of seconds and fractions of seconds at nanosecond resolution. The count is relative to an epoch at UTC midnight on January 1, 1970, in the proleptic Gregorian calendar which extends the Gregorian calendar backwards to year one. All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap second table is needed for interpretation, using a [24-hour linear smear](https://developers.google.com/time/smear). The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By restricting to that range, we ensure that we can convert to and from [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
type TimestampResponse struct {
	// Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive.
	Nanos int `pulumi:"nanos"`
	// Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
	Seconds string `pulumi:"seconds"`
}

// A Timestamp represents a point in time independent of any time zone or local calendar, encoded as a count of seconds and fractions of seconds at nanosecond resolution. The count is relative to an epoch at UTC midnight on January 1, 1970, in the proleptic Gregorian calendar which extends the Gregorian calendar backwards to year one. All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap second table is needed for interpretation, using a [24-hour linear smear](https://developers.google.com/time/smear). The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By restricting to that range, we ensure that we can convert to and from [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
type TimestampResponseOutput struct{ *pulumi.OutputState }

func (TimestampResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimestampResponse)(nil)).Elem()
}

func (o TimestampResponseOutput) ToTimestampResponseOutput() TimestampResponseOutput {
	return o
}

func (o TimestampResponseOutput) ToTimestampResponseOutputWithContext(ctx context.Context) TimestampResponseOutput {
	return o
}

func (o TimestampResponseOutput) ToOutput(ctx context.Context) pulumix.Output[TimestampResponse] {
	return pulumix.Output[TimestampResponse]{
		OutputState: o.OutputState,
	}
}

// Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive.
func (o TimestampResponseOutput) Nanos() pulumi.IntOutput {
	return o.ApplyT(func(v TimestampResponse) int { return v.Nanos }).(pulumi.IntOutput)
}

// Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
func (o TimestampResponseOutput) Seconds() pulumi.StringOutput {
	return o.ApplyT(func(v TimestampResponse) string { return v.Seconds }).(pulumi.StringOutput)
}

// An execution of an arbitrary tool. It could be a test runner or a tool copying artifacts or deploying code.
type ToolExecution struct {
	// The full tokenized command line including the program name (equivalent to argv in a C program). - In response: present if set by create request - In create request: optional - In update request: never set
	CommandLineArguments []string `pulumi:"commandLineArguments"`
	// Tool execution exit code. This field will be set once the tool has exited. - In response: present if set by create/update request - In create request: optional - In update request: optional, a FAILED_PRECONDITION error will be returned if an exit_code is already set.
	ExitCode *ToolExitCode `pulumi:"exitCode"`
	// References to any plain text logs output the tool execution. This field can be set before the tool has exited in order to be able to have access to a live view of the logs while the tool is running. The maximum allowed number of tool logs per step is 1000. - In response: present if set by create/update request - In create request: optional - In update request: optional, any value provided will be appended to the existing list
	ToolLogs []FileReference `pulumi:"toolLogs"`
	// References to opaque files of any format output by the tool execution. The maximum allowed number of tool outputs per step is 1000. - In response: present if set by create/update request - In create request: optional - In update request: optional, any value provided will be appended to the existing list
	ToolOutputs []ToolOutputReference `pulumi:"toolOutputs"`
}

// ToolExecutionInput is an input type that accepts ToolExecutionArgs and ToolExecutionOutput values.
// You can construct a concrete instance of `ToolExecutionInput` via:
//
//	ToolExecutionArgs{...}
type ToolExecutionInput interface {
	pulumi.Input

	ToToolExecutionOutput() ToolExecutionOutput
	ToToolExecutionOutputWithContext(context.Context) ToolExecutionOutput
}

// An execution of an arbitrary tool. It could be a test runner or a tool copying artifacts or deploying code.
type ToolExecutionArgs struct {
	// The full tokenized command line including the program name (equivalent to argv in a C program). - In response: present if set by create request - In create request: optional - In update request: never set
	CommandLineArguments pulumi.StringArrayInput `pulumi:"commandLineArguments"`
	// Tool execution exit code. This field will be set once the tool has exited. - In response: present if set by create/update request - In create request: optional - In update request: optional, a FAILED_PRECONDITION error will be returned if an exit_code is already set.
	ExitCode ToolExitCodePtrInput `pulumi:"exitCode"`
	// References to any plain text logs output the tool execution. This field can be set before the tool has exited in order to be able to have access to a live view of the logs while the tool is running. The maximum allowed number of tool logs per step is 1000. - In response: present if set by create/update request - In create request: optional - In update request: optional, any value provided will be appended to the existing list
	ToolLogs FileReferenceArrayInput `pulumi:"toolLogs"`
	// References to opaque files of any format output by the tool execution. The maximum allowed number of tool outputs per step is 1000. - In response: present if set by create/update request - In create request: optional - In update request: optional, any value provided will be appended to the existing list
	ToolOutputs ToolOutputReferenceArrayInput `pulumi:"toolOutputs"`
}

func (ToolExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ToolExecution)(nil)).Elem()
}

func (i ToolExecutionArgs) ToToolExecutionOutput() ToolExecutionOutput {
	return i.ToToolExecutionOutputWithContext(context.Background())
}

func (i ToolExecutionArgs) ToToolExecutionOutputWithContext(ctx context.Context) ToolExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ToolExecutionOutput)
}

func (i ToolExecutionArgs) ToOutput(ctx context.Context) pulumix.Output[ToolExecution] {
	return pulumix.Output[ToolExecution]{
		OutputState: i.ToToolExecutionOutputWithContext(ctx).OutputState,
	}
}

func (i ToolExecutionArgs) ToToolExecutionPtrOutput() ToolExecutionPtrOutput {
	return i.ToToolExecutionPtrOutputWithContext(context.Background())
}

func (i ToolExecutionArgs) ToToolExecutionPtrOutputWithContext(ctx context.Context) ToolExecutionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ToolExecutionOutput).ToToolExecutionPtrOutputWithContext(ctx)
}

// ToolExecutionPtrInput is an input type that accepts ToolExecutionArgs, ToolExecutionPtr and ToolExecutionPtrOutput values.
// You can construct a concrete instance of `ToolExecutionPtrInput` via:
//
//	        ToolExecutionArgs{...}
//
//	or:
//
//	        nil
type ToolExecutionPtrInput interface {
	pulumi.Input

	ToToolExecutionPtrOutput() ToolExecutionPtrOutput
	ToToolExecutionPtrOutputWithContext(context.Context) ToolExecutionPtrOutput
}

type toolExecutionPtrType ToolExecutionArgs

func ToolExecutionPtr(v *ToolExecutionArgs) ToolExecutionPtrInput {
	return (*toolExecutionPtrType)(v)
}

func (*toolExecutionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ToolExecution)(nil)).Elem()
}

func (i *toolExecutionPtrType) ToToolExecutionPtrOutput() ToolExecutionPtrOutput {
	return i.ToToolExecutionPtrOutputWithContext(context.Background())
}

func (i *toolExecutionPtrType) ToToolExecutionPtrOutputWithContext(ctx context.Context) ToolExecutionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ToolExecutionPtrOutput)
}

func (i *toolExecutionPtrType) ToOutput(ctx context.Context) pulumix.Output[*ToolExecution] {
	return pulumix.Output[*ToolExecution]{
		OutputState: i.ToToolExecutionPtrOutputWithContext(ctx).OutputState,
	}
}

// An execution of an arbitrary tool. It could be a test runner or a tool copying artifacts or deploying code.
type ToolExecutionOutput struct{ *pulumi.OutputState }

func (ToolExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ToolExecution)(nil)).Elem()
}

func (o ToolExecutionOutput) ToToolExecutionOutput() ToolExecutionOutput {
	return o
}

func (o ToolExecutionOutput) ToToolExecutionOutputWithContext(ctx context.Context) ToolExecutionOutput {
	return o
}

func (o ToolExecutionOutput) ToToolExecutionPtrOutput() ToolExecutionPtrOutput {
	return o.ToToolExecutionPtrOutputWithContext(context.Background())
}

func (o ToolExecutionOutput) ToToolExecutionPtrOutputWithContext(ctx context.Context) ToolExecutionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ToolExecution) *ToolExecution {
		return &v
	}).(ToolExecutionPtrOutput)
}

func (o ToolExecutionOutput) ToOutput(ctx context.Context) pulumix.Output[ToolExecution] {
	return pulumix.Output[ToolExecution]{
		OutputState: o.OutputState,
	}
}

// The full tokenized command line including the program name (equivalent to argv in a C program). - In response: present if set by create request - In create request: optional - In update request: never set
func (o ToolExecutionOutput) CommandLineArguments() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ToolExecution) []string { return v.CommandLineArguments }).(pulumi.StringArrayOutput)
}

// Tool execution exit code. This field will be set once the tool has exited. - In response: present if set by create/update request - In create request: optional - In update request: optional, a FAILED_PRECONDITION error will be returned if an exit_code is already set.
func (o ToolExecutionOutput) ExitCode() ToolExitCodePtrOutput {
	return o.ApplyT(func(v ToolExecution) *ToolExitCode { return v.ExitCode }).(ToolExitCodePtrOutput)
}

// References to any plain text logs output the tool execution. This field can be set before the tool has exited in order to be able to have access to a live view of the logs while the tool is running. The maximum allowed number of tool logs per step is 1000. - In response: present if set by create/update request - In create request: optional - In update request: optional, any value provided will be appended to the existing list
func (o ToolExecutionOutput) ToolLogs() FileReferenceArrayOutput {
	return o.ApplyT(func(v ToolExecution) []FileReference { return v.ToolLogs }).(FileReferenceArrayOutput)
}

// References to opaque files of any format output by the tool execution. The maximum allowed number of tool outputs per step is 1000. - In response: present if set by create/update request - In create request: optional - In update request: optional, any value provided will be appended to the existing list
func (o ToolExecutionOutput) ToolOutputs() ToolOutputReferenceArrayOutput {
	return o.ApplyT(func(v ToolExecution) []ToolOutputReference { return v.ToolOutputs }).(ToolOutputReferenceArrayOutput)
}

type ToolExecutionPtrOutput struct{ *pulumi.OutputState }

func (ToolExecutionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ToolExecution)(nil)).Elem()
}

func (o ToolExecutionPtrOutput) ToToolExecutionPtrOutput() ToolExecutionPtrOutput {
	return o
}

func (o ToolExecutionPtrOutput) ToToolExecutionPtrOutputWithContext(ctx context.Context) ToolExecutionPtrOutput {
	return o
}

func (o ToolExecutionPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*ToolExecution] {
	return pulumix.Output[*ToolExecution]{
		OutputState: o.OutputState,
	}
}

func (o ToolExecutionPtrOutput) Elem() ToolExecutionOutput {
	return o.ApplyT(func(v *ToolExecution) ToolExecution {
		if v != nil {
			return *v
		}
		var ret ToolExecution
		return ret
	}).(ToolExecutionOutput)
}

// The full tokenized command line including the program name (equivalent to argv in a C program). - In response: present if set by create request - In create request: optional - In update request: never set
func (o ToolExecutionPtrOutput) CommandLineArguments() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ToolExecution) []string {
		if v == nil {
			return nil
		}
		return v.CommandLineArguments
	}).(pulumi.StringArrayOutput)
}

// Tool execution exit code. This field will be set once the tool has exited. - In response: present if set by create/update request - In create request: optional - In update request: optional, a FAILED_PRECONDITION error will be returned if an exit_code is already set.
func (o ToolExecutionPtrOutput) ExitCode() ToolExitCodePtrOutput {
	return o.ApplyT(func(v *ToolExecution) *ToolExitCode {
		if v == nil {
			return nil
		}
		return v.ExitCode
	}).(ToolExitCodePtrOutput)
}

// References to any plain text logs output the tool execution. This field can be set before the tool has exited in order to be able to have access to a live view of the logs while the tool is running. The maximum allowed number of tool logs per step is 1000. - In response: present if set by create/update request - In create request: optional - In update request: optional, any value provided will be appended to the existing list
func (o ToolExecutionPtrOutput) ToolLogs() FileReferenceArrayOutput {
	return o.ApplyT(func(v *ToolExecution) []FileReference {
		if v == nil {
			return nil
		}
		return v.ToolLogs
	}).(FileReferenceArrayOutput)
}

// References to opaque files of any format output by the tool execution. The maximum allowed number of tool outputs per step is 1000. - In response: present if set by create/update request - In create request: optional - In update request: optional, any value provided will be appended to the existing list
func (o ToolExecutionPtrOutput) ToolOutputs() ToolOutputReferenceArrayOutput {
	return o.ApplyT(func(v *ToolExecution) []ToolOutputReference {
		if v == nil {
			return nil
		}
		return v.ToolOutputs
	}).(ToolOutputReferenceArrayOutput)
}

// An execution of an arbitrary tool. It could be a test runner or a tool copying artifacts or deploying code.
type ToolExecutionResponse struct {
	// The full tokenized command line including the program name (equivalent to argv in a C program). - In response: present if set by create request - In create request: optional - In update request: never set
	CommandLineArguments []string `pulumi:"commandLineArguments"`
	// Tool execution exit code. This field will be set once the tool has exited. - In response: present if set by create/update request - In create request: optional - In update request: optional, a FAILED_PRECONDITION error will be returned if an exit_code is already set.
	ExitCode ToolExitCodeResponse `pulumi:"exitCode"`
	// References to any plain text logs output the tool execution. This field can be set before the tool has exited in order to be able to have access to a live view of the logs while the tool is running. The maximum allowed number of tool logs per step is 1000. - In response: present if set by create/update request - In create request: optional - In update request: optional, any value provided will be appended to the existing list
	ToolLogs []FileReferenceResponse `pulumi:"toolLogs"`
	// References to opaque files of any format output by the tool execution. The maximum allowed number of tool outputs per step is 1000. - In response: present if set by create/update request - In create request: optional - In update request: optional, any value provided will be appended to the existing list
	ToolOutputs []ToolOutputReferenceResponse `pulumi:"toolOutputs"`
}

// An execution of an arbitrary tool. It could be a test runner or a tool copying artifacts or deploying code.
type ToolExecutionResponseOutput struct{ *pulumi.OutputState }

func (ToolExecutionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ToolExecutionResponse)(nil)).Elem()
}

func (o ToolExecutionResponseOutput) ToToolExecutionResponseOutput() ToolExecutionResponseOutput {
	return o
}

func (o ToolExecutionResponseOutput) ToToolExecutionResponseOutputWithContext(ctx context.Context) ToolExecutionResponseOutput {
	return o
}

func (o ToolExecutionResponseOutput) ToOutput(ctx context.Context) pulumix.Output[ToolExecutionResponse] {
	return pulumix.Output[ToolExecutionResponse]{
		OutputState: o.OutputState,
	}
}

// The full tokenized command line including the program name (equivalent to argv in a C program). - In response: present if set by create request - In create request: optional - In update request: never set
func (o ToolExecutionResponseOutput) CommandLineArguments() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ToolExecutionResponse) []string { return v.CommandLineArguments }).(pulumi.StringArrayOutput)
}

// Tool execution exit code. This field will be set once the tool has exited. - In response: present if set by create/update request - In create request: optional - In update request: optional, a FAILED_PRECONDITION error will be returned if an exit_code is already set.
func (o ToolExecutionResponseOutput) ExitCode() ToolExitCodeResponseOutput {
	return o.ApplyT(func(v ToolExecutionResponse) ToolExitCodeResponse { return v.ExitCode }).(ToolExitCodeResponseOutput)
}

// References to any plain text logs output the tool execution. This field can be set before the tool has exited in order to be able to have access to a live view of the logs while the tool is running. The maximum allowed number of tool logs per step is 1000. - In response: present if set by create/update request - In create request: optional - In update request: optional, any value provided will be appended to the existing list
func (o ToolExecutionResponseOutput) ToolLogs() FileReferenceResponseArrayOutput {
	return o.ApplyT(func(v ToolExecutionResponse) []FileReferenceResponse { return v.ToolLogs }).(FileReferenceResponseArrayOutput)
}

// References to opaque files of any format output by the tool execution. The maximum allowed number of tool outputs per step is 1000. - In response: present if set by create/update request - In create request: optional - In update request: optional, any value provided will be appended to the existing list
func (o ToolExecutionResponseOutput) ToolOutputs() ToolOutputReferenceResponseArrayOutput {
	return o.ApplyT(func(v ToolExecutionResponse) []ToolOutputReferenceResponse { return v.ToolOutputs }).(ToolOutputReferenceResponseArrayOutput)
}

// Generic tool step to be used for binaries we do not explicitly support. For example: running cp to copy artifacts from one location to another.
type ToolExecutionStep struct {
	// A Tool execution. - In response: present if set by create/update request - In create/update request: optional
	ToolExecution *ToolExecution `pulumi:"toolExecution"`
}

// ToolExecutionStepInput is an input type that accepts ToolExecutionStepArgs and ToolExecutionStepOutput values.
// You can construct a concrete instance of `ToolExecutionStepInput` via:
//
//	ToolExecutionStepArgs{...}
type ToolExecutionStepInput interface {
	pulumi.Input

	ToToolExecutionStepOutput() ToolExecutionStepOutput
	ToToolExecutionStepOutputWithContext(context.Context) ToolExecutionStepOutput
}

// Generic tool step to be used for binaries we do not explicitly support. For example: running cp to copy artifacts from one location to another.
type ToolExecutionStepArgs struct {
	// A Tool execution. - In response: present if set by create/update request - In create/update request: optional
	ToolExecution ToolExecutionPtrInput `pulumi:"toolExecution"`
}

func (ToolExecutionStepArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ToolExecutionStep)(nil)).Elem()
}

func (i ToolExecutionStepArgs) ToToolExecutionStepOutput() ToolExecutionStepOutput {
	return i.ToToolExecutionStepOutputWithContext(context.Background())
}

func (i ToolExecutionStepArgs) ToToolExecutionStepOutputWithContext(ctx context.Context) ToolExecutionStepOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ToolExecutionStepOutput)
}

func (i ToolExecutionStepArgs) ToOutput(ctx context.Context) pulumix.Output[ToolExecutionStep] {
	return pulumix.Output[ToolExecutionStep]{
		OutputState: i.ToToolExecutionStepOutputWithContext(ctx).OutputState,
	}
}

func (i ToolExecutionStepArgs) ToToolExecutionStepPtrOutput() ToolExecutionStepPtrOutput {
	return i.ToToolExecutionStepPtrOutputWithContext(context.Background())
}

func (i ToolExecutionStepArgs) ToToolExecutionStepPtrOutputWithContext(ctx context.Context) ToolExecutionStepPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ToolExecutionStepOutput).ToToolExecutionStepPtrOutputWithContext(ctx)
}

// ToolExecutionStepPtrInput is an input type that accepts ToolExecutionStepArgs, ToolExecutionStepPtr and ToolExecutionStepPtrOutput values.
// You can construct a concrete instance of `ToolExecutionStepPtrInput` via:
//
//	        ToolExecutionStepArgs{...}
//
//	or:
//
//	        nil
type ToolExecutionStepPtrInput interface {
	pulumi.Input

	ToToolExecutionStepPtrOutput() ToolExecutionStepPtrOutput
	ToToolExecutionStepPtrOutputWithContext(context.Context) ToolExecutionStepPtrOutput
}

type toolExecutionStepPtrType ToolExecutionStepArgs

func ToolExecutionStepPtr(v *ToolExecutionStepArgs) ToolExecutionStepPtrInput {
	return (*toolExecutionStepPtrType)(v)
}

func (*toolExecutionStepPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ToolExecutionStep)(nil)).Elem()
}

func (i *toolExecutionStepPtrType) ToToolExecutionStepPtrOutput() ToolExecutionStepPtrOutput {
	return i.ToToolExecutionStepPtrOutputWithContext(context.Background())
}

func (i *toolExecutionStepPtrType) ToToolExecutionStepPtrOutputWithContext(ctx context.Context) ToolExecutionStepPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ToolExecutionStepPtrOutput)
}

func (i *toolExecutionStepPtrType) ToOutput(ctx context.Context) pulumix.Output[*ToolExecutionStep] {
	return pulumix.Output[*ToolExecutionStep]{
		OutputState: i.ToToolExecutionStepPtrOutputWithContext(ctx).OutputState,
	}
}

// Generic tool step to be used for binaries we do not explicitly support. For example: running cp to copy artifacts from one location to another.
type ToolExecutionStepOutput struct{ *pulumi.OutputState }

func (ToolExecutionStepOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ToolExecutionStep)(nil)).Elem()
}

func (o ToolExecutionStepOutput) ToToolExecutionStepOutput() ToolExecutionStepOutput {
	return o
}

func (o ToolExecutionStepOutput) ToToolExecutionStepOutputWithContext(ctx context.Context) ToolExecutionStepOutput {
	return o
}

func (o ToolExecutionStepOutput) ToToolExecutionStepPtrOutput() ToolExecutionStepPtrOutput {
	return o.ToToolExecutionStepPtrOutputWithContext(context.Background())
}

func (o ToolExecutionStepOutput) ToToolExecutionStepPtrOutputWithContext(ctx context.Context) ToolExecutionStepPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ToolExecutionStep) *ToolExecutionStep {
		return &v
	}).(ToolExecutionStepPtrOutput)
}

func (o ToolExecutionStepOutput) ToOutput(ctx context.Context) pulumix.Output[ToolExecutionStep] {
	return pulumix.Output[ToolExecutionStep]{
		OutputState: o.OutputState,
	}
}

// A Tool execution. - In response: present if set by create/update request - In create/update request: optional
func (o ToolExecutionStepOutput) ToolExecution() ToolExecutionPtrOutput {
	return o.ApplyT(func(v ToolExecutionStep) *ToolExecution { return v.ToolExecution }).(ToolExecutionPtrOutput)
}

type ToolExecutionStepPtrOutput struct{ *pulumi.OutputState }

func (ToolExecutionStepPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ToolExecutionStep)(nil)).Elem()
}

func (o ToolExecutionStepPtrOutput) ToToolExecutionStepPtrOutput() ToolExecutionStepPtrOutput {
	return o
}

func (o ToolExecutionStepPtrOutput) ToToolExecutionStepPtrOutputWithContext(ctx context.Context) ToolExecutionStepPtrOutput {
	return o
}

func (o ToolExecutionStepPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*ToolExecutionStep] {
	return pulumix.Output[*ToolExecutionStep]{
		OutputState: o.OutputState,
	}
}

func (o ToolExecutionStepPtrOutput) Elem() ToolExecutionStepOutput {
	return o.ApplyT(func(v *ToolExecutionStep) ToolExecutionStep {
		if v != nil {
			return *v
		}
		var ret ToolExecutionStep
		return ret
	}).(ToolExecutionStepOutput)
}

// A Tool execution. - In response: present if set by create/update request - In create/update request: optional
func (o ToolExecutionStepPtrOutput) ToolExecution() ToolExecutionPtrOutput {
	return o.ApplyT(func(v *ToolExecutionStep) *ToolExecution {
		if v == nil {
			return nil
		}
		return v.ToolExecution
	}).(ToolExecutionPtrOutput)
}

// Generic tool step to be used for binaries we do not explicitly support. For example: running cp to copy artifacts from one location to another.
type ToolExecutionStepResponse struct {
	// A Tool execution. - In response: present if set by create/update request - In create/update request: optional
	ToolExecution ToolExecutionResponse `pulumi:"toolExecution"`
}

// Generic tool step to be used for binaries we do not explicitly support. For example: running cp to copy artifacts from one location to another.
type ToolExecutionStepResponseOutput struct{ *pulumi.OutputState }

func (ToolExecutionStepResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ToolExecutionStepResponse)(nil)).Elem()
}

func (o ToolExecutionStepResponseOutput) ToToolExecutionStepResponseOutput() ToolExecutionStepResponseOutput {
	return o
}

func (o ToolExecutionStepResponseOutput) ToToolExecutionStepResponseOutputWithContext(ctx context.Context) ToolExecutionStepResponseOutput {
	return o
}

func (o ToolExecutionStepResponseOutput) ToOutput(ctx context.Context) pulumix.Output[ToolExecutionStepResponse] {
	return pulumix.Output[ToolExecutionStepResponse]{
		OutputState: o.OutputState,
	}
}

// A Tool execution. - In response: present if set by create/update request - In create/update request: optional
func (o ToolExecutionStepResponseOutput) ToolExecution() ToolExecutionResponseOutput {
	return o.ApplyT(func(v ToolExecutionStepResponse) ToolExecutionResponse { return v.ToolExecution }).(ToolExecutionResponseOutput)
}

// Exit code from a tool execution.
type ToolExitCode struct {
	// Tool execution exit code. A value of 0 means that the execution was successful. - In response: always set - In create/update request: always set
	Number *int `pulumi:"number"`
}

// ToolExitCodeInput is an input type that accepts ToolExitCodeArgs and ToolExitCodeOutput values.
// You can construct a concrete instance of `ToolExitCodeInput` via:
//
//	ToolExitCodeArgs{...}
type ToolExitCodeInput interface {
	pulumi.Input

	ToToolExitCodeOutput() ToolExitCodeOutput
	ToToolExitCodeOutputWithContext(context.Context) ToolExitCodeOutput
}

// Exit code from a tool execution.
type ToolExitCodeArgs struct {
	// Tool execution exit code. A value of 0 means that the execution was successful. - In response: always set - In create/update request: always set
	Number pulumi.IntPtrInput `pulumi:"number"`
}

func (ToolExitCodeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ToolExitCode)(nil)).Elem()
}

func (i ToolExitCodeArgs) ToToolExitCodeOutput() ToolExitCodeOutput {
	return i.ToToolExitCodeOutputWithContext(context.Background())
}

func (i ToolExitCodeArgs) ToToolExitCodeOutputWithContext(ctx context.Context) ToolExitCodeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ToolExitCodeOutput)
}

func (i ToolExitCodeArgs) ToOutput(ctx context.Context) pulumix.Output[ToolExitCode] {
	return pulumix.Output[ToolExitCode]{
		OutputState: i.ToToolExitCodeOutputWithContext(ctx).OutputState,
	}
}

func (i ToolExitCodeArgs) ToToolExitCodePtrOutput() ToolExitCodePtrOutput {
	return i.ToToolExitCodePtrOutputWithContext(context.Background())
}

func (i ToolExitCodeArgs) ToToolExitCodePtrOutputWithContext(ctx context.Context) ToolExitCodePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ToolExitCodeOutput).ToToolExitCodePtrOutputWithContext(ctx)
}

// ToolExitCodePtrInput is an input type that accepts ToolExitCodeArgs, ToolExitCodePtr and ToolExitCodePtrOutput values.
// You can construct a concrete instance of `ToolExitCodePtrInput` via:
//
//	        ToolExitCodeArgs{...}
//
//	or:
//
//	        nil
type ToolExitCodePtrInput interface {
	pulumi.Input

	ToToolExitCodePtrOutput() ToolExitCodePtrOutput
	ToToolExitCodePtrOutputWithContext(context.Context) ToolExitCodePtrOutput
}

type toolExitCodePtrType ToolExitCodeArgs

func ToolExitCodePtr(v *ToolExitCodeArgs) ToolExitCodePtrInput {
	return (*toolExitCodePtrType)(v)
}

func (*toolExitCodePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ToolExitCode)(nil)).Elem()
}

func (i *toolExitCodePtrType) ToToolExitCodePtrOutput() ToolExitCodePtrOutput {
	return i.ToToolExitCodePtrOutputWithContext(context.Background())
}

func (i *toolExitCodePtrType) ToToolExitCodePtrOutputWithContext(ctx context.Context) ToolExitCodePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ToolExitCodePtrOutput)
}

func (i *toolExitCodePtrType) ToOutput(ctx context.Context) pulumix.Output[*ToolExitCode] {
	return pulumix.Output[*ToolExitCode]{
		OutputState: i.ToToolExitCodePtrOutputWithContext(ctx).OutputState,
	}
}

// Exit code from a tool execution.
type ToolExitCodeOutput struct{ *pulumi.OutputState }

func (ToolExitCodeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ToolExitCode)(nil)).Elem()
}

func (o ToolExitCodeOutput) ToToolExitCodeOutput() ToolExitCodeOutput {
	return o
}

func (o ToolExitCodeOutput) ToToolExitCodeOutputWithContext(ctx context.Context) ToolExitCodeOutput {
	return o
}

func (o ToolExitCodeOutput) ToToolExitCodePtrOutput() ToolExitCodePtrOutput {
	return o.ToToolExitCodePtrOutputWithContext(context.Background())
}

func (o ToolExitCodeOutput) ToToolExitCodePtrOutputWithContext(ctx context.Context) ToolExitCodePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ToolExitCode) *ToolExitCode {
		return &v
	}).(ToolExitCodePtrOutput)
}

func (o ToolExitCodeOutput) ToOutput(ctx context.Context) pulumix.Output[ToolExitCode] {
	return pulumix.Output[ToolExitCode]{
		OutputState: o.OutputState,
	}
}

// Tool execution exit code. A value of 0 means that the execution was successful. - In response: always set - In create/update request: always set
func (o ToolExitCodeOutput) Number() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ToolExitCode) *int { return v.Number }).(pulumi.IntPtrOutput)
}

type ToolExitCodePtrOutput struct{ *pulumi.OutputState }

func (ToolExitCodePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ToolExitCode)(nil)).Elem()
}

func (o ToolExitCodePtrOutput) ToToolExitCodePtrOutput() ToolExitCodePtrOutput {
	return o
}

func (o ToolExitCodePtrOutput) ToToolExitCodePtrOutputWithContext(ctx context.Context) ToolExitCodePtrOutput {
	return o
}

func (o ToolExitCodePtrOutput) ToOutput(ctx context.Context) pulumix.Output[*ToolExitCode] {
	return pulumix.Output[*ToolExitCode]{
		OutputState: o.OutputState,
	}
}

func (o ToolExitCodePtrOutput) Elem() ToolExitCodeOutput {
	return o.ApplyT(func(v *ToolExitCode) ToolExitCode {
		if v != nil {
			return *v
		}
		var ret ToolExitCode
		return ret
	}).(ToolExitCodeOutput)
}

// Tool execution exit code. A value of 0 means that the execution was successful. - In response: always set - In create/update request: always set
func (o ToolExitCodePtrOutput) Number() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ToolExitCode) *int {
		if v == nil {
			return nil
		}
		return v.Number
	}).(pulumi.IntPtrOutput)
}

// Exit code from a tool execution.
type ToolExitCodeResponse struct {
	// Tool execution exit code. A value of 0 means that the execution was successful. - In response: always set - In create/update request: always set
	Number int `pulumi:"number"`
}

// Exit code from a tool execution.
type ToolExitCodeResponseOutput struct{ *pulumi.OutputState }

func (ToolExitCodeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ToolExitCodeResponse)(nil)).Elem()
}

func (o ToolExitCodeResponseOutput) ToToolExitCodeResponseOutput() ToolExitCodeResponseOutput {
	return o
}

func (o ToolExitCodeResponseOutput) ToToolExitCodeResponseOutputWithContext(ctx context.Context) ToolExitCodeResponseOutput {
	return o
}

func (o ToolExitCodeResponseOutput) ToOutput(ctx context.Context) pulumix.Output[ToolExitCodeResponse] {
	return pulumix.Output[ToolExitCodeResponse]{
		OutputState: o.OutputState,
	}
}

// Tool execution exit code. A value of 0 means that the execution was successful. - In response: always set - In create/update request: always set
func (o ToolExitCodeResponseOutput) Number() pulumi.IntOutput {
	return o.ApplyT(func(v ToolExitCodeResponse) int { return v.Number }).(pulumi.IntOutput)
}

// A reference to a ToolExecution output file.
type ToolOutputReference struct {
	// The creation time of the file. - In response: present if set by create/update request - In create/update request: optional
	CreationTime *Timestamp `pulumi:"creationTime"`
	// A FileReference to an output file. - In response: always set - In create/update request: always set
	Output *FileReference `pulumi:"output"`
	// The test case to which this output file belongs. - In response: present if set by create/update request - In create/update request: optional
	TestCase *TestCaseReference `pulumi:"testCase"`
}

// ToolOutputReferenceInput is an input type that accepts ToolOutputReferenceArgs and ToolOutputReferenceOutput values.
// You can construct a concrete instance of `ToolOutputReferenceInput` via:
//
//	ToolOutputReferenceArgs{...}
type ToolOutputReferenceInput interface {
	pulumi.Input

	ToToolOutputReferenceOutput() ToolOutputReferenceOutput
	ToToolOutputReferenceOutputWithContext(context.Context) ToolOutputReferenceOutput
}

// A reference to a ToolExecution output file.
type ToolOutputReferenceArgs struct {
	// The creation time of the file. - In response: present if set by create/update request - In create/update request: optional
	CreationTime TimestampPtrInput `pulumi:"creationTime"`
	// A FileReference to an output file. - In response: always set - In create/update request: always set
	Output FileReferencePtrInput `pulumi:"output"`
	// The test case to which this output file belongs. - In response: present if set by create/update request - In create/update request: optional
	TestCase TestCaseReferencePtrInput `pulumi:"testCase"`
}

func (ToolOutputReferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ToolOutputReference)(nil)).Elem()
}

func (i ToolOutputReferenceArgs) ToToolOutputReferenceOutput() ToolOutputReferenceOutput {
	return i.ToToolOutputReferenceOutputWithContext(context.Background())
}

func (i ToolOutputReferenceArgs) ToToolOutputReferenceOutputWithContext(ctx context.Context) ToolOutputReferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ToolOutputReferenceOutput)
}

func (i ToolOutputReferenceArgs) ToOutput(ctx context.Context) pulumix.Output[ToolOutputReference] {
	return pulumix.Output[ToolOutputReference]{
		OutputState: i.ToToolOutputReferenceOutputWithContext(ctx).OutputState,
	}
}

// ToolOutputReferenceArrayInput is an input type that accepts ToolOutputReferenceArray and ToolOutputReferenceArrayOutput values.
// You can construct a concrete instance of `ToolOutputReferenceArrayInput` via:
//
//	ToolOutputReferenceArray{ ToolOutputReferenceArgs{...} }
type ToolOutputReferenceArrayInput interface {
	pulumi.Input

	ToToolOutputReferenceArrayOutput() ToolOutputReferenceArrayOutput
	ToToolOutputReferenceArrayOutputWithContext(context.Context) ToolOutputReferenceArrayOutput
}

type ToolOutputReferenceArray []ToolOutputReferenceInput

func (ToolOutputReferenceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ToolOutputReference)(nil)).Elem()
}

func (i ToolOutputReferenceArray) ToToolOutputReferenceArrayOutput() ToolOutputReferenceArrayOutput {
	return i.ToToolOutputReferenceArrayOutputWithContext(context.Background())
}

func (i ToolOutputReferenceArray) ToToolOutputReferenceArrayOutputWithContext(ctx context.Context) ToolOutputReferenceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ToolOutputReferenceArrayOutput)
}

func (i ToolOutputReferenceArray) ToOutput(ctx context.Context) pulumix.Output[[]ToolOutputReference] {
	return pulumix.Output[[]ToolOutputReference]{
		OutputState: i.ToToolOutputReferenceArrayOutputWithContext(ctx).OutputState,
	}
}

// A reference to a ToolExecution output file.
type ToolOutputReferenceOutput struct{ *pulumi.OutputState }

func (ToolOutputReferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ToolOutputReference)(nil)).Elem()
}

func (o ToolOutputReferenceOutput) ToToolOutputReferenceOutput() ToolOutputReferenceOutput {
	return o
}

func (o ToolOutputReferenceOutput) ToToolOutputReferenceOutputWithContext(ctx context.Context) ToolOutputReferenceOutput {
	return o
}

func (o ToolOutputReferenceOutput) ToOutput(ctx context.Context) pulumix.Output[ToolOutputReference] {
	return pulumix.Output[ToolOutputReference]{
		OutputState: o.OutputState,
	}
}

// The creation time of the file. - In response: present if set by create/update request - In create/update request: optional
func (o ToolOutputReferenceOutput) CreationTime() TimestampPtrOutput {
	return o.ApplyT(func(v ToolOutputReference) *Timestamp { return v.CreationTime }).(TimestampPtrOutput)
}

// A FileReference to an output file. - In response: always set - In create/update request: always set
func (o ToolOutputReferenceOutput) Output() FileReferencePtrOutput {
	return o.ApplyT(func(v ToolOutputReference) *FileReference { return v.Output }).(FileReferencePtrOutput)
}

// The test case to which this output file belongs. - In response: present if set by create/update request - In create/update request: optional
func (o ToolOutputReferenceOutput) TestCase() TestCaseReferencePtrOutput {
	return o.ApplyT(func(v ToolOutputReference) *TestCaseReference { return v.TestCase }).(TestCaseReferencePtrOutput)
}

type ToolOutputReferenceArrayOutput struct{ *pulumi.OutputState }

func (ToolOutputReferenceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ToolOutputReference)(nil)).Elem()
}

func (o ToolOutputReferenceArrayOutput) ToToolOutputReferenceArrayOutput() ToolOutputReferenceArrayOutput {
	return o
}

func (o ToolOutputReferenceArrayOutput) ToToolOutputReferenceArrayOutputWithContext(ctx context.Context) ToolOutputReferenceArrayOutput {
	return o
}

func (o ToolOutputReferenceArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]ToolOutputReference] {
	return pulumix.Output[[]ToolOutputReference]{
		OutputState: o.OutputState,
	}
}

func (o ToolOutputReferenceArrayOutput) Index(i pulumi.IntInput) ToolOutputReferenceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ToolOutputReference {
		return vs[0].([]ToolOutputReference)[vs[1].(int)]
	}).(ToolOutputReferenceOutput)
}

// A reference to a ToolExecution output file.
type ToolOutputReferenceResponse struct {
	// The creation time of the file. - In response: present if set by create/update request - In create/update request: optional
	CreationTime TimestampResponse `pulumi:"creationTime"`
	// A FileReference to an output file. - In response: always set - In create/update request: always set
	Output FileReferenceResponse `pulumi:"output"`
	// The test case to which this output file belongs. - In response: present if set by create/update request - In create/update request: optional
	TestCase TestCaseReferenceResponse `pulumi:"testCase"`
}

// A reference to a ToolExecution output file.
type ToolOutputReferenceResponseOutput struct{ *pulumi.OutputState }

func (ToolOutputReferenceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ToolOutputReferenceResponse)(nil)).Elem()
}

func (o ToolOutputReferenceResponseOutput) ToToolOutputReferenceResponseOutput() ToolOutputReferenceResponseOutput {
	return o
}

func (o ToolOutputReferenceResponseOutput) ToToolOutputReferenceResponseOutputWithContext(ctx context.Context) ToolOutputReferenceResponseOutput {
	return o
}

func (o ToolOutputReferenceResponseOutput) ToOutput(ctx context.Context) pulumix.Output[ToolOutputReferenceResponse] {
	return pulumix.Output[ToolOutputReferenceResponse]{
		OutputState: o.OutputState,
	}
}

// The creation time of the file. - In response: present if set by create/update request - In create/update request: optional
func (o ToolOutputReferenceResponseOutput) CreationTime() TimestampResponseOutput {
	return o.ApplyT(func(v ToolOutputReferenceResponse) TimestampResponse { return v.CreationTime }).(TimestampResponseOutput)
}

// A FileReference to an output file. - In response: always set - In create/update request: always set
func (o ToolOutputReferenceResponseOutput) Output() FileReferenceResponseOutput {
	return o.ApplyT(func(v ToolOutputReferenceResponse) FileReferenceResponse { return v.Output }).(FileReferenceResponseOutput)
}

// The test case to which this output file belongs. - In response: present if set by create/update request - In create/update request: optional
func (o ToolOutputReferenceResponseOutput) TestCase() TestCaseReferenceResponseOutput {
	return o.ApplyT(func(v ToolOutputReferenceResponse) TestCaseReferenceResponse { return v.TestCase }).(TestCaseReferenceResponseOutput)
}

type ToolOutputReferenceResponseArrayOutput struct{ *pulumi.OutputState }

func (ToolOutputReferenceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ToolOutputReferenceResponse)(nil)).Elem()
}

func (o ToolOutputReferenceResponseArrayOutput) ToToolOutputReferenceResponseArrayOutput() ToolOutputReferenceResponseArrayOutput {
	return o
}

func (o ToolOutputReferenceResponseArrayOutput) ToToolOutputReferenceResponseArrayOutputWithContext(ctx context.Context) ToolOutputReferenceResponseArrayOutput {
	return o
}

func (o ToolOutputReferenceResponseArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]ToolOutputReferenceResponse] {
	return pulumix.Output[[]ToolOutputReferenceResponse]{
		OutputState: o.OutputState,
	}
}

func (o ToolOutputReferenceResponseArrayOutput) Index(i pulumi.IntInput) ToolOutputReferenceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ToolOutputReferenceResponse {
		return vs[0].([]ToolOutputReferenceResponse)[vs[1].(int)]
	}).(ToolOutputReferenceResponseOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AndroidAppInfoInput)(nil)).Elem(), AndroidAppInfoArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AndroidAppInfoPtrInput)(nil)).Elem(), AndroidAppInfoArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AndroidInstrumentationTestInput)(nil)).Elem(), AndroidInstrumentationTestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AndroidInstrumentationTestPtrInput)(nil)).Elem(), AndroidInstrumentationTestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AndroidRoboTestInput)(nil)).Elem(), AndroidRoboTestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AndroidRoboTestPtrInput)(nil)).Elem(), AndroidRoboTestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AndroidTestInput)(nil)).Elem(), AndroidTestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AndroidTestPtrInput)(nil)).Elem(), AndroidTestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AndroidTestLoopInput)(nil)).Elem(), AndroidTestLoopArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AndroidTestLoopPtrInput)(nil)).Elem(), AndroidTestLoopArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AnyInput)(nil)).Elem(), AnyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AnyPtrInput)(nil)).Elem(), AnyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicPerfSampleSeriesInput)(nil)).Elem(), BasicPerfSampleSeriesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicPerfSampleSeriesPtrInput)(nil)).Elem(), BasicPerfSampleSeriesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DurationInput)(nil)).Elem(), DurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DurationPtrInput)(nil)).Elem(), DurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FailureDetailInput)(nil)).Elem(), FailureDetailArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FailureDetailPtrInput)(nil)).Elem(), FailureDetailArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FileReferenceInput)(nil)).Elem(), FileReferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FileReferencePtrInput)(nil)).Elem(), FileReferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FileReferenceArrayInput)(nil)).Elem(), FileReferenceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InconclusiveDetailInput)(nil)).Elem(), InconclusiveDetailArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InconclusiveDetailPtrInput)(nil)).Elem(), InconclusiveDetailArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndividualOutcomeInput)(nil)).Elem(), IndividualOutcomeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndividualOutcomeArrayInput)(nil)).Elem(), IndividualOutcomeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IosAppInfoInput)(nil)).Elem(), IosAppInfoArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IosAppInfoPtrInput)(nil)).Elem(), IosAppInfoArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IosRoboTestInput)(nil)).Elem(), IosRoboTestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IosRoboTestPtrInput)(nil)).Elem(), IosRoboTestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IosTestInput)(nil)).Elem(), IosTestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IosTestPtrInput)(nil)).Elem(), IosTestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IosTestLoopInput)(nil)).Elem(), IosTestLoopArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IosTestLoopPtrInput)(nil)).Elem(), IosTestLoopArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IosXcTestInput)(nil)).Elem(), IosXcTestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IosXcTestPtrInput)(nil)).Elem(), IosXcTestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MatrixDimensionDefinitionInput)(nil)).Elem(), MatrixDimensionDefinitionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MatrixDimensionDefinitionArrayInput)(nil)).Elem(), MatrixDimensionDefinitionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MultiStepInput)(nil)).Elem(), MultiStepArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MultiStepPtrInput)(nil)).Elem(), MultiStepArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OutcomeInput)(nil)).Elem(), OutcomeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OutcomePtrInput)(nil)).Elem(), OutcomeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PrimaryStepInput)(nil)).Elem(), PrimaryStepArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PrimaryStepPtrInput)(nil)).Elem(), PrimaryStepArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SkippedDetailInput)(nil)).Elem(), SkippedDetailArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SkippedDetailPtrInput)(nil)).Elem(), SkippedDetailArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SpecificationInput)(nil)).Elem(), SpecificationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SpecificationPtrInput)(nil)).Elem(), SpecificationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StackTraceInput)(nil)).Elem(), StackTraceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StackTracePtrInput)(nil)).Elem(), StackTraceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StepDimensionValueEntryInput)(nil)).Elem(), StepDimensionValueEntryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StepDimensionValueEntryArrayInput)(nil)).Elem(), StepDimensionValueEntryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*StepLabelsEntryInput)(nil)).Elem(), StepLabelsEntryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StepLabelsEntryArrayInput)(nil)).Elem(), StepLabelsEntryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SuccessDetailInput)(nil)).Elem(), SuccessDetailArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SuccessDetailPtrInput)(nil)).Elem(), SuccessDetailArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TestCaseReferenceInput)(nil)).Elem(), TestCaseReferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TestCaseReferencePtrInput)(nil)).Elem(), TestCaseReferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TestExecutionStepInput)(nil)).Elem(), TestExecutionStepArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TestExecutionStepPtrInput)(nil)).Elem(), TestExecutionStepArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TestIssueInput)(nil)).Elem(), TestIssueArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TestIssueArrayInput)(nil)).Elem(), TestIssueArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TestSuiteOverviewInput)(nil)).Elem(), TestSuiteOverviewArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TestSuiteOverviewArrayInput)(nil)).Elem(), TestSuiteOverviewArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TestTimingInput)(nil)).Elem(), TestTimingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TestTimingPtrInput)(nil)).Elem(), TestTimingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimestampInput)(nil)).Elem(), TimestampArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimestampPtrInput)(nil)).Elem(), TimestampArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ToolExecutionInput)(nil)).Elem(), ToolExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ToolExecutionPtrInput)(nil)).Elem(), ToolExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ToolExecutionStepInput)(nil)).Elem(), ToolExecutionStepArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ToolExecutionStepPtrInput)(nil)).Elem(), ToolExecutionStepArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ToolExitCodeInput)(nil)).Elem(), ToolExitCodeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ToolExitCodePtrInput)(nil)).Elem(), ToolExitCodeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ToolOutputReferenceInput)(nil)).Elem(), ToolOutputReferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ToolOutputReferenceArrayInput)(nil)).Elem(), ToolOutputReferenceArray{})
	pulumi.RegisterOutputType(AndroidAppInfoOutput{})
	pulumi.RegisterOutputType(AndroidAppInfoPtrOutput{})
	pulumi.RegisterOutputType(AndroidAppInfoResponseOutput{})
	pulumi.RegisterOutputType(AndroidInstrumentationTestOutput{})
	pulumi.RegisterOutputType(AndroidInstrumentationTestPtrOutput{})
	pulumi.RegisterOutputType(AndroidInstrumentationTestResponseOutput{})
	pulumi.RegisterOutputType(AndroidRoboTestOutput{})
	pulumi.RegisterOutputType(AndroidRoboTestPtrOutput{})
	pulumi.RegisterOutputType(AndroidRoboTestResponseOutput{})
	pulumi.RegisterOutputType(AndroidTestOutput{})
	pulumi.RegisterOutputType(AndroidTestPtrOutput{})
	pulumi.RegisterOutputType(AndroidTestLoopOutput{})
	pulumi.RegisterOutputType(AndroidTestLoopPtrOutput{})
	pulumi.RegisterOutputType(AndroidTestLoopResponseOutput{})
	pulumi.RegisterOutputType(AndroidTestResponseOutput{})
	pulumi.RegisterOutputType(AnyOutput{})
	pulumi.RegisterOutputType(AnyPtrOutput{})
	pulumi.RegisterOutputType(AnyResponseOutput{})
	pulumi.RegisterOutputType(BasicPerfSampleSeriesOutput{})
	pulumi.RegisterOutputType(BasicPerfSampleSeriesPtrOutput{})
	pulumi.RegisterOutputType(BasicPerfSampleSeriesResponseOutput{})
	pulumi.RegisterOutputType(DurationOutput{})
	pulumi.RegisterOutputType(DurationPtrOutput{})
	pulumi.RegisterOutputType(DurationResponseOutput{})
	pulumi.RegisterOutputType(FailureDetailOutput{})
	pulumi.RegisterOutputType(FailureDetailPtrOutput{})
	pulumi.RegisterOutputType(FailureDetailResponseOutput{})
	pulumi.RegisterOutputType(FileReferenceOutput{})
	pulumi.RegisterOutputType(FileReferencePtrOutput{})
	pulumi.RegisterOutputType(FileReferenceArrayOutput{})
	pulumi.RegisterOutputType(FileReferenceResponseOutput{})
	pulumi.RegisterOutputType(FileReferenceResponseArrayOutput{})
	pulumi.RegisterOutputType(InconclusiveDetailOutput{})
	pulumi.RegisterOutputType(InconclusiveDetailPtrOutput{})
	pulumi.RegisterOutputType(InconclusiveDetailResponseOutput{})
	pulumi.RegisterOutputType(IndividualOutcomeOutput{})
	pulumi.RegisterOutputType(IndividualOutcomeArrayOutput{})
	pulumi.RegisterOutputType(IndividualOutcomeResponseOutput{})
	pulumi.RegisterOutputType(IndividualOutcomeResponseArrayOutput{})
	pulumi.RegisterOutputType(IosAppInfoOutput{})
	pulumi.RegisterOutputType(IosAppInfoPtrOutput{})
	pulumi.RegisterOutputType(IosAppInfoResponseOutput{})
	pulumi.RegisterOutputType(IosRoboTestOutput{})
	pulumi.RegisterOutputType(IosRoboTestPtrOutput{})
	pulumi.RegisterOutputType(IosRoboTestResponseOutput{})
	pulumi.RegisterOutputType(IosTestOutput{})
	pulumi.RegisterOutputType(IosTestPtrOutput{})
	pulumi.RegisterOutputType(IosTestLoopOutput{})
	pulumi.RegisterOutputType(IosTestLoopPtrOutput{})
	pulumi.RegisterOutputType(IosTestLoopResponseOutput{})
	pulumi.RegisterOutputType(IosTestResponseOutput{})
	pulumi.RegisterOutputType(IosXcTestOutput{})
	pulumi.RegisterOutputType(IosXcTestPtrOutput{})
	pulumi.RegisterOutputType(IosXcTestResponseOutput{})
	pulumi.RegisterOutputType(MatrixDimensionDefinitionOutput{})
	pulumi.RegisterOutputType(MatrixDimensionDefinitionArrayOutput{})
	pulumi.RegisterOutputType(MatrixDimensionDefinitionResponseOutput{})
	pulumi.RegisterOutputType(MatrixDimensionDefinitionResponseArrayOutput{})
	pulumi.RegisterOutputType(MultiStepOutput{})
	pulumi.RegisterOutputType(MultiStepPtrOutput{})
	pulumi.RegisterOutputType(MultiStepResponseOutput{})
	pulumi.RegisterOutputType(OutcomeOutput{})
	pulumi.RegisterOutputType(OutcomePtrOutput{})
	pulumi.RegisterOutputType(OutcomeResponseOutput{})
	pulumi.RegisterOutputType(PrimaryStepOutput{})
	pulumi.RegisterOutputType(PrimaryStepPtrOutput{})
	pulumi.RegisterOutputType(PrimaryStepResponseOutput{})
	pulumi.RegisterOutputType(SkippedDetailOutput{})
	pulumi.RegisterOutputType(SkippedDetailPtrOutput{})
	pulumi.RegisterOutputType(SkippedDetailResponseOutput{})
	pulumi.RegisterOutputType(SpecificationOutput{})
	pulumi.RegisterOutputType(SpecificationPtrOutput{})
	pulumi.RegisterOutputType(SpecificationResponseOutput{})
	pulumi.RegisterOutputType(StackTraceOutput{})
	pulumi.RegisterOutputType(StackTracePtrOutput{})
	pulumi.RegisterOutputType(StackTraceResponseOutput{})
	pulumi.RegisterOutputType(StepDimensionValueEntryOutput{})
	pulumi.RegisterOutputType(StepDimensionValueEntryArrayOutput{})
	pulumi.RegisterOutputType(StepDimensionValueEntryResponseOutput{})
	pulumi.RegisterOutputType(StepDimensionValueEntryResponseArrayOutput{})
	pulumi.RegisterOutputType(StepLabelsEntryOutput{})
	pulumi.RegisterOutputType(StepLabelsEntryArrayOutput{})
	pulumi.RegisterOutputType(StepLabelsEntryResponseOutput{})
	pulumi.RegisterOutputType(StepLabelsEntryResponseArrayOutput{})
	pulumi.RegisterOutputType(SuccessDetailOutput{})
	pulumi.RegisterOutputType(SuccessDetailPtrOutput{})
	pulumi.RegisterOutputType(SuccessDetailResponseOutput{})
	pulumi.RegisterOutputType(TestCaseReferenceOutput{})
	pulumi.RegisterOutputType(TestCaseReferencePtrOutput{})
	pulumi.RegisterOutputType(TestCaseReferenceResponseOutput{})
	pulumi.RegisterOutputType(TestExecutionStepOutput{})
	pulumi.RegisterOutputType(TestExecutionStepPtrOutput{})
	pulumi.RegisterOutputType(TestExecutionStepResponseOutput{})
	pulumi.RegisterOutputType(TestIssueOutput{})
	pulumi.RegisterOutputType(TestIssueArrayOutput{})
	pulumi.RegisterOutputType(TestIssueResponseOutput{})
	pulumi.RegisterOutputType(TestIssueResponseArrayOutput{})
	pulumi.RegisterOutputType(TestSuiteOverviewOutput{})
	pulumi.RegisterOutputType(TestSuiteOverviewArrayOutput{})
	pulumi.RegisterOutputType(TestSuiteOverviewResponseOutput{})
	pulumi.RegisterOutputType(TestSuiteOverviewResponseArrayOutput{})
	pulumi.RegisterOutputType(TestTimingOutput{})
	pulumi.RegisterOutputType(TestTimingPtrOutput{})
	pulumi.RegisterOutputType(TestTimingResponseOutput{})
	pulumi.RegisterOutputType(TimestampOutput{})
	pulumi.RegisterOutputType(TimestampPtrOutput{})
	pulumi.RegisterOutputType(TimestampResponseOutput{})
	pulumi.RegisterOutputType(ToolExecutionOutput{})
	pulumi.RegisterOutputType(ToolExecutionPtrOutput{})
	pulumi.RegisterOutputType(ToolExecutionResponseOutput{})
	pulumi.RegisterOutputType(ToolExecutionStepOutput{})
	pulumi.RegisterOutputType(ToolExecutionStepPtrOutput{})
	pulumi.RegisterOutputType(ToolExecutionStepResponseOutput{})
	pulumi.RegisterOutputType(ToolExitCodeOutput{})
	pulumi.RegisterOutputType(ToolExitCodePtrOutput{})
	pulumi.RegisterOutputType(ToolExitCodeResponseOutput{})
	pulumi.RegisterOutputType(ToolOutputReferenceOutput{})
	pulumi.RegisterOutputType(ToolOutputReferenceArrayOutput{})
	pulumi.RegisterOutputType(ToolOutputReferenceResponseOutput{})
	pulumi.RegisterOutputType(ToolOutputReferenceResponseArrayOutput{})
}

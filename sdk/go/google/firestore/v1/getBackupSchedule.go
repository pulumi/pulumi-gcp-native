// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Gets information about a backup schedule.
func LookupBackupSchedule(ctx *pulumi.Context, args *LookupBackupScheduleArgs, opts ...pulumi.InvokeOption) (*LookupBackupScheduleResult, error) {
	opts = internal.PkgInvokeDefaultOpts(opts)
	var rv LookupBackupScheduleResult
	err := ctx.Invoke("google-native:firestore/v1:getBackupSchedule", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

type LookupBackupScheduleArgs struct {
	BackupScheduleId string  `pulumi:"backupScheduleId"`
	DatabaseId       string  `pulumi:"databaseId"`
	Project          *string `pulumi:"project"`
}

type LookupBackupScheduleResult struct {
	// The timestamp at which this backup schedule was created and effective since. No backups will be created for this schedule before this time.
	CreateTime string `pulumi:"createTime"`
	// For a schedule that runs daily at a specified time.
	DailyRecurrence GoogleFirestoreAdminV1DailyRecurrenceResponse `pulumi:"dailyRecurrence"`
	// The unique backup schedule identifier across all locations and databases for the given project. This will be auto-assigned. Format is `projects/{project}/databases/{database}/backupSchedules/{backup_schedule}`
	Name string `pulumi:"name"`
	// At what relative time in the future, compared to the creation time of the backup should the backup be deleted, i.e. keep backups for 7 days.
	Retention string `pulumi:"retention"`
	// The timestamp at which this backup schedule was most recently updated. When a backup schedule is first created, this is the same as create_time.
	UpdateTime string `pulumi:"updateTime"`
	// For a schedule that runs weekly on a specific day and time.
	WeeklyRecurrence GoogleFirestoreAdminV1WeeklyRecurrenceResponse `pulumi:"weeklyRecurrence"`
}

func LookupBackupScheduleOutput(ctx *pulumi.Context, args LookupBackupScheduleOutputArgs, opts ...pulumi.InvokeOption) LookupBackupScheduleResultOutput {
	return pulumi.ToOutputWithContext(context.Background(), args).
		ApplyT(func(v interface{}) (LookupBackupScheduleResult, error) {
			args := v.(LookupBackupScheduleArgs)
			r, err := LookupBackupSchedule(ctx, &args, opts...)
			var s LookupBackupScheduleResult
			if r != nil {
				s = *r
			}
			return s, err
		}).(LookupBackupScheduleResultOutput)
}

type LookupBackupScheduleOutputArgs struct {
	BackupScheduleId pulumi.StringInput    `pulumi:"backupScheduleId"`
	DatabaseId       pulumi.StringInput    `pulumi:"databaseId"`
	Project          pulumi.StringPtrInput `pulumi:"project"`
}

func (LookupBackupScheduleOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupBackupScheduleArgs)(nil)).Elem()
}

type LookupBackupScheduleResultOutput struct{ *pulumi.OutputState }

func (LookupBackupScheduleResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupBackupScheduleResult)(nil)).Elem()
}

func (o LookupBackupScheduleResultOutput) ToLookupBackupScheduleResultOutput() LookupBackupScheduleResultOutput {
	return o
}

func (o LookupBackupScheduleResultOutput) ToLookupBackupScheduleResultOutputWithContext(ctx context.Context) LookupBackupScheduleResultOutput {
	return o
}

// The timestamp at which this backup schedule was created and effective since. No backups will be created for this schedule before this time.
func (o LookupBackupScheduleResultOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v LookupBackupScheduleResult) string { return v.CreateTime }).(pulumi.StringOutput)
}

// For a schedule that runs daily at a specified time.
func (o LookupBackupScheduleResultOutput) DailyRecurrence() GoogleFirestoreAdminV1DailyRecurrenceResponseOutput {
	return o.ApplyT(func(v LookupBackupScheduleResult) GoogleFirestoreAdminV1DailyRecurrenceResponse {
		return v.DailyRecurrence
	}).(GoogleFirestoreAdminV1DailyRecurrenceResponseOutput)
}

// The unique backup schedule identifier across all locations and databases for the given project. This will be auto-assigned. Format is `projects/{project}/databases/{database}/backupSchedules/{backup_schedule}`
func (o LookupBackupScheduleResultOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v LookupBackupScheduleResult) string { return v.Name }).(pulumi.StringOutput)
}

// At what relative time in the future, compared to the creation time of the backup should the backup be deleted, i.e. keep backups for 7 days.
func (o LookupBackupScheduleResultOutput) Retention() pulumi.StringOutput {
	return o.ApplyT(func(v LookupBackupScheduleResult) string { return v.Retention }).(pulumi.StringOutput)
}

// The timestamp at which this backup schedule was most recently updated. When a backup schedule is first created, this is the same as create_time.
func (o LookupBackupScheduleResultOutput) UpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v LookupBackupScheduleResult) string { return v.UpdateTime }).(pulumi.StringOutput)
}

// For a schedule that runs weekly on a specific day and time.
func (o LookupBackupScheduleResultOutput) WeeklyRecurrence() GoogleFirestoreAdminV1WeeklyRecurrenceResponseOutput {
	return o.ApplyT(func(v LookupBackupScheduleResult) GoogleFirestoreAdminV1WeeklyRecurrenceResponse {
		return v.WeeklyRecurrence
	}).(GoogleFirestoreAdminV1WeeklyRecurrenceResponseOutput)
}

func init() {
	pulumi.RegisterOutputType(LookupBackupScheduleResultOutput{})
}

// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../../../types/input";
import * as outputs from "../../../types/output";
import * as enums from "../../../types/enums";
import * as utilities from "../../../utilities";

/**
 * Specifies a selection of tags and an `Action` to apply to each one.
 */
export interface ActionResponse {
    /**
     * Inspect image and transform sensitive burnt-in text. Doesn't apply to elements nested in a sequence, which revert to `Keep`. Supported [tags](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html): PixelData
     */
    cleanImageTag: outputs.healthcare.v1beta1.ImageConfigResponse;
    /**
     * Inspect text and transform sensitive text. Configurable via TextConfig. Supported Value Representations: AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
     */
    cleanTextTag: outputs.healthcare.v1beta1.CleanTextTagResponse;
    /**
     * Delete tag.
     */
    deleteTag: outputs.healthcare.v1beta1.DeleteTagResponse;
    /**
     * Keep tag unchanged.
     */
    keepTag: outputs.healthcare.v1beta1.KeepTagResponse;
    /**
     * Select all tags with the listed tag IDs, names, or Value Representations (VRs). Examples: ID: "00100010" Keyword: "PatientName" VR: "PN"
     */
    queries: string[];
    /**
     * Recursively apply DICOM de-id to tags nested in a sequence. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): SQ
     */
    recurseTag: outputs.healthcare.v1beta1.RecurseTagResponse;
    /**
     * Replace UID with a new generated UID. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): UI
     */
    regenUidTag: outputs.healthcare.v1beta1.RegenUidTagResponse;
    /**
     * Replace with empty tag.
     */
    removeTag: outputs.healthcare.v1beta1.RemoveTagResponse;
    /**
     * Reset tag to a placeholder value.
     */
    resetTag: outputs.healthcare.v1beta1.ResetTagResponse;
}

/**
 * Specifies how to store annotations during de-identification operation.
 */
export interface AnnotationConfigResponse {
    /**
     * The name of the annotation store, in the form `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/annotationStores/{annotation_store_id}`). * The destination annotation store must be in the same project as the source data. De-identifying data across multiple projects is not supported. * The destination annotation store must exist when using DeidentifyDicomStore or DeidentifyFhirStore. DeidentifyDataset automatically creates the destination annotation store.
     */
    annotationStoreName: string;
    /**
     * If set to true, the sensitive texts are included in SensitiveTextAnnotation of Annotation.
     */
    storeQuote: boolean;
}

/**
 * AnnotationSource holds the source information of the annotation.
 */
export interface AnnotationSourceResponse {
    /**
     * Cloud Healthcare API resource.
     */
    cloudHealthcareSource: outputs.healthcare.v1beta1.CloudHealthcareSourceResponse;
}

/**
 * An attribute value for a Consent or User data mapping. Each Attribute must have a corresponding AttributeDefinition in the consent store that defines the default and allowed values.
 */
export interface AttributeResponse {
    /**
     * Indicates the name of an attribute defined in the consent store.
     */
    attributeDefinitionId: string;
    /**
     * The value of the attribute. Must be an acceptable value as defined in the consent store. For example, if the consent store defines "data type" with acceptable values "questionnaire" and "step-count", when the attribute name is data type, this field must contain one of those values.
     */
    values: string[];
}

/**
 * Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
 */
export interface AuditConfigResponse {
    /**
     * The configuration for logging of each type of permission.
     */
    auditLogConfigs: outputs.healthcare.v1beta1.AuditLogConfigResponse[];
    /**
     * Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
     */
    service: string;
}

/**
 * Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
 */
export interface AuditLogConfigResponse {
    /**
     * Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
     */
    exemptedMembers: string[];
    /**
     * The log type that this config enables.
     */
    logType: string;
}

/**
 * Associates `members`, or principals, with a `role`.
 */
export interface BindingResponse {
    /**
     * The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
     */
    condition: outputs.healthcare.v1beta1.ExprResponse;
    /**
     * Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. 
     */
    members: string[];
    /**
     * Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
     */
    role: string;
}

/**
 * A bounding polygon for the detected image annotation.
 */
export interface BoundingPolyResponse {
    /**
     * A description of this polygon.
     */
    label: string;
    /**
     * List of the vertices of this polygon.
     */
    vertices: outputs.healthcare.v1beta1.VertexResponse[];
}

/**
 * Mask a string by replacing its characters with a fixed character.
 */
export interface CharacterMaskConfigResponse {
    /**
     * Character to mask the sensitive values. If not supplied, defaults to "*".
     */
    maskingCharacter: string;
}

/**
 * Replace field value with masking character. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml
 */
export interface CharacterMaskFieldResponse {
}

/**
 * This option is based on the DICOM Standard's [Clean Descriptors Option](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/sect_E.3.5.html), and the `CleanText` `Action` is applied to all the specified fields. When cleaning text, the process attempts to transform phrases matching any of the tags marked for removal (action codes D, Z, X, and U) in the [Basic Profile](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/chapter_E.html). These contextual phrases are replaced with the token "[CTX]". This option uses an additional `InfoType` during inspection.
 */
export interface CleanDescriptorsOptionResponse {
}

/**
 * Inspect text and transform sensitive text. Configure using `TextConfig`. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Date, DateTime, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml
 */
export interface CleanTextFieldResponse {
}

/**
 * Inspect text and transform sensitive text. Configurable using `TextConfig`. Supported [Value Representations] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
 */
export interface CleanTextTagResponse {
}

/**
 * Cloud Healthcare API resource.
 */
export interface CloudHealthcareSourceResponse {
    /**
     * Full path of a Cloud Healthcare API resource.
     */
    name: string;
}

/**
 * The fields that aren't marked `Keep` or `CleanText` in the `BASIC` profile are collected into a contextual phrase list. For fields marked `CleanText`, the process attempts to transform phrases matching these contextual entries. These contextual phrases are replaced with the token "[CTX]". This feature uses an additional InfoType during inspection.
 */
export interface ContextualDeidConfigResponse {
}

/**
 * Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. Outputs a base64-encoded representation of the hashed output. For example, `L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=`.
 */
export interface CryptoHashConfigResponse {
    /**
     * An AES 128/192/256 bit key. Causes the hash to be computed based on this key. A default key is generated for each Deidentify operation and is used when neither `crypto_key` nor `kms_wrapped` is specified. Must not be set if `kms_wrapped` is set.
     */
    cryptoKey: string;
    /**
     * KMS wrapped key. Must not be set if `crypto_key` is set.
     */
    kmsWrapped: outputs.healthcare.v1beta1.KmsWrappedCryptoKeyResponse;
}

/**
 * Replace field value with a hash of that value. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml
 */
export interface CryptoHashFieldResponse {
}

/**
 * Shift a date forward or backward in time by a random amount which is consistent for a given patient and crypto key combination.
 */
export interface DateShiftConfigResponse {
    /**
     * An AES 128/192/256 bit key. Causes the shift to be computed based on this key and the patient ID. A default key is generated for each de-identification operation and is used when neither `crypto_key` nor `kms_wrapped` is specified. Must not be set if `kms_wrapped` is set.
     */
    cryptoKey: string;
    /**
     * KMS wrapped key. Must not be set if `crypto_key` is set.
     */
    kmsWrapped: outputs.healthcare.v1beta1.KmsWrappedCryptoKeyResponse;
}

/**
 * Shift the date by a randomized number of days. See [date shifting](https://cloud.google.com/dlp/docs/concepts-date-shifting) for more information. Supported [types](https://www.hl7.org/fhir/datatypes.html): Date, DateTime
 */
export interface DateShiftFieldResponse {
}

/**
 * Contains configuration for streaming de-identified FHIR export.
 */
export interface DeidentifiedStoreDestinationResponse {
    /**
     * The configuration to use when de-identifying resources that are added to this store.
     */
    config: outputs.healthcare.v1beta1.DeidentifyConfigResponse;
    /**
     * The full resource name of a Cloud Healthcare FHIR store, for example, `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.
     */
    store: string;
}

/**
 * Configures de-id options specific to different types of content. Each submessage customizes the handling of an https://tools.ietf.org/html/rfc6838 media type or subtype. Configs are applied in a nested manner at runtime.
 */
export interface DeidentifyConfigResponse {
    /**
     * Configures how annotations, meaning that the location and infoType of sensitive information findings, are created during de-identification. If unspecified, no annotations are created.
     */
    annotation: outputs.healthcare.v1beta1.AnnotationConfigResponse;
    /**
     * Configures de-id of application/DICOM content. Deprecated. Use `dicom_tag_config` instead.
     *
     * @deprecated Configures de-id of application/DICOM content. Deprecated. Use `dicom_tag_config` instead.
     */
    dicom: outputs.healthcare.v1beta1.DicomConfigResponse;
    /**
     * Configures de-id of application/DICOM content.
     */
    dicomTagConfig: outputs.healthcare.v1beta1.DicomTagConfigResponse;
    /**
     * Configures de-id of application/FHIR content. Deprecated. Use `fhir_field_config` instead.
     *
     * @deprecated Configures de-id of application/FHIR content. Deprecated. Use `fhir_field_config` instead.
     */
    fhir: outputs.healthcare.v1beta1.FhirConfigResponse;
    /**
     * Configures de-id of application/FHIR content.
     */
    fhirFieldConfig: outputs.healthcare.v1beta1.FhirFieldConfigResponse;
    /**
     * Configures the de-identification of image pixels in the source_dataset. Deprecated. Use `dicom_tag_config.options.clean_image` instead.
     *
     * @deprecated Configures the de-identification of image pixels in the source_dataset. Deprecated. Use `dicom_tag_config.options.clean_image` instead.
     */
    image: outputs.healthcare.v1beta1.ImageConfigResponse;
    /**
     * Details about the work the de-identify operation performed.
     */
    operationMetadata: outputs.healthcare.v1beta1.DeidentifyOperationMetadataResponse;
    /**
     * Configures de-identification of text wherever it is found in the source_dataset.
     */
    text: outputs.healthcare.v1beta1.TextConfigResponse;
}

/**
 * Details about the work the de-identify operation performed.
 */
export interface DeidentifyOperationMetadataResponse {
    /**
     * Details about the FHIR store to write the output to.
     */
    fhirOutput: outputs.healthcare.v1beta1.FhirOutputResponse;
}

/**
 * Delete tag.
 */
export interface DeleteTagResponse {
}

/**
 * Specifies the parameters needed for de-identification of DICOM stores.
 */
export interface DicomConfigResponse {
    /**
     * Tag filtering profile that determines which tags to keep/remove.
     */
    filterProfile: string;
    /**
     * List of tags to keep. Remove all other tags.
     */
    keepList: outputs.healthcare.v1beta1.TagFilterListResponse;
    /**
     * List of tags to remove. Keep all other tags.
     */
    removeList: outputs.healthcare.v1beta1.TagFilterListResponse;
    /**
     * If true, skip replacing StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID, and MediaStorageSOPInstanceUID and leave them untouched. The Cloud Healthcare API regenerates these UIDs by default based on the DICOM Standard's reasoning: "Whilst these UIDs cannot be mapped directly to an individual out of context, given access to the original images, or to a database of the original images containing the UIDs, it would be possible to recover the individual's identity." http://dicom.nema.org/medical/dicom/current/output/chtml/part15/sect_E.3.9.html
     */
    skipIdRedaction: boolean;
}

/**
 * Specifies the parameters needed for the de-identification of DICOM stores.
 */
export interface DicomTagConfigResponse {
    /**
     * Specifies custom tag selections and `Actions` to apply to them. Overrides `options` and `profile`. Conflicting `Actions` are applied in the order given.
     */
    actions: outputs.healthcare.v1beta1.ActionResponse[];
    /**
     * Specifies additional options to apply, overriding the base `profile`.
     */
    options: outputs.healthcare.v1beta1.OptionsResponse;
    /**
     * Base profile type for handling DICOM tags.
     */
    profileType: string;
}

/**
 * Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
 */
export interface ExprResponse {
    /**
     * Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
     */
    description: string;
    /**
     * Textual representation of an expression in Common Expression Language syntax.
     */
    expression: string;
    /**
     * Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
     */
    location: string;
    /**
     * Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
     */
    title: string;
}

/**
 * Specifies how to handle de-identification of a FHIR store.
 */
export interface FhirConfigResponse {
    /**
     * The behaviour for handling FHIR extensions that aren't otherwise specified for de-identification. If true, all extensions are preserved during de-identification by default. If false or unspecified, all extensions are removed during de-identification by default.
     */
    defaultKeepExtensions: boolean;
    /**
     * Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata is passed through to the output dataset unmodified. All extensions will be processed according to `default_keep_extensions`. If a field can be matched by more than one FieldMetadata, the first FieldMetadata.Action is applied.
     */
    fieldMetadataList: outputs.healthcare.v1beta1.FieldMetadataResponse[];
}

/**
 * Specifies how to handle the de-identification of a FHIR store.
 */
export interface FhirFieldConfigResponse {
    /**
     * Specifies FHIR paths to match and how to transform them. Any field that is not matched by a `FieldMetadata` is passed through to the output dataset unmodified. All extensions will be processed according to `keep_extensions`. If a field can be matched by more than one `FieldMetadata`, the first `FieldMetadata.Action` is applied. Overrides `options` and `profile`.
     */
    fieldMetadataList: outputs.healthcare.v1beta1.GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse[];
    /**
     * Specifies additional options, overriding the base `profile`.
     */
    options: outputs.healthcare.v1beta1.GoogleCloudHealthcareV1beta1DeidentifyOptionsResponse;
    /**
     * Base profile type for handling FHIR fields.
     */
    profileType: string;
}

/**
 * Contains the configuration for FHIR notifications.
 */
export interface FhirNotificationConfigResponse {
    /**
     * The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. The Cloud Healthcare API service account, service-@gcp-sa-healthcare.iam.gserviceaccount.com, must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare-api/docs/how-tos/logging).
     */
    pubsubTopic: string;
    /**
     * Whether to send full FHIR resource to this Pub/Sub topic for Create and Update operation. Note that setting this to true does not guarantee that all resources will be sent in the format of full FHIR resource. When a resource change is too large or during heavy traffic, only the resource name will be sent. Clients should always check the "payloadType" label from a Pub/Sub message to determine whether it needs to fetch the full resource as a separate operation.
     */
    sendFullResource: boolean;
}

/**
 * Details about the FHIR store to write the output to.
 */
export interface FhirOutputResponse {
    /**
     * Name of the output FHIR store, which must already exist. You must grant the healthcare.fhirResources.update permission on the destination store to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent). The destination store must set `enable_update_create` to true. The destination store must use FHIR version R4. Writing these resources will consume FHIR operations quota from the project containing the source data. De-identify operation metadata is only generated for DICOM de-identification operations.
     */
    fhirStore: string;
}

/**
 * Specifies FHIR paths to match, and how to handle de-identification of matching fields.
 */
export interface FieldMetadataResponse {
    /**
     * Deidentify action for one field.
     */
    action: string;
    /**
     * List of paths to FHIR fields to redact. Each path is a period-separated list where each component is either a field name or FHIR type name. All types begin with an upper case letter. For example, the resource field "Patient.Address.city", which uses a string type, can be matched by "Patient.Address.String". Path also supports partial matching. For example, "Patient.Address.city" can be matched by "Address.city" (Patient omitted). Partial matching and type matching can be combined. For example, "Patient.Address.city" can be matched by "Address.String". For "choice" types (those defined in the FHIR spec with the form: field[x]), use two separate components. For example, "deceasedAge.unit" is matched by "Deceased.Age.unit". Supported types are: AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime, Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid, PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml. The sub-type for HumanName(for example HumanName.given, HumanName.family) can be omitted.
     */
    paths: string[];
}

/**
 * A (sub) field of a type.
 */
export interface FieldResponse {
    /**
     * The maximum number of times this field can be repeated. 0 or -1 means unbounded.
     */
    maxOccurs: number;
    /**
     * The minimum number of times this field must be present/repeated.
     */
    minOccurs: number;
    /**
     * The name of the field. For example, "PID-1" or just "1".
     */
    name: string;
    /**
     * The HL7v2 table this field refers to. For example, PID-15 (Patient's Primary Language) usually refers to table "0296".
     */
    table: string;
    /**
     * The type of this field. A Type with this name must be defined in an Hl7TypesConfig.
     */
    type: string;
}

/**
 * Represents a user's consent in terms of the resources that can be accessed and under what conditions.
 */
export interface GoogleCloudHealthcareV1beta1ConsentPolicyResponse {
    /**
     * The request conditions to meet to grant access. In addition to any supported comparison operators, authorization rules may have `IN` operator as well as at most 10 logical operators that are limited to `AND` (`&&`), `OR` (`||`).
     */
    authorizationRule: outputs.healthcare.v1beta1.ExprResponse;
    /**
     * The resources that this policy applies to. A resource is a match if it matches all the attributes listed here. If empty, this policy applies to all User data mappings for the given user.
     */
    resourceAttributes: outputs.healthcare.v1beta1.AttributeResponse[];
}

/**
 * Specifies the FHIR paths to match and how to handle the de-identification of matching fields.
 */
export interface GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse {
    /**
     * Replace the field's value with a masking character. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml
     */
    characterMaskField: outputs.healthcare.v1beta1.CharacterMaskFieldResponse;
    /**
     * Inspect the field's text and transform sensitive text. Configure using `TextConfig`. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Date, DateTime, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml
     */
    cleanTextField: outputs.healthcare.v1beta1.CleanTextFieldResponse;
    /**
     * Replace field value with a hash of that value. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml
     */
    cryptoHashField: outputs.healthcare.v1beta1.CryptoHashFieldResponse;
    /**
     * Shift the date by a randomized number of days. See [date shifting](https://cloud.google.com/dlp/docs/concepts-date-shifting) for more information. Supported [types](https://www.hl7.org/fhir/datatypes.html): Date, DateTime
     */
    dateShiftField: outputs.healthcare.v1beta1.DateShiftFieldResponse;
    /**
     * Keep the field unchanged.
     */
    keepField: outputs.healthcare.v1beta1.KeepFieldResponse;
    /**
     * List of paths to FHIR fields to redact. Each path is a period-separated list where each component is either a field name or FHIR type name. All types begin with an upper case letter. For example, the resource field "Patient.Address.city", which uses a string type, can be matched by "Patient.Address.String". Path also supports partialkk matching. For example, "Patient.Address.city" can be matched by "Address.city" (Patient omitted). Partial matching and type matching can be combined, for example "Patient.Address.city" can be matched by "Address.String". For "choice" types (those defined in the FHIR spec with the form: field[x]), use two separate components. For example, "deceasedAge.unit" is matched by "Deceased.Age.unit". Supported [types](https://www.hl7.org/fhir/datatypes.html) are: AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime, Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid, PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml. The sub-type for HumanName (for example HumanName.given, HumanName.family) can be omitted.
     */
    paths: string[];
    /**
     * Remove the field.
     */
    removeField: outputs.healthcare.v1beta1.RemoveFieldResponse;
}

/**
 * Specifies additional options to apply to the base `profile`.
 */
export interface GoogleCloudHealthcareV1beta1DeidentifyOptionsResponse {
    /**
     * Character mask config for `CharacterMaskField` `FieldMetadatas`.
     */
    characterMaskConfig: outputs.healthcare.v1beta1.CharacterMaskConfigResponse;
    /**
     * Configure contextual de-id.
     */
    contextualDeid: outputs.healthcare.v1beta1.ContextualDeidConfigResponse;
    /**
     * Crypo hash config for `CharacterMaskField` `FieldMetadatas`.
     */
    cryptoHashConfig: outputs.healthcare.v1beta1.CryptoHashConfigResponse;
    /**
     * Date shifting config for `CharacterMaskField` `FieldMetadatas`.
     */
    dateShiftConfig: outputs.healthcare.v1beta1.DateShiftConfigResponse;
    /**
     * Configure keeping extensions by default.
     */
    keepExtensions: outputs.healthcare.v1beta1.KeepExtensionsConfigResponse;
}

/**
 * The BigQuery table where the server writes output.
 */
export interface GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse {
    /**
     * Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
     */
    force: boolean;
    /**
     * BigQuery URI to a table, up to 2000 characters long, in the format `bq://projectId.bqDatasetId.tableId`
     */
    tableUri: string;
    /**
     * Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
     */
    writeDisposition: string;
}

/**
 * StreamConfig specifies configuration for a streaming DICOM export.
 */
export interface GoogleCloudHealthcareV1beta1DicomStreamConfigResponse {
    /**
     * Results are appended to this table. The server creates a new table in the given BigQuery dataset if the specified table does not exist. To enable the Cloud Healthcare API to write to your BigQuery table, you must give the Cloud Healthcare API service account the bigquery.dataEditor role. The service account is: `service-{PROJECT_NUMBER}@gcp-sa-healthcare.iam.gserviceaccount.com`. The PROJECT_NUMBER identifies the project that the DICOM store resides in. To get the project number, go to the Cloud Console Dashboard. It is recommended to not have a custom schema in the destination table which could conflict with the schema created by the Cloud Healthcare API. Instance deletions are not applied to the destination table. The destination's table schema will be automatically updated in case a new instance's data is incompatible with the current schema. The schema should not be updated manually as this can cause incompatibilies that cannot be resolved automatically. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any instance that generates more than 1 MB of BigQuery data will not be streamed. If an instance cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
     */
    bigqueryDestination: outputs.healthcare.v1beta1.GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse;
}

/**
 * The configuration for exporting to BigQuery.
 */
export interface GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse {
    /**
     * BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
     */
    datasetUri: string;
    /**
     * Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
     */
    force: boolean;
    /**
     * The configuration for the exported BigQuery schema.
     */
    schemaConfig: outputs.healthcare.v1beta1.SchemaConfigResponse;
    /**
     * Determines if existing data in the destination dataset is overwritten, appended to, or not written if the tables contain data. If a write_disposition is specified, the `force` parameter is ignored.
     */
    writeDisposition: string;
}

/**
 * Root config message for HL7v2 schema. This contains a schema structure of groups and segments, and filters that determine which messages to apply the schema structure to.
 */
export interface Hl7SchemaConfigResponse {
    /**
     * Map from each HL7v2 message type and trigger event pair, such as ADT_A04, to its schema configuration root group.
     */
    messageSchemaConfigs: {[key: string]: string};
    /**
     * Each VersionSource is tested and only if they all match is the schema used for the message.
     */
    version: outputs.healthcare.v1beta1.VersionSourceResponse[];
}

/**
 * Root config for HL7v2 datatype definitions for a specific HL7v2 version.
 */
export interface Hl7TypesConfigResponse {
    /**
     * The HL7v2 type definitions.
     */
    type: outputs.healthcare.v1beta1.TypeResponse[];
    /**
     * The version selectors that this config applies to. A message must match ALL version sources to apply.
     */
    version: outputs.healthcare.v1beta1.VersionSourceResponse[];
}

/**
 * Specifies where and whether to send notifications upon changes to a data store.
 */
export interface Hl7V2NotificationConfigResponse {
    /**
     * Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. The following syntax is available: * A string field value can be written as text inside quotation marks, for example `"query text"`. The only valid relational operation for text fields is equality (`=`), where text is searched within the field, rather than having the field be equal to the text. For example, `"Comment = great"` returns messages with `great` in the comment field. * A number field value can be written as an integer, a decimal, or an exponential. The valid relational operators for number fields are the equality operator (`=`), along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * A date field value must be written in `yyyy-mm-dd` form. Fields with date and time use the RFC3339 time format. Leading zeros are required for one-digit months and days. The valid relational operators for date fields are the equality operator (`=`) , along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * Multiple field query expressions can be combined in one query by adding `AND` or `OR` operators between the expressions. If a boolean operator appears within a quoted string, it is not treated as special, it's just another part of the character string to be matched. You can prepend the `NOT` operator to an expression to negate it. Fields/functions available for filtering are: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `create_time`, the timestamp when the message was created in the HL7v2 store. Use the RFC3339 time format for comparisons. For example, `create_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
     */
    filter: string;
    /**
     * The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging).
     */
    pubsubTopic: string;
}

/**
 * Image annotation.
 */
export interface ImageAnnotationResponse {
    /**
     * The list of polygons outlining the sensitive regions in the image.
     */
    boundingPolys: outputs.healthcare.v1beta1.BoundingPolyResponse[];
    /**
     * 0-based index of the image frame. For example, an image frame in a DICOM instance.
     */
    frameIndex: number;
}

/**
 * Specifies how to handle de-identification of image pixels.
 */
export interface ImageConfigResponse {
    /**
     * Additional InfoTypes to redact in the images in addition to those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT`, `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS` or `TEXT_REDACTION_MODE_UNSPECIFIED`.
     */
    additionalInfoTypes: string[];
    /**
     * InfoTypes to skip redacting, overriding those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT` or `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS`.
     */
    excludeInfoTypes: string[];
    /**
     * Determines how to redact text from image.
     */
    textRedactionMode: string;
}

/**
 * Raw bytes representing consent artifact content.
 */
export interface ImageResponse {
    /**
     * Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
     */
    gcsUri: string;
    /**
     * Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
     */
    rawBytes: string;
}

/**
 * A transformation to apply to text that is identified as a specific info_type.
 */
export interface InfoTypeTransformationResponse {
    /**
     * Config for character mask.
     */
    characterMaskConfig: outputs.healthcare.v1beta1.CharacterMaskConfigResponse;
    /**
     * Config for crypto hash.
     */
    cryptoHashConfig: outputs.healthcare.v1beta1.CryptoHashConfigResponse;
    /**
     * Config for date shift.
     */
    dateShiftConfig: outputs.healthcare.v1beta1.DateShiftConfigResponse;
    /**
     * `InfoTypes` to apply this transformation to. If this is not specified, this transformation becomes the default transformation, and is used for any `info_type` that is not specified in another transformation.
     */
    infoTypes: string[];
    /**
     * Config for text redaction.
     */
    redactConfig: outputs.healthcare.v1beta1.RedactConfigResponse;
    /**
     * Config for replace with InfoType.
     */
    replaceWithInfoTypeConfig: outputs.healthcare.v1beta1.ReplaceWithInfoTypeConfigResponse;
}

/**
 * The behaviour for handling FHIR extensions that aren't otherwise specified for de-identification. If provided, all extensions are preserved during de-identification by default. If unspecified, all extensions are removed during de-identification by default.
 */
export interface KeepExtensionsConfigResponse {
}

/**
 * Keep field unchanged.
 */
export interface KeepFieldResponse {
}

/**
 * Keep tag unchanged.
 */
export interface KeepTagResponse {
}

/**
 * Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. The key must grant the Cloud IAM permission `cloudkms.cryptoKeyVersions.useToDecrypt` to the project's Cloud Healthcare Service Agent service account. For more information, see [Creating a wrapped key] (https://cloud.google.com/dlp/docs/create-wrapped-key).
 */
export interface KmsWrappedCryptoKeyResponse {
    /**
     * The resource name of the KMS CryptoKey to use for unwrapping. For example, `projects/{project_id}/locations/{location_id}/keyRings/{keyring}/cryptoKeys/{key}`.
     */
    cryptoKey: string;
    /**
     * The wrapped data crypto key.
     */
    wrappedKey: string;
}

/**
 * Specifies where to send notifications upon changes to a data store.
 */
export interface NotificationConfigResponse {
    /**
     * The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
     */
    pubsubTopic: string;
    /**
     * Indicates whether or not to send Pub/Sub notifications on bulk import. Only supported for DICOM imports.
     */
    sendForBulkImport: boolean;
}

/**
 * Specifies additional options to apply to the base profile.
 */
export interface OptionsResponse {
    /**
     * Set Clean Descriptors Option.
     */
    cleanDescriptors: outputs.healthcare.v1beta1.CleanDescriptorsOptionResponse;
    /**
     * Apply `Action.clean_image` to [`PixelData`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html) as configured.
     */
    cleanImage: outputs.healthcare.v1beta1.ImageConfigResponse;
    /**
     * Set `Action` for [`StudyInstanceUID`, `SeriesInstanceUID`, `SOPInstanceUID`, and `MediaStorageSOPInstanceUID`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html).
     */
    primaryIds: string;
}

/**
 * The content of an HL7v2 message in a structured format.
 */
export interface ParsedDataResponse {
    segments: outputs.healthcare.v1beta1.SegmentResponse[];
}

/**
 * The configuration for the parser. It determines how the server parses the messages.
 */
export interface ParserConfigResponse {
    /**
     * Determines whether messages with no header are allowed.
     */
    allowNullHeader: boolean;
    /**
     * Schemas used to parse messages in this store, if schematized parsing is desired.
     */
    schema: outputs.healthcare.v1beta1.SchemaPackageResponse;
    /**
     * Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
     */
    segmentTerminator: string;
    /**
     * Immutable. Determines the version of both the default parser to be used when `schema` is not given, as well as the schematized parser used when `schema` is specified. This field is immutable after HL7v2 store creation.
     */
    version: string;
}

/**
 * A patient identifier and associated type.
 */
export interface PatientIdResponse {
    /**
     * ID type. For example, MRN or NHS.
     */
    type: string;
    /**
     * The patient's unique identifier.
     */
    value: string;
}

/**
 * Recursively apply DICOM de-id to tags nested in a sequence. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): SQ
 */
export interface RecurseTagResponse {
}

/**
 * Define how to redact sensitive values. Default behaviour is erase. For example, "My name is Jane." becomes "My name is ."
 */
export interface RedactConfigResponse {
}

/**
 * Replace UID with a new generated UID. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): UI
 */
export interface RegenUidTagResponse {
}

/**
 * Remove field.
 */
export interface RemoveFieldResponse {
}

/**
 * Replace with empty tag.
 */
export interface RemoveTagResponse {
}

/**
 * When using the INSPECT_AND_TRANSFORM action, each match is replaced with the name of the info_type. For example, "My name is Jane" becomes "My name is [PERSON_NAME]." The TRANSFORM action is equivalent to redacting.
 */
export interface ReplaceWithInfoTypeConfigResponse {
}

/**
 * Reset tag to a placeholder value.
 */
export interface ResetTagResponse {
}

/**
 * Resource level annotation.
 */
export interface ResourceAnnotationResponse {
    /**
     * A description of the annotation record.
     */
    label: string;
}

/**
 * Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
 */
export interface SchemaConfigResponse {
    /**
     * The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
     */
    recursiveStructureDepth: string;
    /**
     * Specifies the output schema type. Schema type is required.
     */
    schemaType: string;
}

/**
 * A schema package contains a set of schemas and type definitions.
 */
export interface SchemaPackageResponse {
    /**
     * Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
     */
    ignoreMinOccurs: boolean;
    /**
     * Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
     */
    schemas: outputs.healthcare.v1beta1.Hl7SchemaConfigResponse[];
    /**
     * Determines how messages that fail to parse are handled.
     */
    schematizedParsingType: string;
    /**
     * Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
     */
    types: outputs.healthcare.v1beta1.Hl7TypesConfigResponse[];
    /**
     * Determines how unexpected segments (segments not matched to the schema) are handled.
     */
    unexpectedSegmentHandling: string;
}

/**
 * The content of an HL7v2 message in a structured format as specified by a schema.
 */
export interface SchematizedDataResponse {
    /**
     * JSON output of the parser.
     */
    data: string;
    /**
     * The error output of the parser.
     */
    error: string;
}

/**
 * Contains the configuration for FHIR search.
 */
export interface SearchConfigResponse {
    /**
     * A list of search parameters in this FHIR store that are used to configure this FHIR store.
     */
    searchParameters: outputs.healthcare.v1beta1.SearchParameterResponse[];
}

/**
 * Contains the versioned name and the URL for one SearchParameter.
 */
export interface SearchParameterResponse {
    /**
     * The canonical url of the search parameter resource.
     */
    canonicalUrl: string;
    /**
     * The versioned name of the search parameter resource. The format is projects/{project-id}/locations/{location}/datasets/{dataset-id}/fhirStores/{fhirStore-id}/fhir/SearchParameter/{resource-id}/_history/{version-id} For fhir stores with disable_resource_versioning=true, the format is projects/{project-id}/locations/{location}/datasets/{dataset-id}/fhirStores/{fhirStore-id}/fhir/SearchParameter/{resource-id}/
     */
    parameter: string;
}

/**
 * A segment in a structured format.
 */
export interface SegmentResponse {
    /**
     * A mapping from the positional location to the value. The key string uses zero-based indexes separated by dots to identify Fields, components and sub-components. A bracket notation is also used to identify different instances of a repeated field. Regex for key: (\d+)(\[\d+\])?(.\d+)?(.\d+)? Examples of (key, value) pairs: * (0.1, "hemoglobin") denotes that the first component of Field 0 has the value "hemoglobin". * (1.1.2, "CBC") denotes that the second sub-component of the first component of Field 1 has the value "CBC". * (1[0].1, "HbA1c") denotes that the first component of the first Instance of Field 1, which is repeated, has the value "HbA1c".
     */
    fields: {[key: string]: string};
    /**
     * A string that indicates the type of segment. For example, EVN or PID.
     */
    segmentId: string;
    /**
     * Set ID for segments that can be in a set. This can be empty if it's missing or isn't applicable.
     */
    setId: string;
}

/**
 * A TextAnnotation specifies a text range that includes sensitive information.
 */
export interface SensitiveTextAnnotationResponse {
    /**
     * Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
     */
    details: {[key: string]: string};
}

/**
 * User signature.
 */
export interface SignatureResponse {
    /**
     * Optional. An image of the user's signature.
     */
    image: outputs.healthcare.v1beta1.ImageResponse;
    /**
     * Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
     */
    metadata: {[key: string]: string};
    /**
     * Optional. Timestamp of the signature.
     */
    signatureTime: string;
    /**
     * User's UUID provided by the client.
     */
    userId: string;
}

/**
 * Contains configuration for streaming FHIR export.
 */
export interface StreamConfigResponse {
    /**
     * The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types, e.g. "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data will not be streamed. Results are written to BigQuery tables according to the parameters in BigQueryDestination.WriteDisposition. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
     */
    bigqueryDestination: outputs.healthcare.v1beta1.GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse;
    /**
     * The destination FHIR store for de-identified resources. After this field is added, all subsequent creates/updates/patches to the source store will be de-identified using the provided configuration and applied to the destination store. Importing resources to the source store will not trigger the streaming. If the source store already contains resources when this option is enabled, those resources will not be copied to the destination store unless they are subsequently updated. This may result in invalid references in the destination store. Before adding this config, you must grant the healthcare.fhirResources.update permission on the destination store to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent). The destination store must set enable_update_create to true. The destination store must have disable_referential_integrity set to true. If a resource cannot be de-identified, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
     */
    deidentifiedStoreDestination: outputs.healthcare.v1beta1.DeidentifiedStoreDestinationResponse;
    /**
     * Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
     */
    resourceTypes: string[];
}

/**
 * List of tags to be filtered.
 */
export interface TagFilterListResponse {
    /**
     * Tags to be filtered. Tags must be DICOM Data Elements, File Meta Elements, or Directory Structuring Elements, as defined at: http://dicom.nema.org/medical/dicom/current/output/html/part06.html#table_6-1,. They may be provided by "Keyword" or "Tag". For example, "PatientID", "00100010".
     */
    tags: string[];
}

/**
 * Configures how to transform sensitive text `InfoTypes`.
 */
export interface TextConfigResponse {
    /**
     * Additional transformations to apply to the detected data, overriding `profile`.
     */
    additionalTransformations: outputs.healthcare.v1beta1.InfoTypeTransformationResponse[];
    /**
     * InfoTypes to skip transforming, overriding `profile`.
     */
    excludeInfoTypes: string[];
    /**
     * Base profile type for text transformation.
     */
    profileType: string;
    /**
     * The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.
     *
     * @deprecated The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.
     */
    transformations: outputs.healthcare.v1beta1.InfoTypeTransformationResponse[];
}

/**
 * A type definition for some HL7v2 type (incl. Segments and Datatypes).
 */
export interface TypeResponse {
    /**
     * The (sub) fields this type has (if not primitive).
     */
    fields: outputs.healthcare.v1beta1.FieldResponse[];
    /**
     * The name of this type. This would be the segment or datatype name. For example, "PID" or "XPN".
     */
    name: string;
    /**
     * If this is a primitive type then this field is the type of the primitive For example, STRING. Leave unspecified for composite types.
     */
    primitive: string;
}

/**
 * Contains the configuration for FHIR profiles and validation.
 */
export interface ValidationConfigResponse {
    /**
     * Whether to disable FHIRPath validation for incoming resources. Set this to true to disable checking incoming resources for conformance against FHIRPath requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
     */
    disableFhirpathValidation: boolean;
    /**
     * Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
     */
    disableProfileValidation: boolean;
    /**
     * Whether to disable reference type validation for incoming resources. Set this to true to disable checking incoming resources for conformance against reference type requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
     */
    disableReferenceTypeValidation: boolean;
    /**
     * Whether to disable required fields validation for incoming resources. Set this to true to disable checking incoming resources for conformance against required fields requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
     */
    disableRequiredFieldValidation: boolean;
    /**
     * A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
     */
    enabledImplementationGuides: string[];
}

/**
 * Describes a selector for extracting and matching an MSH field to a value.
 */
export interface VersionSourceResponse {
    /**
     * The field to extract from the MSH segment. For example, "3.1" or "18[1].1".
     */
    mshField: string;
    /**
     * The value to match with the field. For example, "My Application Name" or "2.3".
     */
    value: string;
}

/**
 * A 2D coordinate in an image. The origin is the top-left.
 */
export interface VertexResponse {
    /**
     * X coordinate.
     */
    x: number;
    /**
     * Y coordinate.
     */
    y: number;
}


// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../../../types/input";
import * as outputs from "../../../types/output";
import * as enums from "../../../types/enums";
import * as utilities from "../../../utilities";

/**
 * Parameters for DnsKey key generation. Used for generating initial keys for a new ManagedZone and as default when adding a new DnsKey.
 */
export interface DnsKeySpecArgs {
    /**
     * String mnemonic specifying the DNSSEC algorithm of this key.
     */
    algorithm?: pulumi.Input<enums.dns.v1beta2.DnsKeySpecAlgorithm>;
    /**
     * Length of the keys in bits.
     */
    keyLength?: pulumi.Input<number>;
    /**
     * Specifies whether this is a key signing key (KSK) or a zone signing key (ZSK). Key signing keys have the Secure Entry Point flag set and, when active, are only used to sign resource record sets of type DNSKEY. Zone signing keys do not have the Secure Entry Point flag set and are used to sign all other types of resource record sets.
     */
    keyType?: pulumi.Input<enums.dns.v1beta2.DnsKeySpecKeyType>;
    kind?: pulumi.Input<string>;
}

/**
 * Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
 */
export interface ExprArgs {
    /**
     * Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
     */
    description?: pulumi.Input<string>;
    /**
     * Textual representation of an expression in Common Expression Language syntax.
     */
    expression?: pulumi.Input<string>;
    /**
     * Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
     */
    location?: pulumi.Input<string>;
    /**
     * Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
     */
    title?: pulumi.Input<string>;
}

/**
 * Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
 */
export interface GoogleIamV1AuditConfigArgs {
    /**
     * The configuration for logging of each type of permission.
     */
    auditLogConfigs?: pulumi.Input<pulumi.Input<inputs.dns.v1beta2.GoogleIamV1AuditLogConfigArgs>[]>;
    /**
     * Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
     */
    service?: pulumi.Input<string>;
}

/**
 * Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
 */
export interface GoogleIamV1AuditLogConfigArgs {
    /**
     * Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
     */
    exemptedMembers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The log type that this config enables.
     */
    logType?: pulumi.Input<enums.dns.v1beta2.GoogleIamV1AuditLogConfigLogType>;
}

/**
 * Associates `members`, or principals, with a `role`.
 */
export interface GoogleIamV1BindingArgs {
    /**
     * The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
     */
    condition?: pulumi.Input<inputs.dns.v1beta2.ExprArgs>;
    /**
     * Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. 
     */
    members?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
     */
    role?: pulumi.Input<string>;
}

/**
 * Cloud Logging configurations for publicly visible zones.
 */
export interface ManagedZoneCloudLoggingConfigArgs {
    /**
     * If set, enable query logging for this ManagedZone. False by default, making logging opt-in.
     */
    enableLogging?: pulumi.Input<boolean>;
    kind?: pulumi.Input<string>;
}

export interface ManagedZoneDnsSecConfigArgs {
    /**
     * Specifies parameters for generating initial DnsKeys for this ManagedZone. Can only be changed while the state is OFF.
     */
    defaultKeySpecs?: pulumi.Input<pulumi.Input<inputs.dns.v1beta2.DnsKeySpecArgs>[]>;
    kind?: pulumi.Input<string>;
    /**
     * Specifies the mechanism for authenticated denial-of-existence responses. Can only be changed while the state is OFF.
     */
    nonExistence?: pulumi.Input<enums.dns.v1beta2.ManagedZoneDnsSecConfigNonExistence>;
    /**
     * Specifies whether DNSSEC is enabled, and what mode it is in.
     */
    state?: pulumi.Input<enums.dns.v1beta2.ManagedZoneDnsSecConfigState>;
}

export interface ManagedZoneForwardingConfigArgs {
    kind?: pulumi.Input<string>;
    /**
     * List of target name servers to forward to. Cloud DNS selects the best available name server if more than one target is given.
     */
    targetNameServers?: pulumi.Input<pulumi.Input<inputs.dns.v1beta2.ManagedZoneForwardingConfigNameServerTargetArgs>[]>;
}

export interface ManagedZoneForwardingConfigNameServerTargetArgs {
    /**
     * Forwarding path for this NameServerTarget. If unset or set to DEFAULT, Cloud DNS makes forwarding decisions based on IP address ranges; that is, RFC1918 addresses go to the VPC network, non-RFC1918 addresses go to the internet. When set to PRIVATE, Cloud DNS always sends queries through the VPC network for this target.
     */
    forwardingPath?: pulumi.Input<enums.dns.v1beta2.ManagedZoneForwardingConfigNameServerTargetForwardingPath>;
    /**
     * IPv4 address of a target name server.
     */
    ipv4Address?: pulumi.Input<string>;
    /**
     * IPv6 address of a target name server. Does not accept both fields (ipv4 & ipv6) being populated.
     */
    ipv6Address?: pulumi.Input<string>;
    kind?: pulumi.Input<string>;
}

export interface ManagedZonePeeringConfigArgs {
    kind?: pulumi.Input<string>;
    /**
     * The network with which to peer.
     */
    targetNetwork?: pulumi.Input<inputs.dns.v1beta2.ManagedZonePeeringConfigTargetNetworkArgs>;
}

export interface ManagedZonePeeringConfigTargetNetworkArgs {
    /**
     * The time at which the zone was deactivated, in RFC 3339 date-time format. An empty string indicates that the peering connection is active. The producer network can deactivate a zone. The zone is automatically deactivated if the producer network that the zone targeted is deleted. Output only.
     */
    deactivateTime?: pulumi.Input<string>;
    kind?: pulumi.Input<string>;
    /**
     * The fully qualified URL of the VPC network to forward queries to. This should be formatted like https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
     */
    networkUrl?: pulumi.Input<string>;
}

export interface ManagedZonePrivateVisibilityConfigArgs {
    /**
     * The list of Google Kubernetes Engine clusters that can see this zone.
     */
    gkeClusters?: pulumi.Input<pulumi.Input<inputs.dns.v1beta2.ManagedZonePrivateVisibilityConfigGKEClusterArgs>[]>;
    kind?: pulumi.Input<string>;
    /**
     * The list of VPC networks that can see this zone.
     */
    networks?: pulumi.Input<pulumi.Input<inputs.dns.v1beta2.ManagedZonePrivateVisibilityConfigNetworkArgs>[]>;
}

export interface ManagedZonePrivateVisibilityConfigGKEClusterArgs {
    /**
     * The resource name of the cluster to bind this ManagedZone to. This should be specified in the format like: projects/*&#47;locations/*&#47;clusters/*. This is referenced from GKE projects.locations.clusters.get API: https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters/get
     */
    gkeClusterName?: pulumi.Input<string>;
    kind?: pulumi.Input<string>;
}

export interface ManagedZonePrivateVisibilityConfigNetworkArgs {
    kind?: pulumi.Input<string>;
    /**
     * The fully qualified URL of the VPC network to bind to. Format this URL like https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
     */
    networkUrl?: pulumi.Input<string>;
}

export interface ManagedZoneReverseLookupConfigArgs {
    kind?: pulumi.Input<string>;
}

/**
 * Contains information about Service Directory-backed zones.
 */
export interface ManagedZoneServiceDirectoryConfigArgs {
    kind?: pulumi.Input<string>;
    /**
     * Contains information about the namespace associated with the zone.
     */
    namespace?: pulumi.Input<inputs.dns.v1beta2.ManagedZoneServiceDirectoryConfigNamespaceArgs>;
}

export interface ManagedZoneServiceDirectoryConfigNamespaceArgs {
    /**
     * The time that the namespace backing this zone was deleted; an empty string if it still exists. This is in RFC3339 text format. Output only.
     */
    deletionTime?: pulumi.Input<string>;
    kind?: pulumi.Input<string>;
    /**
     * The fully qualified URL of the namespace associated with the zone. Format must be https://servicedirectory.googleapis.com/v1/projects/{project}/locations/{location}/namespaces/{namespace}
     */
    namespaceUrl?: pulumi.Input<string>;
}

export interface PolicyAlternativeNameServerConfigArgs {
    kind?: pulumi.Input<string>;
    /**
     * Sets an alternative name server for the associated networks. When specified, all DNS queries are forwarded to a name server that you choose. Names such as .internal are not available when an alternative name server is specified.
     */
    targetNameServers?: pulumi.Input<pulumi.Input<inputs.dns.v1beta2.PolicyAlternativeNameServerConfigTargetNameServerArgs>[]>;
}

export interface PolicyAlternativeNameServerConfigTargetNameServerArgs {
    /**
     * Forwarding path for this TargetNameServer. If unset or set to DEFAULT, Cloud DNS makes forwarding decisions based on address ranges; that is, RFC1918 addresses go to the VPC network, non-RFC1918 addresses go to the internet. When set to PRIVATE, Cloud DNS always sends queries through the VPC network for this target.
     */
    forwardingPath?: pulumi.Input<enums.dns.v1beta2.PolicyAlternativeNameServerConfigTargetNameServerForwardingPath>;
    /**
     * IPv4 address to forward queries to.
     */
    ipv4Address?: pulumi.Input<string>;
    /**
     * IPv6 address to forward to. Does not accept both fields (ipv4 & ipv6) being populated.
     */
    ipv6Address?: pulumi.Input<string>;
    kind?: pulumi.Input<string>;
}

export interface PolicyNetworkArgs {
    kind?: pulumi.Input<string>;
    /**
     * The fully qualified URL of the VPC network to bind to. This should be formatted like https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
     */
    networkUrl?: pulumi.Input<string>;
}

/**
 * A RRSetRoutingPolicy represents ResourceRecordSet data that is returned dynamically with the response varying based on configured properties such as geolocation or by weighted random selection.
 */
export interface RRSetRoutingPolicyArgs {
    geo?: pulumi.Input<inputs.dns.v1beta2.RRSetRoutingPolicyGeoPolicyArgs>;
    geoPolicy?: pulumi.Input<inputs.dns.v1beta2.RRSetRoutingPolicyGeoPolicyArgs>;
    kind?: pulumi.Input<string>;
    primaryBackup?: pulumi.Input<inputs.dns.v1beta2.RRSetRoutingPolicyPrimaryBackupPolicyArgs>;
    wrr?: pulumi.Input<inputs.dns.v1beta2.RRSetRoutingPolicyWrrPolicyArgs>;
    wrrPolicy?: pulumi.Input<inputs.dns.v1beta2.RRSetRoutingPolicyWrrPolicyArgs>;
}

/**
 * Configures a RRSetRoutingPolicy that routes based on the geo location of the querying user.
 */
export interface RRSetRoutingPolicyGeoPolicyArgs {
    /**
     * Without fencing, if health check fails for all configured items in the current geo bucket, we'll failover to the next nearest geo bucket. With fencing, if health check is enabled, as long as some targets in the current geo bucket are healthy, we'll return only the healthy targets. However, if they're all unhealthy, we won't failover to the next nearest bucket, we'll simply return all the items in the current bucket even though they're unhealthy.
     */
    enableFencing?: pulumi.Input<boolean>;
    /**
     * The primary geo routing configuration. If there are multiple items with the same location, an error is returned instead.
     */
    items?: pulumi.Input<pulumi.Input<inputs.dns.v1beta2.RRSetRoutingPolicyGeoPolicyGeoPolicyItemArgs>[]>;
    kind?: pulumi.Input<string>;
}

/**
 * ResourceRecordSet data for one geo location.
 */
export interface RRSetRoutingPolicyGeoPolicyGeoPolicyItemArgs {
    /**
     * For A and AAAA types only. Endpoints to return in the query result only if they are healthy. These can be specified along with rrdata within this item.
     */
    healthCheckedTargets?: pulumi.Input<inputs.dns.v1beta2.RRSetRoutingPolicyHealthCheckTargetsArgs>;
    kind?: pulumi.Input<string>;
    /**
     * The geo-location granularity is a GCP region. This location string should correspond to a GCP region. e.g. "us-east1", "southamerica-east1", "asia-east1", etc.
     */
    location?: pulumi.Input<string>;
    rrdatas?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * DNSSEC generated signatures for all the rrdata within this item. Note that if health checked targets are provided for DNSSEC enabled zones, there's a restriction of 1 ip per item. .
     */
    signatureRrdatas?: pulumi.Input<pulumi.Input<string>[]>;
}

/**
 * HealthCheckTargets describes endpoints to health-check when responding to Routing Policy queries. Only the healthy endpoints will be included in the response.
 */
export interface RRSetRoutingPolicyHealthCheckTargetsArgs {
    internalLoadBalancers?: pulumi.Input<pulumi.Input<inputs.dns.v1beta2.RRSetRoutingPolicyLoadBalancerTargetArgs>[]>;
}

export interface RRSetRoutingPolicyLoadBalancerTargetArgs {
    /**
     * The frontend IP address of the
     */
    ipAddress?: pulumi.Input<string>;
    ipProtocol?: pulumi.Input<enums.dns.v1beta2.RRSetRoutingPolicyLoadBalancerTargetIpProtocol>;
    kind?: pulumi.Input<string>;
    loadBalancerType?: pulumi.Input<enums.dns.v1beta2.RRSetRoutingPolicyLoadBalancerTargetLoadBalancerType>;
    /**
     * The fully qualified url of the network on which the ILB is
     */
    networkUrl?: pulumi.Input<string>;
    /**
     * Load Balancer to health check. The configured port of the Load Balancer.
     */
    port?: pulumi.Input<string>;
    /**
     * present. This should be formatted like https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network} The project ID in which the ILB exists.
     */
    project?: pulumi.Input<string>;
    /**
     * The region for regional ILBs.
     */
    region?: pulumi.Input<string>;
}

/**
 * Configures a RRSetRoutingPolicy such that all queries are responded with the primary_targets if they are healthy. And if all of them are unhealthy, then we fallback to a geo localized policy.
 */
export interface RRSetRoutingPolicyPrimaryBackupPolicyArgs {
    /**
     * Backup targets provide a regional failover policy for the otherwise global primary targets. If serving state is set to BACKUP, this policy essentially becomes a geo routing policy.
     */
    backupGeoTargets?: pulumi.Input<inputs.dns.v1beta2.RRSetRoutingPolicyGeoPolicyArgs>;
    kind?: pulumi.Input<string>;
    primaryTargets?: pulumi.Input<inputs.dns.v1beta2.RRSetRoutingPolicyHealthCheckTargetsArgs>;
    /**
     * When serving state is PRIMARY, this field provides the option of sending a small percentage of the traffic to the backup targets.
     */
    trickleTraffic?: pulumi.Input<number>;
}

/**
 * Configures a RRSetRoutingPolicy that routes in a weighted round robin fashion.
 */
export interface RRSetRoutingPolicyWrrPolicyArgs {
    items?: pulumi.Input<pulumi.Input<inputs.dns.v1beta2.RRSetRoutingPolicyWrrPolicyWrrPolicyItemArgs>[]>;
    kind?: pulumi.Input<string>;
}

/**
 * A routing block which contains the routing information for one WRR item.
 */
export interface RRSetRoutingPolicyWrrPolicyWrrPolicyItemArgs {
    /**
     * endpoints that need to be health checked before making the routing decision. The unhealthy endpoints will be omitted from the result. If all endpoints within a buckete are unhealthy, we'll choose a different bucket (sampled w.r.t. its weight) for responding. Note that if DNSSEC is enabled for this zone, only one of rrdata or health_checked_targets can be set.
     */
    healthCheckedTargets?: pulumi.Input<inputs.dns.v1beta2.RRSetRoutingPolicyHealthCheckTargetsArgs>;
    kind?: pulumi.Input<string>;
    rrdatas?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * DNSSEC generated signatures for all the rrdata within this item. Note that if health checked targets are provided for DNSSEC enabled zones, there's a restriction of 1 ip per item. .
     */
    signatureRrdatas?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The weight corresponding to this subset of rrdata. When multiple WeightedRoundRobinPolicyItems are configured, the probability of returning an rrset is proportional to its weight relative to the sum of weights configured for all items. This weight should be non-negative.
     */
    weight?: pulumi.Input<number>;
}

/**
 * A unit of data that is returned by the DNS servers.
 */
export interface ResourceRecordSetArgs {
    kind?: pulumi.Input<string>;
    /**
     * For example, www.example.com.
     */
    name?: pulumi.Input<string>;
    /**
     * Configures dynamic query responses based on geo location of querying user or a weighted round robin based routing policy. A ResourceRecordSet should only have either rrdata (static) or routing_policy (dynamic). An error is returned otherwise.
     */
    routingPolicy?: pulumi.Input<inputs.dns.v1beta2.RRSetRoutingPolicyArgs>;
    /**
     * As defined in RFC 1035 (section 5) and RFC 1034 (section 3.6.1) -- see examples.
     */
    rrdatas?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * As defined in RFC 4034 (section 3.2).
     */
    signatureRrdatas?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Number of seconds that this ResourceRecordSet can be cached by resolvers.
     */
    ttl?: pulumi.Input<number>;
    /**
     * The identifier of a supported record type. See the list of Supported DNS record types.
     */
    type?: pulumi.Input<string>;
}

export interface ResponsePolicyGKEClusterArgs {
    /**
     * The resource name of the cluster to bind this response policy to. This should be specified in the format like: projects/*&#47;locations/*&#47;clusters/*. This is referenced from GKE projects.locations.clusters.get API: https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters/get
     */
    gkeClusterName?: pulumi.Input<string>;
    kind?: pulumi.Input<string>;
}

export interface ResponsePolicyNetworkArgs {
    kind?: pulumi.Input<string>;
    /**
     * The fully qualified URL of the VPC network to bind to. This should be formatted like https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
     */
    networkUrl?: pulumi.Input<string>;
}

export interface ResponsePolicyRuleLocalDataArgs {
    /**
     * All resource record sets for this selector, one per resource record type. The name must match the dns_name.
     */
    localDatas?: pulumi.Input<pulumi.Input<inputs.dns.v1beta2.ResourceRecordSetArgs>[]>;
}


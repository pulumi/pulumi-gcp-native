// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***


export const ArtifactState = {
    /**
     * Unspecified state for the Artifact.
     */
    StateUnspecified: "STATE_UNSPECIFIED",
    /**
     * A state used by systems like Vertex AI Pipelines to indicate that the underlying data item represented by this Artifact is being created.
     */
    Pending: "PENDING",
    /**
     * A state indicating that the Artifact should exist, unless something external to the system deletes it.
     */
    Live: "LIVE",
} as const;

/**
 * The state of this Artifact. This is a property of the Artifact, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines), and the system does not prescribe or check the validity of state transitions.
 */
export type ArtifactState = (typeof ArtifactState)[keyof typeof ArtifactState];

export const ExecutionState = {
    /**
     * Unspecified Execution state
     */
    StateUnspecified: "STATE_UNSPECIFIED",
    /**
     * The Execution is new
     */
    New: "NEW",
    /**
     * The Execution is running
     */
    Running: "RUNNING",
    /**
     * The Execution has finished running
     */
    Complete: "COMPLETE",
    /**
     * The Execution has failed
     */
    Failed: "FAILED",
    /**
     * The Execution completed through Cache hit.
     */
    Cached: "CACHED",
    /**
     * The Execution was cancelled.
     */
    Cancelled: "CANCELLED",
} as const;

/**
 * The state of this Execution. This is a property of the Execution, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines) and the system does not prescribe or check the validity of state transitions.
 */
export type ExecutionState = (typeof ExecutionState)[keyof typeof ExecutionState];

export const FeatureGroupFeatureValueType = {
    /**
     * The value type is unspecified.
     */
    ValueTypeUnspecified: "VALUE_TYPE_UNSPECIFIED",
    /**
     * Used for Feature that is a boolean.
     */
    Bool: "BOOL",
    /**
     * Used for Feature that is a list of boolean.
     */
    BoolArray: "BOOL_ARRAY",
    /**
     * Used for Feature that is double.
     */
    Double: "DOUBLE",
    /**
     * Used for Feature that is a list of double.
     */
    DoubleArray: "DOUBLE_ARRAY",
    /**
     * Used for Feature that is INT64.
     */
    Int64: "INT64",
    /**
     * Used for Feature that is a list of INT64.
     */
    Int64Array: "INT64_ARRAY",
    /**
     * Used for Feature that is string.
     */
    String: "STRING",
    /**
     * Used for Feature that is a list of String.
     */
    StringArray: "STRING_ARRAY",
    /**
     * Used for Feature that is bytes.
     */
    Bytes: "BYTES",
} as const;

/**
 * Immutable. Only applicable for Vertex AI Feature Store (Legacy). Type of Feature value.
 */
export type FeatureGroupFeatureValueType = (typeof FeatureGroupFeatureValueType)[keyof typeof FeatureGroupFeatureValueType];

export const FeatureStoreFeatureValueType = {
    /**
     * The value type is unspecified.
     */
    ValueTypeUnspecified: "VALUE_TYPE_UNSPECIFIED",
    /**
     * Used for Feature that is a boolean.
     */
    Bool: "BOOL",
    /**
     * Used for Feature that is a list of boolean.
     */
    BoolArray: "BOOL_ARRAY",
    /**
     * Used for Feature that is double.
     */
    Double: "DOUBLE",
    /**
     * Used for Feature that is a list of double.
     */
    DoubleArray: "DOUBLE_ARRAY",
    /**
     * Used for Feature that is INT64.
     */
    Int64: "INT64",
    /**
     * Used for Feature that is a list of INT64.
     */
    Int64Array: "INT64_ARRAY",
    /**
     * Used for Feature that is string.
     */
    String: "STRING",
    /**
     * Used for Feature that is a list of String.
     */
    StringArray: "STRING_ARRAY",
    /**
     * Used for Feature that is bytes.
     */
    Bytes: "BYTES",
} as const;

/**
 * Immutable. Only applicable for Vertex AI Feature Store (Legacy). Type of Feature value.
 */
export type FeatureStoreFeatureValueType = (typeof FeatureStoreFeatureValueType)[keyof typeof FeatureStoreFeatureValueType];

export const GoogleCloudAiplatformV1ExamplesExampleGcsSourceDataFormat = {
    /**
     * Format unspecified, used when unset.
     */
    DataFormatUnspecified: "DATA_FORMAT_UNSPECIFIED",
    /**
     * Examples are stored in JSONL files.
     */
    Jsonl: "JSONL",
} as const;

/**
 * The format in which instances are given, if not specified, assume it's JSONL format. Currently only JSONL format is supported.
 */
export type GoogleCloudAiplatformV1ExamplesExampleGcsSourceDataFormat = (typeof GoogleCloudAiplatformV1ExamplesExampleGcsSourceDataFormat)[keyof typeof GoogleCloudAiplatformV1ExamplesExampleGcsSourceDataFormat];

export const GoogleCloudAiplatformV1ExplanationMetadataInputMetadataEncoding = {
    /**
     * Default value. This is the same as IDENTITY.
     */
    EncodingUnspecified: "ENCODING_UNSPECIFIED",
    /**
     * The tensor represents one feature.
     */
    Identity: "IDENTITY",
    /**
     * The tensor represents a bag of features where each index maps to a feature. InputMetadata.index_feature_mapping must be provided for this encoding. For example: ``` input = [27, 6.0, 150] index_feature_mapping = ["age", "height", "weight"] ```
     */
    BagOfFeatures: "BAG_OF_FEATURES",
    /**
     * The tensor represents a bag of features where each index maps to a feature. Zero values in the tensor indicates feature being non-existent. InputMetadata.index_feature_mapping must be provided for this encoding. For example: ``` input = [2, 0, 5, 0, 1] index_feature_mapping = ["a", "b", "c", "d", "e"] ```
     */
    BagOfFeaturesSparse: "BAG_OF_FEATURES_SPARSE",
    /**
     * The tensor is a list of binaries representing whether a feature exists or not (1 indicates existence). InputMetadata.index_feature_mapping must be provided for this encoding. For example: ``` input = [1, 0, 1, 0, 1] index_feature_mapping = ["a", "b", "c", "d", "e"] ```
     */
    Indicator: "INDICATOR",
    /**
     * The tensor is encoded into a 1-dimensional array represented by an encoded tensor. InputMetadata.encoded_tensor_name must be provided for this encoding. For example: ``` input = ["This", "is", "a", "test", "."] encoded = [0.1, 0.2, 0.3, 0.4, 0.5] ```
     */
    CombinedEmbedding: "COMBINED_EMBEDDING",
    /**
     * Select this encoding when the input tensor is encoded into a 2-dimensional array represented by an encoded tensor. InputMetadata.encoded_tensor_name must be provided for this encoding. The first dimension of the encoded tensor's shape is the same as the input tensor's shape. For example: ``` input = ["This", "is", "a", "test", "."] encoded = [[0.1, 0.2, 0.3, 0.4, 0.5], [0.2, 0.1, 0.4, 0.3, 0.5], [0.5, 0.1, 0.3, 0.5, 0.4], [0.5, 0.3, 0.1, 0.2, 0.4], [0.4, 0.3, 0.2, 0.5, 0.1]] ```
     */
    ConcatEmbedding: "CONCAT_EMBEDDING",
} as const;

/**
 * Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
 */
export type GoogleCloudAiplatformV1ExplanationMetadataInputMetadataEncoding = (typeof GoogleCloudAiplatformV1ExplanationMetadataInputMetadataEncoding)[keyof typeof GoogleCloudAiplatformV1ExplanationMetadataInputMetadataEncoding];

export const GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationColorMap = {
    /**
     * Should not be used.
     */
    ColorMapUnspecified: "COLOR_MAP_UNSPECIFIED",
    /**
     * Positive: green. Negative: pink.
     */
    PinkGreen: "PINK_GREEN",
    /**
     * Viridis color map: A perceptually uniform color mapping which is easier to see by those with colorblindness and progresses from yellow to green to blue. Positive: yellow. Negative: blue.
     */
    Viridis: "VIRIDIS",
    /**
     * Positive: red. Negative: red.
     */
    Red: "RED",
    /**
     * Positive: green. Negative: green.
     */
    Green: "GREEN",
    /**
     * Positive: green. Negative: red.
     */
    RedGreen: "RED_GREEN",
    /**
     * PiYG palette.
     */
    PinkWhiteGreen: "PINK_WHITE_GREEN",
} as const;

/**
 * The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.
 */
export type GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationColorMap = (typeof GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationColorMap)[keyof typeof GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationColorMap];

export const GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationOverlayType = {
    /**
     * Default value. This is the same as NONE.
     */
    OverlayTypeUnspecified: "OVERLAY_TYPE_UNSPECIFIED",
    /**
     * No overlay.
     */
    None: "NONE",
    /**
     * The attributions are shown on top of the original image.
     */
    Original: "ORIGINAL",
    /**
     * The attributions are shown on top of grayscaled version of the original image.
     */
    Grayscale: "GRAYSCALE",
    /**
     * The attributions are used as a mask to reveal predictive parts of the image and hide the un-predictive parts.
     */
    MaskBlack: "MASK_BLACK",
} as const;

/**
 * How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.
 */
export type GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationOverlayType = (typeof GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationOverlayType)[keyof typeof GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationOverlayType];

export const GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationPolarity = {
    /**
     * Default value. This is the same as POSITIVE.
     */
    PolarityUnspecified: "POLARITY_UNSPECIFIED",
    /**
     * Highlights the pixels/outlines that were most influential to the model's prediction.
     */
    Positive: "POSITIVE",
    /**
     * Setting polarity to negative highlights areas that does not lead to the models's current prediction.
     */
    Negative: "NEGATIVE",
    /**
     * Shows both positive and negative attributions.
     */
    Both: "BOTH",
} as const;

/**
 * Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.
 */
export type GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationPolarity = (typeof GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationPolarity)[keyof typeof GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationPolarity];

export const GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationType = {
    /**
     * Should not be used.
     */
    TypeUnspecified: "TYPE_UNSPECIFIED",
    /**
     * Shows which pixel contributed to the image prediction.
     */
    Pixels: "PIXELS",
    /**
     * Shows which region contributed to the image prediction by outlining the region.
     */
    Outlines: "OUTLINES",
} as const;

/**
 * Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.
 */
export type GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationType = (typeof GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationType)[keyof typeof GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualizationType];

export const GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysisAnomalyDetectionBaseline = {
    /**
     * Should not be used.
     */
    BaselineUnspecified: "BASELINE_UNSPECIFIED",
    /**
     * Choose the later one statistics generated by either most recent snapshot analysis or previous import features analysis. If non of them exists, skip anomaly detection and only generate a statistics.
     */
    LatestStats: "LATEST_STATS",
    /**
     * Use the statistics generated by the most recent snapshot analysis if exists.
     */
    MostRecentSnapshotStats: "MOST_RECENT_SNAPSHOT_STATS",
    /**
     * Use the statistics generated by the previous import features analysis if exists.
     */
    PreviousImportFeaturesStats: "PREVIOUS_IMPORT_FEATURES_STATS",
} as const;

/**
 * The baseline used to do anomaly detection for the statistics generated by import features analysis.
 */
export type GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysisAnomalyDetectionBaseline = (typeof GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysisAnomalyDetectionBaseline)[keyof typeof GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysisAnomalyDetectionBaseline];

export const GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysisState = {
    /**
     * Should not be used.
     */
    StateUnspecified: "STATE_UNSPECIFIED",
    /**
     * The default behavior of whether to enable the monitoring. EntityType-level config: disabled. Feature-level config: inherited from the configuration of EntityType this Feature belongs to.
     */
    Default: "DEFAULT",
    /**
     * Explicitly enables import features analysis. EntityType-level config: by default enables import features analysis for all Features under it. Feature-level config: enables import features analysis regardless of the EntityType-level config.
     */
    Enabled: "ENABLED",
    /**
     * Explicitly disables import features analysis. EntityType-level config: by default disables import features analysis for all Features under it. Feature-level config: disables import features analysis regardless of the EntityType-level config.
     */
    Disabled: "DISABLED",
} as const;

/**
 * Whether to enable / disable / inherite default hebavior for import features analysis.
 */
export type GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysisState = (typeof GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysisState)[keyof typeof GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysisState];

export const GoogleCloudAiplatformV1MachineSpecAcceleratorType = {
    /**
     * Unspecified accelerator type, which means no accelerator.
     */
    AcceleratorTypeUnspecified: "ACCELERATOR_TYPE_UNSPECIFIED",
    /**
     * Nvidia Tesla K80 GPU.
     */
    NvidiaTeslaK80: "NVIDIA_TESLA_K80",
    /**
     * Nvidia Tesla P100 GPU.
     */
    NvidiaTeslaP100: "NVIDIA_TESLA_P100",
    /**
     * Nvidia Tesla V100 GPU.
     */
    NvidiaTeslaV100: "NVIDIA_TESLA_V100",
    /**
     * Nvidia Tesla P4 GPU.
     */
    NvidiaTeslaP4: "NVIDIA_TESLA_P4",
    /**
     * Nvidia Tesla T4 GPU.
     */
    NvidiaTeslaT4: "NVIDIA_TESLA_T4",
    /**
     * Nvidia Tesla A100 GPU.
     */
    NvidiaTeslaA100: "NVIDIA_TESLA_A100",
    /**
     * Nvidia A100 80GB GPU.
     */
    NvidiaA10080gb: "NVIDIA_A100_80GB",
    /**
     * Nvidia L4 GPU.
     */
    NvidiaL4: "NVIDIA_L4",
    /**
     * TPU v2.
     */
    TpuV2: "TPU_V2",
    /**
     * TPU v3.
     */
    TpuV3: "TPU_V3",
    /**
     * TPU v4.
     */
    TpuV4Pod: "TPU_V4_POD",
} as const;

/**
 * Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
 */
export type GoogleCloudAiplatformV1MachineSpecAcceleratorType = (typeof GoogleCloudAiplatformV1MachineSpecAcceleratorType)[keyof typeof GoogleCloudAiplatformV1MachineSpecAcceleratorType];

export const GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaselinePredictionFormat = {
    /**
     * Should not be set.
     */
    PredictionFormatUnspecified: "PREDICTION_FORMAT_UNSPECIFIED",
    /**
     * Predictions are in JSONL files.
     */
    Jsonl: "JSONL",
    /**
     * Predictions are in BigQuery.
     */
    Bigquery: "BIGQUERY",
} as const;

/**
 * The storage format of the predictions generated BatchPrediction job.
 */
export type GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaselinePredictionFormat = (typeof GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaselinePredictionFormat)[keyof typeof GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaselinePredictionFormat];

export const GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpecGoal = {
    /**
     * Goal Type will default to maximize.
     */
    GoalTypeUnspecified: "GOAL_TYPE_UNSPECIFIED",
    /**
     * Maximize the goal metric.
     */
    Maximize: "MAXIMIZE",
    /**
     * Minimize the goal metric.
     */
    Minimize: "MINIMIZE",
} as const;

/**
 * Required. The optimization goal of the metric.
 */
export type GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpecGoal = (typeof GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpecGoal)[keyof typeof GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpecGoal];

export const GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMultiTrialAlgorithm = {
    /**
     * Defaults to `REINFORCEMENT_LEARNING`.
     */
    MultiTrialAlgorithmUnspecified: "MULTI_TRIAL_ALGORITHM_UNSPECIFIED",
    /**
     * The Reinforcement Learning Algorithm for Multi-trial Neural Architecture Search (NAS).
     */
    ReinforcementLearning: "REINFORCEMENT_LEARNING",
    /**
     * The Grid Search Algorithm for Multi-trial Neural Architecture Search (NAS).
     */
    GridSearch: "GRID_SEARCH",
} as const;

/**
 * The multi-trial Neural Architecture Search (NAS) algorithm type. Defaults to `REINFORCEMENT_LEARNING`.
 */
export type GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMultiTrialAlgorithm = (typeof GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMultiTrialAlgorithm)[keyof typeof GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMultiTrialAlgorithm];

export const GoogleCloudAiplatformV1PipelineJobRuntimeConfigFailurePolicy = {
    /**
     * Default value, and follows fail slow behavior.
     */
    PipelineFailurePolicyUnspecified: "PIPELINE_FAILURE_POLICY_UNSPECIFIED",
    /**
     * Indicates that the pipeline should continue to run until all possible tasks have been scheduled and completed.
     */
    PipelineFailurePolicyFailSlow: "PIPELINE_FAILURE_POLICY_FAIL_SLOW",
    /**
     * Indicates that the pipeline should stop scheduling new tasks after a task has failed.
     */
    PipelineFailurePolicyFailFast: "PIPELINE_FAILURE_POLICY_FAIL_FAST",
} as const;

/**
 * Represents the failure policy of a pipeline. Currently, the default of a pipeline is that the pipeline will continue to run until no more tasks can be executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling any new tasks when a task has failed. Any scheduled tasks will continue to completion.
 */
export type GoogleCloudAiplatformV1PipelineJobRuntimeConfigFailurePolicy = (typeof GoogleCloudAiplatformV1PipelineJobRuntimeConfigFailurePolicy)[keyof typeof GoogleCloudAiplatformV1PipelineJobRuntimeConfigFailurePolicy];

export const GoogleCloudAiplatformV1PresetsModality = {
    /**
     * Should not be set. Added as a recommended best practice for enums
     */
    ModalityUnspecified: "MODALITY_UNSPECIFIED",
    /**
     * IMAGE modality
     */
    Image: "IMAGE",
    /**
     * TEXT modality
     */
    Text: "TEXT",
    /**
     * TABULAR modality
     */
    Tabular: "TABULAR",
} as const;

/**
 * The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
 */
export type GoogleCloudAiplatformV1PresetsModality = (typeof GoogleCloudAiplatformV1PresetsModality)[keyof typeof GoogleCloudAiplatformV1PresetsModality];

export const GoogleCloudAiplatformV1PresetsQuery = {
    /**
     * More precise neighbors as a trade-off against slower response.
     */
    Precise: "PRECISE",
    /**
     * Faster response as a trade-off against less precise neighbors.
     */
    Fast: "FAST",
} as const;

/**
 * Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
 */
export type GoogleCloudAiplatformV1PresetsQuery = (typeof GoogleCloudAiplatformV1PresetsQuery)[keyof typeof GoogleCloudAiplatformV1PresetsQuery];

export const GoogleCloudAiplatformV1SampleConfigSampleStrategy = {
    /**
     * Default will be treated as UNCERTAINTY.
     */
    SampleStrategyUnspecified: "SAMPLE_STRATEGY_UNSPECIFIED",
    /**
     * Sample the most uncertain data to label.
     */
    Uncertainty: "UNCERTAINTY",
} as const;

/**
 * Field to choose sampling strategy. Sampling strategy will decide which data should be selected for human labeling in every batch.
 */
export type GoogleCloudAiplatformV1SampleConfigSampleStrategy = (typeof GoogleCloudAiplatformV1SampleConfigSampleStrategy)[keyof typeof GoogleCloudAiplatformV1SampleConfigSampleStrategy];

export const GoogleCloudAiplatformV1StudySpecAlgorithm = {
    /**
     * The default algorithm used by Vertex AI for [hyperparameter tuning](https://cloud.google.com/vertex-ai/docs/training/hyperparameter-tuning-overview) and [Vertex AI Vizier](https://cloud.google.com/vertex-ai/docs/vizier).
     */
    AlgorithmUnspecified: "ALGORITHM_UNSPECIFIED",
    /**
     * Simple grid search within the feasible space. To use grid search, all parameters must be `INTEGER`, `CATEGORICAL`, or `DISCRETE`.
     */
    GridSearch: "GRID_SEARCH",
    /**
     * Simple random search within the feasible space.
     */
    RandomSearch: "RANDOM_SEARCH",
} as const;

/**
 * The search algorithm specified for the Study.
 */
export type GoogleCloudAiplatformV1StudySpecAlgorithm = (typeof GoogleCloudAiplatformV1StudySpecAlgorithm)[keyof typeof GoogleCloudAiplatformV1StudySpecAlgorithm];

export const GoogleCloudAiplatformV1StudySpecMeasurementSelectionType = {
    /**
     * Will be treated as LAST_MEASUREMENT.
     */
    MeasurementSelectionTypeUnspecified: "MEASUREMENT_SELECTION_TYPE_UNSPECIFIED",
    /**
     * Use the last measurement reported.
     */
    LastMeasurement: "LAST_MEASUREMENT",
    /**
     * Use the best measurement reported.
     */
    BestMeasurement: "BEST_MEASUREMENT",
} as const;

/**
 * Describe which measurement selection type will be used
 */
export type GoogleCloudAiplatformV1StudySpecMeasurementSelectionType = (typeof GoogleCloudAiplatformV1StudySpecMeasurementSelectionType)[keyof typeof GoogleCloudAiplatformV1StudySpecMeasurementSelectionType];

export const GoogleCloudAiplatformV1StudySpecMetricSpecGoal = {
    /**
     * Goal Type will default to maximize.
     */
    GoalTypeUnspecified: "GOAL_TYPE_UNSPECIFIED",
    /**
     * Maximize the goal metric.
     */
    Maximize: "MAXIMIZE",
    /**
     * Minimize the goal metric.
     */
    Minimize: "MINIMIZE",
} as const;

/**
 * Required. The optimization goal of the metric.
 */
export type GoogleCloudAiplatformV1StudySpecMetricSpecGoal = (typeof GoogleCloudAiplatformV1StudySpecMetricSpecGoal)[keyof typeof GoogleCloudAiplatformV1StudySpecMetricSpecGoal];

export const GoogleCloudAiplatformV1StudySpecObservationNoise = {
    /**
     * The default noise level chosen by Vertex AI.
     */
    ObservationNoiseUnspecified: "OBSERVATION_NOISE_UNSPECIFIED",
    /**
     * Vertex AI assumes that the objective function is (nearly) perfectly reproducible, and will never repeat the same Trial parameters.
     */
    Low: "LOW",
    /**
     * Vertex AI will estimate the amount of noise in metric evaluations, it may repeat the same Trial parameters more than once.
     */
    High: "HIGH",
} as const;

/**
 * The observation noise level of the study. Currently only supported by the Vertex AI Vizier service. Not supported by HyperparameterTuningJob or TrainingPipeline.
 */
export type GoogleCloudAiplatformV1StudySpecObservationNoise = (typeof GoogleCloudAiplatformV1StudySpecObservationNoise)[keyof typeof GoogleCloudAiplatformV1StudySpecObservationNoise];

export const GoogleCloudAiplatformV1StudySpecParameterSpecScaleType = {
    /**
     * By default, no scaling is applied.
     */
    ScaleTypeUnspecified: "SCALE_TYPE_UNSPECIFIED",
    /**
     * Scales the feasible space to (0, 1) linearly.
     */
    UnitLinearScale: "UNIT_LINEAR_SCALE",
    /**
     * Scales the feasible space logarithmically to (0, 1). The entire feasible space must be strictly positive.
     */
    UnitLogScale: "UNIT_LOG_SCALE",
    /**
     * Scales the feasible space "reverse" logarithmically to (0, 1). The result is that values close to the top of the feasible space are spread out more than points near the bottom. The entire feasible space must be strictly positive.
     */
    UnitReverseLogScale: "UNIT_REVERSE_LOG_SCALE",
} as const;

/**
 * How the parameter should be scaled. Leave unset for `CATEGORICAL` parameters.
 */
export type GoogleCloudAiplatformV1StudySpecParameterSpecScaleType = (typeof GoogleCloudAiplatformV1StudySpecParameterSpecScaleType)[keyof typeof GoogleCloudAiplatformV1StudySpecParameterSpecScaleType];

export const IndexIndexUpdateMethod = {
    /**
     * Should not be used.
     */
    IndexUpdateMethodUnspecified: "INDEX_UPDATE_METHOD_UNSPECIFIED",
    /**
     * BatchUpdate: user can call UpdateIndex with files on Cloud Storage of Datapoints to update.
     */
    BatchUpdate: "BATCH_UPDATE",
    /**
     * StreamUpdate: user can call UpsertDatapoints/DeleteDatapoints to update the Index and the updates will be applied in corresponding DeployedIndexes in nearly real-time.
     */
    StreamUpdate: "STREAM_UPDATE",
} as const;

/**
 * Immutable. The update method to use with this Index. If not set, BATCH_UPDATE will be used by default.
 */
export type IndexIndexUpdateMethod = (typeof IndexIndexUpdateMethod)[keyof typeof IndexIndexUpdateMethod];

export const MetadataSchemaSchemaType = {
    /**
     * Unspecified type for the MetadataSchema.
     */
    MetadataSchemaTypeUnspecified: "METADATA_SCHEMA_TYPE_UNSPECIFIED",
    /**
     * A type indicating that the MetadataSchema will be used by Artifacts.
     */
    ArtifactType: "ARTIFACT_TYPE",
    /**
     * A typee indicating that the MetadataSchema will be used by Executions.
     */
    ExecutionType: "EXECUTION_TYPE",
    /**
     * A state indicating that the MetadataSchema will be used by Contexts.
     */
    ContextType: "CONTEXT_TYPE",
} as const;

/**
 * The type of the MetadataSchema. This is a property that identifies which metadata types will use the MetadataSchema.
 */
export type MetadataSchemaSchemaType = (typeof MetadataSchemaSchemaType)[keyof typeof MetadataSchemaSchemaType];

export const NotebookRuntimeTemplateNotebookRuntimeType = {
    /**
     * Unspecified notebook runtime type, NotebookRuntimeType will default to USER_DEFINED.
     */
    NotebookRuntimeTypeUnspecified: "NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED",
    /**
     * runtime or template with coustomized configurations from user.
     */
    UserDefined: "USER_DEFINED",
    /**
     * runtime or template with system defined configurations.
     */
    OneClick: "ONE_CLICK",
} as const;

/**
 * Optional. Immutable. The type of the notebook runtime template.
 */
export type NotebookRuntimeTemplateNotebookRuntimeType = (typeof NotebookRuntimeTemplateNotebookRuntimeType)[keyof typeof NotebookRuntimeTemplateNotebookRuntimeType];

export const TimeSeriesValueType = {
    /**
     * The value type is unspecified.
     */
    ValueTypeUnspecified: "VALUE_TYPE_UNSPECIFIED",
    /**
     * Used for TensorboardTimeSeries that is a list of scalars. E.g. accuracy of a model over epochs/time.
     */
    Scalar: "SCALAR",
    /**
     * Used for TensorboardTimeSeries that is a list of tensors. E.g. histograms of weights of layer in a model over epoch/time.
     */
    Tensor: "TENSOR",
    /**
     * Used for TensorboardTimeSeries that is a list of blob sequences. E.g. set of sample images with labels over epochs/time.
     */
    BlobSequence: "BLOB_SEQUENCE",
} as const;

/**
 * Required. Immutable. Type of TensorboardTimeSeries value.
 */
export type TimeSeriesValueType = (typeof TimeSeriesValueType)[keyof typeof TimeSeriesValueType];

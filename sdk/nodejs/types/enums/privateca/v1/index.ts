// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***


export const AuditLogConfigLogType = {
    /**
     * Default case. Should never be this.
     */
    LogTypeUnspecified: "LOG_TYPE_UNSPECIFIED",
    /**
     * Admin reads. Example: CloudIAM getIamPolicy
     */
    AdminRead: "ADMIN_READ",
    /**
     * Data writes. Example: CloudSQL Users create
     */
    DataWrite: "DATA_WRITE",
    /**
     * Data reads. Example: CloudSQL Users list
     */
    DataRead: "DATA_READ",
} as const;

/**
 * The log type that this config enables.
 */
export type AuditLogConfigLogType = (typeof AuditLogConfigLogType)[keyof typeof AuditLogConfigLogType];

export const CaPoolTier = {
    /**
     * Not specified.
     */
    TierUnspecified: "TIER_UNSPECIFIED",
    /**
     * Enterprise tier.
     */
    Enterprise: "ENTERPRISE",
    /**
     * DevOps tier.
     */
    Devops: "DEVOPS",
} as const;

/**
 * Required. Immutable. The Tier of this CaPool.
 */
export type CaPoolTier = (typeof CaPoolTier)[keyof typeof CaPoolTier];

export const CertificateAuthorityType = {
    /**
     * Not specified.
     */
    TypeUnspecified: "TYPE_UNSPECIFIED",
    /**
     * Self-signed CA.
     */
    SelfSigned: "SELF_SIGNED",
    /**
     * Subordinate CA. Could be issued by a Private CA CertificateAuthority or an unmanaged CA.
     */
    Subordinate: "SUBORDINATE",
} as const;

/**
 * Required. Immutable. The Type of this CertificateAuthority.
 */
export type CertificateAuthorityType = (typeof CertificateAuthorityType)[keyof typeof CertificateAuthorityType];

export const CertificateExtensionConstraintsKnownExtensionsItem = {
    /**
     * Not specified.
     */
    KnownCertificateExtensionUnspecified: "KNOWN_CERTIFICATE_EXTENSION_UNSPECIFIED",
    /**
     * Refers to a certificate's Key Usage extension, as described in [RFC 5280 section 4.2.1.3](https://tools.ietf.org/html/rfc5280#section-4.2.1.3). This corresponds to the KeyUsage.base_key_usage field.
     */
    BaseKeyUsage: "BASE_KEY_USAGE",
    /**
     * Refers to a certificate's Extended Key Usage extension, as described in [RFC 5280 section 4.2.1.12](https://tools.ietf.org/html/rfc5280#section-4.2.1.12). This corresponds to the KeyUsage.extended_key_usage message.
     */
    ExtendedKeyUsage: "EXTENDED_KEY_USAGE",
    /**
     * Refers to a certificate's Basic Constraints extension, as described in [RFC 5280 section 4.2.1.9](https://tools.ietf.org/html/rfc5280#section-4.2.1.9). This corresponds to the X509Parameters.ca_options field.
     */
    CaOptions: "CA_OPTIONS",
    /**
     * Refers to a certificate's Policy object identifiers, as described in [RFC 5280 section 4.2.1.4](https://tools.ietf.org/html/rfc5280#section-4.2.1.4). This corresponds to the X509Parameters.policy_ids field.
     */
    PolicyIds: "POLICY_IDS",
    /**
     * Refers to OCSP servers in a certificate's Authority Information Access extension, as described in [RFC 5280 section 4.2.2.1](https://tools.ietf.org/html/rfc5280#section-4.2.2.1), This corresponds to the X509Parameters.aia_ocsp_servers field.
     */
    AiaOcspServers: "AIA_OCSP_SERVERS",
    /**
     * Refers to Name Constraints extension as described in [RFC 5280 section 4.2.1.10](https://tools.ietf.org/html/rfc5280#section-4.2.1.10)
     */
    NameConstraints: "NAME_CONSTRAINTS",
} as const;

export type CertificateExtensionConstraintsKnownExtensionsItem = (typeof CertificateExtensionConstraintsKnownExtensionsItem)[keyof typeof CertificateExtensionConstraintsKnownExtensionsItem];

export const CertificateSubjectMode = {
    /**
     * Not specified.
     */
    SubjectRequestModeUnspecified: "SUBJECT_REQUEST_MODE_UNSPECIFIED",
    /**
     * The default mode used in most cases. Indicates that the certificate's Subject and/or SubjectAltNames are specified in the certificate request. This mode requires the caller to have the `privateca.certificates.create` permission.
     */
    Default: "DEFAULT",
    /**
     * A mode reserved for special cases. Indicates that the certificate should have one SPIFFE SubjectAltNames set by the service based on the caller's identity. This mode will ignore any explicitly specified Subject and/or SubjectAltNames in the certificate request. This mode requires the caller to have the `privateca.certificates.createForSelf` permission.
     */
    ReflectedSpiffe: "REFLECTED_SPIFFE",
} as const;

/**
 * Immutable. Specifies how the Certificate's identity fields are to be decided. If this is omitted, the `DEFAULT` subject mode will be used.
 */
export type CertificateSubjectMode = (typeof CertificateSubjectMode)[keyof typeof CertificateSubjectMode];

export const EcKeyTypeSignatureAlgorithm = {
    /**
     * Not specified. Signifies that any signature algorithm may be used.
     */
    EcSignatureAlgorithmUnspecified: "EC_SIGNATURE_ALGORITHM_UNSPECIFIED",
    /**
     * Refers to the Elliptic Curve Digital Signature Algorithm over the NIST P-256 curve.
     */
    EcdsaP256: "ECDSA_P256",
    /**
     * Refers to the Elliptic Curve Digital Signature Algorithm over the NIST P-384 curve.
     */
    EcdsaP384: "ECDSA_P384",
    /**
     * Refers to the Edwards-curve Digital Signature Algorithm over curve 25519, as described in RFC 8410.
     */
    Eddsa25519: "EDDSA_25519",
} as const;

/**
 * Optional. A signature algorithm that must be used. If this is omitted, any EC-based signature algorithm will be allowed.
 */
export type EcKeyTypeSignatureAlgorithm = (typeof EcKeyTypeSignatureAlgorithm)[keyof typeof EcKeyTypeSignatureAlgorithm];

export const KeyVersionSpecAlgorithm = {
    /**
     * Not specified.
     */
    SignHashAlgorithmUnspecified: "SIGN_HASH_ALGORITHM_UNSPECIFIED",
    /**
     * maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256
     */
    RsaPss2048Sha256: "RSA_PSS_2048_SHA256",
    /**
     * maps to CryptoKeyVersionAlgorithm. RSA_SIGN_PSS_3072_SHA256
     */
    RsaPss3072Sha256: "RSA_PSS_3072_SHA256",
    /**
     * maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_4096_SHA256
     */
    RsaPss4096Sha256: "RSA_PSS_4096_SHA256",
    /**
     * maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_2048_SHA256
     */
    RsaPkcs12048Sha256: "RSA_PKCS1_2048_SHA256",
    /**
     * maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_3072_SHA256
     */
    RsaPkcs13072Sha256: "RSA_PKCS1_3072_SHA256",
    /**
     * maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_4096_SHA256
     */
    RsaPkcs14096Sha256: "RSA_PKCS1_4096_SHA256",
    /**
     * maps to CryptoKeyVersionAlgorithm.EC_SIGN_P256_SHA256
     */
    EcP256Sha256: "EC_P256_SHA256",
    /**
     * maps to CryptoKeyVersionAlgorithm.EC_SIGN_P384_SHA384
     */
    EcP384Sha384: "EC_P384_SHA384",
} as const;

/**
 * The algorithm to use for creating a managed Cloud KMS key for a for a simplified experience. All managed keys will be have their ProtectionLevel as `HSM`.
 */
export type KeyVersionSpecAlgorithm = (typeof KeyVersionSpecAlgorithm)[keyof typeof KeyVersionSpecAlgorithm];

export const PublicKeyFormat = {
    /**
     * Default unspecified value.
     */
    KeyFormatUnspecified: "KEY_FORMAT_UNSPECIFIED",
    /**
     * The key is PEM-encoded as defined in [RFC 7468](https://tools.ietf.org/html/rfc7468). It can be any of the following: a PEM-encoded PKCS#1/RFC 3447 RSAPublicKey structure, an RFC 5280 [SubjectPublicKeyInfo](https://tools.ietf.org/html/rfc5280#section-4.1) or a PEM-encoded X.509 certificate signing request (CSR). If a [SubjectPublicKeyInfo](https://tools.ietf.org/html/rfc5280#section-4.1) is specified, it can contain a A PEM-encoded PKCS#1/RFC 3447 RSAPublicKey or a NIST P-256/secp256r1/prime256v1 or P-384 key. If a CSR is specified, it will used solely for the purpose of extracting the public key. When generated by the service, it will always be an RFC 5280 [SubjectPublicKeyInfo](https://tools.ietf.org/html/rfc5280#section-4.1) structure containing an algorithm identifier and a key.
     */
    Pem: "PEM",
} as const;

/**
 * Required. The format of the public key.
 */
export type PublicKeyFormat = (typeof PublicKeyFormat)[keyof typeof PublicKeyFormat];

export const PublishingOptionsEncodingFormat = {
    /**
     * Not specified. By default, PEM format will be used.
     */
    EncodingFormatUnspecified: "ENCODING_FORMAT_UNSPECIFIED",
    /**
     * The CertificateAuthority's CA certificate and CRLs will be published in PEM format.
     */
    Pem: "PEM",
    /**
     * The CertificateAuthority's CA certificate and CRLs will be published in DER format.
     */
    Der: "DER",
} as const;

/**
 * Optional. Specifies the encoding format of each CertificateAuthority's CA certificate and CRLs. If this is omitted, CA certificates and CRLs will be published in PEM.
 */
export type PublishingOptionsEncodingFormat = (typeof PublishingOptionsEncodingFormat)[keyof typeof PublishingOptionsEncodingFormat];

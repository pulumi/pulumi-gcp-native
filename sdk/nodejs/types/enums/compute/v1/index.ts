// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***


export const AccessConfigNetworkTier = {
    Premium: "PREMIUM",
    Standard: "STANDARD",
} as const;

/**
 * This signifies the networking tier used for configuring this access configuration and can only take the following values: PREMIUM, STANDARD.
 *
 * If an AccessConfig is specified without a valid external IP address, an ephemeral IP will be created with this networkTier.
 *
 * If an AccessConfig with a valid external IP address is specified, it must match that of the networkTier associated with the Address resource owning that IP.
 */
export type AccessConfigNetworkTier = (typeof AccessConfigNetworkTier)[keyof typeof AccessConfigNetworkTier];

export const AccessConfigType = {
    OneToOneNat: "ONE_TO_ONE_NAT",
} as const;

/**
 * The type of configuration. The default and only option is ONE_TO_ONE_NAT.
 */
export type AccessConfigType = (typeof AccessConfigType)[keyof typeof AccessConfigType];

export const AddressAddressType = {
    External: "EXTERNAL",
    Internal: "INTERNAL",
    UnspecifiedType: "UNSPECIFIED_TYPE",
} as const;

/**
 * The type of address to reserve, either INTERNAL or EXTERNAL. If unspecified, defaults to EXTERNAL.
 */
export type AddressAddressType = (typeof AddressAddressType)[keyof typeof AddressAddressType];

export const AddressIpVersion = {
    Ipv4: "IPV4",
    Ipv6: "IPV6",
    UnspecifiedVersion: "UNSPECIFIED_VERSION",
} as const;

/**
 * The IP version that will be used by this address. Valid options are IPV4 or IPV6. This can only be specified for a global address.
 */
export type AddressIpVersion = (typeof AddressIpVersion)[keyof typeof AddressIpVersion];

export const AddressNetworkTier = {
    Premium: "PREMIUM",
    Standard: "STANDARD",
} as const;

/**
 * This signifies the networking tier used for configuring this address and can only take the following values: PREMIUM or STANDARD. Global forwarding rules can only be Premium Tier. Regional forwarding rules can be either Premium or Standard Tier. Standard Tier addresses applied to regional forwarding rules can be used with any external load balancer. Regional forwarding rules in Premium Tier can only be used with a network load balancer.
 *
 * If this field is not specified, it is assumed to be PREMIUM.
 */
export type AddressNetworkTier = (typeof AddressNetworkTier)[keyof typeof AddressNetworkTier];

export const AddressPurpose = {
    DnsResolver: "DNS_RESOLVER",
    GceEndpoint: "GCE_ENDPOINT",
    IpsecInterconnect: "IPSEC_INTERCONNECT",
    NatAuto: "NAT_AUTO",
    PrivateServiceConnect: "PRIVATE_SERVICE_CONNECT",
    SharedLoadbalancerVip: "SHARED_LOADBALANCER_VIP",
    VpcPeering: "VPC_PEERING",
} as const;

/**
 * The purpose of this resource, which can be one of the following values:  
 * - `GCE_ENDPOINT` for addresses that are used by VM instances, alias IP ranges, internal load balancers, and similar resources. 
 * - `DNS_RESOLVER` for a DNS resolver address in a subnetwork 
 * - `VPC_PEERING` for addresses that are reserved for VPC peer networks. 
 * - `NAT_AUTO` for addresses that are external IP addresses automatically reserved for Cloud NAT. 
 * - `IPSEC_INTERCONNECT` for addresses created from a private IP range that are reserved for a VLAN attachment in an IPsec-encrypted Cloud Interconnect configuration. These addresses are regional resources.
 */
export type AddressPurpose = (typeof AddressPurpose)[keyof typeof AddressPurpose];

export const AddressStatus = {
    InUse: "IN_USE",
    Reserved: "RESERVED",
    Reserving: "RESERVING",
} as const;

/**
 * [Output Only] The status of the address, which can be one of RESERVING, RESERVED, or IN_USE. An address that is RESERVING is currently in the process of being reserved. A RESERVED address is currently reserved and available to use. An IN_USE address is currently being used by another resource and is not available.
 */
export type AddressStatus = (typeof AddressStatus)[keyof typeof AddressStatus];

export const AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface = {
    Nvme: "NVME",
    Scsi: "SCSI",
} as const;

/**
 * Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI. For performance characteristics of SCSI over NVMe, see Local SSD performance.
 */
export type AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface = (typeof AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface)[keyof typeof AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface];

export const AttachedDiskInitializeParamsOnUpdateAction = {
    RecreateDisk: "RECREATE_DISK",
    RecreateDiskIfSourceChanged: "RECREATE_DISK_IF_SOURCE_CHANGED",
    UseExistingDisk: "USE_EXISTING_DISK",
} as const;

/**
 * Specifies which action to take on instance update with this disk. Default is to use the existing disk.
 */
export type AttachedDiskInitializeParamsOnUpdateAction = (typeof AttachedDiskInitializeParamsOnUpdateAction)[keyof typeof AttachedDiskInitializeParamsOnUpdateAction];

export const AttachedDiskInterface = {
    Nvme: "NVME",
    Scsi: "SCSI",
} as const;

/**
 * Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI and the request will fail if you attempt to attach a persistent disk in any other format than SCSI. Local SSDs can use either NVME or SCSI. For performance characteristics of SCSI over NVMe, see Local SSD performance.
 */
export type AttachedDiskInterface = (typeof AttachedDiskInterface)[keyof typeof AttachedDiskInterface];

export const AttachedDiskMode = {
    ReadOnly: "READ_ONLY",
    ReadWrite: "READ_WRITE",
} as const;

/**
 * The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If not specified, the default is to attach the disk in READ_WRITE mode.
 */
export type AttachedDiskMode = (typeof AttachedDiskMode)[keyof typeof AttachedDiskMode];

export const AttachedDiskType = {
    Persistent: "PERSISTENT",
    Scratch: "SCRATCH",
} as const;

/**
 * Specifies the type of the disk, either SCRATCH or PERSISTENT. If not specified, the default is PERSISTENT.
 */
export type AttachedDiskType = (typeof AttachedDiskType)[keyof typeof AttachedDiskType];

export const AuditLogConfigLogType = {
    AdminRead: "ADMIN_READ",
    DataRead: "DATA_READ",
    DataWrite: "DATA_WRITE",
    LogTypeUnspecified: "LOG_TYPE_UNSPECIFIED",
} as const;

/**
 * The log type that this config enables.
 */
export type AuditLogConfigLogType = (typeof AuditLogConfigLogType)[keyof typeof AuditLogConfigLogType];

export const AuthorizationLoggingOptionsPermissionType = {
    AdminRead: "ADMIN_READ",
    AdminWrite: "ADMIN_WRITE",
    DataRead: "DATA_READ",
    DataWrite: "DATA_WRITE",
    PermissionTypeUnspecified: "PERMISSION_TYPE_UNSPECIFIED",
} as const;

/**
 * The type of the permission that was checked.
 */
export type AuthorizationLoggingOptionsPermissionType = (typeof AuthorizationLoggingOptionsPermissionType)[keyof typeof AuthorizationLoggingOptionsPermissionType];

export const AutoscalerStatus = {
    Active: "ACTIVE",
    Deleting: "DELETING",
    Error: "ERROR",
    Pending: "PENDING",
} as const;

/**
 * [Output Only] The status of the autoscaler configuration. Current set of possible values:  
 * - PENDING: Autoscaler backend hasn't read new/updated configuration. 
 * - DELETING: Configuration is being deleted. 
 * - ACTIVE: Configuration is acknowledged to be effective. Some warnings might be present in the statusDetails field. 
 * - ERROR: Configuration has errors. Actionable for users. Details are present in the statusDetails field.  New values might be added in the future.
 */
export type AutoscalerStatus = (typeof AutoscalerStatus)[keyof typeof AutoscalerStatus];

export const AutoscalerStatusDetailsType = {
    AllInstancesUnhealthy: "ALL_INSTANCES_UNHEALTHY",
    BackendServiceDoesNotExist: "BACKEND_SERVICE_DOES_NOT_EXIST",
    CappedAtMaxNumReplicas: "CAPPED_AT_MAX_NUM_REPLICAS",
    CustomMetricDataPointsTooSparse: "CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE",
    CustomMetricInvalid: "CUSTOM_METRIC_INVALID",
    MinEqualsMax: "MIN_EQUALS_MAX",
    MissingCustomMetricDataPoints: "MISSING_CUSTOM_METRIC_DATA_POINTS",
    MissingLoadBalancingDataPoints: "MISSING_LOAD_BALANCING_DATA_POINTS",
    ModeOff: "MODE_OFF",
    ModeOnlyScaleOut: "MODE_ONLY_SCALE_OUT",
    ModeOnlyUp: "MODE_ONLY_UP",
    MoreThanOneBackendService: "MORE_THAN_ONE_BACKEND_SERVICE",
    NotEnoughQuotaAvailable: "NOT_ENOUGH_QUOTA_AVAILABLE",
    RegionResourceStockout: "REGION_RESOURCE_STOCKOUT",
    ScalingTargetDoesNotExist: "SCALING_TARGET_DOES_NOT_EXIST",
    ScheduledInstancesGreaterThanAutoscalerMax: "SCHEDULED_INSTANCES_GREATER_THAN_AUTOSCALER_MAX",
    ScheduledInstancesLessThanAutoscalerMin: "SCHEDULED_INSTANCES_LESS_THAN_AUTOSCALER_MIN",
    Unknown: "UNKNOWN",
    UnsupportedMaxRateLoadBalancingConfiguration: "UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION",
    ZoneResourceStockout: "ZONE_RESOURCE_STOCKOUT",
} as const;

/**
 * The type of error, warning, or notice returned. Current set of possible values:  
 * - ALL_INSTANCES_UNHEALTHY (WARNING): All instances in the instance group are unhealthy (not in RUNNING state). 
 * - BACKEND_SERVICE_DOES_NOT_EXIST (ERROR): There is no backend service attached to the instance group. 
 * - CAPPED_AT_MAX_NUM_REPLICAS (WARNING): Autoscaler recommends a size greater than maxNumReplicas. 
 * - CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE (WARNING): The custom metric samples are not exported often enough to be a credible base for autoscaling. 
 * - CUSTOM_METRIC_INVALID (ERROR): The custom metric that was specified does not exist or does not have the necessary labels. 
 * - MIN_EQUALS_MAX (WARNING): The minNumReplicas is equal to maxNumReplicas. This means the autoscaler cannot add or remove instances from the instance group. 
 * - MISSING_CUSTOM_METRIC_DATA_POINTS (WARNING): The autoscaler did not receive any data from the custom metric configured for autoscaling. 
 * - MISSING_LOAD_BALANCING_DATA_POINTS (WARNING): The autoscaler is configured to scale based on a load balancing signal but the instance group has not received any requests from the load balancer. 
 * - MODE_OFF (WARNING): Autoscaling is turned off. The number of instances in the group won't change automatically. The autoscaling configuration is preserved. 
 * - MODE_ONLY_UP (WARNING): Autoscaling is in the "Autoscale only out" mode. The autoscaler can add instances but not remove any. 
 * - MORE_THAN_ONE_BACKEND_SERVICE (ERROR): The instance group cannot be autoscaled because it has more than one backend service attached to it. 
 * - NOT_ENOUGH_QUOTA_AVAILABLE (ERROR): There is insufficient quota for the necessary resources, such as CPU or number of instances. 
 * - REGION_RESOURCE_STOCKOUT (ERROR): Shown only for regional autoscalers: there is a resource stockout in the chosen region. 
 * - SCALING_TARGET_DOES_NOT_EXIST (ERROR): The target to be scaled does not exist. 
 * - UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION (ERROR): Autoscaling does not work with an HTTP/S load balancer that has been configured for maxRate. 
 * - ZONE_RESOURCE_STOCKOUT (ERROR): For zonal autoscalers: there is a resource stockout in the chosen zone. For regional autoscalers: in at least one of the zones you're using there is a resource stockout.  New values might be added in the future. Some of the values might not be available in all API versions.
 */
export type AutoscalerStatusDetailsType = (typeof AutoscalerStatusDetailsType)[keyof typeof AutoscalerStatusDetailsType];

export const AutoscalingPolicyCpuUtilizationPredictiveMethod = {
    None: "NONE",
    OptimizeAvailability: "OPTIMIZE_AVAILABILITY",
} as const;

/**
 * Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are:
 *
 * * NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics. * OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
 */
export type AutoscalingPolicyCpuUtilizationPredictiveMethod = (typeof AutoscalingPolicyCpuUtilizationPredictiveMethod)[keyof typeof AutoscalingPolicyCpuUtilizationPredictiveMethod];

export const AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType = {
    DeltaPerMinute: "DELTA_PER_MINUTE",
    DeltaPerSecond: "DELTA_PER_SECOND",
    Gauge: "GAUGE",
} as const;

/**
 * Defines how target utilization value is expressed for a Stackdriver Monitoring metric. Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE.
 */
export type AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType = (typeof AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType)[keyof typeof AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType];

export const AutoscalingPolicyMode = {
    Off: "OFF",
    On: "ON",
    OnlyScaleOut: "ONLY_SCALE_OUT",
    OnlyUp: "ONLY_UP",
} as const;

/**
 * Defines operating mode for this policy.
 */
export type AutoscalingPolicyMode = (typeof AutoscalingPolicyMode)[keyof typeof AutoscalingPolicyMode];

export const BackendBalancingMode = {
    Connection: "CONNECTION",
    Rate: "RATE",
    Utilization: "UTILIZATION",
} as const;

/**
 * Specifies how to determine whether the backend of a load balancer can handle additional traffic or is fully loaded. For usage guidelines, see  Connection balancing mode.
 */
export type BackendBalancingMode = (typeof BackendBalancingMode)[keyof typeof BackendBalancingMode];

export const BackendBucketCdnPolicyCacheMode = {
    CacheAllStatic: "CACHE_ALL_STATIC",
    ForceCacheAll: "FORCE_CACHE_ALL",
    InvalidCacheMode: "INVALID_CACHE_MODE",
    UseOriginHeaders: "USE_ORIGIN_HEADERS",
} as const;

/**
 * Specifies the cache setting for all responses from this backend. The possible values are:
 *
 * USE_ORIGIN_HEADERS Requires the origin to set valid caching headers to cache content. Responses without these headers will not be cached at Google's edge, and will require a full trip to the origin on every request, potentially impacting performance and increasing load on the origin server.
 *
 * FORCE_CACHE_ALL Cache all content, ignoring any "private", "no-store" or "no-cache" directives in Cache-Control response headers. Warning: this may result in Cloud CDN caching private, per-user (user identifiable) content.
 *
 * CACHE_ALL_STATIC Automatically cache static content, including common image formats, media (video and audio), and web assets (JavaScript and CSS). Requests and responses that are marked as uncacheable, as well as dynamic content (including HTML), will not be cached.
 */
export type BackendBucketCdnPolicyCacheMode = (typeof BackendBucketCdnPolicyCacheMode)[keyof typeof BackendBucketCdnPolicyCacheMode];

export const BackendServiceCdnPolicyCacheMode = {
    CacheAllStatic: "CACHE_ALL_STATIC",
    ForceCacheAll: "FORCE_CACHE_ALL",
    InvalidCacheMode: "INVALID_CACHE_MODE",
    UseOriginHeaders: "USE_ORIGIN_HEADERS",
} as const;

/**
 * Specifies the cache setting for all responses from this backend. The possible values are:
 *
 * USE_ORIGIN_HEADERS Requires the origin to set valid caching headers to cache content. Responses without these headers will not be cached at Google's edge, and will require a full trip to the origin on every request, potentially impacting performance and increasing load on the origin server.
 *
 * FORCE_CACHE_ALL Cache all content, ignoring any "private", "no-store" or "no-cache" directives in Cache-Control response headers. Warning: this may result in Cloud CDN caching private, per-user (user identifiable) content.
 *
 * CACHE_ALL_STATIC Automatically cache static content, including common image formats, media (video and audio), and web assets (JavaScript and CSS). Requests and responses that are marked as uncacheable, as well as dynamic content (including HTML), will not be cached.
 */
export type BackendServiceCdnPolicyCacheMode = (typeof BackendServiceCdnPolicyCacheMode)[keyof typeof BackendServiceCdnPolicyCacheMode];

export const BackendServiceLoadBalancingScheme = {
    External: "EXTERNAL",
    Internal: "INTERNAL",
    InternalManaged: "INTERNAL_MANAGED",
    InternalSelfManaged: "INTERNAL_SELF_MANAGED",
    InvalidLoadBalancingScheme: "INVALID_LOAD_BALANCING_SCHEME",
} as const;

/**
 * Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose  INTERNAL for Internal TCP/UDP Load Balancing. Choose  INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.  INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
 */
export type BackendServiceLoadBalancingScheme = (typeof BackendServiceLoadBalancingScheme)[keyof typeof BackendServiceLoadBalancingScheme];

export const BackendServiceLocalityLbPolicy = {
    InvalidLbPolicy: "INVALID_LB_POLICY",
    LeastRequest: "LEAST_REQUEST",
    Maglev: "MAGLEV",
    OriginalDestination: "ORIGINAL_DESTINATION",
    Random: "RANDOM",
    RingHash: "RING_HASH",
    RoundRobin: "ROUND_ROBIN",
} as const;

/**
 * The load balancing algorithm used within the scope of the locality. The possible values are:  
 * - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default. 
 * - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests. 
 * - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests. 
 * - RANDOM: The load balancer selects a random healthy host. 
 * - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer. 
 * - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824 
 *
 * This field is applicable to either:  
 * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED. 
 * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.  
 *
 * If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect.
 *
 * Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
 */
export type BackendServiceLocalityLbPolicy = (typeof BackendServiceLocalityLbPolicy)[keyof typeof BackendServiceLocalityLbPolicy];

export const BackendServiceProtocol = {
    Grpc: "GRPC",
    Http: "HTTP",
    Http2: "HTTP2",
    Https: "HTTPS",
    Ssl: "SSL",
    Tcp: "TCP",
    Udp: "UDP",
} as const;

/**
 * The protocol this BackendService uses to communicate with backends.
 *
 * Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information.
 *
 * Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
 */
export type BackendServiceProtocol = (typeof BackendServiceProtocol)[keyof typeof BackendServiceProtocol];

export const BackendServiceSessionAffinity = {
    ClientIp: "CLIENT_IP",
    ClientIpNoDestination: "CLIENT_IP_NO_DESTINATION",
    ClientIpPortProto: "CLIENT_IP_PORT_PROTO",
    ClientIpProto: "CLIENT_IP_PROTO",
    GeneratedCookie: "GENERATED_COOKIE",
    HeaderField: "HEADER_FIELD",
    HttpCookie: "HTTP_COOKIE",
    None: "NONE",
} as const;

/**
 * Type of session affinity to use. The default is NONE.
 *
 * When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or  CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS.
 *
 * When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
 *
 * When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
 *
 * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
 */
export type BackendServiceSessionAffinity = (typeof BackendServiceSessionAffinity)[keyof typeof BackendServiceSessionAffinity];

export const ConditionIam = {
    Approver: "APPROVER",
    Attribution: "ATTRIBUTION",
    Authority: "AUTHORITY",
    CredentialsType: "CREDENTIALS_TYPE",
    CredsAssertion: "CREDS_ASSERTION",
    JustificationType: "JUSTIFICATION_TYPE",
    NoAttr: "NO_ATTR",
    SecurityRealm: "SECURITY_REALM",
} as const;

/**
 * Trusted attributes supplied by the IAM system.
 */
export type ConditionIam = (typeof ConditionIam)[keyof typeof ConditionIam];

export const ConditionOp = {
    Discharged: "DISCHARGED",
    Equals: "EQUALS",
    In: "IN",
    NotEquals: "NOT_EQUALS",
    NotIn: "NOT_IN",
    NoOp: "NO_OP",
} as const;

/**
 * An operator to apply the subject with.
 */
export type ConditionOp = (typeof ConditionOp)[keyof typeof ConditionOp];

export const ConditionSys = {
    Ip: "IP",
    Name: "NAME",
    NoAttr: "NO_ATTR",
    Region: "REGION",
    Service: "SERVICE",
} as const;

/**
 * Trusted attributes supplied by any service that owns resources and uses the IAM system for access control.
 */
export type ConditionSys = (typeof ConditionSys)[keyof typeof ConditionSys];

export const DeprecationStatusState = {
    Active: "ACTIVE",
    Deleted: "DELETED",
    Deprecated: "DEPRECATED",
    Obsolete: "OBSOLETE",
} as const;

/**
 * The deprecation state of this resource. This can be ACTIVE, DEPRECATED, OBSOLETE, or DELETED. Operations which communicate the end of life date for an image, can use ACTIVE. Operations which create a new resource using a DEPRECATED resource will return successfully, but with a warning indicating the deprecated resource and recommending its replacement. Operations which use OBSOLETE or DELETED resources will be rejected and result in an error.
 */
export type DeprecationStatusState = (typeof DeprecationStatusState)[keyof typeof DeprecationStatusState];

export const DiskInstantiationConfigInstantiateFrom = {
    AttachReadOnly: "ATTACH_READ_ONLY",
    Blank: "BLANK",
    CustomImage: "CUSTOM_IMAGE",
    Default: "DEFAULT",
    DoNotInclude: "DO_NOT_INCLUDE",
    SourceImage: "SOURCE_IMAGE",
    SourceImageFamily: "SOURCE_IMAGE_FAMILY",
} as const;

/**
 * Specifies whether to include the disk and what image to use. Possible values are:  
 * - source-image: to use the same image that was used to create the source instance's corresponding disk. Applicable to the boot disk and additional read-write disks. 
 * - source-image-family: to use the same image family that was used to create the source instance's corresponding disk. Applicable to the boot disk and additional read-write disks. 
 * - custom-image: to use a user-provided image url for disk creation. Applicable to the boot disk and additional read-write disks. 
 * - attach-read-only: to attach a read-only disk. Applicable to read-only disks. 
 * - do-not-include: to exclude a disk from the template. Applicable to additional read-write disks, local SSDs, and read-only disks.
 */
export type DiskInstantiationConfigInstantiateFrom = (typeof DiskInstantiationConfigInstantiateFrom)[keyof typeof DiskInstantiationConfigInstantiateFrom];

export const DiskStatus = {
    Creating: "CREATING",
    Deleting: "DELETING",
    Failed: "FAILED",
    Ready: "READY",
    Restoring: "RESTORING",
} as const;

/**
 * [Output Only] The status of disk creation.  
 * - CREATING: Disk is provisioning. 
 * - RESTORING: Source data is being copied into the disk. 
 * - FAILED: Disk creation failed. 
 * - READY: Disk is ready for use. 
 * - DELETING: Disk is deleting.
 */
export type DiskStatus = (typeof DiskStatus)[keyof typeof DiskStatus];

export const DistributionPolicyTargetShape = {
    Any: "ANY",
    Balanced: "BALANCED",
    Even: "EVEN",
} as const;

/**
 * The distribution shape to which the group converges either proactively or on resize events (depending on the value set in updatePolicy.instanceRedistributionType).
 */
export type DistributionPolicyTargetShape = (typeof DistributionPolicyTargetShape)[keyof typeof DistributionPolicyTargetShape];

export const ExternalVpnGatewayRedundancyType = {
    FourIpsRedundancy: "FOUR_IPS_REDUNDANCY",
    SingleIpInternallyRedundant: "SINGLE_IP_INTERNALLY_REDUNDANT",
    TwoIpsRedundancy: "TWO_IPS_REDUNDANCY",
} as const;

/**
 * Indicates the user-supplied redundancy type of this external VPN gateway.
 */
export type ExternalVpnGatewayRedundancyType = (typeof ExternalVpnGatewayRedundancyType)[keyof typeof ExternalVpnGatewayRedundancyType];

export const FileContentBufferFileType = {
    Bin: "BIN",
    Undefined: "UNDEFINED",
    X509: "X509",
} as const;

/**
 * The file type of source file.
 */
export type FileContentBufferFileType = (typeof FileContentBufferFileType)[keyof typeof FileContentBufferFileType];

export const FirewallDirection = {
    Egress: "EGRESS",
    Ingress: "INGRESS",
} as const;

/**
 * Direction of traffic to which this firewall applies, either `INGRESS` or `EGRESS`. The default is `INGRESS`. For `INGRESS` traffic, you cannot specify the destinationRanges field, and for `EGRESS` traffic, you cannot specify the sourceRanges or sourceTags fields.
 */
export type FirewallDirection = (typeof FirewallDirection)[keyof typeof FirewallDirection];

export const FirewallLogConfigMetadata = {
    ExcludeAllMetadata: "EXCLUDE_ALL_METADATA",
    IncludeAllMetadata: "INCLUDE_ALL_METADATA",
} as const;

/**
 * This field can only be specified for a particular firewall rule if logging is enabled for that rule. This field denotes whether to include or exclude metadata for firewall logs.
 */
export type FirewallLogConfigMetadata = (typeof FirewallLogConfigMetadata)[keyof typeof FirewallLogConfigMetadata];

export const FirewallPolicyRuleDirection = {
    Egress: "EGRESS",
    Ingress: "INGRESS",
} as const;

/**
 * The direction in which this rule applies.
 */
export type FirewallPolicyRuleDirection = (typeof FirewallPolicyRuleDirection)[keyof typeof FirewallPolicyRuleDirection];

export const ForwardingRuleIPProtocol = {
    Ah: "AH",
    Esp: "ESP",
    Icmp: "ICMP",
    Sctp: "SCTP",
    Tcp: "TCP",
    Udp: "UDP",
} as const;

/**
 * The IP protocol to which this rule applies.
 *
 * For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and ICMP.
 *
 * The valid IP protocols are different for different load balancing products:  
 * - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or ALL is valid. 
 * - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid.  
 * - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid. 
 * - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid. 
 * - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP or UDP is valid.
 */
export type ForwardingRuleIPProtocol = (typeof ForwardingRuleIPProtocol)[keyof typeof ForwardingRuleIPProtocol];

export const ForwardingRuleIpVersion = {
    Ipv4: "IPV4",
    Ipv6: "IPV6",
    UnspecifiedVersion: "UNSPECIFIED_VERSION",
} as const;

/**
 * The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
 */
export type ForwardingRuleIpVersion = (typeof ForwardingRuleIpVersion)[keyof typeof ForwardingRuleIpVersion];

export const ForwardingRuleLoadBalancingScheme = {
    External: "EXTERNAL",
    Internal: "INTERNAL",
    InternalManaged: "INTERNAL_MANAGED",
    InternalSelfManaged: "INTERNAL_SELF_MANAGED",
    Invalid: "INVALID",
} as const;

/**
 * Specifies the forwarding rule type.
 *
 *  
 * - EXTERNAL is used for:  
 * - Classic Cloud VPN gateways 
 * - Protocol forwarding to VMs from an external IP address 
 * - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing    
 * - INTERNAL is used for:  
 * - Protocol forwarding to VMs from an internal IP address 
 * - Internal TCP/UDP Load Balancing   
 * - INTERNAL_MANAGED is used for:  
 * - Internal HTTP(S) Load Balancing   
 * - INTERNAL_SELF_MANAGED is used for:  
 * - Traffic Director    
 *
 * For more information about forwarding rules, refer to Forwarding rule concepts.
 */
export type ForwardingRuleLoadBalancingScheme = (typeof ForwardingRuleLoadBalancingScheme)[keyof typeof ForwardingRuleLoadBalancingScheme];

export const ForwardingRuleNetworkTier = {
    Premium: "PREMIUM",
    Standard: "STANDARD",
} as const;

/**
 * This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD.
 *
 * For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
 *
 * If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
 */
export type ForwardingRuleNetworkTier = (typeof ForwardingRuleNetworkTier)[keyof typeof ForwardingRuleNetworkTier];

export const GRPCHealthCheckPortSpecification = {
    UseFixedPort: "USE_FIXED_PORT",
    UseNamedPort: "USE_NAMED_PORT",
    UseServingPort: "USE_SERVING_PORT",
} as const;

/**
 * Specifies how port is selected for health checking, can be one of following values:
 * USE_FIXED_PORT: The port number in port is used for health checking.
 * USE_NAMED_PORT: The portName is used for health checking.
 * USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
 *
 *
 * If not specified, gRPC health check follows behavior specified in port and portName fields.
 */
export type GRPCHealthCheckPortSpecification = (typeof GRPCHealthCheckPortSpecification)[keyof typeof GRPCHealthCheckPortSpecification];

export const GlobalAddressAddressType = {
    External: "EXTERNAL",
    Internal: "INTERNAL",
    UnspecifiedType: "UNSPECIFIED_TYPE",
} as const;

/**
 * The type of address to reserve, either INTERNAL or EXTERNAL. If unspecified, defaults to EXTERNAL.
 */
export type GlobalAddressAddressType = (typeof GlobalAddressAddressType)[keyof typeof GlobalAddressAddressType];

export const GlobalAddressIpVersion = {
    Ipv4: "IPV4",
    Ipv6: "IPV6",
    UnspecifiedVersion: "UNSPECIFIED_VERSION",
} as const;

/**
 * The IP version that will be used by this address. Valid options are IPV4 or IPV6. This can only be specified for a global address.
 */
export type GlobalAddressIpVersion = (typeof GlobalAddressIpVersion)[keyof typeof GlobalAddressIpVersion];

export const GlobalAddressNetworkTier = {
    Premium: "PREMIUM",
    Standard: "STANDARD",
} as const;

/**
 * This signifies the networking tier used for configuring this address and can only take the following values: PREMIUM or STANDARD. Global forwarding rules can only be Premium Tier. Regional forwarding rules can be either Premium or Standard Tier. Standard Tier addresses applied to regional forwarding rules can be used with any external load balancer. Regional forwarding rules in Premium Tier can only be used with a network load balancer.
 *
 * If this field is not specified, it is assumed to be PREMIUM.
 */
export type GlobalAddressNetworkTier = (typeof GlobalAddressNetworkTier)[keyof typeof GlobalAddressNetworkTier];

export const GlobalAddressPurpose = {
    DnsResolver: "DNS_RESOLVER",
    GceEndpoint: "GCE_ENDPOINT",
    IpsecInterconnect: "IPSEC_INTERCONNECT",
    NatAuto: "NAT_AUTO",
    PrivateServiceConnect: "PRIVATE_SERVICE_CONNECT",
    SharedLoadbalancerVip: "SHARED_LOADBALANCER_VIP",
    VpcPeering: "VPC_PEERING",
} as const;

/**
 * The purpose of this resource, which can be one of the following values:  
 * - `GCE_ENDPOINT` for addresses that are used by VM instances, alias IP ranges, internal load balancers, and similar resources. 
 * - `DNS_RESOLVER` for a DNS resolver address in a subnetwork 
 * - `VPC_PEERING` for addresses that are reserved for VPC peer networks. 
 * - `NAT_AUTO` for addresses that are external IP addresses automatically reserved for Cloud NAT. 
 * - `IPSEC_INTERCONNECT` for addresses created from a private IP range that are reserved for a VLAN attachment in an IPsec-encrypted Cloud Interconnect configuration. These addresses are regional resources.
 */
export type GlobalAddressPurpose = (typeof GlobalAddressPurpose)[keyof typeof GlobalAddressPurpose];

export const GlobalAddressStatus = {
    InUse: "IN_USE",
    Reserved: "RESERVED",
    Reserving: "RESERVING",
} as const;

/**
 * [Output Only] The status of the address, which can be one of RESERVING, RESERVED, or IN_USE. An address that is RESERVING is currently in the process of being reserved. A RESERVED address is currently reserved and available to use. An IN_USE address is currently being used by another resource and is not available.
 */
export type GlobalAddressStatus = (typeof GlobalAddressStatus)[keyof typeof GlobalAddressStatus];

export const GlobalForwardingRuleIPProtocol = {
    Ah: "AH",
    Esp: "ESP",
    Icmp: "ICMP",
    Sctp: "SCTP",
    Tcp: "TCP",
    Udp: "UDP",
} as const;

/**
 * The IP protocol to which this rule applies.
 *
 * For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and ICMP.
 *
 * The valid IP protocols are different for different load balancing products:  
 * - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or ALL is valid. 
 * - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid.  
 * - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid. 
 * - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid. 
 * - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP or UDP is valid.
 */
export type GlobalForwardingRuleIPProtocol = (typeof GlobalForwardingRuleIPProtocol)[keyof typeof GlobalForwardingRuleIPProtocol];

export const GlobalForwardingRuleIpVersion = {
    Ipv4: "IPV4",
    Ipv6: "IPV6",
    UnspecifiedVersion: "UNSPECIFIED_VERSION",
} as const;

/**
 * The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
 */
export type GlobalForwardingRuleIpVersion = (typeof GlobalForwardingRuleIpVersion)[keyof typeof GlobalForwardingRuleIpVersion];

export const GlobalForwardingRuleLoadBalancingScheme = {
    External: "EXTERNAL",
    Internal: "INTERNAL",
    InternalManaged: "INTERNAL_MANAGED",
    InternalSelfManaged: "INTERNAL_SELF_MANAGED",
    Invalid: "INVALID",
} as const;

/**
 * Specifies the forwarding rule type.
 *
 *  
 * - EXTERNAL is used for:  
 * - Classic Cloud VPN gateways 
 * - Protocol forwarding to VMs from an external IP address 
 * - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing    
 * - INTERNAL is used for:  
 * - Protocol forwarding to VMs from an internal IP address 
 * - Internal TCP/UDP Load Balancing   
 * - INTERNAL_MANAGED is used for:  
 * - Internal HTTP(S) Load Balancing   
 * - INTERNAL_SELF_MANAGED is used for:  
 * - Traffic Director    
 *
 * For more information about forwarding rules, refer to Forwarding rule concepts.
 */
export type GlobalForwardingRuleLoadBalancingScheme = (typeof GlobalForwardingRuleLoadBalancingScheme)[keyof typeof GlobalForwardingRuleLoadBalancingScheme];

export const GlobalForwardingRuleNetworkTier = {
    Premium: "PREMIUM",
    Standard: "STANDARD",
} as const;

/**
 * This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD.
 *
 * For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
 *
 * If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
 */
export type GlobalForwardingRuleNetworkTier = (typeof GlobalForwardingRuleNetworkTier)[keyof typeof GlobalForwardingRuleNetworkTier];

export const GlobalNetworkEndpointGroupNetworkEndpointType = {
    GceVmIp: "GCE_VM_IP",
    GceVmIpPort: "GCE_VM_IP_PORT",
    InternetFqdnPort: "INTERNET_FQDN_PORT",
    InternetIpPort: "INTERNET_IP_PORT",
    NonGcpPrivateIpPort: "NON_GCP_PRIVATE_IP_PORT",
    Serverless: "SERVERLESS",
} as const;

/**
 * Type of network endpoints in this network endpoint group. Can be one of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT, INTERNET_IP_PORT, or SERVERLESS.
 */
export type GlobalNetworkEndpointGroupNetworkEndpointType = (typeof GlobalNetworkEndpointGroupNetworkEndpointType)[keyof typeof GlobalNetworkEndpointGroupNetworkEndpointType];

export const GlobalPublicDelegatedPrefixStatus = {
    Announced: "ANNOUNCED",
    Deleting: "DELETING",
    Initializing: "INITIALIZING",
} as const;

/**
 * [Output Only] The status of the public delegated prefix.
 */
export type GlobalPublicDelegatedPrefixStatus = (typeof GlobalPublicDelegatedPrefixStatus)[keyof typeof GlobalPublicDelegatedPrefixStatus];

export const GuestOsFeatureType = {
    FeatureTypeUnspecified: "FEATURE_TYPE_UNSPECIFIED",
    Gvnic: "GVNIC",
    MultiIpSubnet: "MULTI_IP_SUBNET",
    SecureBoot: "SECURE_BOOT",
    SevCapable: "SEV_CAPABLE",
    UefiCompatible: "UEFI_COMPATIBLE",
    VirtioScsiMultiqueue: "VIRTIO_SCSI_MULTIQUEUE",
    Windows: "WINDOWS",
} as const;

/**
 * The ID of a supported feature. Read  Enabling guest operating system features to see a list of available options.
 */
export type GuestOsFeatureType = (typeof GuestOsFeatureType)[keyof typeof GuestOsFeatureType];

export const HTTP2HealthCheckPortSpecification = {
    UseFixedPort: "USE_FIXED_PORT",
    UseNamedPort: "USE_NAMED_PORT",
    UseServingPort: "USE_SERVING_PORT",
} as const;

/**
 * Specifies how port is selected for health checking, can be one of following values:
 * USE_FIXED_PORT: The port number in port is used for health checking.
 * USE_NAMED_PORT: The portName is used for health checking.
 * USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
 *
 *
 * If not specified, HTTP2 health check follows behavior specified in port and portName fields.
 */
export type HTTP2HealthCheckPortSpecification = (typeof HTTP2HealthCheckPortSpecification)[keyof typeof HTTP2HealthCheckPortSpecification];

export const HTTP2HealthCheckProxyHeader = {
    None: "NONE",
    ProxyV1: "PROXY_V1",
} as const;

/**
 * Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
 */
export type HTTP2HealthCheckProxyHeader = (typeof HTTP2HealthCheckProxyHeader)[keyof typeof HTTP2HealthCheckProxyHeader];

export const HTTPHealthCheckPortSpecification = {
    UseFixedPort: "USE_FIXED_PORT",
    UseNamedPort: "USE_NAMED_PORT",
    UseServingPort: "USE_SERVING_PORT",
} as const;

/**
 * Specifies how port is selected for health checking, can be one of following values:
 * USE_FIXED_PORT: The port number in port is used for health checking.
 * USE_NAMED_PORT: The portName is used for health checking.
 * USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
 *
 *
 * If not specified, HTTP health check follows behavior specified in port and portName fields.
 */
export type HTTPHealthCheckPortSpecification = (typeof HTTPHealthCheckPortSpecification)[keyof typeof HTTPHealthCheckPortSpecification];

export const HTTPHealthCheckProxyHeader = {
    None: "NONE",
    ProxyV1: "PROXY_V1",
} as const;

/**
 * Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
 */
export type HTTPHealthCheckProxyHeader = (typeof HTTPHealthCheckProxyHeader)[keyof typeof HTTPHealthCheckProxyHeader];

export const HTTPSHealthCheckPortSpecification = {
    UseFixedPort: "USE_FIXED_PORT",
    UseNamedPort: "USE_NAMED_PORT",
    UseServingPort: "USE_SERVING_PORT",
} as const;

/**
 * Specifies how port is selected for health checking, can be one of following values:
 * USE_FIXED_PORT: The port number in port is used for health checking.
 * USE_NAMED_PORT: The portName is used for health checking.
 * USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
 *
 *
 * If not specified, HTTPS health check follows behavior specified in port and portName fields.
 */
export type HTTPSHealthCheckPortSpecification = (typeof HTTPSHealthCheckPortSpecification)[keyof typeof HTTPSHealthCheckPortSpecification];

export const HTTPSHealthCheckProxyHeader = {
    None: "NONE",
    ProxyV1: "PROXY_V1",
} as const;

/**
 * Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
 */
export type HTTPSHealthCheckProxyHeader = (typeof HTTPSHealthCheckProxyHeader)[keyof typeof HTTPSHealthCheckProxyHeader];

export const HealthCheckType = {
    Grpc: "GRPC",
    Http: "HTTP",
    Http2: "HTTP2",
    Https: "HTTPS",
    Invalid: "INVALID",
    Ssl: "SSL",
    Tcp: "TCP",
} as const;

/**
 * Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS or HTTP2. If not specified, the default is TCP. Exactly one of the protocol-specific health check field must be specified, which must match type field.
 */
export type HealthCheckType = (typeof HealthCheckType)[keyof typeof HealthCheckType];

export const HttpRedirectActionRedirectResponseCode = {
    Found: "FOUND",
    MovedPermanentlyDefault: "MOVED_PERMANENTLY_DEFAULT",
    PermanentRedirect: "PERMANENT_REDIRECT",
    SeeOther: "SEE_OTHER",
    TemporaryRedirect: "TEMPORARY_REDIRECT",
} as const;

/**
 * The HTTP Status code to use for this RedirectAction.
 * Supported values are:  
 * - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301. 
 * - FOUND, which corresponds to 302. 
 * - SEE_OTHER which corresponds to 303. 
 * - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method will be retained. 
 * - PERMANENT_REDIRECT, which corresponds to 308. In this case, the request method will be retained.
 */
export type HttpRedirectActionRedirectResponseCode = (typeof HttpRedirectActionRedirectResponseCode)[keyof typeof HttpRedirectActionRedirectResponseCode];

export const ImageRawDiskContainerType = {
    Tar: "TAR",
} as const;

/**
 * The format used to encode and transmit the block device, which should be TAR. This is just a container and transmission format and not a runtime format. Provided by the client when the disk image is created.
 */
export type ImageRawDiskContainerType = (typeof ImageRawDiskContainerType)[keyof typeof ImageRawDiskContainerType];

export const ImageSourceType = {
    Raw: "RAW",
} as const;

/**
 * The type of the image used to create this disk. The default and only value is RAW
 */
export type ImageSourceType = (typeof ImageSourceType)[keyof typeof ImageSourceType];

export const ImageStatus = {
    Deleting: "DELETING",
    Failed: "FAILED",
    Pending: "PENDING",
    Ready: "READY",
} as const;

/**
 * [Output Only] The status of the image. An image can be used to create other resources, such as instances, only after the image has been successfully created and the status is set to READY. Possible values are FAILED, PENDING, or READY.
 */
export type ImageStatus = (typeof ImageStatus)[keyof typeof ImageStatus];

export const InstanceGroupManagerUpdatePolicyInstanceRedistributionType = {
    None: "NONE",
    Proactive: "PROACTIVE",
} as const;

/**
 * The  instance redistribution policy for regional managed instance groups. Valid values are:  
 * - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region. 
 * - NONE: For non-autoscaled groups, proactive redistribution is disabled.
 */
export type InstanceGroupManagerUpdatePolicyInstanceRedistributionType = (typeof InstanceGroupManagerUpdatePolicyInstanceRedistributionType)[keyof typeof InstanceGroupManagerUpdatePolicyInstanceRedistributionType];

export const InstanceGroupManagerUpdatePolicyMinimalAction = {
    None: "NONE",
    Refresh: "REFRESH",
    Replace: "REPLACE",
    Restart: "RESTART",
} as const;

/**
 * Minimal action to be taken on an instance. You can specify either RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a RESTART, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
 */
export type InstanceGroupManagerUpdatePolicyMinimalAction = (typeof InstanceGroupManagerUpdatePolicyMinimalAction)[keyof typeof InstanceGroupManagerUpdatePolicyMinimalAction];

export const InstanceGroupManagerUpdatePolicyReplacementMethod = {
    Recreate: "RECREATE",
    Substitute: "SUBSTITUTE",
} as const;

/**
 * What action should be used to replace instances. See minimal_action.REPLACE
 */
export type InstanceGroupManagerUpdatePolicyReplacementMethod = (typeof InstanceGroupManagerUpdatePolicyReplacementMethod)[keyof typeof InstanceGroupManagerUpdatePolicyReplacementMethod];

export const InstanceGroupManagerUpdatePolicyType = {
    Opportunistic: "OPPORTUNISTIC",
    Proactive: "PROACTIVE",
} as const;

/**
 * The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
 */
export type InstanceGroupManagerUpdatePolicyType = (typeof InstanceGroupManagerUpdatePolicyType)[keyof typeof InstanceGroupManagerUpdatePolicyType];

export const InstancePostKeyRevocationActionType = {
    Noop: "NOOP",
    PostKeyRevocationActionTypeUnspecified: "POST_KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED",
    Shutdown: "SHUTDOWN",
} as const;

/**
 * PostKeyRevocationActionType of the instance.
 */
export type InstancePostKeyRevocationActionType = (typeof InstancePostKeyRevocationActionType)[keyof typeof InstancePostKeyRevocationActionType];

export const InstancePrivateIpv6GoogleAccess = {
    EnableBidirectionalAccessToGoogle: "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE",
    EnableOutboundVmAccessToGoogle: "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE",
    InheritFromSubnetwork: "INHERIT_FROM_SUBNETWORK",
} as const;

/**
 * The private IPv6 google access type for the VM. If not specified, use  INHERIT_FROM_SUBNETWORK as default.
 */
export type InstancePrivateIpv6GoogleAccess = (typeof InstancePrivateIpv6GoogleAccess)[keyof typeof InstancePrivateIpv6GoogleAccess];

export const InstancePropertiesPostKeyRevocationActionType = {
    Noop: "NOOP",
    PostKeyRevocationActionTypeUnspecified: "POST_KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED",
    Shutdown: "SHUTDOWN",
} as const;

/**
 * PostKeyRevocationActionType of the instance.
 */
export type InstancePropertiesPostKeyRevocationActionType = (typeof InstancePropertiesPostKeyRevocationActionType)[keyof typeof InstancePropertiesPostKeyRevocationActionType];

export const InstancePropertiesPrivateIpv6GoogleAccess = {
    EnableBidirectionalAccessToGoogle: "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE",
    EnableOutboundVmAccessToGoogle: "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE",
    InheritFromSubnetwork: "INHERIT_FROM_SUBNETWORK",
} as const;

/**
 * The private IPv6 google access type for VMs. If not specified, use  INHERIT_FROM_SUBNETWORK as default.
 */
export type InstancePropertiesPrivateIpv6GoogleAccess = (typeof InstancePropertiesPrivateIpv6GoogleAccess)[keyof typeof InstancePropertiesPrivateIpv6GoogleAccess];

export const InstanceStatus = {
    Deprovisioning: "DEPROVISIONING",
    Provisioning: "PROVISIONING",
    Repairing: "REPAIRING",
    Running: "RUNNING",
    Staging: "STAGING",
    Stopped: "STOPPED",
    Stopping: "STOPPING",
    Suspended: "SUSPENDED",
    Suspending: "SUSPENDING",
    Terminated: "TERMINATED",
} as const;

/**
 * [Output Only] The status of the instance. One of the following values: PROVISIONING, STAGING, RUNNING, STOPPING, SUSPENDING, SUSPENDED, REPAIRING, and TERMINATED. For more information about the status of the instance, see  Instance life cycle.
 */
export type InstanceStatus = (typeof InstanceStatus)[keyof typeof InstanceStatus];

export const InterconnectAttachmentBandwidth = {
    Bps100m: "BPS_100M",
    Bps10g: "BPS_10G",
    Bps1g: "BPS_1G",
    Bps200m: "BPS_200M",
    Bps20g: "BPS_20G",
    Bps2g: "BPS_2G",
    Bps300m: "BPS_300M",
    Bps400m: "BPS_400M",
    Bps500m: "BPS_500M",
    Bps50g: "BPS_50G",
    Bps50m: "BPS_50M",
    Bps5g: "BPS_5G",
} as const;

/**
 * Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values: 
 * - BPS_50M: 50 Mbit/s 
 * - BPS_100M: 100 Mbit/s 
 * - BPS_200M: 200 Mbit/s 
 * - BPS_300M: 300 Mbit/s 
 * - BPS_400M: 400 Mbit/s 
 * - BPS_500M: 500 Mbit/s 
 * - BPS_1G: 1 Gbit/s 
 * - BPS_2G: 2 Gbit/s 
 * - BPS_5G: 5 Gbit/s 
 * - BPS_10G: 10 Gbit/s 
 * - BPS_20G: 20 Gbit/s 
 * - BPS_50G: 50 Gbit/s
 */
export type InterconnectAttachmentBandwidth = (typeof InterconnectAttachmentBandwidth)[keyof typeof InterconnectAttachmentBandwidth];

export const InterconnectAttachmentEdgeAvailabilityDomain = {
    AvailabilityDomain1: "AVAILABILITY_DOMAIN_1",
    AvailabilityDomain2: "AVAILABILITY_DOMAIN_2",
    AvailabilityDomainAny: "AVAILABILITY_DOMAIN_ANY",
} as const;

/**
 * Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values: 
 * - AVAILABILITY_DOMAIN_ANY 
 * - AVAILABILITY_DOMAIN_1 
 * - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
 */
export type InterconnectAttachmentEdgeAvailabilityDomain = (typeof InterconnectAttachmentEdgeAvailabilityDomain)[keyof typeof InterconnectAttachmentEdgeAvailabilityDomain];

export const InterconnectAttachmentEncryption = {
    Ipsec: "IPSEC",
    None: "NONE",
} as const;

/**
 * Indicates the user-supplied encryption option of this interconnect attachment: 
 * - NONE is the default value, which means that the attachment carries unencrypted traffic. VMs can send traffic to, or receive traffic from, this type of attachment. 
 * - IPSEC indicates that the attachment carries only traffic encrypted by an IPsec device such as an HA VPN gateway. VMs cannot directly send traffic to, or receive traffic from, such an attachment. To use IPsec-encrypted Cloud Interconnect, create the attachment using this option. 
 * Not currently available in all Interconnect locations.
 */
export type InterconnectAttachmentEncryption = (typeof InterconnectAttachmentEncryption)[keyof typeof InterconnectAttachmentEncryption];

export const InterconnectAttachmentOperationalStatus = {
    OsActive: "OS_ACTIVE",
    OsUnprovisioned: "OS_UNPROVISIONED",
} as const;

/**
 * [Output Only] The current status of whether or not this interconnect attachment is functional, which can take one of the following values: 
 * - OS_ACTIVE: The attachment has been turned up and is ready to use. 
 * - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
 */
export type InterconnectAttachmentOperationalStatus = (typeof InterconnectAttachmentOperationalStatus)[keyof typeof InterconnectAttachmentOperationalStatus];

export const InterconnectAttachmentState = {
    Active: "ACTIVE",
    Defunct: "DEFUNCT",
    PartnerRequestReceived: "PARTNER_REQUEST_RECEIVED",
    PendingCustomer: "PENDING_CUSTOMER",
    PendingPartner: "PENDING_PARTNER",
    StateUnspecified: "STATE_UNSPECIFIED",
    Unprovisioned: "UNPROVISIONED",
} as const;

/**
 * [Output Only] The current state of this attachment's functionality. Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state can take one of the following values: 
 * - ACTIVE: The attachment has been turned up and is ready to use. 
 * - UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete. 
 * - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet been configured on the Partner side. 
 * - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it. 
 * - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is waiting for a customer to activate it. 
 * - DEFUNCT: The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was removed, or because the other side of a Partner attachment was deleted.
 */
export type InterconnectAttachmentState = (typeof InterconnectAttachmentState)[keyof typeof InterconnectAttachmentState];

export const InterconnectAttachmentType = {
    Dedicated: "DEDICATED",
    Partner: "PARTNER",
    PartnerProvider: "PARTNER_PROVIDER",
} as const;

/**
 * The type of interconnect attachment this is, which can take one of the following values: 
 * - DEDICATED: an attachment to a Dedicated Interconnect. 
 * - PARTNER: an attachment to a Partner Interconnect, created by the customer. 
 * - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner.
 */
export type InterconnectAttachmentType = (typeof InterconnectAttachmentType)[keyof typeof InterconnectAttachmentType];

export const InterconnectInterconnectType = {
    Dedicated: "DEDICATED",
    ItPrivate: "IT_PRIVATE",
    Partner: "PARTNER",
} as const;

/**
 * Type of interconnect, which can take one of the following values: 
 * - PARTNER: A partner-managed interconnection shared between customers though a partner. 
 * - DEDICATED: A dedicated physical interconnection with the customer. Note that a value IT_PRIVATE has been deprecated in favor of DEDICATED.
 */
export type InterconnectInterconnectType = (typeof InterconnectInterconnectType)[keyof typeof InterconnectInterconnectType];

export const InterconnectLinkType = {
    LinkTypeEthernet100gLr: "LINK_TYPE_ETHERNET_100G_LR",
    LinkTypeEthernet10gLr: "LINK_TYPE_ETHERNET_10G_LR",
} as const;

/**
 * Type of link requested, which can take one of the following values: 
 * - LINK_TYPE_ETHERNET_10G_LR: A 10G Ethernet with LR optics 
 * - LINK_TYPE_ETHERNET_100G_LR: A 100G Ethernet with LR optics. Note that this field indicates the speed of each of the links in the bundle, not the speed of the entire bundle.
 */
export type InterconnectLinkType = (typeof InterconnectLinkType)[keyof typeof InterconnectLinkType];

export const InterconnectOperationalStatus = {
    OsActive: "OS_ACTIVE",
    OsUnprovisioned: "OS_UNPROVISIONED",
} as const;

/**
 * [Output Only] The current status of this Interconnect's functionality, which can take one of the following values: 
 * - OS_ACTIVE: A valid Interconnect, which is turned up and is ready to use. Attachments may be provisioned on this Interconnect. 
 * - OS_UNPROVISIONED: An Interconnect that has not completed turnup. No attachments may be provisioned on this Interconnect. 
 * - OS_UNDER_MAINTENANCE: An Interconnect that is undergoing internal maintenance. No attachments may be provisioned or updated on this Interconnect.
 */
export type InterconnectOperationalStatus = (typeof InterconnectOperationalStatus)[keyof typeof InterconnectOperationalStatus];

export const InterconnectOutageNotificationIssueType = {
    ItOutage: "IT_OUTAGE",
    ItPartialOutage: "IT_PARTIAL_OUTAGE",
    Outage: "OUTAGE",
    PartialOutage: "PARTIAL_OUTAGE",
} as const;

/**
 * Form this outage is expected to take, which can take one of the following values: 
 * - OUTAGE: The Interconnect may be completely out of service for some or all of the specified window. 
 * - PARTIAL_OUTAGE: Some circuits comprising the Interconnect as a whole should remain up, but with reduced bandwidth. Note that the versions of this enum prefixed with "IT_" have been deprecated in favor of the unprefixed values.
 */
export type InterconnectOutageNotificationIssueType = (typeof InterconnectOutageNotificationIssueType)[keyof typeof InterconnectOutageNotificationIssueType];

export const InterconnectOutageNotificationSource = {
    Google: "GOOGLE",
    NsrcGoogle: "NSRC_GOOGLE",
} as const;

/**
 * The party that generated this notification, which can take the following value: 
 * - GOOGLE: this notification as generated by Google. Note that the value of NSRC_GOOGLE has been deprecated in favor of GOOGLE.
 */
export type InterconnectOutageNotificationSource = (typeof InterconnectOutageNotificationSource)[keyof typeof InterconnectOutageNotificationSource];

export const InterconnectOutageNotificationState = {
    Active: "ACTIVE",
    Cancelled: "CANCELLED",
    Completed: "COMPLETED",
    NsActive: "NS_ACTIVE",
    NsCanceled: "NS_CANCELED",
} as const;

/**
 * State of this notification, which can take one of the following values: 
 * - ACTIVE: This outage notification is active. The event could be in the past, present, or future. See start_time and end_time for scheduling. 
 * - CANCELLED: The outage associated with this notification was cancelled before the outage was due to start. Note that the versions of this enum prefixed with "NS_" have been deprecated in favor of the unprefixed values.
 */
export type InterconnectOutageNotificationState = (typeof InterconnectOutageNotificationState)[keyof typeof InterconnectOutageNotificationState];

export const InterconnectState = {
    Active: "ACTIVE",
    Unprovisioned: "UNPROVISIONED",
} as const;

/**
 * [Output Only] The current state of Interconnect functionality, which can take one of the following values: 
 * - ACTIVE: The Interconnect is valid, turned up and ready to use. Attachments may be provisioned on this Interconnect. 
 * - UNPROVISIONED: The Interconnect has not completed turnup. No attachments may be provisioned on this Interconnect. 
 * - UNDER_MAINTENANCE: The Interconnect is undergoing internal maintenance. No attachments may be provisioned or updated on this Interconnect.
 */
export type InterconnectState = (typeof InterconnectState)[keyof typeof InterconnectState];

export const LogConfigCloudAuditOptionsLogName = {
    AdminActivity: "ADMIN_ACTIVITY",
    DataAccess: "DATA_ACCESS",
    UnspecifiedLogName: "UNSPECIFIED_LOG_NAME",
} as const;

/**
 * The log_name to populate in the Cloud Audit Record.
 */
export type LogConfigCloudAuditOptionsLogName = (typeof LogConfigCloudAuditOptionsLogName)[keyof typeof LogConfigCloudAuditOptionsLogName];

export const LogConfigDataAccessOptionsLogMode = {
    LogFailClosed: "LOG_FAIL_CLOSED",
    LogModeUnspecified: "LOG_MODE_UNSPECIFIED",
} as const;

export type LogConfigDataAccessOptionsLogMode = (typeof LogConfigDataAccessOptionsLogMode)[keyof typeof LogConfigDataAccessOptionsLogMode];

export const MetadataFilterFilterMatchCriteria = {
    MatchAll: "MATCH_ALL",
    MatchAny: "MATCH_ANY",
    NotSet: "NOT_SET",
} as const;

/**
 * Specifies how individual filterLabel matches within the list of filterLabels contribute towards the overall metadataFilter match.
 * Supported values are:  
 * - MATCH_ANY: At least one of the filterLabels must have a matching label in the provided metadata. 
 * - MATCH_ALL: All filterLabels must have matching labels in the provided metadata.
 */
export type MetadataFilterFilterMatchCriteria = (typeof MetadataFilterFilterMatchCriteria)[keyof typeof MetadataFilterFilterMatchCriteria];

export const NetworkEndpointGroupNetworkEndpointType = {
    GceVmIp: "GCE_VM_IP",
    GceVmIpPort: "GCE_VM_IP_PORT",
    InternetFqdnPort: "INTERNET_FQDN_PORT",
    InternetIpPort: "INTERNET_IP_PORT",
    NonGcpPrivateIpPort: "NON_GCP_PRIVATE_IP_PORT",
    Serverless: "SERVERLESS",
} as const;

/**
 * Type of network endpoints in this network endpoint group. Can be one of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT, INTERNET_IP_PORT, or SERVERLESS.
 */
export type NetworkEndpointGroupNetworkEndpointType = (typeof NetworkEndpointGroupNetworkEndpointType)[keyof typeof NetworkEndpointGroupNetworkEndpointType];

export const NetworkInterfaceNicType = {
    Gvnic: "GVNIC",
    UnspecifiedNicType: "UNSPECIFIED_NIC_TYPE",
    VirtioNet: "VIRTIO_NET",
} as const;

/**
 * The type of vNIC to be used on this interface. This may be gVNIC or VirtioNet.
 */
export type NetworkInterfaceNicType = (typeof NetworkInterfaceNicType)[keyof typeof NetworkInterfaceNicType];

export const NetworkPeeringState = {
    Active: "ACTIVE",
    Inactive: "INACTIVE",
} as const;

/**
 * [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The peering is `ACTIVE` when there's a matching configuration in the peer network.
 */
export type NetworkPeeringState = (typeof NetworkPeeringState)[keyof typeof NetworkPeeringState];

export const NetworkRoutingConfigRoutingMode = {
    Global: "GLOBAL",
    Regional: "REGIONAL",
} as const;

/**
 * The network-wide routing mode to use. If set to REGIONAL, this network's Cloud Routers will only advertise routes with subnets of this network in the same region as the router. If set to GLOBAL, this network's Cloud Routers will advertise routes with all subnets of this network, across regions.
 */
export type NetworkRoutingConfigRoutingMode = (typeof NetworkRoutingConfigRoutingMode)[keyof typeof NetworkRoutingConfigRoutingMode];

export const NodeGroupAutoscalingPolicyMode = {
    ModeUnspecified: "MODE_UNSPECIFIED",
    Off: "OFF",
    On: "ON",
    OnlyScaleOut: "ONLY_SCALE_OUT",
} as const;

/**
 * The autoscaling mode. Set to one of: ON, OFF, or ONLY_SCALE_OUT. For more information, see  Autoscaler modes.
 */
export type NodeGroupAutoscalingPolicyMode = (typeof NodeGroupAutoscalingPolicyMode)[keyof typeof NodeGroupAutoscalingPolicyMode];

export const NodeGroupMaintenancePolicy = {
    Default: "DEFAULT",
    MaintenancePolicyUnspecified: "MAINTENANCE_POLICY_UNSPECIFIED",
    MigrateWithinNodeGroup: "MIGRATE_WITHIN_NODE_GROUP",
    RestartInPlace: "RESTART_IN_PLACE",
} as const;

/**
 * Specifies how to handle instances when a node in the group undergoes maintenance. Set to one of: DEFAULT, RESTART_IN_PLACE, or MIGRATE_WITHIN_NODE_GROUP. The default value is DEFAULT. For more information, see  Maintenance policies.
 */
export type NodeGroupMaintenancePolicy = (typeof NodeGroupMaintenancePolicy)[keyof typeof NodeGroupMaintenancePolicy];

export const NodeGroupStatus = {
    Creating: "CREATING",
    Deleting: "DELETING",
    Invalid: "INVALID",
    Ready: "READY",
} as const;

export type NodeGroupStatus = (typeof NodeGroupStatus)[keyof typeof NodeGroupStatus];

export const NodeTemplateCpuOvercommitType = {
    CpuOvercommitTypeUnspecified: "CPU_OVERCOMMIT_TYPE_UNSPECIFIED",
    Enabled: "ENABLED",
    None: "NONE",
} as const;

/**
 * CPU overcommit.
 */
export type NodeTemplateCpuOvercommitType = (typeof NodeTemplateCpuOvercommitType)[keyof typeof NodeTemplateCpuOvercommitType];

export const NodeTemplateStatus = {
    Creating: "CREATING",
    Deleting: "DELETING",
    Invalid: "INVALID",
    Ready: "READY",
} as const;

/**
 * [Output Only] The status of the node template. One of the following values: CREATING, READY, and DELETING.
 */
export type NodeTemplateStatus = (typeof NodeTemplateStatus)[keyof typeof NodeTemplateStatus];

export const PacketMirroringEnable = {
    False: "FALSE",
    True: "TRUE",
} as const;

/**
 * Indicates whether or not this packet mirroring takes effect. If set to FALSE, this packet mirroring policy will not be enforced on the network.
 *
 * The default is TRUE.
 */
export type PacketMirroringEnable = (typeof PacketMirroringEnable)[keyof typeof PacketMirroringEnable];

export const PacketMirroringFilterDirection = {
    Both: "BOTH",
    Egress: "EGRESS",
    Ingress: "INGRESS",
} as const;

/**
 * Direction of traffic to mirror, either INGRESS, EGRESS, or BOTH. The default is BOTH.
 */
export type PacketMirroringFilterDirection = (typeof PacketMirroringFilterDirection)[keyof typeof PacketMirroringFilterDirection];

export const PublicAdvertisedPrefixStatus = {
    Initial: "INITIAL",
    PrefixConfigurationComplete: "PREFIX_CONFIGURATION_COMPLETE",
    PrefixConfigurationInProgress: "PREFIX_CONFIGURATION_IN_PROGRESS",
    PrefixRemovalInProgress: "PREFIX_REMOVAL_IN_PROGRESS",
    PtrConfigured: "PTR_CONFIGURED",
    ReverseDnsLookupFailed: "REVERSE_DNS_LOOKUP_FAILED",
    Validated: "VALIDATED",
} as const;

/**
 * The status of the public advertised prefix.
 */
export type PublicAdvertisedPrefixStatus = (typeof PublicAdvertisedPrefixStatus)[keyof typeof PublicAdvertisedPrefixStatus];

export const PublicDelegatedPrefixPublicDelegatedSubPrefixStatus = {
    Active: "ACTIVE",
    Inactive: "INACTIVE",
} as const;

/**
 * [Output Only] The status of the sub public delegated prefix.
 */
export type PublicDelegatedPrefixPublicDelegatedSubPrefixStatus = (typeof PublicDelegatedPrefixPublicDelegatedSubPrefixStatus)[keyof typeof PublicDelegatedPrefixPublicDelegatedSubPrefixStatus];

export const PublicDelegatedPrefixStatus = {
    Announced: "ANNOUNCED",
    Deleting: "DELETING",
    Initializing: "INITIALIZING",
} as const;

/**
 * [Output Only] The status of the public delegated prefix.
 */
export type PublicDelegatedPrefixStatus = (typeof PublicDelegatedPrefixStatus)[keyof typeof PublicDelegatedPrefixStatus];

export const RegionAutoscalerStatus = {
    Active: "ACTIVE",
    Deleting: "DELETING",
    Error: "ERROR",
    Pending: "PENDING",
} as const;

/**
 * [Output Only] The status of the autoscaler configuration. Current set of possible values:  
 * - PENDING: Autoscaler backend hasn't read new/updated configuration. 
 * - DELETING: Configuration is being deleted. 
 * - ACTIVE: Configuration is acknowledged to be effective. Some warnings might be present in the statusDetails field. 
 * - ERROR: Configuration has errors. Actionable for users. Details are present in the statusDetails field.  New values might be added in the future.
 */
export type RegionAutoscalerStatus = (typeof RegionAutoscalerStatus)[keyof typeof RegionAutoscalerStatus];

export const RegionBackendServiceLoadBalancingScheme = {
    External: "EXTERNAL",
    Internal: "INTERNAL",
    InternalManaged: "INTERNAL_MANAGED",
    InternalSelfManaged: "INTERNAL_SELF_MANAGED",
    InvalidLoadBalancingScheme: "INVALID_LOAD_BALANCING_SCHEME",
} as const;

/**
 * Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose  INTERNAL for Internal TCP/UDP Load Balancing. Choose  INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.  INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
 */
export type RegionBackendServiceLoadBalancingScheme = (typeof RegionBackendServiceLoadBalancingScheme)[keyof typeof RegionBackendServiceLoadBalancingScheme];

export const RegionBackendServiceLocalityLbPolicy = {
    InvalidLbPolicy: "INVALID_LB_POLICY",
    LeastRequest: "LEAST_REQUEST",
    Maglev: "MAGLEV",
    OriginalDestination: "ORIGINAL_DESTINATION",
    Random: "RANDOM",
    RingHash: "RING_HASH",
    RoundRobin: "ROUND_ROBIN",
} as const;

/**
 * The load balancing algorithm used within the scope of the locality. The possible values are:  
 * - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default. 
 * - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests. 
 * - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests. 
 * - RANDOM: The load balancer selects a random healthy host. 
 * - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer. 
 * - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824 
 *
 * This field is applicable to either:  
 * - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED. 
 * - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.  
 *
 * If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect.
 *
 * Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
 */
export type RegionBackendServiceLocalityLbPolicy = (typeof RegionBackendServiceLocalityLbPolicy)[keyof typeof RegionBackendServiceLocalityLbPolicy];

export const RegionBackendServiceProtocol = {
    Grpc: "GRPC",
    Http: "HTTP",
    Http2: "HTTP2",
    Https: "HTTPS",
    Ssl: "SSL",
    Tcp: "TCP",
    Udp: "UDP",
} as const;

/**
 * The protocol this BackendService uses to communicate with backends.
 *
 * Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information.
 *
 * Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
 */
export type RegionBackendServiceProtocol = (typeof RegionBackendServiceProtocol)[keyof typeof RegionBackendServiceProtocol];

export const RegionBackendServiceSessionAffinity = {
    ClientIp: "CLIENT_IP",
    ClientIpNoDestination: "CLIENT_IP_NO_DESTINATION",
    ClientIpPortProto: "CLIENT_IP_PORT_PROTO",
    ClientIpProto: "CLIENT_IP_PROTO",
    GeneratedCookie: "GENERATED_COOKIE",
    HeaderField: "HEADER_FIELD",
    HttpCookie: "HTTP_COOKIE",
    None: "NONE",
} as const;

/**
 * Type of session affinity to use. The default is NONE.
 *
 * When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or  CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS.
 *
 * When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
 *
 * When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE.
 *
 * Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
 */
export type RegionBackendServiceSessionAffinity = (typeof RegionBackendServiceSessionAffinity)[keyof typeof RegionBackendServiceSessionAffinity];

export const RegionCommitmentCategory = {
    CategoryUnspecified: "CATEGORY_UNSPECIFIED",
    License: "LICENSE",
    Machine: "MACHINE",
} as const;

/**
 * The category of the commitment. Category MACHINE specifies commitments composed of machine resources such as VCPU or MEMORY, listed in resources. Category LICENSE specifies commitments composed of software licenses, listed in licenseResources. Note that only MACHINE commitments should have a Type specified.
 */
export type RegionCommitmentCategory = (typeof RegionCommitmentCategory)[keyof typeof RegionCommitmentCategory];

export const RegionCommitmentPlan = {
    Invalid: "INVALID",
    ThirtySixMonth: "THIRTY_SIX_MONTH",
    TwelveMonth: "TWELVE_MONTH",
} as const;

/**
 * The plan for this commitment, which determines duration and discount rate. The currently supported plans are TWELVE_MONTH (1 year), and THIRTY_SIX_MONTH (3 years).
 */
export type RegionCommitmentPlan = (typeof RegionCommitmentPlan)[keyof typeof RegionCommitmentPlan];

export const RegionCommitmentStatus = {
    Active: "ACTIVE",
    Creating: "CREATING",
    Expired: "EXPIRED",
    NotYetActive: "NOT_YET_ACTIVE",
} as const;

/**
 * [Output Only] Status of the commitment with regards to eventual expiration (each commitment has an end date defined). One of the following values: NOT_YET_ACTIVE, ACTIVE, EXPIRED.
 */
export type RegionCommitmentStatus = (typeof RegionCommitmentStatus)[keyof typeof RegionCommitmentStatus];

export const RegionDiskStatus = {
    Creating: "CREATING",
    Deleting: "DELETING",
    Failed: "FAILED",
    Ready: "READY",
    Restoring: "RESTORING",
} as const;

/**
 * [Output Only] The status of disk creation.  
 * - CREATING: Disk is provisioning. 
 * - RESTORING: Source data is being copied into the disk. 
 * - FAILED: Disk creation failed. 
 * - READY: Disk is ready for use. 
 * - DELETING: Disk is deleting.
 */
export type RegionDiskStatus = (typeof RegionDiskStatus)[keyof typeof RegionDiskStatus];

export const RegionHealthCheckServiceHealthStatusAggregationPolicy = {
    And: "AND",
    NoAggregation: "NO_AGGREGATION",
} as const;

/**
 * Optional. Policy for how the results from multiple health checks for the same endpoint are aggregated. Defaults to NO_AGGREGATION if unspecified.  
 * - NO_AGGREGATION. An EndpointHealth message is returned for each backend in the health check service. 
 * - AND. If any backend's health check reports UNHEALTHY, then UNHEALTHY is the HealthState of the entire health check service. If all backend's are healthy, the HealthState of the health check service is HEALTHY. .
 */
export type RegionHealthCheckServiceHealthStatusAggregationPolicy = (typeof RegionHealthCheckServiceHealthStatusAggregationPolicy)[keyof typeof RegionHealthCheckServiceHealthStatusAggregationPolicy];

export const RegionHealthCheckType = {
    Grpc: "GRPC",
    Http: "HTTP",
    Http2: "HTTP2",
    Https: "HTTPS",
    Invalid: "INVALID",
    Ssl: "SSL",
    Tcp: "TCP",
} as const;

/**
 * Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS or HTTP2. If not specified, the default is TCP. Exactly one of the protocol-specific health check field must be specified, which must match type field.
 */
export type RegionHealthCheckType = (typeof RegionHealthCheckType)[keyof typeof RegionHealthCheckType];

export const RegionNetworkEndpointGroupNetworkEndpointType = {
    GceVmIp: "GCE_VM_IP",
    GceVmIpPort: "GCE_VM_IP_PORT",
    InternetFqdnPort: "INTERNET_FQDN_PORT",
    InternetIpPort: "INTERNET_IP_PORT",
    NonGcpPrivateIpPort: "NON_GCP_PRIVATE_IP_PORT",
    Serverless: "SERVERLESS",
} as const;

/**
 * Type of network endpoints in this network endpoint group. Can be one of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT, INTERNET_IP_PORT, or SERVERLESS.
 */
export type RegionNetworkEndpointGroupNetworkEndpointType = (typeof RegionNetworkEndpointGroupNetworkEndpointType)[keyof typeof RegionNetworkEndpointGroupNetworkEndpointType];

export const RegionSslCertificateType = {
    Managed: "MANAGED",
    SelfManaged: "SELF_MANAGED",
    TypeUnspecified: "TYPE_UNSPECIFIED",
} as const;

/**
 * (Optional) Specifies the type of SSL certificate, either "SELF_MANAGED" or "MANAGED". If not specified, the certificate is self-managed and the fields certificate and private_key are used.
 */
export type RegionSslCertificateType = (typeof RegionSslCertificateType)[keyof typeof RegionSslCertificateType];

export const RegionTargetHttpsProxyQuicOverride = {
    Disable: "DISABLE",
    Enable: "ENABLE",
    None: "NONE",
} as const;

/**
 * Specifies the QUIC override policy for this TargetHttpsProxy resource. This setting determines whether the load balancer attempts to negotiate QUIC with clients. You can specify NONE, ENABLE, or DISABLE.  
 * - When quic-override is set to NONE, Google manages whether QUIC is used. 
 * - When quic-override is set to ENABLE, the load balancer uses QUIC when possible. 
 * - When quic-override is set to DISABLE, the load balancer doesn't use QUIC. 
 * - If the quic-override flag is not specified, NONE is implied.
 */
export type RegionTargetHttpsProxyQuicOverride = (typeof RegionTargetHttpsProxyQuicOverride)[keyof typeof RegionTargetHttpsProxyQuicOverride];

export const ReservationAffinityConsumeReservationType = {
    AnyReservation: "ANY_RESERVATION",
    NoReservation: "NO_RESERVATION",
    SpecificReservation: "SPECIFIC_RESERVATION",
    Unspecified: "UNSPECIFIED",
} as const;

/**
 * Specifies the type of reservation from which this instance can consume resources: ANY_RESERVATION (default), SPECIFIC_RESERVATION, or NO_RESERVATION. See  Consuming reserved instances for examples.
 */
export type ReservationAffinityConsumeReservationType = (typeof ReservationAffinityConsumeReservationType)[keyof typeof ReservationAffinityConsumeReservationType];

export const ReservationStatus = {
    Creating: "CREATING",
    Deleting: "DELETING",
    Invalid: "INVALID",
    Ready: "READY",
    Updating: "UPDATING",
} as const;

/**
 * [Output Only] The status of the reservation.
 */
export type ReservationStatus = (typeof ReservationStatus)[keyof typeof ReservationStatus];

export const ResourceCommitmentType = {
    Accelerator: "ACCELERATOR",
    LocalSsd: "LOCAL_SSD",
    Memory: "MEMORY",
    Unspecified: "UNSPECIFIED",
    Vcpu: "VCPU",
} as const;

/**
 * Type of resource for which this commitment applies. Possible values are VCPU and MEMORY
 */
export type ResourceCommitmentType = (typeof ResourceCommitmentType)[keyof typeof ResourceCommitmentType];

export const ResourcePolicyGroupPlacementPolicyCollocation = {
    Collocated: "COLLOCATED",
    UnspecifiedCollocation: "UNSPECIFIED_COLLOCATION",
} as const;

/**
 * Specifies network collocation
 */
export type ResourcePolicyGroupPlacementPolicyCollocation = (typeof ResourcePolicyGroupPlacementPolicyCollocation)[keyof typeof ResourcePolicyGroupPlacementPolicyCollocation];

export const ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete = {
    ApplyRetentionPolicy: "APPLY_RETENTION_POLICY",
    KeepAutoSnapshots: "KEEP_AUTO_SNAPSHOTS",
    UnspecifiedOnSourceDiskDelete: "UNSPECIFIED_ON_SOURCE_DISK_DELETE",
} as const;

/**
 * Specifies the behavior to apply to scheduled snapshots when the source disk is deleted.
 */
export type ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete = (typeof ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete)[keyof typeof ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete];

export const ResourcePolicyStatus = {
    Creating: "CREATING",
    Deleting: "DELETING",
    Expired: "EXPIRED",
    Invalid: "INVALID",
    Ready: "READY",
} as const;

/**
 * [Output Only] The status of resource policy creation.
 */
export type ResourcePolicyStatus = (typeof ResourcePolicyStatus)[keyof typeof ResourcePolicyStatus];

export const ResourcePolicyWeeklyCycleDayOfWeekDay = {
    Friday: "FRIDAY",
    Invalid: "INVALID",
    Monday: "MONDAY",
    Saturday: "SATURDAY",
    Sunday: "SUNDAY",
    Thursday: "THURSDAY",
    Tuesday: "TUESDAY",
    Wednesday: "WEDNESDAY",
} as const;

/**
 * Defines a schedule that runs on specific days of the week. Specify one or more days. The following options are available: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
 */
export type ResourcePolicyWeeklyCycleDayOfWeekDay = (typeof ResourcePolicyWeeklyCycleDayOfWeekDay)[keyof typeof ResourcePolicyWeeklyCycleDayOfWeekDay];

export const RouteWarningsItemCode = {
    CleanupFailed: "CLEANUP_FAILED",
    DeprecatedResourceUsed: "DEPRECATED_RESOURCE_USED",
    DeprecatedTypeUsed: "DEPRECATED_TYPE_USED",
    DiskSizeLargerThanImageSize: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE",
    ExperimentalTypeUsed: "EXPERIMENTAL_TYPE_USED",
    ExternalApiWarning: "EXTERNAL_API_WARNING",
    FieldValueOverriden: "FIELD_VALUE_OVERRIDEN",
    InjectedKernelsDeprecated: "INJECTED_KERNELS_DEPRECATED",
    LargeDeploymentWarning: "LARGE_DEPLOYMENT_WARNING",
    MissingTypeDependency: "MISSING_TYPE_DEPENDENCY",
    NextHopAddressNotAssigned: "NEXT_HOP_ADDRESS_NOT_ASSIGNED",
    NextHopCannotIpForward: "NEXT_HOP_CANNOT_IP_FORWARD",
    NextHopInstanceNotFound: "NEXT_HOP_INSTANCE_NOT_FOUND",
    NextHopInstanceNotOnNetwork: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK",
    NextHopNotRunning: "NEXT_HOP_NOT_RUNNING",
    NotCriticalError: "NOT_CRITICAL_ERROR",
    NoResultsOnPage: "NO_RESULTS_ON_PAGE",
    PartialSuccess: "PARTIAL_SUCCESS",
    RequiredTosAgreement: "REQUIRED_TOS_AGREEMENT",
    ResourceInUseByOtherResourceWarning: "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING",
    ResourceNotDeleted: "RESOURCE_NOT_DELETED",
    SchemaValidationIgnored: "SCHEMA_VALIDATION_IGNORED",
    SingleInstancePropertyTemplate: "SINGLE_INSTANCE_PROPERTY_TEMPLATE",
    UndeclaredProperties: "UNDECLARED_PROPERTIES",
    Unreachable: "UNREACHABLE",
} as const;

/**
 * [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
 */
export type RouteWarningsItemCode = (typeof RouteWarningsItemCode)[keyof typeof RouteWarningsItemCode];

export const RouterBgpAdvertiseMode = {
    Custom: "CUSTOM",
    Default: "DEFAULT",
} as const;

/**
 * User-specified flag to indicate which mode to use for advertisement. The options are DEFAULT or CUSTOM.
 */
export type RouterBgpAdvertiseMode = (typeof RouterBgpAdvertiseMode)[keyof typeof RouterBgpAdvertiseMode];

export const RouterBgpAdvertisedGroupsItem = {
    AllSubnets: "ALL_SUBNETS",
} as const;

export type RouterBgpAdvertisedGroupsItem = (typeof RouterBgpAdvertisedGroupsItem)[keyof typeof RouterBgpAdvertisedGroupsItem];

export const RouterBgpPeerAdvertiseMode = {
    Custom: "CUSTOM",
    Default: "DEFAULT",
} as const;

/**
 * User-specified flag to indicate which mode to use for advertisement.
 */
export type RouterBgpPeerAdvertiseMode = (typeof RouterBgpPeerAdvertiseMode)[keyof typeof RouterBgpPeerAdvertiseMode];

export const RouterBgpPeerAdvertisedGroupsItem = {
    AllSubnets: "ALL_SUBNETS",
} as const;

export type RouterBgpPeerAdvertisedGroupsItem = (typeof RouterBgpPeerAdvertisedGroupsItem)[keyof typeof RouterBgpPeerAdvertisedGroupsItem];

export const RouterBgpPeerManagementType = {
    ManagedByAttachment: "MANAGED_BY_ATTACHMENT",
    ManagedByUser: "MANAGED_BY_USER",
} as const;

/**
 * [Output Only] The resource that configures and manages this BGP peer. 
 * - MANAGED_BY_USER is the default value and can be managed by you or other users 
 * - MANAGED_BY_ATTACHMENT is a BGP peer that is configured and managed by Cloud Interconnect, specifically by an InterconnectAttachment of type PARTNER. Google automatically creates, updates, and deletes this type of BGP peer when the PARTNER InterconnectAttachment is created, updated, or deleted.
 */
export type RouterBgpPeerManagementType = (typeof RouterBgpPeerManagementType)[keyof typeof RouterBgpPeerManagementType];

export const RouterInterfaceManagementType = {
    ManagedByAttachment: "MANAGED_BY_ATTACHMENT",
    ManagedByUser: "MANAGED_BY_USER",
} as const;

/**
 * [Output Only] The resource that configures and manages this interface. 
 * - MANAGED_BY_USER is the default value and can be managed directly by users. 
 * - MANAGED_BY_ATTACHMENT is an interface that is configured and managed by Cloud Interconnect, specifically, by an InterconnectAttachment of type PARTNER. Google automatically creates, updates, and deletes this type of interface when the PARTNER InterconnectAttachment is created, updated, or deleted.
 */
export type RouterInterfaceManagementType = (typeof RouterInterfaceManagementType)[keyof typeof RouterInterfaceManagementType];

export const RouterNatLogConfigFilter = {
    All: "ALL",
    ErrorsOnly: "ERRORS_ONLY",
    TranslationsOnly: "TRANSLATIONS_ONLY",
} as const;

/**
 * Specify the desired filtering of logs on this NAT. If unspecified, logs are exported for all connections handled by this NAT. This option can take one of the following values: 
 * - ERRORS_ONLY: Export logs only for connection failures. 
 * - TRANSLATIONS_ONLY: Export logs only for successful connections. 
 * - ALL: Export logs for all connections, successful and unsuccessful.
 */
export type RouterNatLogConfigFilter = (typeof RouterNatLogConfigFilter)[keyof typeof RouterNatLogConfigFilter];

export const RouterNatNatIpAllocateOption = {
    AutoOnly: "AUTO_ONLY",
    ManualOnly: "MANUAL_ONLY",
} as const;

/**
 * Specify the NatIpAllocateOption, which can take one of the following values: 
 * - MANUAL_ONLY: Uses only Nat IP addresses provided by customers. When there are not enough specified Nat IPs, the Nat service fails for new VMs. 
 * - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform; customers can't specify any Nat IPs. When choosing AUTO_ONLY, then nat_ip should be empty.
 */
export type RouterNatNatIpAllocateOption = (typeof RouterNatNatIpAllocateOption)[keyof typeof RouterNatNatIpAllocateOption];

export const RouterNatSourceSubnetworkIpRangesToNat = {
    AllSubnetworksAllIpRanges: "ALL_SUBNETWORKS_ALL_IP_RANGES",
    AllSubnetworksAllPrimaryIpRanges: "ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES",
    ListOfSubnetworks: "LIST_OF_SUBNETWORKS",
} as const;

/**
 * Specify the Nat option, which can take one of the following values: 
 * - ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork are allowed to Nat. 
 * - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the primary IP ranges in every Subnetwork are allowed to Nat. 
 * - LIST_OF_SUBNETWORKS: A list of Subnetworks are allowed to Nat (specified in the field subnetwork below) The default is SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note that if this field contains ALL_SUBNETWORKS_ALL_IP_RANGES or ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any other Router.Nat section in any Router for this network in this region.
 */
export type RouterNatSourceSubnetworkIpRangesToNat = (typeof RouterNatSourceSubnetworkIpRangesToNat)[keyof typeof RouterNatSourceSubnetworkIpRangesToNat];

export const RouterNatSubnetworkToNatSourceIpRangesToNatItem = {
    AllIpRanges: "ALL_IP_RANGES",
    ListOfSecondaryIpRanges: "LIST_OF_SECONDARY_IP_RANGES",
    PrimaryIpRange: "PRIMARY_IP_RANGE",
} as const;

export type RouterNatSubnetworkToNatSourceIpRangesToNatItem = (typeof RouterNatSubnetworkToNatSourceIpRangesToNatItem)[keyof typeof RouterNatSubnetworkToNatSourceIpRangesToNatItem];

export const RuleAction = {
    Allow: "ALLOW",
    AllowWithLog: "ALLOW_WITH_LOG",
    Deny: "DENY",
    DenyWithLog: "DENY_WITH_LOG",
    Log: "LOG",
    NoAction: "NO_ACTION",
} as const;

/**
 * Required
 */
export type RuleAction = (typeof RuleAction)[keyof typeof RuleAction];

export const SSLHealthCheckPortSpecification = {
    UseFixedPort: "USE_FIXED_PORT",
    UseNamedPort: "USE_NAMED_PORT",
    UseServingPort: "USE_SERVING_PORT",
} as const;

/**
 * Specifies how port is selected for health checking, can be one of following values:
 * USE_FIXED_PORT: The port number in port is used for health checking.
 * USE_NAMED_PORT: The portName is used for health checking.
 * USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
 *
 *
 * If not specified, SSL health check follows behavior specified in port and portName fields.
 */
export type SSLHealthCheckPortSpecification = (typeof SSLHealthCheckPortSpecification)[keyof typeof SSLHealthCheckPortSpecification];

export const SSLHealthCheckProxyHeader = {
    None: "NONE",
    ProxyV1: "PROXY_V1",
} as const;

/**
 * Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
 */
export type SSLHealthCheckProxyHeader = (typeof SSLHealthCheckProxyHeader)[keyof typeof SSLHealthCheckProxyHeader];

export const SchedulingNodeAffinityOperator = {
    In: "IN",
    NotIn: "NOT_IN",
    OperatorUnspecified: "OPERATOR_UNSPECIFIED",
} as const;

/**
 * Defines the operation of node selection. Valid operators are IN for affinity and NOT_IN for anti-affinity.
 */
export type SchedulingNodeAffinityOperator = (typeof SchedulingNodeAffinityOperator)[keyof typeof SchedulingNodeAffinityOperator];

export const SchedulingOnHostMaintenance = {
    Migrate: "MIGRATE",
    Terminate: "TERMINATE",
} as const;

/**
 * Defines the maintenance behavior for this instance. For standard instances, the default behavior is MIGRATE. For preemptible instances, the default and only possible behavior is TERMINATE. For more information, see Setting Instance Scheduling Options.
 */
export type SchedulingOnHostMaintenance = (typeof SchedulingOnHostMaintenance)[keyof typeof SchedulingOnHostMaintenance];

export const SecurityPolicyRuleMatcherVersionedExpr = {
    SrcIpsV1: "SRC_IPS_V1",
} as const;

/**
 * Preconfigured versioned expression. If this field is specified, config must also be specified. Available preconfigured expressions along with their requirements are: SRC_IPS_V1 - must specify the corresponding src_ip_range field in config.
 */
export type SecurityPolicyRuleMatcherVersionedExpr = (typeof SecurityPolicyRuleMatcherVersionedExpr)[keyof typeof SecurityPolicyRuleMatcherVersionedExpr];

export const ServerBindingType = {
    RestartNodeOnAnyServer: "RESTART_NODE_ON_ANY_SERVER",
    RestartNodeOnMinimalServers: "RESTART_NODE_ON_MINIMAL_SERVERS",
    ServerBindingTypeUnspecified: "SERVER_BINDING_TYPE_UNSPECIFIED",
} as const;

export type ServerBindingType = (typeof ServerBindingType)[keyof typeof ServerBindingType];

export const SslCertificateManagedSslCertificateStatus = {
    Active: "ACTIVE",
    ManagedCertificateStatusUnspecified: "MANAGED_CERTIFICATE_STATUS_UNSPECIFIED",
    Provisioning: "PROVISIONING",
    ProvisioningFailed: "PROVISIONING_FAILED",
    ProvisioningFailedPermanently: "PROVISIONING_FAILED_PERMANENTLY",
    RenewalFailed: "RENEWAL_FAILED",
} as const;

/**
 * [Output only] Status of the managed certificate resource.
 */
export type SslCertificateManagedSslCertificateStatus = (typeof SslCertificateManagedSslCertificateStatus)[keyof typeof SslCertificateManagedSslCertificateStatus];

export const SslCertificateType = {
    Managed: "MANAGED",
    SelfManaged: "SELF_MANAGED",
    TypeUnspecified: "TYPE_UNSPECIFIED",
} as const;

/**
 * (Optional) Specifies the type of SSL certificate, either "SELF_MANAGED" or "MANAGED". If not specified, the certificate is self-managed and the fields certificate and private_key are used.
 */
export type SslCertificateType = (typeof SslCertificateType)[keyof typeof SslCertificateType];

export const SslPolicyMinTlsVersion = {
    Tls10: "TLS_1_0",
    Tls11: "TLS_1_1",
    Tls12: "TLS_1_2",
} as const;

/**
 * The minimum version of SSL protocol that can be used by the clients to establish a connection with the load balancer. This can be one of TLS_1_0, TLS_1_1, TLS_1_2.
 */
export type SslPolicyMinTlsVersion = (typeof SslPolicyMinTlsVersion)[keyof typeof SslPolicyMinTlsVersion];

export const SslPolicyProfile = {
    Compatible: "COMPATIBLE",
    Custom: "CUSTOM",
    Modern: "MODERN",
    Restricted: "RESTRICTED",
} as const;

/**
 * Profile specifies the set of SSL features that can be used by the load balancer when negotiating SSL with clients. This can be one of COMPATIBLE, MODERN, RESTRICTED, or CUSTOM. If using CUSTOM, the set of SSL features to enable must be specified in the customFeatures field.
 */
export type SslPolicyProfile = (typeof SslPolicyProfile)[keyof typeof SslPolicyProfile];

export const SslPolicyWarningsItemCode = {
    CleanupFailed: "CLEANUP_FAILED",
    DeprecatedResourceUsed: "DEPRECATED_RESOURCE_USED",
    DeprecatedTypeUsed: "DEPRECATED_TYPE_USED",
    DiskSizeLargerThanImageSize: "DISK_SIZE_LARGER_THAN_IMAGE_SIZE",
    ExperimentalTypeUsed: "EXPERIMENTAL_TYPE_USED",
    ExternalApiWarning: "EXTERNAL_API_WARNING",
    FieldValueOverriden: "FIELD_VALUE_OVERRIDEN",
    InjectedKernelsDeprecated: "INJECTED_KERNELS_DEPRECATED",
    LargeDeploymentWarning: "LARGE_DEPLOYMENT_WARNING",
    MissingTypeDependency: "MISSING_TYPE_DEPENDENCY",
    NextHopAddressNotAssigned: "NEXT_HOP_ADDRESS_NOT_ASSIGNED",
    NextHopCannotIpForward: "NEXT_HOP_CANNOT_IP_FORWARD",
    NextHopInstanceNotFound: "NEXT_HOP_INSTANCE_NOT_FOUND",
    NextHopInstanceNotOnNetwork: "NEXT_HOP_INSTANCE_NOT_ON_NETWORK",
    NextHopNotRunning: "NEXT_HOP_NOT_RUNNING",
    NotCriticalError: "NOT_CRITICAL_ERROR",
    NoResultsOnPage: "NO_RESULTS_ON_PAGE",
    PartialSuccess: "PARTIAL_SUCCESS",
    RequiredTosAgreement: "REQUIRED_TOS_AGREEMENT",
    ResourceInUseByOtherResourceWarning: "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING",
    ResourceNotDeleted: "RESOURCE_NOT_DELETED",
    SchemaValidationIgnored: "SCHEMA_VALIDATION_IGNORED",
    SingleInstancePropertyTemplate: "SINGLE_INSTANCE_PROPERTY_TEMPLATE",
    UndeclaredProperties: "UNDECLARED_PROPERTIES",
    Unreachable: "UNREACHABLE",
} as const;

/**
 * [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
 */
export type SslPolicyWarningsItemCode = (typeof SslPolicyWarningsItemCode)[keyof typeof SslPolicyWarningsItemCode];

export const SubnetworkLogConfigAggregationInterval = {
    Interval10Min: "INTERVAL_10_MIN",
    Interval15Min: "INTERVAL_15_MIN",
    Interval1Min: "INTERVAL_1_MIN",
    Interval30Sec: "INTERVAL_30_SEC",
    Interval5Min: "INTERVAL_5_MIN",
    Interval5Sec: "INTERVAL_5_SEC",
} as const;

/**
 * Can only be specified if VPC flow logging for this subnetwork is enabled. Toggles the aggregation interval for collecting flow logs. Increasing the interval time will reduce the amount of generated flow logs for long lasting connections. Default is an interval of 5 seconds per connection.
 */
export type SubnetworkLogConfigAggregationInterval = (typeof SubnetworkLogConfigAggregationInterval)[keyof typeof SubnetworkLogConfigAggregationInterval];

export const SubnetworkLogConfigMetadata = {
    CustomMetadata: "CUSTOM_METADATA",
    ExcludeAllMetadata: "EXCLUDE_ALL_METADATA",
    IncludeAllMetadata: "INCLUDE_ALL_METADATA",
} as const;

/**
 * Can only be specified if VPC flow logs for this subnetwork is enabled. Configures whether all, none or a subset of metadata fields should be added to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
 */
export type SubnetworkLogConfigMetadata = (typeof SubnetworkLogConfigMetadata)[keyof typeof SubnetworkLogConfigMetadata];

export const SubnetworkPrivateIpv6GoogleAccess = {
    DisableGoogleAccess: "DISABLE_GOOGLE_ACCESS",
    EnableBidirectionalAccessToGoogle: "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE",
    EnableOutboundVmAccessToGoogle: "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE",
} as const;

/**
 * The private IPv6 google access type for the VMs in this subnet. This is an expanded field of enablePrivateV6Access. If both fields are set, privateIpv6GoogleAccess will take priority.
 *
 * This field can be both set at resource creation time and updated using patch.
 */
export type SubnetworkPrivateIpv6GoogleAccess = (typeof SubnetworkPrivateIpv6GoogleAccess)[keyof typeof SubnetworkPrivateIpv6GoogleAccess];

export const SubnetworkPurpose = {
    InternalHttpsLoadBalancer: "INTERNAL_HTTPS_LOAD_BALANCER",
    Private: "PRIVATE",
    PrivateRfc1918: "PRIVATE_RFC_1918",
} as const;

/**
 * The purpose of the resource. This field can be either PRIVATE_RFC_1918 or INTERNAL_HTTPS_LOAD_BALANCER. A subnetwork with purpose set to INTERNAL_HTTPS_LOAD_BALANCER is a user-created subnetwork that is reserved for Internal HTTP(S) Load Balancing. If unspecified, the purpose defaults to PRIVATE_RFC_1918. The enableFlowLogs field isn't supported with the purpose field set to INTERNAL_HTTPS_LOAD_BALANCER.
 */
export type SubnetworkPurpose = (typeof SubnetworkPurpose)[keyof typeof SubnetworkPurpose];

export const SubnetworkRole = {
    Active: "ACTIVE",
    Backup: "BACKUP",
} as const;

/**
 * The role of subnetwork. Currently, this field is only used when purpose = INTERNAL_HTTPS_LOAD_BALANCER. The value can be set to ACTIVE or BACKUP. An ACTIVE subnetwork is one that is currently being used for Internal HTTP(S) Load Balancing. A BACKUP subnetwork is one that is ready to be promoted to ACTIVE or is currently draining. This field can be updated with a patch request.
 */
export type SubnetworkRole = (typeof SubnetworkRole)[keyof typeof SubnetworkRole];

export const SubnetworkState = {
    Draining: "DRAINING",
    Ready: "READY",
} as const;

/**
 * [Output Only] The state of the subnetwork, which can be one of the following values: READY: Subnetwork is created and ready to use DRAINING: only applicable to subnetworks that have the purpose set to INTERNAL_HTTPS_LOAD_BALANCER and indicates that connections to the load balancer are being drained. A subnetwork that is draining cannot be used or modified until it reaches a status of READY CREATING: Subnetwork is provisioning DELETING: Subnetwork is being deleted UPDATING: Subnetwork is being updated
 */
export type SubnetworkState = (typeof SubnetworkState)[keyof typeof SubnetworkState];

export const TCPHealthCheckPortSpecification = {
    UseFixedPort: "USE_FIXED_PORT",
    UseNamedPort: "USE_NAMED_PORT",
    UseServingPort: "USE_SERVING_PORT",
} as const;

/**
 * Specifies how port is selected for health checking, can be one of following values:
 * USE_FIXED_PORT: The port number in port is used for health checking.
 * USE_NAMED_PORT: The portName is used for health checking.
 * USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
 *
 *
 * If not specified, TCP health check follows behavior specified in port and portName fields.
 */
export type TCPHealthCheckPortSpecification = (typeof TCPHealthCheckPortSpecification)[keyof typeof TCPHealthCheckPortSpecification];

export const TCPHealthCheckProxyHeader = {
    None: "NONE",
    ProxyV1: "PROXY_V1",
} as const;

/**
 * Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
 */
export type TCPHealthCheckProxyHeader = (typeof TCPHealthCheckProxyHeader)[keyof typeof TCPHealthCheckProxyHeader];

export const TargetHttpsProxyQuicOverride = {
    Disable: "DISABLE",
    Enable: "ENABLE",
    None: "NONE",
} as const;

/**
 * Specifies the QUIC override policy for this TargetHttpsProxy resource. This setting determines whether the load balancer attempts to negotiate QUIC with clients. You can specify NONE, ENABLE, or DISABLE.  
 * - When quic-override is set to NONE, Google manages whether QUIC is used. 
 * - When quic-override is set to ENABLE, the load balancer uses QUIC when possible. 
 * - When quic-override is set to DISABLE, the load balancer doesn't use QUIC. 
 * - If the quic-override flag is not specified, NONE is implied.
 */
export type TargetHttpsProxyQuicOverride = (typeof TargetHttpsProxyQuicOverride)[keyof typeof TargetHttpsProxyQuicOverride];

export const TargetInstanceNatPolicy = {
    NoNat: "NO_NAT",
} as const;

/**
 * NAT option controlling how IPs are NAT'ed to the instance. Currently only NO_NAT (default value) is supported.
 */
export type TargetInstanceNatPolicy = (typeof TargetInstanceNatPolicy)[keyof typeof TargetInstanceNatPolicy];

export const TargetPoolSessionAffinity = {
    ClientIp: "CLIENT_IP",
    ClientIpNoDestination: "CLIENT_IP_NO_DESTINATION",
    ClientIpPortProto: "CLIENT_IP_PORT_PROTO",
    ClientIpProto: "CLIENT_IP_PROTO",
    GeneratedCookie: "GENERATED_COOKIE",
    HeaderField: "HEADER_FIELD",
    HttpCookie: "HTTP_COOKIE",
    None: "NONE",
} as const;

/**
 * Session affinity option, must be one of the following values:
 * NONE: Connections from the same client IP may go to any instance in the pool.
 * CLIENT_IP: Connections from the same client IP will go to the same instance in the pool while that instance remains healthy.
 * CLIENT_IP_PROTO: Connections from the same client IP with the same IP protocol will go to the same instance in the pool while that instance remains healthy.
 */
export type TargetPoolSessionAffinity = (typeof TargetPoolSessionAffinity)[keyof typeof TargetPoolSessionAffinity];

export const TargetSslProxyProxyHeader = {
    None: "NONE",
    ProxyV1: "PROXY_V1",
} as const;

/**
 * Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
 */
export type TargetSslProxyProxyHeader = (typeof TargetSslProxyProxyHeader)[keyof typeof TargetSslProxyProxyHeader];

export const TargetTcpProxyProxyHeader = {
    None: "NONE",
    ProxyV1: "PROXY_V1",
} as const;

/**
 * Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
 */
export type TargetTcpProxyProxyHeader = (typeof TargetTcpProxyProxyHeader)[keyof typeof TargetTcpProxyProxyHeader];

export const TargetVpnGatewayStatus = {
    Creating: "CREATING",
    Deleting: "DELETING",
    Failed: "FAILED",
    Ready: "READY",
} as const;

/**
 * [Output Only] The status of the VPN gateway, which can be one of the following: CREATING, READY, FAILED, or DELETING.
 */
export type TargetVpnGatewayStatus = (typeof TargetVpnGatewayStatus)[keyof typeof TargetVpnGatewayStatus];

export const VpnTunnelStatus = {
    AllocatingResources: "ALLOCATING_RESOURCES",
    AuthorizationError: "AUTHORIZATION_ERROR",
    Deprovisioning: "DEPROVISIONING",
    Established: "ESTABLISHED",
    Failed: "FAILED",
    FirstHandshake: "FIRST_HANDSHAKE",
    NegotiationFailure: "NEGOTIATION_FAILURE",
    NetworkError: "NETWORK_ERROR",
    NoIncomingPackets: "NO_INCOMING_PACKETS",
    Provisioning: "PROVISIONING",
    Rejected: "REJECTED",
    Stopped: "STOPPED",
    WaitingForFullConfig: "WAITING_FOR_FULL_CONFIG",
} as const;

/**
 * [Output Only] The status of the VPN tunnel, which can be one of the following: 
 * - PROVISIONING: Resource is being allocated for the VPN tunnel. 
 * - WAITING_FOR_FULL_CONFIG: Waiting to receive all VPN-related configs from the user. Network, TargetVpnGateway, VpnTunnel, ForwardingRule, and Route resources are needed to setup the VPN tunnel. 
 * - FIRST_HANDSHAKE: Successful first handshake with the peer VPN. 
 * - ESTABLISHED: Secure session is successfully established with the peer VPN. 
 * - NETWORK_ERROR: Deprecated, replaced by NO_INCOMING_PACKETS 
 * - AUTHORIZATION_ERROR: Auth error (for example, bad shared secret). 
 * - NEGOTIATION_FAILURE: Handshake failed. 
 * - DEPROVISIONING: Resources are being deallocated for the VPN tunnel. 
 * - FAILED: Tunnel creation has failed and the tunnel is not ready to be used. 
 * - NO_INCOMING_PACKETS: No incoming packets from peer. 
 * - REJECTED: Tunnel configuration was rejected, can be result of being denied access. 
 * - ALLOCATING_RESOURCES: Cloud VPN is in the process of allocating all required resources. 
 * - STOPPED: Tunnel is stopped due to its Forwarding Rules being deleted for Classic VPN tunnels or the project is in frozen state. 
 * - PEER_IDENTITY_MISMATCH: Peer identity does not match peer IP, probably behind NAT. 
 * - TS_NARROWING_NOT_ALLOWED: Traffic selector narrowing not allowed for an HA-VPN tunnel.
 */
export type VpnTunnelStatus = (typeof VpnTunnelStatus)[keyof typeof VpnTunnelStatus];

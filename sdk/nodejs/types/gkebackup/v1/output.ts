// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../../../types/input";
import * as outputs from "../../../types/output";
import * as enums from "../../../types/enums";
import * as utilities from "../../../utilities";

/**
 * Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
 */
export interface AuditConfigResponse {
    /**
     * The configuration for logging of each type of permission.
     */
    auditLogConfigs: outputs.gkebackup.v1.AuditLogConfigResponse[];
    /**
     * Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
     */
    service: string;
}

/**
 * Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
 */
export interface AuditLogConfigResponse {
    /**
     * Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
     */
    exemptedMembers: string[];
    /**
     * The log type that this config enables.
     */
    logType: string;
}

/**
 * BackupConfig defines the configuration of Backups created via this BackupPlan.
 */
export interface BackupConfigResponse {
    /**
     * If True, include all namespaced resources
     */
    allNamespaces: boolean;
    /**
     * This defines a customer managed encryption key that will be used to encrypt the "config" portion (the Kubernetes resources) of Backups created via this plan. Default (empty): Config backup artifacts will not be encrypted.
     */
    encryptionKey: outputs.gkebackup.v1.EncryptionKeyResponse;
    /**
     * This flag specifies whether Kubernetes Secret resources should be included when they fall into the scope of Backups. Default: False
     */
    includeSecrets: boolean;
    /**
     * This flag specifies whether volume data should be backed up when PVCs are included in the scope of a Backup. Default: False
     */
    includeVolumeData: boolean;
    /**
     * If set, include just the resources referenced by the listed ProtectedApplications.
     */
    selectedApplications: outputs.gkebackup.v1.NamespacedNamesResponse;
    /**
     * If set, include just the resources in the listed namespaces.
     */
    selectedNamespaces: outputs.gkebackup.v1.NamespacesResponse;
}

/**
 * Associates `members`, or principals, with a `role`.
 */
export interface BindingResponse {
    /**
     * The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
     */
    condition: outputs.gkebackup.v1.ExprResponse;
    /**
     * Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. 
     */
    members: string[];
    /**
     * Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
     */
    role: string;
}

/**
 * Information about the GKE cluster from which this Backup was created.
 */
export interface ClusterMetadataResponse {
    /**
     * Anthos version
     */
    anthosVersion: string;
    /**
     * A list of the Backup for GKE CRD versions found in the cluster.
     */
    backupCrdVersions: {[key: string]: string};
    /**
     * The source cluster from which this Backup was created. Valid formats: - `projects/*&#47;locations/*&#47;clusters/*` - `projects/*&#47;zones/*&#47;clusters/*` This is inherited from the parent BackupPlan's cluster field.
     */
    cluster: string;
    /**
     * GKE version
     */
    gkeVersion: string;
    /**
     * The Kubernetes server version of the source cluster.
     */
    k8sVersion: string;
}

/**
 * Identifies the cluster-scoped resources to restore from the Backup.
 */
export interface ClusterResourceRestoreScopeResponse {
    /**
     * A list of "types" of cluster-scoped resources to be restored from the Backup. An empty list means that NO cluster-scoped resources will be restored. Note that Namespaces and PersistentVolume restoration is handled separately and is not governed by this field.
     */
    selectedGroupKinds: outputs.gkebackup.v1.GroupKindResponse[];
}

/**
 * Defined a customer managed encryption key that will be used to encrypt Backup artifacts.
 */
export interface EncryptionKeyResponse {
    /**
     * Google Cloud KMS encryption key. Format: `projects/*&#47;locations/*&#47;keyRings/*&#47;cryptoKeys/*`
     */
    gcpKmsEncryptionKey: string;
}

/**
 * Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
 */
export interface ExprResponse {
    /**
     * Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
     */
    description: string;
    /**
     * Textual representation of an expression in Common Expression Language syntax.
     */
    expression: string;
    /**
     * Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
     */
    location: string;
    /**
     * Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
     */
    title: string;
}

/**
 * This is a direct map to the Kubernetes GroupKind type [GroupKind](https://godoc.org/k8s.io/apimachinery/pkg/runtime/schema#GroupKind) and is used for identifying specific "types" of resources to restore.
 */
export interface GroupKindResponse {
    /**
     * API group string of a Kubernetes resource, e.g. "apiextensions.k8s.io", "storage.k8s.io", etc. Note: use empty string for core API group
     */
    resourceGroup: string;
    /**
     * Kind of a Kubernetes resource, e.g. "CustomResourceDefinition", "StorageClass", etc.
     */
    resourceKind: string;
}

/**
 * A reference to a namespaced resource in Kubernetes.
 */
export interface NamespacedNameResponse {
    /**
     * The name of the Kubernetes resource.
     */
    name: string;
    /**
     * The Namespace of the Kubernetes resource.
     */
    namespace: string;
}

/**
 * A list of namespaced Kubernetes resources.
 */
export interface NamespacedNamesResponse {
    /**
     * A list of namespaced Kubernetes resources.
     */
    namespacedNames: outputs.gkebackup.v1.NamespacedNameResponse[];
}

/**
 * A list of Kubernetes Namespaces
 */
export interface NamespacesResponse {
    /**
     * A list of Kubernetes Namespaces
     */
    namespaces: string[];
}

/**
 * Configuration of a restore. Next id: 9
 */
export interface RestoreConfigResponse {
    /**
     * Restore all namespaced resources in the Backup if set to "True". Specifying this field to "False" is an error.
     */
    allNamespaces: boolean;
    /**
     * Defines the behavior for handling the situation where cluster-scoped resources being restored already exist in the target cluster. This MUST be set to a value other than CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED if cluster_resource_restore_scope is not empty.
     */
    clusterResourceConflictPolicy: string;
    /**
     * Identifies the cluster-scoped resources to restore from the Backup. Not specifying it means NO cluster resource will be restored.
     */
    clusterResourceRestoreScope: outputs.gkebackup.v1.ClusterResourceRestoreScopeResponse;
    /**
     * Defines the behavior for handling the situation where sets of namespaced resources being restored already exist in the target cluster. This MUST be set to a value other than NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED.
     */
    namespacedResourceRestoreMode: string;
    /**
     * A list of selected ProtectedApplications to restore. The listed ProtectedApplications and all the resources to which they refer will be restored.
     */
    selectedApplications: outputs.gkebackup.v1.NamespacedNamesResponse;
    /**
     * A list of selected Namespaces to restore from the Backup. The listed Namespaces and all resources contained in them will be restored.
     */
    selectedNamespaces: outputs.gkebackup.v1.NamespacesResponse;
    /**
     * A list of transformation rules to be applied against Kubernetes resources as they are selected for restoration from a Backup. Rules are executed in order defined - this order matters, as changes made by a rule may impact the filtering logic of subsequent rules. An empty list means no substitution will occur.
     */
    substitutionRules: outputs.gkebackup.v1.SubstitutionRuleResponse[];
    /**
     * Specifies the mechanism to be used to restore volume data. Default: VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED (will be treated as NO_VOLUME_DATA_RESTORATION).
     */
    volumeDataRestorePolicy: string;
}

/**
 * RetentionPolicy defines a Backup retention policy for a BackupPlan.
 */
export interface RetentionPolicyResponse {
    /**
     * Minimum age for Backups created via this BackupPlan (in days). This field MUST be an integer value between 0-90 (inclusive). A Backup created under this BackupPlan will NOT be deletable until it reaches Backup's (create_time + backup_delete_lock_days). Updating this field of a BackupPlan does NOT affect existing Backups under it. Backups created AFTER a successful update will inherit the new value. Default: 0 (no delete blocking)
     */
    backupDeleteLockDays: number;
    /**
     * The default maximum age of a Backup created via this BackupPlan. This field MUST be an integer value >= 0 and <= 365. If specified, a Backup created under this BackupPlan will be automatically deleted after its age reaches (create_time + backup_retain_days). If not specified, Backups created under this BackupPlan will NOT be subject to automatic deletion. Updating this field does NOT affect existing Backups under it. Backups created AFTER a successful update will automatically pick up the new value. NOTE: backup_retain_days must be >= backup_delete_lock_days. If cron_schedule is defined, then this must be <= 360 * the creation interval. Default: 0 (no automatic deletion)
     */
    backupRetainDays: number;
    /**
     * This flag denotes whether the retention policy of this BackupPlan is locked. If set to True, no further update is allowed on this policy, including the `locked` field itself. Default: False
     */
    locked: boolean;
}

/**
 * Schedule defines scheduling parameters for automatically creating Backups via this BackupPlan.
 */
export interface ScheduleResponse {
    /**
     * A standard [cron](https://wikipedia.com/wiki/cron) string that defines a repeating schedule for creating Backups via this BackupPlan. If this is defined, then backup_retain_days must also be defined. Default (empty): no automatic backup creation will occur.
     */
    cronSchedule: string;
    /**
     * This flag denotes whether automatic Backup creation is paused for this BackupPlan. Default: False
     */
    paused: boolean;
}

/**
 * A transformation rule to be applied against Kubernetes resources as they are selected for restoration from a Backup. A rule contains both filtering logic (which resources are subject to substitution) and substitution logic.
 */
export interface SubstitutionRuleResponse {
    /**
     * This is the new value to set for any fields that pass the filtering and selection criteria. To remove a value from a Kubernetes resource, either leave this field unspecified, or set it to the empty string ("").
     */
    newValue: string;
    /**
     * (Filtering parameter) This is a [regular expression] (https://en.wikipedia.org/wiki/Regular_expression) that is compared against the fields matched by the target_json_path expression (and must also have passed the previous filters). Substitution will not be performed against fields whose value does not match this expression. If this field is NOT specified, then ALL fields matched by the target_json_path expression will undergo substitution. Note that an empty (e.g., "", rather than unspecified) value for for this field will only match empty fields.
     */
    originalValuePattern: string;
    /**
     * (Filtering parameter) Any resource subject to substitution must belong to one of the listed "types". If this field is not provided, no type filtering will be performed (all resources of all types matching previous filtering parameters will be candidates for substitution).
     */
    targetGroupKinds: outputs.gkebackup.v1.GroupKindResponse[];
    /**
     * This is a [JSONPath] (https://kubernetes.io/docs/reference/kubectl/jsonpath/) expression that matches specific fields of candidate resources and it operates as both a filtering parameter (resources that are not matched with this expression will not be candidates for substitution) as well as a field identifier (identifies exactly which fields out of the candidate resources will be modified).
     */
    targetJsonPath: string;
    /**
     * (Filtering parameter) Any resource subject to substitution must be contained within one of the listed Kubernetes Namespace in the Backup. If this field is not provided, no namespace filtering will be performed (all resources in all Namespaces, including all cluster-scoped resources, will be candidates for substitution). To mix cluster-scoped and namespaced resources in the same rule, use an empty string ("") as one of the target namespaces.
     */
    targetNamespaces: string[];
}

